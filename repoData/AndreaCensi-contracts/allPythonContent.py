__FILENAME__ = custom_conds_in_docstrings
from contracts import contract, new_contract

@new_contract
def my_condition(x):
    return x > 0

@contract(a='list(my_condition)')
def f1(a):
    pass

@contract
def f2(a):
    """
        :type a: list(my_condition)
    """
    pass

@contract
def f3(a):
    """
        You can also enclose the contract with RST code spec 
        if it creates problems.
        :type a: ``list(my_condition)``
    """
    pass

#f1([1,0])
#f2([1,0])
f3([1,0])

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# procgraph documentation build configuration file, created by
# sphinx-quickstart on Tue Jul 27 15:21:25 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.append(os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc',
              'sphinx.ext.todo', 'sphinx.ext.coverage',
              'sphinx.ext.pngmath', 'sphinx.ext.ifconfig',
              'sphinx.ext.viewcode', 'sphinx.ext.intersphinx',
              'sphinxtogithub',
              # 'numpydoc'
              ]

intersphinx_mapping = {'http://docs.python.org/': None,
    'http://matplotlib.sourceforge.net/': None,
    'http://docs.scipy.org/doc/numpy/': None}
    
# Add any paths that contain templates here, relative to this directory.
templates_path = ['my_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'PyContracts'
copyright = u'2010, Andrea Censi'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.

try: 
    import contracts

    version = contracts.__version__
    # The full version, including alpha/beta/rc tags.
    release = contracts.__version__
except:
    print('---- Warning: could not get version info; is PyContracts installed?')
    version = 'unknown'
    release = 'unknown'
    
# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
# pygments_style = 'sphinx'
pygments_style = 'friendly'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'default'
# html_theme = 'haiku'
# html_theme = 'nature'
 
# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['my_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'contractsdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'contracts.tex', u'PyContracts Documentation',
   u'Andrea Censi', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'contracts', u'PyContracts Documentation',
     [u'Andrea Censi'], 1)
]

########NEW FILE########
__FILENAME__ = class_contracts

# This is an example where the contract depends on the object

from contracts import new_contract, contract

class Game(object):

    def __init__(self, legal_moves):
        self.legal_moves = legal_moves

    # you can now create a contract from object methods
    @new_contract
    def legal_move(self, move):
        if not move in self.legal_moves:
            raise ValueError('Move %r is not valid at this point.' % move)

    @contract(move='legal_move')
    def take_turn(self, move):
        pass
        
        
game = Game(legal_moves=[1,2,3])
game.take_turn(1) # ok
game.take_turn(5) # raises exception

########NEW FILE########
__FILENAME__ = meta
from contracts import ContractsMeta, contract
from abc import abstractmethod

class TimerInterface():
    __metaclass__ = ContractsMeta

    @abstractmethod
    @contract(interval='(float|int),>=0')
    def start(self, interval):
        pass


class Timer(TimerInterface):
    
    def start(self, interval):
        time.sleep()


t = Timer()
t.start(-1) # raises ContractNotRespected

# contracts.interface.ContractNotRespected: Breach for argument 'interval' to Timer:start().
# Condition -1 >= 0 not respected
# checking: >=0               for value: Instance of int: -1
# checking: (float|int),>=0   for value: Instance of int: -1
########NEW FILE########
__FILENAME__ = predicate
from contracts import contract, new_contract

new_contract('positive', lambda x: x>0)

@contract(interval='positive')
def timer(interval):
    print('sleep for %s' % interval)


timer(2)
timer(-1)

########NEW FILE########
__FILENAME__ = user_defined
from contracts import contract, new_contract

class Foo(object):
    pass

new_contract('foo', Foo)

@contract(foo_list='list[>1](foo)')
def foo_list_func(foo_list):
    pass
    
# OK
foo_list_func([Foo(), Foo()])

# raises ContractNotRespected
foo_list_func([Foo(), 42])
########NEW FILE########
__FILENAME__ = sphinxtogithub
#! /usr/bin/env python
 
from optparse import OptionParser
import os
import sys
import shutil


class NoDirectoriesError(Exception):
    "Error thrown when no directories starting with an underscore are found"

class DirHelper(object):

    def __init__(self, is_dir, list_dir, walk, rmtree):

        self.is_dir = is_dir
        self.list_dir = list_dir
        self.walk = walk
        self.rmtree = rmtree

class FileSystemHelper(object):

    def __init__(self, open_, path_join, move, exists):

        self.open_ = open_
        self.path_join = path_join
        self.move = move
        self.exists = exists

class Replacer(object):
    "Encapsulates a simple text replace"

    def __init__(self, from_, to):

        self.from_ = from_
        self.to = to

    def process(self, text):
        print 'from: %r' % self.from_
        print 'to: %r' % self.to
        return text.replace( self.from_, self.to )

class FileHandler(object):
    "Applies a series of replacements the contents of a file inplace"

    def __init__(self, name, replacers, opener):

        self.name = name
        self.replacers = replacers
        self.opener = opener

    def process(self):

        text = self.opener(self.name).read()

        for replacer in self.replacers:
            text = replacer.process( text )

        self.opener(self.name, "w").write(text)

class Remover(object):

    def __init__(self, exists, remove):
        self.exists = exists
        self.remove = remove

    def __call__(self, name):

        if self.exists(name):
            self.remove(name)

class ForceRename(object):

    def __init__(self, renamer, remove):

        self.renamer = renamer
        self.remove = remove

    def __call__(self, from_, to):

        self.remove(to)
        self.renamer(from_, to)

class VerboseRename(object):

    def __init__(self, renamer, stream):

        self.renamer = renamer
        self.stream = stream

    def __call__(self, from_, to):

        self.stream.write(
                "Renaming directory '%s' -> '%s'\n"
                    % (os.path.basename(from_), os.path.basename(to))
                )

        self.renamer(from_, to)


class DirectoryHandler(object):
    "Encapsulates renaming a directory by removing its first character"

    def __init__(self, name, root, renamer):

        self.name = name
        self.new_name = name[1:]
        self.root = root + os.sep
        self.renamer = renamer

    def path(self):
        
        return os.path.join(self.root, self.name)

    def relative_path(self, directory, filename):

        path = directory.replace(self.root, "", 1)
        return os.path.join(path, filename)

    def new_relative_path(self, directory, filename):

        path = self.relative_path(directory, filename)
        return path.replace(self.name, self.new_name, 1)

    def process(self):

        from_ = os.path.join(self.root, self.name)
        to = os.path.join(self.root, self.new_name)
        self.renamer(from_, to)


class HandlerFactory(object):

    def create_file_handler(self, name, replacers, opener):

        return FileHandler(name, replacers, opener)

    def create_dir_handler(self, name, root, renamer):

        return DirectoryHandler(name, root, renamer)


class OperationsFactory(object):

    def create_force_rename(self, renamer, remover):

        return ForceRename(renamer, remover)

    def create_verbose_rename(self, renamer, stream):

        return VerboseRename(renamer, stream)

    def create_replacer(self, from_, to):

        return Replacer(from_, to)

    def create_remover(self, exists, remove):

        return Remover(exists, remove)


class Layout(object):
    """
    Applies a set of operations which result in the layout
    of a directory changing
    """

    def __init__(self, directory_handlers, file_handlers):

        self.directory_handlers = directory_handlers
        self.file_handlers = file_handlers

    def process(self):

        for handler in self.file_handlers:
            handler.process()

        for handler in self.directory_handlers:
            handler.process()


class LayoutFactory(object):
    "Creates a layout object"

    def __init__(self, operations_factory, handler_factory, file_helper, dir_helper, verbose, stream, force):

        self.operations_factory = operations_factory
        self.handler_factory = handler_factory

        self.file_helper = file_helper
        self.dir_helper = dir_helper

        self.verbose = verbose
        self.output_stream = stream
        self.force = force

    def create_layout(self, path):
        path = str(path)

        contents = self.dir_helper.list_dir(path)

        renamer = self.file_helper.move

        if self.force:
            remove = self.operations_factory.create_remover(self.file_helper.exists, self.dir_helper.rmtree)
            renamer = self.operations_factory.create_force_rename(renamer, remove) 

        if self.verbose:
            renamer = self.operations_factory.create_verbose_rename(renamer, self.output_stream) 

        # Build list of directories to process
        directories = [d for d in contents if self.is_underscore_dir(path, d)]
        underscore_directories = [
                self.handler_factory.create_dir_handler(d, path, renamer)
                    for d in directories
                ]

        if not underscore_directories:
            raise NoDirectoriesError()

        # Build list of files that are in those directories
        replacers = []
        for handler in underscore_directories:
            for directory, dirs, files in self.dir_helper.walk(handler.path()):
                for f in files:
                    replacers.append(
                            self.operations_factory.create_replacer(
                                handler.relative_path(directory, f),
                                handler.new_relative_path(directory, f)
                                )
                            )

        # Build list of handlers to process all files
        filelist = []
        for root, dirs, files in self.dir_helper.walk(path):
            for f in files:
                if f.endswith(".html"):
                    filelist.append(
                            self.handler_factory.create_file_handler(
                                self.file_helper.path_join(root, f),
                                replacers,
                                self.file_helper.open_)
                            )
                if f.endswith(".js"):
                    filelist.append(
                            self.handler_factory.create_file_handler(
                                self.file_helper.path_join(root, f),
                                [self.operations_factory.create_replacer("'_sources/'", "'sources/'")],
                                self.file_helper.open_
                                )
                            )

        return Layout(underscore_directories, filelist)

    def is_underscore_dir(self, path, directory):

        return (self.dir_helper.is_dir(self.file_helper.path_join(path, directory))
            and directory.startswith("_"))



def sphinx_extension(app, exception):
    "Wrapped up as a Sphinx Extension"

    # This code is sadly untestable in its current state
    # It would be helped if there was some function for loading extension
    # specific data on to the app object and the app object providing 
    # a file-like object for writing to standard out.
    # The former is doable, but not officially supported (as far as I know)
    # so I wouldn't know where to stash the data. 

    if not app.builder.name in ("html", "dirhtml"):
        return

    if not app.config.sphinx_to_github:
        if app.config.sphinx_to_github_verbose:
            print "Sphinx-to-github: Disabled, doing nothing."
        return

    if exception:
        if app.config.sphinx_to_github_verbose:
            print "Sphinx-to-github: Exception raised in main build, doing nothing."
        return

    dir_helper = DirHelper(
            os.path.isdir,
            os.listdir,
            os.walk,
            shutil.rmtree
            )

    file_helper = FileSystemHelper(
            open,
            os.path.join,
            shutil.move,
            os.path.exists
            )
    
    operations_factory = OperationsFactory()
    handler_factory = HandlerFactory()

    layout_factory = LayoutFactory(
            operations_factory,
            handler_factory,
            file_helper,
            dir_helper,
            app.config.sphinx_to_github_verbose,
            sys.stdout,
            force=True
            )

    layout = layout_factory.create_layout(app.outdir)
    layout.process()


def setup(app):
    "Setup function for Sphinx Extension"

    app.add_config_value("sphinx_to_github", True, '')
    app.add_config_value("sphinx_to_github_verbose", True, '')

    app.connect("build-finished", sphinx_extension)


def main(args):

    usage = "usage: %prog [options] <html directory>"
    parser = OptionParser(usage=usage)
    parser.add_option("-v","--verbose", action="store_true",
            dest="verbose", default=False, help="Provides verbose output")
    opts, args = parser.parse_args(args)

    try:
        path = args[0]
    except IndexError:
        sys.stderr.write(
                "Error - Expecting path to html directory:"
                "sphinx-to-github <path>\n"
                )
        return

    dir_helper = DirHelper(
            os.path.isdir,
            os.listdir,
            os.walk,
            shutil.rmtree
            )

    file_helper = FileSystemHelper(
            open,
            os.path.join,
            shutil.move,
            os.path.exists
            )
    
    operations_factory = OperationsFactory()
    handler_factory = HandlerFactory()

    layout_factory = LayoutFactory(
            operations_factory,
            handler_factory,
            file_helper,
            dir_helper,
            opts.verbose,
            sys.stdout,
            force=False
            )

    try:
        layout = layout_factory.create_layout(path)
    except NoDirectoriesError:
        sys.stderr.write(
                "Error - No top level directories starting with an underscore "
                "were found in '%s'\n" % path
                )
        return

    layout.process()
    


if __name__ == "__main__":
    main(sys.argv[1:])




########NEW FILE########
__FILENAME__ = backported
import sys
from inspect import ArgSpec

if sys.version_info[0] == 3:  # pragma: no cover
    from inspect import getfullargspec  # @UnresolvedImport

else:  # pragma: no cover
    from collections import namedtuple
    FullArgSpec = namedtuple('FullArgSpec', 'args varargs varkw defaults'
                             ' kwonlyargs kwonlydefaults annotations')
    from inspect import getargspec as _getargspec
    
    def getargspec(function):
        # print 'hasattr im_func', hasattr(function, 'im_func')
        if hasattr(function, 'im_func'):
            # print('this is a special function : %s' % function)
            # For methods or classmethods drop the first
            # argument from the returned list because
            # python supplies that automatically for us.
            # Note that this differs from what
            # inspect.getargspec() returns for methods.
            # NB: We use im_func so we work with
            #     instancemethod objects also.
            x = _getargspec(function.im_func)
            new_args = x.args[1:]
            spec = ArgSpec(args=new_args, varargs=x.varargs,
                           keywords=x.keywords, defaults=x.defaults)
            return spec
        
        # print 'calling normal %s' % function
        return _getargspec(function)

    def getfullargspec(function):
        spec = getargspec(function)
        fullspec = FullArgSpec(args=spec.args, varargs=spec.varargs,
                               varkw=spec.keywords,
                               defaults=spec.defaults, kwonlyargs=[],
                               kwonlydefaults=None,
                               annotations={})
        return fullspec


# Backport inspect.getcallargs from Python 2.7 to 2.6
if sys.version_info[:2] == (2, 7):  # pragma: no cover
    from inspect import getcallargs  # @UnresolvedImport @UnusedImport

else:  # pragma: no cover
    inPy3k = sys.version_info[0] == 3

    from inspect import ismethod

    def getcallargs(func, *positional, **named):
        """Get the mapping of arguments to values.
    
        A dict is returned, with keys the function argument names (including the
        names of the * and ** arguments, if any), and values the respective bound
        values from 'positional' and 'named'."""
        args, varargs, varkw, defaults, \
            kwonlyargs, kwonlydefaults, annotations = getfullargspec(func)  # @UnusedVariable

        if kwonlyargs:
            raise ValueError("I'm sorry, I don't have the logic to use kwonlyargs. "
                             "Perhapse you can help PyContracts and implement this? Thanks.")

        f_name = func.__name__
        arg2value = {}

        # The following closures are basically because of tuple parameter unpacking.
        assigned_tuple_params = []
        
        def assign(arg, value):
            if isinstance(arg, str):
                arg2value[arg] = value
            else:
                assigned_tuple_params.append(arg)
                value = iter(value)
                for i, subarg in enumerate(arg):
                    try:
                        subvalue = next(value)
                    except StopIteration:
                        raise ValueError('need more than %d %s to unpack' % 
                                         (i, 'values' if i > 1 else 'value'))
                    assign(subarg, subvalue)
                try:
                    next(value)
                except StopIteration:
                    pass
                else:
                    raise ValueError('too many values to unpack')
        
        def is_assigned(arg):
            if isinstance(arg, str):
                return arg in arg2value
            return arg in assigned_tuple_params

        if not inPy3k:
            im_self = getattr(func, 'im_self', None)
        else:
            im_self = getattr(func, '__self__', None)

        if ismethod(func) and im_self is not None:
            # implicit 'self' (or 'cls' for classmethods) argument
            positional = (im_self,) + positional
        num_pos = len(positional)
        num_total = num_pos + len(named)
        num_args = len(args)
        num_defaults = len(defaults) if defaults else 0
        for arg, value in zip(args, positional):
            assign(arg, value)
        if varargs:
            if num_pos > num_args:
                assign(varargs, positional[-(num_pos - num_args):])
            else:
                assign(varargs, ())
        elif 0 < num_args < num_pos:
            raise TypeError('%s() takes %s %d %s (%d given)' % (
                f_name, 'at most' if defaults else 'exactly', num_args,
                'arguments' if num_args > 1 else 'argument', num_total))
        elif num_args == 0 and num_total:
            raise TypeError('%s() takes no arguments (%d given)' % 
                            (f_name, num_total))
        for arg in args:
            if isinstance(arg, str) and arg in named:
                if is_assigned(arg):
                    raise TypeError("%s() got multiple values for keyword "
                                    "argument '%s'" % (f_name, arg))
                else:
                    assign(arg, named.pop(arg))
        if defaults:  # fill in any missing values with the defaults
            for arg, value in zip(args[-num_defaults:], defaults):
                if not is_assigned(arg):
                    assign(arg, value)
        if varkw:
            assign(varkw, named)
        elif named:
            unexpected = next(iter(named))
            if isinstance(unexpected, unicode):
                unexpected = unexpected.encode(sys.getdefaultencoding(), 'replace')
            raise TypeError("%s() got an unexpected keyword argument '%s'" % 
                            (f_name, unexpected))
        unassigned = num_args - len([arg for arg in args if is_assigned(arg)])
        if unassigned:
            num_required = num_args - num_defaults
            raise TypeError('%s() takes %s %d %s (%d given)' % (
                f_name, 'at least' if defaults else 'exactly', num_required,
                'arguments' if num_required > 1 else 'argument', num_total))
        return arg2value




########NEW FILE########
__FILENAME__ = docstring_parsing
from collections import namedtuple
import re

Arg = namedtuple('Arg', 'name type')


class Arg(object):
    def __init__(self, desc=None, type=None):  # @ReservedAssignment
        if desc is not None:
            desc = desc.strip()
        self.desc = desc
        if type is not None:
            type = type.strip()  # @ReservedAssignment
        self.type = type

    def __eq__(self, other):
        return (self.type == other.type and
                self.desc == other.desc)

    def __repr__(self):
        return "Arg(%r,%r)" % (self.desc, self.type)


class DocStringInfo(object):
    def __init__(self, docstring=None, params=None, returns=None):
        if params is None:
            params = {}
        if returns is None:
            returns = []
        self.docstring = docstring
        self.params = params
        self.returns = returns

    def __eq__(self, other):
        return (self.docstring == other.docstring and
                self.params == other.params and
                self.returns == other.returns)

    def __repr__(self):
        return ("DocString(\n\t%r,\n\t%r,\n\t%r)" %
                (self.docstring, self.params, self.returns))

    def __str__(self):
        s = self.docstring
        valid_lines = [x for x in self.docstring.split('\n') if x]
        if valid_lines:
            last_line = [-1]
            indentation = number_of_spaces(last_line)
        else:
            indentation = 0
        # ORDER?
        s += '\n\n'
        prefix = '\n' + (' ' * indentation)
        for param in self.params:
            if self.params[param].desc is not None:
                s += (prefix + ':param %s: %s'
                      % (param, self.params[param].desc))
            if self.params[param].type is not None:
                s += (prefix + ':type %s:  %s'
                       % (param, self.params[param].type))
            s += prefix

        if self.returns:
            for r in self.returns:
                if r.desc is not None:
                    s += prefix + ':returns: %s' % (r.desc)
                if r.type is not None:
                    s += prefix + ':rtype:  %s' % (r.type)
                s += prefix

        return s

    @staticmethod
    def parse(docstring):
        assert docstring is not None

        param_keys = ['param', 'parameter', 'arg',
                      'argument', 'key', 'keyword']
        type_keys = ['type']
        return_keys = ['returns', 'return']
        rtype_keys = ['rtype']
        # TODO: document state?
        # var_keys = ['var', 'ivar', 'cvar']
        # raises, raise, except, exception

        docstring, params_ann = parse_annotations(docstring, param_keys, False)
        docstring, types_ann = parse_annotations(docstring, type_keys, False)
        docstring, returns_ann = \
            parse_annotations(docstring, return_keys, True)
        docstring, rtype_ann = parse_annotations(docstring, rtype_keys, True)

        params = {}
        names = set(list(params_ann.keys()) + list(types_ann.keys()))
        for name in names:
            params[name] = Arg(params_ann.get(name, None),
                                types_ann.get(name, None))

        returns = []
        for i in range(max(len(returns_ann), len(rtype_ann))):
            returns.append(Arg(returns_ann.get(i, None),
                                rtype_ann.get(i, None)))

        return DocStringInfo(docstring, params=params, returns=returns)


def parse_annotations(docstring, keys, empty=False):
    '''
        Returns docstring_without, dictionary.
        If empty specified, will look for empty statements, and give integers
        for names.
    '''
    assert docstring is not None

    found = {}

    for key in keys:
        if empty:
            regexp = '^\s*:\s*%s\s*:\s*(?P<desc>.*?)\s*$' % key
        else:
            regexp = ('^\s*:\s*%s\s+(?P<name>\w*?)\s*:\s*(?P<desc>.*?)\s*$'
                      % key)
        regexp = re.compile(regexp, re.MULTILINE)

        def replace(match):
            d = match.groupdict()

            if empty:
                name = len(found)
            else:
                name = d['name']

            found[name] = d['desc']

            return ""

        docstring = regexp.sub(repl=replace, string=docstring)

    return docstring, found


def number_of_spaces(x):
    for i in range(1, len(x)):
        if x[:i] != ' ' * i:
            return i - 1
    return len(x)

########NEW FILE########
__FILENAME__ = enabling
from . import logger


class Switches:
    disable_all = False


def disable_all():
    ''' Disables all contracts checks. '''
    Switches.disable_all = True
    logger.info('All contracts checking disabled.')


def enable_all():
    ''' Enables all contracts checks. '''
    Switches.disable_all = False
    logger.info('All contracts checking enabled.')


def all_disabled():
    ''' Returns true if all contracts checks are disabled. '''
    return Switches.disable_all


########NEW FILE########
__FILENAME__ = interface
from .syntax import lineno, col
import sys
from abc import abstractmethod, ABCMeta


class Where(object):
    '''
        An object of this class represents a place in a file.

        All parsed elements contain a reference to a :py:class:`Where` object
        so that we can output pretty error messages.
    '''
    def __init__(self, string,
                 character=None, line=None, column=None):
        self.string = string
        if character is None:
            assert line is not None and column is not None
            self.line = line
            self.col = column
            self.character = None
        else:
            assert line is None and column is None
            self.character = character
            self.line = lineno(character, string)
            self.col = col(character, string)

    def __str__(self):
        s = ''
        context = 3
        lines = self.string.split('\n')
        start = max(0, self.line - context)
        pattern = 'line %2d >'
        for i in range(start, self.line):
            s += ("%s%s\n" % (pattern % (i + 1), lines[i]))
        fill = len(pattern % (i + 1))
        space = ' ' * fill + ' ' * (self.col - 1)
        s += space + '^\n'
        s += space + '|\n'
        s += space + 'here or nearby'
        return  s


def add_prefix(s, prefix):
    result = ""
    for l in s.split('\n'):
        result += prefix + l + '\n'
    # chop last newline
    result = result[:-1]
    return result


class ContractException(Exception):
    ''' The base class for the exceptions thrown by this module. '''
    pass

class MissingContract(ContractException):
    pass

class ContractDefinitionError(ContractException):
    """ Thrown when defining the contracts """

class CannotDecorateClassmethods(ContractDefinitionError):
    pass
    
class ContractSyntaxError(ContractDefinitionError):
    ''' Exception thrown when there is a syntax error in the contracts. '''

    def __init__(self, error, where=None):
        self.error = error
        self.where = where

    def __str__(self):
        s = self.error
        s += "\n\n" + add_prefix(self.where.__str__(), ' ')
        return s


class ContractNotRespected(ContractException):
    ''' Exception thrown when a value does not respect a contract. '''

    def __init__(self, contract, error, value, context):
        # XXX: solves pickling problem in multiprocess problem, but not the
        # real solution
        Exception.__init__(self, contract, error, value, context)
        assert isinstance(contract, Contract), contract
        assert isinstance(context, dict), context
        assert isinstance(error, str), error

        self.contract = contract
        self.error = error
        self.value = value
        self.context = context
        self.stack = []

    def __str__(self):
        msg = str(self.error)
        
        def context_to_string(context):
            try:
                varss = ['- %s: %s' % (k, describe_value(v, clip=70))
                         for k, v in context.items()]
                contexts = "\n".join(varss)
            except:
                contexts = '! cannot write context'
            return contexts

        align = []
        for (contract, context, value) in self.stack:  # @UnusedVariable
            # cons = ("%s %s" % (contract, contexts)).ljust(30)
            row = ['checking: %s' % contract,
                    'for value: %s' % describe_value(value, clip=70)]
            align.append(row)
            
        msg += format_table(align, colspacing=3)
        
        context0 = self.stack[0][1]
        if context0:
            msg += ('\nVariables bound in inner context:\n%s' 
                    % context_to_string(self.stack[0][1]))
            
        return msg


def format_table(rows, colspacing=1):
    sizes = []
    for i in range(len(rows[0])):
        sizes.append(max(len(row[i]) for row in rows))
    s = ''
    for row in rows:
        s += '\n'
        for size, cell in zip(sizes, row):
            s += cell.ljust(size)
            s += ' ' * colspacing
    return s


class RValue(object):
    __metaclass__ = ABCMeta

    @abstractmethod
    def eval(self, context):  # @UnusedVariable @ReservedAssignment
        ''' Can raise ValueError; will be wrapped in ContractNotRespected. '''

    def __eq__(self, other):
        return (self.__class__ == other.__class__ and
                self.__repr__() == other.__repr__())

    @abstractmethod
    def __repr__(self):
        ''' Same constraints as :py:func:`Contract.__repr__()`. '''

    @abstractmethod
    def __str__(self):
        ''' Same constraints as :py:func:`Contract.__str__()`. '''


def eval_in_context(context, value, contract):
    assert isinstance(contract, Contract)
    assert isinstance(value, RValue), describe_value(value)
    try:
        return value.eval(context)
    except ValueError as e:
        msg = 'Error while evaluating RValue %r: %s' % (value, e)
        raise ContractNotRespected(contract, msg, value, context)


class Contract(object):
    __metaclass__ = ABCMeta

    def __init__(self, where):
        assert ((where is None) or
                (isinstance(where, Where), 'Wrong type %s' % where))
        self.where = where
        self.enable()

    def enable(self):
        self._enabled = True

    def disable(self):
        self._enabled = False

    def enabled(self):
        return self._enabled

    def check(self, value):
        '''
            Checks that the value satisfies this contract.

            :raise: ContractNotRespected
        '''
        return self.check_contract({}, value)

    def fail(self, value):
        '''
            Checks that the value **does not** respect this contract.
            Raises an exception if it does.

            :raise: ValueError
        '''
        try:
            context = self.check(value)
        except ContractNotRespected:
            pass
        else:
            msg = ('I did not expect that this value would '
                   'satisfy this contract.\n')
            msg += '-    value: %s\n' % describe_value(value)
            msg += '- contract: %s\n' % self
            msg += '-  context: %r' % context
            raise ValueError(msg)

    @abstractmethod
    def check_contract(self, context, value):  # @UnusedVariable
        ''' 
            Checks that value is ok with this contract in the specific 
            context. This is the function that subclasses must implement.
            
            :param context: The context in which expressions are evaluated.
            :type context: ``class(Contract)``
        '''

    def _check_contract(self, context, value):
        ''' Recursively checks the contracts; it calls check_contract,
            but the error is wrapped recursively. This is the function
            that subclasses must call when checking their sub-contracts. 
        '''
        if not self._enabled:
            return

        variables = context.copy()
        try:
            self.check_contract(context, value)
        except ContractNotRespected as e:
            e.stack.append((self, variables, value))
            raise

    @abstractmethod
    def __repr__(self):
        ''' 
            Returns a string representation of a contract that can be 
            evaluated by Python's :py:func:`eval()`.
            
            It must hold that: ``eval(contract.__repr__()) == contract``.
            This is checked in the unit-tests.

            Example:
            
            >>> from contracts import parse
            >>> contract = parse('list[N]')
            >>> contract.__repr__()
            "List(BindVariable('N',int),None)"
            
            All the symbols you need to eval() the expression are in 
            :py:mod:`contracts.library`.
            
            >>> from contracts.library import *
            >>> contract == eval("%r"%contract)
            True

        '''

    @abstractmethod
    def __str__(self):
        ''' Returns a string representation of a contract that can be 
            reparsed by :py:func:`contracts.parse()`.
            
            It must hold that: ``parse(str(contract)) == contract``.
            This is checked in the unit-tests.
            
            Example:
            
            >>> from contracts import parse
            >>> spec = 'list[N]' 
            >>> contract = parse(spec)
            >>> contract
            List(BindVariable('N',int),None)
            >>> str(contract) == spec
            True
            
            The expressions generated by :py:func:`Contract.__str__` will be
            exactly the same as what was parsed (this is checked in the 
            unittests as well) if and only if the expression is "minimal". 
            If it isn't (there is whitespace or redundant symbols), 
            the returned expression will be an equivalent minimal one.
            
            Example with extra parenthesis and whitespace:
            
            >>> from contracts import parse
            >>> verbose_spec = 'list[((N))]( int, > 0)' 
            >>> contract = parse(verbose_spec)
            >>> str(contract)
            'list[N](int,>0)'
            
            Example that removes extra parentheses around arithmetic operators:
            
            >>> verbose_spec = '=1+(1*2)+(2+4)' 
            >>> str(parse(verbose_spec))
            '=1+1*2+2+4'
            
            This is an example with logical operators precedence. The AND
            operator ``,`` (comma) has more precedence than the OR (``|``).
            
            >>> verbose_spec = '(a|(b,c)),e' 
            >>> str(parse(verbose_spec))
            '(a|b,c),e'
            
            Not that only the outer parenthesis is kept as it is the only one 
            needed.
            
            
        '''

    def __eq__(self, other):
        return (self.__class__ == other.__class__ and
                self.__repr__() == other.__repr__())


inPy2 = sys.version_info[0] == 2
if inPy2:
    from types import ClassType


def clipped_repr(x, clip):
    s = "{0!r}".format(x)
    if len(s) > clip:
        clip_tag = '... [clip]'
        cut = clip - len(clip_tag)
        s = "%s%s" % (s[:cut], clip_tag)
    return s

# TODO: add checks for these functions


def remove_newlines(s):
    return s.replace('\n', ' ')


def describe_type(x):
    ''' Returns a friendly description of the type of x. '''
    if inPy2 and isinstance(x, ClassType):
        class_name = '(old-style class) %s' % x
    else:
        if hasattr(x, '__class__'):
            class_name = '%s' % x.__class__.__name__
        else:
            # for extension classes (spmatrix)
            class_name = str(type(x))

    return class_name


def describe_value(x, clip=50):
    ''' Describes an object, for use in the error messages. '''
    if hasattr(x, 'shape') and hasattr(x, 'dtype'):
        shape_desc = 'x'.join(str(i) for i in x.shape)
        desc = 'array[%r](%s) ' % (shape_desc, x.dtype)
        final = desc + clipped_repr(x, clip - len(desc))
        return remove_newlines(final)
    else:
        class_name = describe_type(x)
        desc = 'Instance of %s: ' % class_name
        final = desc + clipped_repr(x, clip - len(desc))
        return remove_newlines(final)



########NEW FILE########
__FILENAME__ = arithmetic
from functools import reduce

from ..interface import RValue
from ..syntax import isnumber, W


class Binary(RValue):
    operations = {
        '+': lambda x, y: x + y,
        '-': lambda x, y: x - y,
        '*': lambda x, y: x * y
    }

    precedence = {
        '+': 0,
        '-': 0,
        '*': 1,
    }

    def __init__(self, exprs, glyph, where=None):
        assert glyph in  Binary.operations
        for e in exprs:
            assert isinstance(e, RValue)

        self.where = where
        self.exprs = exprs
        self.glyph = glyph
        self.precedence = Binary.precedence[glyph]

    def eval(self, context):  # @ReservedAssignment
        vals = []
        for expr in self.exprs:
            val = expr.eval(context)
            if not isnumber(val):
                raise ValueError('I can only do math with numbers, not %r.' % 
                                 val.__class__.__name__)
            vals.append(val)
        operation = Binary.operations[self.glyph]
        return reduce(operation, vals)

    def __repr__(self):
        s = 'Binary(%r,%r)' % (self.exprs, self.glyph)
        return s

    def __str__(self):
        def convert(x):
            if isinstance(x, Binary) and x.precedence < self.precedence:
                return '(%s)' % x
            else:
                return '%s' % x

        s = self.glyph.join(convert(x) for x in self.exprs)
        return s

    @staticmethod
    def parse_action(s, loc, tokens):
        where = W(s, loc)
        l = list(tokens[0])
        exprs = [l.pop(0)]
        while l:
            glyph = l.pop(0)
            assert isinstance(glyph, str)
            expr = l.pop(0)
            assert isinstance(expr, RValue)
            exprs.append(expr)

        return Binary(exprs, glyph, where=where)


class Unary(RValue):

    operations = {
        '-': lambda x: (-x),
    }

    def __init__(self, glyph, expr, where=None):
        assert glyph in Unary.operations
        assert isinstance(expr, RValue)

        self.where = where
        self.expr = expr
        self.glyph = glyph

    def eval(self, context):  # @ReservedAssignment
        val = self.expr.eval(context)
        if not isnumber(val):
            raise ValueError('I can only do math with numbers, not with %r.' % 
                   val.__class__.__name__)

        operation = Unary.operations[self.glyph]
        return operation(val)

    def __repr__(self):
        s = 'Unary(%r,%r)' % (self.glyph, self.expr)
        return s

    def __str__(self):
        # XXX: precedence
        return '%s%s' % (self.glyph, self.expr)

    @staticmethod
    def parse_action(s, loc, tokens):
        where = W(s, loc)
        glyph = tokens[0][0]
        assert isinstance(glyph, str)
        expr = tokens[0][1]
        assert isinstance(expr, RValue)
        return Unary(glyph, expr, where=where)


########NEW FILE########
__FILENAME__ = array
from ..interface import Contract, ContractNotRespected, describe_type
from ..pyparsing_utils import myOperatorPrecedence
from ..syntax import (add_contract, W, contract_expression, O, S, rvalue,
    simple_contract, ZeroOrMore, Literal, MatchFirst, opAssoc, FollowedBy, NotAny,
    Keyword, add_keyword, Word)
from .array_ops import (ArrayOR, ArrayAnd, DType, ArrayConstraint,
    ArrayORCustomString)
from .compositions import And, OR
from .suggester import create_suggester
from numpy import ndarray, dtype  # @UnusedImport
import numpy


class Array(Contract):

    def __init__(self, shape_contract=None,
                        elements_contract=None, where=None):
        Contract.__init__(self, where)
        self.shape_contract = shape_contract
        self.elements_contract = elements_contract

    def check_contract(self, context, value):
        if not isinstance(value, ndarray):
            error = 'Expected an array, got a %s.' % describe_type(value)
            raise ContractNotRespected(contract=self, error=error,
                                       value=value, context=context)

        if self.shape_contract is not None:
            self.shape_contract._check_contract(context, value.shape)

        if self.elements_contract is not None:
            self.elements_contract._check_contract(context, value)

    def __str__(self):
        s = 'array'
        if self.shape_contract is not None:
            s += '[%s]' % self.shape_contract
        if self.elements_contract is not None:
            s += '(%s)' % self.elements_contract
        return s

    def __repr__(self):
        s = 'Array(%r,%r)' % (self.shape_contract, self.elements_contract)
        return s

    @staticmethod
    def parse_action(s, loc, tokens):
        where = W(s, loc)
        shape_contract = tokens.get('shape_contract', [None])[0]
        elements_contract = tokens.get('elements_contract', [None])[0]

        assert shape_contract is None or isinstance(shape_contract,
                                                    ShapeContract)
        assert elements_contract is None or isinstance(elements_contract,
                                                       Contract)
        return Array(shape_contract, elements_contract, where=where)


class ShapeContract(Contract):
    def __init__(self, dimensions, ellipsis=False, where=None):
        assert isinstance(dimensions, list)
        assert isinstance(ellipsis, bool)
        Contract.__init__(self, where)
        self.dimensions = dimensions
        self.ellipsis = ellipsis

    def check_contract(self, context, value):
        assert isinstance(value, tuple)  # Guaranteed by construction

        expected = len(self.dimensions)
        ndim = len(value)

        if ndim < expected:  # TODO: write clearer message
            error = 'Expected %d dimensions, got %d.' % (expected, ndim)
            raise ContractNotRespected(contract=self, error=error,
                                       value=value, context=context)

        if ndim > expected and not self.ellipsis:
            error = 'Expected %d dimensions, got %d.' % (expected, ndim)
            raise ContractNotRespected(contract=self, error=error,
                                       value=value, context=context)

        for i in range(expected):
            self.dimensions[i]._check_contract(context, value[i])

    def __str__(self):
        be_careful = self.ellipsis or len(self.dimensions) > 1

        def rep(x):
            if be_careful and isinstance(x, (And, OR)):
                return "(%s)" % x
            else:
                return "%s" % x

        s = 'x'.join(rep(x) for x in self.dimensions)
        if self.ellipsis:
            s += 'x...'
        return s

    def __repr__(self):
        if self.ellipsis:
            s = 'ShapeContract(%r,%r)' % (self.dimensions, self.ellipsis)
        else:
            s = 'ShapeContract(%r)' % self.dimensions
        return s

    @staticmethod
    def parse_action(s, loc, tokens):
        where = W(s, loc)
        # print "in tokens: " % tokens
        # workaround for some bugs
        ellipsis = False
        dimensions = []
        for t in tokens:
            if t == '...':
                ellipsis = True
            else:
                assert isinstance(t, Contract), 'Wrong token %r' % t
                dimensions.append(t)
        return ShapeContract(dimensions, ellipsis, where=where)


class Shape(Contract):
    def __init__(self, length, contract, where=None):
        Contract.__init__(self, where)
        self.contract = contract
        self.length = length

    def check_contract(self, context, value):
        if not isinstance(value, ndarray):
            error = 'Expected an array, got %r.' % value.__class__.__name__
            raise ContractNotRespected(contract=self, error=error,
                                       value=value, context=context)

        if isinstance(value, ndarray):
            value = value.shape

        if self.length is not None:
            self.length._check_contract(context, len(value))

        if self.contract is not None:
            self.contract._check_contract(context, value)

    def __str__(self):
        s = 'shape'
        if self.length is not None:
            s += '[%s]' % self.length
        if self.contract is not None:
            s += '(%s)' % self.contract
        return s

    def __repr__(self):
        s = 'Shape(%r,%r)' % (self.length, self.contract)
        return s

    @staticmethod
    def parse_action(s, loc, tokens):
        where = W(s, loc)
        assert 0 <= len(tokens) <= 2
        length = tokens.get('length', [None])[0]
        contract = tokens.get('other', [None])[0]
        return Shape(length, contract, where)


array_constraints = []
for glyph in ArrayConstraint.constraints:
    if glyph == '!=':
        # special case: ! must be followed by =
        glyph_expression = Literal('!') - Literal('=')
        glyph_expression.setName('!=')
    else:
        glyph_expression = Literal(glyph)

    expr = glyph_expression('glyph') - rvalue('rvalue')
    expr.setParseAction(ArrayConstraint.parse_action)
    array_constraints.append(expr)

np_uint_dtypes = "u1 uint8 uint16 uint32 uint64".split()
np_int_dtypes = "i1 int8 int16 int32 int64".split()
np_float_dtypes = "float32 float64".split()
np_other_dtypes = ['bool']  
atomic = np_uint_dtypes + np_int_dtypes + np_float_dtypes + np_other_dtypes

# in numpy, int = int64, float = float64
# for us, int = int64|int32| ...

dtype_checks = []
for x in atomic:
    d = numpy.dtype(x)
    expr = Keyword(x).setParseAction(DType.parse_action(d))
    dtype_checks.append(expr)
    
def np_composite(custom_string, alternatives):
    alts = [DType(numpy.dtype(a), a) for a in alternatives] 
    return ArrayORCustomString(custom_string=custom_string, clauses=alts)
    
def np_uint(s, loc, tokens):  # @UnusedVariable
    return np_composite('uint', np_uint_dtypes)
 
def np_int(s, loc, tokens):  # @UnusedVariable
    return np_composite('int', np_int_dtypes)

def np_float(s, loc, tokens):  # @UnusedVariable
    return np_composite('float', np_float_dtypes)

dtype_checks.append(Keyword('int').setParseAction(np_int))
dtype_checks.append(Keyword('uint').setParseAction(np_uint))
dtype_checks.append(Keyword('float').setParseAction(np_float))

composite = ['int', 'uint', 'float']

ndarray_simple_contract = MatchFirst(dtype_checks + array_constraints)
ndarray_simple_contract.setName('numpy element contract')

suggester = create_suggester(get_options=lambda: atomic + composite)
baseExpr = ndarray_simple_contract | suggester
baseExpr.setName('numpy contract (with recovery)')

ndarray_composite_contract = myOperatorPrecedence(baseExpr, [
    (',', 2, opAssoc.LEFT, ArrayAnd.parse_action),  # @UndefinedVariable
    ('|', 2, opAssoc.LEFT, ArrayOR.parse_action),  # @UndefinedVariable
])


def my_delim_list2(what, delim):
    return (what + ZeroOrMore(S(delim) + FollowedBy(NotAny(ellipsis)) - what))


ellipsis = Literal('...')

shape_suggester = create_suggester(get_options=lambda: ['...'],
                                   pattern=Word('.'))

inside_inside1 = simple_contract | shape_suggester
inside_inside2 = contract_expression | shape_suggester
inside = (S('(') - inside_inside2 - S(')')) | inside_inside1  # XXX: ^ and use or_contract?
shape_contract = my_delim_list2(inside, S('x')) + O(S('x') + ellipsis)
shape_contract.setParseAction(ShapeContract.parse_action)
shape_contract.setName('array shape contract')

name = Keyword('array') | Keyword('ndarray')
optional_shape = (S('[') - shape_contract - S(']'))('shape_contract')
optional_elements = (S('(') - ndarray_composite_contract - S(')'))('elements_contract')
array_contract = name + O(optional_shape) + O(optional_elements)
array_contract.setParseAction(Array.parse_action)
array_contract.setName('array() contract')
add_contract(array_contract)
add_keyword('array')
add_keyword('ndarray')

optional_length = (S('[') - contract_expression - S(']'))('length')
optional_other = (S('(') - contract_expression - S(')'))('other')
shape = Keyword('shape') + O(optional_length) + O(optional_other)
shape.setName('shape() contract')
shape.setParseAction(Shape.parse_action)
add_contract(shape)
add_keyword('shape')





########NEW FILE########
__FILENAME__ = array_ops
from ..interface import Contract, ContractNotRespected, RValue, eval_in_context
from ..syntax import W, Keyword, add_contract, add_keyword
from .types_misc import CheckType
from abc import abstractmethod
import numpy as np



class ArrayElementsTest(Contract):

    @abstractmethod
    def test_elements(self, context, value):
        ''' Returns either a bool or an array of bool. '''

    def check_contract(self, context, value):
        result = self.test_elements(context, value)
        if np.all(result):
            return
        result = np.array(result)  # for simple bool
        resultf = result.flatten()
        valuef = value.flatten()
        some, = np.nonzero(np.logical_not(resultf))
        num = value.size
        num_fail = len(some)
        perc = 100.0 * num_fail / num
        error = ("In this array, %d/%d (%f%%) of elements do not respect "
                 "the condition %s." % (num_fail, num, perc, self))
        some_failures = valuef[some]
        MAX_N = 4
        if len(some_failures) > MAX_N:
            some_failures = some_failures[:MAX_N]
        failures = list(some_failures)
        N = len(failures)
        error += '\nThese are the first %d: %s.' % (N, failures)
        raise ContractNotRespected(self, error, value, context)


class ArrayLogical(ArrayElementsTest):
    def __init__(self, glyph, precedence):
        self.glyph = glyph
        self.precedence = precedence

    def __str__(self):
        def convert(x):
            if isinstance(x, ArrayLogical) and x.precedence < self.precedence:
                return '(%s)' % x
            else:
                return '%s' % x

        s = self.glyph.join(convert(x) for x in self.clauses)
        return s


class ArrayOR(ArrayLogical):
    def __init__(self, clauses, where=None):
        assert isinstance(clauses, list)
        assert len(clauses) >= 2
        for c in clauses:
            assert isinstance(c, ArrayElementsTest)
        Contract.__init__(self, where)
        ArrayLogical.__init__(self, '|', 1)
        self.clauses = clauses

    def test_elements(self, context, value):
        assert isinstance(value, np.ndarray)
        result = False
        for c in self.clauses:
            result_c = c.test_elements(context, value)
            result = np.logical_or(result_c, result)
        return result

    def __repr__(self):
        s = 'ArrayOR(%r)' % self.clauses
        return s

    @staticmethod
    def parse_action(string, location, tokens):
        l = list(tokens[0])
        clauses = [l.pop(0)]
        while l:
            glyph = l.pop(0)  # @UnusedVariable
            assert glyph == '|'
            operand = l.pop(0)
            clauses.append(operand)
        where = W(string, location)
        return ArrayOR(clauses, where=where)

class ArrayORCustomString(ArrayOR):
    def __init__(self, custom_string, **other):
        self.custom_string = custom_string
        ArrayOR.__init__(self, **other)
        
    def __str__(self):
        return self.custom_string


class ArrayAnd(ArrayLogical):
    def __init__(self, clauses, where=None):
        assert isinstance(clauses, list)
        assert len(clauses) >= 2, clauses
        assert isinstance(clauses, list)
        assert len(clauses) >= 2
        for c in clauses:
            assert isinstance(c, ArrayElementsTest)

        Contract.__init__(self, where)
        ArrayLogical.__init__(self, ',', 2)
        self.clauses = clauses

    def test_elements(self, context, value):
        assert isinstance(value, np.ndarray)
        result = True
        for c in self.clauses:
            result_c = c.test_elements(context, value)
            result = np.logical_and(result_c, result)
        return result

    def __repr__(self):
        s = 'ArrayAnd(%r)' % self.clauses
        return s

    @staticmethod
    def parse_action(string, location, tokens):
        l = list(tokens[0])
        clauses = [l.pop(0)]
        while l:
            glyph = l.pop(0)  # @UnusedVariable
            assert glyph == ','
            operand = l.pop(0)
            clauses.append(operand)
        where = W(string, location)
        return ArrayAnd(clauses, where=where)


class ArrayConstraint(ArrayElementsTest):
    ''' Comparisons for numpy array elements. They check that
        the condition is respected for all the entries in the array. '''

    constraints = {
        '=': lambda x, rvalue: x == rvalue,
        '==': lambda x, rvalue: x == rvalue,
        '!=': lambda x, rvalue: x != rvalue,
        '>': lambda x, rvalue: x > rvalue,
        '>=': lambda x, rvalue: x >= rvalue,
        '<': lambda x, rvalue: x < rvalue,
        '<=': lambda x, rvalue: x <= rvalue,
    }

    def __init__(self, glyph, rvalue, where=None):
        assert glyph in ArrayConstraint.constraints
        assert isinstance(rvalue, RValue)
        Contract.__init__(self, where)
        self.glyph = glyph
        self.rvalue = rvalue

    def test_elements(self, context, value):
        ''' Returns either a bool or an array of bool. '''
        assert isinstance(value, np.ndarray)
        bound = eval_in_context(context=context, value=self.rvalue,
                                contract=self)

        operation = ArrayConstraint.constraints[self.glyph]
        result = operation(value, bound)
        return result

    def __str__(self):
        return '%s%s' % (self.glyph, self.rvalue)

    def __repr__(self):
        return 'ArrayConstraint(%r,%r)' % (self.glyph, self.rvalue)

    @staticmethod
    def parse_action(s, loc, tokens):
        where = W(s, loc)
        glyph = "".join(tokens['glyph'])
        rvalue = tokens['rvalue']
        return ArrayConstraint(glyph, rvalue, where)


class DType(ArrayElementsTest):
    ''' Checks that the value is an array with the given dtype. '''
    def __init__(self, dtype, dtype_string=None, where=None):
        assert isinstance(dtype, np.dtype)
        Contract.__init__(self, where)
        self.dtype = dtype
        if dtype_string is None:
            dtype_string = "%s" % dtype
        self.dtype_string = dtype_string

    def test_elements(self, context, value):  # @UnusedVariable
        assert isinstance(value, np.ndarray)  # Guaranteed by construction
        return (value.dtype == self.dtype)

    def __str__(self):
        return self.dtype_string

    def __repr__(self):
        if  "%s" % self.dtype == self.dtype_string:
            return 'DType(%r)' % self.dtype
        else:
            return 'DType(%r,%r)' % (self.dtype, self.dtype_string)

    @staticmethod
    def parse_action(dtype=None):
        assert dtype is None or isinstance(dtype, np.dtype)

        def parse(s, loc, tokens):
            where = W(s, loc)
            dtype_string = tokens[0]
            if dtype is None:
                use_dtype = np.dtype(dtype_string)
            else:
                use_dtype = dtype
            return DType(use_dtype, dtype_string, where)
        return parse


np_types = {
    'np_int': np.int,  # Platform integer (normally either int32 or int64)
    'np_int8': np.int8,  # Byte (-128 to 127)
    'np_int16': np.int16,  # Integer (-32768 to 32767)
    'np_int32': np.int32,  # Integer (-2147483648 to 2147483647)
    'np_int64': np.int64,  # Integer (9223372036854775808 to 9223372036854775807)
    'np_uint8': np.uint8,  # Unsigned integer (0 to 255)
    'np_uint16': np.uint16,  # Unsigned integer (0 to 65535)
    'np_uint32': np.uint32,  # Unsigned integer (0 to 4294967295)
    'np_uint64': np.uint64,  # Unsigned integer (0 to 18446744073709551615)
    'np_float': np.float,  # Shorthand for float64.
    'np_float16': np.float16,  #  Half precision float: sign bit, 5 bits exponent, 10 bits mantissa
    'np_float32': np.float32,  #  Single precision float: sign bit, 8 bits exponent, 23 bits mantissa
    'np_float64': np.float64,  #  Double precision float: sign bit, 11 bits exponent, 52 bits mantissa
    'np_complex': np.complex,  #  Shorthand for complex128.
    'np_complex64': np.complex64,  #    Complex number, represented by two 32-bit floats (real and imaginary components)
    'np_complex128': np.complex128}

for k, t in np_types.items():
    add_contract(Keyword(k).setParseAction(CheckType.parse_action(t)))
    add_keyword(k)





########NEW FILE########
__FILENAME__ = attributes
from ..interface import Contract, ContractNotRespected
from ..syntax import W, contract_expression, add_contract, add_keyword, Keyword
from pyparsing import (Dict, delimitedList, Group, alphanums, Suppress, Literal,
    Word)


class Attr(Contract):
    def __init__(self, attrs, where=None):
        # attrs: dict(str: contract)
        Contract.__init__(self, where)
        if not attrs:
            raise ValueError('Need some attributes') 
        self.attrs = attrs

    def check_contract(self, context, value):
        for k in self.attrs:
            if hasattr(value, k):
                self.attrs[k]._check_contract(context, getattr(value, k))
            else:
                error = 'Expected an attribute %r.' % k
                raise ContractNotRespected(contract=self, error=error,
                                           value=value, context=context)


    def __str__(self):
        sattrs = ";".join(['%s:%s' % (k, v) for (k, v) in self.attrs.items()]) 
        return 'attr(%s)' % sattrs

    def __repr__(self):
        return 'Attr(%r)' % self.attrs

    @staticmethod
    def parse_action(s, loc, tokens):
        where = W(s, loc)
        attrs = tokens.get('attrs', None)
        # Python 3 only
        # attrs = {k: v for k, v in attrs.items()}
        attrs = dict([(k, v) for k, v in attrs.items()])
        return Attr(attrs, where=where)

attr_spec = Dict(
        delimitedList(
            Group(Word(alphanums) + 
                    Suppress(Literal(':')) + 
                    contract_expression('value')),
            delim=';')
        )('attrs')
attrs_spec = ('(' - attr_spec - ')')


attr_contract = Keyword('attr') - attrs_spec
attr_contract.setParseAction(Attr.parse_action)

add_contract(attr_contract)
add_keyword('attr')

########NEW FILE########
__FILENAME__ = comparison
from ..interface import Contract, ContractNotRespected, RValue
from ..syntax import W, add_contract, O, Literal, isnumber, rvalue
import math
from contracts.interface import eval_in_context


class CheckOrder(Contract):

    conditions = {
        '=': (False, True, False),
        '==': (False, True, False),
        '!=': (True, False, True),
        '>': (False, False, True),
        '>=': (False, True, True),
        '<': (True, False, False),
        '<=': (True, True, False)
    }

    def __init__(self, expr1, glyph, expr2, where=None):
        Contract.__init__(self, where)
        assert isinstance(expr1, RValue) or expr1 is None
        assert isinstance(expr2, RValue)

        self.expr1 = expr1
        self.glyph = glyph
        self.expr2 = expr2
        self.smaller, self.equal, self.larger = CheckOrder.conditions[glyph]

    def check_contract(self, context, value):
        if self.expr1 is None:
            val1 = value
        else:
#            val1 = context.eval(self.expr1, self)
            val1 = eval_in_context(context, self.expr1, self)

#        val2 = context.eval(self.expr2, self)
        val2 = eval_in_context(context, self.expr2, self)

        # Check if we only need to check equality
        # in that case, we don't care for the type

        # FIXME: add support for != here
        pure_equality = (
            (self.smaller, self.equal, self.larger) == (False, True, False)
            or
            (self.smaller, self.equal, self.larger) == (True, False, True))

        if pure_equality:
            # but we want them to be either numbers or same type
            if (not (isnumber(val1) and isnumber(val2))) and \
                (not isinstance(val1, val2.__class__)):
                msg = ("I won't let you compare two different types if they "
                       "are not numbers (%s,%s)" % (type(val1), type(val2)))
                raise ContractNotRespected(self, msg, (val1, val2), context)

            ok = (val1 == val2) ^ (not self.equal)
        else:
            # We potentially want < or >. They must be numbers.

            for val in [val1, val2]:
                if not isnumber(val):
                    msg = ('I can only compare the order of numbers, not %r.' %
                           val.__class__.__name__)
                    raise ContractNotRespected(self, msg, (val1, val2),
                                               context)

            if math.isnan(val1) or math.isnan(val2):
                msg = ('I cannot compare NaN (checking: %s %s %s)'
                       % (val1, self.glyph, val2))
                raise ContractNotRespected(self, msg, (val1, val2), context)

            if val1 < val2:
                ok = self.smaller
            elif val1 > val2:
                ok = self.larger
            else:
                assert val1 == val2
                ok = self.equal

        if not ok:
            error = ('Condition %s %s %s not respected' %
                    (val1, self.glyph, val2))

            raise ContractNotRespected(contract=self, error=error,
                                       value=value, context=context)

    def __str__(self):
        if self.expr1 is not None:
            return '%s%s%s' % (self.expr1, self.glyph, self.expr2)
        else:
            return '%s%s' % (self.glyph, self.expr2)

    def __repr__(self):
        return 'CheckOrder(%r,%r,%r)' % (self.expr1, self.glyph, self.expr2)

    @staticmethod
    def parse_action(s, loc, tokens):
        expr1 = tokens.get('expr1', None)
        glyph = "".join(tokens['glyph'])
        expr2 = tokens['expr2']
        where = W(s, loc)
        return CheckOrder(expr1, glyph, expr2, where=where)


for glyph in CheckOrder.conditions:
    if glyph == '!=':
        # special case: ! must be followed by =
        glyph_expression = Literal('!') - Literal('=')
        glyph_expression.setName('!=')
    else:
        glyph_expression = Literal(glyph)

    expr = O(rvalue('expr1')) + glyph_expression('glyph') - rvalue('expr2')
    expr.setParseAction(CheckOrder.parse_action)
    add_contract(expr)


########NEW FILE########
__FILENAME__ = compositions
from ..syntax import simple_contract, W, ParsingTmp, opAssoc
from ..interface import Contract, ContractNotRespected, add_prefix
from ..pyparsing_utils import myOperatorPrecedence
from .suggester import create_suggester
from .extensions import Extension


class Logical(object):
    def __init__(self, glyph, precedence):
        self.glyph = glyph
        self.precedence = precedence

    def __str__(self):
        def convert(x):
            if isinstance(x, Logical) and x.precedence < self.precedence:
                return '(%s)' % x
            else:
                return '%s' % x

        s = self.glyph.join(convert(x) for x in self.clauses)
        return s


class OR(Logical, Contract):
    def __init__(self, clauses, where=None):
        assert isinstance(clauses, list)
        assert len(clauses) >= 2
        Contract.__init__(self, where)
        Logical.__init__(self, '|', 1)
        self.clauses = clauses

    def check_contract(self, context, value):
        exceptions = []
        for c in self.clauses:
            try:
                # try with fake context
                c._check_contract(context.copy(), value)
                # if ok, do with main context
                c._check_contract(context, value)
                break
            except ContractNotRespected as e:
                exceptions.append((c, e))
        else:
            msg = ('Could not satisfy any of the %d clauses in %s.'
                   % (len(self.clauses), self))

            for i, ex in enumerate(exceptions):
                c, e = ex
                msg += '\n ---- Clause #%d:   %s\n' % (i + 1, c)
                msg += add_prefix('%s' % e, ' | ')

            msg += '\n ------- (end clauses) -------'
            raise ContractNotRespected(contract=self, error=msg,
                        value=value, context=context)

    def __repr__(self):
        s = 'OR(%r)' % self.clauses
        return s

    @staticmethod
    def parse_action(string, location, tokens):
        l = list(tokens[0])
        clauses = [l.pop(0)]
        while l:
            glyph = l.pop(0)  # @UnusedVariable
            assert glyph == '|'
            operand = l.pop(0)
            clauses.append(operand)
        where = W(string, location)
        return OR(clauses, where=where)


class And(Logical, Contract):
    def __init__(self, clauses, where=None):
        assert isinstance(clauses, list)
        assert len(clauses) >= 2, clauses
        Contract.__init__(self, where)
        Logical.__init__(self, ',', 2)
        self.clauses = clauses

    def check_contract(self, context, value):
        for c in self.clauses:
            c._check_contract(context, value)

    def __repr__(self):
        s = 'And(%r)' % self.clauses
        return s

    @staticmethod
    def parse_action(string, location, tokens):
        l = list(tokens[0])
        clauses = [l.pop(0)]
        while l:
            glyph = l.pop(0)  # @UnusedVariable
            assert glyph == ','
            operand = l.pop(0)
            clauses.append(operand)
        where = W(string, location)
        return And(clauses, where=where)


suggester = create_suggester(get_options=lambda: ParsingTmp.keywords +
                             list(Extension.registrar.keys()))
baseExpr = simple_contract | suggester
baseExpr.setName('Simple contract (recovering)')

composite_contract = myOperatorPrecedence(baseExpr, [
                         (',', 2, opAssoc.LEFT, And.parse_action),
                         ('|', 2, opAssoc.LEFT, OR.parse_action),
                    ])
composite_contract.setName('OR/AND contract')

or_contract = myOperatorPrecedence(baseExpr, [
                         ('|', 2, opAssoc.LEFT, OR.parse_action),
                    ])
or_contract.setName('OR contract')


########NEW FILE########
__FILENAME__ = dicts
from ..interface import Contract, ContractNotRespected
from ..syntax import (W, contract_expression, O, S, add_contract, add_keyword,
    Keyword)


class Dict(Contract):

    def __init__(self, length=None, key_c=None, value_c=None, where=None):
        Contract.__init__(self, where)
        self.length = length
        self.key_c = key_c
        self.value_c = value_c

    def check_contract(self, context, value):
        if not isinstance(value, dict):
            error = 'Expected a dict, got %r.' % value.__class__.__name__
            raise ContractNotRespected(contract=self, error=error,
                                       value=value, context=context)

        if self.length is not None:
            self.length._check_contract(context, len(value))

        for k in value:
            if self.key_c is not None:
                self.key_c._check_contract(context, k)
            if self.value_c is not None:
                self.value_c._check_contract(context, value[k])

    def __str__(self):
        s = 'dict'
        if self.length is not None:
            s += '[%s]' % self.length
        if self.key_c is not None:
            k = str(self.key_c)
        else:
            k = ''
        if self.value_c is not None:
            v = str(self.value_c)
        else:
            v = ''
        if k or v:
            s += '(%s:%s)' % (k, v)
        return s

    def __repr__(self):
        return 'Dict(%r,%r,%r)' % (self.length, self.key_c, self.value_c)

    @staticmethod
    def parse_action(s, loc, tokens):
        where = W(s, loc)
        length = tokens.get('length', None)
        key = tokens.get('key', None)
        value = tokens.get('value', None)
        return Dict(length, key, value, where=where)


length_spec = S('[') - contract_expression('length') - S(']')
kv_spec = ('(' - O(contract_expression('key'))
           + ':' + O(contract_expression('value')) - ')')
dict_contract = Keyword('dict') + O(length_spec) + O(kv_spec)

dict_contract.setParseAction(Dict.parse_action)

add_contract(dict_contract)
add_keyword('dict')

########NEW FILE########
__FILENAME__ = dummy
from ..interface import Contract, ContractNotRespected
from ..syntax import add_contract, W, Literal


class Any(Contract):
    ''' Always true. '''

    def __init__(self, where=None):
        Contract.__init__(self, where)

    def __repr__(self):
        return 'Any()'

    def __str__(self):
        return '*'

    def check_contract(self, context, value):
        pass

    @staticmethod
    def parse_action(s, loc, tokens):  # @UnusedVariable
        return Any(W(s, loc))


class Never(Contract):
    ''' A contract that does not match anything. Useful for debugging. '''

    def __init__(self, where=None):
        Contract.__init__(self, where)

    def __repr__(self):
        return 'Never()'

    def __str__(self):
        return '#'

    def check_contract(self, context, value):
        raise ContractNotRespected(self, 'No value can match this',
                                   value, context)

    @staticmethod
    def parse_action(s, loc, tokens):  # @UnusedVariable
        return Never(W(s, loc))


add_contract(Literal('*').setParseAction(Any.parse_action))
add_contract(Literal('#').setParseAction(Never.parse_action))

########NEW FILE########
__FILENAME__ = extensions
from ..interface import Contract, ContractNotRespected, describe_value
from ..syntax import (Combine, Word, W, alphas, alphanums, oneOf,
                      ParseException)


class Extension(Contract):

    registrar = {}

    def __init__(self, identifier, where=None):
        assert identifier in Extension.registrar
        self.contract = Extension.registrar[identifier]
        self.identifier = identifier
        Contract.__init__(self, where)

    def __str__(self):
        return self.identifier
#         return Extension.registrar[self.identifier].__str__()

    def __repr__(self):
        return "Extension(%r)" % self.identifier
        # return "new_contract(%r,%s)" % (self.identifier, Extension.registrar[self.identifier])

    def check_contract(self, context, value):
        self.contract._check_contract(context, value)

    @staticmethod
    def parse_action(s, loc, tokens):
        identifier = tokens[0]

        if not identifier in Extension.registrar:
            raise ParseException('Not matching %r' % identifier)

        where = W(s, loc)
        return Extension(identifier, where)

    # We want to be pickable so we do not save self.contract
    # which might point to a lambda
    def __getstate__(self):
        return {'identifier': self.identifier}

    def __setstate__(self, d):
        self.identifier = d['identifier']
        self.contract = Extension.registrar[self.identifier]


class CheckCallable(Contract):

    def __init__(self, callable):  # @ReservedAssignment
        self.callable = callable
        Contract.__init__(self, where=None)

    def check_contract(self, context, value):
        allowed = (ValueError, AssertionError)
        try:
            result = self.callable(value)
        except allowed as e:  # failed
            raise ContractNotRespected(self, str(e), value, context)

        if result in [None, True]:
            # passed
            pass
        elif result == False:
            msg = ('Value does not pass criteria of %s() (module: %s).' % 
                   (self.callable.__name__, self.callable.__module__))
            raise ContractNotRespected(self, msg, value, context)
        else:
            msg = ('I expect that %r returns either True, False, None; or '
                   'raises a ValueError exception. Instead, I got %s.' % 
                   (self.callable, describe_value(value)))
            raise ValueError(msg)

    def __repr__(self):
        ''' Note: this contract is not representable, but anyway it is 
            only used by Extension, which serializes using the identifier. '''
        return 'CheckCallable(%r)' % self.callable

    def __str__(self):
        ''' Note: this contract is not representable, but anyway it is only 
            used by Extension, which serializes using the identifier. '''
        return 'function %s()' % self.callable.__name__


class CheckCallableWithSelf(Contract):
    def __init__(self, callable):  # @ReservedAssignment
        self.callable = callable
        Contract.__init__(self, where=None)

    def check_contract(self, context, value):
        if not 'self' in context:
            msg = ('You can only call this contract in the context of '
                   ' a function call to a regular method.')
            raise ContractNotRespected(self, msg, value, context)

        args = (context['self'], value)
        allowed = (ValueError, AssertionError)
        try:
            result = self.callable(*args)
        except allowed as e:  # failed
            raise ContractNotRespected(self, str(e), value, context)

        if result in [None, True]:
            # passed
            pass
        elif result == False:
            msg = ('Value does not pass criteria of %s() (module: %s).' % 
                   (self.callable.__name__, self.callable.__module__))
            raise ContractNotRespected(self, msg, value, context)
        else:
            msg = ('I expect that %r returns either True, False, None; or '
                   'raises a ValueError exception. Instead, I got %s.' % 
                   (self.callable, describe_value(value)))
            raise ValueError(msg)

    def __repr__(self):
        ''' Note: this contract is not representable, but anyway it is only 
            used by Extension, which serializes using the identifier. '''
        return 'CheckCallableWithSelf(%r)' % self.callable

    def __str__(self):
        ''' Note: this contract is not representable, but anyway it is only 
            used by Extension, which serializes using the identifier. '''
        return 'function %s()' % self.callable.__name__


# lowercase = alphas.lower()
identifier_expression = Combine(oneOf(list(alphas)) + Word('_' + alphanums))

identifier_contract = identifier_expression.copy().setParseAction(
                                                        Extension.parse_action)


########NEW FILE########
__FILENAME__ = isinstance_imp
from contracts.interface import Contract, ContractNotRespected
from contracts.syntax import W, S, Keyword, add_contract, add_keyword
from pyparsing import alphanums, Word

__all__ = ['IsInstance', 'isinstance_contract']

class IsInstance(Contract):
    
    """ Checks that one of the superclasses have the specified name. """
     
    def __init__(self, name, where=None):
        Contract.__init__(self, where)
        self.name = name

    def check_contract(self, context, value):
        class_name, bases_names = get_all_super_names(value) 
        
        if not self.name in bases_names + [class_name]:
            msg = ('Failed check isinstance(%s) for type %r and superclasses %r.' 
                   % (self.name, class_name, bases_names))
            raise ContractNotRespected(self, msg, value, context)

    def __str__(self):
        return 'isinstance(%s)' % self.name

    def __repr__(self):
        return 'IsInstance(%r)' % self.name

    @staticmethod
    def parse_action(s, loc, tokens):
        where = W(s, loc)
        name = tokens['name']
        return IsInstance(name, where)


def get_all_super_names(value):
    """ Returns name of class, list of names of supers """
    if hasattr(value, '__class__'):
        # old style class
        klass = value.__class__
        class_name = klass.__name__
        bases = get_oldstyle_bases(klass)
        bases_names = [x.__name__ for x in bases]
    else:
        # new style
        t = type(value)
        class_name = t.__name__
        bases_names = [b.__name__ for b in t.mro()]
    return class_name, bases_names

def get_oldstyle_bases(klass):
    todo = [klass]
    res = []
    while todo:
        x = todo.pop(0)
        res.append(x)
        for b in x.__bases__:
            if not b in res:
                todo.append(b)
    return res

Identifier = Word(alphanums + '_')

isinstance_contract = (Keyword('isinstance') - S('(') - Identifier('name') - S(')'))

add_contract(isinstance_contract.setParseAction(IsInstance.parse_action))
add_keyword('isinstance')

########NEW FILE########
__FILENAME__ = lists
from ..interface import Contract, ContractNotRespected
from ..syntax import (add_contract, W, contract_expression, O, S, add_keyword,
    Keyword)


class List(Contract):

    def __init__(self, length_contract=None,
                 elements_contract=None, where=None):
        Contract.__init__(self, where)
        self.length_contract = length_contract
        self.elements_contract = elements_contract

    def check_contract(self, context, value):
        if not isinstance(value, list):
            error = 'Expected a sequence, got %r.' % value.__class__.__name__
            raise ContractNotRespected(self, error, value, context)

        if self.length_contract is not None:
            self.length_contract._check_contract(context, len(value))

        if self.elements_contract is not None:
            for element in value:
                self.elements_contract._check_contract(context, element)

    def __str__(self):
        s = 'list'
        if self.length_contract is not None:
            s += '[%s]' % self.length_contract
        if self.elements_contract is not None:
            s += '(%s)' % self.elements_contract
        return s

    def __repr__(self):
        s = 'List(%r,%r)' % (self.length_contract, self.elements_contract)
        return s

    @staticmethod
    def parse_action(s, loc, tokens):
        where = W(s, loc)
        length_contract = tokens.get('length_contract', None)
        elements_contract = tokens.get('elements_contract', None)
        return List(length_contract, elements_contract, where=where)


list_contract = (Keyword('list') -
                 O(S('[') - contract_expression('length_contract') - S(']')) +
                 O(S('(') - contract_expression('elements_contract') - S(')')))
list_contract.setParseAction(List.parse_action)

list_contract.setName('List contract')
add_keyword('list')
add_contract(list_contract)

########NEW FILE########
__FILENAME__ = map
from ..interface import Contract, ContractNotRespected
from ..syntax import (W, contract_expression, O, S, add_contract, add_keyword,
    Keyword)
import collections


class Map(Contract):

    def __init__(self, length=None, key_c=None, value_c=None, where=None):
        Contract.__init__(self, where)
        self.length = length
        self.key_c = key_c
        self.value_c = value_c

    def check_contract(self, context, value):
        if not isinstance(value, collections.Mapping):
            error = 'Expected a Mapping, got %r.' % value.__class__.__name__
            raise ContractNotRespected(contract=self, error=error,
                                       value=value, context=context)

        if self.length is not None:
            self.length._check_contract(context, len(value))

        for k in value:
            if self.key_c is not None:
                self.key_c._check_contract(context, k)
            if self.value_c is not None:
                self.value_c._check_contract(context, value[k])

    def __str__(self):
        s = 'map'
        if self.length is not None:
            s += '[%s]' % self.length
        if self.key_c is not None:
            k = str(self.key_c)
        else:
            k = ''
        if self.value_c is not None:
            v = str(self.value_c)
        else:
            v = ''
        if k or v:
            s += '(%s:%s)' % (k, v)
        return s

    def __repr__(self):
        return 'Map(%r,%r,%r)' % (self.length, self.key_c, self.value_c)

    @staticmethod
    def parse_action(s, loc, tokens):
        where = W(s, loc)
        length = tokens.get('length', None)
        key = tokens.get('key', None)
        value = tokens.get('value', None)
        return Map(length, key, value, where=where)


length_spec = S('[') - contract_expression('length') - S(']')
kv_spec = ('(' - O(contract_expression('key')) + ':'
           + O(contract_expression('value')) - ')')
dict_contract = Keyword('map') + O(length_spec) + O(kv_spec)

dict_contract.setParseAction(Map.parse_action)

add_contract(dict_contract)
add_keyword('map')

########NEW FILE########
__FILENAME__ = miscellaneous_aliases
import collections

from ..main import new_contract


def ist(C):
    def f(x):
        f.__name__ = 'isinstance_of_%s' % C.__name__
        if not isinstance(x, C):
            raise ValueError('Value is not an instance of %s.' % C.__name__)
    return f

new_contract('Container', ist(collections.Container))
new_contract('Hashable', ist(collections.Hashable))
new_contract('Iterable', ist(collections.Iterable))
new_contract('Iterator', ist(collections.Iterator))
new_contract('Sized', ist(collections.Sized))
new_contract('Callable', ist(collections.Callable))
new_contract('Sequence', ist(collections.Sequence))
new_contract('Set', ist(collections.Set))
new_contract('MutableSequence', ist(collections.MutableSequence))
new_contract('MutableSet', ist(collections.MutableSet))
new_contract('Mapping', ist(collections.Mapping))
new_contract('MutableMapping', ist(collections.MutableMapping))
#new_contract('MappingView', ist(collections.MappingView))
#new_contract('ItemsView', ist(collections.ItemsView))
#new_contract('ValuesView', ist(collections.ValuesView))


# Not a lambda to have better messages
def is_None(x): 
    return x is None

new_contract('None', is_None)
new_contract('NoneType', is_None)

########NEW FILE########
__FILENAME__ = separate_context
from ..interface import Contract
from ..syntax import add_contract, W, contract_expression, Literal, Group


class SeparateContext(Contract):

    def __init__(self, contract, where=None):
        assert isinstance(contract, Contract)
        Contract.__init__(self, where)
        self.contract = contract

    def check_contract(self, context, value):
        copy = context.copy()
        self.contract._check_contract(copy, value)

    def __str__(self):
        return '$(%s)' % self.contract

    def __repr__(self):
        return 'SeparateContext(%r)' % self.contract

    @staticmethod
    def parse_action(s, loc, tokens):
        where = W(s, loc)
        return SeparateContext(tokens[0]['child'], where=where)


sepcon = (Group(Literal('$') - Literal('(') -
                contract_expression('child') - Literal(')')))
sepcon.setParseAction(SeparateContext.parse_action)
sepcon.setName('Context separation construct')
add_contract(sepcon)

########NEW FILE########
__FILENAME__ = seq
from ..interface import Contract, ContractNotRespected
from ..syntax import (add_contract, W, contract_expression, O, S, add_keyword,
    Keyword)
import collections


try:
    import numpy
    has_numpy = True
except:
    has_numpy = False


class Seq(Contract):

    def __init__(self, length_contract=None,
                    elements_contract=None, where=None):
        Contract.__init__(self, where)
        self.length_contract = length_contract
        self.elements_contract = elements_contract

    def check_contract(self, context, value):
        if has_numpy and isinstance(value, numpy.ndarray):
            # TODO: check basic datatypes
            # use value.size and value.flat for iteration
            if self.length_contract is not None:
                self.length_contract._check_contract(context, value.size)

            if self.elements_contract is not None:
                n = value.size
                for i in xrange(n):
                    element = value.flat[i]
                    if ((element.dtype == numpy.int32) or
                        (element.dtype == numpy.int64)):
                        element = int(element)
                    # XXX: hack
                    self.elements_contract._check_contract(context, element)

            return

        if not isinstance(value, collections.Sequence):
            error = 'Expected a sequence, got %r.' % value.__class__.__name__
            raise ContractNotRespected(self, error, value, context)

        if self.length_contract is not None:
            self.length_contract._check_contract(context, len(value))

        if self.elements_contract is not None:
            for element in value:
                self.elements_contract._check_contract(context, element)

    def __str__(self):
        s = 'seq'
        if self.length_contract is not None:
            s += '[%s]' % self.length_contract
        if self.elements_contract is not None:
            s += '(%s)' % self.elements_contract
        return s

    def __repr__(self):
        s = 'Seq(%r,%r)' % (self.length_contract, self.elements_contract)
        return s

    @staticmethod
    def parse_action(s, loc, tokens):
        where = W(s, loc)
        length_contract = tokens.get('length_contract', None)
        elements_contract = tokens.get('elements_contract', None)
        return Seq(length_contract, elements_contract, where=where)


list_contract = (Keyword('seq') -
                 O(S('[') - contract_expression('length_contract') - S(']')) +
                 O(S('(') - contract_expression('elements_contract') - S(')')))
list_contract.setParseAction(Seq.parse_action)

list_contract.setName('Seq contract')
add_keyword('seq')
add_contract(list_contract)

########NEW FILE########
__FILENAME__ = sets
from ..interface import Contract, ContractNotRespected
from ..syntax import (add_contract, W, contract_expression, O, S, add_keyword,
    Keyword)
from ..interface import describe_type


class ASet(Contract):

    def __init__(self, length_contract=None,
                 elements_contract=None, where=None):
        Contract.__init__(self, where)
        self.length_contract = length_contract
        self.elements_contract = elements_contract

    def check_contract(self, context, value):
        if not isinstance(value, set):
            error = 'Expected a set, got %r.' % describe_type(value)
            raise ContractNotRespected(self, error, value, context)

        if self.length_contract is not None:
            self.length_contract._check_contract(context, len(value))

        if self.elements_contract is not None:
            for element in value:
                self.elements_contract._check_contract(context, element)

    def __str__(self):
        s = 'set'
        if self.length_contract is not None:
            s += '[%s]' % self.length_contract
        if self.elements_contract is not None:
            s += '(%s)' % self.elements_contract
        return s

    def __repr__(self):
        s = 'ASet(%r,%r)' % (self.length_contract, self.elements_contract)
        return s

    @staticmethod
    def parse_action(s, loc, tokens):
        where = W(s, loc)
        length_contract = tokens.get('length_contract', None)
        elements_contract = tokens.get('elements_contract', None)
        return ASet(length_contract, elements_contract, where=where)


list_contract = (Keyword('set') - 
                 O(S('[') - contract_expression('length_contract') - S(']')) + 
                 O(S('(') - contract_expression('elements_contract') - S(')')))
list_contract.setParseAction(ASet.parse_action)

list_contract.setName('Set contract')
add_keyword('set')
add_contract(list_contract)

########NEW FILE########
__FILENAME__ = simple_values
from ..interface import Contract, ContractNotRespected, RValue
from ..syntax import W
from ..interface import eval_in_context


class EqualTo(Contract):
    def __init__(self, rvalue, where=None):
        Contract.__init__(self, where)
        assert isinstance(rvalue, RValue)
        self.rvalue = rvalue

    def check_contract(self, context, value):
        val = eval_in_context(context, self.rvalue, self)
#        val = context.eval(self.rvalue, self)
        if not(val == value):
            error = ('EqualTo: Condition %s == %s not respected.'
                     % (val, value))
            raise ContractNotRespected(contract=self, error=error,
                                       value=value, context=context)

    def __str__(self):
        return "%s" % self.rvalue

    def __repr__(self):
        return 'EqualTo(%r)' % self.rvalue

    @staticmethod
    def parse_action(s, loc, tokens):
        where = W(s, loc)
        rvalue = tokens[0]
        return EqualTo(rvalue, where)


class SimpleRValue(RValue):
    def __init__(self, value, representation=None, where=None):
        assert representation is None or isinstance(representation, str)
        self.value = value
        self.where = where
        self.representation = representation
#
#    def __eq__(self, other):
#        return (self.__class__ == other.__class__ and 
#                self.value == other.value)

    def __str__(self):
        if self.representation is None:
            return "{0!s}".format(self.value)
        else:
            return self.representation

    def __repr__(self):
        if self.representation is None:
            return "SimpleRValue({0!r})".format(self.value)
        else:
            return "SimpleRValue({0!r},{1!r})".format(self.value,
                                                      self.representation)

    def eval(self, context):  # @UnusedVariable @ReservedAssignment
        return self.value



########NEW FILE########
__FILENAME__ = strings
from ..interface import Contract, ContractNotRespected
from ..syntax import (add_contract, W, contract_expression, O, add_keyword,
    Keyword)


# Base class for string contracts
class StringBase(Contract):

    def __init__(self, length=None, where=None):
        Contract.__init__(self, where)
        self.length = length
        assert length is None or isinstance(length, Contract)

    def check_contract(self, context, value):
        if not isinstance(value, self.TYPE):
            error = 'Expected %s, got %r.' % (
                self.DESCRIPTION, value.__class__.__name__)
            raise ContractNotRespected(contract=self, error=error,
                                       value=value, context=context)

        if self.length is not None:
            self.length._check_contract(context, len(value))

    def __repr__(self):
        return '%s(%r)' % (self.__class__.__name__, self.length)

    def __str__(self):
        s = self.KEYWORDS[0]
        if self.length is not None:
            s += '[%s]' % self.length
        return s

    @classmethod
    def parse_action(cls, s, loc, tokens):
        where = W(s, loc)
        length = tokens.get('length', None)
        return cls(length, where=where)


import sys
if sys.version_info[0] == 3:  # Python 3

    __all__ = ['String']

    class String(StringBase):
        KEYWORDS = ['str', 'string']
        TYPE = str
        DESCRIPTION = "a string"

else:  # Python 2.x

    __all__ = ['String', 'AnsiString', 'UnicodeString']

    class String(StringBase):
        KEYWORDS = ['string']
        TYPE = basestring
        DESCRIPTION = "an ANSI or Unicode string"

    class AnsiString(StringBase):
        KEYWORDS = ['str']
        TYPE = str
        DESCRIPTION = "an ANSI string"

    class UnicodeString(StringBase):
        KEYWORDS = ['unicode']
        TYPE = unicode
        DESCRIPTION = "a Unicode string"


for cls in StringBase.__subclasses__():
    for keyword in cls.KEYWORDS:
        mycontract = (Keyword(keyword) + 
                    O('[' - contract_expression('length') - ']'))
        add_keyword(keyword)
        add_contract(mycontract.setParseAction(cls.parse_action))

########NEW FILE########
__FILENAME__ = suggester
import operator

from ..syntax import (Combine, Word, alphas, alphanums, oneOf,
                      ParseSyntaxException, ParseException)


def find_longest_match(s, options):
    matches = [(x, longest_match(s, x)) for x in options]
    best = max(matches, key=operator.itemgetter(1))
    return best


def longest_match(a, b):
    lengths = range(min(len(a), len(b)) + 1)
    lengths = list(reversed(lengths))
    for i in lengths:
        if a[:i] == b[:i]:
            return i
    assert False  # pragma: no cover

assert ('float64', 6) == find_longest_match('float6', ['float32', 'float64'])
assert 2 == find_longest_match('fl6', ['float32', 'float64'])[1]


# http://hetland.org/coding/python/levenshtein.py
def levenshtein(a, b):
    "Calculates the Levenshtein distance between a and b."
    n, m = len(a), len(b)
    if n > m:  # pragma: no cover
        # Make sure n <= m, to use O(min(n,m)) space
        a, b = b, a
        n, m = m, n

    current = range(n + 1)
    for i in range(1, m + 1):
        previous, current = current, [i] + [0] * n
        for j in range(1, n + 1):
            add, delete = previous[j] + 1, current[j - 1] + 1
            change = previous[j - 1]
            if a[j - 1] != b[i - 1]:
                change = change + 1
            current[j] = min(add, delete, change)

    return current[n]


def find_best_match(s, options):
    matches = [(x, levenshtein(s[:len(x)], x) - len(x)) for x in options]
    best = min(matches, key=operator.itemgetter(1))
    return best


def default_message(identifier):
    return 'Unknown identifier %r. ' % identifier


def create_suggester(get_options, get_message=default_message,
            pattern=Combine(oneOf(list(alphas)) + Word('_' + alphanums))):
    pattern = pattern.copy()

    def find_match(identifier, options, local_string):
        match, length = find_longest_match(identifier, options)
        if length >= 2:
            return True, match, length

        match, distance = find_best_match(local_string, options)

        if distance < len(match) - 1:
            length = longest_match(local_string, match)
            return True, match, length

        return False, "No matches found", 0

    def parse_action(s, loc, tokens):
        identifier = tokens[0]
        options = get_options()
        
        msg = 'Bug in syntax: I was not supposed to match %r.' % identifier
        msg += '(options: %s)' % options
        
        msg += ''' Suggestions on the cause:
            1) Use add_keyword(), always.
            
            2) Use:
                Keyword('attr') - attrs_spec
               instead of 
                Keyword('attr') + attrs_spec
        '''
        assert not (identifier in options), msg

        
        msg = get_message(identifier)

        if options:
            local_string = s[loc:]
            confident, match, length = find_match(identifier, options,
                                                  local_string)
            if confident:
                msg += 'Did you mean %r?' % match
                loc += length
            else:
                msg += '\nI know: %r.\n' % (options)
        pe = ParseException(s, loc, msg, pattern)
        raise ParseSyntaxException(pe)

    pattern.setParseAction(parse_action)

    return pattern

########NEW FILE########
__FILENAME__ = tuple
from ..interface import Contract, ContractNotRespected
from ..syntax import(add_contract, W, contract_expression, O, S, ZeroOrMore,
                      Group, add_keyword, Keyword)
from .compositions import or_contract


class Tuple(Contract):

    def __init__(self, length=None, elements=None, where=None):
        Contract.__init__(self, where)
        self.length = length
        self.elements = elements
        assert elements is None or isinstance(elements, list)
        if elements:
            for e in elements:
                assert isinstance(e, Contract)

    def check_contract(self, context, value):
        if not isinstance(value, tuple):
            error = 'Expected a tuple, got %r.' % value.__class__.__name__
            raise ContractNotRespected(contract=self, error=error,
                                       value=value, context=context)

        if self.length is not None:
            self.length._check_contract(context, len(value))

        if self.elements is not None:
            if len(value) != len(self.elements):
                error = ('Expected a tuple of length '
                         '%s, got %r of length %s.' %
                         (len(self.elements), value, len(value)))
                raise ContractNotRespected(contract=self, error=error,
                                           value=value, context=context)

            for i in range(len(value)):
                self.elements[i]._check_contract(context, value[i])

    def __repr__(self):
        return 'Tuple(%r,%r)' % (self.length, self.elements)

    def __str__(self):
        s = 'tuple'
        if self.length is not None:
            s += '[%s]' % self.length

        def rep(x):
            from .compositions import And
            if isinstance(x, And):
                return "(%s)" % x
            else:
                return "%s" % x

        if self.elements is not None:
            s += '(%s)' % ",".join(rep(x) for x in self.elements)
        return s

    @staticmethod
    def parse_action(s, loc, tokens):
        where = W(s, loc)
        length = tokens.get('length', [None])[0]
#        elements = tokens.get('elements', [None])[0]

        if 'elements' in tokens:
            elements = list(tokens['elements'])
        else:
            elements = None
        assert elements is None or length is None
        assert length is None or isinstance(length, Contract), ("Wrong type %r"
                                                                % length)

        if elements:
            for e in elements:
                assert isinstance(e, Contract), ("Wrong type %s (%r)"
                                                 % (type(e), e))
        return Tuple(length, elements, where=where)


# if you use contract instead of simple_contract, it will be matched as And


inside = (S('(') - contract_expression - S(')')) | or_contract
inside.setName('Any contract for tuple elements (use parenthesis for AND)')

elements = (Group(S('(') - inside - ZeroOrMore(S(',')
                                            - inside) - S(')'))('elements'))
elements.setName('Tuple elements contract.')


length = Group(S('[') - contract_expression - S(']'))('length')
length.setName('Tuple length contract.')

tuple_contract = Keyword('tuple') - O(length | elements)
tuple_contract.setName('tuple contract')

add_contract(tuple_contract.setParseAction(Tuple.parse_action))
add_keyword('tuple')


########NEW FILE########
__FILENAME__ = types_misc
from ..interface import Contract, ContractNotRespected
from ..syntax import (W, add_contract, contract_expression, S, Keyword,
    add_keyword)
from numbers import Number


class CheckType(Contract):

    def __init__(self, types, type_string=None, where=None):
        from ..main import can_be_used_as_a_type  # XXX: make it better
        assert can_be_used_as_a_type(types)
        Contract.__init__(self, where)
        self.types = types
        if type_string is None:
            self.type_string = types.__name__
        else:
            self.type_string = type_string

    def check_contract(self, context, value):
        if not isinstance(value, self.types):
            error = 'Expected type %r, got %r.' % (self.types.__name__,
                                                   value.__class__.__name__)
            raise ContractNotRespected(contract=self, error=error,
                                       value=value, context=context)

    def __str__(self):
        return self.type_string

    def __repr__(self):
        if self.types.__name__ == self.type_string:
            return 'CheckType(%s)' % (self.types.__name__)
        else:
            return 'CheckType(%s,%r)' % (self.types.__name__, self.type_string)

    @staticmethod
    def parse_action(types):
        def parse(s, loc, tokens):
            where = W(s, loc)
            return CheckType(types, tokens[0], where=where)  # @UnusedVariable
        return parse


add_contract(Keyword('Int').setParseAction(CheckType.parse_action(int)))
add_keyword('Int')

add_contract(Keyword('Float').setParseAction(CheckType.parse_action(float)))
add_keyword('Float')

add_contract(Keyword('Number').setParseAction(CheckType.parse_action(Number)))
add_keyword('Number')

add_contract(Keyword('bool').setParseAction(CheckType.parse_action(bool)))
add_keyword('bool')



class Type(Contract):
    def __init__(self, type_constraint, where=None):
        Contract.__init__(self, where)
        self.type_constraint = type_constraint

    def check_contract(self, context, value):
        #  self.type_constraint._check_contract(context, type(value))
        self.type_constraint._check_contract(context, value.__class__)

    def __str__(self):
        return 'type(%s)' % self.type_constraint

    def __repr__(self):
        return 'Type(%r)' % self.type_constraint

    @staticmethod
    def parse_action(s, loc, tokens):
        where = W(s, loc)
        type_constraint = tokens['type_constraint']
        return Type(type_constraint, where)


type_contract = (Keyword('type') - S('(')
                 - contract_expression('type_constraint') - S(')'))

add_contract(type_contract.setParseAction(Type.parse_action))
add_keyword('type')



########NEW FILE########
__FILENAME__ = variables
from ..interface import Contract, ContractNotRespected, RValue, describe_value
from ..syntax import (W, oneOf, FollowedBy, NotAny)


class BindVariable(Contract):

    def __init__(self, variable, allowed_types, where=None):
        assert isinstance(variable, str) and len(variable) == 1
        assert allowed_types, '%r' % allowed_types
        Contract.__init__(self, where)
        self.variable = variable
        self.allowed_types = allowed_types

    def check_contract(self, context, value):
        if self.variable in context:
            expected = context[self.variable]
            if not (expected == value):
                # TODO: add where it was bound
                error = (
                'Expected value for %r was: %s\n'
                '        instead I received: %s' %
                         (self.variable, describe_value(expected),
                         describe_value(value)))
                raise ContractNotRespected(contract=self, error=error,
                                           value=value, context=context)

        else:
            # bound variable
            if not isinstance(value, self.allowed_types):
                error = ('Variable %r can only bind to %r, not %r.' %
                         (self.variable, self.allowed_types,
                          value.__class__.__name__))
                raise ContractNotRespected(self, error, value, context)

            context[self.variable] = value

    def __str__(self):
        return self.variable

    def __repr__(self):
        # XXX: invalid if tuple
        return 'BindVariable(%r,%s)' % (self.variable,
                                        self.allowed_types.__name__)

    @staticmethod
    def parse_action(allowed_types):
        def parse(s, loc, tokens):
            where = W(s, loc)
            variable = tokens[0]
            assert len(variable) == 1, \
                    ('Wrong syntax, matched %r as variable in %r.'
                     % (variable, s))
            # print ('Matched %r as variable in %r.' % (variable, s))
            return BindVariable(variable, allowed_types, where=where)
        return parse


class VariableRef(RValue):
    def __init__(self, variable, where=None):
        assert isinstance(variable, str)
        self.where = where
        self.variable = variable

    def eval(self, context):  # @ReservedAssignment
        var = self.variable
        if not var in context:
            raise ValueError('Unknown variable %r.' % var)
        return context[var]

    def __repr__(self):
        return "VariableRef(%r)" % self.variable

    def __str__(self):
        return "%s" % self.variable

    @staticmethod
    def parse_action(s, loc, tokens):
        where = W(s, loc)
        return VariableRef(tokens[0], where=where)


alphabetu = 'A B C D E F G H I J K L M N O P Q R S T U W V X Y Z '
alphabetl = 'a b c d e f g h i j k l m n o p q r s t u w v x y z '

# Special case: allow an expression like AxBxC
nofollow = 'a b c d e f g h i j k l m n o p q r s t u w v   y z'
# also do not commit if part of word (SEn, a_2)
nofollow += 'A B C D E F G H I J K L M N O P Q R S T U W V X Y Z '
nofollow += '0 1 2 3 4 5 6 7 8 9 _'
# but recall 'axis_angle'
int_variables = (oneOf(alphabetu.split())
                  + FollowedBy(NotAny(oneOf(nofollow.split()))))
misc_variables = (oneOf(alphabetl.split())
                  + FollowedBy(NotAny(oneOf(nofollow.split() + ['x']))))
int_variables_ref = int_variables.copy().setParseAction(
                                                    VariableRef.parse_action)
misc_variables_ref = misc_variables.copy().setParseAction(
                                                    VariableRef.parse_action)

#int_variables = oneOf(alphabetu.split()) + FollowedBy(White() ^ 'x')

# These must be followed by whitespace; punctuation
#misc_variables = oneOf(alphabet.lower()) + FollowedBy(White()) 

nofollow = 'a b c d e f g h i j k l m n o p q r s t u w v   y z '
nofollow += ' * - + /'
nofollow += 'A B C D E F G H I J K L M N O P Q R S T U W V X Y Z '
nofollow += '0 1 2 3 4 5 6 7 8 9 _'
int_variables2 = (oneOf(alphabetu.split())
                  + FollowedBy(NotAny(oneOf(nofollow.split()))))
misc_variables2 = (oneOf(alphabetl.split())
                   + FollowedBy(NotAny(oneOf(nofollow.split() + ['x']))))
int_variables_contract = int_variables2.setParseAction(
                                                BindVariable.parse_action(int))
misc_variables_contract = misc_variables2.setParseAction(
                                            BindVariable.parse_action(object))



########NEW FILE########
__FILENAME__ = main
from .backported import getcallargs, getfullargspec
from .docstring_parsing import DocStringInfo, Arg
from .enabling import all_disabled
from .interface import (Contract, ContractSyntaxError, Where,
                        ContractException, ContractNotRespected,
                        describe_value, MissingContract)
from .library import (identifier_expression, Extension, CheckCallable,
                      SeparateContext)
from .library.extensions import CheckCallableWithSelf
from .syntax import contract_expression, ParseException, ParseFatalException
import inspect
import sys
import types
from contracts.interface import ContractDefinitionError, \
    CannotDecorateClassmethods


def check_contracts(contracts, values, context_variables=None):
    '''
        Checks that the values respect the contract.
        Not a public function -- no friendly messages.

        :param contracts: List of contracts.
        :type contracts:  ``list[N](str),N>0``

        :param values: Values that should match the contracts.
        :type values: ``list[N]``

        :param context_variables: Initial context
        :type context_variables: ``dict(str[1]: *)``

        :return: a Context variable
        :rtype: type(Context)

        :raise: ContractSyntaxError
        :raise: ContractNotRespected
        :raise: ValueError
    '''
    assert isinstance(contracts, list)
    assert isinstance(contracts, list)
    assert len(contracts) == len(values)

    if context_variables is None:
        context_variables = {}

    for var in context_variables:
        if not (isinstance(var, str) and len(var) == 1):  # XXX: isalpha
            msg = ('Invalid name %r for a variable. '
                   'I expect a string of length 1.' % var)
            raise ValueError(msg)

    C = []
    for x in contracts:
        assert isinstance(x, str)
        C.append(parse_contract_string(x))

    context = context_variables.copy()
    for i in range(len(contracts)):
        C[i]._check_contract(context, values[i])

    return context


class Storage:
    string2contract = {}

def parse_contract_string(string):
    assert isinstance(string, str), type(string)
    if string in Storage.string2contract:
        return Storage.string2contract[string]
    try:
        c = contract_expression.parseString(string,
                                             parseAll=True)[0]
        assert isinstance(c, Contract), 'Want Contract, not %r' % c
        Storage.string2contract[string] = c
        return c
    except ParseException as e:
        where = Where(string, line=e.lineno, column=e.col)
        msg = '%s' % e
        raise ContractSyntaxError(msg, where=where)
    except ParseFatalException as e:
        where = Where(string, line=e.lineno, column=e.col)
        msg = '%s' % e
        raise ContractSyntaxError(msg, where=where)

# TODO: add decorator-specific exception


def contract_decorator(*arg, **kwargs):
    ''' 
        Decorator for adding contracts to functions.
    
        It is smart enough to support functions with variable number of 
        arguments and keyword arguments.
        
        There are three ways to specify the contracts. In order of precedence:
        
        - As arguments to this decorator. For example: ::
        
              @contract(a='int,>0',b='list[N],N>0',returns='list[N]')
              def my_function(a, b):
                  # ...
                  pass
        
        - As annotations (supported only in Python 3): ::
        
              @contract
              def my_function(a:'int,>0', b:'list[N],N>0') -> 'list[N]': 
                  # ...
                  pass
        
        - Using ``:type:`` and ``:rtype:`` tags in the function's docstring: ::
        
              @contract
              def my_function(a, b): 
                  """ Function description.
                      :type a: int,>0
                      :type b: list[N],N>0
                      :rtype: list[N]
                  """
                  pass
        
        **Signature and docstrings**: The signature of the decorated
        function is conserved. By default, the docstring is modified
        by adding ``:type:`` and ``:rtype:`` definitions. To avoid that,
        pass ``modify_docstring=False`` as a parameter.
        
                 
        **Contracts evaluation**: Note that all contracts for the arguments 
        and the return values
        are evaluated in the same context. This make it possible to use
        common variables in the contract expression. For example, in the 
        example above, the return value is constrained to be a list of the same 
        length (``N``) as the parameter ``b``. 
        
        **Using docstrings** Note that, by convention, those annotations must 
        be parseable as RestructuredText. This is relevant if you are using 
        Sphinx.
        If the contract string has special RST characters in it, like ``*``,
        you can include it in double ticks. |pycontracts| will remove
        the double ticks before interpreting the string.
          
        For example, the two annotations in this docstring are equivalent
        for |pycontracts|, but the latter is better for Sphinx: ::
           
              """ My function 
              
                  :param a: First parameter
                  :type a: list(tuple(str,*))
                  
                  :param b: First parameter
                  :type b: ``list(tuple(str,*))``
              """
    
        :raise: ContractException, if arguments are not coherent 
        :raise: ContractSyntaxError
    '''
    # OK, this is black magic. You are not expected to understand this.
    if arg:
        if isinstance(arg[0], types.FunctionType):
            # We were called without parameters
            function = arg[0]
            if all_disabled():
                return function
            try:
                return contracts_decorate(function, **kwargs)
            except ContractSyntaxError as e:
                # Erase the stack
                raise ContractSyntaxError(e.error, e.where)
        else:
            msg = ('I expect that contracts() is called with '
                    'only keyword arguments (passed: %r)' % arg)
            raise ContractException(msg)
    else:
        # We were called *with* parameters.
        if all_disabled():
            def tmp_wrap(function):
                return function
        else:
            def tmp_wrap(function):
                try:
                    return contracts_decorate(function, **kwargs)
                except ContractSyntaxError as e:
                    # Erase the stack
                    raise ContractSyntaxError(e.error, e.where)
        return tmp_wrap


def contracts_decorate(function_, modify_docstring=True, **kwargs):
    ''' An explicit way to decorate a given function.
        The decorator :py:func:`decorate` calls this function internally. 
    '''
    
    if isinstance(function_, classmethod):
        msg = """
The function is a classmethod; PyContracts cannot decorate a classmethod. 
You can, however, first decorate a function and then turn it into a classmethod.

For example, instead of doing this:

    class A():
    
        @contract(a='>0')
        @classmethod
        def f(cls, a):
            pass

you can achieve the same goal by inverting the two decorators:

    class A():
    
        @classmethod
        @contract(a='>0')
        def f(cls, a):
            pass
"""
        raise CannotDecorateClassmethods(msg)
        

    all_args = get_all_arg_names(function_)

    if kwargs:

        returns = kwargs.pop('returns', None)

        for kw in kwargs:
            if not kw in all_args:
                msg = 'Unknown parameter %r; I know %r.' % (kw, all_args)
                raise ContractException(msg)

        accepts_dict = dict(**kwargs)

    else:
        # Py3k: check if there are annotations
        annotations = get_annotations(function_)

        if annotations:
            if 'return' in annotations:
                returns = annotations['return']
                del annotations['return']
            else:
                returns = None

            accepts_dict = annotations
        else:
            # Last resort: get types from documentation string.
            if function_.__doc__ is None:
                # XXX: change name
                raise ContractException(
                                'You did not specify a contract, nor I can '
                                        'find a docstring for %r.' % function_)

            accepts_dict, returns = parse_contracts_from_docstring(function_)

            if not accepts_dict and not returns:
                raise ContractException('No contract specified in docstring.')

    if returns is None:
        returns_parsed = None
    else:
        returns_parsed = parse_flexible_spec(returns)

    accepts_parsed = dict([(x, parse_flexible_spec(accepts_dict[x]))
                            for x in accepts_dict])

    is_bound_method = 'self' in all_args
    
    def contracts_checker(unused, *args, **kwargs):
        do_checks = not all_disabled()
        if not do_checks:
            return function_(*args, **kwargs)

        nice_function_display = '%s()' % function_.__name__
        if is_bound_method:
            klass = type(args[0]).__name__
            nice_function_display = klass + ':' + nice_function_display  

        bound = getcallargs(function_, *args, **kwargs)

        try:
            context = {}
            # add self if we are a bound method
            if is_bound_method:
                context['self'] = args[0]

            for arg in all_args:
                if arg in accepts_parsed:
                    accepts_parsed[arg]._check_contract(context, bound[arg])

        except ContractNotRespected as e:
            msg = ('Breach for argument %r to %s.\n'
                   % (arg, nice_function_display))
            e.error = msg + e.error
            raise e

        result = function_(*args, **kwargs)

        if returns_parsed is not None:
            try:
                returns_parsed._check_contract(context, result)
            except ContractNotRespected as e:
                msg = ('Breach for return value of %s.\n'
                       % (nice_function_display))
                e.error = msg + e.error
                raise e

        return result

    # TODO: add rtype statements if missing

    if modify_docstring:
        def write_contract_as_rst(c):
            return '``%s``' % c

        if function_.__doc__ is not None:
            docs = DocStringInfo.parse(function_.__doc__)
        else:
            docs = DocStringInfo("")
        for param in accepts_parsed:
            if not param in docs.params:
#                default = '*not documented*'
                default = ''
                docs.params[param] = Arg(default, None)

            docs.params[param].type = \
                write_contract_as_rst(accepts_parsed[param])

        if returns_parsed is not None:
            if not docs.returns:
                docs.returns.append(Arg(None, None))
            docs.returns[0].type = write_contract_as_rst(returns_parsed)
        new_docs = docs.__str__()

    else:
        new_docs = function_.__doc__

    # XXX: why doesn't this work?
    contracts_checker.__name__ = 'checker-for-%s' % function_.__name__
    contracts_checker.__module__ = function_.__module__

    # TODO: is using functools.wraps better?
    from decorator import decorator
    wrapper = decorator(contracts_checker, function_)

    wrapper.__doc__ = new_docs
    wrapper.__name__ = function_.__name__
    wrapper.__module__ = function_.__module__

    wrapper.__contracts__ = dict(returns=returns_parsed, **accepts_parsed)
    return wrapper


def parse_flexible_spec(spec):
    ''' spec can be either a Contract, a type, or a contract string. 
        In the latter case, the usual parsing takes place'''
    if isinstance(spec, Contract):
        return spec
    elif isinstance(spec, str):
        return parse_contract_string(spec)
    elif can_be_used_as_a_type(spec):
        from .library import CheckType
        return CheckType(spec)
    else:
        raise ContractException('I want either a string or a type, not %s.'
                                % describe_value(spec))


def parse_contracts_from_docstring(function):
    annotations = DocStringInfo.parse(function.__doc__)

    if len(annotations.returns) > 1:
        raise ContractException('More than one return type specified.')

    def remove_quotes(x):
        ''' Removes the double back-tick quotes if present. '''
        if x is None:
            return None
        if x.startswith('``') and x.endswith('``') and len(x) > 3:
            return x[2:-2]
        elif x.startswith('``') or x.endswith('``'):
            msg = 'Malformed quoting in string %r.' % x
            raise ContractException(msg)
        else:
            return x

    if len(annotations.returns) == 0:
        returns = None
    else:
        returns = remove_quotes(annotations.returns[0].type)

    # These are the annotations
    params = annotations.params
    name2type = dict([(name, remove_quotes(params[name].type))
                       for name in params])

    # Check the ones that do not have contracts specified
    nullparams = [name for name in params if params[name].type is None]
    if nullparams:
        msg = ('The parameter(s) %r in this docstring have no type statement.'
                % (",".join(nullparams)))
        msg += """

Note: you can use the asterisk if you do not care about assigning
a contract to a certain parameter:

    :param x: 
    :type x: *
"""
        raise MissingContract(msg)

    # Let's look at the parameters:
    all_args = get_all_arg_names(function)

    # Check we don't have extra:
    for name in name2type:
        if not name in all_args:
            msg = ('A contract was specified for argument %r which I cannot'
                   ' find in my list of arguments (%r)' % 
                    (name, all_args))
            raise ContractException(msg)

    if len(name2type) != len(all_args):  # pragma: no cover
        pass
        # TODO: warn?

    return name2type, returns

inPy3k = sys.version_info[0] == 3


def get_annotations(function):
    return getfullargspec(function).annotations


def get_all_arg_names(function):
    spec = getfullargspec(function)
    possible = spec.args + [spec.varargs, spec.varkw] + spec.kwonlyargs
    all_args = [x for x in possible if x]
    return all_args


def check(contract, object, desc=None, **context):  # @ReservedAssignment
    ''' 
        Checks that ``object`` satisfies the contract 
        described by ``contract``.
    
        :param contract: The contract string.
        :type contract:  str
        
        :param object: Any object.
        :type object: ``*``

        :param desc: An optional description of the error. If given, 
                     it is included in the error message.
        :type desc: ``None|str``
    '''
    if not isinstance(contract, str):
        # XXX: make it more liberal?
        raise ValueError('I expect a string (contract spec) as the first '
                         'argument, not a %s.' % describe_value(contract))
    try:
        return check_contracts([contract], [object], context)
    except ContractNotRespected as e:
        if desc is not None:
            e.error = '%s\n%s' % (desc, e.error)
        raise e


def fail(contract, value, **initial_context):
    ''' Checks that the value **does not** respect this contract.
        Raises an exception if it does. 
       
       :raise: ValueError 
    '''
    try:
        parsed_contract = parse_contract_string(contract)
        context = check_contracts([contract], [value], initial_context)
    except ContractNotRespected:
        pass
    else:
        msg = 'I did not expect that this value would satisfy this contract.\n'
        msg += '-    value: %s\n' % describe_value(value)
        msg += '- contract: %s\n' % parsed_contract
        msg += '-  context: %r' % context
        raise ValueError(msg)


def check_multiple(couples, desc=None):
    ''' 
        Checks multiple couples of (contract, value) in the same context. 
        
        This means that the variables in each contract are shared with 
        the others. 
        
        :param couples: A list of tuple (contract, value) to check.
        :type couples: ``list[>0](tuple(str, *))``
        
        :param desc: An optional description of the error. If given, 
                     it is included in the error message.
        :type desc: ``None|str``
    '''

    check('list[>0](tuple(str, *))', couples,
          'I expect a non-empty list of (object, string) tuples.')
    contracts = [x[0] for x in couples]
    values = [x[1] for x in couples]
    try:
        return check_contracts(contracts, values)
    except ContractNotRespected as e:
        if desc is not None:
            e.error = '%s\n%s' % (desc, e.error)
        raise e


def new_contract(*args):
    ''' Defines a new contract type. Used both as a decorator and as 
        a function.
    
        **1) Use as a function.** The first parameter must be a string. 
        The second parameter can be either
        a string or a callable function.  ::
        
            new_contract('new_contract_name', 'list[N]') 
            new_contract('new_contract_name', lambda x: isinstance(x, list) )
            
        - If it is a string, it is interpreted as contract expression; 
          the given identifier will become an alias
          for that expression. 
          
        - If it is a callable, it must accept one parameter, and either:
          
          * return True or None, to signify it accepts.
          
          * return False or raise ValueError or AssertionError, 
            to signify it doesn't.
          
          If ValueError is raised, its message is used in the error.

        **2) Use as a decorator.**

        Or, it can be used as a decorator (without arguments).
        The function name is used as the identifier. ::
        
            @new_contract
            def new_contract_name(x):
                return isinstance(x, list)
        
          
        This function returns a :py:class:`Contract` object. It might be
        useful to check right away if the declaration is what you meant,
        using :py:func:`Contract.check` and :py:func:`Contract.fail`.  
        
        :param identifier: The identifier must be a string not already in use
                          (you cannot redefine ``list``, ``tuple``, etc.).
        :type identifier: str 
        
        :param condition: Definition of the new contract.
        :type condition: ``type|callable|str``
        
        :return: The equivalent contract -- might be useful for debugging.
        :rtype: Contract
    '''
    if args and len(args) == 1 and isinstance(args[0], types.FunctionType):
        # TODO: add here for class decorator
        # We were called without parameters
        function = args[0]
        identifier = function.__name__
        new_contract_impl(identifier, function)
        return function
    else:
        return new_contract_impl(*args)


def new_contract_impl(identifier, condition):
    # Be friendly
    if not isinstance(identifier, str):
        raise ValueError('I expect the identifier to be a string; '
                         'received %s.' % 
                         describe_value(identifier))

    # Make sure it is not already an expression that we know.
    #  (exception: allow redundant definitions. To this purpose,
    #   skip this test if the identifier is already known, and catch
    #   later if the condition changed.)
    if identifier in Extension.registrar:
        # already known as identifier; check later if the condition 
        # remained the same.
        pass
    else:
        # check it does not redefine list, tuple, etc.
        try:
            c = parse_contract_string(identifier)
            msg = ('Invalid identifier %r; it overwrites an already known '
                   'expression. In fact, I can parse it as %s (%r).' % 
                             (identifier, c, c))
            raise ValueError(msg)
        except ContractSyntaxError:
            pass

    # Make sure it corresponds to our idea of identifier
    try:
        c = identifier_expression.parseString(identifier, parseAll=True)  # @UndefinedVariable
    except ParseException as e:
        where = Where(identifier, line=e.lineno, column=e.col)
        # msg = 'Error in parsing string: %s' % e 
        msg = ('The given identifier %r does not correspond to my idea '
               'of what an identifier should look like;\n%s\n%s'
                 % (identifier, e, where))
        raise ValueError(msg)

    # Now let's check the condition
    if isinstance(condition, str):
        # We assume it is a condition that should parse cleanly
        try:
            # could call parse_flexible_spec as well here
            bare_contract = parse_contract_string(condition)
        except ContractSyntaxError as e:
            msg = ('The given condition %r does not parse cleanly: %s' % 
                   (condition, e))
            raise ValueError(msg)
    # Important: types are callable, so check this first.
    elif can_be_used_as_a_type(condition):
        # parse_flexible_spec can take care of types
        bare_contract = parse_flexible_spec(condition)
    # Lastly, it should be a callable
    elif hasattr(condition, '__call__'):
        # Check that the signature is right
        if can_accept_self_plus_one_argument(condition):
            bare_contract = CheckCallableWithSelf(condition)
        else:
            can, error = can_accept_exactly_one_argument(condition)
            if not can:
                msg = ('The given callable %r should be able to accept '
                      'exactly one argument. Error: %s ' % (condition, error))
                raise ValueError(msg)
            bare_contract = CheckCallable(condition)
    else:
        raise ValueError('I need either a string or a callable for the '
                         'condition; found %s.' % describe_value(condition))

    # Separate the context if needed
    if isinstance(bare_contract, (CheckCallable, CheckCallableWithSelf)):
        contract = bare_contract
    else:
        contract = SeparateContext(bare_contract)

    # It's okay if we define the same thing twice
    if identifier in Extension.registrar:
        old = Extension.registrar[identifier]
        if not(contract == old):
            msg = ('Tried to redefine %r with a definition that looks '
                   'different to me.\n' % identifier)
            msg += ' - old: %r\n' % old
            msg += ' - new: %r\n' % contract
            raise ValueError(msg)
    else:
        Extension.registrar[identifier] = contract

    # Check that we can parse it now
    try:
        c = parse_contract_string(identifier)
        expected = Extension(identifier)
        assert c == expected, \
              'Expected %r, got %r.' % (c, expected)  # pragma: no cover
    except ContractSyntaxError as e:  # pragma: no cover
        assert False, 'Cannot parse %r: %s' % (identifier, e)

    return contract
#    return bare_contract
#    return condition


inPy2 = sys.version_info[0] == 2
if inPy2:
    from types import ClassType


def can_be_used_as_a_type(x):
    ''' Checks that x can be used as a type; specifically,
        we can write isintance(y,x). 
        Here we support old-style classes. 
    '''
    if isinstance(x, type):
        return True

    if inPy2:
        if isinstance(x, ClassType):
            return True

    return False


def can_accept_exactly_one_argument(callable_thing):
    ''' Checks that a callable can accept exactly one argument
        using introspection.
    '''
    if inspect.ismethod(callable_thing):  # bound method
        f = callable_thing.__func__
        args = (callable_thing.__self__, 'test',)
    else:
        if not inspect.isfunction(callable_thing):
            f = callable_thing.__call__
        else:
            f = callable_thing
        args = ('test',)

    try:
        getcallargs(f, *args)
    except (TypeError, ValueError) as e:  # @UnusedVariable
        # print 'Get call args exception (f=%r,args=%r): %s ' % (f, args, e)
        return False, str(e)
    else:
        return True, None


def can_accept_self_plus_one_argument(callable_thing):
    ''' Checks that a callable can accept exactly self plus one argument
        using introspection.
    '''

    if inspect.ismethod(callable_thing):  # bound method
        f = callable_thing.__func__
    else:
        if not inspect.isfunction(callable_thing):
            f = callable_thing.__call__
        else:
            f = callable_thing

    spec = getfullargspec(f)
    if len(spec.args) == 0 or spec.args[0] != 'self':
        return False

    try:
        getcallargs(f, 'self', 'value')
    except (TypeError, ValueError) as e:  # @UnusedVariable
        return False
    else:
        return True

    return False



########NEW FILE########
__FILENAME__ = metaclass
from .main import contracts_decorate
from .utils import indent
from abc import ABCMeta
from contracts import ContractException
from types import FunctionType
import traceback


__all__ = ['ContractsMeta']


def is_function_or_static(f):
    is_normal_function = isinstance(f, FunctionType)
    is_staticmethod = isinstance(f, staticmethod)
    is_classmethod = isinstance(f, classmethod)
    return is_normal_function or is_staticmethod or is_classmethod
    
class ContractsMeta(ABCMeta):
    """ 
        This metaclass lets the subclasses inherit the specifications. 
        Very useful for abstract commands.
    
    """

    def __init__(cls, clsname, bases, clsdict):  # @UnusedVariable @NoSelf
        ABCMeta.__init__(cls, clsname, bases, clsdict)
        
        for k, f in clsdict.items():
            is_normal_function = isinstance(f, FunctionType)
            is_staticmethod = isinstance(f, staticmethod)
            is_classmethod = isinstance(f, classmethod)
            
            if not (is_normal_function or is_staticmethod or is_classmethod):
                # print('skipping %s:%s, %s' % (clsname, k, f))
                continue
            if k == '__init__': 
                continue
            
            this_function = '%s:%s()' % (clsname, k)  # @UnusedVariable
            # print('considering %s' % this_function)

            superclasses = cls.mro()[1:]
            for b in superclasses:
                if k in b.__dict__:
                    f0 = b.__dict__[k]
                    if is_function_or_static(f0):
                        if isinstance(f0, classmethod):
                            # print('found ancestor classmethod')
                            pass
                        elif isinstance(f0, staticmethod):
                            # print('found ancestor staticmethod')
                            pass
                        else:
                            assert isinstance(f0, FunctionType)
                            if '__contracts__' in f0.__dict__:
                                spec = f0.__contracts__
                                # msg = 'inherit contracts for %s:%s() from %s' % (clsname, k, b.__name__)
                                # print(msg)
                                # TODO: check that the contracts are a subtype
                                try:
                                    f1 = contracts_decorate(f, **spec)
                                except ContractException as e:
                                    msg = 'Error while applying ContractsMeta magic.\n'
                                    msg += '  subclass:  %s\n' % clsname
                                    msg += '      base:  %s\n' % b.__name__
                                    msg += '  function:  %s()\n' % k
                                    msg += 'Exception:\n'
                                    msg += indent(traceback.format_exc(e), '| ') + '\n'
                                    msg += '(most likely parameters names are different?)'
                                    raise ContractException(msg)       
                                setattr(cls, k, f1)
                                break
                    else:
                        pass
                else:
                    # print(' X not found in %s' % b.__name__)
                    pass
                    
                        
            else:
                pass
                # print(' -> No inheritance for %s' % this_function)
        

########NEW FILE########
__FILENAME__ = pyparsing_utils
from .syntax import (Forward, Suppress, FollowedBy, Group, OneOrMore, Optional,
                     opAssoc)


def myOperatorPrecedence(baseExpr, opList):
    """Helper method for constructing grammars of expressions made up of
       operators working in a precedence hierarchy.  Operators may be unary or
       binary, left- or right-associative.  Parse actions can also be attached
       to operator expressions.

       Parameters:
        - baseExpr - expression representing the most basic element for the
        - opList - list of tuples, one for each operator precedence level in 
          expression grammar; each tuple is of the form
          (opExpr, numTerms, rightLeftAssoc, parseAction), where:
           - opExpr is the pyparsing expression for the operator;
              may also be a string, which will be converted to a Literal;
              if numTerms is 3, opExpr is a tuple of two expressions, for the
              two operators separating the 3 terms
           - numTerms is the number of terms for this operator (must
              be 1, 2, or 3)
           - rightLeftAssoc is the indicator whether the operator is
              right or left associative, using the pyparsing-defined
              constants opAssoc.RIGHT and opAssoc.LEFT.
           - parseAction is the parse action to be associated with
              expressions matching this operator expression (the
              parse action tuple member may be omitted)
    """
    ret = Forward()
    allops = [x[0] for x in opList]
    opnames = ",".join(str(x) for x in allops)
    ret.setName('operatorSystem(%s)' % opnames)
#    parenthesis = Suppress('(') + ret + FollowedBy(NotAny(oneOf(allops))) - Suppress(')')
    parenthesis = Suppress('(') - ret - Suppress(')')
    lastExpr = parenthesis.setName('parenthesis(%s)' % opnames) | baseExpr
    lastExpr.setName('Base operand (%s) or parenthesis' % baseExpr.name)
    for operDef in opList:
        opExpr, arity, rightLeftAssoc, pa = (operDef + (None,))[:4]
        if arity == 3:
            if opExpr is None or len(opExpr) != 2:
                raise ValueError("if numterms=3, opExpr must be a tuple or list of two expressions")
            opExpr1, opExpr2 = opExpr
        thisExpr = Forward().setName("operation_with(%s)" % opExpr)
        if rightLeftAssoc == opAssoc.LEFT:
            if arity == 1:
                matchExpr = FollowedBy(lastExpr + opExpr) + Group(lastExpr + OneOrMore(opExpr))
            elif arity == 2:
                if opExpr is not None:
#                    matchExpr = Group(lastExpr + FollowedBy(opExpr) + OneOrMore(opExpr - lastExpr))                
                    matchExpr = Group(lastExpr + FollowedBy(opExpr) - OneOrMore(opExpr - lastExpr))
                else:
                    matchExpr = FollowedBy(lastExpr + lastExpr) + Group(lastExpr + OneOrMore(lastExpr))
            elif arity == 3:
                matchExpr = FollowedBy(lastExpr + opExpr1 + lastExpr + opExpr2 + lastExpr) + \
                            Group(lastExpr + opExpr1 + lastExpr + opExpr2 + lastExpr)
            else:
                raise ValueError("operator must be unary (1), binary (2), or ternary (3)")
        elif rightLeftAssoc == opAssoc.RIGHT:
            if arity == 1:
                # try to avoid LR with this extra test
                if not isinstance(opExpr, Optional):
                    opExpr = Optional(opExpr)
                matchExpr = FollowedBy(opExpr.expr - thisExpr) - Group(opExpr - thisExpr)
            elif arity == 2:
                if opExpr is not None:
                    matchExpr = FollowedBy(lastExpr + opExpr - thisExpr) + Group(lastExpr + OneOrMore(opExpr - thisExpr))
                else:
                    matchExpr = FollowedBy(lastExpr + thisExpr) + Group(lastExpr + OneOrMore(thisExpr))
            elif arity == 3:
                matchExpr = FollowedBy(lastExpr + opExpr1 + thisExpr + opExpr2 + thisExpr) + \
                            Group(lastExpr + opExpr1 + thisExpr + opExpr2 + thisExpr)
            else:
                raise ValueError("operator must be unary (1), binary (2), or ternary (3)")
        else:
            raise ValueError("operator must indicate right or left associativity")
        if pa:
            matchExpr.setParseAction(pa)
        thisExpr << (matchExpr | lastExpr).setName('operation with %s' % opExpr)
        lastExpr = thisExpr
    ret << lastExpr
    return ret

########NEW FILE########
__FILENAME__ = syntax
from numbers import Number
import math


# All the imports from pyparsing go here
from pyparsing import (delimitedList, Forward, Literal,  # @UnusedImport
  stringEnd, nums, Word, CaselessLiteral, Combine,  # @UnusedImport
  Optional, Suppress, OneOrMore, ZeroOrMore, opAssoc,  # @UnusedImport
  operatorPrecedence, oneOf, ParseException, ParserElement,  # @UnusedImport
  alphas, alphanums, ParseFatalException,  # @UnusedImport
  ParseSyntaxException, FollowedBy, NotAny, Or,  # @UnusedImport
  MatchFirst, Keyword, Group, White, lineno, col)  # @UnusedImport


from .pyparsing_utils import myOperatorPrecedence

# Enable memoization (much faster!)
ParserElement.enablePackrat()

from .interface import Where


class ParsingTmp:
    # TODO: FIXME: decide on an order, if we do the opposite it doesn't work.
    contract_types = []
    rvalues_types = []
    keywords = []


def add_contract(x):
    ParsingTmp.contract_types.append(x)


def add_keyword(x):
    ''' Declares that x is a keyword --- this is useful to have more
        clear messages. "keywords" are not parsed by Extension.
        (see extensions.py) and allows to have "deep" error indications.
        See http://pyparsing.wikispaces.com/message/view/home/620225
        and the discussion of the "-" operator in the docs.
    '''
    ParsingTmp.keywords.append(x)

W = Where


O = Optional
S = Suppress

number = Word(nums)
point = Literal('.')
e = CaselessLiteral('E')
plusorminus = Literal('+') | Literal('-')
integer = Combine(O(plusorminus) + number)
floatnumber = Combine(integer + (point + O(number)) ^ (e + integer))
integer.setParseAction(lambda tokens: SimpleRValue(int(tokens[0])))
floatnumber.setParseAction(lambda tokens: SimpleRValue(float(tokens[0])))
pi = Keyword('pi').setParseAction(lambda tokens: SimpleRValue(math.pi, 'pi'))  # @UnusedVariable

def isnumber(x):
    # These are scalar quantities that we can compare (=,>,>=, etc.)
    if isinstance(x, Number):
        return True
    try: 
        # Slow, do it only once (TODO)
        import numpy
        return isinstance(x, numpy.number)
    except:
        return False
    

rvalue = Forward()
rvalue.setName('rvalue')
contract_expression = Forward()
contract_expression.setName('contract')
simple_contract = Forward()
simple_contract.setName('simple_contract')

# Import all expressions -- they will call add_contract()
from .library import (EqualTo, Unary, Binary, composite_contract,
                      identifier_contract, misc_variables_contract,
                      int_variables_contract, int_variables_ref,
                      misc_variables_ref, SimpleRValue)


number = pi | floatnumber | integer
operand = number | int_variables_ref | misc_variables_ref
operand.setName('r-value')


rvalue << myOperatorPrecedence(operand, [
             ('-', 1, opAssoc.RIGHT, Unary.parse_action),
             ('*', 2, opAssoc.LEFT, Binary.parse_action),
             ('-', 2, opAssoc.LEFT, Binary.parse_action),
             ('+', 2, opAssoc.LEFT, Binary.parse_action),
          ])

# I want 
# - BindVariable to have precedence to EqualTo(VariableRef)
# but I also want:
# - Arithmetic to have precedence w.r.t BindVariable 
# last is variables
add_contract(misc_variables_contract)
add_contract(int_variables_contract)
add_contract(rvalue.copy().setParseAction(EqualTo.parse_action))

hardwired = MatchFirst(ParsingTmp.contract_types)
hardwired.setName('Predefined contract expression')

simple_contract << (hardwired | identifier_contract)
simple_contract.setName('simple contract expression')

any_contract = composite_contract | simple_contract
any_contract.setName('Any simple or composite contract')
contract_expression << (any_contract)  # Parentheses before << !!


########NEW FILE########
__FILENAME__ = array_extended_test
try:
    import numpy
except ImportError:
    pass
else:

    import unittest

    from contracts import decorate, new_contract, ContractNotRespected

    new_contract('rgb', 'array[HxWx3],H>0,W>0')
    new_contract('rgba', 'array[HxWx4],H>0,W>0')

    def blend_function(image1, image2, bug=False):
        '''
            Blends two RGB or RGBA images together.
            
             :param image1: The first image to blend.
             :type image1: (rgb|rgba),array[HxWx*]
             :param image2: The second image to blend.
             :type image2: (rgb|rgba),array[HxWx*]
             :param bug: Introduce a bug to check the contracts.
             :type bug: bool

             :return: The blended image.
             :rtype: rgb,array[HxWx3]
        '''
        H, W = image1.shape[0], image1.shape[1]

        if bug:
            # if we want to show a bug, return a different shape
            W += 1

        result = numpy.zeros((H, W, 3), 'uint8')

        # put here the actual function
        image2

        return result

    im_float = numpy.zeros((10, 10, 3), dtype='float32')
    rgb_small = numpy.zeros((10, 10, 3), dtype='uint8')
    rgb_large = numpy.zeros((20, 20, 3), dtype='uint8')

    rgba_small = numpy.zeros((10, 10, 3), dtype='uint8')
    rgba_large = numpy.zeros((20, 20, 3), dtype='uint8')

    class ArrayTest(unittest.TestCase):

        def setUp(self):
            self.blend = decorate(blend_function)

        def test_correct_behavior(self):
            self.blend(rgb_small, rgb_small)
            self.blend(rgb_small, rgba_small)
            self.blend(rgba_small, rgb_small)
            self.blend(rgb_large, rgba_large)
            self.blend(rgba_large, rgb_large)

        def test_incorrect1(self):
            self.assertRaises(ContractNotRespected, self.blend, None, None)

        def test_incorrect2(self):
            self.assertRaises(ContractNotRespected, self.blend,
                              None, rgb_small)

        def test_incorrect3(self):
            self.assertRaises(ContractNotRespected, self.blend,
                              rgb_small, None)

        def test_incorrect4(self):
            self.assertRaises(ContractNotRespected, self.blend,
                              rgb_small, rgb_large)

        def test_incorrect5(self):
            self.assertRaises(ContractNotRespected, self.blend,
                              rgb_small, rgb_large)

        def test_incorrect6(self):
            # check that rtype checking works, introduce a bug
            self.assertRaises(ContractNotRespected, self.blend, rgb_small,
                              rgb_small, bug=True)


########NEW FILE########
__FILENAME__ = friendliness_statistics
from contracts.test_registrar import (good_examples, semantic_fail_examples,
                                      contract_fail_examples)
from contracts import parse, ContractSyntaxError


def get_all_strings():
    all_strings = (good_examples + semantic_fail_examples +
                   contract_fail_examples)
    for contract, _, _ in all_strings:
        if isinstance(contract, list):
            for c in contract:
                yield c
        else:
            yield contract

# went from 89.9% to 95.7%


def main():
    examples = get_all_strings()

    differences = run_joker(examples)

    diff = list(differences)
    unfriendliness = sum(diff) / len(diff)

    friendliness = 100 - 100 * unfriendliness
    print("Friendliness: %.2f%% " % friendliness)


def replace_one(s, i, c):
    assert i >= 0 and i < len(s)
    return s[:i] + c + s[i + 1:]

assert replace_one('python', 1, 'a') == 'pathon'
s = 'python'
for i in range(len(s)):
    s2 = replace_one(s, i, '~')
    s3 = replace_one(s2, i, s[i])
    assert s == s3, 'i=%d  %r -> %r -> %r' % (i, s, s2, s3)


def run_joker(examples):

    for s in examples:
        # make sure we can parse it
        parse(s)

        # now alter one letter
        for i in range(len(s)):
            s2 = replace_one(s, i, '~')

            try:
                parse(s2)

            except ContractSyntaxError as e:
                detected = e.where.col - 1
                displacement = i - detected
#                if  displacement < 0:
#                    print displacement
#                    print e
                assert displacement >= 0

                value = displacement * 1.0 / len(s)
                if displacement > 0:
                    print(e)
#                    assert False

                yield value


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = arithmetic_tc
from . import syntax_fail, good, fail

syntax_fail('=1+')
syntax_fail('=1-')
syntax_fail('=1*')

for number in [1, 1.0, 1e10, -1]:
    good('=%r' % number, number)
    good('%r' % number, number)

good('=2', 2)
good('=1+1', 2)
good('1+1', 2)
good('=1-1', 0)
good('1-1', 0)

# unary operators

good('N,-N=-1', 1)

good(['N', 'N-1'], [1, 0])
good(['N', 'N+1'], [1, 2])

good(['N', 'N-1'], [1, 0])
good(['N', 'N*4'], [1, 4])
good(['N', 'Y,N==Y+1'], [5, 4])

# Checking precedence
good('1+2*3', 7)
good('2*3+1', 7)
# Now with parentheses
good('=1+1*3', 4)
good('=(1+1)*3', 6)

good('1+1+1', 3)
good('2*2*2', 8)
good('2-1-1', 0)

# Wrong math
fail('x,x+1=0', 'ciao')
fail('x,-x=0', 'ciao')

# Binding to non-existing variable
fail('N+1=0', 1)

########NEW FILE########
__FILENAME__ = array_elements_tc
import numpy

from . import good, fail

arr01 = numpy.array([0, 1, 0, 1])
arr012 = numpy.array([0, 1, 0, 2])
arr124 = numpy.array([1, 2, 4])
arr125 = numpy.array([1, 2, 5])

good('array(=0|=1|=2)', arr01)
good('array(=0|=1|=2)', arr012)
good('array(=0|=1)', arr01)
fail('array(=0|=1)', arr012)

good('array(=4|>=0,<=2)', arr124)
good('array(=5|>=0,<=2)', arr125)
fail('array(=4|>=2,<=0)', arr124)

arr01int16 = numpy.zeros((3,), 'int16')
good('array(int16,(=0|=1))', arr01int16)

########NEW FILE########
__FILENAME__ = array_tc
from numpy import zeros, ones
import numpy as np

from . import syntax_fail, good, fail
from contracts.library.array import np_int_dtypes, np_uint_dtypes, \
    np_float_dtypes

a_u8 = np.zeros((3, 4), dtype='uint8')
a_i8 = np.zeros((3, 4), dtype='int8')
a_u16 = np.zeros((3, 4), dtype='uint16')
a_i16 = np.zeros((3, 4), dtype='int16')
a_u32 = np.zeros((3, 4), dtype='uint32')
a_i32 = np.zeros((3, 4), dtype='int32')
a_f32 = np.zeros((3, 4), dtype='float32')
a_f64 = np.zeros((3, 4), dtype='float64')
a_bool = np.zeros((3, 4), dtype='bool')

# ## Strings
good('array', a_f32)
good('array', a_f64)
# synonims
good('ndarray', a_f32, exact=False)  # will be canonicalized to "array"
good('ndarray', a_f64, exact=False)  # same
fail('array', [0, 1])
# dtypes
good('array(uint8)', a_u8)
good('array(u1)', a_u8)
good('array(int8)', a_i8)
good('array(i1)', a_i8)
good('array(float32)', a_f32)
good('array(float64)', a_f64)
good('array(bool)', a_bool)
fail('array(float64)', a_f32)
fail('array(float32)', a_f64)
fail('array(uint8)', a_f32)
fail('array(float32)', a_u8)

# shapes
a0d = np.zeros((), dtype='float32')
a1d = np.zeros((2,))
a2d = np.zeros((2, 4,))
a3d = np.zeros((2, 4, 8))

good('shape[0]', a0d)
good('shape[1]', a1d)
good('shape[2]', a2d)
good('shape[3]', a3d)
fail('shape[>0]', a0d)
fail('shape[<1]', a1d)
fail('shape[>2]', a2d)
fail('shape[<3]', a3d)
good(['shape[x]', 'shape[y],x=y'], [a3d, a3d])
good(['shape[x]', 'shape[y],x=y'], [a2d, a2d])
good(['shape[x]', 'shape[y],x=y'], [a1d, a1d])
good(['shape[x]', 'shape[y],x=y'], [a0d, a0d])

good('array[2x4]', a2d)
fail('array[AxBxC]', a2d)
fail('array[2x4]', a3d)

good('array[HxW],H=2,W>3', a2d)
good('array[(=2)x(>3)]', a2d, exact=False)  # Parenthesis are unnecessary

# ellipsis to mean 0 or more dimensions 
good('array[2x4x...]', a2d)
good('array[2x4x...]', a3d)

# if we really want more, use:
good('shape[>2],array[2x4x...]', a3d)
fail('shape[>2],array[2x4x...]', a2d)

fail('shape[>2]', [2, 2, 3])

# Try some binding:
good('array[XxYx...],X=2,Y=4', a3d)

# We don't do in between yet
syntax_fail('array[2x...x3]')

# We don't do in between yet
syntax_fail('array[2x...x3]')
# Try some binding:
good('array[XxYx...],X=2,Y=4', a2d)
good('array[XxYx...],X=2,Y=4', a3d)

# Using the array syntax  array[shape desc]

v1d = np.zeros(100)
v2d = np.zeros((10, 10))
good('array[100]', v1d)
fail('array[100]', v2d)
good('array[10x10]', v2d)
fail('array[10x...]', v1d)
good('array[10x...]', v2d)

fail('shape[>0]', a0d)
fail('shape[<1]', a1d)
fail('shape[>2]', a2d)
fail('shape[<3]', a3d)
good('shape[0]', a0d)
good('shape[1]', a1d)
good('shape[2]', a2d)
good('shape[3]', a3d)
# TODO: check this
# good('array[shape[3]]', a3d)

good('array[1x2]', zeros((1, 2)))

# Now: special comparisons for arrays
A = np.array([0, 1, 2])
B = np.array([10, 20, 30])
good('array(>=0)', A)
good('array(<=2)', A)
fail('array(<=20)', B)
good('array(=0)', zeros((10)))
fail('array(=0)', np.array([0, 1, 0]))
good('array(=1)', ones((10)))

good(['shape(x)', 'shape(x)'], [a2d, a2d])
fail(['shape(x)', 'shape(x)'], [a2d, a3d])

good('array[NxN](<=1)', np.ones((10, 10)))
good('array[NxN](<=1,float32)', np.ones((10, 10), dtype='float32'))
good('array[NxN](<=1,float32|float64)', np.ones((10, 10), dtype='float64'))
good('array[NxN](<=1,(float32|float64))',
     np.ones((10, 10), dtype='float64'))
good('array[NxN](<=1,>=1)', np.ones((10, 10)))

# more complicated tests

good('array[(2|3)xN]', np.ones((2, 10)))
good('array[(2|3)xN]', np.ones((3, 10)))
fail('array[(2|3)xN]', np.ones((4, 10)))
good('array[(2|3)x...]', np.ones((2, 10)))
good('array[(2|3)x...]', np.ones((3, 10)))
fail('array[(2|3)x...]', np.ones((4, 10)))

good('array[(2,*)xN]', np.ones((2, 10)))
fail('array[(2,3)xN]', np.ones((4, 10)))
good('array[(2,*)x...]', np.ones((2, 10)))
fail('array[(2,3)x...]', np.ones((4, 10)))


good('seq', np.ones(3))
good('seq[3]', np.ones(3))
fail('seq[3]', np.ones(2))
good('seq[6]', np.ones((2, 3)))
fail('seq[6]', np.ones((2, 4)))

# "finite" contract 
good('finite', 1)
good('finite', 0)
good('finite', -1)
good('finite', np.float(1))
fail('finite', np.inf)
fail('finite', np.nan)


# generalized ideas of numbers
# np_ints = ['int8', 'int16', 'int32', 'int64',
#            'uint8', 'uint16', 'uint32', 'uint64',
#            ]
# np_floats = ['float32', 'float64']

good('array(float)', np.array(1.32, 'float32'))


for dt in np_int_dtypes:
    x = np.array(1).astype(dt)
    good('number', x)
    fail('Number', x)

    good('array(int)', x)
    good('int', x)
    fail('Int', x)

    fail('array(float)', x)
    fail('float', x)
    fail('Float', x)
    
# generalized ideas of numbers
for dt in np_float_dtypes:
    x = np.array(1).astype(dt)
    good('number', x)
    fail('Number', x)
    
    fail('array(int)', x)
    fail('int', x)
    fail('Int', x)

    good('array(float)', x)
    good('float', x)
    fail('Float', x)
    
# generalized ideas of numbers
for dt in np_uint_dtypes:
    x = np.array(1).astype(dt)
    good('number', x)
    fail('Number', x)
    
    fail('array(int)', x)
    fail('int', x)
    fail('Int', x)

    good('array(uint)', x)
    fail('Int', x)

    fail('array(float)', x)
    fail('float', x)
    fail('Float', x)


########NEW FILE########
__FILENAME__ = attr_tc
from . import good, fail, syntax_fail


class A(object):
    a = 1
    b = 2

tc_a = A()


class B(object):
    a = 2

tc_b = B()



syntax_fail('attr')  # need at least some attribute

good('attr(a:*)', tc_a)
good('attr(a:int)', tc_a)
good('attr(b:int)', tc_a)
good('attr(b:>1)', tc_a)
good('attr(b:int,>1)', tc_a)
fail('attr(b:int,<=1)', tc_a)

good('attr(a:*)', tc_b)
fail('attr(b:*)', tc_b)

good('attr(a:int;b:int)', tc_a)
good('attr(a:int;b:int)', tc_a)
good('attr(a:int;b:int,>1)', tc_a)
fail('attr(a:int;b:int,<=1)', tc_a)

########NEW FILE########
__FILENAME__ = comparison_tc
from . import good, fail, semantic_fail

# Basic comparisons, unitary syntax
good('=0', 0)
good('==0', 0)
fail('=0', 1)
fail('==0', 1)
good('!=0', 1)
fail('!=0', 0)
good('>0', 1)
fail('>0', 0)
fail('>0', -1)
good('>=0', 1)
good('>=0', 0)
fail('>=0', -1)
good('<0', -1)
fail('<0', 0)
fail('<0', +1)
good('<=0', -1)
good('<=0', 0)
fail('<=0', +1)

# wrong types
good('=1', 1)
semantic_fail('=1', [1])
semantic_fail('=0', [0])

semantic_fail('>0', [])

# binary syntax
good('1>0', None)
fail('1>1', None)
good('0<1', None)
fail('1<1', None)
good('1>=0', None)
fail('1>=2', None)
good('0<=1', None)
fail('2<=1', None)
good('1=1', None)
fail('1=0', None)
good('1==1', None)
fail('1==0', None)
good('0!=1', None)
fail('0!=0', None)

good('1+1>=0', None)
fail('0>=1+1', None)
good('1-1=0', None)
fail('1-1=1', None)
good('-1<=1-1', None)
good('3*2>=2*1', None)


########NEW FILE########
__FILENAME__ = compositions_tc
from . import good, fail

# AND
fail('=0,=1', 0)
good('=0,>=0', 0)

# OR
good('=0|=1', 0)
good('=0|=1', 1)
fail('=0|=1', 2)


good('0|1|2', 2)
good('0|1|2', 1)

good('0|2', 2)
good('0|1|2', 2)
good('0|1|2|3', 2)
good('0|1|2|3|4', 2)
good('0|1|2|3|4|5', 2)

good('list(0|1)', [0, 1, 0])
fail('list(0|1)', [0, 1, 2])


# Check logic and precedence
# & has more precedence than |

good('*|#', None)
good('*|(#,*)', None, exact=False)
good('*|(*,#)', None, exact=False)
good('*|*,#', None)
fail('(*|*),#', None)
good('*,*|#', None)
good('*,#|*', None)
good('*|#|*', None)
fail('*,#,*', None)
fail('*,#|#', None)
good('#|*,(#|*)', None)

########NEW FILE########
__FILENAME__ = dicts_tc
from .  import syntax_fail, good, fail

good('dict', {})
fail('dict', 1)
fail('dict', [])
syntax_fail('dict[]')
syntax_fail('dict[]()')
syntax_fail('dict()')
good('dict[1]', {1: 2})
good('dict[N],N<2', {1: 2})
fail('dict[N],N<2', {1: 2, 3: 4})
good('dict(int:int)', {1: 2})
fail('dict(int:int)', {'a': 2})
good('dict(*:int)', {1: 2})
good('dict(*:int)', {'a': 2})

# dictionary of string -> tuple, with tuple of two elements with different type
good('dict(str:tuple(type(x),type(y))),x!=y', {'a': (2, 1.1)})
fail('dict(str:tuple(type(x),type(y))),x!=y', {'a': (2, 1)})

########NEW FILE########
__FILENAME__ = dummy_tc
from . import good, fail

# dummy
good('*', 0)
good('*', [1])
good('*', None)

fail('#', None)

good('*|#', None)
fail('*,#', None)

########NEW FILE########
__FILENAME__ = isinstance_tc
from . import good, fail

class BaseClass():
    pass

class SubClass(BaseClass):
    pass

good('isinstance(BaseClass)', BaseClass())
good('isinstance(BaseClass)', SubClass())
good('isinstance(SubClass)', SubClass())
fail('isinstance(SubClass)', BaseClass())

class BaseClass2(object):
    pass

class SubClass2(BaseClass2):
    pass

good('isinstance(BaseClass2)', BaseClass2())
good('isinstance(BaseClass2)', SubClass2())
good('isinstance(SubClass2)', SubClass2())
fail('isinstance(SubClass2)', BaseClass2())

# Let's try with 3, old-style

class BaseClass3():
    pass

class MidClass3(BaseClass3):
    pass

class SubClass3(MidClass3):
    pass

good('isinstance(BaseClass3)', BaseClass3())
good('isinstance(BaseClass3)', SubClass3())
good('isinstance(SubClass3)', SubClass3())
fail('isinstance(SubClass3)', BaseClass3())

class BaseClass4(object):
    pass

class MidClass4(BaseClass4):
    pass

class SubClass4(MidClass4):
    pass

good('isinstance(BaseClass4)', BaseClass4())
good('isinstance(BaseClass4)', SubClass4())
good('isinstance(SubClass4)', SubClass4())
fail('isinstance(SubClass4)', BaseClass4())


########NEW FILE########
__FILENAME__ = lists_tc
from . import good, fail


# lists
good('list', [])
fail('list', 'ciao')
good('list[*]', [])
good('list[*]', [1])
good('list[*](*)', [1])
good('list[*](float)', [1.0])
fail('list[*](float)', [1])
good('list[=1]', [0])
good('list[=2]', [0, 1])
fail('list[=2]', [0])
good('list[1]', [0])  # shortcut
good('list[2]', [0, 1])
fail('list[2]', [0])
good('list(int)', [])
good('list(int)', [0, 1])
fail('list(int)', [0, 'a'])
fail('list(int)', [0, 'a'])
good('list(int,>0)', [2, 1])
fail('list(int,>0)', [0, 1])
good('list(int,=0)', [0, 0])
# with parametric lengths 
good('list[N]', [])
good('list[N],N>0', [1])
good('list[N],N=1', [1])
good('list[N],N>0,N<2', [1])
fail('list[N],N>0', [])


########NEW FILE########
__FILENAME__ = map_tc
from .  import syntax_fail, good, fail


good('map', {})
fail('map', 1)
fail('map', [])
syntax_fail('map[]')
syntax_fail('map[]()')
syntax_fail('map()')
good('map[1]', {1: 2})
good('map[N],N<2', {1: 2})
fail('map[N],N<2', {1: 2, 3: 4})
good('map(int:int)', {1: 2})
fail('map(int:int)', {'a': 2})
good('map(*:int)', {1: 2})
good('map(*:int)', {'a': 2})

# mapionary of string -> tuple, with tuple of two elements with different type
good('map(str:tuple(type(x),type(y))),x!=y', {'a': (2, 1.1)})
fail('map(str:tuple(type(x),type(y))),x!=y', {'a': (2, 1)})

########NEW FILE########
__FILENAME__ = miscellaneous_aliases_tc
from . import good, fail

good('Container', []) 
fail('Container', 1)
good('Hashable', 1)
# counterexample? 
good('Iterable', []) 
fail('Iterable', 1)
good('Iterable', {})
good('Iterator', [].__iter__())
fail('Iterator', []) 
good('Sized', [])
good('Sized', {})
fail('Sized', lambda: None)
good('Sized', '')
good('Callable', lambda: None)
fail('Callable', [])
good('Sequence', [])
good('Sequence', (1,))
good('Sequence', '')
fail('Sequence', {})
good('Set', set([]))
fail('Set', [])
good('MutableSequence', [])
fail('MutableSequence', (1,))
good('MutableSet', set([]))
fail('MutableSet', frozenset([]))
good('Mapping', {})
fail('Mapping', [])
good('MutableMapping', {})
#good('MappingView', {}.keys())
#good('ItemsView', {}.items())
#good('ValuesView', {}.values())

########NEW FILE########
__FILENAME__ = separate_context_tc
from .  import good, fail

# dictionary of string -> tuple, with tuple of two elements with different type
# In this case, each value should have the same two types
good('dict(str:tuple(type(x),type(y))),x!=y', {'a': (2, 1.1)})
fail('dict(str:tuple(type(x),type(y))),x!=y', {'a': (2, 1)})

# This fails because we have x=int,y=float followed by float,int
fail('dict(str:tuple(type(x),type(y))),x!=y', {'a': (2, 1.1), 'b': (1.1, 2)})

# Here we force the context to not match using $(...) 
good('dict(str:$(tuple(type(x),type(y)),x!=y))', {'a': (2, 1.1),
                                                  'b': (1.1, 2)})
fail('dict(str:$(tuple(type(x),type(y)),x!=y))', {'a': (2, 1)})

########NEW FILE########
__FILENAME__ = seq_tc
from . import good, fail


# sequences
good('seq', [])
good('seq', ())
good('seq', 'ciao')
fail('seq', {})
good('seq[*]', [])
good('seq[*]', [1])
good('seq[*](*)', [1])
good('seq[*](float)', [1.0])
fail('seq[*](float)', [1])
good('seq[*]', ())
good('seq[*]', (1,))
good('seq[*](*)', (1,))
good('seq[*](float)', (1.0,))
fail('seq[*](float)', (1,))

good('seq[=1]', [0])
good('seq[=2]', [0, 1])
fail('seq[=2]', [0])
good('seq[1]', [0])  # shortcut
good('seq[2]', (0, 1))
fail('seq[2]', (0,))

good('seq[N]', [])
good('seq[N],N>0', [1])
good('seq[N],N=1', [1])
good('seq[N],N>0,N<2', [1])
fail('seq[N],N>0', [])

good('seq[N]', ())
good('seq[N],N>0', (1,))
good('seq[N],N=1', (1,))
good('seq[N],N>0,N<2', (1,))
fail('seq[N],N>0', ())



########NEW FILE########
__FILENAME__ = simple_values_tc
from . import good, fail
import math


good('0', 0)
good('1', 1)
fail('1', 2)

good('pi', math.pi)
fail('pi', math.pi * 2)

########NEW FILE########
__FILENAME__ = strings_tc
from . import syntax_fail, good, fail


### Strings
good('str', 'ciao')
good('string', 'ciao', exact=False)
fail('str', list('ciao'))  # sequences of chars are not str
# Can specify the length
good('str[N]', '')
good('str[1]', 'a')
good('str[2]', 'ab')
good('str[>0]', 'ab')
fail('str[>0]', '')
good('str[N],N>3', 'ciao')
fail('str[N],N>3', 'cia')
# Cannot specify anything on the content
syntax_fail('str(*)')

########NEW FILE########
__FILENAME__ = tuple_tc
from . import syntax_fail, good, fail

   
#### Tuples
good('tuple', ())
good('tuple', (1,))
# tuples and lists are different
fail('tuple', [])
fail('list', ())
# tuples can have the length
good('tuple[*]', (2, 2))
good('tuple[1]', (1,))
# you cannot specify every element
good('tuple(*,*)', (1, 2))
good('tuple(*)', (1,))
fail('tuple(*,*)', (1, 2, 3))
good('tuple(int,int)', (1, 2))
good('tuple(int,float)', (1, 2.0))
fail('tuple(float,float)', (1, 2.0))
good('tuple(type(x),type(x))', (1, 2))
# something complicated: nested tuples
good('tuple(x,tuple(*,*,x))', (1, (2, 3, 1)))
fail('tuple(x,tuple(*,*,x))', (1, (2, 3, 2)))
good('tuple(type(x),tuple(*,*,type(x)))', (1, (2.1, 3.0, 3)))
fail('tuple(type(x),tuple(*,*,type(x)))', (1, (2.1, 3.0, 3.1)))
# cannot specify both, even if coherent
syntax_fail('tuple[*](*,*)')

good('tuple(0,1|2)', (0, 2))
good('tuple(0,1|2)', (0, 2))
good('tuple(0,1|2|3)', (0, 3))
good('tuple(0,1|2|3,4)', (0, 3, 4))
fail('tuple(0,1|2)', (0, 3))
good('tuple(0,1,2)', (0, 1, 2))
good('tuple(1|2,3)', (1, 3))
good('tuple(1,(>2,int))', (1, 3))
fail('tuple(1,(>2,int))', (1, 3.0))
good('tuple(1,(*,*),2)', (1, 3, 2))
good('tuple(str,(str[1],str))', ('a', 'b'))

########NEW FILE########
__FILENAME__ = types_tc
from . import syntax_fail, good, fail, semantic_fail

# basic types

good('int', 1)
fail('int', None)
fail('int', 2.0)
good('float', 1.1)
fail('float', None)
fail('float', 2)

good('number', 1)
good('number', 1.0)
fail('number', [1])

good('bool', False)
good('bool', True)
fail('bool', 1)
fail('bool', 0)

# type contract

good('None', None)
good('NoneType', None)
fail('None', 1)
fail('NoneType', 1)

syntax_fail('type')
syntax_fail('type()')
good('type(x)', 1)
semantic_fail('type(X)', 1)

########NEW FILE########
__FILENAME__ = variables_tc
from . import syntax_fail, good, fail, semantic_fail

# only single letters
syntax_fail('NN')
syntax_fail('xx')

# big letters can only bind to numbers
good('N,N>0', 1)
fail('N,N>0', 0)
semantic_fail('N', [])

# lower case can bind to anything
good('x', 1) 
good('x', [])

########NEW FILE########
__FILENAME__ = test_class_contracts
from contracts import contract, new_contract, ContractNotRespected
import unittest


class ClassContractsTests(unittest.TestCase):

    def test_class_contract1(self):

        class Game(object):
            def __init__(self, legal):
                self.legal = legal

            @new_contract
            def legal_move1(self, move):
                return move in self.legal

            @contract(move='legal_move1')
            def take_turn(self, move):
                pass

        g1 = Game([1, 2])
        g1.take_turn(1)
        g1.take_turn(2)
        self.assertRaises(ContractNotRespected, g1.take_turn, 3)

    def test_class_contract2(self):

        class Game(object):
            def __init__(self, legal):
                self.legal = legal

            @new_contract
            def legal_move2(self, move):
                return move in self.legal

            @contract(move='legal_move2')
            def take_turn(self, move):
                pass

        g1 = Game([1, 2])
        g1.take_turn(1)
        g1.take_turn(2)
        self.assertRaises(ContractNotRespected, g1.take_turn, 3)

    def test_class_contract3(self):

        class Game(object):
            def __init__(self, legal):
                self.legal = legal

            def legal_move(self, move):
                return move in self.legal

            new_contract('alegalmove', legal_move)

            @contract(move='alegalmove')
            def take_turn(self, move):
                pass

        g1 = Game([1, 2])
        g1.take_turn(1)
        g1.take_turn(2)
        self.assertRaises(ContractNotRespected, g1.take_turn, 3)

    def test_class_contract1_bad(self):
        ''' example of bad usage, using the contract from outside '''

        class Game(object):
            def __init__(self, legal):
                self.legal = legal

            @new_contract
            def legal_move4(self, move):
                return move in self.legal

        def go():
            @contract(move='legal_move4')
            def take_turn(move):
                pass

            take_turn(0)

        self.assertRaises(ContractNotRespected, go)




########NEW FILE########
__FILENAME__ = test_decorator
import unittest

from contracts import (decorate, contract,
                ContractException, ContractNotRespected)

from contracts.interface import MissingContract


class DecoratorTests(unittest.TestCase):

    def test_malformed(self):
        def f():
            ''' 
                Wrong syntax 
            
                :rtype okok
            '''
            pass

        self.assertRaises(ContractException, decorate, f)

    def test_malformed2(self):
        def f():
            ''' 
                Wrong syntax 
            
                :rtype: okok
            '''
            pass

        self.assertRaises(ContractException, decorate, f)

    def test_not_specified1(self):
        ''' No docstring specified '''
        def f():
            pass

        self.assertRaises(ContractException, decorate, f)

    def test_not_specified2(self):
        def f():
            ''' No types specified in the docstring '''
            pass

        self.assertRaises(ContractException, decorate, f)

    def test_too_many(self):
        def f():
            ''' 
                Too many rtype clauses.
                :rtype: int
                :rtype: int
            '''
            pass

        self.assertRaises(ContractException, decorate, f)

    def test_invalid1(self):
        def f(a):
            ''' Unknown b.
                :type a: int
                :type b: int
            '''
            pass

        self.assertRaises(ContractException, decorate, f)

    def test_parse_error1(self):
        def f(a, b):
            ''' Same with optional
                :type a: in
                :type b: int
            '''
            pass

        self.assertRaises(ContractException, decorate, f)

    def test_parse_error2(self):
        def f(a, b):
            ''' Same with optional
                :type a: int
                :type b: int
                :rtype: in
            '''
            pass

        self.assertRaises(ContractException, decorate, f)

    def not_supported1(self):
        ''' Support of *args '''

        def f(a, *b):  # @UnusedVariable
            ''' 
                :type a: int
                :type b: tuple(int)
                :rtype: int
            '''
            pass

            decorate(f)

    def not_supported2(self):
        ''' Support of **args '''
        def f(a, **b):
            ''' 
                :type a: int
                :type b: dict(int:int)
                :rtype: int
            '''
            pass

        self.assertRaises(ContractException, decorate, f)

    def test_ok1(self):
        @contract
        def f(a, b):
            ''' This is good
                :type a: int
                :type b: int
                :rtype: int
            '''
            pass

    def test_ok3(self):
        ''' Trying the quoting thing. '''
        @contract
        def f(a, b):
            ''' This is good
                :type a: ``int``
                :type b: ``int``
                :rtype: ``int``
            '''
            pass

    def test_bad_quoting(self):
        def f(a, b):
            ''' 
                :type a: ``int``
                :type b: ``int``
                :rtype: ``int`
            '''
            pass

        self.assertRaises(ContractException, decorate, f)

    def test_bad_quoting2(self):
        def f(a, b):
            ''' 
                :type a: ``int``
                :type b: `int``
                :rtype: ``int``
            '''
            pass

        self.assertRaises(ContractException, decorate, f)

    def test_ok2(self):
        @contract(a='int', returns='int')
        def f(a, b):
            pass

    def test_invalid_args(self):
        def f():
            @contract(1)
            def g(a, b):
                return int(a + b)
        self.assertRaises(ContractException, f)

    def test_invalid_args2(self):
        ''' unknown parameter '''
        def f():
            @contract(c=2)
            def g(a, b):
                return int(a + b)
        self.assertRaises(ContractException, f)

    def test_check_it_works1(self):
        @contract(a='int', b='int', returns='int')
        def f(a, b):  # @UnusedVariable
            return 2.0
        self.assertRaises(ContractNotRespected, f, 1, 2)

    def test_check_it_works2(self):
        @contract(a='int', b='int', returns='int')
        def f(a, b):  # @UnusedVariable
            return a + b
        f(1, 2)
        self.assertRaises(ContractNotRespected, f, 1.0, 2)
        self.assertRaises(ContractNotRespected, f, 1, 2.0)

    def test_check_it_works2b(self):
        ''' Nothing for b '''
        @contract(a='int', returns='int')
        def f(a, b):  # @UnusedVariable
            return int(a + b)
        f(1, 2)
        f(1, 2.0)

    def test_check_it_works2c(self):
        ''' Nothing for b '''
        def f1(a, b):  # @UnusedVariable
            return int(a + b)

        f = decorate(f1, a='int', returns='int')

        f(1, 2)
        f(1, 2.0)
        self.assertRaises(ContractNotRespected, f, 1.0, 2)

    # def test_module_as_decorator(self):
    #     import contracts as contract_module
    # 
    #     @contract_module
    #     def f(a, b): #@UnusedVariable
    #         return a + b
    #     f(1, 2)
    #     self.assertRaises(ContractNotRespected, f, 1.0, 2)

    def test_check_it_works3(self):
        @contract
        def f(a, b):
            ''' This is good
                :type a: int
                :type b: int
                :rtype: int
            '''
            return a + b
        f(1, 2)
        self.assertRaises(ContractNotRespected, f, 1.0, 2)
        self.assertRaises(ContractNotRespected, f, 1, 2.0)

    def test_check_docstring_maintained(self):
        def f1(a, b):
            ''' This is good
                :type a: int
                :type b: int
                :rtype: int
            '''
            return a + b

        def f2(string):
            pass

        f1_dec = decorate(f1)
        self.assertNotEqual(f1.__doc__, f1_dec.__doc__)
        self.assertEqual(f1.__name__, f1_dec.__name__)
        self.assertEqual(f1.__module__, f1_dec.__module__)

        f2_dec = decorate(f2, string='str')
        self.assertNotEqual(f2.__doc__, f2_dec.__doc__)
        self.assertEqual(f2.__name__, f2_dec.__name__)
        self.assertEqual(f2.__module__, f2_dec.__module__)

        f1_dec_p = decorate(f1, modify_docstring=False)
        self.assertEqual(f1_dec_p.__doc__, f1.__doc__)

        f2_dec_p = decorate(f2, modify_docstring=False, string='str')
        self.assertEqual(f2.__doc__, f2_dec_p.__doc__)

        @contract
        def f1b(a, b):
            ''' This is good
                :type a: int
                :type b: int
                :rtype: int
            '''
            return a + b

        @contract(string='str')
        def f2b(string):
            pass

        @contract(modify_docstring=False)
        def f1b_p(a, b):
            ''' This is good
                :type a: int
                :type b: int
                :rtype: int
            '''
            return a + b

        @contract(modify_docstring=False, string='str')
        def f2b_p(string):
            pass

        self.assertNotEqual(f1.__doc__, f1b.__doc__)
        self.assertEqual(f1.__doc__, f1b_p.__doc__)
        self.assertNotEqual(f2.__doc__, f2b.__doc__)
        self.assertEqual(f2.__doc__, f2b_p.__doc__)

    def test_kwargs(self):
        def f(a, b, c=7):  # @UnusedVariable
            ''' Same with optional
                :type a: int
                :type b: int
                :type c: int
            '''
            if c != b:
                raise Exception()

        f2 = decorate(f)
        f2(0, 7)
        f2(0, 5, 5)
        self.assertRaises(Exception, f2, 0, 5, 4)
        self.assertRaises(Exception, f2, 0, 5)

    def test_varargs(self):
        def f(a, b, *c):
            ''' Same with optional
                :type a: int
                :type b: int
                :type c: tuple
            '''
            assert c == (a, b)

        f2 = decorate(f)
        f2(0, 7, 0, 7)

    def test_keywords(self):
        def f(A, B, **c):
            ''' Same with optional
                :type A: int
                :type B: int
                :type c: dict
            '''
            assert c['a'] == A
            assert c['b'] == B

        f2 = decorate(f)
        f(0, 7, a=0, b=7)
        f2(0, 7, a=0, b=7)

        self.assertRaises(Exception, f2, 0, 5, 0, 6)

    def test_same_signature(self):
        from inspect import getargspec

        def f(a):
            return a

        @contract(a='int')
        def f2(a):
            return a

        self.assertEqual(getargspec(f2), getargspec(f))


    def test_empty_types(self):

        def x():
            @contract
            def f(myparam):
                """
                :param myparam: something
                """

        self.assertRaises(MissingContract, x)

    def test_empty_types2(self):

        @contract
        def f(x):
            """
            :param x: something
            :type x: *
            """

        f(1)

########NEW FILE########
__FILENAME__ = test_docstring_parsing
import unittest

from ..docstring_parsing import DocStringInfo, Arg, number_of_spaces
from contracts.interface import add_prefix


examples = {""" 
        Provides a RGB representation of the values by interpolating the range 
        [min(value),max(value)] into the colorspace [min_color, max_color].
        
        :param value: The field to represent.
        :type  value: HxW array
            
        :param max_value: If specified, everything *above* is clipped.
        :type max_value: float
        :param min_value: If specified, everything *below* is clipped.
        :type min_value: float
    
        :param min_color:  Color to give to the minimum values.
        
        
        :return: A RGB image.
        :rtype: HxWx3 uint8

        :return: gray

    """: DocStringInfo(docstring=' \n        Provides a RGB representation of the values by interpolating the range \n'
                         '        [min(value),max(value)] into the colorspace [min_color, max_color].\n',
  params={
        'value': Arg('The field to represent.', 'HxW array'),
        'max_value': Arg('If specified, everything *above* is clipped.', 'float'),
        'min_value': Arg('If specified, everything *below* is clipped.', 'float'),
        'min_color': Arg('Color to give to the minimum values.', None),
  },
  returns=[Arg('A RGB image.', "HxWx3 uint8"), Arg('gray', None)] 
)          
}


class DocStringTest(unittest.TestCase):
    
    def test_parsing(self):
        for string in examples:
            parsed = DocStringInfo.parse(string)
            "%s" % parsed
            "%r" % parsed
            result = examples[string]
            self.assertEqual(result, parsed)
                
    def test_number_of_spaces(self):
        self.assertEqual(number_of_spaces(''), 0)
        self.assertEqual(number_of_spaces(' '), 1)
        self.assertEqual(number_of_spaces('  '), 2)
        self.assertEqual(number_of_spaces('11'), 0)
        self.assertEqual(number_of_spaces(' 223'), 1)
        self.assertEqual(number_of_spaces('  4343'), 2)
        
    def test_reparsing(self):
        for string, result in examples.items(): #@UnusedVariable
            parsed = DocStringInfo.parse(string)
            converted = "%s" % parsed
            reparsed = DocStringInfo.parse(converted)
            
            msg = ('First string:\n%s\nParsed as:\n%s\n' % 
                (add_prefix(string, '|'), add_prefix('%r' % parsed, '|')))
            
            msg += ('Converted:\n%s\nReparsed as:\n%s\n' % 
                (add_prefix(converted, '|'), add_prefix('%r' % reparsed, '|')))
            
            self.assertEqual(parsed, reparsed, msg=msg)
        

########NEW FILE########
__FILENAME__ = test_idioms
import unittest

from contracts import (check, ContractNotRespected, Contract, parse,
                       check_multiple, ContractSyntaxError, fail)


class TestIdioms(unittest.TestCase):

    def test_check_1(self):
        res = check('tuple(int,int)', (2, 2))

        assert isinstance(res, dict)

    def test_check_1a(self):
        self.assertRaises(ValueError, check, 1, 2)

    def test_parse_1(self):
        contract = parse('>0')
        assert isinstance(contract, Contract)
        contract.check(2)
        self.assertRaises(ContractNotRespected, contract.check, 'ciao')

    def test_parse_2(self):
        self.assertRaises(ContractSyntaxError, parse, '>>')

    def test_check_2(self):
        self.assertRaises(ContractNotRespected,
                          check, 'tuple(int,int)', (None, 2))

    def test_check_3(self):
        self.assertRaises(ContractSyntaxError,
                          check, 'tuple(>>int,int)', (None, 2))

    def test_check_4(self):
        score = (2, None)
        msg = 'Player score must be a tuple of 2 int.'
        try:
            check('tuple(int,int)', score, msg)
        except ContractNotRespected as e:
            s = str(e)
            assert msg in s
        else:
            self.assertFalse()

    def test_repr_1(self):
        contract = parse(' list[N](int), N > 0')

        ("%s" % contract)   # => 'list[N](int),N>0'
        ("%r" % contract)   # => And([List(BindVariable('N',int),...

    def test_binding(self):
        context = check('list[N](str), N>0', ['a', 'b', 'c'])

        self.assertTrue('N' in context)
        self.assertTrue(context['N'] == 3)

    def test_check_multiple_1(self):

        data = [[1, 2, 3],
                [4, 5, 6]]
        row_labels = ['first season', 'second season']
        col_labels = ['Team1', 'Team2', 'Team3']

        spec = [('list[C](str),C>0', col_labels),
                ('list[R](str),R>0', row_labels),
                ('list[R](list[C])', data)]
        check_multiple(spec)

        # now with description 
        check_multiple(spec,
                        'I expect col_labels, row_labels, data to '
                        'have coherent dimensions.')

        data = [[1, 2, 3], [1, 2]]
        spec = [('list[C](str),C>0', col_labels),
                ('list[R](str),R>0', row_labels),
                ('list[R](list[C])', data)]

        self.assertRaises(ContractNotRespected, check_multiple, spec)
        self.assertRaises(ContractNotRespected, check_multiple, spec,
                          'my message')

    def test_symbols(self):
        from contracts import contract_expression  # @UnusedImport
        # TODO: type

    def test_equality_contract(self):
        c1 = parse('list[C](str),C>0')
        c2 = parse('list[C](str),C>0')
        c3 = parse('list[R](str),R>0')
        self.assertEqual(c1, c2)
        self.assertNotEqual(c1, c3)

    def test_equality_rvalue(self):
        c1 = parse('N+1')
        c2 = parse('N+2')
        c3 = parse('P+1')
        self.assertEqual(c1, c1)
        self.assertEqual(c2, c2)
        self.assertEqual(c3, c3)
        self.assertNotEqual(c1, c2)
        self.assertNotEqual(c1, c3)
        self.assertNotEqual(c2, c3)

    def test_check_context(self):
        check('N', 1, N=1)
        fail('N', 1, N=2)

        self.assertRaises(ContractNotRespected, check, 'N', 1, N=2)

        self.assertRaises(ValueError, fail, 'N', 1, N=1)

    def test_check_context2(self):
        ''' Variable names must have only one letter. '''
        self.assertRaises(ValueError, check, 'N', 1, NN=2)
        self.assertRaises(ValueError, check, 'N', 1, nn=2)


########NEW FILE########
__FILENAME__ = test_meta
from abc import abstractmethod
from contracts import ContractNotRespected, contract, ContractsMeta
import unittest
from contracts import CannotDecorateClassmethods
import functools
import nose


def expected_failure(test):
    @functools.wraps(test)
    def inner(*args, **kwargs):
        try:
            test(*args, **kwargs)
        except Exception:
            raise nose.SkipTest
        else:
            raise AssertionError('Failure expected')
    return inner


class TestMeta(unittest.TestCase):

    def test_meta_still_works1(self):
        
        class A():
            __metaclass__ = ContractsMeta
            
            @abstractmethod
            @contract(a='>0')
            def f(self, a):
                pass
        
        class B(A):
            # does not implement f
            pass
        
        self.assertRaises(TypeError, B)
        
    def test_meta_still_works2(self):
        
        class A():
            __metaclass__ = ContractsMeta
            
            # inverse order
            @contract(a='>0')
            @abstractmethod
            def f(self, a):
                pass
        
        class B(A):
            # does not implement f
            pass
            
        
        self.assertRaises(TypeError, B)
        
    def test_meta1(self):
        
        class A():
            __metaclass__ = ContractsMeta
            
            @abstractmethod
            @contract(a='>0')
            def f(self, a):
                pass
            
            
            @contract(a='>0')
            @abstractmethod
            def g(self, a):
                pass
            
        class B(A):
            
            def f(self, a):
                pass
            
            def g(self, a):
                pass
        
        b = B()
  
        self.assertRaises(ContractNotRespected, b.f, 0)
        self.assertRaises(ContractNotRespected, b.g, 0)

    @expected_failure
    def test_static1(self):
        
        class A():
            __metaclass__ = ContractsMeta
            
            @staticmethod
            @contract(a='>0')
            def f(a):
                pass
            
        self.assertRaises(ContractNotRespected, A.f, 0)
        
        class B(A):
            
            @staticmethod
            def f(a):
                pass
  
        self.assertRaises(ContractNotRespected, B.f, 0) # this doesn't work  
        
    @expected_failure   
    def test_classmethod1(self):
        
        class A():
            __metaclass__ = ContractsMeta
            
            @classmethod
            @contract(a='>0')
            def f(cls, a):  
                print('called A.f(%s)' % a)
                pass

        self.assertRaises(ContractNotRespected, A.f, 0)
            
        class B(A):
            
            @classmethod
            def f(cls, a):
                print('called B.f(%s)' % a)
                pass

        self.assertRaises(ContractNotRespected, B.f, 0) # this doesn't work  

    @expected_failure
    def test_classmethod1ns(self):
    
        class A(object):
            __metaclass__ = ContractsMeta
            
            @classmethod
            @contract(a='>0')
            def f(cls, a):
                print('called A.f(%s)' % a)
                pass

        self.assertRaises(ContractNotRespected, A.f, 0)
            
        class B(A):
            
            @classmethod
            def f(cls, a):
                print('called B.f(%s)' % a)
                pass

        self.assertRaises(ContractNotRespected, B.f, 0) # this doesn't work  
        

    def test_classmethod2a(self):
         
        def test_classmethod2():
            
            class A():
                __metaclass__ = ContractsMeta
                
                @contract(a='>0')
                @classmethod
                def f(cls, a):
                    pass
                
            class B(A):
                
                @classmethod
                def f(cls, a):
                    pass
      
        self.assertRaises(CannotDecorateClassmethods, test_classmethod2)
      
       


########NEW FILE########
__FILENAME__ = test_multiple
''' Other testing examples '''

from ..test_registrar import good, fail

# dummy
good(['*'], [0])
good(['*', '*'], [0, 1])
good(['=0', '=1'], [0, 1])
fail(['=0', '=1'], [0, 2])

# Lists of equal length
good(['list[N]', 'list[N]'], [[4], [3]])
good(['list[N]', 'list[N]'], [[], []])
fail(['list[N]', 'list[N]'], [[], [1]])
good(['list[N]', 'list[N],N>0'], [[1], [3]])
# we can also refer to the other context
good(['list[N]', 'list,N>0'], [[1], [3]])
fail(['list[N]', 'list,N>0'], [[], [3]])

# Lists of different length
good(['list[N]', 'list[M],M!=N'], [[4], [3, 2]])
good(['list[N]', 'list[M],M!=N'], [[4, 3], [3]])
fail(['list[N]', 'list[M],M!=N'], [[3], [3]])

# One list shorter than the other
good(['list[N]', 'list[M],M<N'], [[4, 3], [3]])
good(['list[N]', 'list[M],N>M'], [[4, 3], [3]])
fail(['list[N]', 'list[M],N>M'], [[3], [3]])

# Values of the same type
good(['type(x)', 'type(x)'], [0, 1])
good(['type(x)', 'type(x)'], [0.1, 1.1])
fail(['type(x)', 'type(x)'], [0.1, 1])
good(['type(x)', 'type(y)', 'type(x)|type(y)'], [0, 1.1, 1.2])
good(['type(x)', 'type(y)', 'type(x)|type(y)'], [0, 1.1, 3])
fail(['type(x)', 'type(y)', 'type(x)|type(y)'], [0, 1.1, 'ciao'])

# A list with all elements of the same type
good(['list(type(x))'], [[0, 1, 2]])
fail(['list(type(x))'], [[0, 1.2, 2]])
fail(['list(type(x))'], [[0, None, 2]])
# Lists with the same type of elements
good(['list(type(x))', 'list(type(x))'], [[1, 2], [3, 4]])
fail(['list(type(x))', 'list(type(x))'], [[1, 2], [3.0, 4]])
# Using different variables and then imposing they are equal
good(['list(type(x))', 'list(type(y)),x=y'], [[1, 2], [3, 4]])
fail(['list(type(x))', 'list(type(y)),x=y'], [[1, 2], [3.0, 4]])

# a list with at most two types
good('list(type(x|y))', [1, 2, 3, 4.0])
fail('list(type(x|y))', [1, 2, 'ciao', 4.0])



########NEW FILE########
__FILENAME__ = test_new_contract
import unittest

from contracts import new_contract, check, Contract, contract
from contracts.library.extensions import identifier_expression

from .utils import check_contracts_fail, check_contracts_ok
from contracts.main import  can_be_used_as_a_type
from contracts.syntax import ParsingTmp

# The different patterns


def ok1(x):
    pass


def ok2(x):  # @UnusedVariable
    return True


def fail1(x):
    raise ValueError('message')


def fail2(x):  # @UnusedVariable
    return False


def invalid_callable1(x):  # @UnusedVariable
    return 'ciao'


# generates a new name:
def cname():
    TestNewContract.counter += 1
    return 'GeneratedContract%d' % TestNewContract.counter


class TestNewContract(unittest.TestCase):
    counter = 0

    def test_inverted_args(self):
        self.assertRaises(ValueError, new_contract, ok1, 'list')

    def test_wrong_args(self):
        self.assertRaises(ValueError, new_contract, 'my13', 2)

    def test_invalid_callable(self):
        self.assertRaises(ValueError, new_contract, 'new', lambda: None)

    def test_parsing_error(self):
        self.assertRaises(ValueError, new_contract, 'new', '>>')

    def test_parsing_error2(self):
        # parsing error (unknown spec)
        self.assertRaises(ValueError, new_contract, 'new', 'unknown')

    def test_invalid_names(self):
        # invalid names:
        alphabet = 'A B C D E F G H I J K L M N O P Q R S T U W V X Y Z'
        for x in alphabet.split():
            self.assertRaises(ValueError, new_contract, x, 'list')
            self.assertRaises(ValueError, new_contract, x.lower(), 'list')
        self.assertRaises(ValueError, new_contract, 'list', 'list[N]')
        self.assertRaises(ValueError, new_contract, '2acdca', 'list[N]')
        self.assertRaises(ValueError, new_contract, '_', 'list[N]')

    def test_valid(self):
        c = new_contract('my_list', 'list[2]')
        assert isinstance(c, Contract)
        check('tuple(my_list, my_list)', ([1, 2], [1, 2]))
        check_contracts_fail('tuple(my_list, my_list)', ([1, 2], [1, 2, 3]))

    def test_separate_context(self):
        new_contract('my_list2', 'list[N]')
        check('tuple(my_list2, my_list2)', ([1, 2], [1, 2]))
        check('tuple(my_list2, my_list2)', ([1, 2], [1, 2, 3]))

    def test_renaming(self):
        self.assertNotEqual(ok1, ok2)
        new_contract('my7', ok1)
        self.assertRaises(ValueError, new_contract, 'my7', ok2)

    def test_allow_renaming_if_equal1(self):
        new_contract('my8', ok1)
        new_contract('my8', ok1)

    def test_allow_renaming_if_equal2(self):
        new_contract('my8b', 'list[3]')
        new_contract('my8b', 'list[3]')

    def test_callable1(self):
        c = cname()
        new_contract(c, ok2)
        check('list(%s)' % c, [0])

    def test_callable2(self):
        c = cname()
        new_contract(c, ok2)
        check('list(%s)' % c, [0])

    def test_callable3(self):
        c = cname()
        new_contract(c, fail1)
        check_contracts_fail('list(%s)' % c, [0])

    def test_callable4(self):
        c = cname()
        new_contract(c, fail2)
        check_contracts_fail('list(%s)' % c, [0])

    def test_invalid_callable2(self):
        c = cname()
        new_contract(c, invalid_callable1)
        self.assertRaises(ValueError, check, 'list(%s)' % c, [0])

    def test_other_pass(self):
        class Ex1(Exception):
            pass
        
        def invalid(x):
            raise Ex1()
        c = cname()
        new_contract(c, invalid)
        self.assertRaises(Ex1, check, 'list(%s)' % c, [0])

    def test_callable(self):
        class MyTest_ok(object):
            def __call__(self, x):  # @UnusedVariable 
                return True
        o = MyTest_ok()
        assert o('value') == True
        new_contract(cname(), o)

    def test_callable_old_style(self):
        class MyTest_ok():
            def __call__(self, x):  # @UnusedVariable 
                return True
        o = MyTest_ok()
        assert o('value') == True
        new_contract(cname(), o)

    def test_class_as_contract1(self):
        # This should be interpreted as a type
        # init(x,y) so it is not mistaken for a valid callable
        class NewStyleClass(object):
            def __init__(self, x, y):  # @UnusedVariable 
                pass
        new_contract(cname(), NewStyleClass)

    def test_class_as_contract2(self):
        # old sytle class
        class OldStyleClass():
            def __init__(self, x, y):  # @UnusedVariable 
                pass
        new_contract(cname(), OldStyleClass)

    def test_class_as_contract3(self):
        class NewStyleClass(object):
            def __init__(self, x, y):  # @UnusedVariable 
                pass
            
        @contract(x=NewStyleClass)
        def f(x):
            pass

    def test_class_as_contract4(self):
        class OldStyleClass():
            def __init__(self, x, y):  # @UnusedVariable 
                pass
            
        @contract(x=OldStyleClass)
        def f(x):
            pass

    def test_callable_5(self):
        class MyTest_ok(object):
            def f(self, x):  # @UnusedVariable
                return True
        o = MyTest_ok()
        assert o.f('value') == True
        new_contract(cname(), o.f)

# TODO: removed after checking in class methods
#    def test_callable_invalid(self):
#        class MyTest_fail(object):
#            def __call__(self, x, y):  # @UnusedVariable
#                return True
#            
#        self.assertRaises(ValueError, new_contract, cname(), MyTest_fail())

    def test_lambda_2(self):
        new_contract(cname(), lambda x: True)  # @UnusedVariable
        new_contract(cname(), lambda x: None)  # @UnusedVariable

    def test_lambda_invalid(self):
        f = lambda x, y: True  # @UnusedVariable
        self.assertRaises(ValueError, new_contract, cname(), f)

    def test_lambda_invalid2(self):
        self.assertRaises(ValueError, new_contract, cname(), lambda: True)

    def test_idioms(self):
        color = new_contract('color', 'list[3](number,>=0,<=1)')
        # Make sure we got it right
        color.check([0, 0, 0])
        color.check([0, 0, 1])
        color.fail([0, 0])
        color.fail([0, 0, 2])

        self.assertRaises(ValueError, color.fail, [0, 0, 1])

        # Now use ``color`` in other contracts.
        @contract
        def fill_area(inside, border):
            """ Fill the area inside the current figure.
            
                :type border: color
                :type inside: color
            """
            pass

        @contract
        def fill_gradient(colors):
            """ Use a gradient to fill the area.
            
                :type colors: list(color)
            """
            pass

    def test_as_decorator(self):
        @new_contract
        def even(x):
            return x % 2 == 0
        from contracts import parse
        p = parse('even')
        p.check(2)
        p.check(4)
        p.fail(3)
        p.check(2.0)

    def test_as_decorator_multiple(self):
        @new_contract
        @contract(x='int')
        def even2(x):
            return x % 2 == 0

        from contracts import parse
        p = parse('even2')
        p.check(2)
        p.fail(3)
        p.fail(2.0) # now fails 

    def test_types_as_contracts(self):
        c = cname()
        new_contract(c, str)
        check_contracts_ok(c, '')
        check_contracts_fail(c, 1)

    def test_types_as_contracts2(self):
        c = cname()
        new_contract(c, int)
        check_contracts_ok(c, 1)
        check_contracts_fail(c, '')

    def test_well_recognized(self):
        class OldStyleClass():
            def __init__(self, x, y):  # @UnusedVariable 
                pass

        assert can_be_used_as_a_type(OldStyleClass)

        class NewStyleClass():
            def __init__(self, x, y):  # @UnusedVariable 
                pass

        assert can_be_used_as_a_type(NewStyleClass)

    def test_capital_name1(self):
        # some problems with identifiers starting with capitals
        new_contract('SEn', 'int')
        check_contracts_ok('SEn', 1)
        check_contracts_fail('SEn', 2.0)

    def test_capital_name2(self):
        new_contract('Sen', 'int')
        check_contracts_ok('Sen', 1)
        check_contracts_fail('Sen', 2.0)


examples_valid = ['aa', 'a_', 'a2', 'a_2', 'list2', 'dict2', 'int2',
                'float2', 'point2', 'A2', 'array2', 'unit_length', 'SE2', 'SE3', 'S1', 'S2', 'axis_angle']

for k in ParsingTmp.keywords:
    examples_valid.append('%s2' % k)
    examples_valid.append('%s_' % k)


def check_valid_identifier(e):
    check_valid_identifier.__dict__['description'] = \
        'check_valid_identifier(%r)' % e

    identifier_expression.parseString(e, parseAll=True) #@UndefinedVariable

    new_contract(e, '*')

    check(e, 42)


def test_valid_identifiers():

    for e in examples_valid:
        yield check_valid_identifier, e



########NEW FILE########
__FILENAME__ = test_particulars
from contracts import parse
from contracts.interface import Where, ContractSyntaxError
from contracts.library import *  # @UnusedWildImport
from contracts.syntax import ParseFatalException, ParseException
import unittest


def expression_fails(expression, string, all=True):  # @ReservedAssignment
    try:
        c = expression.parseString(string, parseAll=all)
    except ParseException:
        pass
    except ParseFatalException:
        pass
    else:
        raise Exception('Expression: %s\nparsed to: %s\n(%r)' % 
                        (string, c, c))


def expression_parses(expression, string, all=True):  # @ReservedAssignment
    try:
        expression.parseString(string, parseAll=all)
    except ParseException as e:
        where = Where(string, line=e.lineno, column=e.col)
        msg = 'Error in parsing string: %s' % e
        raise ContractSyntaxError(msg, where=where)
    except ParseFatalException as e:
        where = Where(string, line=e.lineno, column=e.col)
        msg = 'Fatal error in parsing string: %s' % e
        raise ContractSyntaxError(msg, where=where)


class TestParticular(unittest.TestCase):

    def test_variables(self):
        for s in ['a', 'b', 'c', 'd', 'x', 'y']:
            self.assertEqual(parse(s), BindVariable(s, object))
            U = s.upper()
            self.assertEqual(parse(U), BindVariable(U, int))

    def test_variable_parseable(self):
        for s in ['a', 'b', 'c', 'd', 'x', 'y']:
            expression_fails(int_variables_contract, s)
            expression_parses(misc_variables_contract, s)
            U = s.upper()
            expression_parses(int_variables_contract, U)
            expression_fails(misc_variables_contract, U)

    def test_partial(self):
        expression_parses(int_variables_contract, 'A', all=False)
        expression_fails(int_variables_contract, 'A A', all=True)
        expression_parses(int_variables_contract, 'A', all=True)
        expression_fails(int_variables_contract, 'A*', all=False)




class TestBindingVsRef(unittest.TestCase):
    def test_binding_vs_ref(self):
        self.assertEqual(parse('list[N]'), List(BindVariable('N', int), None))

    def test_binding_vs_ref2(self):
        self.assertEqual(parse('N'), BindVariable('N', int))




########NEW FILE########
__FILENAME__ = test_pickling
from .utils import check_contracts_fail
from contracts import ContractNotRespected, parse, Contract
from contracts.test_registrar import (semantic_fail_examples,
    contract_fail_examples, good_examples)
import pickle


def check_exception_pickable(contract, value):
    exception = check_contracts_fail(contract, value)
    assert isinstance(exception, Exception)
    try:
        s = pickle.dumps(exception)
        pickle.loads(s)
    except TypeError as e:
        print('While pickling: %s' % exception)
        raise e
        msg = 'Could not pickle exception.\n'
        msg += str(exception)
        msg += 'Raised: %s' % e
        raise Exception(msg)


def test_exceptions_are_pickable():
    for contract, value, exact in semantic_fail_examples:  # @UnusedVariable
        yield check_contracts_fail, contract, value, ContractNotRespected
        #ContractSemanticError
    for contract, value, exact in contract_fail_examples:  # @UnusedVariable
        yield check_contracts_fail, contract, value, ContractNotRespected


def check_contract_pickable(contract):
    c = parse(contract)
    assert isinstance(c, Contract)
    try:
        s = pickle.dumps(c)
        c2 = pickle.loads(s)
    except TypeError as e:
        msg = 'Could not pickle contract.\n'
        msg += '- string: %s\n' % c
        msg += '-   repr: %r\n' % c
        msg += 'Exception: %s' % e
        raise Exception(msg)

    assert c == c2


def test_contracts_are_pickable():
    allc = (good_examples + semantic_fail_examples + contract_fail_examples)
    for contract, _, _ in allc:
        if isinstance(contract, list):
            for c in contract:
                yield check_contract_pickable, c
        else:
            yield check_contract_pickable, contract

########NEW FILE########
__FILENAME__ = test_simple
import traceback

from ..main import parse_contract_string
from ..interface import ContractNotRespected
from ..test_registrar import (good_examples, semantic_fail_examples,
                              syntax_fail_examples, contract_fail_examples)
from .utils import check_contracts_ok, check_syntax_fail, check_contracts_fail

# Import the other tests
from . import test_multiple  # @UnusedImport

# Import all the symbols needed to eval() the __repr__() output.
from ..library import *  # @UnusedWildImport @UnresolvedImport


## If you want to try only some tests, set select to True, and add them below.
## Remove the other tests
#good_examples[:] = []
#syntax_fail_examples[:] = []
#semantic_fail_examples[:] = []
#contract_fail_examples[:] = []
#
## Add the ones you want to do here:
#from ..test_registrar import  fail, good, syntax_fail, semantic_fail 


def test_good():
    for contract, value, exact in good_examples:  # @UnusedVariable
        yield check_contracts_ok, contract, value


def test_syntax_fail():
    for s in syntax_fail_examples:
        yield check_syntax_fail, s


def test_semantic_fail():
    for contract, value, exact in semantic_fail_examples:  # @UnusedVariable
        yield check_contracts_fail, contract, value, ContractNotRespected


def test_contract_fail():
    for contract, value, exact in contract_fail_examples:  # @UnusedVariable
        yield check_contracts_fail, contract, value, ContractNotRespected


# Checks that we can eval() the __repr__() value and 
# we get an equivalent object. 
def test_repr():
    allc = (good_examples + semantic_fail_examples + contract_fail_examples)
    for contract, value, exact in allc:  # @UnusedVariable
        if isinstance(contract, list):
            for c in contract:
                yield check_good_repr, c
        else:
            yield check_good_repr, contract


#  Checks that we can reconvert the __str__() value and we get the same. 
def test_reconversion():
    allc = (good_examples + semantic_fail_examples + contract_fail_examples)
    for contract, _, exact in allc:
        if isinstance(contract, list):
            for c in contract:
                yield check_recoversion, c, exact
        else:
            yield check_recoversion, contract, exact


def check_good_repr(c):
    ''' Checks that we can eval() the __repr__() value and we get
        an equivalent object. '''
    parsed = parse_contract_string(c)
    # Check that it compares true with itself
    assert parsed.__eq__(parsed), 'Repr does not know itself: %r' % parsed

    reprc = parsed.__repr__()

    try:
        reeval = eval(reprc)
    except Exception as e:
        traceback.print_exc()
        raise Exception('Could not evaluate expression %r: %s' % (reprc, e))

    assert reeval == parsed, \
            'Repr gives different object:\n  %r !=\n  %r' % (parsed, reeval)


def check_recoversion(s, exact):
    ''' Checks that we can eval() the __repr__() value and we get
        an equivalent object. '''
    parsed = parse_contract_string(s)

    s2 = parsed.__str__()
    reconv = parse_contract_string(s2)

    msg = 'Reparsing gives different objects:\n'
    msg += '  Original string: %r\n' % s
    msg += '           parsed: %r\n' % parsed
    msg += '      Regenerated: %r\n' % s2
    msg += '         reparsed: %r' % reconv

    assert reconv == parsed, msg

    if exact:
        # Warn if the string is not exactly the same.
        if s2 != s:
            msg = ('Slight different regenerated strings:\n')
            msg += ('   original: %s\n' % s)
            msg += ('  generated: %s\n' % s2)
            msg += ('   parsed the first time as: %r\n' % parsed)
            msg += ('                and then as: %r' % reconv)
            assert s2 == s, msg





########NEW FILE########
__FILENAME__ = utils
from ..interface import (ContractSyntaxError, describe_value,
                         ContractNotRespected)
from ..main import parse_contract_string, check_contracts


def check_contracts_ok(contract, value):
    if isinstance(contract, str):
        contract = [contract]
        value = [value]
    context = check_contracts(contract, value)

    assert isinstance(context, dict)
    "%s" % context
    "%r" % context


def check_contracts_fail(contract, value, error=ContractNotRespected):
    ''' Returns the exception '''
    if isinstance(contract, str):
        contract = [contract]
        value = [value]

    try:
        context = check_contracts(contract, value)

        msg = ('I was expecting that the values would not not'
               ' satisfy the contract.\n')

        for v in value:
            msg += '      value: %s\n' % describe_value(v)

        for c in contract:
            cp = parse_contract_string(c)
            msg += '   contract: %r, parsed as %r (%s)\n' % (c, cp, cp)

        msg += '    context:  %r\n' % context

        raise Exception(msg)

    except error as e:
        # Try generation of strings:
        s = "%r" % e  # @UnusedVariable
        s = "%s" % e  # @UnusedVariable
        return e


def check_syntax_fail(string):
    assert isinstance(string, str)

    try:
        parsed_contract = parse_contract_string(string)
        msg = 'I would not expect to parse %r.' % string
        msg += ' contract:         %s\n' % parsed_contract
        raise Exception(msg)

    except ContractSyntaxError as e:
        # Try generation of strings:
        s = "%r" % e  # @UnusedVariable
        s = "%s" % e  # @UnusedVariable
        pass


########NEW FILE########
__FILENAME__ = test_registrar

good_examples = []
syntax_fail_examples = []
semantic_fail_examples = []
contract_fail_examples = []


# If exact is True, we are providing a canonical form
# for the expression and we want it back.
def good(a, b, exact=True):
    good_examples.append((a, b, exact))


def semantic_fail(a, b, exact=True):
    semantic_fail_examples.append((a, b, exact))


def syntax_fail(s):
    syntax_fail_examples.append(s)


def fail(a, b, exact=True):
    contract_fail_examples.append((a, b, exact))



########NEW FILE########
__FILENAME__ = numbers
from contracts.main import new_contract

__all__ = []

try:
    import numpy  # @UnusedImport
except ImportError:  # pragma: no cover
    new_contract('float', 'Float')
    new_contract('int', 'Int')
    new_contract('number', 'float|int')    
else:
    new_contract('float', 'Float|np_scalar_float|(np_scalar, array(float))')
    new_contract('int', 'Int|np_scalar_int|(np_scalar,array(int))')
    new_contract('uint', 'np_scalar_uint|(np_scalar, array(uint))')
    new_contract('number', 'float|int|uint')

    
    

########NEW FILE########
__FILENAME__ = numpy_specific
from contracts import new_contract
import numpy as np
from contracts.interface import describe_value, describe_type

__all__ = ['finite']

@new_contract
def finite(x):
    return np.isfinite(x).all()

new_contract('np_scalar_uint', 'np_uint8|np_uint16|np_uint32|np_uint64')
new_contract('np_scalar_int', 'np_int8|np_int16|np_int32|np_int64')
new_contract('np_scalar_float', 'np_float32|np_float64')
new_contract('np_scalar_type', 'np_scalar_int|np_scalar_uint|np_scalar_float')

@new_contract  
def np_zeroshape_array(x):
#     scalars = [ 
#     np.int,  # Platform integer (normally either int32 or int64)
#     np.int8,  # Byte (-128 to 127)
#     np.int16,  # Integer (-32768 to 32767)
#     np.int32,  # Integer (-2147483648 to 2147483647)
#     np.int64,  # Integer (9223372036854775808 to 9223372036854775807)
#     np.uint8,  # Unsigned integer (0 to 255)
#     np.uint16,  # Unsigned integer (0 to 65535)
#     np.uint32,  # Unsigned integer (0 to 4294967295)
#     np.uint64,  # Unsigned integer (0 to 18446744073709551615)
#     np.float,  # Shorthand for float64.
#     np.float16,  #  Half precision float: sign bit, 5 bits exponent, 10 bits mantissa
#     np.float32,  #  Single precision float: sign bit, 8 bits exponent, 23 bits mantissa
#     np.float64,  #  Double precision float: sign bit, 11 bits exponent, 52 bits mantissa
#     np.complex,  #  Shorthand for complex128.
#     np.complex64,  #    Complex number, represented by two 32-bit floats (real and imaginary components)
#     np.complex128
#     ]
#  
#     if isinstance(x, tuple(scalars)):
#         return
#  
#  
    if not isinstance(x, np.ndarray):
        msg = 'Not an array: %s %s ' % (type(x), describe_type(x))
        raise ValueError(msg)
 
    if not x.shape == ():
        msg = 'Not a scalar: %s' % describe_value(x)
        raise ValueError(msg)
     

new_contract('np_scalar', 'np_zeroshape_array|np_scalar_type')


########NEW FILE########
__FILENAME__ = utils

def indent(s, prefix):
    lines = s.split('\n')
    lines = ['%s%s' % (prefix, line.rstrip()) for line in lines]
    return '\n'.join(lines)

########NEW FILE########
__FILENAME__ = test_py3k_annotations
# FIXME: how can I not parse this with python2?
import unittest
from contracts import decorate, ContractException, contract, ContractNotRespected
#@PydevCodeAnalysisIgnore
class Py3kAnnotationsTest(unittest.TestCase):

    def test_malformed(self):
        def f() -> "":
            pass
    
        self.assertRaises(ContractException, decorate, f)

    def test_malformed2(self):
        def f() -> "okok":
            pass
    
        self.assertRaises(ContractException, decorate, f)

    def test_malformed3(self):
        def f() -> 3:
            pass
    
        self.assertRaises(ContractException, decorate, f)
    
    def test_not_specified1(self):
        ''' No docstring specified, but annotation is. '''
        def f() -> "int":
            pass
    
    def test_parse_error1(self):
        def f(a: "int", b: "in"):
            pass
    
        self.assertRaises(ContractException, decorate, f)

    def test_parse_error2(self):
        def f(a, b) -> "in":
            pass
        self.assertRaises(ContractException, decorate, f)


    def not_supported2(self):
        ''' Cannot do with **args ''' 
        def f(a, **b):
            ''' 
                :type a: int
                :rtype: int
            '''
            pass
    
        self.assertRaises(ContractException, decorate, f)


    def test_ok1(self):
        @contract
        def f(a, b):
            ''' This is good
                :type a: int
                :type b: int
                :rtype: int
            '''
            pass

    def test_types1(self):
        @contract
        def f(a: int, b: int) -> int:
            return a + b 

        f(1, 2)
        self.assertRaises(ContractNotRespected, f, 1.0, 2)
        self.assertRaises(ContractNotRespected, f, 1, 2.0)

    def test_types2(self):
        ''' Testing return value contract '''
        @contract
        def f(a: int, b: int) -> int:
            return (a + b) * 2.1

        self.assertRaises(ContractNotRespected, f, 1, 2)


    def test_kwargs(self):
        def f(a:int, b:int, c:int=7): #@UnusedVariable
            if c != b:
                raise Exception()

    
        f2 = decorate(f)
        f2(0, 7)
        f2(0, 5, 5)
        self.assertRaises(Exception, f2, 0, 5, 4)
        self.assertRaises(Exception, f2, 0, 5)

    def test_varargs(self):
        def f(a, b, *c: tuple):
            assert c == (a, b)
    
        f2 = decorate(f)
        f2(0, 7, 0, 7)

    def test_varargs2(self):
        def f(a, b, *c: "tuple"):
            assert c == (a, b)
    
        f2 = decorate(f)
        f2(0, 7, 0, 7)

    def test_keywords(self):
        def f(A:int, B:int, **c: dict):
            assert c['a'] == A
            assert c['b'] == B
                
        f2 = decorate(f)
        f(0, 7, a=0, b=7)
        f2(0, 7, a=0, b=7)
    
        self.assertRaises(Exception, f2, 0, 5, 0, 6)
        
# from unittest.case import SkipTest

# class KnownFailuresTest(SkipTest):
#     def test_kwonly_1(self):
#         @contract
#         def f(a: int, b: int, *, c: int = 2) -> int:
#             return (a + b + c)  
# 
#             self.assertRaises(ContractNotRespected, f, 1, 2, 3)

########NEW FILE########
