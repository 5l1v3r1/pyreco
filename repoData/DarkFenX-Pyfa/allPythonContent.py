__FILENAME__ = config
import os
import sys

# Load variable overrides specific to distribution type
try:
    import configforced
except ImportError:
    configforced = None

# Turns on debug mode
debug = False
# Defines if our saveddata will be in pyfa root or not
saveInRoot = False

# Version data
version = "1.1.23"
tag = "git"
expansionName = "Rubicon"
expansionVersion = "1.3"
evemonMinVersion = "4081"

pyfaPath = None
savePath = None
staticPath = None
saveDB = None
gameDB = None

def defPaths():
    global pyfaPath
    global savePath
    global staticPath
    global saveDB
    global gameDB
    global saveInRoot
    # The main pyfa directory which contains run.py
    # Python 2.X uses ANSI by default, so we need to convert the character encoding
    pyfaPath = getattr(configforced, "pyfaPath", pyfaPath)
    if pyfaPath is None:
        pyfaPath = unicode(os.path.dirname(os.path.realpath(os.path.abspath(
            sys.modules['__main__'].__file__))), sys.getfilesystemencoding())

    # Where we store the saved fits etc, default is the current users home directory
    if saveInRoot is True:
        savePath = getattr(configforced, "savePath", None)
        if savePath is None:
            savePath = os.path.join(pyfaPath, "saveddata")
    else:
        savePath = getattr(configforced, "savePath", None)
        if savePath is None:
            savePath = unicode(os.path.expanduser(os.path.join("~", ".pyfa")),
                               sys.getfilesystemencoding())

    # Redirect stderr to file if we're requested to do so
    stderrToFile = getattr(configforced, "stderrToFile", None)
    if stderrToFile is True:
        if not os.path.exists(savePath):
            os.mkdir(savePath)
        sys.stderr = open(os.path.join(savePath, "error_log.txt"), "w")

    # Same for stdout
    stdoutToFile = getattr(configforced, "stdoutToFile", None)
    if stdoutToFile is True:
        if not os.path.exists(savePath):
            os.mkdir(savePath)
        sys.stdout = open(os.path.join(savePath, "output_log.txt"), "w")

    # Static EVE Data from the staticdata repository, should be in the staticdata
    # directory in our pyfa directory
    staticPath = os.path.join(pyfaPath, "staticdata")

    # The database where we store all the fits etc
    saveDB = os.path.join(savePath, "saveddata.db")

    # The database where the static EVE data from the datadump is kept.
    # This is not the standard sqlite datadump but a modified version created by eos
    # maintenance script
    gameDB = os.path.join(staticPath, "eve.db")

    ## DON'T MODIFY ANYTHING BELOW ##
    import eos.config

    #Caching modifiers, disable all gamedata caching, its unneeded.
    eos.config.gamedataCache = False
    # saveddata db location modifier, shouldn't ever need to touch this
    eos.config.saveddata_connectionstring = "sqlite:///" + saveDB + "?check_same_thread=False"
    eos.config.gamedata_connectionstring = "sqlite:///" + gameDB + "?check_same_thread=False"

########NEW FILE########
__FILENAME__ = capSim
import heapq
from math import sqrt, exp
import time


DAY = 24 * 60 * 60 * 1000

def lcm(a,b):
    n = a*b
    while b:
        a, b = b, a % b
    return n / a


class CapSimulator(object):
    """Entity's EVE Capacitor Simulator"""

    def __init__(self):
        # simulator defaults (change in instance, not here)

        self.capacitorCapacity = 100
        self.capacitorRecharge = 1000

        # max simulated time.
        self.t_max = DAY

        # take reloads into account?
        self.reload = False

        # stagger activations of identical modules?
        self.stagger = False

        # scale activation duration and capNeed to values that ease the
        # calculation at the cost of accuracy?
        self.scale = False

        # millisecond resolutions for scaling
        self.scale_resolutions = (100, 50, 25, 10)

        # relevant decimal digits of capacitor for LCM period optimization
        self.stability_precision = 1


    def scale_activation(self, duration, capNeed):
        for res in self.scale_resolutions:
            mod = duration % res
            if mod:
                if mod > res/2.0:
                    mod = res-mod
                else:
                    mod = -mod

                if abs(mod) <= duration/100.0:
                    # only adjust if the adjustment is less than 1%
                    duration += mod
                    capNeed += float(mod)/duration * capNeed
                    break

        return duration, capNeed

    def init(self, modules):
        """prepare modules. a list of (duration, capNeed, clipSize) tuples is
         expected, with clipSize 0 if the module has infinite ammo.
            """
        mods = {}
        for module in modules:
                if module in mods:
                        mods[module] += 1
                else:
                        mods[module] = 1

        self.modules = mods


    def reset(self):
        """Reset the simulator state"""
        self.state = []
        period = 1
        disable_period = False

        for (duration, capNeed, clipSize), amount in self.modules.iteritems():
            if self.scale:
                duration, capNeed = self.scale_activation(duration, capNeed)

            if self.stagger:
                duration = int(duration/amount)
            else:
                capNeed *= amount

            period = lcm(period, duration)

            # set clipSize to infinite if reloads are disabled unless it's
            # a cap booster module.
            if not self.reload and capNeed > 0:
                clipSize = 0

            # period optimization doesn't work when reloads are active.
            if clipSize:
                disable_period = True

            heapq.heappush(self.state, [0, duration, capNeed, 0, clipSize])


        if disable_period:
            self.period = self.t_max
        else:
            self.period = period


    def run(self):
        """Run the simulation"""

        start = time.time()

        self.reset()

        push = heapq.heappush
        pop = heapq.heappop

        state = self.state
        stability_precision = self.stability_precision
        period = self.period

        iterations = 0

        capCapacity = self.capacitorCapacity
        tau = self.capacitorRecharge / 5.0

        cap_wrap = capCapacity                # cap value at last period
        cap_lowest = capCapacity            # lowest cap value encountered
        cap_lowest_pre = capCapacity    # lowest cap value before activations
        cap = capCapacity                         # current cap value
        t_wrap = self.period                    # point in time of next period

        t_now = t_last = 0
        t_max = self.t_max

        while 1:
            activation = pop(state)
            t_now, duration, capNeed, shot, clipSize = activation
            if t_now >= t_max:
                break

            cap = ((1.0+(sqrt(cap/capCapacity)-1.0)*exp((t_last-t_now)/tau))**2)*capCapacity

            if t_now != t_last:
                if cap < cap_lowest_pre:
                    cap_lowest_pre = cap
                if t_now == t_wrap:
                    # history is repeating itself, so if we have more cap now than last
                    # time this happened, it is a stable setup.
                    if cap >= cap_wrap:
                        break
                    cap_wrap = round(cap, stability_precision)
                    t_wrap += period

            cap -= capNeed
            if cap > capCapacity:
                cap = capCapacity

            iterations += 1

            if cap < cap_lowest:
                if cap < 0.0:
                    break
                cap_lowest = cap

            t_last = t_now

            # queue the next activation of this module
            t_now += duration
            shot += 1
            if clipSize:
                if shot % clipSize == 0:
                    shot = 0
                    t_now += 10000    # include reload time
            activation[0] = t_now
            activation[3] = shot

            push(state, activation)
        push(state, activation)

        # update instance with relevant results.
        self.t = t_last
        self.iterations = iterations

        # calculate EVE's stability value
        try:
            avgDrain = reduce(float.__add__, map(lambda x: x[2]/x[1], self.state), 0.0)
            self.cap_stable_eve = 0.25 * (1.0 + sqrt(-(2.0 * avgDrain * tau - capCapacity)/capCapacity)) ** 2
        except ValueError:
            self.cap_stable_eve = 0.0


        if cap > 0.0:
            # capacitor low/high water marks
            self.cap_stable_low = cap_lowest
            self.cap_stable_high = cap_lowest_pre
        else:
            self.cap_stable_low =\
            self.cap_stable_high = 0.0


        self.runtime = time.time()-start

########NEW FILE########
__FILENAME__ = config
import os.path
import sys

debug = False
gamedataCache = True
saveddataCache = True
gamedata_connectionstring = 'sqlite:///' + os.path.expanduser(os.path.join("~", ".pyfa","eve.db"))
saveddata_connectionstring = 'sqlite:///:memory:'

#Autodetect path, only change if the autodetection bugs out.
path = os.path.dirname(unicode(__file__, sys.getfilesystemencoding()))

########NEW FILE########
__FILENAME__ = attribute
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from sqlalchemy import Table, Column, Integer, Float, Unicode, ForeignKey, String, Boolean
from sqlalchemy.orm import relation, mapper, synonym, deferred
from sqlalchemy.ext.associationproxy import association_proxy
from eos.types import Attribute, Icon, AttributeInfo, Unit
from eos.db import gamedata_meta
typeattributes_table = Table("dgmtypeattribs", gamedata_meta,
                         Column("value", Float),
                         Column("typeID", Integer, ForeignKey("invtypes.typeID"), primary_key=True, index=True),
                         Column("attributeID", ForeignKey("dgmattribs.attributeID"), primary_key=True))

attributes_table = Table("dgmattribs", gamedata_meta,
                         Column("attributeID", Integer, primary_key = True),
                         Column("attributeName", String),
                         Column("defaultValue", Float),
                         Column("description", Unicode),
                         Column("published", Boolean),
                         Column("displayName", String),
                         Column("highIsGood", Boolean),
                         Column("iconID", Integer, ForeignKey("icons.iconID")),
                         Column("unitID", Integer, ForeignKey("dgmunits.unitID")))

mapper(Attribute, typeattributes_table,
       properties = {"info": relation(AttributeInfo, lazy=False)})

mapper(AttributeInfo, attributes_table,
       properties = {"icon" : relation(Icon),
                     "unit": relation(Unit),
                     "ID": synonym("attributeID"),
                     "name": synonym("attributeName"),
                     "description" : deferred(attributes_table.c.description)})

Attribute.ID = association_proxy("info", "attributeID")
Attribute.name = association_proxy("info", "attributeName")
Attribute.description = association_proxy("info", "description")
Attribute.published = association_proxy("info", "published")
Attribute.displayName = association_proxy("info", "displayName")
Attribute.highIsGood = association_proxy("info", "highIsGood")
Attribute.iconID = association_proxy("info", "iconID")
Attribute.icon = association_proxy("info", "icon")
Attribute.unit = association_proxy("info", "unit")

########NEW FILE########
__FILENAME__ = category
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from sqlalchemy import Column, String, Integer, ForeignKey, Boolean, Table
from sqlalchemy.orm import relation, mapper, synonym, deferred

from eos.db import gamedata_meta
from eos.types import Category, Icon

categories_table = Table("invcategories", gamedata_meta,
                         Column("categoryID", Integer, primary_key = True),
                         Column("categoryName", String),
                         Column("description", String),
                         Column("published", Boolean),
                         Column("iconID", Integer, ForeignKey("icons.iconID")))

mapper(Category, categories_table,
       properties = {"icon" : relation(Icon),
                     "ID" : synonym("categoryID"),
                     "name" : synonym("categoryName"),
                     "description" : deferred(categories_table.c.description)})

########NEW FILE########
__FILENAME__ = effect
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from sqlalchemy import Column, String, Integer, Boolean, Table, ForeignKey
from sqlalchemy.ext.associationproxy import association_proxy
from sqlalchemy.orm import mapper, synonym, relation, deferred
from eos.types import Effect, EffectInfo
from eos.db import gamedata_meta

typeeffects_table = Table("dgmtypeeffects", gamedata_meta,
                          Column("typeID", Integer, ForeignKey("invtypes.typeID"), primary_key=True, index=True),
                          Column("effectID", Integer, ForeignKey("dgmeffects.effectID"), primary_key=True))

effects_table = Table("dgmeffects", gamedata_meta,
                      Column("effectID", Integer, primary_key = True),
                      Column("effectName", String),
                      Column("description", String),
                      Column("published", Boolean),
                      Column("isAssistance", Boolean),
                      Column("isOffensive", Boolean))


mapper(EffectInfo, effects_table,
       properties = {"ID" : synonym("effectID"),
                     "name" : synonym("effectName"),
                     "description" : deferred(effects_table.c.description)})

mapper(Effect, typeeffects_table,
       properties = {"ID": synonym("effectID"),
                     "info": relation(EffectInfo, lazy=False)})

Effect.name = association_proxy("info", "name")
Effect.description = association_proxy("info", "description")
Effect.published = association_proxy("info", "published")

########NEW FILE########
__FILENAME__ = group
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from sqlalchemy import Column, String, Integer, Boolean, ForeignKey, Table
from sqlalchemy.orm import relation, mapper, synonym, deferred

from eos.db import gamedata_meta
from eos.types import Group, Icon, Category

groups_table = Table("invgroups", gamedata_meta,
                     Column("groupID", Integer, primary_key = True),
                     Column("groupName", String),
                     Column("description", String),
                     Column("published", Boolean),
                     Column("categoryID", Integer, ForeignKey("invcategories.categoryID")),
                     Column("iconID", Integer, ForeignKey("icons.iconID")))

mapper(Group, groups_table,
       properties = {"category" : relation(Category, backref = "groups"),
                     "icon" : relation(Icon),
                     "ID" : synonym("groupID"),
                     "name" : synonym("groupName"),
                     "description" : deferred(groups_table.c.description)})

########NEW FILE########
__FILENAME__ = icon
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from sqlalchemy import Column, String, Integer, Table
from sqlalchemy.orm import mapper, synonym, deferred

from eos.db import gamedata_meta
from eos.types import Icon

icons_table = Table("icons", gamedata_meta,
                    Column("iconID", Integer, primary_key = True),
                    Column("description", String),
                    Column("iconFile", String))

mapper(Icon, icons_table,
       properties = {"ID" : synonym("iconID"),
                     "description" : deferred(icons_table.c.description)})

########NEW FILE########
__FILENAME__ = item
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from sqlalchemy import Column, String, Integer, Boolean, ForeignKey, Table, Float
from sqlalchemy.orm import relation, mapper, synonym, deferred
from sqlalchemy.ext.associationproxy import association_proxy
from sqlalchemy.orm.collections import attribute_mapped_collection

from eos.db import gamedata_meta
from eos.types import Icon, Attribute, Item, Effect, MetaType, Group, Traits

items_table = Table("invtypes", gamedata_meta,
                    Column("typeID", Integer, primary_key = True),
                    Column("typeName", String, index=True),
                    Column("description", String),
                    Column("raceID", Integer),
                    Column("volume", Float),
                    Column("mass", Float),
                    Column("capacity", Float),
                    Column("published", Boolean),
                    Column("marketGroupID", Integer, ForeignKey("invmarketgroups.marketGroupID")),
                    Column("iconID", Integer, ForeignKey("icons.iconID")),
                    Column("groupID", Integer, ForeignKey("invgroups.groupID"), index=True))

from .metaGroup import metatypes_table
from .traits import traits_table

mapper(Item, items_table,
       properties = {"group" : relation(Group, backref = "items"),
                     "icon" : relation(Icon),
                     "_Item__attributes" : relation(Attribute, collection_class = attribute_mapped_collection('name')),
                     "effects" : relation(Effect, collection_class = attribute_mapped_collection('name')),
                     "metaGroup" : relation(MetaType,
                                            primaryjoin = metatypes_table.c.typeID == items_table.c.typeID,
                                            uselist = False),
                     "ID" : synonym("typeID"),
                     "name" : synonym("typeName"),
                     "description" : deferred(items_table.c.description),
                     "traits" : relation(Traits,
                                            primaryjoin = traits_table.c.typeID == items_table.c.typeID,
                                            order_by = traits_table.c.typeID,
                                            uselist = True)
                    })

Item.category = association_proxy("group", "category")

########NEW FILE########
__FILENAME__ = marketGroup
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from sqlalchemy import Column, String, Integer, Boolean, ForeignKey, Table
from sqlalchemy.orm import relation, mapper, synonym, deferred

from eos.db import gamedata_meta
from eos.types import Item, MarketGroup, Icon

marketgroups_table = Table("invmarketgroups", gamedata_meta,
                           Column("marketGroupID", Integer, primary_key = True),
                           Column("marketGroupName", String),
                           Column("description", String),
                           Column("hasTypes", Boolean),
                           Column("parentGroupID", Integer, ForeignKey("invmarketgroups.marketGroupID", initially="DEFERRED", deferrable=True)),
                           Column("iconID", Integer, ForeignKey("icons.iconID")))

mapper(MarketGroup, marketgroups_table,
       properties = {"items" : relation(Item, backref = "marketGroup"),
                     "parent" : relation(MarketGroup, backref = "children", remote_side = [marketgroups_table.c.marketGroupID]),
                     "icon" : relation(Icon),
                     "ID" : synonym("marketGroupID"),
                     "name" : synonym("marketGroupName"),
                     "description" : deferred(marketgroups_table.c.description)})

########NEW FILE########
__FILENAME__ = metaData
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from sqlalchemy import Column, Table, String
from sqlalchemy.orm import mapper
from eos.types import MetaData
from eos.db import gamedata_meta

metadata_table = Table("metadata", gamedata_meta,
                           Column("fieldName", String, primary_key=True),
                           Column("fieldValue", String))

mapper(MetaData, metadata_table)

########NEW FILE########
__FILENAME__ = metaGroup
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from sqlalchemy import Table, Column, Integer, ForeignKey, String
from sqlalchemy.orm import relation, mapper, synonym
from eos.db import gamedata_meta
from eos.db.gamedata.item import items_table
from eos.types import MetaGroup, Item, MetaType
from sqlalchemy.ext.associationproxy import association_proxy

metagroups_table = Table("invmetagroups", gamedata_meta,
                         Column("metaGroupID", Integer, primary_key = True),
                         Column("metaGroupName", String))

metatypes_table = Table("invmetatypes", gamedata_meta,
                        Column("typeID", Integer, ForeignKey("invtypes.typeID"), primary_key = True),
                        Column("parentTypeID", Integer, ForeignKey("invtypes.typeID")),
                        Column("metaGroupID", Integer, ForeignKey("invmetagroups.metaGroupID")))

mapper(MetaGroup, metagroups_table,
       properties = {"ID" : synonym("metaGroupID"),
                     "name" : synonym("metaGroupName")})

mapper(MetaType, metatypes_table,
       properties = {"ID" : synonym("metaGroupID"),
                     "parent" : relation(Item, primaryjoin = metatypes_table.c.parentTypeID == items_table.c.typeID),
                     "items" : relation(Item, primaryjoin = metatypes_table.c.typeID == items_table.c.typeID),
                     "info": relation(MetaGroup, lazy=False)})

MetaType.name = association_proxy("info", "name")


########NEW FILE########
__FILENAME__ = queries
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from eos.db import gamedata_session
from eos.db.gamedata.metaGroup import metatypes_table, items_table
from sqlalchemy.sql import and_, or_, select, func
from sqlalchemy.orm import join, exc
from eos.types import Item, Category, Group, MarketGroup, AttributeInfo, MetaData, MetaGroup
from eos.db.util import processEager, processWhere
import eos.config

configVal = getattr(eos.config, "gamedataCache", None)
if configVal is True:
    def cachedQuery(amount, *keywords):
        def deco(function):
            cache = {}
            def checkAndReturn(*args, **kwargs):
                useCache = kwargs.pop("useCache", True)
                cacheKey = []
                cacheKey.extend(args)
                for keyword in keywords:
                    cacheKey.append(kwargs.get(keyword))

                cacheKey = tuple(cacheKey)
                handler = cache.get(cacheKey)
                if handler is None or not useCache:
                    handler = cache[cacheKey] = function(*args, **kwargs)

                return handler

            return checkAndReturn
        return deco

elif callable(configVal):
    cachedQuery = eos.config.gamedataCache
else:
    def cachedQuery(amount, *keywords):
        def deco(function):
            def checkAndReturn(*args, **kwargs):
                return function(*args, **kwargs)

            return checkAndReturn
        return deco

def sqlizeString(line):
    # Escape backslashes first, as they will be as escape symbol in queries
    # Then escape percent and underscore signs
    # Finally, replace generic wildcards with sql-style wildcards
    line = line.replace("\\", "\\\\").replace("%", "\\%").replace("_", "\\_").replace("*", "%")
    return line

itemNameMap = {}
@cachedQuery(1, "lookfor")
def getItem(lookfor, eager=None):
    if isinstance(lookfor, int):
        if eager is None:
            item = gamedata_session.query(Item).get(lookfor)
        else:
            item = gamedata_session.query(Item).options(*processEager(eager)).filter(Item.ID == lookfor).first()
    elif isinstance(lookfor, basestring):
        if lookfor in itemNameMap:
            id = itemNameMap[lookfor]
            if eager is None:
                item = gamedata_session.query(Item).get(id)
            else:
                item = gamedata_session.query(Item).options(*processEager(eager)).filter(Item.ID == id).first()
        else:
            # Item names are unique, so we can use first() instead of one()
            item = gamedata_session.query(Item).options(*processEager(eager)).filter(Item.name == lookfor).first()
            itemNameMap[lookfor] = item.ID
    else:
        raise TypeError("Need integer or string as argument")
    return item

groupNameMap = {}
@cachedQuery(1, "lookfor")
def getGroup(lookfor, eager=None):
    if isinstance(lookfor, int):
        if eager is None:
            group = gamedata_session.query(Group).get(lookfor)
        else:
            group = gamedata_session.query(Group).options(*processEager(eager)).filter(Group.ID == lookfor).first()
    elif isinstance(lookfor, basestring):
        if lookfor in groupNameMap:
            id = groupNameMap[lookfor]
            if eager is None:
                group = gamedata_session.query(Group).get(id)
            else:
                group = gamedata_session.query(Group).options(*processEager(eager)).filter(Group.ID == id).first()
        else:
            # Group names are unique, so we can use first() instead of one()
            group = gamedata_session.query(Group).options(*processEager(eager)).filter(Group.name == lookfor).first()
            groupNameMap[lookfor] = group.ID
    else:
        raise TypeError("Need integer or string as argument")
    return group

categoryNameMap = {}
@cachedQuery(1, "lookfor")
def getCategory(lookfor, eager=None):
    if isinstance(lookfor, int):
        if eager is None:
            category = gamedata_session.query(Category).get(lookfor)
        else:
            category = gamedata_session.query(Category).options(*processEager(eager)).filter(Category.ID == lookfor).first()
    elif isinstance(lookfor, basestring):
        if lookfor in categoryNameMap:
            id = categoryNameMap[lookfor]
            if eager is None:
                category = gamedata_session.query(Category).get(id)
            else:
                category = gamedata_session.query(Category).options(*processEager(eager)).filter(Category.ID == id).first()
        else:
            # Category names are unique, so we can use first() instead of one()
            category = gamedata_session.query(Category).options(*processEager(eager)).filter(Category.name == lookfor).first()
            categoryNameMap[lookfor] = category.ID
    else:
        raise TypeError("Need integer or string as argument")
    return category

metaGroupNameMap = {}
@cachedQuery(1, "lookfor")
def getMetaGroup(lookfor, eager=None):
    if isinstance(lookfor, int):
        if eager is None:
            metaGroup = gamedata_session.query(MetaGroup).get(lookfor)
        else:
            metaGroup = gamedata_session.query(MetaGroup).options(*processEager(eager)).filter(MetaGroup.ID == lookfor).first()
    elif isinstance(lookfor, basestring):
        if lookfor in metaGroupNameMap:
            id = metaGroupNameMap[lookfor]
            if eager is None:
                metaGroup = gamedata_session.query(MetaGroup).get(id)
            else:
                metaGroup = gamedata_session.query(MetaGroup).options(*processEager(eager)).filter(MetaGroup.ID == id).first()
        else:
            # MetaGroup names are unique, so we can use first() instead of one()
            metaGroup = gamedata_session.query(MetaGroup).options(*processEager(eager)).filter(MetaGroup.name == lookfor).first()
            metaGroupNameMap[lookfor] = metaGroup.ID
    else:
        raise TypeError("Need integer or string as argument")
    return metaGroup

@cachedQuery(1, "lookfor")
def getMarketGroup(lookfor, eager=None):
    if isinstance(lookfor, int):
        if eager is None:
            marketGroup = gamedata_session.query(MarketGroup).get(lookfor)
        else:
            marketGroup = gamedata_session.query(MarketGroup).options(*processEager(eager)).filter(MarketGroup.ID == lookfor).first()
    else:
        raise TypeError("Need integer as argument")
    return marketGroup

@cachedQuery(2, "where", "filter")
def getItemsByCategory(filter, where=None, eager=None):
    if isinstance(filter, int):
        filter = Category.ID == filter
    elif isinstance(filter, basestring):
        filter = Category.name == filter
    else:
        raise TypeError("Need integer or string as argument")

    filter = processWhere(filter, where)
    return gamedata_session.query(Item).options(*processEager(eager)).join(Item.group, Group.category).filter(filter).all()

@cachedQuery(3, "where", "nameLike", "join")
def searchItems(nameLike, where=None, join=None, eager=None):
    if not isinstance(nameLike, basestring):
        raise TypeError("Need string as argument")

    if join is None:
        join = tuple()

    if not hasattr(join, "__iter__"):
        join = (join,)

    items = gamedata_session.query(Item).options(*processEager(eager)).join(*join)
    for token in nameLike.split(' '):
        token_safe = u"%{0}%".format(sqlizeString(token))
        items = items.filter(processWhere(Item.name.like(token_safe, escape="\\"), where))
    items = items.limit(100).all()
    return items

@cachedQuery(2, "where", "itemids")
def getVariations(itemids, where=None, eager=None):
    for itemid in itemids:
        if not isinstance(itemid, int):
            raise TypeError("All passed item IDs must be integers")
    # Get out if list of provided IDs is empty
    if len(itemids) == 0:
        return []

    itemfilter = or_(*(metatypes_table.c.parentTypeID == itemid for itemid in itemids))
    filter = processWhere(itemfilter, where)
    joinon = items_table.c.typeID == metatypes_table.c.typeID
    vars = gamedata_session.query(Item).options(*processEager(eager)).join((metatypes_table, joinon)).filter(filter).all()
    return vars

@cachedQuery(1, "attr")
def getAttributeInfo(attr, eager=None):
    if isinstance(attr, basestring):
        filter = AttributeInfo.name == attr
    elif isinstance(attr, int):
        filter = AttributeInfo.ID == attr
    else:
        raise TypeError("Need integer or string as argument")
    try:
        result = gamedata_session.query(AttributeInfo).options(*processEager(eager)).filter(filter).one()
    except exc.NoResultFound:
        result = None
    return result

@cachedQuery(1, "field")
def getMetaData(field):
    if isinstance(field, basestring):
        data = gamedata_session.query(MetaData).get(field)
    else:
        raise TypeError("Need string as argument")
    return data

@cachedQuery(2, "itemIDs", "attributeID")
def directAttributeRequest(itemIDs, attrIDs):
    for itemID in itemIDs:
        if not isinstance(itemID, int):
            raise TypeError("All attrIDs must be integer")
    for itemID in itemIDs:
        if not isinstance(itemID, int):
            raise TypeError("All itemIDs must be integer")

    q = select((eos.types.Item.typeID, eos.types.Attribute.attributeID, eos.types.Attribute.value),
                                  and_(eos.types.Attribute.attributeID.in_(attrIDs), eos.types.Item.typeID.in_(itemIDs)),
                                  from_obj=[join(eos.types.Attribute, eos.types.Item)])

    result = gamedata_session.execute(q).fetchall()
    return result

########NEW FILE########
__FILENAME__ = traits

from sqlalchemy import Column, Table, Integer, String, ForeignKey, and_, select
from sqlalchemy.orm import mapper, column_property
from eos.types import Item, Traits
from eos.db import gamedata_meta

traits_table = Table("invtraits", gamedata_meta,
                     Column("typeID", Integer, ForeignKey("invtypes.typeID"), primary_key=True),
                     Column("skillID", Integer, ForeignKey("invtypes.typeID"), primary_key=True),
                     Column("bonusText", String, primary_key=True))


from .item import items_table

mapper(Traits, traits_table,
        properties = {"skillName" : column_property(
                                             select([items_table.c.typeName],
                                                and_(
                                                    items_table.c.typeID == traits_table.c.skillID,
                                                    traits_table.c.skillID != -1
                                                )))
        });

########NEW FILE########
__FILENAME__ = unit
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from sqlalchemy import Column, Table, Integer, String
from sqlalchemy.orm import mapper, synonym

from eos.db import gamedata_meta
from eos.types import Unit

groups_table = Table("dgmunits", gamedata_meta,
                     Column("unitID", Integer, primary_key = True),
                     Column("unitName", String),
                     Column("displayName", String))

mapper(Unit, groups_table,
       properties = {"ID" : synonym("unitID"),
                     "name" : synonym("unitName")})

########NEW FILE########
__FILENAME__ = migration
import sqlalchemy

def update(saveddata_engine):
    checkPriceFailures(saveddata_engine)
    checkApiDefaultChar(saveddata_engine)
    checkFitBooster(saveddata_engine)

def checkPriceFailures(saveddata_engine):
    # Check if we have 'failed' column
    try:
        saveddata_engine.execute("SELECT failed FROM prices")
    except sqlalchemy.exc.DatabaseError:
        # As we don't have any important data there, let's just drop
        # and recreate whole table
        from eos.db.saveddata.price import prices_table
        # Attempt to drop/create table only if it's already there
        try:
            prices_table.drop(saveddata_engine)
            prices_table.create(saveddata_engine)
        except sqlalchemy.exc.DatabaseError:
            pass


def checkApiDefaultChar(saveddata_engine):
    try:
        saveddata_engine.execute("SELECT * FROM characters LIMIT 1")
    # If table doesn't exist, it means we're doing everything from scratch
    # and sqlalchemy will process everything as needed
    except sqlalchemy.exc.DatabaseError:
        pass
    # If not, we're running on top of existing DB
    else:
        # Check that we have columns
        try:
            saveddata_engine.execute("SELECT defaultChar, chars FROM characters LIMIT 1")
        # If we don't, create them
        # This is ugly as hell, but we can't use proper migrate packages as it
        # will require us to rebuild skeletons, including mac
        except sqlalchemy.exc.DatabaseError:
            saveddata_engine.execute("ALTER TABLE characters ADD COLUMN defaultChar INTEGER;")
            saveddata_engine.execute("ALTER TABLE characters ADD COLUMN chars VARCHAR;")

def checkFitBooster(saveddata_engine):
    try:
        saveddata_engine.execute("SELECT * FROM fits LIMIT 1")
    # If table doesn't exist, it means we're doing everything from scratch
    # and sqlalchemy will process everything as needed
    except sqlalchemy.exc.DatabaseError:
        pass
    # If not, we're running on top of existing DB
    else:
        # Check that we have columns
        try:
            saveddata_engine.execute("SELECT booster FROM fits LIMIT 1")
        # If we don't, create them
        except sqlalchemy.exc.DatabaseError:
            saveddata_engine.execute("ALTER TABLE fits ADD COLUMN booster BOOLEAN;")
        # Set NULL data to 0 (needed in case of downgrade, see GH issue #62
        saveddata_engine.execute("UPDATE fits SET booster = 0 WHERE booster IS NULL;")

########NEW FILE########
__FILENAME__ = booster
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from sqlalchemy import Table, Column, ForeignKey, Integer, UniqueConstraint, Boolean
from sqlalchemy.orm import mapper, relation
from sqlalchemy.ext.associationproxy import association_proxy

from eos.db import saveddata_meta
from eos.types import Booster

boosters_table = Table("boosters", saveddata_meta,
                       Column("ID", Integer, primary_key = True),
                       Column("itemID", Integer),
                       Column("fitID", Integer, ForeignKey("fits.ID"), nullable = False),
                       Column("active", Boolean),
                       UniqueConstraint("itemID", "fitID"))

activeSideEffects_table = Table("boostersActiveSideEffects", saveddata_meta,
                                Column("boosterID", ForeignKey("boosters.ID"), primary_key = True),
                                Column("effectID", Integer, primary_key = True))

class ActiveSideEffectsDummy(object):
    def __init__(self, effectID):
        self.effectID = effectID


mapper(ActiveSideEffectsDummy, activeSideEffects_table)
mapper(Booster, boosters_table,
       properties = {"_Booster__activeSideEffectDummies" : relation(ActiveSideEffectsDummy)})

Booster._Booster__activeSideEffectIDs = association_proxy("_Booster__activeSideEffectDummies", "effectID")

########NEW FILE########
__FILENAME__ = cargo
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from sqlalchemy import Table, Column, Integer, ForeignKey, Boolean
from sqlalchemy.orm import mapper

from eos.db import saveddata_meta
from eos.types import Cargo

cargo_table = Table("cargo", saveddata_meta,
                     Column("ID", Integer, primary_key=True),
                     Column("fitID", Integer, ForeignKey("fits.ID"), nullable = False, index = True),
                     Column("itemID", Integer, nullable = False),
                     Column("amount", Integer, nullable = False))

mapper(Cargo, cargo_table)
########NEW FILE########
__FILENAME__ = character
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from sqlalchemy import Table, Column, Integer, ForeignKey, String
from sqlalchemy.orm import relation, mapper

from eos.db import saveddata_meta
from eos.db.saveddata.implant import charImplants_table
from eos.types import Character, User, Skill, Implant
from eos.effectHandlerHelpers import HandledImplantBoosterList

characters_table = Table("characters", saveddata_meta,
                         Column("ID", Integer, primary_key = True),
                         Column("name", String, nullable = False),
                         Column("apiID", Integer),
                         Column("apiKey", String),
                         Column("defaultChar", Integer),
                         Column("chars", String, nullable = True),
                         Column("defaultLevel", Integer, nullable=True),
                         Column("ownerID", ForeignKey("users.ID"), nullable = True))

mapper(Character, characters_table,
       properties = {"_Character__owner" : relation(User, backref = "characters"),
                     "_Character__skills" : relation(Skill, backref="character", cascade = "all,delete-orphan"),
                     "_Character__implants" : relation(Implant, collection_class = HandledImplantBoosterList, cascade='all,delete-orphan', single_parent=True,
                                                       primaryjoin = charImplants_table.c.charID == characters_table.c.ID,
                                                       secondaryjoin = charImplants_table.c.implantID == Implant.ID,
                                                       secondary = charImplants_table),})

########NEW FILE########
__FILENAME__ = damagePattern
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from sqlalchemy import Table, Column, Integer, ForeignKey, String
from sqlalchemy.orm import mapper

from eos.db import saveddata_meta
from eos.types import DamagePattern

damagePatterns_table = Table("damagePatterns", saveddata_meta,
                             Column("ID", Integer, primary_key = True),
                             Column("name", String),
                             Column("emAmount", Integer),
                             Column("thermalAmount", Integer),
                             Column("kineticAmount", Integer),
                             Column("explosiveAmount", Integer),
                             Column("ownerID", ForeignKey("users.ID"), nullable=True))

mapper(DamagePattern, damagePatterns_table)

########NEW FILE########
__FILENAME__ = drone
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from sqlalchemy import Table, Column, Integer, ForeignKey, Boolean
from sqlalchemy.orm import mapper
from eos.db import saveddata_meta
from eos.types import Drone

drones_table = Table("drones", saveddata_meta,
                     Column("groupID", Integer, primary_key=True),
                     Column("fitID", Integer, ForeignKey("fits.ID"), nullable = False, index = True),
                     Column("itemID", Integer, nullable = False),
                     Column("amount", Integer, nullable = False),
                     Column("amountActive", Integer, nullable = False),
                     Column("projected", Boolean, default = False))

mapper(Drone, drones_table)

########NEW FILE########
__FILENAME__ = fit
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from sqlalchemy import Table, Column, Integer, ForeignKey, String, Boolean
from sqlalchemy.orm import relation, mapper
from sqlalchemy.sql import and_

from eos.db import saveddata_meta
from eos.db.saveddata.module import modules_table
from eos.db.saveddata.drone import drones_table
from eos.db.saveddata.cargo import cargo_table
from eos.db.saveddata.implant import fitImplants_table
from eos.types import Fit, Module, User, Booster, Drone, Cargo, Implant, Character, DamagePattern
from eos.effectHandlerHelpers import HandledModuleList, HandledDroneList, \
HandledImplantBoosterList, HandledProjectedModList, HandledProjectedDroneList, \
HandledProjectedFitList, HandledCargoList
fits_table = Table("fits", saveddata_meta,
                         Column("ID", Integer, primary_key = True),
                         Column("ownerID", ForeignKey("users.ID"), nullable = True, index = True),
                         Column("shipID", Integer, nullable = False, index = True),
                         Column("name", String, nullable = False),
                         Column("timestamp", Integer, nullable = False),
                         Column("characterID", ForeignKey("characters.ID"), nullable = True),
                         Column("damagePatternID", ForeignKey("damagePatterns.ID"), nullable=True),
                         Column("booster", Boolean, nullable = False, index = True, default = 0))

projectedFits_table = Table("projectedFits", saveddata_meta,
                            Column("sourceID", ForeignKey("fits.ID"), primary_key = True),
                            Column("victimID", ForeignKey("fits.ID"), primary_key = True),
                            Column("amount", Integer))
mapper(Fit, fits_table,
       properties = {"_Fit__modules" : relation(Module, collection_class = HandledModuleList,
                                                primaryjoin = and_(modules_table.c.fitID == fits_table.c.ID, modules_table.c.projected == False),
                                                order_by = modules_table.c.position, cascade='all, delete, delete-orphan'),
                     "_Fit__projectedModules" : relation(Module, collection_class = HandledProjectedModList, cascade='all, delete, delete-orphan', single_parent=True,
                                                primaryjoin = and_(modules_table.c.fitID == fits_table.c.ID, modules_table.c.projected == True)),
                     "owner" : relation(User, backref = "fits"),
                     "_Fit__boosters" : relation(Booster, collection_class = HandledImplantBoosterList, cascade='all, delete, delete-orphan', single_parent=True),
                     "_Fit__drones" : relation(Drone, collection_class = HandledDroneList, cascade='all, delete, delete-orphan', single_parent=True,
                                               primaryjoin = and_(drones_table.c.fitID == fits_table.c.ID, drones_table.c.projected == False)),
                     "_Fit__cargo" : relation(Cargo, collection_class = HandledCargoList, cascade='all, delete, delete-orphan', single_parent=True,
                                               primaryjoin = and_(cargo_table.c.fitID == fits_table.c.ID)),
                     "_Fit__projectedDrones" : relation(Drone, collection_class = HandledProjectedDroneList, cascade='all, delete, delete-orphan', single_parent=True,
                                               primaryjoin = and_(drones_table.c.fitID == fits_table.c.ID, drones_table.c.projected == True)),
                     "_Fit__implants" : relation(Implant, collection_class = HandledImplantBoosterList, cascade='all, delete, delete-orphan', single_parent=True,
                                                 primaryjoin = fitImplants_table.c.fitID == fits_table.c.ID,
                                                 secondaryjoin = fitImplants_table.c.implantID == Implant.ID,
                                                 secondary = fitImplants_table),
                     "_Fit__character" : relation(Character, backref = "fits"),
                     "_Fit__damagePattern" : relation(DamagePattern),
                     "_Fit__projectedFits" : relation(Fit,
                                                      primaryjoin = projectedFits_table.c.victimID == fits_table.c.ID,
                                                      secondaryjoin = fits_table.c.ID == projectedFits_table.c.sourceID,
                                                      secondary = projectedFits_table,
                                                      collection_class = HandledProjectedFitList)
                     })

########NEW FILE########
__FILENAME__ = fleet
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from sqlalchemy import Table, Column, Integer, ForeignKey, String
from sqlalchemy.orm import mapper, relation

from eos.db import saveddata_meta
from eos.types import Fleet, Wing, Squad, Fit
from eos.db.saveddata.fit import fits_table

gangs_table = Table("gangs", saveddata_meta,
                    Column("ID", Integer, primary_key = True),
                    Column("leaderID", ForeignKey("fits.ID")),
                    Column("boosterID", ForeignKey("fits.ID")),
                    Column("name", String))

wings_table = Table("wings", saveddata_meta,
                    Column("ID", Integer, primary_key = True),
                    Column("gangID", ForeignKey("gangs.ID")),
                    Column("boosterID", ForeignKey("fits.ID")),
                    Column("leaderID", ForeignKey("fits.ID")))

squads_table = Table("squads", saveddata_meta,
                     Column("ID", Integer, primary_key = True),
                     Column("wingID", ForeignKey("wings.ID")),
                     Column("leaderID", ForeignKey("fits.ID")),
                     Column("boosterID", ForeignKey("fits.ID")))

squadmembers_table = Table("squadmembers", saveddata_meta,
                           Column("squadID", ForeignKey("squads.ID"), primary_key = True),
                           Column("memberID", ForeignKey("fits.ID"), primary_key = True))

mapper(Fleet, gangs_table,
       properties = {"wings" : relation(Wing, backref="gang"),
                     "leader" : relation(Fit, primaryjoin = gangs_table.c.leaderID == fits_table.c.ID),
                     "booster": relation(Fit, primaryjoin = gangs_table.c.boosterID == fits_table.c.ID)})

mapper(Wing, wings_table,
       properties = {"squads" : relation(Squad, backref="wing"),
                     "leader" : relation(Fit, primaryjoin = wings_table.c.leaderID == fits_table.c.ID),
                     "booster": relation(Fit, primaryjoin = wings_table.c.boosterID == fits_table.c.ID)})

mapper(Squad, squads_table,
       properties = {"leader" : relation(Fit, primaryjoin = squads_table.c.leaderID == fits_table.c.ID),
                     "booster" : relation(Fit, primaryjoin = squads_table.c.boosterID == fits_table.c.ID),
                     "members" : relation(Fit,
                                          primaryjoin = squads_table.c.ID == squadmembers_table.c.squadID,
                                          secondaryjoin = squadmembers_table.c.memberID == fits_table.c.ID,
                                          secondary = squadmembers_table)})


########NEW FILE########
__FILENAME__ = implant
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from sqlalchemy import Table, Column, Integer, ForeignKey, Boolean
from sqlalchemy.orm import mapper

from eos.db import saveddata_meta
from eos.types import Implant

implants_table = Table("implants", saveddata_meta,
                     Column("ID", Integer, primary_key = True),
                     Column("itemID", Integer),
                     Column("active", Boolean))

fitImplants_table = Table("fitImplants", saveddata_meta,
                          Column("fitID", ForeignKey("fits.ID"), index = True),
                          Column("implantID", ForeignKey("implants.ID"), primary_key = True))

charImplants_table = Table("charImplants", saveddata_meta,
                           Column("charID", ForeignKey("characters.ID"), index = True),
                           Column("implantID", ForeignKey("implants.ID"), primary_key = True))

mapper(Implant, implants_table)

########NEW FILE########
__FILENAME__ = miscData
#===============================================================================
# Copyright (C) 2011 Anton Vorobyov
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from sqlalchemy import Column, Table, String
from sqlalchemy.orm import mapper
from eos.types import MiscData
from eos.db import saveddata_meta

miscdata_table = Table("miscdata", saveddata_meta,
                           Column("fieldName", String, primary_key=True),
                           Column("fieldValue", String))

mapper(MiscData, miscdata_table)

########NEW FILE########
__FILENAME__ = module
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from sqlalchemy import Table, Column, Integer, ForeignKey, CheckConstraint, Boolean
from sqlalchemy.orm import relation, mapper

from eos.db import saveddata_meta
from eos.types import Module, Fit

modules_table = Table("modules", saveddata_meta,
                      Column("ID", Integer, primary_key = True),
                      Column("fitID", Integer, ForeignKey("fits.ID"), nullable = False, index = True),
                      Column("itemID", Integer, nullable = True),
                      Column("dummySlot", Integer, nullable = True, default = None),
                      Column("chargeID", Integer),
                      Column("state", Integer, CheckConstraint("state >= -1"), CheckConstraint("state <= 2")),
                      Column("projected", Boolean, default = False, nullable = False),
                      Column("position", Integer),
                      CheckConstraint('("dummySlot" = NULL OR "itemID" = NULL) AND "dummySlot" != "itemID"'))

mapper(Module, modules_table,
       properties = {"owner" : relation(Fit)})


########NEW FILE########
__FILENAME__ = price
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from sqlalchemy import Table, Column, Float, Integer
from sqlalchemy.orm import mapper
from eos.db import saveddata_meta
from eos.types import Price

prices_table = Table("prices", saveddata_meta,
                     Column("typeID", Integer, primary_key=True),
                     Column("price", Float),
                     Column("time", Integer, nullable = False),
                     Column("failed", Integer))

mapper(Price, prices_table)

########NEW FILE########
__FILENAME__ = queries
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from eos.db.util import processEager, processWhere
from eos.db import saveddata_session, sd_lock
from eos.types import User, Character, Fit, Price, DamagePattern, Fleet, MiscData, Wing, Squad
from eos.db.saveddata.fleet import squadmembers_table
from eos.db.saveddata.fit import projectedFits_table
from sqlalchemy.sql import and_
import eos.config

configVal = getattr(eos.config, "saveddataCache", None)
if configVal is True:
    import weakref
    itemCache = {}
    queryCache = {}
    def cachedQuery(type, amount, *keywords):
        itemCache[type] = localItemCache = weakref.WeakValueDictionary()
        queryCache[type] = typeQueryCache = {}
        def deco(function):
            localQueryCache = typeQueryCache[function] = {}
            def setCache(cacheKey, args, kwargs):
                items = function(*args, **kwargs)
                IDs = set()
                localQueryCache[cacheKey] = (isinstance(items, list), IDs)
                stuff = items if isinstance(items, list) else (items,)
                for item in stuff:
                    ID = getattr(item, "ID", None)
                    if ID is None:
                        #Some uncachable data, don't cache this query
                        del localQueryCache[cacheKey]
                        break
                    localItemCache[ID] = item
                    IDs.add(ID)

                return items

            def checkAndReturn(*args, **kwargs):
                useCache = kwargs.pop("useCache", True)
                cacheKey = []
                cacheKey.extend(args)
                for keyword in keywords:
                    cacheKey.append(kwargs.get(keyword))

                cacheKey = tuple(cacheKey)
                info = localQueryCache.get(cacheKey)
                if info is None or not useCache:
                    items = setCache(cacheKey, args, kwargs)
                else:
                    l, IDs = info
                    if l:
                        items = []
                        for ID in IDs:
                            data = localItemCache.get(ID)
                            if data is None:
                                #Fuck, some of our stuff isn't cached it seems.
                                items = setCache(cacheKey, args, kwargs)
                                break
                            items.append(data)
                    else:
                        for ID in IDs:
                            items = localItemCache.get(ID)
                            if items is None:
                                items = setCache(cacheKey, args, kwargs)
                            break

                return items
            return checkAndReturn
        return deco

    def removeCachedEntry(type, ID):
        if not type in queryCache:
            return
        functionCache = queryCache[type]
        for _, localCache in functionCache.iteritems():
            toDelete = set()
            for cacheKey, info in localCache.iteritems():
                IDs = info[1]
                if ID in IDs:
                    toDelete.add(cacheKey)

            for cacheKey in toDelete:
                del localCache[cacheKey]

            if ID in itemCache[type]:
                del itemCache[type][ID]

elif callable(configVal):
    cachedQuery, removeCachedEntry = eos.config.gamedataCache
else:
    def cachedQuery(amount, *keywords):
        def deco(function):
            def checkAndReturn(*args, **kwargs):
                return function(*args, **kwargs)

            return checkAndReturn
        return deco

    def removeCachedEntry(*args, **kwargs):
        return

def sqlizeString(line):
    # Escape backslashes first, as they will be as escape symbol in queries
    # Then escape percent and underscore signs
    # Finally, replace generic wildcards with sql-style wildcards
    line = line.replace("\\", "\\\\").replace("%", "\\%").replace("_", "\\_").replace("*", "%")
    return line

@cachedQuery(User, 1, "lookfor")
def getUser(lookfor, eager=None):
    if isinstance(lookfor, int):
        if eager is None:
            with sd_lock:
                user = saveddata_session.query(User).get(lookfor)
        else:
            eager = processEager(eager)
            with sd_lock:
                user = saveddata_session.query(User).options(*eager).filter(User.ID == lookfor).first()
    elif isinstance(lookfor, basestring):
        eager = processEager(eager)
        with sd_lock:
            user = saveddata_session.query(User).options(*eager).filter(User.username == lookfor).first()
    else:
        raise TypeError("Need integer or string as argument")
    return user

@cachedQuery(Character, 1, "lookfor")
def getCharacter(lookfor, eager=None):
    if isinstance(lookfor, int):
        if eager is None:
            with sd_lock:
                character = saveddata_session.query(Character).get(lookfor)
        else:
            eager = processEager(eager)
            with sd_lock:
                character = saveddata_session.query(Character).options(*eager).filter(Character.ID == lookfor).first()
    elif isinstance(lookfor, basestring):
        eager = processEager(eager)
        with sd_lock:
            character = saveddata_session.query(Character).options(*eager).filter(Character.name == lookfor).first()
    else:
        raise TypeError("Need integer or string as argument")
    return character

def getCharacterList(eager=None):
    eager = processEager(eager)
    with sd_lock:
        characters = saveddata_session.query(Character).options(*eager).all()
    return characters

def getCharactersForUser(lookfor, eager=None):
    if isinstance(lookfor, int):
        eager = processEager(eager)
        with sd_lock:
            characters = saveddata_session.query(Character).options(*eager).filter(Character.ownerID == lookfor).all()
    else:
        raise TypeError("Need integer as argument")
    return characters

@cachedQuery(Fit, 1, "lookfor")
def getFit(lookfor, eager=None):
    if isinstance(lookfor, int):
        if eager is None:
            with sd_lock:
                fit = saveddata_session.query(Fit).get(lookfor)
        else:
            eager = processEager(eager)
            with sd_lock:
                fit = saveddata_session.query(Fit).options(*eager).filter(Fit.ID == fitID).first()
    else:
        raise TypeError("Need integer as argument")
    return fit

@cachedQuery(Fleet, 1, "fleetID")
def getFleet(fleetID, eager=None):
    if isinstance(fleetID, int):
        if eager is None:
            with sd_lock:
                fleet = saveddata_session.query(Fleet).get(fleetID)
        else:
            eager = processEager(eager)
            with sd_lock:
                fleet = saveddata_session.query(Fleet).options(*eager).filter(Fleet.ID == fleetID).first()
    else:
        raise TypeError("Need integer as argument")
    return fleet

@cachedQuery(Wing, 1, "wingID")
def getWing(wingID, eager=None):
    if isinstance(wingID, int):
        if eager is None:
            with sd_lock:
                wing = saveddata_session.query(Wing).get(wingID)
        else:
            eager = processEager(eager)
            with sd_lock:
                wing = saveddata_session.query(Wing).options(*eager).filter(Wing.ID == wingID).first()
    else:
        raise TypeError("Need integer as argument")
    return wing

@cachedQuery(Squad, 1, "squadID")
def getSquad(squadID, eager=None):
    if isinstance(squadID, int):
        if eager is None:
            with sd_lock:
                squad = saveddata_session.query(Squad).get(squadID)
        else:
            eager = processEager(eager)
            with sd_lock:
                squad = saveddata_session.query(Squad).options(*eager).filter(Fleet.ID == squadID).first()
    else:
        raise TypeError("Need integer as argument")
    return squad

def getFitsWithShip(shipID, ownerID=None, where=None, eager=None):
    """
    Get all the fits using a certain ship.
    If no user is passed, do this for all users.
    """
    if isinstance(shipID, int):
        if ownerID is not None and not isinstance(ownerID, int):
            raise TypeError("OwnerID must be integer")
        filter = Fit.shipID == shipID
        if ownerID is not None:
            filter = and_(filter, Fit.ownerID == ownerID)

        filter = processWhere(filter, where)
        eager = processEager(eager)
        with sd_lock:
            fits = saveddata_session.query(Fit).options(*eager).filter(filter).all()
    else:
        raise TypeError("ShipID must be integer")
    return fits

def getBoosterFits(ownerID=None, where=None, eager=None):
    """
    Get all the fits that are flagged as a boosting ship
    If no user is passed, do this for all users.
    """

    if ownerID is not None and not isinstance(ownerID, int):
        raise TypeError("OwnerID must be integer")
    filter = Fit.booster == 1
    if ownerID is not None:
        filter = and_(filter, Fit.ownerID == ownerID)

    filter = processWhere(filter, where)
    eager = processEager(eager)
    with sd_lock:
        fits = saveddata_session.query(Fit).options(*eager).filter(filter).all()
    return fits

def countFitsWithShip(shipID, ownerID=None, where=None, eager=None):
    """
    Get all the fits using a certain ship.
    If no user is passed, do this for all users.
    """
    if isinstance(shipID, int):
        if ownerID is not None and not isinstance(ownerID, int):
            raise TypeError("OwnerID must be integer")
        filter = Fit.shipID == shipID
        if ownerID is not None:
            filter = and_(filter, Fit.ownerID == ownerID)

        filter = processWhere(filter, where)
        eager = processEager(eager)
        with sd_lock:
            count = saveddata_session.query(Fit).options(*eager).filter(filter).count()
    else:
        raise TypeError("ShipID must be integer")
    return count

def getFitList(eager=None):
    eager = processEager(eager)
    with sd_lock:
        fits = saveddata_session.query(Fit).options(*eager).all()
    return fits

def getFleetList(eager=None):
    eager = processEager(eager)
    with sd_lock:
        fleets = saveddata_session.query(Fleet).options(*eager).all()
    return fleets

@cachedQuery(Price, 1, "typeID")
def getPrice(typeID):
    if isinstance(typeID, int):
        with sd_lock:
            price = saveddata_session.query(Price).get(typeID)
    else:
        raise TypeError("Need integer as argument")
    return price

def getMiscData(field):
    if isinstance(field, basestring):
        with sd_lock:
            data = saveddata_session.query(MiscData).get(field)
    else:
        raise TypeError("Need string as argument")
    return data

def getDamagePatternList(eager=None):
    eager = processEager(eager)
    with sd_lock:
        patterns = saveddata_session.query(DamagePattern).options(*eager).all()
    return patterns

@cachedQuery(DamagePattern, 1, "lookfor")
def getDamagePattern(lookfor, eager=None):
    if isinstance(lookfor, int):
        if eager is None:
            with sd_lock:
                pattern = saveddata_session.query(DamagePattern).get(lookfor)
        else:
            eager = processEager(eager)
            with sd_lock:
                pattern = saveddata_session.query(DamagePattern).options(*eager).filter(DamagePattern.ID == lookfor).first()
    elif isinstance(lookfor, basestring):
        eager = processEager(eager)
        with sd_lock:
            pattern = saveddata_session.query(DamagePattern).options(*eager).filter(DamagePattern.name == lookfor).first()
    else:
        raise TypeError("Need integer or string as argument")
    return pattern

def searchFits(nameLike, where=None, eager=None):
    if not isinstance(nameLike, basestring):
        raise TypeError("Need string as argument")
    # Prepare our string for request
    nameLike = u"%{0}%".format(sqlizeString(nameLike))

    #Add any extra components to the search to our where clause
    filter = processWhere(Fit.name.like(nameLike, escape="\\"), where)
    eager = processEager(eager)
    with sd_lock:
        fits = saveddata_session.query(Fit).options(*eager).filter(filter).all()
    return fits

def getSquadsIDsWithFitID(fitID):
    if isinstance(fitID, int):
        with sd_lock:
            squads = saveddata_session.query(squadmembers_table.c.squadID).filter(squadmembers_table.c.memberID == fitID).all()
            squads = tuple(entry[0] for entry in squads)
            return squads
    else:
        raise TypeError("Need integer as argument")
        
def getProjectedFits(fitID):
    if isinstance(fitID, int):
        with sd_lock:
            filter = and_(projectedFits_table.c.sourceID == fitID, Fit.ID == projectedFits_table.c.victimID)
            fits = saveddata_session.query(Fit).filter(filter).all()
            return fits
    else:
        raise TypeError("Need integer as argument")        

def add(stuff):
    with sd_lock:
        saveddata_session.add(stuff)

def save(stuff):
    add(stuff)
    commit()

def remove(stuff):
    removeCachedEntry(type(stuff), stuff.ID)
    with sd_lock:
        saveddata_session.delete(stuff)
    commit()


def commit():
    with sd_lock:
        saveddata_session.commit()
        saveddata_session.flush()

########NEW FILE########
__FILENAME__ = skill
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from sqlalchemy import Table, Column, Integer, ForeignKey
from sqlalchemy.orm import mapper

from eos.db import saveddata_meta
from eos.types import Skill

skills_table = Table("characterSkills", saveddata_meta,
                     Column("characterID", ForeignKey("characters.ID"), primary_key = True, index = True),
                     Column("itemID", Integer, primary_key = True),
                     Column("_Skill__level", Integer, nullable = True))

mapper(Skill, skills_table)

########NEW FILE########
__FILENAME__ = user
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from sqlalchemy import Table, Column, Integer, String, Boolean
from sqlalchemy.orm import mapper

from eos.db import saveddata_meta
from eos.types import User

users_table = Table("users", saveddata_meta,
                         Column("ID", Integer, primary_key = True),
                         Column("username", String, nullable = False, unique = True),
                         Column("password", String, nullable = False),
                         Column("admin", Boolean, nullable = False))

mapper(User, users_table)

########NEW FILE########
__FILENAME__ = util
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from sqlalchemy.orm import eagerload
from sqlalchemy.sql import and_

replace = {"attributes": "_Item__attributes",
           "modules": "_Fit__modules",
           "projectedModules": "_Fit__projectedModules",
           "boosters": "_Fit__boosters",
           "drones": "_Fit__drones",
           "projectedDrones": "_Fit__projectedDrones",
           "implants": "_Fit__implants",
           "character": "_Fit__character",
           "damagePattern": "_Fit__damagePattern",
           "projectedFits": "_Fit__projectedFits"}

def processEager(eager):
    if eager == None:
        return tuple()
    else:
        l = []
        if isinstance(eager, basestring):
            eager = (eager,)

        for e in eager:
            l.append(eagerload(_replacements(e)))

        return l

def _replacements(eagerString):
    splitEager = eagerString.split(".")
    for i in xrange(len(splitEager)):
        part = splitEager[i]
        replacement = replace.get(part)
        if replacement:
            splitEager[i] = replacement

    return ".".join(splitEager)

def processWhere(clause, where):
    if where is not None:
        if not hasattr(where, "__iter__"):
            where = (where,)

        try:
            for extraClause in where:
                clause = and_(clause, extraClause)
        except NotImplementedError:
            clause = and_(clause, where)

    return clause

########NEW FILE########
__FILENAME__ = effectHandlerHelpers
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import eos.db
import eos.types

class HandledList(list):
    def filteredItemPreAssign(self, filter, *args, **kwargs):
        for element in self:
            try:
                if filter(element):
                    element.preAssignItemAttr(*args, **kwargs)
            except AttributeError:
                pass

    def filteredItemIncrease(self, filter, *args, **kwargs):
        for element in self:
            try:
                if filter(element):
                    element.increaseItemAttr(*args, **kwargs)
            except AttributeError:
                pass

    def filteredItemMultiply(self, filter, *args, **kwargs):
        for element in self:
            try:
                if filter(element):
                    element.multiplyItemAttr(*args, **kwargs)
            except AttributeError:
                pass

    def filteredItemBoost(self, filter, *args, **kwargs):
        for element in self:
            try:
                if filter(element):
                    element.boostItemAttr(*args, **kwargs)
            except AttributeError:
                pass

    def filteredItemForce(self, filter, *args, **kwargs):
        for element in self:
            try:
                if filter(element):
                    element.forceItemAttr(*args, **kwargs)
            except AttributeError:
                pass

    def filteredChargePreAssign(self, filter, *args, **kwargs):
        for element in self:
            try:
                if filter(element):
                    element.preAssignChargeAttr(*args, **kwargs)
            except AttributeError:
                pass

    def filteredChargeIncrease(self, filter, *args, **kwargs):
        for element in self:
            try:
                if filter(element):
                    element.increaseChargeAttr(*args, **kwargs)
            except AttributeError:
                pass

    def filteredChargeMultiply(self, filter, *args, **kwargs):
        for element in self:
            try:
                if filter(element):
                    element.multiplyChargeAttr(*args, **kwargs)
            except AttributeError:
                pass

    def filteredChargeBoost(self, filter, *args, **kwargs):
        for element in self:
            try:
                if filter(element):
                    element.boostChargeAttr(*args, **kwargs)
            except AttributeError:
                pass

    def filteredChargeForce(self, filter, *args, **kwargs):
        for element in self:
            try:
                if filter(element):
                    element.forceChargeAttr(*args, **kwargs)
            except AttributeError:
                pass

class HandledModuleList(HandledList):
    def append(self, mod):
        emptyPosition = float("Inf")
        for i in xrange(len(self)):
            currMod = self[i]
            if currMod.isEmpty and not mod.isEmpty and currMod.slot == mod.slot:
                currPos = mod.position or i
                if currPos < emptyPosition:
                    emptyPosition = currPos

        if emptyPosition < len(self):
            del self[emptyPosition]
            mod.position = emptyPosition
            HandledList.insert(self, emptyPosition, mod)
            return

        mod.position = len(self)
        HandledList.append(self, mod)

    def insert(self, index, mod):
        mod.position = index
        i = index
        while i < len(self):
            self[i].position += 1
            i += 1
        HandledList.insert(self, index, mod)

    def remove(self, mod):
        HandledList.remove(self, mod)
        oldPos = mod.position

        mod.position = None
        for i in xrange(oldPos, len(self)):
            self[i].position -= 1

    def toDummy(self, index):
        mod = self[index]
        if not mod.isEmpty:
            dummy = eos.types.Module.buildEmpty(mod.slot)
            dummy.position = index
            self[index] = dummy

    def freeSlot(self, slot):
        for i in range(len(self) -1, -1, -1):
            mod = self[i]
            if mod.getModifiedItemAttr("subSystemSlot") == slot:
                del self[i]

class HandledDroneList(HandledList):
    def find(self, item):
        for d in self:
            if d.item == item:
                yield d

    def findFirst(self, item):
        for d in self.find(item):
            return d

    def append(self, drone):
        list.append(self, drone)

    def remove(self, drone):
        HandledList.remove(self, drone)

    def appendItem(self, item, amount = 1):
        if amount < 1: ValueError("Amount of drones to add should be >= 1")
        d = self.findFirst(item)

        if d is None:
            d = eos.types.Drone(item)
            self.append(d)

        d.amount += amount
        return d

    def removeItem(self, item, amount):
        if amount < 1: ValueError("Amount of drones to remove should be >= 1")
        d = self.findFirst(item)
        if d is None: return
        d.amount -= amount
        if d.amount <= 0:
            self.remove(d)
            return None

        return d

class HandledCargoList(HandledList):
    # shameless copy of HandledDroneList
    # I have no idea what this does, but I needed it
    # @todo: investigate this
    def find(self, item):
        for d in self:
            if d.item == item:
                yield d

    def findFirst(self, item):
        for d in self.find(item):
            return d

    def append(self, cargo):
        list.append(self, cargo)

    def remove(self, cargo):
        HandledList.remove(self, cargo)

    def appendItem(self, item, qty = 1):
        if qty < 1: ValueError("Amount of cargo to add should be >= 1")
        d = self.findFirst(item)

        if d is None:
            d = eos.types.Cargo(item)
            self.append(d)

        d.qty += qty
        return d

    def removeItem(self, item, qty):
        if qty < 1: ValueError("Amount of cargo to remove should be >= 1")
        d = self.findFirst(item)
        if d is None: return
        d.qty -= qty
        if d.qty <= 0:
            self.remove(d)
            return None

        return d

class HandledImplantBoosterList(HandledList):
    def __init__(self):
        self.__slotCache = {}

    def append(self, implant):
        if self.__slotCache.has_key(implant.slot):
            raise ValueError("Implant/Booster slot already in use, remove the old one first or set replace = True")
        self.__slotCache[implant.slot] = implant
        HandledList.append(self, implant)

    def remove(self, implant):
        HandledList.remove(self, implant)
        del self.__slotCache[implant.slot]
        # While we deleted this implant, in edge case seems like not all references
        # to it are removed and object still lives in session; forcibly remove it,
        # or otherwise when adding the same booster twice booster's table (typeID, fitID)
        # constraint will report database integrity error
        # TODO: make a proper fix, probably by adjusting fit-boosters sqlalchemy relationships
        eos.db.remove(implant)

    def freeSlot(self, slot):
        if hasattr(slot, "slot"):
            slot = slot.slot

        try:
            implant = self.__slotCache[slot]
        except KeyError:
            return False
        try:
            self.remove(implant)
        except ValueError:
            return False
        return True

class HandledProjectedModList(HandledList):
    def append(self, proj):
        proj.projected = True
        HandledList.append(self, proj)

class HandledProjectedDroneList(HandledDroneList):
    def append(self, proj):
        proj.projected = True
        list.append(self, proj)

class HandledProjectedFitList(HandledList):
    def append(self, proj):
        proj.projected = True
        list.append(self, proj)

class HandledItem(object):
    def preAssignItemAttr(self, *args, **kwargs):
        self.itemModifiedAttributes.preAssign(*args, **kwargs)

    def increaseItemAttr(self, *args, **kwargs):
        self.itemModifiedAttributes.increase(*args, **kwargs)

    def multiplyItemAttr(self, *args, **kwargs):
        self.itemModifiedAttributes.multiply(*args, **kwargs)

    def boostItemAttr(self, *args, **kwargs):
        self.itemModifiedAttributes.boost(*args, **kwargs)

    def forceItemAttr(self, *args, **kwargs):
        self.itemModifiedAttributes.force(*args, **kwargs)

class HandledCharge(object):
    def preAssignChargeAttr(self, *args, **kwargs):
        self.chargeModifiedAttributes.preAssign(*args, **kwargs)

    def increaseChargeAttr(self, *args, **kwargs):
        self.chargeModifiedAttributes.increase(*args, **kwargs)

    def multiplyChargeAttr(self, *args, **kwargs):
        self.chargeModifiedAttributes.multiply(*args, **kwargs)

    def boostChargeAttr(self, *args, **kwargs):
        self.chargeModifiedAttributes.boost(*args, **kwargs)

    def forceChargeAttr(self, *args, **kwargs):
        self.chargeModifiedAttributes.force(*args, **kwargs)

########NEW FILE########
__FILENAME__ = accerationcontrolcapneedbonuspostpercentcapacitorneedlocationshipgroupafterburner
# Used by:
# Modules named like: Dynamic Fuel Valve (8 of 8)
type = "passive"
def handler(fit, container, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Propulsion Module",
                                  "capacitorNeed", container.getModifiedItemAttr("capNeedBonus"))

########NEW FILE########
__FILENAME__ = accerationcontrolskillabmwdspeedboost
# Used by:
# Implant: Zor's Custom Navigation Hyper-Link
# Skill: Acceleration Control
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Propulsion Module",
                                  "speedFactor", container.getModifiedItemAttr("speedFBonus") * level)

########NEW FILE########
__FILENAME__ = accerationcontrolspeedfbonuspostpercentspeedfactorlocationshipgroupafterburner
# Used by:
# Implants named like: Eifyr and Co. 'Rogue' Acceleration Control AC (6 of 6)
type = "passive"
def handler(fit, implant, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Propulsion Module",
                                  "speedFactor", implant.getModifiedItemAttr("speedFBonus"))

########NEW FILE########
__FILENAME__ = accessdifficultybonusmodifierrequiringarchaelogy
# Used by:
# Modules named like: Emission Scope Sharpener (8 of 8)
# Implant: Poteque 'Prospector' Archaeology AC-905
type = "passive"
def handler(fit, container, context):
    fit.modules.filteredItemIncrease(lambda module: module.item.requiresSkill("Archaeology"),
                                     "accessDifficultyBonus",
                                     container.getModifiedItemAttr("accessDifficultyBonusModifier"), position="post")

########NEW FILE########
__FILENAME__ = accessdifficultybonusmodifierrequiringhacking
# Used by:
# Modules named like: Memetic Algorithm Bank (8 of 8)
# Implant: Poteque 'Prospector' Hacking HC-905
type = "passive"
def handler(fit, container, context):
    fit.modules.filteredItemIncrease(lambda c: c.item.requiresSkill("Hacking"),
                                  "accessDifficultyBonus",
                                  container.getModifiedItemAttr("accessDifficultyBonusModifier"), position="post")

########NEW FILE########
__FILENAME__ = adaptivearmorhardener
# Used by:
# Module: Reactive Armor Hardener
type = "active"
def handler(fit, module, context):
    for type in ("kinetic", "thermal", "explosive", "em"):
        attr = "armor%sDamageResonance" % type.capitalize()
        fit.ship.multiplyItemAttr(attr, module.getModifiedItemAttr(attr),
                                  stackingPenalties=True, penaltyGroup="preMul")

########NEW FILE########
__FILENAME__ = addtosignatureradius2
# Used by:
# Modules from group: Shield Extender (37 of 37)
type = "passive"
def handler(fit, module, context):
    fit.ship.increaseItemAttr("signatureRadius", module.getModifiedItemAttr("signatureRadiusAdd"))
########NEW FILE########
__FILENAME__ = advanceddroneinterfacingmaxgroupdcuskilllevel
# Used by:
# Skill: Advanced Drone Interfacing
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemIncrease(lambda mod: mod.item.group.name == "Drone Control Unit",
                                     "maxGroupActive", skill.level)

########NEW FILE########
__FILENAME__ = afterburnerdurationbonuspostpercentdurationlocationshipmodulesrequiringafterburner
# Used by:
# Implants named like: Eifyr and Co. 'Rogue' Afterburner AB (6 of 6)
# Implant: Zor's Custom Navigation Link
# Skill: Afterburner
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Afterburner"),
                                     "duration", container.getModifiedItemAttr("durationBonus") * level)

########NEW FILE########
__FILENAME__ = agilitymultipliereffect
# Used by:
# Modules from group: Inertia Stabilizer (12 of 12)
# Modules from group: Nanofiber Internal Structure (14 of 14)
# Modules from group: Reinforced Bulkhead (12 of 12)
type = "passive"
def handler(fit, module, context):
    fit.ship.boostItemAttr("agility",
                           module.getModifiedItemAttr("agilityMultiplier"),
                           stackingPenalties = True)

########NEW FILE########
__FILENAME__ = agilitymultipliereffectpassive
# Used by:
# Modules named like: Polycarbon Engine Housing (8 of 8)
type = "passive"
def handler(fit, module, context):
    fit.ship.boostItemAttr("agility", module.getModifiedItemAttr("agilityMultiplier"), stackingPenalties = True)

########NEW FILE########
__FILENAME__ = ammofallofmultiplier
# Used by:
# Charges from group: Advanced Artillery Ammo (6 of 6)
# Charges from group: Advanced Autocannon Ammo (6 of 6)
# Charges from group: Advanced Beam Laser Crystal (6 of 6)
# Charges from group: Advanced Blaster Charge (6 of 6)
# Charges from group: Advanced Pulse Laser Crystal (6 of 6)
# Charges from group: Advanced Railgun Charge (6 of 6)
type = "passive"
def handler(fit, module, context):
    module.multiplyItemAttr("falloff", module.getModifiedChargeAttr("fallofMultiplier") or 1)

########NEW FILE########
__FILENAME__ = ammoinfluencecapneed
# Used by:
# Items from category: Charge (458 of 828)
type = "passive"
def handler(fit, module, context):
    # Dirty hack to work around cap charges setting cap booster
    # injection amount to zero
    rawAttr = module.item.getAttribute("capacitorNeed")
    if rawAttr is not None and rawAttr >= 0:
        module.boostItemAttr("capacitorNeed", module.getModifiedChargeAttr("capNeedBonus") or 0)

########NEW FILE########
__FILENAME__ = ammoinfluencerange
# Used by:
# Items from category: Charge (559 of 828)
type = "passive"
def handler(fit, module, context):
    module.multiplyItemAttr("maxRange", module.getModifiedChargeAttr("weaponRangeMultiplier"))
########NEW FILE########
__FILENAME__ = ammospeedmultiplier
# Used by:
# Charges from group: Festival Charges (8 of 8)
# Charges from group: Survey Probe (3 of 3)
# Charge: Warp Disrupt Probe
type = "passive"
def handler(fit, module, context):
    module.multiplyItemAttr("speed", module.getModifiedChargeAttr("speedMultiplier") or 1)

########NEW FILE########
__FILENAME__ = ammotrackingmultiplier
# Used by:
# Charges from group: Advanced Artillery Ammo (6 of 6)
# Charges from group: Advanced Autocannon Ammo (6 of 6)
# Charges from group: Advanced Beam Laser Crystal (6 of 6)
# Charges from group: Advanced Blaster Charge (6 of 6)
# Charges from group: Advanced Pulse Laser Crystal (6 of 6)
# Charges from group: Advanced Railgun Charge (6 of 6)
# Charges from group: Projectile Ammo (129 of 129)
type = "passive"
def handler(fit, module, context):
    module.multiplyItemAttr("trackingSpeed", module.getModifiedChargeAttr("trackingSpeedMultiplier"))
########NEW FILE########
__FILENAME__ = angelsetbonus
# Used by:
# Implants named like: Halo (12 of 12)
runTime = "early"
type = "passive"
def handler(fit, implant, context):
    fit.implants.filteredItemMultiply(
        lambda implant: "signatureRadiusBonus" in implant.itemModifiedAttributes and "implantSetAngel" in implant.itemModifiedAttributes,
        "signatureRadiusBonus",
        implant.getModifiedItemAttr("implantSetAngel"))
########NEW FILE########
__FILENAME__ = antiwarpscramblingpassive
# Used by:
# Modules from group: Warp Core Stabilizer (8 of 8)
type = "passive"
def handler(fit, module, context):
    fit.ship.increaseItemAttr("warmScrambleStatus", module.getModifiedItemAttr("warpScrambleStrength"))
########NEW FILE########
__FILENAME__ = archaeologyskillvirusbonus
# Used by:
# Modules named like: Emission Scope Sharpener (8 of 8)
# Implant: Poteque 'Prospector' Archaeology AC-905
# Skill: Archaeology
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemIncrease(lambda mod: mod.item.requiresSkill("Archaeology"),
                                     "virusCoherence", container.getModifiedItemAttr("virusCoherenceBonus") * level)

########NEW FILE########
__FILENAME__ = armorallrepairsystemsamountbonuspassive
# Used by:
# Implants named like: Exile Booster (4 of 4)
type = "passive"
def handler(fit, booster, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Repair Systems") or mod.item.requiresSkill("Capital Repair Systems"),
                                  "armorDamageAmount", booster.getModifiedItemAttr("armorDamageAmountBonus"))

########NEW FILE########
__FILENAME__ = armordamageamountbonuscapitalarmorrepairers
# Used by:
# Modules named like: Auxiliary Nano Pump (8 of 8)
type = "passive"
def handler(fit, implant, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Repair Systems"),
                                  "armorDamageAmount", implant.getModifiedItemAttr("repairBonus"),
                                  stackingPenalties = True)

########NEW FILE########
__FILENAME__ = armoredsquadroncommand
# Used by:
# Skill: Armored Warfare Specialist
runTime = "early"
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Armored Warfare Specialist"),
                                  "commandBonus", skill.getModifiedItemAttr("squadronCommandBonus") * skill.level)

########NEW FILE########
__FILENAME__ = armoredwarfaremindlink
# Used by:
# Implant: Armored Warfare Mindlink
# Implant: Federation Navy Warfare Mindlink
# Implant: Imperial Navy Warfare Mindlink
type = "passive"
def handler(fit, implant, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Armored Warfare Specialist"),
                                  "commandBonus", implant.getModifiedItemAttr("mindlinkBonus"))
########NEW FILE########
__FILENAME__ = armorhpbonusadd
# Used by:
# Modules from group: Armor Reinforcer (57 of 57)
type = "passive"
def handler(fit, module, context):
    fit.ship.increaseItemAttr("armorHP", module.getModifiedItemAttr("armorHPBonusAdd"))
########NEW FILE########
__FILENAME__ = armorhpbonusaddpassive
# Used by:
# Subsystems from group: Defensive Systems (16 of 16)
type = "passive"
def handler(fit, module, context):
    fit.ship.increaseItemAttr("armorHP", module.getModifiedItemAttr("armorHPBonusAdd"))

########NEW FILE########
__FILENAME__ = armorhpmultiply
# Used by:
# Modules from group: Armor Coating (202 of 202)
# Modules from group: Armor Plating Energized (187 of 187)
# Modules named like: QA Multiship Module Players (4 of 4)
type = "passive"
def handler(fit, module, context):
    fit.ship.multiplyItemAttr("armorHP", module.getModifiedItemAttr("armorHPMultiplier"))
########NEW FILE########
__FILENAME__ = armorreinforcermassadd
# Used by:
# Modules from group: Armor Reinforcer (57 of 57)
type = "passive"
def handler(fit, module, context):
    fit.ship.increaseItemAttr("mass", module.getModifiedItemAttr("massAddition"))
########NEW FILE########
__FILENAME__ = armorrepair
# Used by:
# Modules from group: Armor Repair Unit (100 of 100)
runTime = "late"
type = "active"
def handler(fit, module, context):
    amount = module.getModifiedItemAttr("armorDamageAmount")
    speed = module.getModifiedItemAttr("duration") / 1000.0
    fit.extraAttributes.increase("armorRepair", amount / speed)
########NEW FILE########
__FILENAME__ = armorrepairprojectormaxrangebonus
# Used by:
# Ship: Augoror
# Ship: Exequror
# Ship: Inquisitor
# Ship: Navitas
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Armor Repairer",
                                  "maxRange", ship.getModifiedItemAttr("maxRangeBonus"))

########NEW FILE########
__FILENAME__ = armortankinggang
# Used by:
# Skill: Armored Warfare
type = "gang"
gangBoost = "armorHP"
gangBonus = "armorHpBonus"
def handler(fit, skill, context):
    fit.ship.boostItemAttr(gangBoost, skill.getModifiedItemAttr(gangBonus) * skill.level)

########NEW FILE########
__FILENAME__ = armortankinggang2
# Used by:
# Implant: Armored Warfare Mindlink
# Implant: Federation Navy Warfare Mindlink
# Implant: Imperial Navy Warfare Mindlink
type = "gang", "active"
gangBonus = "armorHpBonus2"
gangBoost = "armorHP"
def handler(fit, module, context):
    if "gang" not in context: return
    fit.ship.boostItemAttr("armorHP", module.getModifiedItemAttr("armorHpBonus2"))

########NEW FILE########
__FILENAME__ = armorupgradesmasspenaltyreductionbonus
# Used by:
# Skill: Armor Layering
type = "passive"
def handler(fit, container, context):
    level = container.level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Armor Reinforcer",
                                  "massAddition", container.getModifiedItemAttr("massPenaltyReduction") * level)

########NEW FILE########
__FILENAME__ = astrogeologyminingamountbonuspostpercentminingamountlocationshipmodulesrequiringmining
# Used by:
# Implants named like: Inherent Implants 'Highwall' Mining MX (3 of 3)
# Implant: Michi's Excavation Augmentor
# Skill: Astrogeology
# Skill: Mining
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Mining"),
                                  "miningAmount", container.getModifiedItemAttr("miningAmountBonus") * level)

########NEW FILE########
__FILENAME__ = basemaxscandeviationmodifiermoduleonline2none
# Used by:
# Variations of module: Scan Pinpointing Array I (2 of 2)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Astrometrics"),
                                    "baseMaxScanDeviation", module.getModifiedItemAttr("maxScanDeviationModifierModule"),
                                    stackingPenalties=True)

########NEW FILE########
__FILENAME__ = basemaxscandeviationmodifierrequiringastrometrics
# Used by:
# Implants named like: Poteque 'Prospector' Astrometric Pinpointing AP (3 of 3)
# Skill: Astrometric Pinpointing
# Skill: Astrometrics
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Astrometrics"),
                                    "baseMaxScanDeviation", container.getModifiedItemAttr("maxScanDeviationModifier") * level)

########NEW FILE########
__FILENAME__ = basesensorstrengthmodifiermodule
# Used by:
# Variations of module: Scan Rangefinding Array I (2 of 2)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Astrometrics"),
                                    "baseSensorStrength", module.getModifiedItemAttr("scanStrengthBonusModule"),
                                    stackingPenalties=True)

########NEW FILE########
__FILENAME__ = basesensorstrengthmodifierrequiringastrometrics
# Used by:
# Modules from group: Scan Probe Launcher (4 of 7)
# Implants named like: Low grade Virtue (5 of 6)
# Implants named like: Poteque 'Prospector' Astrometric Rangefinding AR (3 of 3)
# Modules named like: Gravity Capacitor Upgrade (8 of 8)
# Skill: Astrometric Rangefinding
# Skill: Astrometrics
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    penalized = False if "skill" in context or "implant" in context else True
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Astrometrics"),
                                    "baseSensorStrength", container.getModifiedItemAttr("scanStrengthBonus") * level,
                                    stackingPenalties=penalized)

########NEW FILE########
__FILENAME__ = bclargeenergyturretcapacitorneedbonus
# Used by:
# Ship: Oracle
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.requiresSkill("Large Energy Turret"),
                                     "capacitorNeed", ship.getModifiedItemAttr("bcLargeTurretCap"))

########NEW FILE########
__FILENAME__ = bclargeenergyturretcpuneedbonus
# Used by:
# Ship: Oracle
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.requiresSkill("Large Energy Turret"),
                                     "cpu", ship.getModifiedItemAttr("bcLargeTurretCPU"))

########NEW FILE########
__FILENAME__ = bclargeenergyturretpowerneedbonus
# Used by:
# Ship: Oracle
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.requiresSkill("Large Energy Turret"),
                                     "power", ship.getModifiedItemAttr("bcLargeTurretPower"))

########NEW FILE########
__FILENAME__ = bclargehybridturretcapacitorneedbonus
# Used by:
# Ship: Naga
# Ship: Talos
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.requiresSkill("Large Hybrid Turret"),
                                     "capacitorNeed", ship.getModifiedItemAttr("bcLargeTurretCap"))

########NEW FILE########
__FILENAME__ = bclargehybridturretcpuneedbonus
# Used by:
# Ship: Naga
# Ship: Talos
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.requiresSkill("Large Hybrid Turret"),
                                     "cpu", ship.getModifiedItemAttr("bcLargeTurretCPU"))

########NEW FILE########
__FILENAME__ = bclargehybridturretpowerneedbonus
# Used by:
# Ship: Naga
# Ship: Talos
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.requiresSkill("Large Hybrid Turret"),
                                     "power", ship.getModifiedItemAttr("bcLargeTurretPower"))

########NEW FILE########
__FILENAME__ = bclargeprojectileturretcpuneedbonus
# Used by:
# Ship: Tornado
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.requiresSkill("Large Projectile Turret"),
                                     "cpu", ship.getModifiedItemAttr("bcLargeTurretCPU"))

########NEW FILE########
__FILENAME__ = bclargeprojectileturretpowerneedbonus
# Used by:
# Ship: Tornado
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.requiresSkill("Large Projectile Turret"),
                                     "power", ship.getModifiedItemAttr("bcLargeTurretPower"))

########NEW FILE########
__FILENAME__ = biologytimebonusfixed
# Used by:
# Implants named like: Eifyr and Co. 'Alchemist' Biology BY (2 of 2)
# Skill: Biology
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.boosters.filteredItemBoost(lambda bst: True, "boosterDuration", container.getModifiedItemAttr("durationBonus") * level)

########NEW FILE########
__FILENAME__ = blockaderunnercloakcpupercentbonus
# Used by:
# Ships from group: Blockade Runner (4 of 4)
type = "passive"
runTime = "early"
def handler(fit, ship, context):
    level = fit.character.getSkill("Transport Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Cloaking Device",
                                  "cpu", ship.getModifiedItemAttr("eliteIndustrialCovertCloakBonus") * level)

########NEW FILE########
__FILENAME__ = boosterarmorhppenalty
# Used by:
# Implants from group: Booster (12 of 37)
type = "boosterSideEffect"
def handler(fit, booster, context):
    fit.ship.boostItemAttr("armorHP", booster.getModifiedItemAttr("boosterArmorHPPenalty"))

########NEW FILE########
__FILENAME__ = boosterarmorrepairamountpenalty
# Used by:
# Implants from group: Booster (9 of 37)
type = "boosterSideEffect"
def handler(fit, booster, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Armor Repair Unit",
                                  "armorDamageAmount", booster.getModifiedItemAttr("boosterArmorRepairAmountPenalty"))

########NEW FILE########
__FILENAME__ = boostercapacitorcapacitypenalty
# Used by:
# Implants named like: Blue Pill Booster (3 of 5)
# Implants named like: Exile Booster (3 of 4)
type = "boosterSideEffect"
def handler(fit, booster, context):
    fit.ship.boostItemAttr("capacitorCapacity", booster.getModifiedItemAttr("boosterCapacitorCapacityPenalty"))

########NEW FILE########
__FILENAME__ = boostermaxvelocitypenalty
# Used by:
# Implants from group: Booster (12 of 37)
type = "boosterSideEffect"
def handler(fit, booster, context):
    fit.ship.boostItemAttr("maxVelocity", booster.getModifiedItemAttr("boosterMaxVelocityPenalty"))

########NEW FILE########
__FILENAME__ = boostermissileexplosioncloudpenaltyfixed
# Used by:
# Implants named like: Exile Booster (3 of 4)
# Implants named like: Mindflood Booster (3 of 4)
type = "boosterSideEffect"
def handler(fit, booster, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Missile Launcher Operation"),
                                    "aoeCloudSize", booster.getModifiedItemAttr("boosterMissileAOECloudPenalty"))

########NEW FILE########
__FILENAME__ = boostermissileexplosionvelocitypenalty
# Used by:
# Implants named like: Blue Pill Booster (3 of 5)
type = "boosterSideEffect"
def handler(fit, booster, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Missile Launcher Operation"),
                                    "aoeVelocity", booster.getModifiedItemAttr("boosterAOEVelocityPenalty"))

########NEW FILE########
__FILENAME__ = boostermissilevelocitypenalty
# Used by:
# Implants named like: Crash Booster (3 of 4)
# Implants named like: X Instinct Booster (3 of 4)
type = "boosterSideEffect"
def handler(fit, booster, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Missile Launcher Operation"),
                                    "maxVelocity", "boosterMissileVelocityPenalty")

########NEW FILE########
__FILENAME__ = boostermodifyboosterarmorpenalties
# Used by:
# Implants named like: Eifyr and Co. 'Alchemist' Nanite Control NC (2 of 2)
# Implants named like: Low grade Edge (5 of 6)
# Skill: Neurotoxin Control
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    attrs = ("boosterArmorHPPenalty", "boosterArmorRepairAmountPenalty")
    for attr in attrs:
        fit.boosters.filteredItemBoost(lambda booster: True, attr,
                                       container.getModifiedItemAttr("boosterAttributeModifier") * level)

########NEW FILE########
__FILENAME__ = boostermodifyboostermaxvelocityandcapacitorpenalty
# Used by:
# Implants named like: Eifyr and Co. 'Alchemist' Nanite Control NC (2 of 2)
# Implants named like: Low grade Edge (5 of 6)
# Skill: Neurotoxin Control
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    attrs = ("boosterCapacitorCapacityPenalty", "boosterMaxVelocityPenalty")
    for attr in attrs:
        fit.boosters.filteredItemBoost(lambda booster: True, attr,
                                       container.getModifiedItemAttr("boosterAttributeModifier") * level)

########NEW FILE########
__FILENAME__ = boostermodifyboostermissilepenalty
# Used by:
# Implants named like: Eifyr and Co. 'Alchemist' Nanite Control NC (2 of 2)
# Implants named like: Low grade Edge (5 of 6)
# Skill: Neurotoxin Control
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    attrs = ("boosterAOEVelocityPenalty", "boosterMissileAOECloudPenalty", "boosterMissileVelocityPenalty")
    for attr in attrs:
        fit.boosters.filteredItemBoost(lambda booster: True, attr,
                                       container.getModifiedItemAttr("boosterAttributeModifier") * level)

########NEW FILE########
__FILENAME__ = boostermodifyboostershieldpenalty
# Used by:
# Implants named like: Eifyr and Co. 'Alchemist' Nanite Control NC (2 of 2)
# Implants named like: Low grade Edge (5 of 6)
# Skill: Neurotoxin Control
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    attrs = ("boosterShieldBoostAmountPenalty", "boosterShieldCapacityPenalty", "shieldBoostMultiplier")
    for attr in attrs:
        # shieldBoostMultiplier can be positive (Blue Pill) and negative value (other boosters)
        # We're interested in decreasing only side-effects
        fit.boosters.filteredItemBoost(lambda booster: booster.getModifiedItemAttr(attr) < 0,
                                       attr, container.getModifiedItemAttr("boosterAttributeModifier") * level)

########NEW FILE########
__FILENAME__ = boostermodifyboosterturretpenalty
# Used by:
# Implants named like: Eifyr and Co. 'Alchemist' Nanite Control NC (2 of 2)
# Implants named like: Low grade Edge (5 of 6)
# Skill: Neurotoxin Control
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    attrs = ("boosterTurretFalloffPenalty", "boosterTurretOptimalRange", "boosterTurretTrackingPenalty")
    for attr in attrs:
        fit.boosters.filteredItemBoost(lambda booster: True, attr,
                                       container.getModifiedItemAttr("boosterAttributeModifier") * level)

########NEW FILE########
__FILENAME__ = boostershieldcapacitypenalty
# Used by:
# Implants from group: Booster (12 of 37)
type = "boosterSideEffect"
def handler(fit, booster, context):
    fit.ship.boostItemAttr("shieldCapacity", booster.getModifiedItemAttr("boosterShieldCapacityPenalty"))

########NEW FILE########
__FILENAME__ = boosterturretfalloffpenalty
# Used by:
# Implants named like: Drop Booster (3 of 4)
# Implants named like: X Instinct Booster (3 of 4)
type = "boosterSideEffect"
def handler(fit, booster, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Gunnery"),
                                  "falloff", booster.getModifiedItemAttr("boosterTurretFalloffPenalty"))

########NEW FILE########
__FILENAME__ = boosterturretoptimalrangepenalty
# Used by:
# Implants from group: Booster (9 of 37)
type = "boosterSideEffect"
def handler(fit, booster, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Gunnery"),
                                  "maxRange", booster.getModifiedItemAttr("boosterTurretOptimalRange"))

########NEW FILE########
__FILENAME__ = boosterturrettrackingpenalty
# Used by:
# Implants named like: Exile Booster (3 of 4)
# Implants named like: Frentix Booster (3 of 4)
type = "boosterSideEffect"
def handler(fit, booster, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Gunnery"),
                                  "trackingSpeed", booster.getModifiedItemAttr("boosterTurretTrackingPenalty"))

########NEW FILE########
__FILENAME__ = caldarisetbonus3
# Used by:
# Implants named like: Talon (6 of 12)
runTime = "early"
type = "passive"
def handler(fit, implant, context):
    fit.implants.filteredItemMultiply(lambda target: target.item.requiresSkill("Cybernetics"),
                                      "scanGravimetricStrengthPercent", implant.getModifiedItemAttr("implantSetCaldariNavy"))

########NEW FILE########
__FILENAME__ = caldarisetlgbonus
# Used by:
# Implants named like: Low grade Talon (6 of 6)
runTime = "early"
type = "passive"
def handler(fit, implant, context):
    fit.implants.filteredItemMultiply(lambda target: target.item.requiresSkill("Cybernetics"),
                                      "scanGravimetricStrengthModifier", implant.getModifiedItemAttr("implantSetLGCaldariNavy"))

########NEW FILE########
__FILENAME__ = caldarishipecmburstoptimalrangecb3
# Used by:
# Ship: Scorpion
# Ship: Scorpion Ishukone Watch
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Battleship").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "ECM Burst",
                                  "ecmBurstRange", ship.getModifiedItemAttr("shipBonusCB3") * level)
########NEW FILE########
__FILENAME__ = caldarishipewcapacitorneedcc
# Used by:
# Ship: Falcon
# Ship: Rook
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "ECM",
                                  "capacitorNeed", ship.getModifiedItemAttr("shipBonusCC") * level)

########NEW FILE########
__FILENAME__ = caldarishipewcapacitorneedcf2
# Used by:
# Variations of ship: Griffin (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "ECM",
                                  "capacitorNeed", ship.getModifiedItemAttr("shipBonusCF2") * level)

########NEW FILE########
__FILENAME__ = caldarishipewfalloffrangecb3
# Used by:
# Ship: Scorpion
# Ship: Scorpion Ishukone Watch
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Battleship").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "ECM",
                                  "falloff", ship.getModifiedItemAttr("shipBonusCB3") * level)
########NEW FILE########
__FILENAME__ = caldarishipewfalloffrangecc2
# Used by:
# Ship: Blackbird
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "ECM",
                                  "falloff", ship.getModifiedItemAttr("shipBonusCC2") * level)

########NEW FILE########
__FILENAME__ = caldarishipewoptimalrangecb3
# Used by:
# Ship: Scorpion
# Ship: Scorpion Ishukone Watch
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Battleship").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "ECM",
                                  "maxRange", ship.getModifiedItemAttr("shipBonusCB3") * level)
########NEW FILE########
__FILENAME__ = caldarishipewoptimalrangecc2
# Used by:
# Ship: Blackbird
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "ECM",
                                  "maxRange", ship.getModifiedItemAttr("shipBonusCC2") * level)

########NEW FILE########
__FILENAME__ = caldarishipewstrengthcb
# Used by:
# Ship: Scorpion
# Ship: Scorpion Ishukone Watch
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Battleship").level
    for sensorType in ("Gravimetric", "Ladar", "Magnetometric", "Radar"):
        fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "ECM",
                                      "scan{0}StrengthBonus".format(sensorType),
                                      ship.getModifiedItemAttr("shipBonusCB") * level)

########NEW FILE########
__FILENAME__ = capacitorcapacityaddpassive
# Used by:
# Subsystems from group: Engineering Systems (16 of 16)
# Subsystem: Tengu Offensive - Magnetic Infusion Basin
type = "passive"
def handler(fit, module, context):
    fit.ship.increaseItemAttr("capacitorCapacity",
                              module.getModifiedItemAttr("capacitorCapacity"))

########NEW FILE########
__FILENAME__ = capacitorcapacitybonus
# Used by:
# Modules from group: Capacitor Battery (27 of 27)
type = "passive"
def handler(fit, ship, context):
    fit.ship.increaseItemAttr("capacitorCapacity", ship.getModifiedItemAttr("capacitorBonus"))
########NEW FILE########
__FILENAME__ = capacitorcapacitymultiply
# Used by:
# Modules from group: Capacitor Flux Coil (12 of 12)
# Modules from group: Capacitor Power Relay (26 of 26)
# Modules from group: Power Diagnostic System (31 of 31)
# Modules from group: Propulsion Module (107 of 107)
# Modules from group: Reactor Control Unit (28 of 28)
# Modules from group: Shield Flux Coil (11 of 11)
# Modules from group: Shield Power Relay (11 of 11)
type = "passive"
def handler(fit, module, context):
    fit.ship.multiplyItemAttr("capacitorCapacity", module.getModifiedItemAttr("capacitorCapacityMultiplier"))

########NEW FILE########
__FILENAME__ = capacitoremissionsystemskill
# Used by:
# Implants named like: Inherent Implants 'Squire' Energy Emission Systems ES (6 of 6)
# Modules named like: Egress Port Maximizer (8 of 8)
# Skill: Capacitor Emission Systems
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capacitor Emission Systems"),
                                  "capacitorNeed", container.getModifiedItemAttr("capNeedBonus") * level)

########NEW FILE########
__FILENAME__ = capacityaddpassive
# Used by:
# Subsystems from group: Defensive Systems (16 of 16)
type = "passive"
def handler(fit, subsystem, context):
    fit.ship.increaseItemAttr("capacity", subsystem.getModifiedItemAttr("capacity") or 0)

########NEW FILE########
__FILENAME__ = capitallauncherskillcitadelemdamage
# Used by:
# Implants named like: Hardwiring Zainou 'Sharpshooter' ZMX (6 of 6)
# Skill: Citadel Torpedoes
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Citadel Torpedoes"),
                                    "emDamage", container.getModifiedItemAttr("damageMultiplierBonus") * level)

########NEW FILE########
__FILENAME__ = capitallauncherskillcitadelexplosivedamage
# Used by:
# Implants named like: Hardwiring Zainou 'Sharpshooter' ZMX (6 of 6)
# Skill: Citadel Torpedoes
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Citadel Torpedoes"),
                                    "explosiveDamage", container.getModifiedItemAttr("damageMultiplierBonus") * level)

########NEW FILE########
__FILENAME__ = capitallauncherskillcitadelkineticdamage
# Used by:
# Implants named like: Hardwiring Zainou 'Sharpshooter' ZMX (6 of 6)
# Skill: Citadel Torpedoes
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Citadel Torpedoes"),
                                    "kineticDamage", container.getModifiedItemAttr("damageMultiplierBonus") * level)

########NEW FILE########
__FILENAME__ = capitallauncherskillcitadelthermaldamage
# Used by:
# Implants named like: Hardwiring Zainou 'Sharpshooter' ZMX (6 of 6)
# Skill: Citadel Torpedoes
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Citadel Torpedoes"),
                                    "thermalDamage", container.getModifiedItemAttr("damageMultiplierBonus") * level)

########NEW FILE########
__FILENAME__ = capitallauncherskillcruisecitadelemdamage1
# Used by:
# Skill: Citadel Cruise Missiles
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Citadel Cruise Missiles"),
                                    "emDamage", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)

########NEW FILE########
__FILENAME__ = capitallauncherskillcruisecitadelexplosivedamage1
# Used by:
# Skill: Citadel Cruise Missiles
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Citadel Cruise Missiles"),
                                    "explosiveDamage", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)

########NEW FILE########
__FILENAME__ = capitallauncherskillcruisecitadelkineticdamage1
# Used by:
# Skill: Citadel Cruise Missiles
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Citadel Cruise Missiles"),
                                    "kineticDamage", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)

########NEW FILE########
__FILENAME__ = capitallauncherskillcruisecitadelthermaldamage1
# Used by:
# Skill: Citadel Cruise Missiles
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Citadel Cruise Missiles"),
                                    "thermalDamage", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)

########NEW FILE########
__FILENAME__ = capitalremotearmorrepairercapneedbonusskill
# Used by:
# Variations of module: Capital Remote Repair Augmentor I (2 of 2)
# Skill: Capital Remote Armor Repair Systems
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Remote Armor Repair Systems"),
                                  "capacitorNeed", container.getModifiedItemAttr("capNeedBonus") * level)

########NEW FILE########
__FILENAME__ = capitalremoteenergytransfercapneedbonusskill
# Used by:
# Skill: Capital Capacitor Emission Systems
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Capacitor Emission Systems"),
                                  "capacitorNeed", skill.getModifiedItemAttr("capNeedBonus") * skill.level)
########NEW FILE########
__FILENAME__ = capitalremoteshieldtransfercapneedbonusskill
# Used by:
# Skill: Capital Shield Emission Systems
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Shield Emission Systems"),
                                  "capacitorNeed", container.getModifiedItemAttr("capNeedBonus") * level)

########NEW FILE########
__FILENAME__ = capitalrepairsystemsskilldurationbonus
# Used by:
# Modules named like: Nanobot Accelerator (8 of 8)
# Skill: Capital Repair Systems
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Repair Systems"),
                                  "duration", container.getModifiedItemAttr("durationSkillBonus") * level,
                                  stackingPenalties = "skill" not in context)

########NEW FILE########
__FILENAME__ = capitalshieldoperationskillcapacitorneedbonus
# Used by:
# Modules named like: Core Defense Capacitor Safeguard (8 of 8)
# Skill: Capital Shield Operation
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Shield Operation"),
                                  "capacitorNeed", container.getModifiedItemAttr("shieldBoostCapacitorBonus") * level)

########NEW FILE########
__FILENAME__ = capitalturretskillhybriddamage
# Used by:
# Skill: Capital Hybrid Turret
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Hybrid Turret"),
                                  "damageMultiplier", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)
########NEW FILE########
__FILENAME__ = capitalturretskilllaserdamage
# Used by:
# Skill: Capital Energy Turret
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Energy Turret"),
                                  "damageMultiplier", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)
########NEW FILE########
__FILENAME__ = capitalturretskillprojectiledamage
# Used by:
# Skill: Capital Projectile Turret
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Projectile Turret"),
                                  "damageMultiplier", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)
########NEW FILE########
__FILENAME__ = capneedbonuseffecthybrids
# Used by:
# Modules named like: Hybrid Discharge Elutriation (8 of 8)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Hybrid Weapon",
                                  "capacitorNeed", module.getModifiedItemAttr("capNeedBonus"))
########NEW FILE########
__FILENAME__ = capneedbonuseffectlasers
# Used by:
# Modules named like: Energy Discharge Elutriation (8 of 8)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Energy Weapon",
                                  "capacitorNeed", module.getModifiedItemAttr("capNeedBonus"))

########NEW FILE########
__FILENAME__ = cargocapacitymultiply
# Used by:
# Modules from group: Expanded Cargohold (13 of 13)
# Modules from group: Overdrive Injector System (14 of 14)
type = "passive"
def handler(fit, module, context):
    fit.ship.multiplyItemAttr("capacity", module.getModifiedItemAttr("cargoCapacityMultiplier"))

########NEW FILE########
__FILENAME__ = carrieramarrarmorenergytransferrange3
# Used by:
# Ship: Aeon
# Ship: Archon
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Carrier").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Remote Armor Repair Systems"),
                                  "maxRange", ship.getModifiedItemAttr("carrierAmarrBonus3") * level)
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Capacitor Emission Systems"),
                                  "powerTransferRange", ship.getModifiedItemAttr("carrierAmarrBonus3") * level)
    
########NEW FILE########
__FILENAME__ = carrieramarrarmorresist2
# Used by:
# Ship: Aeon
# Ship: Archon
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Carrier").level
    for resType in ("Em", "Explosive", "Kinetic", "Thermal"):
        fit.ship.boostItemAttr("armor{0}DamageResonance".format(resType),
                               ship.getModifiedItemAttr("carrierAmarrBonus2") * level)

########NEW FILE########
__FILENAME__ = carrieramarrdronemax1
# Used by:
# Ship: Aeon
# Ship: Archon
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Carrier").level
    amount = ship.getModifiedItemAttr("carrierAmarrBonus1")
    fit.extraAttributes.increase("maxActiveDrones", amount * level)

########NEW FILE########
__FILENAME__ = carrieramarrfighterbombermaxvelocity2
# Used by:
# Ship: Revenant
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Carrier").level
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Fighter Bombers"),
                                 "maxVelocity", ship.getModifiedItemAttr("carrierAmarrBonus2") * level)

########NEW FILE########
__FILENAME__ = carrieramarrfightermaxvelocity2
# Used by:
# Ship: Revenant
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Carrier").level
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Fighters"),
                                 "maxVelocity", ship.getModifiedItemAttr("carrierAmarrBonus2") * level)

########NEW FILE########
__FILENAME__ = carrieramarrleadershipmaxgroupactive4
# Used by:
# Ship: Aeon
# Ship: Revenant
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Carrier").level
    fit.modules.filteredItemIncrease(lambda mod: mod.item.group.name == "Gang Coordinator",
                                     "maxGroupActive", ship.getModifiedItemAttr("carrierAmarrBonus4") * level)

########NEW FILE########
__FILENAME__ = carriercaldaridronemax1
# Used by:
# Ship: Chimera
# Ship: Revenant
# Ship: Wyvern
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Carrier").level
    amount = ship.getModifiedItemAttr("carrierCaldariBonus1")
    fit.extraAttributes.increase("maxActiveDrones", amount * level)

########NEW FILE########
__FILENAME__ = carriercaldarileadershipmaxgroupactive4
# Used by:
# Ship: Wyvern
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Carrier").level
    fit.modules.filteredItemIncrease(lambda mod: mod.item.group.name == "Gang Coordinator",
                                     "maxGroupActive", ship.getModifiedItemAttr("carrierCaldariBonus4") * level)

########NEW FILE########
__FILENAME__ = carriercaldarishieldenergytransferrange3
# Used by:
# Ship: Chimera
# Ship: Revenant
# Ship: Wyvern
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Carrier").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Shield Emission Systems"),
                                  "shieldTransferRange", ship.getModifiedItemAttr("carrierCaldariBonus3") * level)
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Capacitor Emission Systems"),
                                  "powerTransferRange", ship.getModifiedItemAttr("carrierCaldariBonus3") * level)

########NEW FILE########
__FILENAME__ = carriercaldarishieldresist2
# Used by:
# Ship: Chimera
# Ship: Wyvern
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Carrier").level
    for resType in ("Em", "Explosive", "Kinetic", "Thermal"):
        fit.ship.boostItemAttr("shield{0}DamageResonance".format(resType),
                               ship.getModifiedItemAttr("carrierCaldariBonus2") * level)

########NEW FILE########
__FILENAME__ = carrierfightercontrolrangebonus
# Used by:
# Ships from group: Carrier (4 of 4)
# Ships from group: Supercarrier (5 of 5)
type = "passive"
def handler(fit, ship, context):
    # The fighter control range bonus only affects fighters.
    # Until we can calculate and display control range on a per-drone level,
    # we will have to leave this effect as a dummy.
    pass
    # fit.extraAttributes.multiply("droneControlRange", ship.getModifiedItemAttr("droneRangeBonus"))

########NEW FILE########
__FILENAME__ = carriergallentearmorshieldtransferrange3
# Used by:
# Ship: Nyx
# Ship: Thanatos
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Carrier").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Shield Emission Systems"),
                                  "shieldTransferRange", ship.getModifiedItemAttr("carrierGallenteBonus3") * level)
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Remote Armor Repair Systems"),
                                  "maxRange", ship.getModifiedItemAttr("carrierGallenteBonus3") * level)

########NEW FILE########
__FILENAME__ = carriergallentebomberdroneowndmg2
# Used by:
# Ship: Nyx
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Carrier").level
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Fighter Bombers"),
                                 "damageMultiplier", ship.getModifiedItemAttr("carrierGallenteBonus2") * level)

########NEW FILE########
__FILENAME__ = carriergallentedronemax1
# Used by:
# Ship: Nyx
# Ship: Thanatos
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Carrier").level
    amount = ship.getModifiedItemAttr("carrierGallenteBonus1")
    fit.extraAttributes.increase("maxActiveDrones", amount * level)

########NEW FILE########
__FILENAME__ = carriergallentedroneowndmg2
# Used by:
# Ship: Nyx
# Ship: Thanatos
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Carrier").level
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Fighters"),
                                 "damageMultiplier", ship.getModifiedItemAttr("carrierGallenteBonus2") * level)

########NEW FILE########
__FILENAME__ = carriergallenteleadershipmaxgroupactive4
# Used by:
# Ship: Nyx
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Carrier").level
    fit.modules.filteredItemIncrease(lambda mod: mod.item.group.name == "Gang Coordinator",
                                     "maxGroupActive", ship.getModifiedItemAttr("carrierGallenteBonus4") * level)

########NEW FILE########
__FILENAME__ = carrierminmatararmorshieldamount
# Used by:
# Ship: Hel
# Ship: Nidhoggur
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Carrier").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Shield Booster",
                                  "shieldBonus", ship.getModifiedItemAttr("carrierMinmatarBonus2") * level)
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Armor Repairer",
                                  "armorDamageAmount", ship.getModifiedItemAttr("carrierMinmatarBonus2") * level)

########NEW FILE########
__FILENAME__ = carrierminmatararmorshieldtransferrange3
# Used by:
# Ship: Hel
# Ship: Nidhoggur
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Carrier").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Shield Emission Systems"),
                                  "shieldTransferRange", ship.getModifiedItemAttr("carrierMinmatarBonus3") * level)
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Remote Armor Repair Systems"),
                                  "maxRange", ship.getModifiedItemAttr("carrierMinmatarBonus3") * level)

########NEW FILE########
__FILENAME__ = carrierminmatardronemax1
# Used by:
# Ship: Hel
# Ship: Nidhoggur
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Carrier").level
    amount = ship.getModifiedItemAttr("carrierMinmatarBonus1")
    fit.extraAttributes.increase("maxActiveDrones", amount * level)

########NEW FILE########
__FILENAME__ = carrierminmatarleadershipmaxgroupactive4
# Used by:
# Ship: Hel
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Carrier").level
    fit.modules.filteredItemIncrease(lambda mod: mod.item.group.name == "Gang Coordinator",
                                     "maxGroupActive", ship.getModifiedItemAttr("carrierMinmatarBonus4") * level)

########NEW FILE########
__FILENAME__ = cloaking
# Used by:
# Modules from group: Cloaking Device (12 of 14)
type = "active"
runTime = "early"
#TODO: Rewrite this effect
def handler(fit, module, context):
    # Set flag which is used to determine if ship is cloaked or not
    # This is used to apply cloak-only bonuses, like Black Ops' speed bonus
    # Doesn't apply to covops cloaks
    fit.extraAttributes["cloaked"] = True
    # Apply speed penalty
    fit.ship.multiplyItemAttr("maxVelocity", module.getModifiedItemAttr("maxVelocityBonus"))

########NEW FILE########
__FILENAME__ = cloakingscanresolutionmultiplier
# Used by:
# Modules from group: Cloaking Device (12 of 14)
type = "offline"
def handler(fit, module, context):
    fit.ship.multiplyItemAttr("scanResolution",
                              module.getModifiedItemAttr("scanResolutionMultiplier"),
                              stackingPenalties = True, penaltyGroup="cloakingScanResolutionMultiplier")

########NEW FILE########
__FILENAME__ = cloakingtargetingdelaybonuslrsmcloakingpassive
# Used by:
# Modules named like: Targeting Systems Stabilizer (8 of 8)
type = "offline"
def handler(fit, module, context):
    fit.modules.filteredItemBoost(lambda module: module.item.requiresSkill("Cloaking"),
                                  "cloakingTargetingDelay", module.getModifiedItemAttr("cloakingTargetingDelayBonus"))

########NEW FILE########
__FILENAME__ = cloakingtargetingdelaybonuspostpercentcloakingtargetingdelaybonusforshipmodulesrequiringcloaking
# Used by:
# Skill: Cloaking
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Cloaking"),
                                  "cloakingTargetingDelay",
                                  skill.getModifiedItemAttr("cloakingTargetingDelayBonus") * skill.level)
########NEW FILE########
__FILENAME__ = cloakingwarpsafe
# Used by:
# Modules named like: Covert Ops Cloaking Device II (2 of 2)
type = "active"
runTime = "early"
def handler(fit, ship, context):
    fit.extraAttributes["cloaked"] = True
    #TODO: Implement
########NEW FILE########
__FILENAME__ = clonevatmaxjumpclonebonusskillnew
# Used by:
# Skill: Cloning Facility Operation
type = "passive"
def handler(fit, skill, context):
    fit.ship.boostItemAttr("maxJumpClones", skill.getModifiedItemAttr("maxJumpClonesBonus") * skill.level)

########NEW FILE########
__FILENAME__ = commandbonusecmmultiplywithcommandbonushidden
# Used by:
# Variations of module: Information Warfare Link - Electronic Superiority I (2 of 2)
gangBonus = "commandBonusECM"
gangBoost = "ewarStrECM"
type = "active", "gang"
def handler(fit, module, context):
    if "gang" not in context: return
    for scanType in ("Magnetometric", "Radar", "Ladar", "Gravimetric"):
        fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "ECM",
                                      "scan%sStrengthBonus" % scanType,
                                      module.getModifiedItemAttr("commandBonusECM"),
                                      stackingPenalties = True)

########NEW FILE########
__FILENAME__ = commandbonusrsdmultiplywithcommandbonushidden
# Used by:
# Variations of module: Information Warfare Link - Electronic Superiority I (2 of 2)
gangBonus = "commandBonusRSD"
gangBoost = "ewarStrRSD"
type = "active", "gang"
def handler(fit, module, context):
    if "gang" not in context: return
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Sensor Damper",
                                  "maxTargetRangeBonus", module.getModifiedItemAttr("commandBonusRSD"))
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Sensor Damper",
                                  "scanResolutionBonus", module.getModifiedItemAttr("commandBonusRSD"),
                                  stackingPenalties=True)

########NEW FILE########
__FILENAME__ = commandbonustdmultiplywithcommandbonushidden
# Used by:
# Variations of module: Information Warfare Link - Electronic Superiority I (2 of 2)
gangBonus = "commandBonusTD"
gangBoost = "ewarStrTD"
type = "active", "gang"
def handler(fit, module, context):
    for bonus in ("maxRangeBonus", "falloffBonus", "trackingSpeedBonus"):
        fit.modules.filteredItemBoost(lambda mod: lambda mod: mod.item.requiresSkill("Weapon Disruption"),
                                      bonus, module.getModifiedItemAttr("commandBonusTD"))

########NEW FILE########
__FILENAME__ = commandbonustpmultiplywithcommandbonushidden
# Used by:
# Variations of module: Information Warfare Link - Electronic Superiority I (2 of 2)
gangBonus = "commandBonusTP"
gangBoost = "ewarStrTP"
type = "active", "gang"
def handler(fit, module, context):
    if "gang" not in context: return
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Target Painter",
                                  "signatureRadiusBonus", module.getModifiedItemAttr("commandBonusTP"),
                                  stackingPenalties = True)

########NEW FILE########
__FILENAME__ = commandshipmultirelayeffect
# Used by:
# Ships from group: Command Ship (8 of 8)
# Ship: Orca
# Ship: Rorqual
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemIncrease(lambda mod: mod.item.group.name == "Gang Coordinator",
                                     "maxGroupActive", ship.getModifiedItemAttr("maxGangModules"))

########NEW FILE########
__FILENAME__ = controlledburstscapneedbonuspostpercentcapacitorneedlocationshipmodulesrequiringgunnery
# Used by:
# Implants named like: Inherent Implants 'Lancer' Controlled Bursts CB (6 of 6)
# Skill: Controlled Bursts
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Gunnery"),
                                  "capacitorNeed", container.getModifiedItemAttr("capNeedBonus") * level)

########NEW FILE########
__FILENAME__ = covertcloakcpuaddition
# Used by:
# Modules named like: Covert Ops Cloaking Device II (2 of 2)
# Module: Covert Cynosural Field Generator I
type = "passive"
def handler(fit, module, context):
    module.increaseItemAttr("cpu", module.getModifiedItemAttr("covertCloakCPUAdd") or 0)

########NEW FILE########
__FILENAME__ = covertcynocpupenalty
# Used by:
# Subsystems from group: Offensive Systems (12 of 16)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemIncrease(lambda mod: mod.item.requiresSkill("Cynosural Field Theory"),
                                     "covertCloakCPUAdd", module.getModifiedItemAttr("covertCloakCPUPenalty"))


########NEW FILE########
__FILENAME__ = covertopsandreconopscloakmoduledelaybonus
# Used by:
# Ships from group: Black Ops (4 of 4)
# Ships from group: Blockade Runner (4 of 4)
# Ships from group: Covert Ops (5 of 5)
# Ships from group: Force Recon Ship (5 of 5)
# Ships from group: Stealth Bomber (4 of 4)
# Ships named like: Stratios (2 of 2)
# Subsystems named like: Offensive Covert Reconfiguration (4 of 4)
# Ship: Astero
type = "passive"
def handler(fit, container, context):
    fit.modules.filteredItemForce(lambda mod: mod.item.group.name == "Cloaking Device",
                                  "moduleReactivationDelay", container.getModifiedItemAttr("covertOpsAndReconOpsCloakModuleDelay"))

########NEW FILE########
__FILENAME__ = covertopscloakcpupenalty
# Used by:
# Subsystems from group: Offensive Systems (12 of 16)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemIncrease(lambda mod: mod.item.requiresSkill("Cloaking"),
                                     "covertCloakCPUAdd", module.getModifiedItemAttr("covertCloakCPUPenalty"))


########NEW FILE########
__FILENAME__ = covertopscloakcpupercentbonus1
# Used by:
# Ships from group: Covert Ops (5 of 5)
type = "passive"
runTime = "early"
def handler(fit, ship, context):
    level = fit.character.getSkill("Covert Ops").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Cloaking Device",
                                  "cpu", ship.getModifiedItemAttr("eliteBonusCoverOps1") * level)

########NEW FILE########
__FILENAME__ = covertopscloakcpupercentbonuspiratefaction
# Used by:
# Ship: Astero
type = "passive"
runTime = "early"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Cloaking"),
                                  "cpu", ship.getModifiedItemAttr("shipBonusPirateFaction"))

########NEW FILE########
__FILENAME__ = covertopscpubonus1
# Used by:
# Ships from group: Stealth Bomber (4 of 4)
# Subsystems named like: Offensive Covert Reconfiguration (4 of 4)
type = "passive"
def handler(fit, container, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.group.name == "Cloaking Device",
                                     "cpu", container.getModifiedItemAttr("cloakingCpuNeedBonus"))

########NEW FILE########
__FILENAME__ = covertopsstealthbombersiegemissilelauncerpowerneedbonus
# Used by:
# Ships from group: Stealth Bomber (4 of 4)
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.group.name == "Missile Launcher Torpedo",
                                     "power", ship.getModifiedItemAttr("stealthBomberLauncherPower"))

########NEW FILE########
__FILENAME__ = covertopsstealthbombertargettingdelaybonus
# Used by:
# Ships from group: Black Ops (4 of 4)
# Ships from group: Stealth Bomber (4 of 4)
# Ship: Chremoas
# Ship: Etana
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemForce(lambda mod: mod.item.group.name == "Cloaking Device",
                                  "cloakingTargetingDelay", ship.getModifiedItemAttr("covertOpsStealthBomberTargettingDelay"))

########NEW FILE########
__FILENAME__ = covertwarfaremindlink
# Used by:
# Implant: Caldari Navy Warfare Mindlink
# Implant: Imperial Navy Warfare Mindlink
# Implant: Information Warfare Mindlink
type = "passive"
def handler(fit, implant, context):
    fit.character.getSkill("Information Warfare").suppress()
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Information Warfare Specialist"),
                                  "commandBonus", implant.getModifiedItemAttr("mindlinkBonus"))

########NEW FILE########
__FILENAME__ = cpumultiplierpostmulcpuoutputship
# Used by:
# Modules from group: CPU Enhancer (27 of 27)
type = "passive"
def handler(fit, module, context):
    fit.ship.multiplyItemAttr("cpuOutput", module.getModifiedItemAttr("cpuMultiplier"))
########NEW FILE########
__FILENAME__ = cpuneedbonuseffecthybrid
# Used by:
# Modules named like: Algid Hybrid Administrations Unit (8 of 8)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Hybrid Weapon",
                                  "cpu", module.getModifiedItemAttr("cpuNeedBonus"))
########NEW FILE########
__FILENAME__ = cpuneedbonuseffectlasers
# Used by:
# Modules named like: Algid Energy Administrations Unit (8 of 8)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Energy Weapon",
                                  "cpu", module.getModifiedItemAttr("cpuNeedBonus"))
########NEW FILE########
__FILENAME__ = cpuoutputaddcpuoutputpassive
# Used by:
# Items from category: Subsystem (40 of 80)
type = "passive"
def handler(fit, module, context):
    fit.ship.increaseItemAttr("cpuOutput", module.getModifiedItemAttr("cpuOutput"))

########NEW FILE########
__FILENAME__ = cynosuraldurationbonus
# Used by:
# Ships from group: Force Recon Ship (4 of 5)
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Cynosural Field",
                                  "duration", ship.getModifiedItemAttr("durationBonus"))

########NEW FILE########
__FILENAME__ = cynosuralgeneration
# Used by:
# Modules from group: Cynosural Field (2 of 2)
type = "active"
def handler(fit, module, context):
    fit.ship.boostItemAttr("maxVelocity", module.getModifiedItemAttr("speedFactor"))

########NEW FILE########
__FILENAME__ = cynosuraltheoryconsumptionbonus
# Used by:
# Ships from group: Force Recon Ship (4 of 5)
# Skill: Cynosural Field Theory
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Cynosural Field",
                                  "consumptionQuantity", container.getModifiedItemAttr("consumptionQuantityBonusPercentage") * level)

########NEW FILE########
__FILENAME__ = damagecontrol
# Used by:
# Modules from group: Damage Control (14 of 14)
type = "active"
def handler(fit, module, context):
    for layer, attrPrefix in (('shield', 'shield'), ('armor', 'armor'), ('hull', '')):
        for damageType in ('Kinetic', 'Thermal', 'Explosive', 'Em'):
            bonus = "%s%sDamageResonance" % (attrPrefix, damageType)
            bonus = "%s%s" % (bonus[0].lower(), bonus[1:])
            booster = "%s%sDamageResonance" % (layer, damageType)
            penalize = False if layer == 'hull' else True
            fit.ship.multiplyItemAttr(bonus, module.getModifiedItemAttr(booster),
                                      stackingPenalties=penalize, penaltyGroup="preMul")

########NEW FILE########
__FILENAME__ = dataminermoduledurationreduction
# Used by:
# Implant: Poteque 'Prospector' Environmental Analysis EY-1005
type = "passive"
def handler(fit, implant, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Data Miners",
                                  "duration", implant.getModifiedItemAttr("durationBonus"))
########NEW FILE########
__FILENAME__ = dataminingskillboostaccessdifficultybonusabsolutepercent
# Used by:
# Skill: Archaeology
# Skill: Hacking
# Skill: Salvaging
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.requiresSkill(skill), "accessDifficultyBonus",
                                     skill.getModifiedItemAttr("accessDifficultyBonusAbsolutePercent") * skill.level)

########NEW FILE########
__FILENAME__ = decreasetargetspeed
# Used by:
# Drones from group: Stasis Webifying Drone (3 of 3)
# Modules from group: Stasis Web (19 of 19)
type = "active", "projected"
def handler(fit, module, context):
    if "projected" not in context:
        return
    fit.ship.boostItemAttr("maxVelocity", module.getModifiedItemAttr("speedFactor"),
                           stackingPenalties = True)

########NEW FILE########
__FILENAME__ = dohacking
# Used by:
# Modules from group: Data Miners (13 of 14)
# Module: QA Cross Protocol Analyzer
type = "active"
def handler(fit, module, context):
    pass
########NEW FILE########
__FILENAME__ = drawbackarmorhp
# Used by:
# Modules from group: Rig Navigation (48 of 64)
type = "passive"
def handler(fit, module, context):
    fit.ship.boostItemAttr("armorHP", module.getModifiedItemAttr("drawback"))
########NEW FILE########
__FILENAME__ = drawbackcapreppgneed
# Used by:
# Variations of module: Capital Auxiliary Nano Pump I (2 of 2)
# Variations of module: Capital Nanobot Accelerator I (2 of 2)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Repair Systems"),
                                  "power", module.getModifiedItemAttr("drawback"))

########NEW FILE########
__FILENAME__ = drawbackcpuneedlaunchers
# Used by:
# Modules from group: Rig Launcher (48 of 48)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Missile Launcher Operation"),
                                  "cpu", module.getModifiedItemAttr("drawback"))

########NEW FILE########
__FILENAME__ = drawbackcpuoutput
# Used by:
# Modules from group: Rig Drones (64 of 64)
# Modules named like: Optimizer (16 of 16)
type = "passive"
def handler(fit, module, context):
    fit.ship.boostItemAttr("cpuOutput", module.getModifiedItemAttr("drawback"))
########NEW FILE########
__FILENAME__ = drawbackmaxvelocity
# Used by:
# Modules from group: Rig Armor (48 of 64)
# Modules from group: Rig Resource Processing (8 of 10)
type = "passive"
def handler(fit, module, context):
    fit.ship.boostItemAttr("maxVelocity", module.getModifiedItemAttr("drawback"),
                           stackingPenalties = True)
########NEW FILE########
__FILENAME__ = drawbackpowerneedhybrids
# Used by:
# Modules from group: Rig Hybrid Weapon (56 of 56)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Hybrid Weapon",
                                  "power", module.getModifiedItemAttr("drawback"))
########NEW FILE########
__FILENAME__ = drawbackpowerneedlasers
# Used by:
# Modules from group: Rig Energy Weapon (56 of 56)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Energy Weapon",
                                  "power", module.getModifiedItemAttr("drawback"))
########NEW FILE########
__FILENAME__ = drawbackpowerneedprojectiles
# Used by:
# Modules from group: Rig Projectile Weapon (40 of 40)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Projectile Weapon",
                                  "power", module.getModifiedItemAttr("drawback"))
########NEW FILE########
__FILENAME__ = drawbackrepairsystemspgneed
# Used by:
# Modules named like: Auxiliary Nano Pump (6 of 8)
# Modules named like: Nanobot Accelerator (6 of 8)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Repair Systems"),
                                  "power", module.getModifiedItemAttr("drawback"))
########NEW FILE########
__FILENAME__ = drawbackshieldcapacity
# Used by:
# Modules from group: Rig Electronic Systems (40 of 48)
# Modules from group: Rig Targeting (16 of 16)
# Modules named like: Signal Focusing Kit (8 of 8)
type = "passive"
def handler(fit, module, context):
    fit.ship.boostItemAttr("shieldCapacity", module.getModifiedItemAttr("drawback"))

########NEW FILE########
__FILENAME__ = drawbacksigrad
# Used by:
# Modules from group: Rig Shield (72 of 72)
type = "passive"
def handler(fit, module, context):
    fit.ship.boostItemAttr("signatureRadius", module.getModifiedItemAttr("drawback"), stackingPenalties = True)

########NEW FILE########
__FILENAME__ = dreadnoughtmd1projdmgbonus
# Used by:
# Ship: Naglfar
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Dreadnought").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Projectile Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("dreadnoughtShipBonusM1") * level)

########NEW FILE########
__FILENAME__ = dreadnoughtmd3projrofbonus
# Used by:
# Ship: Naglfar
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Dreadnought").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Projectile Turret"),
                                  "speed", ship.getModifiedItemAttr("dreadnoughtShipBonusM3") * level)

########NEW FILE########
__FILENAME__ = dreadnoughtshipbonushybriddmgg1
# Used by:
# Ship: Moros
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Dreadnought").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Hybrid Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("dreadnoughtShipBonusG1") * level)

########NEW FILE########
__FILENAME__ = dreadnoughtshipbonushybridrofg2
# Used by:
# Ship: Moros
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Dreadnought").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Hybrid Turret"),
                                  "speed", ship.getModifiedItemAttr("dreadnoughtShipBonusG2") * level)

########NEW FILE########
__FILENAME__ = dreadnoughtshipbonuslasercapneeda1
# Used by:
# Ship: Revelation
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Dreadnought").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Energy Turret"),
                                  "capacitorNeed", ship.getModifiedItemAttr("dreadnoughtShipBonusA1") * level)

########NEW FILE########
__FILENAME__ = dreadnoughtshipbonuslaserrofa2
# Used by:
# Ship: Revelation
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Dreadnought").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Energy Turret"),
                                  "speed", ship.getModifiedItemAttr("dreadnoughtShipBonusA2") * level)

########NEW FILE########
__FILENAME__ = dreadnoughtshipbonusmissilekineticdmgc2
# Used by:
# Ship: Phoenix
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Dreadnought").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Citadel Torpedoes"),
                                    "kineticDamage", ship.getModifiedItemAttr("dreadnoughtShipBonusC2") * level)

########NEW FILE########
__FILENAME__ = dreadnoughtshipbonusmissilekineticdmgc3
# Used by:
# Ship: Phoenix
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Dreadnought").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Citadel Cruise Missiles"),
                                    "kineticDamage", ship.getModifiedItemAttr("dreadnoughtShipBonusC3") * level)

########NEW FILE########
__FILENAME__ = dronearmordamagebonuseffect
# Used by:
# Ship: Exequror
# Ship: Guardian
# Ship: Oneiros
# Ship: Scythe
type = "passive"
def handler(fit, ship, context):
    # This is actually level-less bonus, anyway you have to train cruisers 5
    # and will get 100% (20%/lvl as stated by description)
    fit.drones.filteredItemBoost(lambda drone: drone.item.group.name == "Logistic Drone",
                                 "armorDamageAmount", ship.getModifiedItemAttr("droneArmorDamageAmountBonus"))

########NEW FILE########
__FILENAME__ = dronebandwidthaddpassive
# Used by:
# Subsystems from group: Engineering Systems (13 of 16)
# Subsystems from group: Offensive Systems (16 of 16)
type = "passive"
def handler(fit, module, context):
    fit.ship.increaseItemAttr("droneBandwidth", module.getModifiedItemAttr("droneBandwidth"))

########NEW FILE########
__FILENAME__ = dronecapacityadddronecapacitypassive
# Used by:
# Items from category: Subsystem (42 of 80)
type = "passive"
def handler(fit, module, context):
    fit.ship.increaseItemAttr("droneCapacity", module.getModifiedItemAttr("droneCapacity"))

########NEW FILE########
__FILENAME__ = dronedamagebonusonline
# Used by:
# Modules from group: Drone Damage Modules (6 of 6)
type = "passive"
def handler(fit, module, context):
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                 "damageMultiplier", module.getModifiedItemAttr("droneDamageBonus"),
                                 stackingPenalties = True)

########NEW FILE########
__FILENAME__ = dronedamagebonusrequringdrones
# Used by:
# Skill: Drone Interfacing
type = "passive"
def handler(fit, skill, context):
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                 "damageMultiplier", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)

########NEW FILE########
__FILENAME__ = dronedmgbonus
# Used by:
# Skills named like: Drone Specialization (4 of 4)
# Skill: Heavy Drone Operation
# Skill: Sentry Drone Interfacing
type = "passive"
def handler(fit, skill, context):
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill(skill),
                                 "damageMultiplier", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)

########NEW FILE########
__FILENAME__ = dronedmgbonusrequiringscoutdroneop
# Used by:
# Skill: Combat Drone Operation
type = "passive"
def handler(fit, skill, context):
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Scout Drone Operation"),
                                 "damageMultiplier", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)

########NEW FILE########
__FILENAME__ = dronedurabilityarmorhpbonus
# Used by:
# Modules named like: Drone Durability Enhancer (8 of 8)
type = "passive"
def handler(fit, module, context):
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                  "armorHP", module.getModifiedItemAttr("hullHpBonus"))

########NEW FILE########
__FILENAME__ = dronedurabilityarmorhpbonus2
# Used by:
# Skill: Drone Durability
type = "passive"
def handler(fit, skill, context):
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                 "armorHP", skill.getModifiedItemAttr("armorHpBonus") * skill.level)
########NEW FILE########
__FILENAME__ = dronedurabilityhpbonus
# Used by:
# Modules named like: Drone Durability Enhancer (8 of 8)
# Skill: Drone Durability
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                 "hp", container.getModifiedItemAttr("hullHpBonus") * level)

########NEW FILE########
__FILENAME__ = dronedurabilityshieldcapbonus
# Used by:
# Modules named like: Drone Durability Enhancer (8 of 8)
type = "passive"
def handler(fit, module, context):
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                  "shieldCapacity", module.getModifiedItemAttr("hullHpBonus"))

########NEW FILE########
__FILENAME__ = dronedurabilityshieldcapbonus2
# Used by:
# Skill: Drone Durability
type = "passive"
def handler(fit, skill, context):
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                  "shieldCapacity", skill.getModifiedItemAttr("shieldCapacityBonus") * skill.level)

########NEW FILE########
__FILENAME__ = dronemaxrangebonus
# Used by:
# Modules named like: Drone Scope Chip (8 of 8)
# Skill: Drone Sharpshooting
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    stacking = False if "skill" in context else True
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                 "maxRange",
                                 container.getModifiedItemAttr("rangeSkillBonus") * level,
                                 stackingPenalties = stacking)

########NEW FILE########
__FILENAME__ = dronemaxvelocitybonus
# Used by:
# Modules named like: Drone Speed Augmentor (8 of 8)
# Skill: Drone Navigation
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                 "maxVelocity", container.getModifiedItemAttr("droneMaxVelocityBonus") * level)

########NEW FILE########
__FILENAME__ = dronemwdboostonline
# Used by:
# Modules from group: Drone Navigation Computer (6 of 6)
type = "passive"
def handler(fit, module, context):
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"), "maxVelocity",
                                 module.getModifiedItemAttr("speedBoostFactor"), stackingPenalties = True)

########NEW FILE########
__FILENAME__ = dronerangebonusadd
# Used by:
# Modules from group: Drone Control Range Module (7 of 7)
type = "passive"
def handler(fit, module, context):
    amount = module.getModifiedItemAttr("droneRangeBonus")
    fit.extraAttributes.increase("droneControlRange", amount)

########NEW FILE########
__FILENAME__ = dronerigstasiswebspeedfactorbonus
# Used by:
# Modules named like: Stasis Drone Augmentor (8 of 8)
type = "passive"
def handler(fit, module, context):
    fit.drones.filteredItemBoost(lambda drone: drone.item.group.name == "Stasis Webifying Drone",
                                 "speedFactor", module.getModifiedItemAttr("webSpeedFactorBonus"))
########NEW FILE########
__FILENAME__ = dronesalvagebonus
# Used by:
# Skill: Salvage Drone Operation
type = "passive"
def handler(fit, container, context):
    fit.drones.filteredItemIncrease(lambda drone: drone.item.requiresSkill("Salvage Drone Operation"),
                                    "accessDifficultyBonus", container.getModifiedItemAttr("accessDifficultyBonus") * container.level)

########NEW FILE########
__FILENAME__ = droneshieldbonusbonuseffect
# Used by:
# Ships from group: Logistics (3 of 5)
# Ship: Exequror
# Ship: Scythe
type = "passive"
def handler(fit, ship, context):
    # This is actually level-less bonus, anyway you have to train cruisers 5
    # and will get 100% (20%/lvl as stated by description)
    fit.drones.filteredItemBoost(lambda drone: drone.item.group.name == "Logistic Drone",
                                 "shieldBonus", ship.getModifiedItemAttr("droneShieldBonusBonus"))

########NEW FILE########
__FILENAME__ = dronesmaxactivedronebonusmodaddmaxactiveactive
# Used by:
# Modules from group: Drone Control Unit (5 of 5)
type = "active"
def handler(fit, module, context):
    amount = module.getModifiedItemAttr("maxActiveDroneBonus")
    fit.extraAttributes.increase("maxActiveDrones", amount)

########NEW FILE########
__FILENAME__ = dronesskillboostmaxactivedronebonus
# Used by:
# Skill: Drones
type = "passive"
def handler(fit, skill, context):
    amount = skill.getModifiedItemAttr("maxActiveDroneBonus") * skill.level
    fit.extraAttributes.increase("maxActiveDrones", amount)

########NEW FILE########
__FILENAME__ = dronetrackingcomputerbonus
# Used by:
# Modules from group: Drone Tracking Modules (7 of 7)
type = "active"
def handler(fit, module, context):
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                 "maxRange", module.getModifiedItemAttr("maxRangeBonus"),
                                 stackingPenalties=True)
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                 "falloff", module.getModifiedItemAttr("falloffBonus"),
                                 stackingPenalties=True)
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                 "trackingSpeed", module.getModifiedItemAttr("trackingSpeedBonus"),
                                 stackingPenalties=True)


########NEW FILE########
__FILENAME__ = durationbonusforgroupafterburner
# Used by:
# Modules named like: Engine Thermal Shielding (8 of 8)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Propulsion Module",
                                  "duration", module.getModifiedItemAttr("durationBonus"))

########NEW FILE########
__FILENAME__ = ecmburst
# Used by:
# Modules from group: ECM Burst (7 of 7)
type = "active"
def handler(fit, module, context):
    pass
########NEW FILE########
__FILENAME__ = ecmgravimetricstrengthbonuspercent
# Used by:
# Modules from group: ECM Stabilizer (6 of 6)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "ECM",
                                  "scanGravimetricStrengthBonus", module.getModifiedItemAttr("ecmStrengthBonusPercent"),
                                  stackingPenalties = True)

########NEW FILE########
__FILENAME__ = ecmladarstrengthbonuspercent
# Used by:
# Modules from group: ECM Stabilizer (6 of 6)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "ECM",
                                  "scanLadarStrengthBonus", module.getModifiedItemAttr("ecmStrengthBonusPercent"),
                                  stackingPenalties = True)

########NEW FILE########
__FILENAME__ = ecmmagnetometricstrengthbonuspercent
# Used by:
# Modules from group: ECM Stabilizer (6 of 6)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "ECM",
                                  "scanMagnetometricStrengthBonus", module.getModifiedItemAttr("ecmStrengthBonusPercent"),
                                  stackingPenalties = True)

########NEW FILE########
__FILENAME__ = ecmradarstrengthbonuspercent
# Used by:
# Modules from group: ECM Stabilizer (6 of 6)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "ECM",
                                  "scanRadarStrengthBonus", module.getModifiedItemAttr("ecmStrengthBonusPercent"),
                                  stackingPenalties = True)

########NEW FILE########
__FILENAME__ = ecmrangebonusmoduleeffect
# Used by:
# Modules from group: ECM Stabilizer (6 of 6)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "ECM",
                                  "maxRange", module.getModifiedItemAttr("ecmRangeBonus"),
                                  stackingPenalties = True)
########NEW FILE########
__FILENAME__ = electronicattributemodifyonline
# Used by:
# Modules from group: Automated Targeting System (6 of 6)
# Module: QA Damage Module
type = "passive"
def handler(fit, module, context):
    fit.ship.increaseItemAttr("maxLockedTargets", module.getModifiedItemAttr("maxLockedTargetsBonus"))

########NEW FILE########
__FILENAME__ = electronicscpuoutputbonuspostpercentcpuoutputlocationshipgroupcomputer
# Used by:
# Implants named like: Zainou 'Gypsy' Electronics EE (6 of 6)
# Modules named like: Processor Overclocking Unit (8 of 8)
# Implant: Genolution Core Augmentation CA-2
# Skill: CPU Management
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.ship.boostItemAttr("cpuOutput", container.getModifiedItemAttr("cpuOutputBonus2") * level)

########NEW FILE########
__FILENAME__ = elitebargebonusiceharvestingcycletimebarge3
# Used by:
# Ships from group: Exhumer (3 of 3)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Exhumers").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Ice Harvesting"),
                                  "duration", ship.getModifiedItemAttr("eliteBonusBarge2") * level)

########NEW FILE########
__FILENAME__ = elitebonusassaultshiplightmissilerof
# Used by:
# Ship: Cambion
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Assault Frigates").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Missile Launcher Light",
                                  "speed", ship.getModifiedItemAttr("eliteBonusGunship1") * level)

########NEW FILE########
__FILENAME__ = elitebonusassaultshipmissilevelocity1
# Used by:
# Ship: Hawk
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Assault Frigates").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Missile Launcher Operation"),
                                    "maxVelocity", ship.getModifiedItemAttr("eliteBonusGunship1") * level)
########NEW FILE########
__FILENAME__ = elitebonusassaultshiprocketrof
# Used by:
# Ship: Cambion
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Assault Frigates").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Missile Launcher Rocket",
                                  "speed", ship.getModifiedItemAttr("eliteBonusGunship1") * level)

########NEW FILE########
__FILENAME__ = elitebonusbargeminingyield
# Used by:
# Ships from group: Exhumer (3 of 3)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Exhumers").level
    groups = ("Strip Miner", "Frequency Mining Laser")
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name in groups,
                                  "miningAmount", ship.getModifiedItemAttr("eliteBonusBarge1") * level)

########NEW FILE########
__FILENAME__ = elitebonusblackopsagiliy1
# Used by:
# Ship: Sin
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Black Ops").level
    fit.ship.boostItemAttr("agility", ship.getModifiedItemAttr("eliteBonusBlackOps1") * level)
########NEW FILE########
__FILENAME__ = elitebonusblackopscloakvelocity2
# Used by:
# Ships from group: Black Ops (4 of 4)
type = "passive"
def handler(fit, ship, context):
    if fit.extraAttributes["cloaked"]:
        level = fit.character.getSkill("Black Ops").level
        fit.ship.multiplyItemAttr("maxVelocity", ship.getModifiedItemAttr("eliteBonusBlackOps2") * level)

########NEW FILE########
__FILENAME__ = elitebonusblackopsecmburstgravandladarandmagnetoandradar
# Used by:
# Ship: Widow
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Black Ops").level
    sensorTypes = ("Gravimetric", "Ladar", "Magnetometric", "Radar")
    for type in sensorTypes:
        fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "ECM Burst", "scan{0}StrengthBonus".format(type),
                                      ship.getModifiedItemAttr("eliteBonusBlackOps1") * level)

########NEW FILE########
__FILENAME__ = elitebonusblackopsecmgravandladarandmagnetometricandradarstrength1
# Used by:
# Ship: Widow
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Black Ops").level
    sensorTypes = ("Gravimetric", "Ladar", "Magnetometric", "Radar")
    for type in sensorTypes:
        fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "ECM", "scan{0}StrengthBonus".format(type),
                                      ship.getModifiedItemAttr("eliteBonusBlackOps1") * level)

########NEW FILE########
__FILENAME__ = elitebonusblackopslargeenergyturrettracking1
# Used by:
# Ship: Redeemer
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Black Ops").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Energy Turret"),
                                  "trackingSpeed", ship.getModifiedItemAttr("eliteBonusBlackOps1") * level)

########NEW FILE########
__FILENAME__ = elitebonusblackopsmaxvelocity1
# Used by:
# Ship: Panther
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Black Ops").level
    fit.ship.boostItemAttr("maxVelocity", ship.getModifiedItemAttr("eliteBonusBlackOps1") * level)
########NEW FILE########
__FILENAME__ = elitebonuscommandshiparmoredcs3
# Used by:
# Ships from group: Command Ship (4 of 8)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Command Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Armored Warfare Specialist"),
                                  "commandBonus", ship.getModifiedItemAttr("eliteBonusCommandShips3") * level)

########NEW FILE########
__FILENAME__ = elitebonuscommandshiparmorhp1
# Used by:
# Ship: Damnation
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Command Ships").level
    fit.ship.boostItemAttr("armorHP", ship.getModifiedItemAttr("eliteBonusCommandShips1") * level)
########NEW FILE########
__FILENAME__ = elitebonuscommandshiphamrofcs1
# Used by:
# Ship: Claymore
# Ship: Nighthawk
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Command Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Missile Launcher Heavy Assault",
                                  "speed", ship.getModifiedItemAttr("eliteBonusCommandShips1") * level)

########NEW FILE########
__FILENAME__ = elitebonuscommandshipheavyassaultmissiledamagecs2
# Used by:
# Ship: Damnation
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Command Ships").level
    damageTypes = ("em", "explosive", "kinetic", "thermal")
    for damageType in damageTypes:
        fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Assault Missiles"),
                                        "{0}Damage".format(damageType), ship.getModifiedItemAttr("eliteBonusCommandShips2") * level)

########NEW FILE########
__FILENAME__ = elitebonuscommandshipheavydronetrackingcs2
# Used by:
# Ship: Eos
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Command Ships").level
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Heavy Drone Operation"),
                                 "trackingSpeed", ship.getModifiedItemAttr("eliteBonusCommandShips2") * level)

########NEW FILE########
__FILENAME__ = elitebonuscommandshipheavydronevelocitycs2
# Used by:
# Ship: Eos
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Command Ships").level
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Heavy Drone Operation"),
                                 "maxVelocity", ship.getModifiedItemAttr("eliteBonusCommandShips2") * level)

########NEW FILE########
__FILENAME__ = elitebonuscommandshipheavymissiledamagecs2
# Used by:
# Ship: Damnation
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Command Ships").level
    damageTypes = ("em", "explosive", "kinetic", "thermal")
    for damageType in damageTypes:
        fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Missiles"),
                                        "{0}Damage".format(damageType), ship.getModifiedItemAttr("eliteBonusCommandShips2") * level)

########NEW FILE########
__FILENAME__ = elitebonuscommandshiphmrofcs1
# Used by:
# Ship: Claymore
# Ship: Nighthawk
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Command Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Missile Launcher Heavy",
                                  "speed", ship.getModifiedItemAttr("eliteBonusCommandShips1") * level)

########NEW FILE########
__FILENAME__ = elitebonuscommandshiphybridfalloffcs2
# Used by:
# Ship: Astarte
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Command Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Hybrid Turret"),
                                  "falloff", ship.getModifiedItemAttr("eliteBonusCommandShips2") * level)

########NEW FILE########
__FILENAME__ = elitebonuscommandshiphybridoptimalcs1
# Used by:
# Ship: Vulture
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Command Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Hybrid Turret"),
                                  "maxRange", ship.getModifiedItemAttr("eliteBonusCommandShips1") * level)

########NEW FILE########
__FILENAME__ = elitebonuscommandshipinformationcs3
# Used by:
# Ships from group: Command Ship (4 of 8)
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Command Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Information Warfare Specialist"),
                                  "commandBonus", module.getModifiedItemAttr("eliteBonusCommandShips3") * level)

########NEW FILE########
__FILENAME__ = elitebonuscommandshipinformationhiddencs3
# Used by:
# Ships from group: Command Ship (4 of 8)
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Command Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Information Warfare Specialist"),
                                  "commandBonusHidden", module.getModifiedItemAttr("eliteBonusCommandShips3") * level)

########NEW FILE########
__FILENAME__ = elitebonuscommandshiplaserdamagecs1
# Used by:
# Ship: Absolution
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Command Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Energy Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("eliteBonusCommandShips1") * level)

########NEW FILE########
__FILENAME__ = elitebonuscommandshiplaserrofcs2
# Used by:
# Ship: Absolution
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Command Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Energy Turret"),
                                  "speed", ship.getModifiedItemAttr("eliteBonusCommandShips2") * level)

########NEW FILE########
__FILENAME__ = elitebonuscommandshipmediumhybriddamagecs2
# Used by:
# Ship: Vulture
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Command Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Hybrid Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("eliteBonusCommandShips2") * level)

########NEW FILE########
__FILENAME__ = elitebonuscommandshipmediumhybridrofcs1
# Used by:
# Ship: Astarte
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Command Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Hybrid Turret"),
                                  "speed", ship.getModifiedItemAttr("eliteBonusCommandShips1") * level)

########NEW FILE########
__FILENAME__ = elitebonuscommandshipmediumhybridtrackingcs1
# Used by:
# Ship: Eos
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Command Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Hybrid Turret"),
                                  "trackingSpeed", ship.getModifiedItemAttr("eliteBonusCommandShips1") * level)

########NEW FILE########
__FILENAME__ = elitebonuscommandshipprojectiledamagecs1
# Used by:
# Ship: Sleipnir
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Command Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Projectile Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("eliteBonusCommandShips1") * level)

########NEW FILE########
__FILENAME__ = elitebonuscommandshipprojectilefalloffcs2
# Used by:
# Ship: Sleipnir
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Command Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Projectile Turret"),
                                  "falloff", ship.getModifiedItemAttr("eliteBonusCommandShips2") * level)

########NEW FILE########
__FILENAME__ = elitebonuscommandshipsheavyassaultmissileexplosionradiuscs2
# Used by:
# Ship: Nighthawk
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Command Ships").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Assault Missiles"),
                                    "aoeCloudSize", ship.getModifiedItemAttr("eliteBonusCommandShips2") * level)

########NEW FILE########
__FILENAME__ = elitebonuscommandshipsheavyassaultmissileexplosionvelocitycs2
# Used by:
# Ship: Claymore
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Command Ships").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Assault Missiles"),
                                    "aoeVelocity", ship.getModifiedItemAttr("eliteBonusCommandShips2") * level)

########NEW FILE########
__FILENAME__ = elitebonuscommandshipsheavymissileexplosionradiuscs2
# Used by:
# Ship: Nighthawk
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Command Ships").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Missiles"),
                                    "aoeCloudSize", ship.getModifiedItemAttr("eliteBonusCommandShips2") * level)

########NEW FILE########
__FILENAME__ = elitebonuscommandshipsheavymissileexplosionvelocitycs2
# Used by:
# Ship: Claymore
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Command Ships").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Missiles"),
                                    "aoeVelocity", ship.getModifiedItemAttr("eliteBonusCommandShips2") * level)

########NEW FILE########
__FILENAME__ = elitebonuscommandshipsiegecs3
# Used by:
# Ships from group: Command Ship (4 of 8)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Command Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Siege Warfare Specialist"),
                                  "commandBonus", ship.getModifiedItemAttr("eliteBonusCommandShips3") * level)

########NEW FILE########
__FILENAME__ = elitebonuscommandshipskirmishcs3
# Used by:
# Ships from group: Command Ship (4 of 8)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Command Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Skirmish Warfare Specialist"),
                                  "commandBonus", ship.getModifiedItemAttr("eliteBonusCommandShips3") * level)

########NEW FILE########
__FILENAME__ = elitebonuscoveropsbombemdmg1
# Used by:
# Ship: Purifier
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Covert Ops").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Bomb Deployment"),
                                    "emDamage", ship.getModifiedItemAttr("eliteBonusCoverOps1") * level)

########NEW FILE########
__FILENAME__ = elitebonuscoveropsbombexplosivedmg1
# Used by:
# Ship: Hound
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Covert Ops").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Bomb Deployment"),
                                    "explosiveDamage", ship.getModifiedItemAttr("eliteBonusCoverOps1") * level)

########NEW FILE########
__FILENAME__ = elitebonuscoveropsbombkineticdmg1
# Used by:
# Ship: Manticore
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Covert Ops").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Bomb Deployment"),
                                    "kineticDamage", ship.getModifiedItemAttr("eliteBonusCoverOps1") * level)

########NEW FILE########
__FILENAME__ = elitebonuscoveropsbombthermaldmg1
# Used by:
# Ship: Nemesis
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Covert Ops").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Bomb Deployment"),
                                    "thermalDamage", ship.getModifiedItemAttr("eliteBonusCoverOps1") * level)

########NEW FILE########
__FILENAME__ = elitebonuscoveropsscanprobestrength2
# Used by:
# Ships from group: Covert Ops (5 of 5)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Covert Ops").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.group.name == "Scanner Probe",
                                    "baseSensorStrength", ship.getModifiedItemAttr("eliteBonusCoverOps2") * level)

########NEW FILE########
__FILENAME__ = elitebonuselectronicattackshipcapacitorcapacity2
# Used by:
# Ship: Kitsune
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Electronic Attack Ships").level
    fit.ship.boostItemAttr("capacitorCapacity", ship.getModifiedItemAttr("eliteBonusElectronicAttackShip2") * level)

########NEW FILE########
__FILENAME__ = elitebonuselectronicattackshipecmoptimalrange1
# Used by:
# Ship: Kitsune
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Electronic Attack Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "ECM",
                                  "maxRange", ship.getModifiedItemAttr("eliteBonusElectronicAttackShip1") * level)

########NEW FILE########
__FILENAME__ = elitebonuselectronicattackshipenergyneutrange1
# Used by:
# Ship: Sentinel
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Electronic Attack Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Energy Destabilizer",
                                  "energyDestabilizationRange", ship.getModifiedItemAttr("eliteBonusElectronicAttackShip1") * level)

########NEW FILE########
__FILENAME__ = elitebonuselectronicattackshipenergyvampirerange1
# Used by:
# Ship: Sentinel
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Electronic Attack Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Energy Vampire",
                                  "powerTransferRange", ship.getModifiedItemAttr("eliteBonusElectronicAttackShip1") * level)

########NEW FILE########
__FILENAME__ = elitebonuselectronicattackshiprechargerate2
# Used by:
# Ship: Sentinel
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Electronic Attack Ships").level
    fit.ship.boostItemAttr("rechargeRate", ship.getModifiedItemAttr("eliteBonusElectronicAttackShip2") * level)

########NEW FILE########
__FILENAME__ = elitebonuselectronicattackshipsignatureradius2
# Used by:
# Ship: Hyena
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Electronic Attack Ships").level
    fit.ship.boostItemAttr("signatureRadius", ship.getModifiedItemAttr("eliteBonusElectronicAttackShip2") * level)

########NEW FILE########
__FILENAME__ = elitebonuselectronicattackshipstasiswebmaxrange1
# Used by:
# Ship: Hyena
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Electronic Attack Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Stasis Web",
                                  "maxRange", ship.getModifiedItemAttr("eliteBonusElectronicAttackShip1") * level)

########NEW FILE########
__FILENAME__ = elitebonuselectronicattackshipwarpscramblercapneed2
# Used by:
# Ship: Keres
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Electronic Attack Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Warp Scrambler",
                                  "capacitorNeed", ship.getModifiedItemAttr("eliteBonusElectronicAttackShip2") * level)
########NEW FILE########
__FILENAME__ = elitebonuselectronicattackshipwarpscramblermaxrange1
# Used by:
# Ship: Keres
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Electronic Attack Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Warp Scrambler",
                                  "maxRange", ship.getModifiedItemAttr("eliteBonusElectronicAttackShip1") * level)

########NEW FILE########
__FILENAME__ = elitebonusgunshiparmoremresistance1
# Used by:
# Ship: Vengeance
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Assault Frigates").level
    fit.ship.boostItemAttr("armorEmDamageResonance", ship.getModifiedItemAttr("eliteBonusGunship1") * level)
########NEW FILE########
__FILENAME__ = elitebonusgunshiparmorexplosiveresistance1
# Used by:
# Ship: Vengeance
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Assault Frigates").level
    fit.ship.boostItemAttr("armorExplosiveDamageResonance", ship.getModifiedItemAttr("eliteBonusGunship1") * level)
########NEW FILE########
__FILENAME__ = elitebonusgunshiparmorkineticresistance1
# Used by:
# Ship: Vengeance
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Assault Frigates").level
    fit.ship.boostItemAttr("armorKineticDamageResonance", ship.getModifiedItemAttr("eliteBonusGunship1") * level)
########NEW FILE########
__FILENAME__ = elitebonusgunshiparmorthermalresistance1
# Used by:
# Ship: Vengeance
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Assault Frigates").level
    fit.ship.boostItemAttr("armorThermalDamageResonance", ship.getModifiedItemAttr("eliteBonusGunship1") * level)
########NEW FILE########
__FILENAME__ = elitebonusgunshipcaprecharge2
# Used by:
# Ship: Vengeance
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Assault Frigates").level
    fit.ship.boostItemAttr("rechargeRate", ship.getModifiedItemAttr("eliteBonusGunship2") * level)
########NEW FILE########
__FILENAME__ = elitebonusgunshipdronecapacity2
# Used by:
# Ship: Ishkur
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Assault Frigates").level
    fit.ship.increaseItemAttr("droneCapacity", ship.getModifiedItemAttr("eliteBonusGunship2") * level)
########NEW FILE########
__FILENAME__ = elitebonusgunshiphybriddmg2
# Used by:
# Ship: Harpy
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Assault Frigates").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Hybrid Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("eliteBonusGunship2") * level)
########NEW FILE########
__FILENAME__ = elitebonusgunshiphybridoptimal1
# Used by:
# Ship: Enyo
# Ship: Harpy
# Ship: Ishkur
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Assault Frigates").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Hybrid Turret"),
                                  "maxRange", ship.getModifiedItemAttr("eliteBonusGunship1") * level)
########NEW FILE########
__FILENAME__ = elitebonusgunshiphybridtracking2
# Used by:
# Ship: Enyo
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Assault Frigates").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Hybrid Turret"),
                                  "trackingSpeed", ship.getModifiedItemAttr("eliteBonusGunship2") * level)
########NEW FILE########
__FILENAME__ = elitebonusgunshiplaserdamage2
# Used by:
# Ship: Retribution
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Assault Frigates").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Energy Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("eliteBonusGunship2") * level)
########NEW FILE########
__FILENAME__ = elitebonusgunshiplaseroptimal1
# Used by:
# Ship: Retribution
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Assault Frigates").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Energy Turret"),
                                  "maxRange", ship.getModifiedItemAttr("eliteBonusGunship1") * level)
########NEW FILE########
__FILENAME__ = elitebonusgunshipprojectiledamage1
# Used by:
# Ship: Wolf
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Assault Frigates").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Projectile Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("eliteBonusGunship1") * level)
########NEW FILE########
__FILENAME__ = elitebonusgunshipprojectiledamage2
# Used by:
# Ship: Jaguar
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Assault Frigates").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Projectile Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("eliteBonusGunship2") * level)
########NEW FILE########
__FILENAME__ = elitebonusgunshipprojectilefalloff2
# Used by:
# Ship: Wolf
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Assault Frigates").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Projectile Turret"),
                                  "falloff", ship.getModifiedItemAttr("eliteBonusGunship2") * level)
########NEW FILE########
__FILENAME__ = elitebonusgunshipprojectileoptimal1
# Used by:
# Ship: Jaguar
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Assault Frigates").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Projectile Turret"),
                                  "maxRange", ship.getModifiedItemAttr("eliteBonusGunship1") * level)
########NEW FILE########
__FILENAME__ = elitebonusgunshipshieldboost2
# Used by:
# Ship: Hawk
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Assault Frigates").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Shield Operation"),
                                  "shieldBonus", ship.getModifiedItemAttr("eliteBonusGunship2") * level)

########NEW FILE########
__FILENAME__ = elitebonusheavygunshipassaultmissileflighttime1
# Used by:
# Ship: Cerberus
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Heavy Assault Cruisers").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Assault Missiles"),
                                    "explosionDelay", ship.getModifiedItemAttr("eliteBonusHeavyGunship1") * level)

########NEW FILE########
__FILENAME__ = elitebonusheavygunshipassaultmissilelaunhcerrof2
# Used by:
# Ship: Cerberus
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Heavy Assault Cruisers").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Missile Launcher Rapid Light",
                                  "speed", ship.getModifiedItemAttr("eliteBonusHeavyGunship2") * level)

########NEW FILE########
__FILENAME__ = elitebonusheavygunshipdronecontrolrange1
# Used by:
# Ship: Ishtar
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Heavy Assault Cruisers").level
    amount = ship.getModifiedItemAttr("eliteBonusHeavyGunship1") * level
    fit.extraAttributes.increase("droneControlRange", amount)

########NEW FILE########
__FILENAME__ = elitebonusheavygunshipheavyandheavyassaultandassaultmissilelauncherrof
# Used by:
# Ship: Sacrilege
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Heavy Assault Cruisers").level
    groups = ("Missile Launcher Rapid Light", "Missile Launcher Heavy Assault", "Missile Launcher Heavy")
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name in groups,
                                  "speed", ship.getModifiedItemAttr("eliteBonusHeavyGunship2") * level)

########NEW FILE########
__FILENAME__ = elitebonusheavygunshipheavyassaultmissilelaunhcerrof2
# Used by:
# Ship: Cerberus
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Heavy Assault Cruisers").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Missile Launcher Heavy Assault",
                                  "speed", ship.getModifiedItemAttr("eliteBonusHeavyGunship2") * level)

########NEW FILE########
__FILENAME__ = elitebonusheavygunshipheavymissileflighttime1
# Used by:
# Ship: Cerberus
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Heavy Assault Cruisers").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Missiles"),
                                    "explosionDelay", ship.getModifiedItemAttr("eliteBonusHeavyGunship1") * level)

########NEW FILE########
__FILENAME__ = elitebonusheavygunshipheavymissilelaunhcerrof2
# Used by:
# Ship: Cerberus
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Heavy Assault Cruisers").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Missile Launcher Heavy",
                                  "speed", ship.getModifiedItemAttr("eliteBonusHeavyGunship2") * level)

########NEW FILE########
__FILENAME__ = elitebonusheavygunshiphybriddmg2
# Used by:
# Ship: Deimos
# Ship: Eagle
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Heavy Assault Cruisers").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Hybrid Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("eliteBonusHeavyGunship2") * level)

########NEW FILE########
__FILENAME__ = elitebonusheavygunshiphybridfalloff1
# Used by:
# Ship: Deimos
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Heavy Assault Cruisers").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Hybrid Turret"),
                                  "falloff", ship.getModifiedItemAttr("eliteBonusHeavyGunship1") * level)

########NEW FILE########
__FILENAME__ = elitebonusheavygunshiphybridoptimal1
# Used by:
# Ship: Eagle
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Heavy Assault Cruisers").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Hybrid Turret"),
                                  "maxRange", ship.getModifiedItemAttr("eliteBonusHeavyGunship1") * level)

########NEW FILE########
__FILENAME__ = elitebonusheavygunshiplaserdmg2
# Used by:
# Ship: Zealot
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Heavy Assault Cruisers").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Energy Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("eliteBonusHeavyGunship2") * level)

########NEW FILE########
__FILENAME__ = elitebonusheavygunshiplaseroptimal1
# Used by:
# Ship: Zealot
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Heavy Assault Cruisers").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Energy Turret"),
                                  "maxRange", ship.getModifiedItemAttr("eliteBonusHeavyGunship1") * level)

########NEW FILE########
__FILENAME__ = elitebonusheavygunshiplightmissileflighttime1
# Used by:
# Ship: Cerberus
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Heavy Assault Cruisers").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Light Missiles"),
                                    "explosionDelay", ship.getModifiedItemAttr("eliteBonusHeavyGunship1") * level)

########NEW FILE########
__FILENAME__ = elitebonusheavygunshipprojectiledmg2
# Used by:
# Ship: Vagabond
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Heavy Assault Cruisers").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Projectile Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("eliteBonusHeavyGunship2") * level)

########NEW FILE########
__FILENAME__ = elitebonusheavygunshipprojectilefalloff1
# Used by:
# Ship: Vagabond
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Heavy Assault Cruisers").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Projectile Turret"),
                                  "falloff", ship.getModifiedItemAttr("eliteBonusHeavyGunship1") * level)

########NEW FILE########
__FILENAME__ = elitebonusheavygunshipprojectileoptimal1
# Used by:
# Ship: Muninn
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Heavy Assault Cruisers").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Projectile Turret"),
                                  "maxRange", ship.getModifiedItemAttr("eliteBonusHeavyGunship1") * level)

########NEW FILE########
__FILENAME__ = elitebonusheavygunshipprojectiletracking2
# Used by:
# Ship: Muninn
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Heavy Assault Cruisers").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Projectile Turret"),
                                  "trackingSpeed", ship.getModifiedItemAttr("eliteBonusHeavyGunship2") * level)

########NEW FILE########
__FILENAME__ = elitebonusheavyinterdictorheavyassaultmissilevelocitybonus
# Used by:
# Ship: Onyx
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Heavy Interdiction Cruisers").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Assault Missiles"),
                                    "maxVelocity", ship.getModifiedItemAttr("eliteBonusHeavyInterdictors1") * level)

########NEW FILE########
__FILENAME__ = elitebonusheavyinterdictorheavymissilevelocitybonus1
# Used by:
# Ship: Onyx
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Heavy Interdiction Cruisers").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Missiles"),
                                    "maxVelocity", ship.getModifiedItemAttr("eliteBonusHeavyInterdictors1") * level)

########NEW FILE########
__FILENAME__ = elitebonusheavyinterdictorlaserrof
# Used by:
# Ship: Devoter
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Heavy Interdiction Cruisers").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Energy Turret"),
                                  "speed", ship.getModifiedItemAttr("eliteBonusHeavyInterdictors1") * level)

########NEW FILE########
__FILENAME__ = elitebonusheavyinterdictorshybridfalloff1
# Used by:
# Ship: Phobos
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Heavy Interdiction Cruisers").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Hybrid Turret"),
                                  "falloff", ship.getModifiedItemAttr("eliteBonusHeavyInterdictors1") * level)

########NEW FILE########
__FILENAME__ = elitebonusheavyinterdictorsprojectilefalloff1
# Used by:
# Ship: Broadsword
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Heavy Interdiction Cruisers").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Projectile Turret"),
                                  "falloff", ship.getModifiedItemAttr("eliteBonusHeavyInterdictors1") * level)

########NEW FILE########
__FILENAME__ = elitebonusheavyinterdictorswarpdisruptfieldgeneratorwarpscramblerange2
# Used by:
# Ships from group: Heavy Interdiction Cruiser (4 of 4)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Heavy Interdiction Cruisers").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Warp Disrupt Field Generator",
                                  "warpScrambleRange", ship.getModifiedItemAttr("eliteBonusHeavyInterdictors2") * level)
########NEW FILE########
__FILENAME__ = elitebonusinterdictorsarmorresist1
# Used by:
# Ship: Heretic
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Interdictors").level
    for damageType in ("Em", "Thermal", "Explosive", "Kinetic"):
        fit.ship.boostItemAttr("armor%sDamageResonance" % damageType,
                               ship.getModifiedItemAttr("eliteBonusInterdictors1") * level)

########NEW FILE########
__FILENAME__ = elitebonusinterdictorsmissilekineticdamage1
# Used by:
# Ship: Flycatcher
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Interdictors").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Light Missiles") or mod.charge.requiresSkill("Rockets"),
                                    "kineticDamage", ship.getModifiedItemAttr("eliteBonusInterdictors1") * level)

########NEW FILE########
__FILENAME__ = elitebonusinterdictorsmwdsigradius2
# Used by:
# Ships from group: Interdictor (4 of 4)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Interdictors").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("High Speed Maneuvering"),
                                  "signatureRadiusBonus", ship.getModifiedItemAttr("eliteBonusInterdictors2") * level)

########NEW FILE########
__FILENAME__ = elitebonusinterdictorsprojectilefalloff1
# Used by:
# Ship: Sabre
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Interdictors").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Projectile Turret"),
                                  "falloff", ship.getModifiedItemAttr("eliteBonusInterdictors1") * level)

########NEW FILE########
__FILENAME__ = elitebonusinterdictorsshtdamage1
# Used by:
# Ship: Eris
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Interdictors").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Hybrid Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("eliteBonusInterdictors1") * level)

########NEW FILE########
__FILENAME__ = elitebonusjumpfreighterarmorhp1
# Used by:
# Ships from group: Jump Freighter (4 of 4)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Jump Freighters").level
    fit.ship.boostItemAttr("armorHP", ship.getModifiedItemAttr("eliteBonusJumpFreighter1") * level)

########NEW FILE########
__FILENAME__ = elitebonusjumpfreighterhullhp1
# Used by:
# Ships from group: Jump Freighter (4 of 4)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Jump Freighters").level
    fit.ship.boostItemAttr("hp", ship.getModifiedItemAttr("eliteBonusJumpFreighter1") * level)

########NEW FILE########
__FILENAME__ = elitebonusjumpfreighterjumpdriveconsumptionamount2
# Used by:
# Ships from group: Jump Freighter (4 of 4)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Jump Freighters").level
    fit.ship.boostItemAttr("jumpDriveConsumptionAmount", ship.getModifiedItemAttr("eliteBonusJumpFreighter2") * level)

########NEW FILE########
__FILENAME__ = elitebonusjumpfreightershieldhp1
# Used by:
# Ships from group: Jump Freighter (4 of 4)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Jump Freighters").level
    fit.ship.boostItemAttr("shieldCapacity", ship.getModifiedItemAttr("eliteBonusJumpFreighter1") * level)

########NEW FILE########
__FILENAME__ = elitebonuslogisticenergytransfercapneed1
# Used by:
# Ship: Guardian
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Logistics").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Capacitor Transmitter",
                                  "capacitorNeed", ship.getModifiedItemAttr("eliteBonusLogistics1") * level)

########NEW FILE########
__FILENAME__ = elitebonuslogisticenergytransfercapneed2
# Used by:
# Ship: Basilisk
# Ship: Etana
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Logistics").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Capacitor Transmitter",
                                  "capacitorNeed", ship.getModifiedItemAttr("eliteBonusLogistics2") * level)

########NEW FILE########
__FILENAME__ = elitebonuslogisticremotearmorrepaircapneed1
# Used by:
# Ship: Oneiros
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Logistics").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Armor Repairer",
                                  "capacitorNeed", ship.getModifiedItemAttr("eliteBonusLogistics1") * level)

########NEW FILE########
__FILENAME__ = elitebonuslogisticremotearmorrepaircapneed2
# Used by:
# Ship: Guardian
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Logistics").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Armor Repairer",
                                  "capacitorNeed", ship.getModifiedItemAttr("eliteBonusLogistics2") * level)

########NEW FILE########
__FILENAME__ = elitebonuslogisticshieldtransfercapneed1
# Used by:
# Ship: Basilisk
# Ship: Etana
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Logistics").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Shield Booster",
                                  "capacitorNeed", ship.getModifiedItemAttr("eliteBonusLogistics1") * level)

########NEW FILE########
__FILENAME__ = elitebonuslogisticshieldtransfercapneed2
# Used by:
# Ship: Scimitar
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Logistics").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Shield Booster",
                                  "capacitorNeed", ship.getModifiedItemAttr("eliteBonusLogistics2") * level)

########NEW FILE########
__FILENAME__ = elitebonuslogisticstrackinglinkfalloffbonus1
# Used by:
# Ship: Scimitar
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Logistics").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Tracking Computer",
                                  "falloffBonus", ship.getModifiedItemAttr("eliteBonusLogistics1") * level)

########NEW FILE########
__FILENAME__ = elitebonuslogisticstrackinglinkfalloffbonus2
# Used by:
# Ship: Oneiros
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Logistics").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Tracking Computer",
                                  "falloffBonus", ship.getModifiedItemAttr("eliteBonusLogistics2") * level)

########NEW FILE########
__FILENAME__ = elitebonuslogisticstrackinglinkmaxrangebonus1
# Used by:
# Ship: Scimitar
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Logistics").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Tracking Computer",
                                  "maxRangeBonus", ship.getModifiedItemAttr("eliteBonusLogistics1") * level)

########NEW FILE########
__FILENAME__ = elitebonuslogisticstrackinglinkmaxrangebonus2
# Used by:
# Ship: Oneiros
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Logistics").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Tracking Computer",
                                  "maxRangeBonus", ship.getModifiedItemAttr("eliteBonusLogistics2") * level)

########NEW FILE########
__FILENAME__ = elitebonuslogisticstrackinglinktrackingspeedbonus1
# Used by:
# Ship: Scimitar
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Logistics").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Tracking Computer",
                                  "trackingSpeedBonus", ship.getModifiedItemAttr("eliteBonusLogistics1") * level)

########NEW FILE########
__FILENAME__ = elitebonuslogisticstrackinglinktrackingspeedbonus2
# Used by:
# Ship: Oneiros
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Logistics").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Tracking Computer",
                                  "trackingSpeedBonus", ship.getModifiedItemAttr("eliteBonusLogistics2") * level)

########NEW FILE########
__FILENAME__ = elitebonusmarauderscruiseandtorpedodamagerole1
# Used by:
# Ship: Golem
type = "passive"
def handler(fit, ship, context):
    damageTypes = ("em", "explosive", "kinetic", "thermal")
    for damageType in damageTypes:
        fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Cruise Missiles") or mod.charge.requiresSkill("Torpedoes"),
                                        "{0}Damage".format(damageType), ship.getModifiedItemAttr("eliteBonusViolatorsRole1"))

########NEW FILE########
__FILENAME__ = elitebonusmaraudersheavymissiledamageemrole1
# Used by:
# Ship: Golem
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Missiles"),
                                    "emDamage", ship.getModifiedItemAttr("eliteBonusViolatorsRole1"))

########NEW FILE########
__FILENAME__ = elitebonusmaraudersheavymissiledamageexprole1
# Used by:
# Ship: Golem
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Missiles"),
                                    "explosiveDamage", ship.getModifiedItemAttr("eliteBonusViolatorsRole1"))

########NEW FILE########
__FILENAME__ = elitebonusmaraudersheavymissiledamagekinrole1
# Used by:
# Ship: Golem
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Missiles"),
                                    "kineticDamage", ship.getModifiedItemAttr("eliteBonusViolatorsRole1"))

########NEW FILE########
__FILENAME__ = elitebonusmaraudersheavymissiledamagethermrole1
# Used by:
# Ship: Golem
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Missiles"),
                                    "thermalDamage", ship.getModifiedItemAttr("eliteBonusViolatorsRole1"))

########NEW FILE########
__FILENAME__ = elitebonusmaraudershieldbonus2a
# Used by:
# Ship: Golem
# Ship: Vargur
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Marauders").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Shield Operation"),
                                  "shieldBonus", ship.getModifiedItemAttr("eliteBonusViolators2") * level)

########NEW FILE########
__FILENAME__ = elitebonusvampiredrainamount2
# Used by:
# Ship: Curse
# Ship: Pilgrim
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Recon Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Energy Vampire",
                                  "powerTransferAmount", ship.getModifiedItemAttr("eliteBonusReconShip2") * level)

########NEW FILE########
__FILENAME__ = elitebonusviolatorsewtargetpainting1
# Used by:
# Ship: Golem
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Marauders").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Target Painter",
                                  "signatureRadiusBonus", ship.getModifiedItemAttr("eliteBonusViolators1") * level)

########NEW FILE########
__FILENAME__ = elitebonusviolatorslargeenergyturretdamage1
# Used by:
# Ship: Paladin
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Marauders").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Energy Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("eliteBonusViolators1") * level)

########NEW FILE########
__FILENAME__ = elitebonusviolatorslargeenergyturretdamagerole1
# Used by:
# Ship: Paladin
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Energy Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("eliteBonusViolatorsRole1"))

########NEW FILE########
__FILENAME__ = elitebonusviolatorslargehybridturretdamagerole1
# Used by:
# Ship: Kronos
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Hybrid Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("eliteBonusViolatorsRole1"))
########NEW FILE########
__FILENAME__ = elitebonusviolatorslargehybridturrettracking1
# Used by:
# Ship: Kronos
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Marauders").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Hybrid Turret"),
                                  "trackingSpeed", ship.getModifiedItemAttr("eliteBonusViolators1") * level)

########NEW FILE########
__FILENAME__ = elitebonusviolatorslargeprojectileturretdamagerole1
# Used by:
# Ship: Vargur
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Projectile Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("eliteBonusViolatorsRole1"))

########NEW FILE########
__FILENAME__ = elitebonusviolatorslargeprojectileturrettracking1
# Used by:
# Ship: Vargur
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Marauders").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Projectile Turret"),
                                  "trackingSpeed", ship.getModifiedItemAttr("eliteBonusViolators1") * level)

########NEW FILE########
__FILENAME__ = elitebonusviolatorsrepairsystemsarmordamageamount2
# Used by:
# Ship: Kronos
# Ship: Paladin
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Marauders").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Repair Systems"),
                                  "armorDamageAmount", ship.getModifiedItemAttr("eliteBonusViolators2") * level)

########NEW FILE########
__FILENAME__ = elitebonusviolatorstractorbeammaxrangerole2
# Used by:
# Ships from group: Marauder (4 of 4)
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Tractor Beam",
                                  "maxRange", ship.getModifiedItemAttr("eliteBonusViolatorsRole2"))

########NEW FILE########
__FILENAME__ = elitebonusviolatorstractorbeammaxtractorvelocityrole3
# Used by:
# Ships from group: Marauder (4 of 4)
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Tractor Beam",
                                  "maxTractorVelocity", ship.getModifiedItemAttr("eliteBonusViolatorsRole3"))

########NEW FILE########
__FILENAME__ = eliteindustrialarmorrepairamountelite1
# Used by:
# Ship: Impel
# Ship: Occator
# Ship: Prorator
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Transport Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Repair Systems"),
                                  "armorDamageAmount", ship.getModifiedItemAttr("eliteBonusIndustrial1") * level)

########NEW FILE########
__FILENAME__ = eliteindustrialarmorrepairdurationelite2
# Used by:
# Ship: Viator
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Transport Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Repair Systems"),
                                  "duration", ship.getModifiedItemAttr("eliteBonusIndustrial2") * level)

########NEW FILE########
__FILENAME__ = eliteindustrialshieldboostamountelite1
# Used by:
# Ship: Bustard
# Ship: Crane
# Ship: Mastodon
# Ship: Prowler
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Transport Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Shield Operation"),
                                  "shieldBonus", ship.getModifiedItemAttr("eliteBonusIndustrial1") * level)

########NEW FILE########
__FILENAME__ = elitereconbonusassaultlauncherrof1
# Used by:
# Ship: Huginn
# Ship: Lachesis
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Recon Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Missile Launcher Rapid Light",
                                  "speed", ship.getModifiedItemAttr("eliteBonusReconShip1") * level)

########NEW FILE########
__FILENAME__ = elitereconbonusenergyneutamount2
# Used by:
# Ship: Curse
# Ship: Pilgrim
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Recon Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Energy Destabilizer",
                                  "energyDestabilizationAmount", ship.getModifiedItemAttr("eliteBonusReconShip2") * level)

########NEW FILE########
__FILENAME__ = elitereconbonusenergyneutrange1
# Used by:
# Ship: Curse
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Recon Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Energy Destabilizer",
                                  "energyDestabilizationRange", ship.getModifiedItemAttr("eliteBonusReconShip1") * level)

########NEW FILE########
__FILENAME__ = elitereconbonusgravimetricstrength2
# Used by:
# Ship: Falcon
# Ship: Rook
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Recon Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "ECM",
                                  "scanGravimetricStrengthBonus", ship.getModifiedItemAttr("eliteBonusReconShip2") * level)

########NEW FILE########
__FILENAME__ = elitereconbonusheavyassaultlauncherrof1
# Used by:
# Ship: Huginn
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Recon Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Missile Launcher Heavy Assault",
                                  "speed", ship.getModifiedItemAttr("eliteBonusReconShip1") * level)

########NEW FILE########
__FILENAME__ = elitereconbonusheavyassaultmissilevelocity
# Used by:
# Ship: Rook
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Recon Ships").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Assault Missiles"),
                                    "maxVelocity", ship.getModifiedItemAttr("eliteBonusReconShip1") * level)

########NEW FILE########
__FILENAME__ = elitereconbonusheavylauncherrof1
# Used by:
# Ship: Huginn
# Ship: Lachesis
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Recon Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Missile Launcher Heavy",
                                  "speed", ship.getModifiedItemAttr("eliteBonusReconShip1") * level)

########NEW FILE########
__FILENAME__ = elitereconbonusheavymissilevelocity
# Used by:
# Ship: Rook
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Recon Ships").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Missiles"),
                                    "maxVelocity", ship.getModifiedItemAttr("eliteBonusReconShip1") * level)

########NEW FILE########
__FILENAME__ = elitereconbonusladarstrength2
# Used by:
# Ship: Falcon
# Ship: Rook
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Recon Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "ECM",
                                  "scanLadarStrengthBonus", ship.getModifiedItemAttr("eliteBonusReconShip2") * level)

########NEW FILE########
__FILENAME__ = elitereconbonusmagnetometricstrength2
# Used by:
# Ship: Falcon
# Ship: Rook
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Recon Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "ECM",
                                  "scanMagnetometricStrengthBonus", ship.getModifiedItemAttr("eliteBonusReconShip2") * level)

########NEW FILE########
__FILENAME__ = elitereconbonusradarstrength2
# Used by:
# Ship: Falcon
# Ship: Rook
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Recon Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "ECM",
                                  "scanRadarStrengthBonus", ship.getModifiedItemAttr("eliteBonusReconShip2") * level)

########NEW FILE########
__FILENAME__ = elitereconenergyvampirerangebonus1
# Used by:
# Ship: Curse
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Recon Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Energy Vampire",
                                  "powerTransferRange", ship.getModifiedItemAttr("eliteBonusReconShip1") * level)

########NEW FILE########
__FILENAME__ = elitereconjumpscramblerrangebonus2
# Used by:
# Ship: Arazu
# Ship: Lachesis
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Recon Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Warp Scrambler",
                                  "maxRange", ship.getModifiedItemAttr("eliteBonusReconShip2") * level)

########NEW FILE########
__FILENAME__ = elitereconstasiswebbonus2
# Used by:
# Ship: Huginn
# Ship: Moracha
# Ship: Rapier
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Recon Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Stasis Web",
                                  "maxRange", ship.getModifiedItemAttr("eliteBonusReconShip2") * level)

########NEW FILE########
__FILENAME__ = emarmorcompensationhardeningbonusgrouparmorcoating
# Used by:
# Skill: EM Armor Compensation
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Armor Coating",
                                  "emDamageResistanceBonus", skill.getModifiedItemAttr("hardeningBonus") * skill.level)

########NEW FILE########
__FILENAME__ = emarmorcompensationhardeningbonusgroupenergized
# Used by:
# Skill: EM Armor Compensation
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Armor Plating Energized",
                                  "emDamageResistanceBonus", skill.getModifiedItemAttr("hardeningBonus") * skill.level)

########NEW FILE########
__FILENAME__ = empwave
# Used by:
# Modules from group: Smart Bomb (118 of 118)
type = "active"
def handler(fit, module, context):
    pass

########NEW FILE########
__FILENAME__ = emshieldcompensationhardeningbonusgroupshieldamp
# Used by:
# Skill: EM Shield Compensation
type = "passive"
def handler(fit, skill, context):
    level = fit.character.getSkill("EM Shield Compensation").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Shield Amplifier",
                                  "emDamageResistanceBonus", skill.getModifiedItemAttr("hardeningBonus") * level)
########NEW FILE########
__FILENAME__ = energydestabilizationnew
# Used by:
# Drones from group: Cap Drain Drone (3 of 3)
# Modules from group: Energy Destabilizer (41 of 41)
from eos.types import State
type = "active", "projected"
def handler(fit, container, context):
    if "projected" in context and ((hasattr(container, "state") \
    and container.state >= State.ACTIVE) or hasattr(container, "amountActive")):
        multiplier = container.amountActive if hasattr(container, "amountActive") else 1
        amount = container.getModifiedItemAttr("energyDestabilizationAmount")
        time = container.getModifiedItemAttr("duration")
        fit.addDrain(time, amount * multiplier, 0)

########NEW FILE########
__FILENAME__ = energygridupgradescpuneedbonuspostpercentcpulocationshipmodulesrequiringenergygridupgrades
# Used by:
# Implants named like: Inherent Implants 'Squire' Energy Grid Upgrades EU (6 of 6)
# Modules named like: Powergrid Subroutine Maximizer (8 of 8)
# Skill: Energy Grid Upgrades
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Energy Grid Upgrades"),
                                  "cpu", container.getModifiedItemAttr("cpuNeedBonus") * level)

########NEW FILE########
__FILENAME__ = energymanagementcapacitorbonuspostpercentcapacitylocationshipgroupcapacitorcapacitybonus
# Used by:
# Implants named like: Inherent Implants 'Squire' Energy Management EM (6 of 6)
# Implants named like: Mindflood Booster (4 of 4)
# Modules named like: Semiconductor Memory Cell (8 of 8)
# Implant: Genolution Core Augmentation CA-1
# Skill: Capacitor Management
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.ship.boostItemAttr("capacitorCapacity", container.getModifiedItemAttr("capacitorCapacityBonus") * level)

########NEW FILE########
__FILENAME__ = energypulseweaponsdurationbonuspostpercentdurationlocationshipmodulesrequiringenergypulseweapons
# Used by:
# Implants named like: Inherent Implants 'Squire' Energy Pulse Weapons EP (6 of 6)
# Skill: Energy Pulse Weapons
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Energy Pulse Weapons"),
                                  "duration", container.getModifiedItemAttr("durationBonus") * level)
########NEW FILE########
__FILENAME__ = energysystemsoperationcaprechargebonuspostpercentrechargeratelocationshipgroupcapacitor
# Used by:
# Implants named like: Inherent Implants 'Squire' Energy Systems Operation EO (6 of 6)
# Modules named like: Capacitor Control Circuit (8 of 8)
# Implant: Genolution Core Augmentation CA-2
# Skill: Capacitor Systems Operation
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.ship.boostItemAttr("rechargeRate", container.getModifiedItemAttr("capRechargeBonus") * level)

########NEW FILE########
__FILENAME__ = energytransfer
# Used by:
# Modules from group: Remote Capacitor Transmitter (38 of 38)
type = "projected", "active"
def handler(fit, module, context):
    if "projected" in context:
        amount = module.getModifiedItemAttr("powerTransferAmount")
        duration = module.getModifiedItemAttr("duration")
        fit.addDrain(duration, -amount, 0)

########NEW FILE########
__FILENAME__ = energytransferarraymaxrangebonus
# Used by:
# Ship: Augoror
# Ship: Osprey
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Capacitor Transmitter",
                                  "powerTransferRange", ship.getModifiedItemAttr("maxRangeBonus"))

########NEW FILE########
__FILENAME__ = energytransferarraytransferamountbonus
# Used by:
# Ship: Augoror
# Ship: Osprey
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Capacitor Transmitter",
                                  "powerTransferAmount", ship.getModifiedItemAttr("energyTransferAmountBonus"))

########NEW FILE########
__FILENAME__ = energytransferpowerneedbonuseffect
# Used by:
# Ships from group: Logistics (3 of 5)
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Capacitor Transmitter",
                                  "power", ship.getModifiedItemAttr("powerTransferPowerNeedBonus"))

########NEW FILE########
__FILENAME__ = energyweapondamagemultiply
# Used by:
# Modules from group: Heat Sink (25 of 25)
# Modules named like: QA Multiship Module Players (4 of 4)
# Module: QA Damage Module
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.group.name == "Energy Weapon",
                                     "damageMultiplier", module.getModifiedItemAttr("damageMultiplier"),
                                     stackingPenalties = True)
########NEW FILE########
__FILENAME__ = energyweapondamagemultiplypassive
# Used by:
# Modules named like: Energy Collision Accelerator (8 of 8)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.group.name == "Energy Weapon",
                                     "damageMultiplier", module.getModifiedItemAttr("damageMultiplier"),
                                     stackingPenalties = True)
########NEW FILE########
__FILENAME__ = energyweaponspeedmultiply
# Used by:
# Modules from group: Heat Sink (25 of 25)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.group.name == "Energy Weapon",
                                     "speed", module.getModifiedItemAttr("speedMultiplier"),
                                     stackingPenalties = True)
########NEW FILE########
__FILENAME__ = energyweaponspeedmultiplypassive
# Used by:
# Modules named like: Energy Burst Aerator (8 of 8)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.group.name == "Energy Weapon",
                                     "speed", module.getModifiedItemAttr("speedMultiplier"),
                                     stackingPenalties = True)
########NEW FILE########
__FILENAME__ = engineeringpowerengineeringoutputbonuspostpercentpoweroutputlocationshipgrouppowercore
# Used by:
# Implants named like: Inherent Implants 'Squire' Engineering EG (6 of 6)
# Modules named like: Ancillary Current Router (8 of 8)
# Implant: Genolution Core Augmentation CA-1
# Skill: Power Grid Management
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.ship.boostItemAttr("powerOutput", container.getModifiedItemAttr("powerEngineeringOutputBonus") * level)

########NEW FILE########
__FILENAME__ = evasivemaneuveringagilitybonuspostpercentagilityship
# Used by:
# Implants named like: Eifyr and Co. 'Rogue' Evasive Maneuvering EM (6 of 6)
# Implants named like: Low grade Nomad (5 of 6)
# Modules named like: Low Friction Nozzle Joints (8 of 8)
# Implant: Genolution Core Augmentation CA-4
# Skill: Evasive Maneuvering
# Skill: Spaceship Command
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.ship.boostItemAttr("agility", container.getModifiedItemAttr("agilityBonus") * level,
                           stackingPenalties = "skill" not in context and "implant" not in context)

########NEW FILE########
__FILENAME__ = ewgroupecmburstmaxrangebonus
# Used by:
# Implants named like: Low grade Centurion (5 of 6)
type = "passive"
def handler(fit, implant, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote ECM Burst",
                                  "maxRange", implant.getModifiedItemAttr("rangeSkillBonus"))
########NEW FILE########
__FILENAME__ = ewgrouprsdmaxrangebonus
# Used by:
# Implants named like: Low grade Centurion (5 of 6)
type = "passive"
def handler(fit, implant, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Sensor Damper",
                                  "maxRange", implant.getModifiedItemAttr("rangeSkillBonus"))
########NEW FILE########
__FILENAME__ = ewgrouptdmaxrangebonus
# Used by:
# Implants named like: Low grade Centurion (5 of 6)
type = "passive"
def handler(fit, implant, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Tracking Disruptor",
                                  "maxRange", implant.getModifiedItemAttr("rangeSkillBonus"))
########NEW FILE########
__FILENAME__ = ewgrouptpmaxrangebonus
# Used by:
# Implants named like: Low grade Centurion (5 of 6)
type = "passive"
def handler(fit, implant, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Target Painter",
                                  "maxRange", implant.getModifiedItemAttr("rangeSkillBonus"))
########NEW FILE########
__FILENAME__ = ewskillecmburstcapneedbonus
# Used by:
# Implants named like: Zainou 'Gypsy' Electronic Warfare EW (6 of 6)
# Modules named like: Signal Disruption Amplifier (8 of 8)
# Skill: Electronic Warfare
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "ECM Burst",
                                  "capacitorNeed", container.getModifiedItemAttr("capNeedBonus") * level)

########NEW FILE########
__FILENAME__ = ewskillecmburstfalloffbonus
# Used by:
# Skill: Frequency Modulation
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "ECM Burst",
                                  "falloff", skill.getModifiedItemAttr("falloffBonus") * skill.level)

########NEW FILE########
__FILENAME__ = ewskillecmburstrangebonus
# Used by:
# Modules named like: Particle Dispersion Projector (8 of 8)
# Skill: Long Distance Jamming
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "ECM Burst",
                                  "ecmBurstRange", container.getModifiedItemAttr("rangeSkillBonus") * level,
                                  stackingPenalties = False if "skill" in context else True)

########NEW FILE########
__FILENAME__ = ewskillewcapneedskilllevel
# Used by:
# Implants named like: Zainou 'Gypsy' Electronic Warfare EW (6 of 6)
# Modules named like: Signal Disruption Amplifier (8 of 8)
# Skill: Electronic Warfare
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "ECM",
                                  "capacitorNeed", container.getModifiedItemAttr("capNeedBonus") * level)

########NEW FILE########
__FILENAME__ = ewskillewfalloffbonus
# Used by:
# Skill: Frequency Modulation
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "ECM",
                                  "falloff", skill.getModifiedItemAttr("falloffBonus") * skill.level)
########NEW FILE########
__FILENAME__ = ewskillewmaxrangebonus
# Used by:
# Implants named like: Low grade Centurion (5 of 6)
# Modules named like: Particle Dispersion Projector (8 of 8)
# Skill: Long Distance Jamming
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "ECM",
                                  "maxRange", container.getModifiedItemAttr("rangeSkillBonus") * level,
                                  stackingPenalties = "skill" not in context and "implant" not in context)

########NEW FILE########
__FILENAME__ = ewskillrsdcapneedbonusskilllevel
# Used by:
# Implants named like: Zainou 'Gypsy' Sensor Linking SL (6 of 6)
# Skill: Sensor Linking
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Sensor Linking"),
                                  "capacitorNeed", container.getModifiedItemAttr("capNeedBonus") * level)

########NEW FILE########
__FILENAME__ = ewskillrsdfalloffbonus
# Used by:
# Skill: Frequency Modulation
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Sensor Linking"),
                                  "falloff", skill.getModifiedItemAttr("falloffBonus") * skill.level)

########NEW FILE########
__FILENAME__ = ewskillrsdmaxrangebonus
# Used by:
# Modules named like: Particle Dispersion Projector (8 of 8)
# Skill: Long Distance Jamming
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Sensor Linking"),
                                  "maxRange", container.getModifiedItemAttr("rangeSkillBonus") * level,
                                  stackingPenalties = "skill" not in context)

########NEW FILE########
__FILENAME__ = ewskillscanstrengthbonus
# Used by:
# Modules named like: Particle Dispersion Augmentor (8 of 8)
# Skill: Signal Dispersion
type = "passive"
def handler(fit, container, context):
    groups = ("ECM", "ECM Burst")
    level = container.level if "skill" in context else 1
    for scanType in ("Gravimetric", "Ladar", "Magnetometric", "Radar"):
        fit.modules.filteredItemBoost(lambda mod: mod.item.group.name in groups,
                                      "scan{0}StrengthBonus".format(scanType), container.getModifiedItemAttr("scanSkillEwStrengthBonus") * level,
                                      stackingPenalties = False if "skill" in context else True)

########NEW FILE########
__FILENAME__ = ewskillsignalsuppressionmaxtargetrangebonus
# Used by:
# Modules named like: Inverted Signal Field Projector (8 of 8)
# Skill: Signal Suppression
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Sensor Damper",
                                  "maxTargetRangeBonus", container.getModifiedItemAttr("scanSkillEwStrengthBonus") * level)

########NEW FILE########
__FILENAME__ = ewskillsignalsuppressionscanresolutionbonus
# Used by:
# Modules named like: Inverted Signal Field Projector (8 of 8)
# Skill: Signal Suppression
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    penalized = False if "skill" in context else True
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Sensor Damper",
                                  "scanResolutionBonus", container.getModifiedItemAttr("scanSkillEwStrengthBonus") * level,
                                  stackingPenalties=penalized)

########NEW FILE########
__FILENAME__ = ewskilltargetpaintingstrengthbonus
# Used by:
# Skill: Signature Focusing
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Target Painter",
                                  "signatureRadiusBonus", skill.getModifiedItemAttr("scanSkillTargetPaintStrengthBonus") * skill.level)
########NEW FILE########
__FILENAME__ = ewskilltdcapneedbonusskilllevel
# Used by:
# Implants named like: Zainou 'Gypsy' Weapon Disruption WD (6 of 6)
# Skill: Weapon Disruption
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Weapon Disruption"),
                                  "capacitorNeed", container.getModifiedItemAttr("capNeedBonus") * level)

########NEW FILE########
__FILENAME__ = ewskilltdfalloffbonus
# Used by:
# Skill: Frequency Modulation
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Tracking Disruptor",
                                  "falloff", skill.getModifiedItemAttr("falloffBonus") * skill.level)
########NEW FILE########
__FILENAME__ = ewskilltdmaxrangebonus
# Used by:
# Modules named like: Particle Dispersion Projector (8 of 8)
# Skill: Long Distance Jamming
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Tracking Disruptor",
                                  "maxRange", container.getModifiedItemAttr("rangeSkillBonus") * level,
                                  stackingPenalties = "skill" not in context)

########NEW FILE########
__FILENAME__ = ewskilltpcapneedbonusskilllevel
# Used by:
# Implants named like: Zainou 'Gypsy' Target Painting TG (6 of 6)
# Skill: Target Painting
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Target Painting"),
                                  "capacitorNeed", container.getModifiedItemAttr("capNeedBonus") * level)

########NEW FILE########
__FILENAME__ = ewskilltpfalloffbonus
# Used by:
# Skill: Frequency Modulation
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Target Painter",
                                  "falloff", skill.getModifiedItemAttr("falloffBonus") * skill.level)
########NEW FILE########
__FILENAME__ = ewskilltpmaxrangebonus
# Used by:
# Modules named like: Particle Dispersion Projector (8 of 8)
# Skill: Long Distance Jamming
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Target Painter",
                                  "maxRange", container.getModifiedItemAttr("rangeSkillBonus") * level,
                                  stackingPenalties = "skill" not in context)

########NEW FILE########
__FILENAME__ = ewskilltrackingdisruptionrangedisruptionbonus
# Used by:
# Modules named like: Tracking Diagnostic Subroutines (8 of 8)
# Skill: Turret Destabilization
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    for attr in ("maxRangeBonus", "falloffBonus"):
        fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Weapon Disruption"),
                                      attr, container.getModifiedItemAttr("scanSkillEwStrengthBonus") * level)

########NEW FILE########
__FILENAME__ = ewskilltrackingdisruptiontrackingspeedbonus
# Used by:
# Modules named like: Tracking Diagnostic Subroutines (8 of 8)
# Skill: Turret Destabilization
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Tracking Disruptor",
                                  "trackingSpeedBonus", container.getModifiedItemAttr("scanSkillEwStrengthBonus") * level)

########NEW FILE########
__FILENAME__ = ewtargetpaint
# Used by:
# Modules from group: Target Painter (9 of 9)
# Drones named like: TP (3 of 3)
type = "projected", "active"
def handler(fit, container, context):
    if "projected" in context:
        fit.ship.boostItemAttr("signatureRadius", container.getModifiedItemAttr("signatureRadiusBonus"),
                               stackingPenalties = True)

########NEW FILE########
__FILENAME__ = ewtesteffectjam
# Used by:
# Modules from group: ECM (44 of 44)
# Drones named like: EC (3 of 3)
type = "projected", "active"
def handler(fit, container, context):
    pass

########NEW FILE########
__FILENAME__ = explosivearmorcompensationhardeningbonusgrouparmorcoating
# Used by:
# Skill: Explosive Armor Compensation
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Armor Coating",
                                  "explosiveDamageResistanceBonus", skill.getModifiedItemAttr("hardeningBonus") * skill.level)
########NEW FILE########
__FILENAME__ = explosivearmorcompensationhardeningbonusgroupenergized
# Used by:
# Skill: Explosive Armor Compensation
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Armor Plating Energized",
                                  "explosiveDamageResistanceBonus", skill.getModifiedItemAttr("hardeningBonus") * skill.level)
########NEW FILE########
__FILENAME__ = explosiveshieldcompensationhardeningbonusgroupshieldamp
# Used by:
# Skill: Explosive Shield Compensation
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Shield Amplifier",
                                  "explosiveDamageResistanceBonus", skill.getModifiedItemAttr("hardeningBonus") * skill.level)
########NEW FILE########
__FILENAME__ = falloffbonuseffecthybrids
# Used by:
# Modules named like: Hybrid Ambit Extension (8 of 8)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Hybrid Weapon",
                                  "falloff", module.getModifiedItemAttr("falloffBonus"),
                                  stackingPenalties = True)
########NEW FILE########
__FILENAME__ = falloffbonuseffectlasers
# Used by:
# Modules named like: Energy Ambit Extension (8 of 8)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Energy Weapon",
                                  "falloff", module.getModifiedItemAttr("falloffBonus"),
                                  stackingPenalties = True)
########NEW FILE########
__FILENAME__ = falloffbonuseffectprojectiles
# Used by:
# Modules named like: Projectile Ambit Extension (8 of 8)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Projectile Weapon",
                                  "falloff", module.getModifiedItemAttr("falloffBonus"),
                                  stackingPenalties = True)
########NEW FILE########
__FILENAME__ = federationsetbonus3
# Used by:
# Implants named like: Spur (6 of 12)
type = "passive"
runTime = "early"
def handler(fit, implant, context):
    fit.implants.filteredItemMultiply(lambda target: target.item.requiresSkill("Cybernetics"),
                                      "scanMagnetometricStrengthPercent", implant.getModifiedItemAttr("implantSetFederationNavy"))

########NEW FILE########
__FILENAME__ = federationsetlgbonus
# Used by:
# Implants named like: Low grade Spur (6 of 6)
type = "passive"
runTime = "early"
def handler(fit, implant, context):
    fit.implants.filteredItemMultiply(lambda target: target.item.requiresSkill("Cybernetics"),
                                      "scanMagnetometricStrengthModifier", implant.getModifiedItemAttr("implantSetLGFederationNavy"))

########NEW FILE########
__FILENAME__ = fightersdmgbonusskills
# Used by:
# Skill: Fighters
type = "passive"
def handler(fit, skill, context):
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Fighters"),
                                 "damageMultiplier", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)
########NEW FILE########
__FILENAME__ = flagshipmultirelayeffect
# Used by:
# Module: Command Processor I
type = "passive"
def handler(fit, module, context):
    #Note: we increase maxGroupActive by two.
    #If we only increased it by one, we'd get the number to stay equal
    #As Comman Processors use one themselves too
    fit.modules.filteredItemIncrease(lambda mod: mod.item.group.name == "Gang Coordinator" and \
                                     "maxGroupActive" in mod.itemModifiedAttributes,
                                     "maxGroupActive", 2)
########NEW FILE########
__FILENAME__ = freighteragilitybonusa1
# Used by:
# Ship: Ark
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Freighter").level
    fit.ship.boostItemAttr("agility", ship.getModifiedItemAttr("freighterBonusA1") * level)

########NEW FILE########
__FILENAME__ = freighteragilitybonusc1
# Used by:
# Ship: Rhea
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Freighter").level
    fit.ship.boostItemAttr("agility", ship.getModifiedItemAttr("freighterBonusC1") * level)

########NEW FILE########
__FILENAME__ = freighteragilitybonusg1
# Used by:
# Ship: Anshar
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Freighter").level
    fit.ship.boostItemAttr("agility", ship.getModifiedItemAttr("freighterBonusG1") * level)

########NEW FILE########
__FILENAME__ = freighteragilitybonusm1
# Used by:
# Ship: Nomad
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Freighter").level
    fit.ship.boostItemAttr("agility", ship.getModifiedItemAttr("freighterBonusM1") * level)

########NEW FILE########
__FILENAME__ = freightercargobonusa2
# Used by:
# Variations of ship: Providence (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Freighter").level
    fit.ship.boostItemAttr("capacity", ship.getModifiedItemAttr("freighterBonusA2") * level)

########NEW FILE########
__FILENAME__ = freightercargobonusc2
# Used by:
# Variations of ship: Charon (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Freighter").level
    fit.ship.boostItemAttr("capacity", ship.getModifiedItemAttr("freighterBonusC2") * level)

########NEW FILE########
__FILENAME__ = freightercargobonusg2
# Used by:
# Variations of ship: Obelisk (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Freighter").level
    fit.ship.boostItemAttr("capacity", ship.getModifiedItemAttr("freighterBonusG2") * level)

########NEW FILE########
__FILENAME__ = freightercargobonusm2
# Used by:
# Variations of ship: Fenrir (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Freighter").level
    fit.ship.boostItemAttr("capacity", ship.getModifiedItemAttr("freighterBonusM2") * level)

########NEW FILE########
__FILENAME__ = freightermaxvelocitybonusa1
# Used by:
# Ship: Providence
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Freighter").level
    fit.ship.boostItemAttr("maxVelocity", ship.getModifiedItemAttr("freighterBonusA1") * level)

########NEW FILE########
__FILENAME__ = freightermaxvelocitybonusc1
# Used by:
# Ship: Charon
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Freighter").level
    fit.ship.boostItemAttr("maxVelocity", ship.getModifiedItemAttr("freighterBonusC1") * level)

########NEW FILE########
__FILENAME__ = freightermaxvelocitybonusg1
# Used by:
# Ship: Obelisk
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Freighter").level
    fit.ship.boostItemAttr("maxVelocity", ship.getModifiedItemAttr("freighterBonusG1") * level)

########NEW FILE########
__FILENAME__ = freightermaxvelocitybonusm1
# Used by:
# Ship: Fenrir
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Freighter").level
    fit.ship.boostItemAttr("maxVelocity", ship.getModifiedItemAttr("freighterBonusM1") * level)

########NEW FILE########
__FILENAME__ = fuelconservationcapneedbonuspostpercentcapacitorneedlocationshipmodulesrequiringafterburner
# Used by:
# Skill: Afterburner
# Skill: Fuel Conservation
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Afterburner"),
                                  "capacitorNeed", skill.getModifiedItemAttr("capNeedBonus") * skill.level)

########NEW FILE########
__FILENAME__ = fueledarmorrepair
# Used by:
# Modules from group: Fueled Armor Repairer (3 of 3)
runTime = "late"
type = "active"
def handler(fit, module, context):
    if module.charge and module.charge.name == "Nanite Repair Paste":
        module.multiplyItemAttr("armorDamageAmount", 3)
        
    amount = module.getModifiedItemAttr("armorDamageAmount")
    speed = module.getModifiedItemAttr("duration") / 1000.0
    fit.extraAttributes.increase("armorRepair", amount / speed)

########NEW FILE########
__FILENAME__ = fueledshieldboosting
# Used by:
# Modules from group: Fueled Shield Booster (4 of 4)
runTime = "late"
type = "active"
def handler(fit, module, context):
    amount = module.getModifiedItemAttr("shieldBonus")
    speed = module.getModifiedItemAttr("duration") / 1000.0
    fit.extraAttributes.increase("shieldRepair", amount / speed)

########NEW FILE########
__FILENAME__ = gangabmwdfactorboost
# Used by:
# Variations of module: Skirmish Warfare Link - Rapid Deployment I (2 of 2)
type = "gang", "active"
gangBoost = "speedFactor"
def handler(fit, module, context):
    if "gang" not in context: return
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Propulsion Module",
                                  "speedFactor", module.getModifiedItemAttr("commandBonus"),
                                  stackingPenalties = True)

########NEW FILE########
__FILENAME__ = gangarmorhardening
# Used by:
# Variations of module: Armored Warfare Link - Passive Defense I (2 of 2)
type = "gang", "active"
gangBoost = "armorResistance"
def handler(fit, module, context):
    if "gang" not in context: return
    for damageType in ("Em", "Thermal", "Explosive", "Kinetic"):
        fit.ship.boostItemAttr("armor%sDamageResonance" % damageType,
                               module.getModifiedItemAttr("commandBonus"),
                               stackingPenalties = True)

########NEW FILE########
__FILENAME__ = gangarmorrepaircapreducerselfandprojected
# Used by:
# Variations of module: Armored Warfare Link - Damage Control I (2 of 2)
type = "gang", "active"
gangBoost = "armorRepairCapacitorNeed"
def handler(fit, module, context):
    if "gang" not in context: return
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Repair Systems") or mod.item.requiresSkill("Remote Armor Repair Systems"),
                                  "capacitorNeed", module.getModifiedItemAttr("commandBonus"))

########NEW FILE########
__FILENAME__ = gangarmorrepairspeedamplifierselfandprojected
# Used by:
# Variations of module: Armored Warfare Link - Rapid Repair I (2 of 2)
type = "gang", "active"
gangBoost = "armorRepairDuration"
def handler(fit, module, context):
    if "gang" not in context: return
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Repair Systems") or mod.item.requiresSkill("Remote Armor Repair Systems"),
                                  "duration", module.getModifiedItemAttr("commandBonus"))

########NEW FILE########
__FILENAME__ = gangbonussignature
# Used by:
# Variations of module: Skirmish Warfare Link - Evasive Maneuvers I (2 of 2)
type = "gang", "active"
gangBoost = "signatureRadius"
def handler(fit, module, context):
    if "gang" not in context: return
    fit.ship.boostItemAttr("signatureRadius", module.getModifiedItemAttr("commandBonus"),
                           stackingPenalties = True)

########NEW FILE########
__FILENAME__ = ganggasharvesterandiceharvesterandmininglasercapneedbonus
# Used by:
# Variations of module: Mining Foreman Link - Harvester Capacitor Efficiency I (2 of 2)
type = "gang", "active"
gangBoost = "miningCapacitorNeed"
def handler(fit, module, context):
    if "gang" not in context: return
    groups = ("Mining Laser", "Strip Miner", "Frequency Mining Laser",
              "Ice Harvester", "Gas Cloud Harvester")
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name in groups,
                                  "capacitorNeed", module.getModifiedItemAttr("commandBonus"),
                                  stackingPenalties = True)

########NEW FILE########
__FILENAME__ = ganggasharvesterandiceharvesterandmininglaserdurationbonus
# Used by:
# Variations of module: Mining Foreman Link - Laser Optimization I (2 of 2)
type = "gang", "active"
gangBoost = "miningDuration"
def handler(fit, module, context):
    if "gang" not in context: return
    groups = ("Mining Laser", "Strip Miner", "Frequency Mining Laser",
              "Ice Harvester", "Gas Cloud Harvester")
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name in groups,
                                  "duration", module.getModifiedItemAttr("commandBonus"),
                                  stackingPenalties = True)

########NEW FILE########
__FILENAME__ = ganginformationwarfarerangebonuswithecmburst
# Used by:
# Variations of module: Information Warfare Link - Recon Operation I (2 of 2)
type = "gang", "active"
gangBoost = "electronicMaxRange"
def handler(fit, module, context):
    if "gang" not in context: return
    groups = ("Target Painter", "Tracking Disruptor", "Remote Sensor Damper", "ECM", "ECM Burst")
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name in groups,
                                  "maxRange", module.getModifiedItemAttr("commandBonus"),
                                  stackingPenalties = True)

########NEW FILE########
__FILENAME__ = ganginformationwarfaresuperiorityall
# Used by:
# Variations of module: Information Warfare Link - Electronic Superiority I (2 of 2)
type = "active"
def handler(fit, module, context):
    module.multiplyItemAttr("commandBonusTD", module.getModifiedItemAttr("commandBonusHidden"))
    module.multiplyItemAttr("commandBonusECM", module.getModifiedItemAttr("commandBonusHidden"))
    module.multiplyItemAttr("commandBonusRSD", module.getModifiedItemAttr("commandBonusHidden"))
    module.multiplyItemAttr("commandBonusTP", module.getModifiedItemAttr("commandBonusHidden"))

########NEW FILE########
__FILENAME__ = gangmininglaserandiceharvesterandgascloudharvestermaxrangebonus
# Used by:
# Variations of module: Mining Foreman Link - Mining Laser Field Enhancement I (2 of 2)
type = "gang", "active"
gangBoost = "miningMaxRange"
def handler(fit, module, context):
    if "gang" not in context: return
    groups = ("Mining Laser", "Strip Miner", "Frequency Mining Laser",
              "Ice Harvester", "Gas Cloud Harvester")
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name in groups,
                                  "maxRange", module.getModifiedItemAttr("commandBonus"),
                                  stackingPenalties = True)

########NEW FILE########
__FILENAME__ = gangpropulsionjammingboost
# Used by:
# Variations of module: Skirmish Warfare Link - Interdiction Maneuvers I (2 of 2)
type = "gang", "active"
gangBoost = "interdictionMaxRange"
def handler(fit, module, context):
    if "gang" not in context: return
    groups = ("Stasis Web","Warp Scrambler")
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name in groups,
                                  "maxRange", module.getModifiedItemAttr("commandBonus"),
                                  stackingPenalties = True)

########NEW FILE########
__FILENAME__ = gangsensorintegrity
# Used by:
# Variations of module: Information Warfare Link - Sensor Integrity I (2 of 2)
type = "gang", "active"
gangBoost = "scanTypeStrength"
def handler(fit, module, context):
    if "gang" not in context: return
    fit.ship.boostItemAttr("maxTargetRange", module.getModifiedItemAttr("commandBonus"),
                           stackingPenalties = True)
    for scanType in ("Gravimetric", "Radar", "Ladar", "Magnetometric"):
        fit.ship.boostItemAttr("scan%sStrength" % scanType,
                               module.getModifiedItemAttr("commandBonus"),
                               stackingPenalties = True)

########NEW FILE########
__FILENAME__ = gangshieldboosteandtransportercapacitorneed
# Used by:
# Variations of module: Siege Warfare Link - Shield Efficiency I (2 of 2)
type = "gang", "active"
gangBoost = "shieldRepairCapacitorNeed"
def handler(fit, module, context):
    if "gang" not in context: return
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Shield Operation") or mod.item.requiresSkill("Shield Emission Systems"),
                                  "capacitorNeed", module.getModifiedItemAttr("commandBonus"))

########NEW FILE########
__FILENAME__ = gangshieldboosterandtransporterspeed
# Used by:
# Variations of module: Siege Warfare Link - Active Shielding I (2 of 2)
type = "gang", "active"
gangBoost = "shieldRepairDuration"
def handler(fit, module, context):
    if "gang" not in context: return
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Shield Operation") or mod.item.requiresSkill("Shield Emission Systems"),
                                  "duration", module.getModifiedItemAttr("commandBonus"))

########NEW FILE########
__FILENAME__ = gangshieldhardening
# Used by:
# Variations of module: Siege Warfare Link - Shield Harmonizing I (2 of 2)
type = "gang", "active"
gangBoost = "shieldResistance"
def handler(fit, module, context):
    if "gang" not in context: return
    for damageType in ("Em", "Explosive", "Thermal", "Kinetic"):
        fit.ship.boostItemAttr("shield%sDamageResonance" % damageType,
                               module.getModifiedItemAttr("commandBonus"),
                               stackingPenalties = True)

########NEW FILE########
__FILENAME__ = gascloudharvestingmaxgroupskilllevel
# Used by:
# Skill: Gas Cloud Harvesting
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemIncrease(lambda mod: mod.item.group.name == "Gas Cloud Harvester",
                                     "maxGroupActive", skill.level)
########NEW FILE########
__FILENAME__ = gasharvestermaxrangebonus
# Used by:
# Implants named like: Low grade Harvest (5 of 6)
type = "passive"
def handler(fit, implant, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Gas Cloud Harvester",
                                  "maxRange", implant.getModifiedItemAttr("maxRangeBonus"))
########NEW FILE########
__FILENAME__ = gasharvestingcycletimemodulesrequiringgascloudharvesting
# Used by:
# Implants named like: Eifyr and Co. 'Alchemist' Gas Harvesting GH (3 of 3)
type = "passive"
def handler(fit, implant, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Gas Cloud Harvesting"),
                                  "duration", implant.getModifiedItemAttr("durationBonus"))
########NEW FILE########
__FILENAME__ = gchyieldmultiplypassive
# Used by:
# Ship: Venture
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.requiresSkill("Gas Cloud Harvesting"),
                                     "miningAmount", module.getModifiedItemAttr("miningAmountMultiplier"))
########NEW FILE########
__FILENAME__ = gunneryfalloffbonusonline
# Used by:
# Modules from group: Tracking Enhancer (17 of 17)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Gunnery"),
                                  "falloff", module.getModifiedItemAttr("falloffBonus"),
                                  stackingPenalties = True)
########NEW FILE########
__FILENAME__ = gunnerymaxrangebonusonline
# Used by:
# Modules from group: Tracking Enhancer (17 of 17)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Gunnery"),
                                  "maxRange", module.getModifiedItemAttr("maxRangeBonus"),
                                  stackingPenalties = True)
########NEW FILE########
__FILENAME__ = gunnerymaxrangefallofftrackingspeedbonus
# Used by:
# Modules from group: Tracking Computer (14 of 14)
type = "active"
def handler(fit, module, context):
    for attr in ("maxRange", "falloff", "trackingSpeed"):
        fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Gunnery"),
                                      attr, module.getModifiedItemAttr("%sBonus" % attr),
                                      stackingPenalties = True)
########NEW FILE########
__FILENAME__ = gunnerytrackingspeedbonusonline
# Used by:
# Modules from group: Tracking Enhancer (17 of 17)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Gunnery"),
                                  "trackingSpeed", module.getModifiedItemAttr("trackingSpeedBonus"),
                                  stackingPenalties = True)
########NEW FILE########
__FILENAME__ = gunneryturretspeebonuspostpercentspeedlocationshipmodulesrequiringgunnery
# Used by:
# Implants named like: Inherent Implants 'Lancer' Gunnery RF (6 of 6)
# Implant: Pashan's Turret Customization Mindlink
# Skill: Gunnery
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Gunnery"),
                                  "speed", container.getModifiedItemAttr("turretSpeeBonus") * level)

########NEW FILE########
__FILENAME__ = hackingskillvirusbonus
# Used by:
# Modules named like: Memetic Algorithm Bank (8 of 8)
# Implant: Poteque 'Prospector' Hacking HC-905
# Skill: Hacking
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemIncrease(lambda mod: mod.item.requiresSkill("Hacking"),
                                     "virusCoherence", container.getModifiedItemAttr("virusCoherenceBonus") * level)

########NEW FILE########
__FILENAME__ = hardpointmodifiereffect
# Used by:
# Subsystems from group: Engineering Systems (16 of 16)
# Subsystems from group: Offensive Systems (16 of 16)
type = "passive"
def handler(fit, module, context):
    fit.ship.increaseItemAttr("turretSlotsLeft", module.getModifiedItemAttr("turretHardPointModifier"))
    fit.ship.increaseItemAttr("launcherSlotsLeft", module.getModifiedItemAttr("launcherHardPointModifier"))
########NEW FILE########
__FILENAME__ = highspeedmanuveringcapacitorneedmultiplierpostpercentcapacitorneedlocationshipmodulesrequiringhighspeedmanuvering
# Used by:
# Implants named like: Eifyr and Co. 'Rogue' High Speed Maneuvering HS (6 of 6)
# Skill: High Speed Maneuvering
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("High Speed Maneuvering"),
                                  "capacitorNeed", container.getModifiedItemAttr("capacitorNeedMultiplier") * level)

########NEW FILE########
__FILENAME__ = hullupgradesarmorhpbonuspostpercenthplocationship
# Used by:
# Implants named like: Slave (10 of 12)
# Modules named like: Trimark Armor Pump (8 of 8)
# Implant: Low-grade Snake Epsilon
# Skill: Hull Upgrades
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.ship.boostItemAttr("armorHP", (container.getModifiedItemAttr("armorHpBonus") or 0) * level)

########NEW FILE########
__FILENAME__ = hybridweapondamagemultiply
# Used by:
# Modules from group: Magnetic Field Stabilizer (20 of 20)
# Modules named like: QA Multiship Module Players (4 of 4)
# Module: QA Damage Module
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.group.name == "Hybrid Weapon",
                                      "damageMultiplier", module.getModifiedItemAttr("damageMultiplier"),
                                      stackingPenalties = True)
########NEW FILE########
__FILENAME__ = hybridweapondamagemultiplypassive
# Used by:
# Modules named like: Hybrid Collision Accelerator (8 of 8)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.group.name == "Hybrid Weapon",
                                     "damageMultiplier", module.getModifiedItemAttr("damageMultiplier"),
                                     stackingPenalties = True)
########NEW FILE########
__FILENAME__ = hybridweaponspeedmultiply
# Used by:
# Modules from group: Magnetic Field Stabilizer (20 of 20)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.group.name == "Hybrid Weapon",
                                     "speed", module.getModifiedItemAttr("speedMultiplier"),
                                     stackingPenalties = True)
########NEW FILE########
__FILENAME__ = hybridweaponspeedmultiplypassive
# Used by:
# Modules named like: Hybrid Burst Aerator (8 of 8)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.group.name == "Hybrid Weapon",
                                     "speed", module.getModifiedItemAttr("speedMultiplier"),
                                     stackingPenalties = True)
########NEW FILE########
__FILENAME__ = iceharvestcycletimemodulesrequiringiceharvesting
# Used by:
# Implants named like: Inherent Implants 'Yeti' Ice Harvesting IH (3 of 3)
# Module: Medium Ice Harvester Accelerator I
# Skill: Ice Harvesting
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Ice Harvesting"),
                                  "duration", container.getModifiedItemAttr("iceHarvestCycleBonus") * level)

########NEW FILE########
__FILENAME__ = iceharvestcycletimemodulesrequiringiceharvestingonline
# Used by:
# Variations of module: Ice Harvester Upgrade I (6 of 6)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Ice Harvesting"),
                                  "duration", module.getModifiedItemAttr("iceHarvestCycleBonus"))
########NEW FILE########
__FILENAME__ = iceharvestercapacitorneedmultiplier
# Used by:
# Variations of ship: Procurer (2 of 2)
# Variations of ship: Retriever (2 of 2)
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.requiresSkill("Ice Harvesting"),
                                     "capacitorNeed", ship.getModifiedItemAttr("iceHarvestCycleBonus"))

########NEW FILE########
__FILENAME__ = iceharvesterdurationmultiplier
# Used by:
# Variations of ship: Procurer (2 of 2)
# Variations of ship: Retriever (2 of 2)
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.requiresSkill("Ice Harvesting"),
                                     "duration", ship.getModifiedItemAttr("iceHarvestCycleBonus"))

########NEW FILE########
__FILENAME__ = iceminercpuusagepercent
# Used by:
# Variations of module: Ice Harvester Upgrade I (6 of 6)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Ice Harvesting"),
                                  "cpu", module.getModifiedItemAttr("cpuPenaltyPercent"))
########NEW FILE########
__FILENAME__ = imperialsetbonus3
# Used by:
# Implants named like: Grail (6 of 12)
type = "passive"
runTime = "early"
def handler(fit, implant, context):
    fit.implants.filteredItemMultiply(lambda target: target.item.requiresSkill("Cybernetics"),
                                      "scanRadarStrengthPercent", implant.getModifiedItemAttr("implantSetImperialNavy"))

########NEW FILE########
__FILENAME__ = imperialsetlgbonus
# Used by:
# Implants named like: Low grade Grail (6 of 6)
type = "passive"
runTime = "early"
def handler(fit, implant, context):
    fit.implants.filteredItemMultiply(lambda target: target.item.requiresSkill("Cybernetics"),
                                      "scanRadarStrengthModifier", implant.getModifiedItemAttr("implantSetLGImperialNavy"))

########NEW FILE########
__FILENAME__ = implantarmorhpbonus2
# Used by:
# Implants named like: Inherent Implants 'Noble' Hull Upgrades HG (7 of 7)
# Implant: Genolution Core Augmentation CA-4
# Implant: Imperial Navy Modified 'Noble' Implant
# Implant: Imperial Special Ops Field Enhancer - Standard
type = "passive"
def handler(fit, implant, context):
    fit.ship.boostItemAttr("armorHP", implant.getModifiedItemAttr("armorHpBonus2"))
########NEW FILE########
__FILENAME__ = implanthardwiringabcapacitorneed
# Used by:
# Implants named like: Eifyr and Co. 'Rogue' Fuel Conservation FC (6 of 6)
type = "passive"
def handler(fit, implant, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Afterburner"),
                                  "capacitorNeed", implant.getModifiedItemAttr("capNeedBonus"))

########NEW FILE########
__FILENAME__ = implantsetwarpspeed
# Used by:
# Implants named like: Ascendancy (12 of 12)
runTime = "early"
type = "passive"
def handler(fit, implant, context):
    fit.implants.filteredItemMultiply(lambda mod: mod.item.group.name == "Cyberimplant",
                                      "WarpSBonus", implant.getModifiedItemAttr("implantSetWarpSpeed"))

########NEW FILE########
__FILENAME__ = implantvelocitybonus
# Used by:
# Implants named like: Eifyr and Co. 'Rogue' Navigation NN (6 of 6)
# Implant: Genolution Core Augmentation CA-3
# Implant: Shaqil's Speed Enhancer
type = "passive"
def handler(fit, implant, context):
    fit.ship.boostItemAttr("maxVelocity", implant.getModifiedItemAttr("implantBonusVelocity"))
########NEW FILE########
__FILENAME__ = implantvelocitybonus2
# Used by:
# Implant: Republic Special Ops Field Enhancer - Gamma
type = "passive"
def handler(fit, implant, context):
    fit.ship.boostItemAttr("maxVelocity", implant.getModifiedItemAttr("velocityBonus2"))
########NEW FILE########
__FILENAME__ = increasesignatureradiusonline
# Used by:
# Modules from group: Inertia Stabilizer (12 of 12)
type = "passive"
def handler(fit, module, context):
    fit.ship.boostItemAttr("signatureRadius", module.getModifiedItemAttr("signatureRadiusBonus"))
########NEW FILE########
__FILENAME__ = industrialcoreeffect2
# Used by:
# Module: Industrial Core I
type = "active"
runTime = "early"
def handler(fit, module, context):
    fit.extraAttributes["siege"] = True
    fit.ship.boostItemAttr("maxVelocity", module.getModifiedItemAttr("speedFactor"))
    fit.ship.multiplyItemAttr("mass", module.getModifiedItemAttr("massMultiplier"))

########NEW FILE########
__FILENAME__ = informationsquadroncommand
# Used by:
# Skill: Information Warfare Specialist
runTime = "early"
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Information Warfare Specialist"),
                                  "commandBonus", skill.getModifiedItemAttr("squadronCommandBonus") * skill.level)

########NEW FILE########
__FILENAME__ = informationsquadroncommandhidden
# Used by:
# Skill: Information Warfare Specialist
runTime = "early"
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Information Warfare Specialist"),
                                  "commandBonusHidden", skill.getModifiedItemAttr("squadronCommandBonus") * skill.level)

########NEW FILE########
__FILENAME__ = informationwarfaremindlinkhidden
# Used by:
# Implant: Caldari Navy Warfare Mindlink
# Implant: Imperial Navy Warfare Mindlink
# Implant: Information Warfare Mindlink
type = "passive"
def handler(fit, implant, context):
    fit.character.getSkill("Information Warfare").suppress()
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Information Warfare Specialist"),
                                  "commandBonusHidden", implant.getModifiedItemAttr("mindlinkBonus"))

########NEW FILE########
__FILENAME__ = interceptor2hybridtracking
# Used by:
# Ship: Taranis
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Interceptors").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Hybrid Turret"),
                                  "trackingSpeed", ship.getModifiedItemAttr("eliteBonusInterceptor2") * level)
########NEW FILE########
__FILENAME__ = interceptor2lasertracking
# Used by:
# Ship: Crusader
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Interceptors").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Energy Turret"),
                                  "trackingSpeed", ship.getModifiedItemAttr("eliteBonusInterceptor2") * level)
########NEW FILE########
__FILENAME__ = interceptor2projectiledamage
# Used by:
# Ship: Claw
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Interceptors").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Projectile Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("eliteBonusInterceptor2") * level)

########NEW FILE########
__FILENAME__ = interceptor2shieldresist
# Used by:
# Ship: Raptor
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Interceptors").level
    damageTypes = ("Em", "Explosive", "Kinetic", "Thermal")
    for damageType in damageTypes:
        fit.ship.boostItemAttr("shield{0}DamageResonance".format(damageType), ship.getModifiedItemAttr("eliteBonusInterceptor2") * level)

########NEW FILE########
__FILENAME__ = interceptor2warpscramblerange
# Used by:
# Ships from group: Interceptor (4 of 8)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Interceptors").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Warp Scrambler",
                                  "maxRange", ship.getModifiedItemAttr("eliteBonusInterceptor2") * level)
########NEW FILE########
__FILENAME__ = interceptormwdsignatureradiusbonus
# Used by:
# Ships from group: Interceptor (8 of 8)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Interceptors").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("High Speed Maneuvering"),
                                  "signatureRadiusBonus", ship.getModifiedItemAttr("eliteBonusInterceptor") * level)

########NEW FILE########
__FILENAME__ = jumpdriveskillscapacitorneedbonus
# Used by:
# Skill: Jump Drive Operation
type = "passive"
def handler(fit, skill, context):
    fit.ship.boostItemAttr("jumpDriveCapacitorNeed", skill.getModifiedItemAttr("jumpDriveCapacitorNeedBonus") * skill.level)

########NEW FILE########
__FILENAME__ = jumpdriveskillsrangebonus
# Used by:
# Skill: Jump Drive Calibration
type = "passive"
def handler(fit, skill, context):
    fit.ship.boostItemAttr("jumpDriveRange", skill.getModifiedItemAttr("jumpDriveRangeBonus") * skill.level)
########NEW FILE########
__FILENAME__ = jumpportalconsumptionbonuspercentskill
# Used by:
# Skill: Jump Portal Generation
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill(skill), "consumptionQuantity",
                                  skill.getModifiedItemAttr("consumptionQuantityBonusPercent") * skill.level)

########NEW FILE########
__FILENAME__ = kineticarmorcompensationhardeningbonusgrouparmorcoating
# Used by:
# Skill: Kinetic Armor Compensation
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Armor Coating",
                                  "kineticDamageResistanceBonus",
                                  skill.getModifiedItemAttr("hardeningBonus") * skill.level)
########NEW FILE########
__FILENAME__ = kineticarmorcompensationhardeningbonusgroupenergized
# Used by:
# Skill: Kinetic Armor Compensation
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Armor Plating Energized",
                                  "kineticDamageResistanceBonus", skill.getModifiedItemAttr("hardeningBonus") * skill.level)
########NEW FILE########
__FILENAME__ = kineticshieldcompensationhardeningbonusgroupshieldamp
# Used by:
# Skill: Kinetic Shield Compensation
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Shield Amplifier",
                                  "kineticDamageResistanceBonus",
                                  skill.getModifiedItemAttr("hardeningBonus") * skill.level)
########NEW FILE########
__FILENAME__ = largeenergyturretdamagemultiplierbonuspostpercentdamagemultiplierlocationshipmodulesrequiringlargeenergyturret
# Used by:
# Implants named like: Inherent Implants 'Lancer' Large Energy Turret LE (6 of 6)
# Implant: Pashan's Turret Handling Mindlink
# Skill: Large Energy Turret
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Energy Turret"),
                                  "damageMultiplier", container.getModifiedItemAttr("damageMultiplierBonus") * level)

########NEW FILE########
__FILENAME__ = largehybridturretdamagemultiplierbonuspostpercentdamagemultiplierlocationshipmodulesrequiringlargehybridturret
# Used by:
# Implants named like: Zainou 'Deadeye' Large Hybrid Turret LH (6 of 6)
# Skill: Large Hybrid Turret
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Hybrid Turret"),
                                  "damageMultiplier", container.getModifiedItemAttr("damageMultiplierBonus") * level)

########NEW FILE########
__FILENAME__ = largeprojectileturretdamagemultiplierbonuspostpercentdamagemultiplierlocationshipmodulesrequiringlargeprojectileturret
# Used by:
# Implants named like: Eifyr and Co. 'Gunslinger' Large Projectile Turret LP (6 of 6)
# Skill: Large Projectile Turret
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Projectile Turret"),
                                  "damageMultiplier", container.getModifiedItemAttr("damageMultiplierBonus") * level)

########NEW FILE########
__FILENAME__ = leadershipeffect
# Used by:
# Skill: Leadership
type = "gang"
gangBoost = "scanResolution"
gangBonus = "scanResolutionBonus"
def handler(fit, skill, context):
    fit.ship.boostItemAttr(gangBoost, skill.getModifiedItemAttr(gangBonus) * skill.level)

########NEW FILE########
__FILENAME__ = leech
# Used by:
# Modules from group: Energy Vampire (52 of 52)
type = "active", "projected"
runTime = "late"
def handler(fit, module, context):
    amount = module.getModifiedItemAttr("powerTransferAmount")
    time = module.getModifiedItemAttr("duration")
    if "projected" in context:
        fit.addDrain(time, amount, 0)
    elif "module" in context:
        module.itemModifiedAttributes.force("capacitorNeed", -amount)

########NEW FILE########
__FILENAME__ = longrangetargetingmaxtargetrangebonuspostpercentmaxtargetrangelocationshipgroupelectronic
# Used by:
# Implants named like: Zainou 'Gypsy' Long Range Targeting LT (6 of 6)
# Skill: Long Range Targeting
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.ship.boostItemAttr("maxTargetRange", container.getModifiedItemAttr("maxTargetRangeBonus") * level)

########NEW FILE########
__FILENAME__ = maraudermodeeffect26
# Used by:
# Module: Bastion Module I
type = "active"
runTime = "early"
def handler(fit, module, context):
    # Resistances
    for layer, attrPrefix in (('shield', 'shield'), ('armor', 'armor'), ('hull', '')):
        for damageType in ('Kinetic', 'Thermal', 'Explosive', 'Em'):
            bonus = "%s%sDamageResonance" % (attrPrefix, damageType)
            bonus = "%s%s" % (bonus[0].lower(), bonus[1:])
            booster = "%s%sDamageResonance" % (layer, damageType)
            penalize = False if layer == 'hull' else True
            fit.ship.multiplyItemAttr(bonus, module.getModifiedItemAttr(booster),
                                      stackingPenalties=penalize, penaltyGroup="preMul")

    # Turrets
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Energy Turret") or \
                                  mod.item.requiresSkill("Large Hybrid Turret") or \
                                  mod.item.requiresSkill("Large Projectile Turret"),
                                  "maxRange", module.getModifiedItemAttr("maxRangeBonus"),
                                  stackingPenalties=True)
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Energy Turret") or \
                                  mod.item.requiresSkill("Large Hybrid Turret") or \
                                  mod.item.requiresSkill("Large Projectile Turret"),
                                  "falloff", module.getModifiedItemAttr("falloffBonus"),
                                  stackingPenalties=True)

    # Missiles
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Torpedoes") or \
                                    mod.charge.requiresSkill("Cruise Missiles") or \
                                    mod.charge.requiresSkill("Heavy Missiles"),
                                    "maxVelocity", module.getModifiedItemAttr("missileVelocityBonus"))

    # Tanking
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Repair Systems") or mod.item.requiresSkill("Repair Systems"),
                                  "armorDamageAmount", module.getModifiedItemAttr("armorDamageAmountBonus"),
                                  stackingPenalties=True)
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Shield Operation") or mod.item.requiresSkill("Shield Operation"),
                                  "shieldBonus", module.getModifiedItemAttr("shieldBoostMultiplier"),
                                  stackingPenalties=True)

    # Speed penalty
    fit.ship.boostItemAttr("maxVelocity", module.getModifiedItemAttr("speedFactor"))

    # Max locked targets
    fit.ship.forceItemAttr("maxLockedTargets", module.getModifiedItemAttr("maxLockedTargets"))

    # Block Hostile ewar
    fit.ship.forceItemAttr("disallowOffensiveModifiers", module.getModifiedItemAttr("disallowOffensiveModifiers"))

########NEW FILE########
__FILENAME__ = massaddpassive
# Used by:
# Items from category: Subsystem (80 of 80)
type = "passive"
def handler(fit, module, context):
    fit.ship.increaseItemAttr("mass", module.getModifiedItemAttr("mass") or 0)

########NEW FILE########
__FILENAME__ = maxrangebonuseffecthybrids
# Used by:
# Modules named like: Hybrid Locus Coordinator (8 of 8)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Hybrid Weapon",
                                  "maxRange", module.getModifiedItemAttr("maxRangeBonus"),
                                  stackingPenalties = True)
########NEW FILE########
__FILENAME__ = maxrangebonuseffectlasers
# Used by:
# Modules named like: Energy Locus Coordinator (8 of 8)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Energy Weapon",
                                  "maxRange", module.getModifiedItemAttr("maxRangeBonus"),
                                  stackingPenalties = True)
########NEW FILE########
__FILENAME__ = maxrangebonuseffectprojectiles
# Used by:
# Modules named like: Projectile Locus Coordinator (8 of 8)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Projectile Weapon",
                                  "maxRange", module.getModifiedItemAttr("maxRangeBonus"),
                                  stackingPenalties = True)
########NEW FILE########
__FILENAME__ = maxtargetingrangebonuspostpercentpassive
# Used by:
# Modules named like: Ionic Field Projector (8 of 8)
type = "passive"
def handler(fit, module, context):
    fit.ship.boostItemAttr("maxTargetRange", module.getModifiedItemAttr("maxTargetRangeBonus"),
                              stackingPenalties = True)

########NEW FILE########
__FILENAME__ = maxtargetrangeaddpassive
# Used by:
# Subsystems from group: Electronic Systems (16 of 16)
type = "passive"
def handler(fit, module, context):
    fit.ship.increaseItemAttr("maxTargetRange", module.getModifiedItemAttr("maxTargetRange"))
########NEW FILE########
__FILENAME__ = maxtargetrangebonus
# Used by:
# Modules from group: Warp Core Stabilizer (8 of 8)
type = "passive"
def handler(fit, module, context):
    fit.ship.boostItemAttr("maxTargetRange", module.getModifiedItemAttr("maxTargetRangeBonus"),
                           stackingPenalties = True)
########NEW FILE########
__FILENAME__ = maxvelocityaddpassive
# Used by:
# Subsystems from group: Propulsion Systems (16 of 16)
type = "passive"
def handler(fit, module, context):
    fit.ship.increaseItemAttr("maxVelocity", module.getModifiedItemAttr("maxVelocity"))
########NEW FILE########
__FILENAME__ = mechanichullhpbonuspostpercenthpship
# Used by:
# Implants named like: Inherent Implants 'Noble' Mechanic MC (6 of 6)
# Skill: Mechanics
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.ship.boostItemAttr("hp", container.getModifiedItemAttr("hullHpBonus") * level)

########NEW FILE########
__FILENAME__ = mediumenergyturretdamagemultiplierbonuspostpercentdamagemultiplierlocationshipmodulesrequiringmediumenergyturret
# Used by:
# Implants named like: Inherent Implants 'Lancer' Medium Energy Turret ME (6 of 6)
# Skill: Medium Energy Turret
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Energy Turret"),
                                  "damageMultiplier", container.getModifiedItemAttr("damageMultiplierBonus") * level)

########NEW FILE########
__FILENAME__ = mediumhybridturretdamagemultiplierbonuspostpercentdamagemultiplierlocationshipmodulesrequiringmediumhybridturret
# Used by:
# Implants named like: Zainou 'Deadeye' Medium Hybrid Turret MH (6 of 6)
# Skill: Medium Hybrid Turret
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Hybrid Turret"),
                                  "damageMultiplier", container.getModifiedItemAttr("damageMultiplierBonus") * level)

########NEW FILE########
__FILENAME__ = mediumprojectileturretdamagemultiplierbonuspostpercentdamagemultiplierlocationshipmodulesrequiringmediumprojectileturret
# Used by:
# Implants named like: Eifyr and Co. 'Gunslinger' Medium Projectile Turret MP (6 of 6)
# Skill: Medium Projectile Turret
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Projectile Turret"),
                                  "damageMultiplier", container.getModifiedItemAttr("damageMultiplierBonus") * level)

########NEW FILE########
__FILENAME__ = mercoxitcrystalbonus
# Used by:
# Module: Medium Mercoxit Mining Crystal Optimization I
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Mercoxit Processing"),
                                    "specialisationAsteroidYieldMultiplier", module.getModifiedItemAttr("miningAmountBonus"))

########NEW FILE########
__FILENAME__ = microjumpdrive
# Used by:
# Module: Large Micro Jump Drive
type = "active"
def handler(fit, module, context):
    fit.ship.boostItemAttr("signatureRadius", module.getModifiedItemAttr("signatureRadiusBonusPercent"))
########NEW FILE########
__FILENAME__ = minercpuusagemultiplypercent2
# Used by:
# Variations of module: Mining Laser Upgrade I (6 of 6)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Mining"),
                                  "cpu", module.getModifiedItemAttr("cpuPenaltyPercent"))
########NEW FILE########
__FILENAME__ = minigamevirusstrengthbonus
# Used by:
# Ships from group: Covert Ops (5 of 5)
# Ships named like: Stratios (2 of 2)
# Subsystems named like: Electronics Emergent Locus Analyzer (4 of 4)
# Variations of ship: Heron (3 of 3)
# Variations of ship: Imicus (3 of 3)
# Variations of ship: Magnate (4 of 6)
# Variations of ship: Probe (3 of 3)
# Ship: Astero
# Ship: Nestor
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemIncrease(lambda mod: mod.item.requiresSkill("Hacking"),
                                     "virusStrength", container.getModifiedItemAttr("virusStrengthBonus") * level)
    fit.modules.filteredItemIncrease(lambda mod: mod.item.requiresSkill("Archaeology"),
                                     "virusStrength", container.getModifiedItemAttr("virusStrengthBonus") * level)

########NEW FILE########
__FILENAME__ = miningclouds
# Used by:
# Modules from group: Gas Cloud Harvester (5 of 5)
type = "active"
def handler(fit, module, context):
    pass

########NEW FILE########
__FILENAME__ = miningdirectorbonuscommandbonuseffective
# Used by:
# Ship: Rorqual
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Mining Director"),
                                  "commandBonus", ship.getModifiedItemAttr("commandBonusEffective"))

########NEW FILE########
__FILENAME__ = miningdroneoperationminingamountbonuspostpercentminingdroneamountpercentchar
# Used by:
# Modules named like: Drone Mining Augmentor (8 of 8)
# Skill: Drone Interfacing
# Skill: Mining Drone Operation
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.drones.filteredItemBoost(lambda drone: drone.item.group.name == "Mining Drone",
                                 "miningAmount", container.getModifiedItemAttr("miningAmountBonus") * level,
                                 stackingPenalties = "skill" not in context)

########NEW FILE########
__FILENAME__ = miningforemanmindlink
# Used by:
# Implant: Mining Foreman Mindlink
type = "passive"
def handler(fit, implant, context):
    fit.character.getSkill("Mining Foreman").suppress()
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Mining Director"),
                                  "commandBonus", implant.getModifiedItemAttr("mindlinkBonus"))
########NEW FILE########
__FILENAME__ = mininginfomultiplier
# Used by:
# Charges from group: Mining Crystal (30 of 30)
# Charges named like: Mining Crystal (32 of 32)
type = "passive"
def handler(fit, module, context):
    module.multiplyItemAttr("miningAmount", module.getModifiedChargeAttr("specialisationAsteroidYieldMultiplier"))
########NEW FILE########
__FILENAME__ = mininglaser
# Used by:
# Modules from group: Frequency Mining Laser (3 of 3)
# Modules from group: Mining Laser (17 of 17)
# Modules from group: Strip Miner (5 of 5)
type = 'active'
def handler(fit, module, context):
    # Set reload time to 1 second
    module.reloadTime = 1000

########NEW FILE########
__FILENAME__ = mininglaserrangebonus
# Used by:
# Implants named like: Low grade Harvest (5 of 6)
type = "passive"
def handler(fit, implant, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Mining Laser",
                                  "maxRange", implant.getModifiedItemAttr("maxRangeBonus"))
########NEW FILE########
__FILENAME__ = miningsquadroncommand
# Used by:
# Skill: Mining Director
runTime = "early"
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Mining Director"),
                                  "commandBonus", skill.getModifiedItemAttr("squadronCommandBonus") * skill.level)

########NEW FILE########
__FILENAME__ = miningupgradecpupenaltyreductionmodulesrequiringminingupgradepercent
# Used by:
# Implants named like: Inherent Implants 'Highwall' Mining Upgrades MU (3 of 3)
# Skill: Mining Upgrades
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Mining Upgrades"),
                                  "cpuPenaltyPercent", container.getModifiedItemAttr("miningUpgradeCPUReductionBonus") * level)

########NEW FILE########
__FILENAME__ = miningyieldgangbonusfixed
# Used by:
# Implant: Mining Foreman Mindlink
# Skill: Mining Foreman
type = "gang"
gangBoost = "miningAmount"
gangBonus = "miningAmountBonus"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Mining"),
                                  gangBoost, container.getModifiedItemAttr(gangBonus) * level)

########NEW FILE########
__FILENAME__ = miningyieldmultiplypassive
# Used by:
# Variations of ship: Procurer (2 of 2)
# Variations of ship: Retriever (2 of 2)
# Ship: Venture
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.requiresSkill("Mining"),
                                     "miningAmount", module.getModifiedItemAttr("miningAmountMultiplier"))
########NEW FILE########
__FILENAME__ = miningyieldmultiplypercent
# Used by:
# Variations of module: Mining Laser Upgrade I (6 of 6)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Mining"),
                                  "miningAmount", module.getModifiedItemAttr("miningAmountBonus"))
########NEW FILE########
__FILENAME__ = minmatarshipewtargetpaintermc1
# Used by:
# Ship: Bellicose
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Target Painter",
                                  "signatureRadiusBonus", ship.getModifiedItemAttr("shipBonusMC") * level)

########NEW FILE########
__FILENAME__ = minmatarshipewtargetpaintermc2
# Used by:
# Ship: Huginn
# Ship: Rapier
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Target Painter",
                                  "signatureRadiusBonus", ship.getModifiedItemAttr("shipBonusMC2") * level)

########NEW FILE########
__FILENAME__ = minmatarshipewtargetpaintermf2
# Used by:
# Variations of ship: Vigil (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Target Painter",
                                  "signatureRadiusBonus", ship.getModifiedItemAttr("shipBonusMF2") * level)

########NEW FILE########
__FILENAME__ = minmatarshipewtargetpainterrookie
# Used by:
# Ship: Reaper
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Target Painter",
                                  "signatureRadiusBonus", ship.getModifiedItemAttr("rookieTargetPainterStrengthBonus"))

########NEW FILE########
__FILENAME__ = missilebombardmentmaxflighttimebonuspostpercentexplosiondelayownercharmodulesrequiringmissilelauncheroperation
# Used by:
# Implants named like: Zainou 'Deadeye' Missile Bombardment MB (6 of 6)
# Modules named like: Rocket Fuel Cache Partition (8 of 8)
# Skill: Missile Bombardment
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Missile Launcher Operation"),
                                    "explosionDelay", container.getModifiedItemAttr("maxFlightTimeBonus") * level)

########NEW FILE########
__FILENAME__ = missiledmgbonus
# Used by:
# Modules from group: Ballistic Control system (21 of 21)
# Modules named like: QA Multiship Module Players (4 of 4)
type = "passive"
def handler(fit, container, context):
    for dmgType in ("em", "kinetic", "explosive", "thermal"):
        fit.modules.filteredChargeMultiply(lambda mod: mod.charge.requiresSkill("Missile Launcher Operation"),
                                    "%sDamage" % dmgType, container.getModifiedItemAttr("missileDamageMultiplierBonus"),
                                    stackingPenalties = True)
########NEW FILE########
__FILENAME__ = missiledmgbonuspassive
# Used by:
# Modules named like: Warhead Calefaction Catalyst (8 of 8)
type = "passive"
def handler(fit, container, context):
    for dmgType in ("em", "kinetic", "explosive", "thermal"):
        fit.modules.filteredChargeMultiply(lambda mod: mod.charge.requiresSkill("Missile Launcher Operation"),
                                           "%sDamage" % dmgType, container.getModifiedItemAttr("missileDamageMultiplierBonus"),
                                           stackingPenalties = True)
########NEW FILE########
__FILENAME__ = missileemdmgbonus
# Used by:
# Skills named like: Missiles (5 of 7)
# Skill: Rockets
# Skill: Torpedoes
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill(skill),
                                    "emDamage", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)

########NEW FILE########
__FILENAME__ = missileemdmgbonuscruise3
# Used by:
# Implants named like: Zainou 'Snapshot' Cruise Missiles CM (6 of 6)
type = "passive"
def handler(fit, implant, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Cruise Missiles"),
                                    "emDamage", implant.getModifiedItemAttr("damageMultiplierBonus"))

########NEW FILE########
__FILENAME__ = missileemdmgbonusham
# Used by:
# Implants named like: Zainou 'Snapshot' Heavy Assault Missiles AM (6 of 6)
type = "passive"
def handler(fit, implant, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Assault Missiles"),
                                    "emDamage", implant.getModifiedItemAttr("damageMultiplierBonus"))

########NEW FILE########
__FILENAME__ = missileemdmgbonusheavy
# Used by:
# Implants named like: Zainou 'Snapshot' Heavy Missiles HM (6 of 6)
type = "passive"
def handler(fit, implant, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Missiles"),
                                    "emDamage", implant.getModifiedItemAttr("damageMultiplierBonus"))

########NEW FILE########
__FILENAME__ = missileemdmgbonusrocket
# Used by:
# Implants named like: Zainou 'Snapshot' Rockets RD (6 of 6)
type = "passive"
def handler(fit, implant, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Rockets"),
                                    "emDamage", implant.getModifiedItemAttr("damageMultiplierBonus"))

########NEW FILE########
__FILENAME__ = missileemdmgbonusstandard
# Used by:
# Implants named like: Zainou 'Snapshot' Light Missiles LM (6 of 6)
type = "passive"
def handler(fit, implant, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Light Missiles"),
                                    "emDamage", implant.getModifiedItemAttr("damageMultiplierBonus"))

########NEW FILE########
__FILENAME__ = missileemdmgbonustorpedo
# Used by:
# Implants named like: Zainou 'Snapshot' Torpedoes TD (6 of 6)
type = "passive"
def handler(fit, implant, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Torpedoes"),
                                    "emDamage", implant.getModifiedItemAttr("damageMultiplierBonus"))

########NEW FILE########
__FILENAME__ = missileexplosivedmgbonus
# Used by:
# Skills named like: Missiles (5 of 7)
# Skill: Rockets
# Skill: Torpedoes
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill(skill),
                                    "explosiveDamage", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)

########NEW FILE########
__FILENAME__ = missileexplosivedmgbonuscruise3
# Used by:
# Implants named like: Zainou 'Snapshot' Cruise Missiles CM (6 of 6)
type = "passive"
def handler(fit, container, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Cruise Missiles"),
                                    "explosiveDamage",container.getModifiedItemAttr("damageMultiplierBonus"))

########NEW FILE########
__FILENAME__ = missileexplosivedmgbonusham
# Used by:
# Implants named like: Zainou 'Snapshot' Heavy Assault Missiles AM (6 of 6)
type = "passive"
def handler(fit, container, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Assault Missiles"),
                                    "explosiveDamage", container.getModifiedItemAttr("damageMultiplierBonus"))

########NEW FILE########
__FILENAME__ = missileexplosivedmgbonusheavy
# Used by:
# Implants named like: Zainou 'Snapshot' Heavy Missiles HM (6 of 6)
type = "passive"
def handler(fit, container, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Missiles"),
                                    "explosiveDamage", container.getModifiedItemAttr("damageMultiplierBonus"))

########NEW FILE########
__FILENAME__ = missileexplosivedmgbonusrocket
# Used by:
# Implants named like: Zainou 'Snapshot' Rockets RD (6 of 6)
type = "passive"
def handler(fit, container, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Rockets"),
                                    "explosiveDamage", container.getModifiedItemAttr("damageMultiplierBonus"))

########NEW FILE########
__FILENAME__ = missileexplosivedmgbonusstandard
# Used by:
# Implants named like: Zainou 'Snapshot' Light Missiles LM (6 of 6)
type = "passive"
def handler(fit, container, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Light Missiles"),
                                    "explosiveDamage", container.getModifiedItemAttr("damageMultiplierBonus"))

########NEW FILE########
__FILENAME__ = missileexplosivedmgbonustorpedo
# Used by:
# Implants named like: Zainou 'Snapshot' Torpedoes TD (6 of 6)
type = "passive"
def handler(fit, container, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Torpedoes"),
                                    "explosiveDamage", container.getModifiedItemAttr("damageMultiplierBonus"))

########NEW FILE########
__FILENAME__ = missilekineticdmgbonus2
# Used by:
# Skills named like: Missiles (5 of 7)
# Skill: Rockets
# Skill: Torpedoes
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill(skill),
                                    "kineticDamage", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)

########NEW FILE########
__FILENAME__ = missilekineticdmgbonuscruise3
# Used by:
# Implants named like: Zainou 'Snapshot' Cruise Missiles CM (6 of 6)
type = "passive"
def handler(fit, container, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Cruise Missiles"),
                                    "kineticDamage", container.getModifiedItemAttr("damageMultiplierBonus"))

########NEW FILE########
__FILENAME__ = missilekineticdmgbonusham
# Used by:
# Implants named like: Zainou 'Snapshot' Heavy Assault Missiles AM (6 of 6)
type = "passive"
def handler(fit, container, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Assault Missiles"),
                                    "kineticDamage", container.getModifiedItemAttr("damageMultiplierBonus"))

########NEW FILE########
__FILENAME__ = missilekineticdmgbonusheavy
# Used by:
# Implants named like: Zainou 'Snapshot' Heavy Missiles HM (6 of 6)
type = "passive"
def handler(fit, container, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Missiles"),
                                    "kineticDamage", container.getModifiedItemAttr("damageMultiplierBonus"))

########NEW FILE########
__FILENAME__ = missilekineticdmgbonusrocket
# Used by:
# Implants named like: Zainou 'Snapshot' Rockets RD (6 of 6)
type = "passive"
def handler(fit, container, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Rockets"),
                                    "kineticDamage", container.getModifiedItemAttr("damageMultiplierBonus"))

########NEW FILE########
__FILENAME__ = missilekineticdmgbonusstandard
# Used by:
# Implants named like: Zainou 'Snapshot' Light Missiles LM (6 of 6)
type = "passive"
def handler(fit, container, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Light Missiles"),
                                    "kineticDamage", container.getModifiedItemAttr("damageMultiplierBonus"))

########NEW FILE########
__FILENAME__ = missilekineticdmgbonustorpedo
# Used by:
# Implants named like: Zainou 'Snapshot' Torpedoes TD (6 of 6)
type = "passive"
def handler(fit, container, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Torpedoes"),
                                    "kineticDamage", container.getModifiedItemAttr("damageMultiplierBonus"))

########NEW FILE########
__FILENAME__ = missilelauncherspeedmultiplier
# Used by:
# Modules from group: Ballistic Control system (21 of 21)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.requiresSkill("Missile Launcher Operation"),
                                     "speed", module.getModifiedItemAttr("speedMultiplier"),
                                     stackingPenalties = True)

########NEW FILE########
__FILENAME__ = missilelauncherspeedmultiplierpassive
# Used by:
# Modules named like: Bay Loading Accelerator (8 of 8)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.requiresSkill("Missile Launcher Operation"),
                                     "speed", module.getModifiedItemAttr("speedMultiplier"),
                                     stackingPenalties = True)

########NEW FILE########
__FILENAME__ = missileskillaoecloudsizebonus
# Used by:
# Implants named like: Zainou 'Deadeye' Guided Missile Precision GP (6 of 6)
# Modules named like: Warhead Rigor Catalyst (8 of 8)
# Skill: Guided Missile Precision
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Light Missiles") or \
                                                mod.charge.requiresSkill("Rockets") or \
                                                mod.charge.requiresSkill("Heavy Missiles") or \
                                                mod.charge.requiresSkill("Heavy Assault Missiles") or \
                                                mod.charge.requiresSkill("Cruise Missiles") or \
                                                mod.charge.requiresSkill("Torpedoes"),
                                    "aoeCloudSize", container.getModifiedItemAttr("aoeCloudSizeBonus") * level,
                                    stackingPenalties = False)

########NEW FILE########
__FILENAME__ = missileskillaoecloudsizebonusallincludingcapitals
# Used by:
# Implants named like: Crash Booster (4 of 4)
type = "passive"
def handler(fit, implant, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Missile Launcher Operation"),
                                    "aoeCloudSize", implant.getModifiedItemAttr("aoeCloudSizeBonus"))

########NEW FILE########
__FILENAME__ = missileskillaoevelocitybonus
# Used by:
# Implants named like: Zainou 'Deadeye' Target Navigation Prediction TN (6 of 6)
# Modules named like: Warhead Flare Catalyst (8 of 8)
# Skill: Target Navigation Prediction
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Missile Launcher Operation"),
                                    "aoeVelocity", container.getModifiedItemAttr("aoeVelocityBonus") * level,
                                    stackingPenalties = "skill" not in context and "implant" not in context)

########NEW FILE########
__FILENAME__ = missileskillfofaoecloudsizebonus
# Used by:
# Implants named like: Zainou 'Snapshot' FOF Explosion Radius FR (6 of 6)
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("FoF Missiles"),
                                    "aoeCloudSize", container.getModifiedItemAttr("aoeCloudSizeBonus") * level)

########NEW FILE########
__FILENAME__ = missileskillmissileprojectilevelocitybonus
# Used by:
# Implants named like: Zainou 'Deadeye' Missile Projection MP (6 of 6)
# Modules named like: Hydraulic Bay Thrusters (8 of 8)
# Skill: Missile Projection
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Missile Launcher Operation"),
                                    "maxVelocity", container.getModifiedItemAttr("speedFactor") * level,
                                    stackingPenalties = "skill" not in context and "implant" not in context)

########NEW FILE########
__FILENAME__ = missileskillrapidlauncherrof
# Used by:
# Implants named like: Cerebral Accelerator (3 of 3)
# Implants named like: Zainou 'Deadeye' Rapid Launch RL (6 of 6)
# Implant: Whelan Machorin's Ballistic Smartlink
# Skill: Missile Launcher Operation
# Skill: Rapid Launch
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Missile Launcher Operation"),
                                    "speed", container.getModifiedItemAttr("rofBonus") * level)

########NEW FILE########
__FILENAME__ = missileskillwarheadupgradesemdamagebonus
# Used by:
# Skill: Warhead Upgrades
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Missile Launcher Operation"),
                                    "emDamage", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)
########NEW FILE########
__FILENAME__ = missileskillwarheadupgradesexplosivedamagebonus
# Used by:
# Skill: Warhead Upgrades
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Missile Launcher Operation"),
                                    "explosiveDamage", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)
########NEW FILE########
__FILENAME__ = missileskillwarheadupgradeskineticdamagebonus
# Used by:
# Skill: Warhead Upgrades
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Missile Launcher Operation"),
                                    "kineticDamage", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)
########NEW FILE########
__FILENAME__ = missileskillwarheadupgradesthermaldamagebonus
# Used by:
# Skill: Warhead Upgrades
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Missile Launcher Operation"),
                                    "thermalDamage", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)
########NEW FILE########
__FILENAME__ = missilethermaldmgbonus
# Used by:
# Skills named like: Missiles (5 of 7)
# Skill: Rockets
# Skill: Torpedoes
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill(skill),
                                    "thermalDamage", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)

########NEW FILE########
__FILENAME__ = missilethermaldmgbonuscruise3
# Used by:
# Implants named like: Zainou 'Snapshot' Cruise Missiles CM (6 of 6)
type = "passive"
def handler(fit, container, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Cruise Missiles"),
                                    "thermalDamage", container.getModifiedItemAttr("damageMultiplierBonus"))

########NEW FILE########
__FILENAME__ = missilethermaldmgbonusham
# Used by:
# Implants named like: Zainou 'Snapshot' Heavy Assault Missiles AM (6 of 6)
type = "passive"
def handler(fit, container, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Assault Missiles"),
                                    "thermalDamage", container.getModifiedItemAttr("damageMultiplierBonus"))

########NEW FILE########
__FILENAME__ = missilethermaldmgbonusheavy
# Used by:
# Implants named like: Zainou 'Snapshot' Heavy Missiles HM (6 of 6)
type = "passive"
def handler(fit, container, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Missiles"),
                                    "thermalDamage", container.getModifiedItemAttr("damageMultiplierBonus"))

########NEW FILE########
__FILENAME__ = missilethermaldmgbonusrocket
# Used by:
# Implants named like: Zainou 'Snapshot' Rockets RD (6 of 6)
type = "passive"
def handler(fit, container, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Rockets"),
                                    "thermalDamage", container.getModifiedItemAttr("damageMultiplierBonus"))

########NEW FILE########
__FILENAME__ = missilethermaldmgbonusstandard
# Used by:
# Implants named like: Zainou 'Snapshot' Light Missiles LM (6 of 6)
type = "passive"
def handler(fit, container, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Light Missiles"),
                                    "thermalDamage", container.getModifiedItemAttr("damageMultiplierBonus"))

########NEW FILE########
__FILENAME__ = missilethermaldmgbonustorpedo
# Used by:
# Implants named like: Zainou 'Snapshot' Torpedoes TD (6 of 6)
type = "passive"
def handler(fit, container, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Torpedoes"),
                                    "thermalDamage", container.getModifiedItemAttr("damageMultiplierBonus"))

########NEW FILE########
__FILENAME__ = missilevelocitybonusdefender
# Used by:
# Implants named like: Zainou 'Snapshot' Defender Missiles DM (6 of 6)
type = "passive"
def handler(fit, container, context):
    fit.modules.filteredChargeMultiply(lambda mod: mod.charge.requiresSkill("Defender Missiles"),
                                       "maxVelocity", container.getModifiedItemAttr("missileVelocityBonus"))
########NEW FILE########
__FILENAME__ = modifyactivearmorresonancepostpercent
# Used by:
# Modules from group: Armor Hardener (156 of 156)
type = "active"
def handler(fit, module, context):
    for damageType in ("kinetic", "thermal", "explosive", "em"):
        fit.ship.boostItemAttr("armor%sDamageResonance" % damageType.capitalize(),
                               module.getModifiedItemAttr("%sDamageResistanceBonus" % damageType),
                               stackingPenalties = True)

########NEW FILE########
__FILENAME__ = modifyactiveshieldresonancepostpercent
# Used by:
# Modules from group: Shield Hardener (97 of 97)
type = "active"
def handler(fit, module, context):
    for damageType in ("kinetic", "thermal", "explosive", "em"):
        fit.ship.boostItemAttr("shield" + damageType.capitalize() + "DamageResonance",
                               module.getModifiedItemAttr(damageType + "DamageResistanceBonus"),
                               stackingPenalties = True)

########NEW FILE########
__FILENAME__ = modifyarmorresonancepassivepreassignment
# Used by:
# Subsystems from group: Defensive Systems (16 of 16)
type = "passive"
def handler(fit, module, context):
    for type in ("Em", "Explosive", "Kinetic", "Thermal"):
        fit.ship.preAssignItemAttr("armor{0}DamageResonance".format(type), module.getModifiedItemAttr("passiveArmor{0}DamageResonance".format(type)))

########NEW FILE########
__FILENAME__ = modifyarmorresonancepostpercent
# Used by:
# Modules from group: Armor Coating (202 of 202)
# Modules from group: Armor Plating Energized (187 of 187)
type = "passive"
def handler(fit, module, context):
    for type in ("kinetic", "thermal", "explosive", "em"):
        fit.ship.boostItemAttr("armor%sDamageResonance" % type.capitalize(),
                               module.getModifiedItemAttr("%sDamageResistanceBonus" % type),
                               stackingPenalties = True)
########NEW FILE########
__FILENAME__ = modifyarmorresonancepostpercentpassive
# Used by:
# Modules named like: Anti Pump (32 of 32)
type = "passive"
def handler(fit, module, context):
    for type in ("kinetic", "thermal", "explosive", "em"):
        fit.ship.boostItemAttr("armor" + type.capitalize() + "DamageResonance",
                               module.getModifiedItemAttr(type + "DamageResistanceBonus") or 0,
                               stackingPenalties = True)

########NEW FILE########
__FILENAME__ = modifyboostereffectchancewithboosterchancebonuspostpercent
# Used by:
# Implants named like: Eifyr and Co. 'Alchemist' Neurotoxin Recovery NR (2 of 2)
# Skill: Neurotoxin Recovery
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    for i in xrange(5):
        attr = "boosterEffectChance{0}".format(i+1)
        fit.boosters.filteredItemBoost(lambda booster: attr in booster.itemModifiedAttributes,
                                       attr, container.getModifiedItemAttr("boosterChanceBonus") * level)

########NEW FILE########
__FILENAME__ = modifymaxvelocityofshiponline
# Used by:
# Modules from group: Reinforced Bulkhead (12 of 12)
type = "passive"
def handler(fit, module, context):
    fit.ship.multiplyItemAttr("maxVelocity", module.getModifiedItemAttr("maxVelocityBonus"),
                              stackingPenalties = True)
########NEW FILE########
__FILENAME__ = modifymaxvelocityofshippassive
# Used by:
# Modules from group: Expanded Cargohold (13 of 13)
type = "passive"
def handler(fit, module, context):
    fit.ship.multiplyItemAttr("maxVelocity", module.getModifiedItemAttr("maxVelocityBonus"),
                              stackingPenalties = True)
########NEW FILE########
__FILENAME__ = modifypowerrechargerate
# Used by:
# Modules from group: Capacitor Flux Coil (12 of 12)
# Modules from group: Capacitor Power Relay (26 of 26)
# Modules from group: Capacitor Recharger (25 of 25)
# Modules from group: Power Diagnostic System (31 of 31)
# Modules from group: Reactor Control Unit (28 of 28)
# Modules from group: Shield Flux Coil (11 of 11)
# Modules from group: Shield Power Relay (11 of 11)
type = "passive"
def handler(fit, module, context):
    fit.ship.multiplyItemAttr("rechargeRate", module.getModifiedItemAttr("capacitorRechargeRateMultiplier"))
########NEW FILE########
__FILENAME__ = modifyshieldrechargerate
# Used by:
# Modules from group: Capacitor Flux Coil (12 of 12)
# Modules from group: Capacitor Power Relay (26 of 26)
# Modules from group: Power Diagnostic System (31 of 31)
# Modules from group: Reactor Control Unit (28 of 28)
# Modules from group: Shield Flux Coil (11 of 11)
# Modules from group: Shield Recharger (6 of 6)
# Modules named like: QA Multiship Module Players (4 of 4)
type = "passive"
def handler(fit, module, context):
    fit.ship.multiplyItemAttr("shieldRechargeRate", module.getModifiedItemAttr("shieldRechargeRateMultiplier") or 1)

########NEW FILE########
__FILENAME__ = modifyshieldrechargeratepassive
# Used by:
# Modules named like: Processor Overclocking Unit (8 of 8)
type = "passive"
def handler(fit, module, context):
    fit.ship.multiplyItemAttr("shieldRechargeRate", module.getModifiedItemAttr("shieldRechargeRateMultiplier"))

########NEW FILE########
__FILENAME__ = modifyshieldresonancepassivepreassignment
# Used by:
# Subsystems from group: Defensive Systems (16 of 16)
type = "passive"
def handler(fit, module, context):
    for type in ("Em", "Explosive", "Kinetic", "Thermal"):
        fit.ship.preAssignItemAttr("shield{0}DamageResonance".format(type), module.getModifiedItemAttr("passiveShield{0}DamageResonance".format(type)))

########NEW FILE########
__FILENAME__ = modifyshieldresonancepostpercent
# Used by:
# Modules from group: Shield Amplifier (88 of 88)
type = "passive"
def handler(fit, module, context):
    for type in ("kinetic", "thermal", "explosive", "em"):
        fit.ship.boostItemAttr("shield%sDamageResonance" % type.capitalize(),
                               module.getModifiedItemAttr("%sDamageResistanceBonus" % type),
                               stackingPenalties = True)
########NEW FILE########
__FILENAME__ = modifyshieldresonancepostpercentpassive
# Used by:
# Modules named like: Anti Screen Reinforcer (32 of 32)
type = "passive"
def handler(fit, module, context):
    for type in ("kinetic", "thermal", "explosive", "em"):
        fit.ship.boostItemAttr("shield" + type.capitalize() + "DamageResonance",
                               module.getModifiedItemAttr(type + "DamageResistanceBonus") or 0,
                               stackingPenalties = True)

########NEW FILE########
__FILENAME__ = modifyshipagilitypassivepreassignment
# Used by:
# Subsystems from group: Propulsion Systems (16 of 16)
runTime = "early"
type = "passive"
def handler(fit, module, context):
    fit.ship.preAssignItemAttr("agility", module.getModifiedItemAttr("agility"))

########NEW FILE########
__FILENAME__ = mwdsignatureradiusrolebonus
# Used by:
# Ships from group: Assault Frigate (8 of 12)
# Ships from group: Heavy Assault Cruiser (8 of 11)
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("High Speed Maneuvering"),
                                  "signatureRadiusBonus", ship.getModifiedItemAttr("MWDSignatureRadiusBonus"))

########NEW FILE########
__FILENAME__ = navigationvelocitybonuspostpercentmaxvelocitylocationship
# Used by:
# Implant: Low-grade Snake Alpha
type = "passive"
def handler(fit, implant, context):
    fit.ship.boostItemAttr("maxVelocity", implant.getModifiedItemAttr("velocityBonus"))
########NEW FILE########
__FILENAME__ = navigationvelocitybonuspostpercentmaxvelocityship
# Used by:
# Implants named like: Snake (11 of 12)
# Modules named like: Auxiliary Thrusters (8 of 8)
# Implant: Quafe Zero
# Skill: Navigation
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    amount = container.getModifiedItemAttr("velocityBonus") or 0
    fit.ship.boostItemAttr("maxVelocity", amount * level,
                           stackingPenalties = "skill" not in context and "implant" not in context and "booster" not in context)

########NEW FILE########
__FILENAME__ = neutattackreflect
# Used by:
# Modules from group: Capacitor Battery (27 of 27)
type = "passive"
def handler(fit, module, context):
    fit.ship.boostItemAttr("neutReflector", module.getModifiedItemAttr("capAttackReflector"),
                           stackingPenalties = True)

########NEW FILE########
__FILENAME__ = neutreflectamount
# Used by:
# Modules from group: Capacitor Battery (27 of 27)
type = "passive"
def handler(fit, module, context):
    fit.ship.boostItemAttr("neutReflectAmount", module.getModifiedItemAttr("neutReflectAmountBonus"))

########NEW FILE########
__FILENAME__ = nosattackreflect
# Used by:
# Modules from group: Capacitor Battery (27 of 27)
type = "passive"
def handler(fit, module, context):
    fit.ship.boostItemAttr("nosReflector", module.getModifiedItemAttr("capAttackReflector"),
                           stackingPenalties = True)

########NEW FILE########
__FILENAME__ = nosreflectamount
# Used by:
# Modules from group: Capacitor Battery (27 of 27)
type = "passive"
def handler(fit, module, context):
    fit.ship.boostItemAttr("nosReflectAmount", module.getModifiedItemAttr("nosReflectAmountBonus"))

########NEW FILE########
__FILENAME__ = offensivedefensivereduction
# Used by:
# Celestials named like: Incursion ship attributes effects (3 of 3)
runTime = "early"
type = ("projected", "offline")
def handler(fit, beacon, context):
    damages = ("em", "thermal", "kinetic", "explosive")
    for damage in damages:
        # Nerf missile damage
        fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Missile Launcher Operation"),
                                        "{0}Damage".format(damage), beacon.getModifiedItemAttr("systemEffectDamageReduction"))
        # Nerf smartbomb damage
        fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Smart Bomb",
                                      "{0}Damage".format(damage), beacon.getModifiedItemAttr("systemEffectDamageReduction"))
        # Nerf armor resistances
        fit.ship.boostItemAttr("armor{0}DamageResonance".format(damage.capitalize()),
                               beacon.getModifiedItemAttr("armor{0}DamageResistanceBonus".format(damage.capitalize())))
        # Nerf shield resistances
        fit.ship.boostItemAttr("shield{0}DamageResonance".format(damage.capitalize()),
                               beacon.getModifiedItemAttr("shield{0}DamageResistanceBonus".format(damage.capitalize())))
    # Nerf drone damage output
    fit.drones.filteredItemBoost(lambda drone: True,
                                 "damageMultiplier", beacon.getModifiedItemAttr("systemEffectDamageReduction"))
    # Nerf turret damage output
    fit.modules.filteredItemBoost(lambda module: module.item.requiresSkill("Gunnery"),
                                  "damageMultiplier", beacon.getModifiedItemAttr("systemEffectDamageReduction"))

########NEW FILE########
__FILENAME__ = orecapitalshipshieldtransferrange
# Used by:
# Ship: Rorqual
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Capital Industrial Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Shield Emission Systems"),
                                  "shieldTransferRange", ship.getModifiedItemAttr("shipBonusORECapital3") * level)

########NEW FILE########
__FILENAME__ = overloadrofbonus
# Used by:
# Modules from group: Energy Weapon (100 of 183)
# Modules from group: Hybrid Weapon (110 of 199)
# Modules from group: Missile Launcher Citadel (4 of 4)
# Modules from group: Missile Launcher Heavy (12 of 12)
# Modules from group: Missile Launcher Rocket (14 of 14)
# Modules from group: Projectile Weapon (60 of 143)
# Modules named like: Launcher (124 of 137)
type = "overheat"
def handler(fit, module, context):
    module.boostItemAttr("speed", module.getModifiedItemAttr("overloadRofBonus"))

########NEW FILE########
__FILENAME__ = overloadselfarmordamageamountdurationbonus
# Used by:
# Modules from group: Armor Repair Unit (100 of 100)
# Modules from group: Fueled Armor Repairer (3 of 3)
type = "overheat"
def handler(fit, module, context):
    module.boostItemAttr("duration", module.getModifiedItemAttr("overloadSelfDurationBonus"))
    module.boostItemAttr("armorDamageAmount", module.getModifiedItemAttr("overloadArmorDamageAmount"))
########NEW FILE########
__FILENAME__ = overloadselfdamagebonus
# Used by:
# Modules from group: Energy Weapon (83 of 183)
# Modules from group: Hybrid Weapon (89 of 199)
# Modules from group: Projectile Weapon (83 of 143)
type = "overheat"
def handler(fit, module, context):
    module.boostItemAttr("damageMultiplier", module.getModifiedItemAttr("overloadDamageModifier"))
########NEW FILE########
__FILENAME__ = overloadselfdurationbonus
# Used by:
# Modules from group: Capacitor Booster (54 of 54)
# Modules from group: Energy Destabilizer (41 of 41)
# Modules from group: Energy Vampire (52 of 52)
# Modules from group: Hull Repair Unit (21 of 21)
# Modules from group: Remote Armor Repairer (38 of 38)
# Modules from group: Remote Capacitor Transmitter (38 of 38)
# Modules from group: Remote Shield Booster (39 of 39)
# Modules from group: Smart Bomb (118 of 118)
# Module: QA Remote Armor Repair System - 5 Players
# Module: QA Shield Transporter - 5 Players
# Module: Reactive Armor Hardener
# Module: Target Spectrum Breaker
type = "overheat"
def handler(fit, module, context):
    module.boostItemAttr("duration", module.getModifiedItemAttr("overloadSelfDurationBonus") or 0)

########NEW FILE########
__FILENAME__ = overloadselfeccmstrenghtbonus
# Used by:
# Modules from group: ECCM (44 of 44)
# Modules from group: Projected ECCM (7 of 7)
type = "overheat"
def handler(fit, module, context):
    for scanType in ("Gravimetric", "Magnetometric", "Radar", "Ladar"):
        module.boostItemAttr("scan%sStrengthPercent" % scanType,
                             module.getModifiedItemAttr("overloadECCMStrenghtBonus"))

########NEW FILE########
__FILENAME__ = overloadselfecmstrenghtbonus
# Used by:
# Modules from group: ECM (44 of 44)
# Modules from group: ECM Burst (7 of 7)
type = "overheat"
def handler(fit, module, context):
    for scanType in ("Gravimetric", "Magnetometric", "Radar", "Ladar"):
        module.boostItemAttr("scan{0}StrengthBonus".format(scanType),
                             module.getModifiedItemAttr("overloadECMStrengthBonus"),
                             stackingPenalties = True)

########NEW FILE########
__FILENAME__ = overloadselfemhardeningbonus
# Used by:
# Variations of module: Armor EM Hardener I (39 of 39)
# Variations of module: EM Ward Field I (19 of 19)
# Module: Civilian EM Ward Field
type = "overheat"
def handler(fit, module, context):
    module.boostItemAttr("emDamageResistanceBonus", module.getModifiedItemAttr("overloadHardeningBonus"))
########NEW FILE########
__FILENAME__ = overloadselfexplosivehardeningbonus
# Used by:
# Variations of module: Armor Explosive Hardener I (39 of 39)
# Variations of module: Explosive Deflection Field I (19 of 19)
# Module: Civilian Explosive Deflection Field
type = "overheat"
def handler(fit, module, context):
    module.boostItemAttr("explosiveDamageResistanceBonus", module.getModifiedItemAttr("overloadHardeningBonus"))
########NEW FILE########
__FILENAME__ = overloadselfhardeninginvulnerabilitybonus
# Used by:
# Variations of module: Adaptive Invulnerability Field I (17 of 17)
type = "overheat"
def handler(fit, module, context):
    for type in ("kinetic", "thermal", "explosive", "em"):
        module.boostItemAttr("%sDamageResistanceBonus" % type,
                             module.getModifiedItemAttr("overloadHardeningBonus"))

########NEW FILE########
__FILENAME__ = overloadselfkinetichardeningbonus
# Used by:
# Variations of module: Armor Kinetic Hardener I (39 of 39)
# Variations of module: Kinetic Deflection Field I (19 of 19)
# Module: Civilian Kinetic Deflection Field
type = "overheat"
def handler(fit, module, context):
    module.boostItemAttr("kineticDamageResistanceBonus", module.getModifiedItemAttr("overloadHardeningBonus"))
########NEW FILE########
__FILENAME__ = overloadselfpainterbonus
# Used by:
# Modules from group: Target Painter (9 of 9)
type = "overheat"
def handler(fit, module, context):
    module.boostItemAttr("signatureRadiusBonus", module.getModifiedItemAttr("overloadPainterStrengthBonus") or 0)

########NEW FILE########
__FILENAME__ = overloadselfrangebonus
# Used by:
# Modules from group: Stasis Web (19 of 19)
# Modules from group: Warp Scrambler (38 of 39)
type = "overheat"
def handler(fit, module, context):
    module.boostItemAttr("maxRange", module.getModifiedItemAttr("overloadRangeBonus"),
                         stackingPenalties = True)
########NEW FILE########
__FILENAME__ = overloadselfsensormodulebonus
# Used by:
# Modules from group: Remote Sensor Booster (8 of 8)
# Modules from group: Remote Sensor Damper (9 of 9)
# Modules from group: Sensor Booster (12 of 12)
type = "overheat"
def handler(fit, module, context):
    module.boostItemAttr("maxTargetRangeBonus", module.getModifiedItemAttr("overloadSensorModuleStrengthBonus"))
    module.boostItemAttr("scanResolutionBonus", module.getModifiedItemAttr("overloadSensorModuleStrengthBonus"),
                         stackingPenalties=True)

########NEW FILE########
__FILENAME__ = overloadselfshieldbonusdurationbonus
# Used by:
# Modules from group: Fueled Shield Booster (4 of 4)
# Modules from group: Shield Booster (87 of 87)
type = "overheat"
def handler(fit, module, context):
    module.boostItemAttr("duration", module.getModifiedItemAttr("overloadSelfDurationBonus"))
    module.boostItemAttr("shieldBonus", module.getModifiedItemAttr("overloadShieldBonus"))
    
########NEW FILE########
__FILENAME__ = overloadselfspeedbonus
# Used by:
# Modules from group: Propulsion Module (107 of 107)
type = "overheat"
def handler(fit, module, context):
    module.boostItemAttr("speedFactor", module.getModifiedItemAttr("overloadSpeedFactorBonus"))
########NEW FILE########
__FILENAME__ = overloadselfthermalhardeningbonus
# Used by:
# Variations of module: Armor Thermic Hardener I (39 of 39)
# Variations of module: Thermic Dissipation Field I (19 of 19)
# Module: Civilian Thermic Dissipation Field
type = "overheat"
def handler(fit, module, context):
    module.boostItemAttr("thermalDamageResistanceBonus", module.getModifiedItemAttr("overloadHardeningBonus"))
########NEW FILE########
__FILENAME__ = overloadselftrackingmodulebonus
# Used by:
# Modules from group: Drone Tracking Modules (7 of 7)
# Modules from group: Remote Tracking Computer (10 of 10)
# Modules from group: Tracking Computer (14 of 14)
# Modules from group: Tracking Disruptor (10 of 10)
type = "overheat"
def handler(fit, module, context):
    module.boostItemAttr("maxRangeBonus", module.getModifiedItemAttr("overloadTrackingModuleStrengthBonus"))
    module.boostItemAttr("falloffBonus", module.getModifiedItemAttr("overloadTrackingModuleStrengthBonus"))
    module.boostItemAttr("trackingSpeedBonus", module.getModifiedItemAttr("overloadTrackingModuleStrengthBonus"))

########NEW FILE########
__FILENAME__ = powerbooster
# Used by:
# Modules from group: Capacitor Booster (54 of 54)
type = "active"
def handler(fit, module, context):
    # Set reload time to 10 seconds
    module.reloadTime = 10000
    # Make so that reloads are always taken into account during clculations
    module.forceReload = True

    if module.charge is None: return
    capAmount = module.getModifiedChargeAttr("capacitorBonus") or 0
    module.itemModifiedAttributes["capacitorNeed"] = -capAmount

########NEW FILE########
__FILENAME__ = powerincrease
# Used by:
# Modules from group: Auxiliary Power Core (8 of 8)
type = "passive"
def handler(fit, module, context):
    fit.ship.increaseItemAttr("powerOutput", module.getModifiedItemAttr("powerIncrease"))
########NEW FILE########
__FILENAME__ = poweroutputaddpassive
# Used by:
# Items from category: Subsystem (40 of 80)
type = "passive"
def handler(fit, module, context):
    fit.ship.increaseItemAttr("powerOutput", module.getModifiedItemAttr("powerOutput"))

########NEW FILE########
__FILENAME__ = poweroutputmultiply
# Used by:
# Modules from group: Capacitor Flux Coil (12 of 12)
# Modules from group: Capacitor Power Relay (26 of 26)
# Modules from group: Power Diagnostic System (31 of 31)
# Modules from group: Reactor Control Unit (28 of 28)
# Modules from group: Shield Flux Coil (11 of 11)
# Modules from group: Shield Power Relay (11 of 11)
type = "passive"
def handler(fit, module, context):
    fit.ship.multiplyItemAttr("powerOutput", module.getModifiedItemAttr("powerOutputMultiplier"))
########NEW FILE########
__FILENAME__ = projectilefired
# Used by:
# Modules from group: Hybrid Weapon (199 of 199)
# Modules from group: Projectile Weapon (143 of 143)
type = 'active'
def handler(fit, module, context):
    rt = module.getModifiedItemAttr("reloadTime")
    if not rt:
        # Set reload time to 10 seconds
        module.reloadTime = 10000
    else:
        module.reloadTime = rt

########NEW FILE########
__FILENAME__ = projectileweapondamagemultiply
# Used by:
# Modules from group: Gyrostabilizer (20 of 20)
# Modules named like: QA Multiship Module Players (4 of 4)
# Module: QA Damage Module
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.group.name == "Projectile Weapon",
                                  "damageMultiplier", module.getModifiedItemAttr("damageMultiplier"),
                                  stackingPenalties = True)
########NEW FILE########
__FILENAME__ = projectileweapondamagemultiplypassive
# Used by:
# Modules named like: Projectile Collision Accelerator (8 of 8)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.group.name == "Projectile Weapon",
                                  "damageMultiplier", module.getModifiedItemAttr("damageMultiplier"),
                                  stackingPenalties = True)
########NEW FILE########
__FILENAME__ = projectileweaponspeedmultiply
# Used by:
# Modules from group: Gyrostabilizer (20 of 20)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.group.name == "Projectile Weapon",
                                     "speed", module.getModifiedItemAttr("speedMultiplier"),
                                     stackingPenalties = True)
########NEW FILE########
__FILENAME__ = projectileweaponspeedmultiplypassive
# Used by:
# Modules named like: Projectile Burst Aerator (8 of 8)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.group.name == "Projectile Weapon",
                                     "speed", module.getModifiedItemAttr("speedMultiplier"),
                                     stackingPenalties = True)
########NEW FILE########
__FILENAME__ = propulsionskillcapneedbonusskilllevel
# Used by:
# Implants named like: Zainou 'Gypsy' Propulsion Jamming PJ (6 of 6)
# Skill: Propulsion Jamming
type = "passive"
def handler(fit, container, context):
    groups = ("Stasis Web", "Warp Scrambler", "Warp Disrupt Field Generator")
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name in groups,
                                  "capacitorNeed", container.getModifiedItemAttr("capNeedBonus") * level)

########NEW FILE########
__FILENAME__ = rapidfiringrofbonuspostpercentspeedlocationshipmodulesrequiringgunnery
# Used by:
# Skill: Rapid Firing
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Gunnery"),
                                  "speed", skill.getModifiedItemAttr("rofBonus") * skill.level)
########NEW FILE########
__FILENAME__ = rechargerateaddpassive
# Used by:
# Subsystems from group: Engineering Systems (16 of 16)
type = "passive"
def handler(fit, module, context):
    fit.ship.increaseItemAttr("rechargeRate", module.getModifiedItemAttr("rechargeRate"))
########NEW FILE########
__FILENAME__ = reconoperationsmaxtargetrangebonuspostpercentmaxtargetrangegangships
# Used by:
# Implant: Caldari Navy Warfare Mindlink
# Implant: Imperial Navy Warfare Mindlink
# Implant: Information Warfare Mindlink
# Skill: Information Warfare
type = "gang"
gangBoost = "maxTargetRange"
gangBonus = "maxTargetRangeBonus"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.ship.boostItemAttr(gangBoost, container.getModifiedItemAttr(gangBonus) * level)

########NEW FILE########
__FILENAME__ = reconshipcloakcpubonus1
# Used by:
# Ships from group: Force Recon Ship (5 of 5)
type = "passive"
runTime = "early"
def handler(fit, ship, context):
    level = fit.character.getSkill("Recon Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Cloaking Device",
                                  "cpu", ship.getModifiedItemAttr("eliteBonusReconShip1") * level)

########NEW FILE########
__FILENAME__ = remotearmorpowerneedbonuseffect
# Used by:
# Ship: Guardian
# Ship: Oneiros
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Armor Repairer",
                                  "power", ship.getModifiedItemAttr("remoteArmorPowerNeedBonus"))

########NEW FILE########
__FILENAME__ = remotearmorsystemscapneedbonuspostpercentcapacitorneedlocationshipmodulesrequiringremotearmorsystems
# Used by:
# Implants named like: Inherent Implants 'Noble' Remote Armor Repair Systems RA (6 of 6)
# Modules named like: Remote Repair Augmentor (6 of 8)
# Skill: Remote Armor Repair Systems
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Remote Armor Repair Systems"),
                                  "capacitorNeed", container.getModifiedItemAttr("capNeedBonus") * level)

########NEW FILE########
__FILENAME__ = remoteecmburst
# Used by:
# Module: Remote ECM Burst I
type = 'active'
def handler(fit, module, context):
    pass

########NEW FILE########
__FILENAME__ = remotehullrepair
# Used by:
# Modules from group: Remote Hull Repairer (7 of 7)
# Drones named like: Hull Maintenance Bot (6 of 6)
type = "projected", "active"
runTime = "late"
def handler(fit, module, context):
    if "projected" not in context: return
    bonus = module.getModifiedItemAttr("structureDamageAmount")
    duration = module.getModifiedItemAttr("duration") / 1000.0
    fit.extraAttributes.increase("hullRepair", bonus / duration)

########NEW FILE########
__FILENAME__ = repairdronearmordamageamountbonus
# Used by:
# Modules named like: Drone Repair Augmentor (8 of 8)
# Skill: Repair Drone Operation
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.drones.filteredItemBoost(lambda drone: drone.item.group.name == "Logistic Drone",
                                 "armorDamageAmount", container.getModifiedItemAttr("damageHP") * level)

########NEW FILE########
__FILENAME__ = repairdronehullbonusbonus
# Used by:
# Modules named like: Drone Repair Augmentor (8 of 8)
# Skill: Repair Drone Operation
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.drones.filteredItemBoost(lambda drone: drone.item.group.name == "Logistic Drone",
                                 "structureDamageAmount", container.getModifiedItemAttr("damageHP") * level)

########NEW FILE########
__FILENAME__ = repairdroneshieldbonusbonus
# Used by:
# Modules named like: Drone Repair Augmentor (8 of 8)
# Skill: Repair Drone Operation
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.drones.filteredItemBoost(lambda drone: drone.item.group.name == "Logistic Drone",
                                 "shieldBonus", container.getModifiedItemAttr("damageHP") * level)

########NEW FILE########
__FILENAME__ = repairsystemsdurationbonuspostpercentdurationlocationshipmodulesrequiringrepairsystems
# Used by:
# Implants named like: Inherent Implants 'Noble' Repair Systems RS (6 of 6)
# Modules named like: Nanobot Accelerator (8 of 8)
# Implant: Numon Family Heirloom
# Skill: Repair Systems
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Repair Systems"),
                                  "duration", container.getModifiedItemAttr("durationSkillBonus") * level)

########NEW FILE########
__FILENAME__ = republicsetbonus3
# Used by:
# Implants named like: Jackal (6 of 12)
runTime = "early"
type = "passive"
def handler(fit, implant, context):
    fit.implants.filteredItemMultiply(lambda target: target.item.requiresSkill("Cybernetics"),
                                      "scanLadarStrengthPercent", implant.getModifiedItemAttr("implantSetRepublicFleet"))

########NEW FILE########
__FILENAME__ = republicsetlgbonus
# Used by:
# Implants named like: Low grade Jackal (6 of 6)
runTime = "early"
type = "passive"
def handler(fit, implant, context):
    fit.implants.filteredItemMultiply(lambda target: target.item.requiresSkill("Cybernetics"),
                                      "scanLadarStrengthModifier", implant.getModifiedItemAttr("implantSetLGRepublicFleet"))

########NEW FILE########
__FILENAME__ = rigdrawbackbonuseffect
# Used by:
# Skills from group: Rigging (9 of 10)
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill(skill),
                                  "drawback", skill.getModifiedItemAttr("rigDrawbackBonus") * skill.level)
    
########NEW FILE########
__FILENAME__ = rolebonusmaraudermjdrreactivationdelaybonus
# Used by:
# Ships from group: Marauder (4 of 4)
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Micro Jump Drive",
                                  "moduleReactivationDelay", ship.getModifiedItemAttr("roleBonusMarauder"))

########NEW FILE########
__FILENAME__ = rorqualcargoscanrangebonus
# Used by:
# Ship: Rorqual
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Cargo Scanner",
                                  "cargoScanRange", ship.getModifiedItemAttr("cargoScannerRangeBonus"))

########NEW FILE########
__FILENAME__ = rorqualsurveyscannerrangebonus
# Used by:
# Ship: Rorqual
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Survey Scanner",
                                  "surveyScanRange", ship.getModifiedItemAttr("surveyScannerRangeBonus"))

########NEW FILE########
__FILENAME__ = salvagermoduledurationreduction
# Used by:
# Implant: Poteque 'Prospector' Environmental Analysis EY-1005
type = "passive"
def handler(fit, implant, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Salvager",
                                  "duration", implant.getModifiedItemAttr("durationBonus"))

########NEW FILE########
__FILENAME__ = salvaging
# Used by:
# Modules from group: Salvager (2 of 2)
type = "active"
def handler(fit, module, context):
    pass
########NEW FILE########
__FILENAME__ = salvagingaccessdifficultybonuseffectpassive
# Used by:
# Modules from group: Rig Resource Processing (8 of 10)
# Implant: Poteque 'Prospector' Salvaging SV-905
type = "passive"
def handler(fit, container, context):
    fit.modules.filteredItemIncrease(lambda mod: mod.item.requiresSkill("Salvaging"),
                                  "accessDifficultyBonus", container.getModifiedItemAttr("accessDifficultyBonus"), position="post")

########NEW FILE########
__FILENAME__ = scangravimetricstrengthmodifiereffect
# Used by:
# Implants named like: Low grade Talon (5 of 6)
type = "passive"
def handler(fit, implant, context):
    fit.ship.increaseItemAttr("scanGravimetricStrength", implant.getModifiedItemAttr("scanGravimetricStrengthModifier"))
########NEW FILE########
__FILENAME__ = scanladarstrengthmodifiereffect
# Used by:
# Implants named like: Low grade Jackal (5 of 6)
type = "passive"
def handler(fit, implant, context):
    fit.ship.increaseItemAttr("scanLadarStrength", implant.getModifiedItemAttr("scanLadarStrengthModifier"))
########NEW FILE########
__FILENAME__ = scanmagnetometricstrengthmodifiereffect
# Used by:
# Implants named like: Low grade Spur (5 of 6)
type = "passive"
def handler(fit, implant, context):
    fit.ship.increaseItemAttr("scanMagnetometricStrength", implant.getModifiedItemAttr("scanMagnetometricStrengthModifier"))
########NEW FILE########
__FILENAME__ = scanradarstrengthmodifiereffect
# Used by:
# Implants named like: Low grade Grail (5 of 6)
type = "passive"
def handler(fit, implant, context):
    fit.ship.increaseItemAttr("scanRadarStrength", implant.getModifiedItemAttr("scanRadarStrengthModifier"))
########NEW FILE########
__FILENAME__ = scanresolutionaddpassive
# Used by:
# Subsystems from group: Electronic Systems (16 of 16)
type = "passive"
def handler(fit, module, context):
    fit.ship.increaseItemAttr("scanResolution", module.getModifiedItemAttr("scanResolution"))

########NEW FILE########
__FILENAME__ = scanresolutionmultiplieronline
# Used by:
# Modules from group: Warp Core Stabilizer (8 of 8)
# Module: Target Spectrum Breaker
type = "passive"
def handler(fit, module, context):
    fit.ship.multiplyItemAttr("scanResolution", module.getModifiedItemAttr("scanResolutionMultiplier"),
                              stackingPenalties = True)
########NEW FILE########
__FILENAME__ = scanstrengthaddpassive
# Used by:
# Subsystems from group: Electronic Systems (16 of 16)
type = "passive"
def handler(fit, module, context):
    sensorTypes = ("Gravimetric", "Ladar", "Magnetometric", "Radar")
    for sensorType in sensorTypes:
        sensAttr = "scan{0}Strength".format(sensorType)
        fit.ship.increaseItemAttr(sensAttr, module.getModifiedItemAttr(sensAttr))

########NEW FILE########
__FILENAME__ = scanstrengthbonuspercentactivate
# Used by:
# Modules from group: ECCM (44 of 44)
# Module: QA ECCM
type = "active"
def handler(fit, module, context):
    for type in ("Gravimetric", "Magnetometric", "Radar", "Ladar"):
        fit.ship.boostItemAttr("scan%sStrength" % type,
                               module.getModifiedItemAttr("scan%sStrengthPercent" % type),
                               stackingPenalties = True)
########NEW FILE########
__FILENAME__ = scanstrengthbonuspercentonline
# Used by:
# Modules from group: Sensor Backup Array (72 of 72)
type = "passive"
def handler(fit, module, context):
    for type in ("Gravimetric", "Magnetometric", "Radar", "Ladar"):
        fit.ship.boostItemAttr("scan%sStrength" % type,
                               module.getModifiedItemAttr("scan%sStrengthPercent" % type),
                               stackingPenalties = True)
########NEW FILE########
__FILENAME__ = scanstrengthbonuspercentpassive
# Used by:
# Implants from group: Cyberimplant (20 of 157)
type = "passive"
def handler(fit, implant, context):
    for type in ("Gravimetric", "Magnetometric", "Radar", "Ladar"):
        sensorType = "scan{0}Strength".format(type)
        sensorBoost = "scan{0}StrengthPercent".format(type)
        if sensorBoost in implant.item.attributes:
            fit.ship.boostItemAttr(sensorType, implant.getModifiedItemAttr(sensorBoost))

########NEW FILE########
__FILENAME__ = scanstrengthtargetpercentbonus
# Used by:
# Modules from group: Projected ECCM (7 of 7)
type = "projected", "active"
def handler(fit, module, context):
    if "projected" not in context: return
    for type in ("Gravimetric", "Magnetometric", "Radar", "Ladar"):
        fit.ship.boostItemAttr("scan%sStrength" % type,
                               module.getModifiedItemAttr("scan%sStrengthPercent" % type),
                               stackingPenalties = True)

########NEW FILE########
__FILENAME__ = scoutdroneoperationdronerangebonusmodadddronecontroldistancechar
# Used by:
# Modules named like: Drone Control Range Augmentor (8 of 8)
# Skill: Electronic Warfare Drone Interfacing
# Skill: Scout Drone Operation
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    amount = container.getModifiedItemAttr("droneRangeBonus") * level
    fit.extraAttributes.increase("droneControlRange", amount)

########NEW FILE########
__FILENAME__ = scriptdurationbonus
# Used by:
# Charge: Focused Warp Disruption Script
type = "passive"
def handler(fit, module, context):
    module.boostItemAttr("duration", module.getModifiedChargeAttr("durationBonus"))

########NEW FILE########
__FILENAME__ = scriptmassbonuspercentagebonus
# Used by:
# Charge: Focused Warp Disruption Script
type = "passive"
runTime = "early"
def handler(fit, module, context):
    module.boostItemAttr("massBonusPercentage", module.getModifiedChargeAttr("massBonusPercentageBonus"))

########NEW FILE########
__FILENAME__ = scriptsensorboostermaxtargetrangebonusbonus
# Used by:
# Charges from group: Sensor Booster Script (2 of 2)
# Charges from group: Sensor Dampener Script (2 of 2)
type = "passive"
def handler(fit, module, context):
    module.boostItemAttr("maxTargetRangeBonus", module.getModifiedChargeAttr("maxTargetRangeBonusBonus"))
########NEW FILE########
__FILENAME__ = scriptsensorboosterscanresolutionbonusbonus
# Used by:
# Charges from group: Sensor Booster Script (2 of 2)
# Charges from group: Sensor Dampener Script (2 of 2)
type = "passive"
def handler(fit, module, context):
    module.boostItemAttr("scanResolutionBonus", module.getModifiedChargeAttr("scanResolutionBonusBonus"))
########NEW FILE########
__FILENAME__ = scriptsignatureradiusbonusbonus
# Used by:
# Charge: Focused Warp Disruption Script
type = "passive"
runTime = "early"
def handler(fit, module, context):
    module.boostItemAttr("signatureRadiusBonus", module.getModifiedChargeAttr("signatureRadiusBonusBonus"))

########NEW FILE########
__FILENAME__ = scriptspeedboostfactorbonusbonus
# Used by:
# Charge: Focused Warp Disruption Script
type = "passive"
runTime = "early"
def handler(fit, module, context):
    module.boostItemAttr("speedBoostFactorBonus", module.getModifiedChargeAttr("speedBoostFactorBonusBonus"))

########NEW FILE########
__FILENAME__ = scriptspeedfactorbonusbonus
# Used by:
# Charge: Focused Warp Disruption Script
type = "passive"
runTime = "early"
def handler(fit, module, context):
    module.boostItemAttr("speedFactorBonus", module.getModifiedChargeAttr("speedFactorBonusBonus"))

########NEW FILE########
__FILENAME__ = scripttrackingcomputermaxrangebonusbonus
# Used by:
# Charges from group: Tracking Disruption Script (2 of 2)
# Charges from group: Tracking Script (2 of 2)
type = "passive"
def handler(fit, module, context):
    module.boostItemAttr("maxRangeBonus", module.getModifiedChargeAttr("maxRangeBonusBonus"))
    module.boostItemAttr("falloffBonus", module.getModifiedChargeAttr("falloffBonusBonus"))

########NEW FILE########
__FILENAME__ = scripttrackingcomputertrackingspeedbonusbonus
# Used by:
# Charges from group: Tracking Disruption Script (2 of 2)
# Charges from group: Tracking Script (2 of 2)
type = "passive"
def handler(fit, module, context):
    module.boostItemAttr("trackingSpeedBonus", module.getModifiedChargeAttr("trackingSpeedBonusBonus"))

########NEW FILE########
__FILENAME__ = scriptwarpdisruptionfieldgeneratorsetdisallowinempirespace
# Used by:
# Charge: Focused Warp Disruption Script
type = "passive"
def handler(fit, module, context):
    module.forceItemAttr("disallowInEmpireSpace", module.getModifiedChargeAttr("disallowInEmpireSpace"))

########NEW FILE########
__FILENAME__ = scriptwarpscramblerangebonus
# Used by:
# Charge: Focused Warp Disruption Script
type = "passive"
def handler(fit, module, context):
    module.boostItemAttr("warpScrambleRange", module.getModifiedChargeAttr("warpScrambleRangeBonus"))

########NEW FILE########
__FILENAME__ = selfrof
# Used by:
# Skills named like: Missile Specialization (4 of 4)
# Skill: Rocket Specialization
# Skill: Torpedo Specialization
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill(skill),
                                  "speed", skill.getModifiedItemAttr("rofBonus") * skill.level)
########NEW FILE########
__FILENAME__ = selft2largehybridblasterdamagebonus
# Used by:
# Skill: Large Blaster Specialization
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Blaster Specialization"),
                                  "damageMultiplier", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)
########NEW FILE########
__FILENAME__ = selft2largehybridraildamagebonus
# Used by:
# Skill: Large Railgun Specialization
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Railgun Specialization"),
                                  "damageMultiplier", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)
########NEW FILE########
__FILENAME__ = selft2largelaserbeamdamagebonus
# Used by:
# Skill: Large Beam Laser Specialization
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Beam Laser Specialization"),
                                  "damageMultiplier", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)
########NEW FILE########
__FILENAME__ = selft2largelaserpulsedamagebonus
# Used by:
# Skill: Large Pulse Laser Specialization
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Pulse Laser Specialization"),
                                  "damageMultiplier", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)
########NEW FILE########
__FILENAME__ = selft2largeprojectileacdamagebonus
# Used by:
# Skill: Large Autocannon Specialization
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Autocannon Specialization"),
                                  "damageMultiplier", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)
########NEW FILE########
__FILENAME__ = selft2largeprojectileartydamagebonus
# Used by:
# Skill: Large Artillery Specialization
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Artillery Specialization"),
                                  "damageMultiplier", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)
########NEW FILE########
__FILENAME__ = selft2mediumhybridblasterdamagebonus
# Used by:
# Skill: Medium Blaster Specialization
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Blaster Specialization"),
                                  "damageMultiplier", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)
########NEW FILE########
__FILENAME__ = selft2mediumhybridraildamagebonus
# Used by:
# Skill: Medium Railgun Specialization
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Railgun Specialization"),
                                  "damageMultiplier", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)
########NEW FILE########
__FILENAME__ = selft2mediumlaserbeamdamagebonus
# Used by:
# Skill: Medium Beam Laser Specialization
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Beam Laser Specialization"),
                                  "damageMultiplier", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)
########NEW FILE########
__FILENAME__ = selft2mediumlaserpulsedamagebonus
# Used by:
# Skill: Medium Pulse Laser Specialization
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Pulse Laser Specialization"),
                                  "damageMultiplier", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)
########NEW FILE########
__FILENAME__ = selft2mediumprojectileacdamagebonus
# Used by:
# Skill: Medium Autocannon Specialization
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Autocannon Specialization"),
                                  "damageMultiplier", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)
########NEW FILE########
__FILENAME__ = selft2mediumprojectileartydamagebonus
# Used by:
# Skill: Medium Artillery Specialization
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Artillery Specialization"),
                                  "damageMultiplier", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)
########NEW FILE########
__FILENAME__ = selft2smallhybridblasterdamagebonus
# Used by:
# Skill: Small Blaster Specialization
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Blaster Specialization"),
                                  "damageMultiplier", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)
########NEW FILE########
__FILENAME__ = selft2smallhybridraildamagebonus
# Used by:
# Skill: Small Railgun Specialization
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Railgun Specialization"),
                                  "damageMultiplier", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)
########NEW FILE########
__FILENAME__ = selft2smalllaserbeamdamagebonus
# Used by:
# Skill: Small Beam Laser Specialization
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Beam Laser Specialization"),
                                  "damageMultiplier", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)
########NEW FILE########
__FILENAME__ = selft2smalllaserpulsedamagebonus
# Used by:
# Skill: Small Pulse Laser Specialization
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Pulse Laser Specialization"),
                                  "damageMultiplier", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)
########NEW FILE########
__FILENAME__ = selft2smallprojectileacdamagebonus
# Used by:
# Skill: Small Autocannon Specialization
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Autocannon Specialization"),
                                  "damageMultiplier", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)
########NEW FILE########
__FILENAME__ = selft2smallprojectileartydamagebonus
# Used by:
# Skill: Small Artillery Specialization
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Artillery Specialization"),
                                  "damageMultiplier", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)
########NEW FILE########
__FILENAME__ = sensorboosteractivepercentage
# Used by:
# Modules from group: Sensor Booster (12 of 12)
type = "active"
def handler(fit, module, context):
    fit.ship.boostItemAttr("maxTargetRange", module.getModifiedItemAttr("maxTargetRangeBonus"),
                           stackingPenalties = True)
    fit.ship.boostItemAttr("scanResolution", module.getModifiedItemAttr("scanResolutionBonus"),
                           stackingPenalties = True)

########NEW FILE########
__FILENAME__ = sensorboosttargetedhostile
# Used by:
# Drones named like: SD (3 of 3)
type = "projected", "active"
def handler(fit, container, context):
    if "projected" in context:
        fit.ship.multiplyItemAttr("maxTargetRange", container.getModifiedItemAttr("maxTargetRangeMultiplier"),
                                  stackingPenalties = True, penaltyGroup="postMul")
        fit.ship.multiplyItemAttr("scanResolution", container.getModifiedItemAttr("scanResolutionMultiplier"),
                                  stackingPenalties = True, penaltyGroup="postMul")

########NEW FILE########
__FILENAME__ = sensorcompensationsensorstrengthbonusgravimetric
# Used by:
# Skill: Gravimetric Sensor Compensation
type = "passive"
def handler(fit, container, context):
    fit.ship.boostItemAttr("scanGravimetricStrength", container.getModifiedItemAttr("sensorStrengthBonus") * container.level)

########NEW FILE########
__FILENAME__ = sensorcompensationsensorstrengthbonusladar
# Used by:
# Skill: Ladar Sensor Compensation
type = "passive"
def handler(fit, container, context):
    fit.ship.boostItemAttr("scanLadarStrength", container.getModifiedItemAttr("sensorStrengthBonus") * container.level)

########NEW FILE########
__FILENAME__ = sensorcompensationsensorstrengthbonusmagnetometric
# Used by:
# Skill: Magnetometric Sensor Compensation
type = "passive"
def handler(fit, container, context):
    fit.ship.boostItemAttr("scanMagnetometricStrength", container.getModifiedItemAttr("sensorStrengthBonus") * container.level)

########NEW FILE########
__FILENAME__ = sensorcompensationsensorstrengthbonusradar
# Used by:
# Skill: Radar Sensor Compensation
type = "passive"
def handler(fit, container, context):
    fit.ship.boostItemAttr("scanRadarStrength", container.getModifiedItemAttr("sensorStrengthBonus") * container.level)

########NEW FILE########
__FILENAME__ = sensorupgradescpuneedbonuspostpercentcpulocationshipmodulesrequiringsensorupgrades
# Used by:
# Implants named like: Zainou 'Gypsy' Electronics Upgrades EU (6 of 6)
# Modules named like: Liquid Cooled Electronics (8 of 8)
# Skill: Electronics Upgrades
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Electronics Upgrades"),
                                  "cpu", container.getModifiedItemAttr("cpuNeedBonus") * level)

########NEW FILE########
__FILENAME__ = sentrydronedamagebonus
# Used by:
# Modules named like: Sentry Damage Augmentor (8 of 8)
type = "passive"
def handler(fit, module, context):
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Sentry Drone Interfacing"),
                                 "damageMultiplier", module.getModifiedItemAttr("damageMultiplierBonus"),
                                 stackingPenalties = True)
########NEW FILE########
__FILENAME__ = setbonusbloodraider
# Used by:
# Implants named like: Talisman (12 of 12)
runTime = "early"
type = "passive"
def handler(fit, implant, context):
    fit.implants.filteredItemMultiply(lambda mod: mod.item.group.name == "Cyberimplant",
                                      "durationBonus", implant.getModifiedItemAttr("implantSetBloodraider"))

########NEW FILE########
__FILENAME__ = setbonusbloodraidernosferatu
# Used by:
# Implants named like: Talisman (10 of 12)
type = "passive"
def handler(fit, implant, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capacitor Emission Systems"),
                                  "duration", implant.getModifiedItemAttr("durationBonus"))

########NEW FILE########
__FILENAME__ = setbonuschristmasagilitybonus
# Used by:
# Implants named like: Genolution Core Augmentation CA (4 of 4)
runTime = "early"
type = "passive"
def handler(fit, implant, context):
    fit.implants.filteredItemMultiply(lambda mod: mod.item.group.name == "Cyberimplant",
                                      "agilityBonus", implant.getModifiedItemAttr("implantSetChristmas"))

########NEW FILE########
__FILENAME__ = setbonuschristmasarmorhpbonus2
# Used by:
# Implants named like: Genolution Core Augmentation CA (4 of 4)
runTime = "early"
type = "passive"
def handler(fit, implant, context):
    fit.implants.filteredItemMultiply(lambda mod: mod.item.group.name == "Cyberimplant",
                                      "armorHpBonus2", implant.getModifiedItemAttr("implantSetChristmas"))

########NEW FILE########
__FILENAME__ = setbonuschristmasbonusvelocity
# Used by:
# Implants named like: Genolution Core Augmentation CA (4 of 4)
runTime = "early"
type = "passive"
def handler(fit, implant, context):
    fit.implants.filteredItemMultiply(lambda mod: mod.item.group.name == "Cyberimplant",
                                      "implantBonusVelocity", implant.getModifiedItemAttr("implantSetChristmas"))

########NEW FILE########
__FILENAME__ = setbonuschristmascapacitorcapacity
# Used by:
# Implants named like: Genolution Core Augmentation CA (4 of 4)
runTime = "early"
type = "passive"
def handler(fit, implant, context):
    fit.implants.filteredItemMultiply(lambda mod: mod.item.group.name == "Cyberimplant",
                                      "capacitorCapacityBonus", implant.getModifiedItemAttr("implantSetChristmas"))

########NEW FILE########
__FILENAME__ = setbonuschristmascapacitorrecharge2
# Used by:
# Implants named like: Genolution Core Augmentation CA (4 of 4)
runTime = "early"
type = "passive"
def handler(fit, implant, context):
    fit.implants.filteredItemMultiply(lambda mod: mod.item.group.name == "Cyberimplant",
                                      "capRechargeBonus", implant.getModifiedItemAttr("implantSetChristmas"))

########NEW FILE########
__FILENAME__ = setbonuschristmascpuoutput
# Used by:
# Implants named like: Genolution Core Augmentation CA (4 of 4)
runTime = "early"
type = "passive"
def handler(fit, implant, context):
    fit.implants.filteredItemMultiply(lambda mod: mod.item.group.name == "Cyberimplant",
                                      "cpuOutputBonus2", implant.getModifiedItemAttr("implantSetChristmas"))

########NEW FILE########
__FILENAME__ = setbonuschristmaspowergrid
# Used by:
# Implants named like: Genolution Core Augmentation CA (4 of 4)
runTime = "early"
type = "passive"
def handler(fit, implant, context):
    fit.implants.filteredItemMultiply(lambda mod: mod.item.group.name == "Cyberimplant",
                                      "powerEngineeringOutputBonus", implant.getModifiedItemAttr("implantSetChristmas"))

########NEW FILE########
__FILENAME__ = setbonuschristmasshieldcapacitybonus
# Used by:
# Implants named like: Genolution Core Augmentation CA (4 of 4)
runTime = "early"
type = "passive"
def handler(fit, implant, context):
    fit.implants.filteredItemMultiply(lambda mod: mod.item.group.name == "Cyberimplant",
                                      "shieldCapacityBonus", implant.getModifiedItemAttr("implantSetChristmas"))

########NEW FILE########
__FILENAME__ = setbonusguristas
# Used by:
# Implants named like: Crystal (12 of 12)
runTime = "early"
type = "passive"
def handler(fit, implant, context):
    fit.implants.filteredItemMultiply(lambda mod: mod.item.group.name == "Cyberimplant",
                                      "shieldBoostMultiplier", implant.getModifiedItemAttr("implantSetGuristas"))

########NEW FILE########
__FILENAME__ = setbonusmordus
# Used by:
# Implants named like: Low grade Centurion (6 of 6)
runTime = "early"
type = "passive"
def handler(fit, implant, context):
    fit.implants.filteredItemMultiply(lambda mod: mod.item.group.name == "Cyberimplant",
                                      "rangeSkillBonus", implant.getModifiedItemAttr("implantSetMordus"))

########NEW FILE########
__FILENAME__ = setbonusore
# Used by:
# Implants named like: Low grade Harvest (6 of 6)
runTime = "early"
type = "passive"
def handler(fit, implant, context):
    fit.implants.filteredItemMultiply(lambda mod: mod.item.group.name == "Cyberimplant",
                                      "maxRangeBonus", implant.getModifiedItemAttr("implantSetORE"))

########NEW FILE########
__FILENAME__ = setbonussansha
# Used by:
# Implants named like: Slave (12 of 12)
# Implant: Halo Omega
runTime = "early"
type = "passive"
def handler(fit, implant, context):
    fit.implants.filteredItemMultiply(lambda target: target.item.requiresSkill("Cybernetics"),
                                      "armorHpBonus", implant.getModifiedItemAttr("implantSetSansha") or 1)

########NEW FILE########
__FILENAME__ = setbonusserpentis
# Used by:
# Implants named like: Snake (12 of 12)
runTime = "early"
type = "passive"
def handler(fit, implant, context):
    fit.implants.filteredItemMultiply(lambda mod: mod.item.group.name == "Cyberimplant",
                                      "velocityBonus", implant.getModifiedItemAttr("implantSetSerpentis"))

########NEW FILE########
__FILENAME__ = setbonussisters
# Used by:
# Implants named like: Low grade Virtue (6 of 6)
runTime = "early"
type = "passive"
def handler(fit, implant, context):
    fit.implants.filteredItemMultiply(lambda mod: mod.item.group.name == "Cyberimplant",
                                      "scanStrengthBonus", implant.getModifiedItemAttr("implantSetSisters"))

########NEW FILE########
__FILENAME__ = setbonussyndicate
# Used by:
# Implants named like: Low grade Edge (6 of 6)
runTime = "early"
type = "passive"
def handler(fit, implant, context):
    fit.implants.filteredItemMultiply(lambda mod: mod.item.group.name == "Cyberimplant",
                                      "boosterAttributeModifier", implant.getModifiedItemAttr("implantSetSyndicate"))

########NEW FILE########
__FILENAME__ = setbonusthukker
# Used by:
# Implants named like: Low grade Nomad (6 of 6)
runTime = "early"
type = "passive"
def handler(fit, implant, context):
    fit.implants.filteredItemMultiply(lambda mod: mod.item.group.name == "Cyberimplant",
                                      "agilityBonus", implant.getModifiedItemAttr("implantSetThukker"))

########NEW FILE########
__FILENAME__ = sharpshooterrangeskillbonuspostpercentmaxrangelocationshipmodulesrequiringgunnery
# Used by:
# Implants named like: Frentix Booster (4 of 4)
# Implants named like: Zainou 'Deadeye' Sharpshooter ST (6 of 6)
# Skill: Sharpshooter
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Gunnery"),
                                  "maxRange", container.getModifiedItemAttr("rangeSkillBonus") * level)

########NEW FILE########
__FILENAME__ = shieldboostamplifier
# Used by:
# Modules from group: Capacitor Power Relay (26 of 26)
# Modules from group: Shield Boost Amplifier (25 of 25)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Shield Operation") or mod.item.requiresSkill("Capital Shield Operation"),
                                  "shieldBonus", module.getModifiedItemAttr("shieldBoostMultiplier"),
                                  stackingPenalties = True)

########NEW FILE########
__FILENAME__ = shieldboostamplifierpassive
# Used by:
# Implants named like: Crystal (10 of 12)
type = "passive"
def handler(fit, container, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Shield Operation"),
                                  "shieldBonus", container.getModifiedItemAttr("shieldBoostMultiplier"))

########NEW FILE########
__FILENAME__ = shieldboostamplifierpassivebooster
# Used by:
# Implants named like: Blue Pill Booster (5 of 5)
type = "passive"
def handler(fit, container, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Shield Operation") or mod.item.requiresSkill("Capital Shield Operation"),
                                  "shieldBonus", container.getModifiedItemAttr("shieldBoostMultiplier"))

########NEW FILE########
__FILENAME__ = shieldboosterdurationbonusshieldskills
# Used by:
# Modules named like: Core Defense Operational Solidifier (8 of 8)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Shield Operation"),
                                  "duration", module.getModifiedItemAttr("durationSkillBonus"))
########NEW FILE########
__FILENAME__ = shieldboosting
# Used by:
# Modules from group: Shield Booster (87 of 87)
runTime = "late"
type = "active"
def handler(fit, module, context):
    amount = module.getModifiedItemAttr("shieldBonus")
    speed = module.getModifiedItemAttr("duration") / 1000.0
    fit.extraAttributes.increase("shieldRepair", amount / speed)
########NEW FILE########
__FILENAME__ = shieldcapacityaddpassive
# Used by:
# Subsystems from group: Defensive Systems (16 of 16)
type = "passive"
def handler(fit, module, context):
    fit.ship.increaseItemAttr("shieldCapacity", module.getModifiedItemAttr("shieldCapacity"))

########NEW FILE########
__FILENAME__ = shieldcapacitybonusonline
# Used by:
# Modules from group: Shield Amplifier (88 of 88)
# Modules from group: Shield Extender (37 of 37)
type = "passive"
def handler(fit, module, context):
    fit.ship.increaseItemAttr("shieldCapacity", module.getModifiedItemAttr("capacityBonus"))
########NEW FILE########
__FILENAME__ = shieldcapacitymultiply
# Used by:
# Modules from group: Capacitor Flux Coil (12 of 12)
# Modules from group: Capacitor Power Relay (26 of 26)
# Modules from group: Power Diagnostic System (31 of 31)
# Modules from group: Reactor Control Unit (28 of 28)
# Modules from group: Shield Flux Coil (11 of 11)
# Modules from group: Shield Power Relay (11 of 11)
type = "passive"
def handler(fit, module, context):
    fit.ship.multiplyItemAttr("shieldCapacity", module.getModifiedItemAttr("shieldCapacityMultiplier"))
########NEW FILE########
__FILENAME__ = shielddefensiveoperationsshieldcapacitybonuspostpercentshieldcapacitygangships
# Used by:
# Implant: Caldari Navy Warfare Mindlink
# Implant: Republic Fleet Warfare Mindlink
# Implant: Siege Warfare Mindlink
# Skill: Siege Warfare
type = "gang"
gangBoost = "shieldCapacity"
gangBonus = "shieldCapacityBonus"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.ship.boostItemAttr(gangBoost, container.getModifiedItemAttr(gangBonus) * level)

########NEW FILE########
__FILENAME__ = shieldemmisionsystemscapneedbonuspostpercentcapacitorneedlocationshipmodulesrequiringshieldemmisionsystems
# Used by:
# Implants named like: Zainou 'Gnome' Shield Emission Systems SE (6 of 6)
# Skill: Shield Emission Systems
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Shield Emission Systems"),
                                  "capacitorNeed", container.getModifiedItemAttr("capNeedBonus") * level)

########NEW FILE########
__FILENAME__ = shieldmanagementshieldcapacitybonuspostpercentcapacitylocationshipgroupshield
# Used by:
# Implants named like: Zainou 'Gnome' Shield Management SM (6 of 6)
# Modules named like: Core Defense Field Extender (8 of 8)
# Modules named like: QA Multiship Module Players (4 of 4)
# Implant: Genolution Core Augmentation CA-3
# Implant: Sansha Modified 'Gnome' Implant
# Skill: Shield Management
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.ship.boostItemAttr("shieldCapacity", container.getModifiedItemAttr("shieldCapacityBonus") * level)

########NEW FILE########
__FILENAME__ = shieldoperationrechargeratebonuspostpercentonline
# Used by:
# Modules from group: Shield Power Relay (11 of 11)
type = "passive"
def handler(fit, module, context):
    fit.ship.boostItemAttr("shieldRechargeRate", module.getModifiedItemAttr("rechargeratebonus") or 0)

########NEW FILE########
__FILENAME__ = shieldoperationrechargeratebonuspostpercentrechargeratelocationshipgroupshield
# Used by:
# Implants named like: Zainou 'Gnome' Shield Operation SP (6 of 6)
# Modules named like: Core Defense Field Purger (8 of 8)
# Implant: Sansha Modified 'Gnome' Implant
# Skill: Shield Operation
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.ship.boostItemAttr("shieldRechargeRate", container.getModifiedItemAttr("rechargeratebonus") * level)

########NEW FILE########
__FILENAME__ = shieldoperationskillboostcapacitorneedbonus
# Used by:
# Modules named like: Core Defense Capacitor Safeguard (8 of 8)
# Skill: Shield Compensation
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Shield Operation"),
                                  "capacitorNeed", container.getModifiedItemAttr("shieldBoostCapacitorBonus") * level)

########NEW FILE########
__FILENAME__ = shieldrechargerateaddpassive
# Used by:
# Subsystems from group: Defensive Systems (16 of 16)
type = "passive"
def handler(fit, module, context):
    fit.ship.increaseItemAttr("shieldRechargeRate", module.getModifiedItemAttr("shieldRechargeRate") or 0)

########NEW FILE########
__FILENAME__ = shieldtransfer
# Used by:
# Modules from group: Remote Shield Booster (39 of 39)
# Drones named like: Shield Maintenance Bot (6 of 6)
# Module: QA Shield Transporter - 5 Players
type = "projected", "active"
def handler(fit, container, context):
    if "projected" in context:
        bonus = container.getModifiedItemAttr("shieldBonus")
        duration = container.getModifiedItemAttr("duration") / 1000.0
        fit.extraAttributes.increase("shieldRepair", bonus / duration)

########NEW FILE########
__FILENAME__ = shieldtransportcpuneedbonuseffect
# Used by:
# Ships from group: Logistics (3 of 5)
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Shield Booster",
                                  "cpu", ship.getModifiedItemAttr("shieldTransportCpuNeedBonus"))

########NEW FILE########
__FILENAME__ = shieldtransportermaxrangebonus
# Used by:
# Ship: Bantam
# Ship: Burst
# Ship: Osprey
# Ship: Scythe
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Shield Booster",
                                  "shieldTransferRange", ship.getModifiedItemAttr("maxRangeBonus"))

########NEW FILE########
__FILENAME__ = shieldupgradespowerneedbonuspostpercentpowerlocationshipmodulesrequiringshieldupgrades
# Used by:
# Implants named like: Zainou 'Gnome' Shield Upgrades SU (6 of 6)
# Modules named like: Core Defense Charge Economizer (8 of 8)
# Skill: Shield Upgrades
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Shield Upgrades"),
                                  "power", container.getModifiedItemAttr("powerNeedBonus") * level)

########NEW FILE########
__FILENAME__ = shipadvancedspaceshipcommandagilitybonus
# Used by:
# Items from market group: Ships > Capital Ships (26 of 27)
type = "passive"
def handler(fit, ship, context):
    skill = fit.character.getSkill("Advanced Spaceship Command")
    fit.ship.boostItemAttr("agility", skill.getModifiedItemAttr("agilityBonus") * skill.level)

########NEW FILE########
__FILENAME__ = shiparmoremandexpandkinandthmresistanceac2
# Used by:
# Ships named like: Stratios (2 of 2)
# Ship: Sacrilege
# Ship: Vangel
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Cruiser").level
    damageTypes = ("Em", "Explosive", "Kinetic", "Thermal")
    for damageType in damageTypes:
        fit.ship.boostItemAttr("armor{0}DamageResonance".format(damageType), ship.getModifiedItemAttr("shipBonusAC2") * level)

########NEW FILE########
__FILENAME__ = shiparmoremresistance1abc1
# Used by:
# Variations of ship: Prophecy (2 of 2)
# Ship: Absolution
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Battlecruiser").level
    fit.ship.boostItemAttr("armorEmDamageResonance", ship.getModifiedItemAttr("shipBonusABC1") * level)

########NEW FILE########
__FILENAME__ = shiparmoremresistanceac2
# Used by:
# Ship: Devoter
# Ship: Maller
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Cruiser").level
    fit.ship.boostItemAttr("armorEmDamageResonance", ship.getModifiedItemAttr("shipBonusAC2") * level)

########NEW FILE########
__FILENAME__ = shiparmoremresistanceaf1
# Used by:
# Ships named like: Punisher (2 of 2)
# Ship: Astero
# Ship: Malice
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Frigate").level
    fit.ship.boostItemAttr("armorEmDamageResonance", ship.getModifiedItemAttr("shipBonusAF") * level)

########NEW FILE########
__FILENAME__ = shiparmoremresistancegc2
# Used by:
# Ship: Phobos
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Cruiser").level
    fit.ship.boostItemAttr("armorEmDamageResonance", ship.getModifiedItemAttr("shipBonusGC2") * level)

########NEW FILE########
__FILENAME__ = shiparmoremresistancemc2
# Used by:
# Ship: Mimir
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Cruiser").level
    fit.ship.boostItemAttr("armorEmDamageResonance", ship.getModifiedItemAttr("shipBonusMC2") * level)

########NEW FILE########
__FILENAME__ = shiparmoremresistancerookie
# Used by:
# Ship: Impairor
type = "passive"
def handler(fit, ship, context):
    fit.ship.boostItemAttr("armorEmDamageResonance", ship.getModifiedItemAttr("rookieArmorResistanceBonus"))

########NEW FILE########
__FILENAME__ = shiparmorexplosiveresistance1abc1
# Used by:
# Variations of ship: Prophecy (2 of 2)
# Ship: Absolution
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Battlecruiser").level
    fit.ship.boostItemAttr("armorExplosiveDamageResonance", ship.getModifiedItemAttr("shipBonusABC1") * level)

########NEW FILE########
__FILENAME__ = shiparmorexplosiveresistanceac2
# Used by:
# Ship: Devoter
# Ship: Maller
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Cruiser").level
    fit.ship.boostItemAttr("armorExplosiveDamageResonance", ship.getModifiedItemAttr("shipBonusAC2") * level)

########NEW FILE########
__FILENAME__ = shiparmorexplosiveresistancegc2
# Used by:
# Ship: Phobos
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Cruiser").level
    fit.ship.boostItemAttr("armorExplosiveDamageResonance", ship.getModifiedItemAttr("shipBonusGC2") * level)

########NEW FILE########
__FILENAME__ = shiparmorexplosiveresistancemc2
# Used by:
# Ship: Mimir
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Cruiser").level
    fit.ship.boostItemAttr("armorExplosiveDamageResonance", ship.getModifiedItemAttr("shipBonusMC2") * level)

########NEW FILE########
__FILENAME__ = shiparmorexresistanceaf1
# Used by:
# Ships named like: Punisher (2 of 2)
# Ship: Astero
# Ship: Malice
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Frigate").level
    fit.ship.boostItemAttr("armorExplosiveDamageResonance", ship.getModifiedItemAttr("shipBonusAF") * level)

########NEW FILE########
__FILENAME__ = shiparmorexresistancerookie
# Used by:
# Ship: Impairor
type = "passive"
def handler(fit, ship, context):
    fit.ship.boostItemAttr("armorExplosiveDamageResonance", ship.getModifiedItemAttr("rookieArmorResistanceBonus"))

########NEW FILE########
__FILENAME__ = shiparmorhpac2
# Used by:
# Ship: Augoror Navy Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Cruiser").level
    fit.ship.boostItemAttr("armorHP", ship.getModifiedItemAttr("shipBonusAC2") * level)

########NEW FILE########
__FILENAME__ = shiparmorkineticresistance1abc1
# Used by:
# Variations of ship: Prophecy (2 of 2)
# Ship: Absolution
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Battlecruiser").level
    fit.ship.boostItemAttr("armorKineticDamageResonance", ship.getModifiedItemAttr("shipBonusABC1") * level)

########NEW FILE########
__FILENAME__ = shiparmorkineticresistanceac2
# Used by:
# Ship: Devoter
# Ship: Maller
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Cruiser").level
    fit.ship.boostItemAttr("armorKineticDamageResonance", ship.getModifiedItemAttr("shipBonusAC2") * level)

########NEW FILE########
__FILENAME__ = shiparmorkineticresistancegc2
# Used by:
# Ship: Phobos
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Cruiser").level
    fit.ship.boostItemAttr("armorKineticDamageResonance", ship.getModifiedItemAttr("shipBonusGC2") * level)

########NEW FILE########
__FILENAME__ = shiparmorkineticresistancemc2
# Used by:
# Ship: Mimir
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Cruiser").level
    fit.ship.boostItemAttr("armorKineticDamageResonance", ship.getModifiedItemAttr("shipBonusMC2") * level)

########NEW FILE########
__FILENAME__ = shiparmorknresistanceaf1
# Used by:
# Ships named like: Punisher (2 of 2)
# Ship: Astero
# Ship: Malice
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Frigate").level
    fit.ship.boostItemAttr("armorKineticDamageResonance", ship.getModifiedItemAttr("shipBonusAF") * level)

########NEW FILE########
__FILENAME__ = shiparmorknresistancerookie
# Used by:
# Ship: Impairor
type = "passive"
def handler(fit, ship, context):
    fit.ship.boostItemAttr("armorKineticDamageResonance", ship.getModifiedItemAttr("rookieArmorResistanceBonus"))

########NEW FILE########
__FILENAME__ = shiparmorrepairing1gbc2
# Used by:
# Variations of ship: Myrmidon (2 of 2)
# Ship: Astarte
# Ship: Brutix
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Battlecruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Repair Systems"),
                                  "armorDamageAmount", ship.getModifiedItemAttr("shipBonusGBC2") * level)

########NEW FILE########
__FILENAME__ = shiparmorrepairinggf2
# Used by:
# Ships named like: Incursus (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Repair Systems"),
                                  "armorDamageAmount", ship.getModifiedItemAttr("shipBonusGF2") * level)

########NEW FILE########
__FILENAME__ = shiparmorrepairingrookie
# Used by:
# Ship: Velator
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Repair Systems"),
                                  "armorDamageAmount", ship.getModifiedItemAttr("rookieArmorRepBonus"))

########NEW FILE########
__FILENAME__ = shiparmorresistanceaf1
# Used by:
# Ship: Malediction
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Frigate").level
    damageTypes = ("Em", "Explosive", "Kinetic", "Thermal")
    for damageType in damageTypes:
        fit.ship.boostItemAttr("armor{0}DamageResonance".format(damageType), ship.getModifiedItemAttr("shipBonusAF") * level)

########NEW FILE########
__FILENAME__ = shiparmorthermalresistanceac2
# Used by:
# Ship: Devoter
# Ship: Maller
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Cruiser").level
    fit.ship.boostItemAttr("armorThermalDamageResonance", ship.getModifiedItemAttr("shipBonusAC2") * level)

########NEW FILE########
__FILENAME__ = shiparmorthermalresistancegc2
# Used by:
# Ship: Phobos
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Cruiser").level
    fit.ship.boostItemAttr("armorThermalDamageResonance", ship.getModifiedItemAttr("shipBonusGC2") * level)

########NEW FILE########
__FILENAME__ = shiparmorthermalresistancemc2
# Used by:
# Ship: Mimir
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Cruiser").level
    fit.ship.boostItemAttr("armorThermalDamageResonance", ship.getModifiedItemAttr("shipBonusMC2") * level)

########NEW FILE########
__FILENAME__ = shiparmorthermresistance1abc1
# Used by:
# Variations of ship: Prophecy (2 of 2)
# Ship: Absolution
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Battlecruiser").level
    fit.ship.boostItemAttr("armorThermalDamageResonance", ship.getModifiedItemAttr("shipBonusABC1") * level)

########NEW FILE########
__FILENAME__ = shiparmorthresistanceaf1
# Used by:
# Ships named like: Punisher (2 of 2)
# Ship: Astero
# Ship: Malice
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Frigate").level
    fit.ship.boostItemAttr("armorThermalDamageResonance", ship.getModifiedItemAttr("shipBonusAF") * level)

########NEW FILE########
__FILENAME__ = shiparmorthresistancerookie
# Used by:
# Ship: Impairor
type = "passive"
def handler(fit, ship, context):
    fit.ship.boostItemAttr("armorThermalDamageResonance", ship.getModifiedItemAttr("rookieArmorResistanceBonus"))

########NEW FILE########
__FILENAME__ = shipbonusaf1torpedoexplosionvelocity
# Used by:
# Ship: Purifier
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Frigate").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Torpedoes"),
                                    "aoeVelocity", ship.getModifiedItemAttr("shipBonusAF") * level)

########NEW FILE########
__FILENAME__ = shipbonusaf1torpedoflighttime
# Used by:
# Ship: Purifier
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Frigate").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Torpedoes"),
                                    "explosionDelay", ship.getModifiedItemAttr("shipBonusAF") * level)

########NEW FILE########
__FILENAME__ = shipbonusafterburnercapneedatf
# Used by:
# Ship: Freki
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Propulsion Module",
                                  "capacitorNeed", ship.getModifiedItemAttr("shipBonusATF1"))

########NEW FILE########
__FILENAME__ = shipbonusagilityai2
# Used by:
# Ship: Sigil
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Industrial").level
    fit.ship.boostItemAttr("agility", ship.getModifiedItemAttr("shipBonusAI2") * level)

########NEW FILE########
__FILENAME__ = shipbonusagilityci2
# Used by:
# Ship: Badger
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Industrial").level
    fit.ship.boostItemAttr("agility", ship.getModifiedItemAttr("shipBonusCI2") * level)

########NEW FILE########
__FILENAME__ = shipbonusagilitygi2
# Used by:
# Ship: Nereus
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Industrial").level
    fit.ship.boostItemAttr("agility", ship.getModifiedItemAttr("shipBonusGI2") * level)

########NEW FILE########
__FILENAME__ = shipbonusagilitymi2
# Used by:
# Ship: Wreathe
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Industrial").level
    fit.ship.boostItemAttr("agility", ship.getModifiedItemAttr("shipBonusMI2") * level)

########NEW FILE########
__FILENAME__ = shipbonusammobaymi2
# Used by:
# Ship: Hoarder
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Industrial").level
    fit.ship.boostItemAttr("specialAmmoHoldCapacity", ship.getModifiedItemAttr("shipBonusMI2") * level)

########NEW FILE########
__FILENAME__ = shipbonusaoevelocitycruiseandtorpedocb2
# Used by:
# Ship: Golem
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Battleship").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Cruise Missiles") or mod.charge.requiresSkill("Torpedoes"),
                                    "aoeVelocity", ship.getModifiedItemAttr("shipBonus2CB") * level)

########NEW FILE########
__FILENAME__ = shipbonusaoevelocitycruisemissilesmb2
# Used by:
# Ship: Typhoon
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Battleship").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Cruise Missiles"),
                                    "aoeVelocity", ship.getModifiedItemAttr("shipBonusMB2") * level)

########NEW FILE########
__FILENAME__ = shipbonusaoevelocityrocketscd2
# Used by:
# Ship: Corax
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Destroyer").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Rockets"),
                                    "aoeVelocity", ship.getModifiedItemAttr("shipBonusCD2") * level)

########NEW FILE########
__FILENAME__ = shipbonusaoevelocitystandardmissilescd2
# Used by:
# Ship: Corax
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Destroyer").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Light Missiles"),
                                    "aoeVelocity", ship.getModifiedItemAttr("shipBonusCD2") * level)

########NEW FILE########
__FILENAME__ = shipbonusarmorrepamountgc2
# Used by:
# Ship: Deimos
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Repair Systems"),
                                  "armorDamageAmount", ship.getModifiedItemAttr("shipBonusGC2") * level)

########NEW FILE########
__FILENAME__ = shipbonusarmorresistab
# Used by:
# Ships named like: Abaddon (2 of 2)
# Ship: Nestor
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Battleship").level
    for type in ("Em", "Explosive", "Kinetic", "Thermal"):
        fit.ship.boostItemAttr("armor{0}DamageResonance".format(type), ship.getModifiedItemAttr("shipBonusAB") * level)

########NEW FILE########
__FILENAME__ = shipbonuscapcapab
# Used by:
# Ship: Apocalypse Imperial Issue
# Ship: Paladin
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Battleship").level
    fit.ship.boostItemAttr("capacitorCapacity", ship.getModifiedItemAttr("shipBonusAB2") * level)

########NEW FILE########
__FILENAME__ = shipbonuscargo2gi
# Used by:
# Variations of ship: Miasmos (3 of 4)
# Variations of ship: Nereus (2 of 2)
# Ship: Iteron Mark V
# Ship: Occator
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Industrial").level
    # TODO: investigate if we can live without such ifs or hardcoding
    # Viator doesn't have GI bonus
    if "shipBonusGI" in fit.ship.item.attributes:
        bonusAttr = "shipBonusGI"
    else:
        bonusAttr = "shipBonusGI2"
    fit.ship.boostItemAttr("capacity", ship.getModifiedItemAttr(bonusAttr) * level)

########NEW FILE########
__FILENAME__ = shipbonuscargoci
# Used by:
# Variations of ship: Badger (2 of 2)
# Variations of ship: Tayra (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Industrial").level
    fit.ship.boostItemAttr("capacity", ship.getModifiedItemAttr("shipBonusCI") * level)

########NEW FILE########
__FILENAME__ = shipbonuscargomi
# Used by:
# Variations of ship: Mammoth (2 of 2)
# Variations of ship: Wreathe (2 of 2)
# Ship: Mammoth Nefantar Edition
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Industrial").level
    fit.ship.boostItemAttr("capacity", ship.getModifiedItemAttr("shipBonusMI") * level)

########NEW FILE########
__FILENAME__ = shipbonuscf1torpedoexplosionvelocity
# Used by:
# Ship: Manticore
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Frigate").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Torpedoes"),
                                    "aoeVelocity", ship.getModifiedItemAttr("shipBonusCF") * level)

########NEW FILE########
__FILENAME__ = shipbonuscf1torpedoflighttime
# Used by:
# Ship: Manticore
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Frigate").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Torpedoes"),
                                    "explosionDelay", ship.getModifiedItemAttr("shipBonusCF") * level)

########NEW FILE########
__FILENAME__ = shipbonuscruisemissileemdmgmb
# Used by:
# Ship: Typhoon Fleet Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Battleship").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Cruise Missiles"),
                                    "emDamage", ship.getModifiedItemAttr("shipBonusMB") * level)

########NEW FILE########
__FILENAME__ = shipbonuscruisemissileexplodmgmb
# Used by:
# Ship: Typhoon Fleet Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Battleship").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Cruise Missiles"),
                                    "explosiveDamage", ship.getModifiedItemAttr("shipBonusMB") * level)

########NEW FILE########
__FILENAME__ = shipbonuscruisemissilekineticdmgmb
# Used by:
# Ship: Typhoon Fleet Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Battleship").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Cruise Missiles"),
                                    "kineticDamage", ship.getModifiedItemAttr("shipBonusMB") * level)

########NEW FILE########
__FILENAME__ = shipbonuscruisemissilethermdmgmb
# Used by:
# Ship: Typhoon Fleet Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Battleship").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Cruise Missiles"),
                                    "thermalDamage", ship.getModifiedItemAttr("shipBonusMB") * level)

########NEW FILE########
__FILENAME__ = shipbonuscruiserofmb
# Used by:
# Ship: Typhoon
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Battleship").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Missile Launcher Cruise",
                                  "speed", ship.getModifiedItemAttr("shipBonusMB") * level)

########NEW FILE########
__FILENAME__ = shipbonusdreadcitadelcruiserofc1
# Used by:
# Ship: Phoenix
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Dreadnought").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Citadel Cruise Missiles"),
                                  "speed", ship.getModifiedItemAttr("dreadnoughtShipBonusC1") * level)

########NEW FILE########
__FILENAME__ = shipbonusdreadcitadeltorprofc1
# Used by:
# Ship: Phoenix
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Dreadnought").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Citadel Torpedoes"),
                                  "speed", ship.getModifiedItemAttr("dreadnoughtShipBonusC1") * level)

########NEW FILE########
__FILENAME__ = shipbonusdronearmorhitpointsab
# Used by:
# Ship: Armageddon
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Battleship").level
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                 "armorHP", ship.getModifiedItemAttr("shipBonusAB") * level)

########NEW FILE########
__FILENAME__ = shipbonusdronearmorhitpointsgf2
# Used by:
# Ship: Ishkur
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Frigate").level
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                 "armorHP", ship.getModifiedItemAttr("shipBonusGF2") * level)

########NEW FILE########
__FILENAME__ = shipbonusdronecapacitygf
# Used by:
# Ship: Worm
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Frigate").level
    fit.ship.increaseItemAttr("droneCapacity", ship.getModifiedItemAttr("shipBonusGF") * level)

########NEW FILE########
__FILENAME__ = shipbonusdronedamagegf2
# Used by:
# Ship: Utu
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Frigate").level
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                 "damageMultiplier", ship.getModifiedItemAttr("shipBonusGF2") * level)

########NEW FILE########
__FILENAME__ = shipbonusdronedamagemultiplierab
# Used by:
# Ship: Armageddon
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Battleship").level
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                 "damageMultiplier", ship.getModifiedItemAttr("shipBonusAB") * level)

########NEW FILE########
__FILENAME__ = shipbonusdronedamagemultiplierabc2
# Used by:
# Ship: Prophecy
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Battlecruiser").level
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                 "damageMultiplier", ship.getModifiedItemAttr("shipBonusABC2") * level)

########NEW FILE########
__FILENAME__ = shipbonusdronedamagemultiplierac2
# Used by:
# Variations of ship: Arbitrator (3 of 3)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Cruiser").level
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                 "damageMultiplier", ship.getModifiedItemAttr("shipBonusAC2") * level)

########NEW FILE########
__FILENAME__ = shipbonusdronedamagemultiplierad1
# Used by:
# Ship: Dragoon
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Destroyer").level
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                 "damageMultiplier", ship.getModifiedItemAttr("shipBonusAD1") * level)

########NEW FILE########
__FILENAME__ = shipbonusdronedamagemultipliergb2
# Used by:
# Variations of ship: Dominix (3 of 3)
# Ship: Nestor
# Ship: Rattlesnake
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Battleship").level
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                 "damageMultiplier", ship.getModifiedItemAttr("shipBonusGB2") * level)

########NEW FILE########
__FILENAME__ = shipbonusdronedamagemultipliergbc1
# Used by:
# Variations of ship: Myrmidon (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Battlecruiser").level
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                 "damageMultiplier", ship.getModifiedItemAttr("shipBonusGBC1") * level)

########NEW FILE########
__FILENAME__ = shipbonusdronedamagemultipliergc2
# Used by:
# Ships named like: Stratios (2 of 2)
# Variations of ship: Vexor (3 of 4)
# Ship: Gila
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Cruiser").level
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                 "damageMultiplier", ship.getModifiedItemAttr("shipBonusGC2") * level)

########NEW FILE########
__FILENAME__ = shipbonusdronedamagemultipliergd1
# Used by:
# Ship: Algos
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Destroyer").level
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                 "damageMultiplier", ship.getModifiedItemAttr("shipBonusGD1") * level)

########NEW FILE########
__FILENAME__ = shipbonusdronedamagemultiplierrookie
# Used by:
# Ship: Gnosis
# Ship: Taipan
# Ship: Velator
type = "passive"
def handler(fit, ship, context):
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                 "damageMultiplier", ship.getModifiedItemAttr("rookieDroneBonus"))

########NEW FILE########
__FILENAME__ = shipbonusdronehitpointsabc2
# Used by:
# Ship: Prophecy
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Battlecruiser").level
    for layer in ("shieldCapacity", "armorHP", "hp"):
        fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                     layer, ship.getModifiedItemAttr("shipBonusABC2") * level)

########NEW FILE########
__FILENAME__ = shipbonusdronehitpointsad1
# Used by:
# Ship: Dragoon
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Destroyer").level
    for layer in ("shieldCapacity", "armorHP", "hp"):
        fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                     layer, ship.getModifiedItemAttr("shipBonusAD1") * level)

########NEW FILE########
__FILENAME__ = shipbonusdronehitpointsfixedac2
# Used by:
# Variations of ship: Arbitrator (3 of 3)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Cruiser").level
    for type in ("shieldCapacity", "armorHP", "hp"):
        fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                     type, ship.getModifiedItemAttr("shipBonusAC2") * level)

########NEW FILE########
__FILENAME__ = shipbonusdronehitpointsgb2
# Used by:
# Variations of ship: Dominix (3 of 3)
# Ship: Nestor
# Ship: Rattlesnake
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Battleship").level
    for type in ("shieldCapacity", "armorHP", "hp"):
        fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                     type, ship.getModifiedItemAttr("shipBonusGB2") * level)

########NEW FILE########
__FILENAME__ = shipbonusdronehitpointsgbc1
# Used by:
# Variations of ship: Myrmidon (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Battlecruiser").level
    for layer in ("shieldCapacity", "armorHP", "hp"):
        fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                     layer, ship.getModifiedItemAttr("shipBonusGBC1") * level)

########NEW FILE########
__FILENAME__ = shipbonusdronehitpointsgc2
# Used by:
# Ships named like: Stratios (2 of 2)
# Variations of ship: Vexor (3 of 4)
# Ship: Gila
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Cruiser").level
    for type in ("shieldCapacity", "armorHP", "hp"):
        fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                     type, ship.getModifiedItemAttr("shipBonusGC2") * level)

########NEW FILE########
__FILENAME__ = shipbonusdronehitpointsgd1
# Used by:
# Ship: Algos
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Destroyer").level
    for layer in ("shieldCapacity", "armorHP", "hp"):
        fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                     layer, ship.getModifiedItemAttr("shipBonusGD1") * level)

########NEW FILE########
__FILENAME__ = shipbonusdronehitpointsgf
# Used by:
# Ship: Astero
# Ship: Tristan
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Frigate").level
    for layer in ("shieldCapacity", "armorHP", "hp"):
        fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                     layer, ship.getModifiedItemAttr("shipBonusGF") * level)

########NEW FILE########
__FILENAME__ = shipbonusdronehitpointsgf2
# Used by:
# Ship: Ishkur
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Frigate").level
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                 "hp", ship.getModifiedItemAttr("shipBonusGF2") * level)

########NEW FILE########
__FILENAME__ = shipbonusdronehitpointsrookie
# Used by:
# Ship: Gnosis
# Ship: Taipan
# Ship: Velator
type = "passive"
def handler(fit, ship, context):
    for type in ("shieldCapacity", "armorHP", "hp"):
        fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                     type, ship.getModifiedItemAttr("rookieDroneBonus"))
########NEW FILE########
__FILENAME__ = shipbonusdroneminingamountac2
# Used by:
# Ship: Arbitrator
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Cruiser").level
    fit.drones.filteredItemBoost(lambda drone: drone.item.group.name == "Mining Drone",
                                 "miningAmount", ship.getModifiedItemAttr("shipBonusAC2") * level)

########NEW FILE########
__FILENAME__ = shipbonusdroneminingamountgc2
# Used by:
# Ship: Vexor
# Ship: Vexor Navy Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Cruiser").level
    fit.drones.filteredItemBoost(lambda drone: drone.item.group.name == "Mining Drone",
                                 "miningAmount", ship.getModifiedItemAttr("shipBonusGC2") * level)

########NEW FILE########
__FILENAME__ = shipbonusdronemwdboostgc
# Used by:
# Ship: Vexor Navy Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Cruiser").level
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                 "maxVelocity", ship.getModifiedItemAttr("shipBonusGC") * level)

########NEW FILE########
__FILENAME__ = shipbonusdronemwdboostrole
# Used by:
# Ship: Algos
# Ship: Dragoon
type = "passive"
def handler(fit, ship, context):
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                 "maxVelocity", ship.getModifiedItemAttr("shipBonusPirateFaction"))

########NEW FILE########
__FILENAME__ = shipbonusdroneoptimalrangegb
# Used by:
# Ship: Dominix
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Battleship").level
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                 "maxRange", ship.getModifiedItemAttr("shipBonusGB") * level)

########NEW FILE########
__FILENAME__ = shipbonusdroneshieldhitpointsab
# Used by:
# Ship: Armageddon
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Battleship").level
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                 "shieldCapacity", ship.getModifiedItemAttr("shipBonusAB") * level)

########NEW FILE########
__FILENAME__ = shipbonusdroneshieldhitpointsgf2
# Used by:
# Ship: Ishkur
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Frigate").level
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                 "shieldCapacity", ship.getModifiedItemAttr("shipBonusGF2") * level)

########NEW FILE########
__FILENAME__ = shipbonusdronestructurehitpointsab
# Used by:
# Ship: Armageddon
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Battleship").level
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                 "hp", ship.getModifiedItemAttr("shipBonusAB") * level)

########NEW FILE########
__FILENAME__ = shipbonusdronetrackinggb
# Used by:
# Ship: Dominix
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Battleship").level
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                 "trackingSpeed", ship.getModifiedItemAttr("shipBonusGB") * level)

########NEW FILE########
__FILENAME__ = shipbonusdronetrackinggc
# Used by:
# Ship: Vexor Navy Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Cruiser").level
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                 "trackingSpeed", ship.getModifiedItemAttr("shipBonusGC") * level)

########NEW FILE########
__FILENAME__ = shipbonusdronetrackinggf
# Used by:
# Ship: Tristan
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Frigate").level
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                 "trackingSpeed", ship.getModifiedItemAttr("shipBonusGF") * level)

########NEW FILE########
__FILENAME__ = shipbonusecmstrengthbonuscc
# Used by:
# Ship: Blackbird
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Cruiser").level
    for type in ("Gravimetric", "Magnetometric", "Ladar", "Radar"):
        fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "ECM",
                                      "scan{0}StrengthBonus".format(type), ship.getModifiedItemAttr("shipBonusCC") * level)

########NEW FILE########
__FILENAME__ = shipbonuselitecover2torpedoemdamage
# Used by:
# Ship: Purifier
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Covert Ops").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Torpedoes"),
                                    "emDamage", ship.getModifiedItemAttr("eliteBonusCoverOps2") * level)

########NEW FILE########
__FILENAME__ = shipbonuselitecover2torpedoexplosivedamage
# Used by:
# Ship: Hound
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Covert Ops").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Torpedoes"),
                                    "explosiveDamage", ship.getModifiedItemAttr("eliteBonusCoverOps2") * level)

########NEW FILE########
__FILENAME__ = shipbonuselitecover2torpedokineticdamage
# Used by:
# Ship: Manticore
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Covert Ops").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Torpedoes"),
                                    "kineticDamage", ship.getModifiedItemAttr("eliteBonusCoverOps2") * level)

########NEW FILE########
__FILENAME__ = shipbonuselitecover2torpedothermaldamage
# Used by:
# Ship: Nemesis
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Covert Ops").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Torpedoes"),
                                    "thermalDamage", ship.getModifiedItemAttr("eliteBonusCoverOps2") * level)

########NEW FILE########
__FILENAME__ = shipbonusemshieldresistancecb2
# Used by:
# Ships named like: Rokh (2 of 2)
# Ship: Rattlesnake
# Ship: Scorpion Navy Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Battleship").level
    fit.ship.boostItemAttr("shieldEmDamageResonance", ship.getModifiedItemAttr("shipBonus2CB") * level)

########NEW FILE########
__FILENAME__ = shipbonusemshieldresistanceore3
# Used by:
# Ships from group: Exhumer (3 of 3)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Mining Barge").level
    fit.ship.boostItemAttr("shieldEmDamageResonance", ship.getModifiedItemAttr("shipBonusORE3") * level)
########NEW FILE########
__FILENAME__ = shipbonusenergyneutrangeab2
# Used by:
# Ship: Armageddon
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Battleship").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Energy Destabilizer",
                                  "energyDestabilizationRange", ship.getModifiedItemAttr("shipBonusAB2") * level)

########NEW FILE########
__FILENAME__ = shipbonusenergyneutrangead2
# Used by:
# Ship: Dragoon
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Destroyer").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Energy Destabilizer",
                                  "energyDestabilizationRange", ship.getModifiedItemAttr("shipBonusAD2") * level)

########NEW FILE########
__FILENAME__ = shipbonusenergyvampirerangeab2
# Used by:
# Ship: Armageddon
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Battleship").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Energy Vampire",
                                  "powerTransferRange", ship.getModifiedItemAttr("shipBonusAB2") * level)

########NEW FILE########
__FILENAME__ = shipbonusenergyvampirerangead2
# Used by:
# Ship: Dragoon
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Destroyer").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Energy Vampire",
                                  "powerTransferRange", ship.getModifiedItemAttr("shipBonusAD2") * level)

########NEW FILE########
__FILENAME__ = shipbonusewremotesensordampenerfalloffbonusgc1
# Used by:
# Ship: Celestis
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Sensor Damper",
                                  "falloff", ship.getModifiedItemAttr("shipBonusGC") * level)

########NEW FILE########
__FILENAME__ = shipbonusewremotesensordampenermaxtargetrangebonusgc2
# Used by:
# Variations of ship: Celestis (3 of 3)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Sensor Damper",
                                  "maxTargetRangeBonus", ship.getModifiedItemAttr("shipBonusGC2") * level)

########NEW FILE########
__FILENAME__ = shipbonusewremotesensordampenermaxtargetrangebonusgf2
# Used by:
# Variations of ship: Maulus (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Sensor Damper",
                                  "maxTargetRangeBonus", ship.getModifiedItemAttr("shipBonusGF2") * level)

########NEW FILE########
__FILENAME__ = shipbonusewremotesensordampenermaxtargetrangebonusrookie
# Used by:
# Ship: Velator
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Sensor Damper",
                                  "maxTargetRangeBonus", ship.getModifiedItemAttr("rookieDampStrengthBonus"))

########NEW FILE########
__FILENAME__ = shipbonusewremotesensordampeneroptimalbonusgc1
# Used by:
# Ship: Celestis
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Sensor Damper",
                                  "maxRange", ship.getModifiedItemAttr("shipBonusGC") * level)

########NEW FILE########
__FILENAME__ = shipbonusewremotesensordampenerscanresolutionbonusgc2
# Used by:
# Variations of ship: Celestis (3 of 3)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Sensor Damper",
                                  "scanResolutionBonus", ship.getModifiedItemAttr("shipBonusGC2") * level)

########NEW FILE########
__FILENAME__ = shipbonusewremotesensordampenerscanresolutionbonusgf2
# Used by:
# Variations of ship: Maulus (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Sensor Damper",
                                  "scanResolutionBonus", ship.getModifiedItemAttr("shipBonusGF2") * level)

########NEW FILE########
__FILENAME__ = shipbonusewremotesensordampenerscanresolutionbonusrookie
# Used by:
# Ship: Velator
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Sensor Damper",
                                  "scanResolutionBonus", ship.getModifiedItemAttr("rookieDampStrengthBonus"))

########NEW FILE########
__FILENAME__ = shipbonusewweapondisruptionrangedisruptionbonusac1
# Used by:
# Variations of ship: Arbitrator (3 of 3)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Weapon Disruption"),
                                  "maxRangeBonus", ship.getModifiedItemAttr("shipBonusAC") * level)
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Weapon Disruption"),
                                  "falloffBonus", ship.getModifiedItemAttr("shipBonusAC") * level)

########NEW FILE########
__FILENAME__ = shipbonusewweapondisruptionrangedisruptionbonusaf2
# Used by:
# Variations of ship: Crucifier (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Weapon Disruption"),
                                  "maxRangeBonus", ship.getModifiedItemAttr("shipBonus2AF") * level)
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Weapon Disruption"),
                                  "falloffBonus", ship.getModifiedItemAttr("shipBonus2AF") * level)

########NEW FILE########
__FILENAME__ = shipbonusewweapondisruptionrangedisruptionrookie
# Used by:
# Ship: Impairor
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Weapon Disruption"),
                                  "maxRangeBonus", ship.getModifiedItemAttr("rookieWeaponDisruptionBonus"))
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Weapon Disruption"),
                                  "falloffBonus", ship.getModifiedItemAttr("rookieWeaponDisruptionBonus"))

########NEW FILE########
__FILENAME__ = shipbonusewweapondisruptiontrackingspeedbonusac1
# Used by:
# Variations of ship: Arbitrator (3 of 3)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Tracking Disruptor",
                                  "trackingSpeedBonus", ship.getModifiedItemAttr("shipBonusAC") * level)

########NEW FILE########
__FILENAME__ = shipbonusewweapondisruptiontrackingspeedbonusaf1
# Used by:
# Ship: Crucifier
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Tracking Disruptor",
                                  "trackingSpeedBonus", ship.getModifiedItemAttr("shipBonusAF") * level)

########NEW FILE########
__FILENAME__ = shipbonusewweapondisruptiontrackingspeedbonusaf2
# Used by:
# Ship: Sentinel
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Tracking Disruptor",
                                  "trackingSpeedBonus", ship.getModifiedItemAttr("shipBonus2AF") * level)

########NEW FILE########
__FILENAME__ = shipbonusewweapondisruptiontrackingspeedbonusrookie
# Used by:
# Ship: Impairor
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Tracking Disruptor",
                                  "trackingSpeedBonus", ship.getModifiedItemAttr("rookieWeaponDisruptionBonus"))

########NEW FILE########
__FILENAME__ = shipbonusexplosiveshieldresistancecb2
# Used by:
# Ships named like: Rokh (2 of 2)
# Ship: Rattlesnake
# Ship: Scorpion Navy Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Battleship").level
    fit.ship.boostItemAttr("shieldExplosiveDamageResonance", ship.getModifiedItemAttr("shipBonus2CB") * level)

########NEW FILE########
__FILENAME__ = shipbonusexplosiveshieldresistanceore3
# Used by:
# Ships from group: Exhumer (3 of 3)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Mining Barge").level
    fit.ship.boostItemAttr("shieldExplosiveDamageResonance", ship.getModifiedItemAttr("shipBonusORE3") * level)
########NEW FILE########
__FILENAME__ = shipbonusfrigatesizedlightmissileexplosivedamagemd1
# Used by:
# Ship: Talwar
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Destroyer").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Light Missiles"),
                                    "explosiveDamage", ship.getModifiedItemAttr("shipBonusMD1") * level)

########NEW FILE########
__FILENAME__ = shipbonusfrigatesizedmissilekineticdamagecd1
# Used by:
# Ship: Corax
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Destroyer").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Light Missiles"),
                                    "kineticDamage", ship.getModifiedItemAttr("shipBonusCD1") * level)

########NEW FILE########
__FILENAME__ = shipbonusgf1torpedoflighttime
# Used by:
# Ship: Nemesis
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Frigate").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Torpedoes"),
                                    "explosionDelay", ship.getModifiedItemAttr("shipBonusGF") * level)

########NEW FILE########
__FILENAME__ = shipbonusgftorpedoexplosionvelocity
# Used by:
# Ship: Nemesis
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Frigate").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Torpedoes"),
                                    "aoeVelocity", ship.getModifiedItemAttr("shipBonusGF") * level)
########NEW FILE########
__FILENAME__ = shipbonushamvelocityelitebonusheavygunship1
# Used by:
# Ship: Sacrilege
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Heavy Assault Cruisers").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Assault Missiles"),
                                    "maxVelocity", ship.getModifiedItemAttr("eliteBonusHeavyGunship1") * level)

########NEW FILE########
__FILENAME__ = shipbonusheatdamageatf1
# Used by:
# Ship: Cambion
# Ship: Etana
# Ship: Utu
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: True, "heatDamage",
                                  ship.getModifiedItemAttr("shipBonusATF1"))

########NEW FILE########
__FILENAME__ = shipbonusheavyassaultlauncherrateoffirecc2
# Used by:
# Ship: Rook
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Missile Launcher Heavy Assault",
                                  "speed", ship.getModifiedItemAttr("shipBonusCC2") * level)

########NEW FILE########
__FILENAME__ = shipbonusheavyassaultmissilekineticdamagecbc1
# Used by:
# Ship: Drake
# Ship: Nighthawk
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Battlecruiser").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Assault Missiles"),
                                    "kineticDamage", ship.getModifiedItemAttr("shipBonusCBC1") * level)

########NEW FILE########
__FILENAME__ = shipbonusheavyassaultmissilelauncherrofmbc2
# Used by:
# Variations of ship: Cyclone (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Battlecruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Missile Launcher Heavy Assault",
                                  "speed", ship.getModifiedItemAttr("shipBonusMBC2") * level)

########NEW FILE########
__FILENAME__ = shipbonusheavydronespeedgc
# Used by:
# Ship: Ishtar
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Cruiser").level
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Heavy Drone Operation"),
                                 "maxVelocity", ship.getModifiedItemAttr("shipBonusGC") * level)

########NEW FILE########
__FILENAME__ = shipbonusheavydronetrackinggc
# Used by:
# Ship: Ishtar
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Cruiser").level
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Heavy Drone Operation"),
                                 "trackingSpeed", ship.getModifiedItemAttr("shipBonusGC") * level)

########NEW FILE########
__FILENAME__ = shipbonusheavylauncherrateoffirecc2
# Used by:
# Ship: Rook
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Missile Launcher Heavy",
                                  "speed", ship.getModifiedItemAttr("shipBonusCC2") * level)

########NEW FILE########
__FILENAME__ = shipbonusheavymissileemdmgmb
# Used by:
# Ship: Typhoon Fleet Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Battleship").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Missiles"),
                                    "emDamage", ship.getModifiedItemAttr("shipBonusMB") * level)

########NEW FILE########
__FILENAME__ = shipbonusheavymissileexplodmgmb
# Used by:
# Ship: Typhoon Fleet Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Battleship").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Missiles"),
                                    "explosiveDamage", ship.getModifiedItemAttr("shipBonusMB") * level)

########NEW FILE########
__FILENAME__ = shipbonusheavymissilekineticdamagecbc1
# Used by:
# Ship: Drake
# Ship: Nighthawk
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Battlecruiser").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Missiles"),
                                    "kineticDamage", ship.getModifiedItemAttr("shipBonusCBC1") * level)

########NEW FILE########
__FILENAME__ = shipbonusheavymissilekineticdmgmb
# Used by:
# Ship: Typhoon Fleet Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Battleship").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Missiles"),
                                    "kineticDamage", ship.getModifiedItemAttr("shipBonusMB") * level)

########NEW FILE########
__FILENAME__ = shipbonusheavymissilelauncherrofmbc2
# Used by:
# Variations of ship: Cyclone (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Battlecruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Missile Launcher Heavy",
                                  "speed", ship.getModifiedItemAttr("shipBonusMBC2") * level)

########NEW FILE########
__FILENAME__ = shipbonusheavymissilethermdmgmb
# Used by:
# Ship: Typhoon Fleet Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Battleship").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Missiles"),
                                    "thermalDamage", ship.getModifiedItemAttr("shipBonusMB") * level)

########NEW FILE########
__FILENAME__ = shipbonushmlemdamageac
# Used by:
# Ship: Sacrilege
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Cruiser").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Missiles"),
                                    "emDamage", ship.getModifiedItemAttr("shipBonusAC") * level)

########NEW FILE########
__FILENAME__ = shipbonushmlexplodamageac
# Used by:
# Ship: Sacrilege
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Cruiser").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Missiles"),
                                    "explosiveDamage", ship.getModifiedItemAttr("shipBonusAC") * level)

########NEW FILE########
__FILENAME__ = shipbonushmlkineticdamageac
# Used by:
# Ship: Sacrilege
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Cruiser").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Missiles"),
                                    "kineticDamage", ship.getModifiedItemAttr("shipBonusAC") * level)

########NEW FILE########
__FILENAME__ = shipbonushmlthermdamageac
# Used by:
# Ship: Sacrilege
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Cruiser").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Missiles"),
                                    "thermalDamage", ship.getModifiedItemAttr("shipBonusAC") * level)

########NEW FILE########
__FILENAME__ = shipbonushmlvelocityelitebonusheavygunship1
# Used by:
# Ship: Sacrilege
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Heavy Assault Cruisers").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Missiles"),
                                    "maxVelocity", ship.getModifiedItemAttr("eliteBonusHeavyGunship1") * level)

########NEW FILE########
__FILENAME__ = shipbonushtfalloffgb2
# Used by:
# Ship: Kronos
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Battleship").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Hybrid Turret"),
                                  "falloff", ship.getModifiedItemAttr("shipBonusGB2") * level)

########NEW FILE########
__FILENAME__ = shipbonushybridfalloffatc2
# Used by:
# Ship: Adrestia
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Hybrid Turret"),
                                  "falloff", ship.getModifiedItemAttr("shipBonusATC2"))

########NEW FILE########
__FILENAME__ = shipbonushybridoptimalcb
# Used by:
# Ships named like: Rokh (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Battleship").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Hybrid Turret"),
                                  "maxRange", ship.getModifiedItemAttr("shipBonusCB") * level)

########NEW FILE########
__FILENAME__ = shipbonushybridtrackingatc2
# Used by:
# Ship: Adrestia
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Hybrid Turret"),
                                  "trackingSpeed", ship.getModifiedItemAttr("shipBonusATC2"))

########NEW FILE########
__FILENAME__ = shipbonushybridtrackinggf2
# Used by:
# Ship: Ares
# Ship: Federation Navy Comet
# Ship: Police Pursuit Comet
# Ship: Tristan
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Hybrid Turret"),
                                    "trackingSpeed", ship.getModifiedItemAttr("shipBonusGF2") * level)

########NEW FILE########
__FILENAME__ = shipbonusiceharvesterdurationore3
# Used by:
# Ship: Covetor
type = "passive"
def handler(fit, container, context):
    level = fit.character.getSkill("Mining Barge").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Ice Harvesting"),
                                  "duration", container.getModifiedItemAttr("shipBonusORE3") * level)
########NEW FILE########
__FILENAME__ = shipbonuskineticshieldresistancecb2
# Used by:
# Ships named like: Rokh (2 of 2)
# Ship: Rattlesnake
# Ship: Scorpion Navy Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Battleship").level
    fit.ship.boostItemAttr("shieldKineticDamageResonance", ship.getModifiedItemAttr("shipBonus2CB") * level)

########NEW FILE########
__FILENAME__ = shipbonuskineticshieldresistanceore3
# Used by:
# Ships from group: Exhumer (3 of 3)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Mining Barge").level
    fit.ship.boostItemAttr("shieldKineticDamageResonance", ship.getModifiedItemAttr("shipBonusORE3") * level)
########NEW FILE########
__FILENAME__ = shipbonuslargeenergyturretdamagecb2
# Used by:
# Ship: Nightmare
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Battleship").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Energy Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("shipBonus2CB") * level)

########NEW FILE########
__FILENAME__ = shipbonuslargeenergyturretmaxrangeab
# Used by:
# Ship: Paladin
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Battleship").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Energy Turret"),
                                  "maxRange", ship.getModifiedItemAttr("shipBonusAB") * level)

########NEW FILE########
__FILENAME__ = shipbonuslargeenergyturretmaxrangeab2
# Used by:
# Ship: Apocalypse
# Ship: Apocalypse Navy Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Battleship").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Energy Turret"),
                                  "maxRange", ship.getModifiedItemAttr("shipBonusAB2") * level)

########NEW FILE########
__FILENAME__ = shipbonuslargeenergyturrettrackingab
# Used by:
# Ship: Apocalypse
# Ship: Apocalypse Navy Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Battleship").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Energy Turret"),
                                  "trackingSpeed", ship.getModifiedItemAttr("shipBonusAB") * level)

########NEW FILE########
__FILENAME__ = shipbonuslargeenergyweapondamageab2
# Used by:
# Ships named like: Abaddon (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Battleship").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Energy Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("shipBonusAB2") * level)

########NEW FILE########
__FILENAME__ = shipbonusletoptimalrangepiratefaction
# Used by:
# Ship: Nestor
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Energy Turret"),
                                  "maxRange", ship.getModifiedItemAttr("shipBonusPirateFaction"))

########NEW FILE########
__FILENAME__ = shipbonusmediumenergyturretdamagecc2
# Used by:
# Ship: Phantasm
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Energy Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("shipBonusCC2") * level)

########NEW FILE########
__FILENAME__ = shipbonusmediumenergyturretdamagepiratefaction
# Used by:
# Ship: Ashimmu
# Ship: Gnosis
# Ship: Phantasm
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Energy Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("shipBonusPirateFaction"))

########NEW FILE########
__FILENAME__ = shipbonusmediumenergyturrettrackingac2
# Used by:
# Ship: Phantasm
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Energy Turret"),
                                  "trackingSpeed", ship.getModifiedItemAttr("shipBonusAC2") * level)

########NEW FILE########
__FILENAME__ = shipbonusmediumhybriddmgcc2
# Used by:
# Ship: Falcon
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Hybrid Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("shipBonusCC2") * level)

########NEW FILE########
__FILENAME__ = shipbonusmetoptimalac2
# Used by:
# Ship: Omen Navy Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Energy Turret"),
                                  "maxRange", ship.getModifiedItemAttr("shipBonusAC2") * level)

########NEW FILE########
__FILENAME__ = shipbonusmetoptimalrangepiratefaction
# Used by:
# Ships named like: Stratios (2 of 2)
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Energy Turret"),
                                  "maxRange", ship.getModifiedItemAttr("shipBonusPirateFaction"))

########NEW FILE########
__FILENAME__ = shipbonusmf1torpedoexplosionvelocity
# Used by:
# Ship: Hound
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Frigate").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Torpedoes"),
                                    "aoeVelocity", ship.getModifiedItemAttr("shipBonusMF") * level)
########NEW FILE########
__FILENAME__ = shipbonusmf1torpedoflighttime
# Used by:
# Ship: Hound
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Frigate").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Torpedoes"),
                                    "explosionDelay", ship.getModifiedItemAttr("shipBonusMF") * level)

########NEW FILE########
__FILENAME__ = shipbonusmineralbaygi2
# Used by:
# Ship: Kryos
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Industrial").level
    fit.ship.boostItemAttr("specialMineralHoldCapacity", ship.getModifiedItemAttr("shipBonusGI2") * level)

########NEW FILE########
__FILENAME__ = shipbonusminingdroneamountpercentrookie
# Used by:
# Ship: Gnosis
# Ship: Taipan
# Ship: Velator
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.drones.filteredItemBoost(lambda drone: drone.item.group.name == "Mining Drone",
                                 "miningAmount", container.getModifiedItemAttr("rookieDroneBonus"))

########NEW FILE########
__FILENAME__ = shipbonusmissileaoevelocitymb2
# Used by:
# Ship: Typhoon
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Battleship").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Torpedoes"),
                                    "aoeVelocity", ship.getModifiedItemAttr("shipBonusMB2") * level)

########NEW FILE########
__FILENAME__ = shipbonusmissilekineticlatf2
# Used by:
# Ship: Cambion
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Missile Launcher Operation"),
                                    "kineticDamage", ship.getModifiedItemAttr("shipBonusATF2"))

########NEW FILE########
__FILENAME__ = shipbonusmissilelauncherassaultrofatc1
# Used by:
# Ship: Vangel
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Missile Launcher Rapid Light",
                                  "speed", ship.getModifiedItemAttr("shipBonusATC1"))

########NEW FILE########
__FILENAME__ = shipbonusmissilelauncherheavyassaultrofatc1
# Used by:
# Ship: Vangel
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Missile Launcher Heavy Assault",
                                  "speed", ship.getModifiedItemAttr("shipBonusATC1"))

########NEW FILE########
__FILENAME__ = shipbonusmissilelauncherheavyrofatc1
# Used by:
# Ship: Vangel
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Missile Launcher Heavy",
                                  "speed", ship.getModifiedItemAttr("shipBonusATC1"))

########NEW FILE########
__FILENAME__ = shipbonusmissilevelocityad2
# Used by:
# Ship: Heretic
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Destroyer").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Missile Launcher Operation"),
                                    "maxVelocity", ship.getModifiedItemAttr("shipBonusAD2") * level)

########NEW FILE########
__FILENAME__ = shipbonusmissilevelocitycc2
# Used by:
# Ship: Cerberus
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Cruiser").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Missile Launcher Operation"),
                                    "maxVelocity", ship.getModifiedItemAttr("shipBonusCC2") * level)

########NEW FILE########
__FILENAME__ = shipbonusmwdsignatureradiusmd2
# Used by:
# Ship: Talwar
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Destroyer").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("High Speed Maneuvering"),
                                  "signatureRadiusBonus", ship.getModifiedItemAttr("shipBonusMD2") * level)

########NEW FILE########
__FILENAME__ = shipbonusnoctissalvagecycle
# Used by:
# Ship: Noctis
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("ORE Industrial").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Salvaging"),
                                  "duration", ship.getModifiedItemAttr("shipBonusOreIndustrial1") * level)

########NEW FILE########
__FILENAME__ = shipbonusnoctistractorcycle
# Used by:
# Ship: Noctis
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("ORE Industrial").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Tractor Beam",
                                  "duration", ship.getModifiedItemAttr("shipBonusOreIndustrial1") * level)

########NEW FILE########
__FILENAME__ = shipbonusnoctistractorrange
# Used by:
# Ship: Noctis
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("ORE Industrial").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Tractor Beam",
                                  "maxRange", ship.getModifiedItemAttr("shipBonusOreIndustrial2") * level)

########NEW FILE########
__FILENAME__ = shipbonusnoctistractorvelocity
# Used by:
# Ship: Noctis
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("ORE Industrial").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Tractor Beam",
                                  "maxTractorVelocity", ship.getModifiedItemAttr("shipBonusOreIndustrial2") * level)

########NEW FILE########
__FILENAME__ = shipbonusorecapacitygi2
# Used by:
# Ship: Miasmos
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Industrial").level
    fit.ship.boostItemAttr("specialOreHoldCapacity", ship.getModifiedItemAttr("shipBonusGI2") * level)

########NEW FILE########
__FILENAME__ = shipbonusorecapshipdronearmorhpandshieldhpandhpbonus
# Used by:
# Ship: Rorqual
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Capital Industrial Ships").level
    for type in ("shieldCapacity", "armorHP", "hp"):
        fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                     type, ship.getModifiedItemAttr("shipBonusORECapital4") * level)

########NEW FILE########
__FILENAME__ = shipbonusorecapshipdronedmgbonus
# Used by:
# Ship: Rorqual
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Capital Industrial Ships").level
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                 "damageMultiplier", ship.getModifiedItemAttr("shipBonusORECapital4") * level)

########NEW FILE########
__FILENAME__ = shipbonusoreholdore2
# Used by:
# Variations of ship: Retriever (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Mining Barge").level
    fit.ship.boostItemAttr("specialOreHoldCapacity", ship.getModifiedItemAttr("shipBonusORE2") * level)
########NEW FILE########
__FILENAME__ = shipbonuspicommoditiesholdgi2
# Used by:
# Ship: Epithal
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Industrial").level
    fit.ship.boostItemAttr("specialPlanetaryCommoditiesHoldCapacity", ship.getModifiedItemAttr("shipBonusGI2") * level)

########NEW FILE########
__FILENAME__ = shipbonuspiratefrigateprojdamage
# Used by:
# Ship: Chremoas
# Ship: Dramiel
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Projectile Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("shipBonusPirateFaction"))

########NEW FILE########
__FILENAME__ = shipbonuspiratesmallhybriddmg
# Used by:
# Ship: Daredevil
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Hybrid Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("shipBonusPirateFaction"))

########NEW FILE########
__FILENAME__ = shipbonusprojectiledamagembc1
# Used by:
# Ships named like: Hurricane (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Battlecruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Projectile Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("shipBonusMBC1") * level)

########NEW FILE########
__FILENAME__ = shipbonusprojectiledamagembc2
# Used by:
# Ship: Sleipnir
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Battlecruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Projectile Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("shipBonusMBC2") * level)

########NEW FILE########
__FILENAME__ = shipbonusprojectiletrackingmc2
# Used by:
# Ship: Stabber Fleet Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Projectile Turret"),
                                  "trackingSpeed", ship.getModifiedItemAttr("shipBonusMC2") * level)

########NEW FILE########
__FILENAME__ = shipbonusptfalloffmb1
# Used by:
# Ship: Vargur
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Battleship").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Projectile Turret"),
                                  "falloff", ship.getModifiedItemAttr("shipBonusMB") * level)

########NEW FILE########
__FILENAME__ = shipbonusremotearmorrepairamount2af
# Used by:
# Ship: Inquisitor
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Armor Repairer",
                                  "armorDamageAmount", ship.getModifiedItemAttr("shipBonus2AF") * level)

########NEW FILE########
__FILENAME__ = shipbonusremotearmorrepairamountac2
# Used by:
# Ship: Augoror
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Armor Repairer",
                                  "armorDamageAmount", ship.getModifiedItemAttr("shipBonusAC2") * level)

########NEW FILE########
__FILENAME__ = shipbonusremotearmorrepairamountgc2
# Used by:
# Ship: Exequror
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Armor Repairer",
                                  "armorDamageAmount", ship.getModifiedItemAttr("shipBonusGC2") * level)

########NEW FILE########
__FILENAME__ = shipbonusremotearmorrepairamountgf2
# Used by:
# Ship: Navitas
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Armor Repairer",
                                  "armorDamageAmount", ship.getModifiedItemAttr("shipBonusGF2") * level)

########NEW FILE########
__FILENAME__ = shipbonusremotearmorrepaircapneedac1
# Used by:
# Ship: Augoror
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Armor Repairer",
                                  "capacitorNeed", ship.getModifiedItemAttr("shipBonusAC") * level)

########NEW FILE########
__FILENAME__ = shipbonusremotearmorrepaircapneedaf
# Used by:
# Ship: Inquisitor
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Armor Repairer",
                                  "capacitorNeed", ship.getModifiedItemAttr("shipBonusAF") * level)

########NEW FILE########
__FILENAME__ = shipbonusremotearmorrepaircapneedgc1
# Used by:
# Ship: Exequror
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Armor Repairer",
                                  "capacitorNeed", ship.getModifiedItemAttr("shipBonusGC") * level)

########NEW FILE########
__FILENAME__ = shipbonusremotearmorrepaircapneedgf
# Used by:
# Ship: Navitas
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Armor Repairer",
                                  "capacitorNeed", ship.getModifiedItemAttr("shipBonusGF") * level)

########NEW FILE########
__FILENAME__ = shipbonusremoterepairamountpiratefaction
# Used by:
# Ship: Nestor
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Remote Armor Repair Systems"),
                                  "armorDamageAmount", ship.getModifiedItemAttr("shipBonusPirateFaction"))

########NEW FILE########
__FILENAME__ = shipbonusremoterepairrangepiratefaction2
# Used by:
# Ship: Nestor
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Remote Armor Repair Systems"),
                                  "maxRange", ship.getModifiedItemAttr("shipBonusPirateFaction2"))

########NEW FILE########
__FILENAME__ = shipbonusrepairsystemsarmorrepairamountgb2
# Used by:
# Ships named like: Hyperion (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Battleship").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Repair Systems"),
                                  "armorDamageAmount", ship.getModifiedItemAttr("shipBonusGB2") * level)

########NEW FILE########
__FILENAME__ = shipbonusrepairsystemsbonusatc2
# Used by:
# Ship: Vangel
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Repair Systems"),
                                  "armorDamageAmount", ship.getModifiedItemAttr("shipBonusATC2"))

########NEW FILE########
__FILENAME__ = shipbonusrhmlrof2cb
# Used by:
# Ship: Raven
# Ship: Widow
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Battleship").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Missile Launcher Rapid Heavy",
                                  "speed", ship.getModifiedItemAttr("shipBonus2CB") * level)

########NEW FILE########
__FILENAME__ = shipbonusrhmlrofmb
# Used by:
# Ship: Typhoon
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Battleship").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Missile Launcher Rapid Heavy",
                                  "speed", ship.getModifiedItemAttr("shipBonusMB") * level)

########NEW FILE########
__FILENAME__ = shipbonussalvagecycleaf
# Used by:
# Variations of ship: Magnate (3 of 6)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Salvaging"),
                                  "duration", ship.getModifiedItemAttr("shipBonusAF") * level)

########NEW FILE########
__FILENAME__ = shipbonussalvagecyclecf
# Used by:
# Ships named like: Heron (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Salvaging"),
                                  "duration", ship.getModifiedItemAttr("shipBonusCF") * level)

########NEW FILE########
__FILENAME__ = shipbonussalvagecyclegf
# Used by:
# Ships named like: Imicus (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Salvaging"),
                                  "duration", ship.getModifiedItemAttr("shipBonusGF") * level)

########NEW FILE########
__FILENAME__ = shipbonussalvagecyclemf
# Used by:
# Ships named like: Probe (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Salvaging"),
                                  "duration", ship.getModifiedItemAttr("shipBonusMF") * level)

########NEW FILE########
__FILENAME__ = shipbonusscanprobestrength2af
# Used by:
# Variations of ship: Magnate (3 of 6)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Frigate").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.group.name == "Scanner Probe",
                                    "baseSensorStrength", ship.getModifiedItemAttr("shipBonus2AF") * level)

########NEW FILE########
__FILENAME__ = shipbonusscanprobestrengthcf
# Used by:
# Ships named like: Heron (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Frigate").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.group.name == "Scanner Probe",
                                    "baseSensorStrength", ship.getModifiedItemAttr("shipBonusCF2") * level)
########NEW FILE########
__FILENAME__ = shipbonusscanprobestrengthgf
# Used by:
# Ships named like: Imicus (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Frigate").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.group.name == "Scanner Probe",
                                    "baseSensorStrength", ship.getModifiedItemAttr("shipBonusGF2") * level)

########NEW FILE########
__FILENAME__ = shipbonusscanprobestrengthmf
# Used by:
# Ships named like: Probe (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Frigate").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.group.name == "Scanner Probe",
                                    "baseSensorStrength", ship.getModifiedItemAttr("shipBonusMF2") * level)

########NEW FILE########
__FILENAME__ = shipbonussentrydroneoptimalrangeelitebonusheavygunship2
# Used by:
# Ship: Ishtar
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Heavy Assault Cruisers").level
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Sentry Drone Interfacing"),
                                 "maxRange", ship.getModifiedItemAttr("eliteBonusHeavyGunship2") * level)

########NEW FILE########
__FILENAME__ = shipbonussentrydronetrackingelitebonusheavygunship2
# Used by:
# Ship: Ishtar
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Heavy Assault Cruisers").level
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Sentry Drone Interfacing"),
                                 "trackingSpeed", ship.getModifiedItemAttr("eliteBonusHeavyGunship2") * level)

########NEW FILE########
__FILENAME__ = shipbonusshieldboostamountmc2
# Used by:
# Ship: Vagabond
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Shield Operation"),
                                  "shieldBonus", ship.getModifiedItemAttr("shipBonusMC2") * level)

########NEW FILE########
__FILENAME__ = shipbonusshieldboostermb1a
# Used by:
# Ships named like: Maelstrom (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Battleship").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Shield Booster",
                                  "shieldBonus", ship.getModifiedItemAttr("shipBonusMB") * level)

########NEW FILE########
__FILENAME__ = shipbonusshieldcapacityore2
# Used by:
# Variations of ship: Procurer (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Mining Barge").level
    fit.ship.boostItemAttr("shieldCapacity", ship.getModifiedItemAttr("shipBonusORE2") * level)

########NEW FILE########
__FILENAME__ = shipbonusshieldtransferboostamountcc2
# Used by:
# Ship: Osprey
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Shield Emission Systems"),
                                  "shieldBonus", ship.getModifiedItemAttr("shipBonusCC2") * level)

########NEW FILE########
__FILENAME__ = shipbonusshieldtransferboostamountcf2
# Used by:
# Ship: Bantam
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Shield Emission Systems"),
                                  "shieldBonus", ship.getModifiedItemAttr("shipBonusCF2") * level)

########NEW FILE########
__FILENAME__ = shipbonusshieldtransferboostamountmc2
# Used by:
# Ship: Scythe
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Shield Emission Systems"),
                                  "shieldBonus", ship.getModifiedItemAttr("shipBonusMC2") * level)

########NEW FILE########
__FILENAME__ = shipbonusshieldtransferboostamountmf2
# Used by:
# Ship: Burst
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Shield Emission Systems"),
                                  "shieldBonus", ship.getModifiedItemAttr("shipBonusMF2") * level)

########NEW FILE########
__FILENAME__ = shipbonusshieldtransfercapneed1
# Used by:
# Ship: Osprey
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Shield Booster",
                                  "capacitorNeed", ship.getModifiedItemAttr("shipBonusCC") * level)

########NEW FILE########
__FILENAME__ = shipbonusshieldtransfercapneedcf
# Used by:
# Ship: Bantam
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Shield Emission Systems"),
                                  "capacitorNeed", ship.getModifiedItemAttr("shipBonusCF") * level)

########NEW FILE########
__FILENAME__ = shipbonusshieldtransfercapneedmc1
# Used by:
# Ship: Scythe
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Shield Emission Systems"),
                                  "capacitorNeed", ship.getModifiedItemAttr("shipBonusMC") * level)

########NEW FILE########
__FILENAME__ = shipbonusshieldtransfercapneedmf
# Used by:
# Ship: Burst
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Shield Emission Systems"),
                                  "capacitorNeed", ship.getModifiedItemAttr("shipBonusMF") * level)

########NEW FILE########
__FILENAME__ = shipbonussmallenergyturretdamageatf1
# Used by:
# Ship: Malice
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Energy Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("shipBonusATF1"))

########NEW FILE########
__FILENAME__ = shipbonussmallenergyturretdamagecf2
# Used by:
# Ship: Succubus
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Energy Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("shipBonusCF2") * level)

########NEW FILE########
__FILENAME__ = shipbonussmallenergyturretdamagepiratefaction
# Used by:
# Ship: Cruor
# Ship: Succubus
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Energy Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("shipBonusPirateFaction"))

########NEW FILE########
__FILENAME__ = shipbonussmallenergyturrettracking2af
# Used by:
# Ship: Succubus
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Energy Turret"),
                                  "trackingSpeed", ship.getModifiedItemAttr("shipBonus2AF") * level)

########NEW FILE########
__FILENAME__ = shipbonussmallenergyweaponoptimalrangeatf2
# Used by:
# Ship: Malice
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Energy Turret"),
                                  "maxRange", ship.getModifiedItemAttr("shipBonusATF2"))

########NEW FILE########
__FILENAME__ = shipbonussmallhybridmaxrangeatf2
# Used by:
# Ship: Utu
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Hybrid Turret"),
                                  "maxRange", ship.getModifiedItemAttr("shipBonusATF2"))

########NEW FILE########
__FILENAME__ = shipbonussmallhybridtrackingspeedatf2
# Used by:
# Ship: Utu
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Hybrid Turret"),
                                  "trackingSpeed", ship.getModifiedItemAttr("shipBonusATF2"))

########NEW FILE########
__FILENAME__ = shipbonussmallmissileexplosionradiuscd2
# Used by:
# Ship: Flycatcher
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Destroyer").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Rockets") or mod.charge.requiresSkill("Light Missiles"),
                                    "aoeCloudSize", ship.getModifiedItemAttr("shipBonusCD2") * level)

########NEW FILE########
__FILENAME__ = shipbonussptfalloffmf2
# Used by:
# Ships named like: Rifter (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Projectile Turret"),
                                  "falloff", ship.getModifiedItemAttr("shipBonusMF2") * level)

########NEW FILE########
__FILENAME__ = shipbonusstasismf2
# Used by:
# Ship: Freki
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Stasis Web",
                                  "maxRange", ship.getModifiedItemAttr("shipBonusMF2") * level)

########NEW FILE########
__FILENAME__ = shipbonusstasiswebspeedfactormb
# Used by:
# Ship: Vindicator
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Battleship").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Stasis Web",
                                  "speedFactor", ship.getModifiedItemAttr("shipBonusMB") * level)

########NEW FILE########
__FILENAME__ = shipbonusstrategiccruiseramarrheatdamage
# Used by:
# Ship: Legion
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Strategic Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: True, "heatDamage",
                                  ship.getModifiedItemAttr("shipBonusStrategicCruiserAmarr") * level)

########NEW FILE########
__FILENAME__ = shipbonusstrategiccruisercaldariheatdamage
# Used by:
# Ship: Tengu
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Strategic Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: True, "heatDamage",
                                  ship.getModifiedItemAttr("shipBonusStrategicCruiserCaldari") * level)

########NEW FILE########
__FILENAME__ = shipbonusstrategiccruisergallenteheatdamage
# Used by:
# Ship: Proteus
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Strategic Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: True, "heatDamage",
                                  ship.getModifiedItemAttr("shipBonusStrategicCruiserGallente") * level)

########NEW FILE########
__FILENAME__ = shipbonusstrategiccruiserminmatarheatdamage
# Used by:
# Ship: Loki
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Strategic Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: True, "heatDamage",
                                  ship.getModifiedItemAttr("shipBonusStrategicCruiserMinmatar") * level)

########NEW FILE########
__FILENAME__ = shipbonussurveyprobeexplosiondelayskillsurveycovertops3
# Used by:
# Ships from group: Covert Ops (4 of 5)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Covert Ops").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.group.name == "Survey Probe",
                                    "explosionDelay", ship.getModifiedItemAttr("eliteBonusCoverOps3") * level)

########NEW FILE########
__FILENAME__ = shipbonustargetpainteroptimalmf1
# Used by:
# Variations of ship: Vigil (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Target Painting"),
                                  "maxRange", ship.getModifiedItemAttr("shipBonusMF") * level)

########NEW FILE########
__FILENAME__ = shipbonustdoptimalbonusaf2
# Used by:
# Ship: Crucifier
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Tracking Disruptor",
                                  "maxRange", ship.getModifiedItemAttr("shipBonus2AF") * level)

########NEW FILE########
__FILENAME__ = shipbonusthermicshieldresistancecb2
# Used by:
# Ships named like: Rokh (2 of 2)
# Ship: Rattlesnake
# Ship: Scorpion Navy Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Battleship").level
    fit.ship.boostItemAttr("shieldThermalDamageResonance", ship.getModifiedItemAttr("shipBonus2CB") * level)

########NEW FILE########
__FILENAME__ = shipbonusthermicshieldresistanceore3
# Used by:
# Ships from group: Exhumer (3 of 3)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Mining Barge").level
    fit.ship.boostItemAttr("shieldThermalDamageResonance", ship.getModifiedItemAttr("shipBonusORE3") * level)

########NEW FILE########
__FILENAME__ = shipbonustorpedomissileemdmgmb
# Used by:
# Ship: Typhoon Fleet Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Battleship").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Torpedoes"),
                                    "emDamage", ship.getModifiedItemAttr("shipBonusMB") * level)

########NEW FILE########
__FILENAME__ = shipbonustorpedomissileexplodmgmb
# Used by:
# Ship: Typhoon Fleet Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Battleship").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Torpedoes"),
                                    "explosiveDamage", ship.getModifiedItemAttr("shipBonusMB") * level)

########NEW FILE########
__FILENAME__ = shipbonustorpedomissilekineticdmgmb
# Used by:
# Ship: Typhoon Fleet Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Battleship").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Torpedoes"),
                                    "kineticDamage", ship.getModifiedItemAttr("shipBonusMB") * level)

########NEW FILE########
__FILENAME__ = shipbonustorpedomissilethermdmgmb
# Used by:
# Ship: Typhoon Fleet Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Battleship").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Torpedoes"),
                                    "thermalDamage", ship.getModifiedItemAttr("shipBonusMB") * level)

########NEW FILE########
__FILENAME__ = shipbonustorpedorofmb
# Used by:
# Ship: Typhoon
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Battleship").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Missile Launcher Torpedo",
                                  "speed", ship.getModifiedItemAttr("shipBonusMB") * level)

########NEW FILE########
__FILENAME__ = shipbonustorpedovelocity2af
# Used by:
# Ship: Purifier
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Frigate").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Torpedoes"),
                                    "maxVelocity", ship.getModifiedItemAttr("shipBonus2AF") * level)

########NEW FILE########
__FILENAME__ = shipbonustorpedovelocitycf2
# Used by:
# Ship: Manticore
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Frigate").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Torpedoes"),
                                    "maxVelocity", ship.getModifiedItemAttr("shipBonusCF2") * level)

########NEW FILE########
__FILENAME__ = shipbonustorpedovelocitygf2
# Used by:
# Ship: Nemesis
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Frigate").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Torpedoes"),
                                    "maxVelocity", ship.getModifiedItemAttr("shipBonusGF2") * level)

########NEW FILE########
__FILENAME__ = shipbonustorpedovelocitymf2
# Used by:
# Ship: Hound
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Frigate").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Torpedoes"),
                                    "maxVelocity", ship.getModifiedItemAttr("shipBonusMF2") * level)

########NEW FILE########
__FILENAME__ = shipbonusvelocityci
# Used by:
# Variations of ship: Tayra (2 of 2)
# Ship: Crane
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Industrial").level
    fit.ship.boostItemAttr("maxVelocity", ship.getModifiedItemAttr("shipBonusCI") * level)

########NEW FILE########
__FILENAME__ = shipbonusvelocitygi
# Used by:
# Variations of ship: Epithal (2 of 2)
# Variations of ship: Miasmos (4 of 4)
# Ship: Iteron Mark V
# Ship: Kryos
# Ship: Viator
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Industrial").level
    # TODO: investigate if we can live without such ifs or hardcoding
    # Viator doesn't have GI bonus
    if "shipBonusGI" in fit.ship.item.attributes:
        bonusAttr = "shipBonusGI"
    else:
        bonusAttr = "shipBonusGI2"
    fit.ship.boostItemAttr("maxVelocity", ship.getModifiedItemAttr(bonusAttr) * level)

########NEW FILE########
__FILENAME__ = shipbonuswarpscramblermaxrangegc2
# Used by:
# Ship: Adrestia
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Warp Scrambler",
                                  "maxRange", ship.getModifiedItemAttr("shipBonusGC2") * level)

########NEW FILE########
__FILENAME__ = shipbonuswarpscramblermaxrangegf2
# Used by:
# Ship: Utu
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Warp Scrambler",
                                  "maxRange", ship.getModifiedItemAttr("shipBonusGF2") * level)

########NEW FILE########
__FILENAME__ = shipcapneedbonusab
# Used by:
# Variations of ship: Armageddon (3 of 5)
# Ship: Apocalypse Imperial Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Battleship").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Energy Turret"),
                                  "capacitorNeed", ship.getModifiedItemAttr("shipBonusAB") * level)

########NEW FILE########
__FILENAME__ = shipcappropulsionjamming
# Used by:
# Ships from group: Interceptor (8 of 8)
# Ship: Atron
# Ship: Condor
# Ship: Executioner
# Ship: Slasher
type = "passive"
def handler(fit, ship, context):
    groups = ("Stasis Web", "Warp Scrambler")
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name in groups,
                                  "capacitorNeed", ship.getModifiedItemAttr("eliteBonusInterceptorRole"))

########NEW FILE########
__FILENAME__ = shipcaprecharge2af
# Used by:
# Ship: Anathema
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Frigate").level
    fit.ship.boostItemAttr("rechargeRate", ship.getModifiedItemAttr("shipBonus2AF") * level)

########NEW FILE########
__FILENAME__ = shipcargobonusai
# Used by:
# Variations of ship: Bestower (2 of 2)
# Variations of ship: Sigil (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Industrial").level
    fit.ship.boostItemAttr("capacity", ship.getModifiedItemAttr("shipBonusAI") * level)

########NEW FILE########
__FILENAME__ = shipcommandbonuseffectivemultiplierorecapital2
# Used by:
# Ship: Rorqual
type = "passive"
def handler(fit, ship, context):
    if fit.extraAttributes["siege"]:
        level = fit.character.getSkill("Capital Industrial Ships").level
        fit.ship.increaseItemAttr("commandBonusEffective", ship.getModifiedItemAttr("shipBonusORECapital2") * level)

########NEW FILE########
__FILENAME__ = shipconsumptionquantitybonusindustrialreconfigurationorecapital1
# Used by:
# Ship: Rorqual
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Capital Industrial Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Industrial Reconfiguration"),
                                  "consumptionQuantity", ship.getModifiedItemAttr("shipBonusORECapital1") * level)

########NEW FILE########
__FILENAME__ = shipcruiseandsiegelauncherrofbonus2cb
# Used by:
# Ship: Widow
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Battleship").level
    affectedGroups = ("Missile Launcher Cruise", "Missile Launcher Torpedo")
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name in affectedGroups,
                                  "speed", ship.getModifiedItemAttr("shipBonus2CB") * level)

########NEW FILE########
__FILENAME__ = shipcruiseandtorpedovelocitybonuscb3
# Used by:
# Ship: Golem
# Ship: Widow
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Battleship").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Cruise Missiles") or mod.charge.requiresSkill("Torpedoes"),
                                    "maxVelocity", ship.getModifiedItemAttr("shipBonusCB3") * level)

########NEW FILE########
__FILENAME__ = shipcruiselauncherrofbonus2cb
# Used by:
# Ship: Raven
# Ship: Raven State Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Battleship").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Missile Launcher Cruise",
                                  "speed", ship.getModifiedItemAttr("shipBonus2CB") * level)

########NEW FILE########
__FILENAME__ = shipcruisemissileaoecloudsize1cb
# Used by:
# Ship: Raven Navy Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Battleship").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Cruise Missiles"),
                                    "aoeCloudSize", ship.getModifiedItemAttr("shipBonusCB") * level)

########NEW FILE########
__FILENAME__ = shipcruisemissilerofcb
# Used by:
# Ship: Scorpion Navy Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Battleship").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Missile Launcher Cruise",
                                  "speed", ship.getModifiedItemAttr("shipBonusCB") * level)

########NEW FILE########
__FILENAME__ = shipcruisemissilevelocitybonuscb3
# Used by:
# Variations of ship: Raven (3 of 4)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Battleship").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Cruise Missiles"),
                                    "maxVelocity", ship.getModifiedItemAttr("shipBonusCB3") * level)

########NEW FILE########
__FILENAME__ = shipdronemwdspeedbonusrookie
# Used by:
# Ship: Taipan
type = "passive"
def handler(fit, ship, context):
    fit.drones.filteredItemBoost(lambda mod: True,
                                 "maxVelocity", ship.getModifiedItemAttr("rookieDroneMWDspeed"))

########NEW FILE########
__FILENAME__ = shipdronescoutthermaldamagegf2
# Used by:
# Ship: Helios
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Frigate").level
    fit.drones.filteredItemBoost(lambda mod: mod.item.requiresSkill("Scout Drone Operation"),
                                 "thermalDamage", ship.getModifiedItemAttr("shipBonusGF2") * level)

########NEW FILE########
__FILENAME__ = shipdronesmaxgc2
# Used by:
# Ship: Guardian-Vexor
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Cruiser").level
    amount = ship.getModifiedItemAttr("shipBonusGC2")
    fit.extraAttributes.increase("maxActiveDrones", amount * level)

########NEW FILE########
__FILENAME__ = shipecmscanstrengthbonuscf
# Used by:
# Variations of ship: Griffin (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Frigate").level
    for type in ("Gravimetric", "Ladar", "Radar", "Magnetometric"):
        fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "ECM",
                                      "scan{0}StrengthBonus".format(type),
                                      ship.getModifiedItemAttr("shipBonusCF") * level)

########NEW FILE########
__FILENAME__ = shipecmscanstrengthbonusrookie
# Used by:
# Ship: Ibis
type = "passive"
def handler(fit, ship, context):
    for type in ("Gravimetric", "Ladar", "Radar", "Magnetometric"):
        fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "ECM",
                                      "scan{0}StrengthBonus".format(type),
                                      ship.getModifiedItemAttr("rookieECMStrengthBonus"))

########NEW FILE########
__FILENAME__ = shipenergydrainamountaf1
# Used by:
# Ship: Cruor
# Ship: Sentinel
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Energy Vampire",
                                  "powerTransferAmount", ship.getModifiedItemAttr("shipBonusAF") * level)

########NEW FILE########
__FILENAME__ = shipenergyneutralizerrangebonusac
# Used by:
# Ship: Vangel
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Energy Destabilizer",
                                  "energyDestabilizationRange", ship.getModifiedItemAttr("shipBonusAC") * level)

########NEW FILE########
__FILENAME__ = shipenergyneutralizerrangebonusaf2
# Used by:
# Ship: Malice
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Energy Destabilizer",
                                  "energyDestabilizationRange", ship.getModifiedItemAttr("shipBonus2AF") * level)

########NEW FILE########
__FILENAME__ = shipenergyneutralizertransferamountbonusab
# Used by:
# Ship: Bhaalgorn
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Battleship").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Energy Destabilizer",
                                  "energyDestabilizationAmount", ship.getModifiedItemAttr("shipBonusAB") * level)

########NEW FILE########
__FILENAME__ = shipenergyneutralizertransferamountbonusac
# Used by:
# Ship: Ashimmu
# Ship: Vangel
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Energy Destabilizer",
                                  "energyDestabilizationAmount", ship.getModifiedItemAttr("shipBonusAC") * level)

########NEW FILE########
__FILENAME__ = shipenergyneutralizertransferamountbonusaf
# Used by:
# Ship: Cruor
# Ship: Sentinel
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Energy Destabilizer",
                                  "energyDestabilizationAmount", ship.getModifiedItemAttr("shipBonusAF") * level)

########NEW FILE########
__FILENAME__ = shipenergyneutralizertransferamountbonusaf2
# Used by:
# Ship: Malice
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Energy Destabilizer",
                                  "energyDestabilizationAmount", ship.getModifiedItemAttr("shipBonus2AF") * level)

########NEW FILE########
__FILENAME__ = shipenergytcapneedbonusaf
# Used by:
# Ship: Crusader
# Ship: Executioner
# Ship: Gold Magnate
# Ship: Retribution
# Ship: Silver Magnate
# Ship: Tormentor
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Energy Turret"),
                                  "capacitorNeed", ship.getModifiedItemAttr("shipBonus2AF") * level)

########NEW FILE########
__FILENAME__ = shipenergytcapneedbonusrookie
# Used by:
# Ship: Hematos
# Ship: Impairor
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Energy Turret"),
                                  "capacitorNeed", ship.getModifiedItemAttr("rookieSETCapBonus"))

########NEW FILE########
__FILENAME__ = shipenergytrackingabc1
# Used by:
# Ship: Harbinger Navy Issue

type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Battlecruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Energy Turret"),
                                  "trackingSpeed", ship.getModifiedItemAttr("shipBonusABC1") * level)

########NEW FILE########
__FILENAME__ = shipenergytransferrange1
# Used by:
# Ship: Guardian
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Capacitor Transmitter",
                                  "powerTransferRange", ship.getModifiedItemAttr("shipBonusAC") * level)

########NEW FILE########
__FILENAME__ = shipenergytransferrange2
# Used by:
# Ship: Basilisk
# Ship: Etana
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Capacitor Transmitter",
                                  "powerTransferRange", ship.getModifiedItemAttr("shipBonusCC2") * level)

########NEW FILE########
__FILENAME__ = shipenergyvampireamountbonusfixedaf2
# Used by:
# Ship: Malice
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Energy Vampire",
                                  "powerTransferAmount", ship.getModifiedItemAttr("shipBonus2AF") * level)

########NEW FILE########
__FILENAME__ = shipenergyvampirerangebonusfixedac
# Used by:
# Ship: Vangel
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Energy Vampire",
                                  "powerTransferRange", ship.getModifiedItemAttr("shipBonusAC") * level)

########NEW FILE########
__FILENAME__ = shipenergyvampirerangebonusfixedaf2
# Used by:
# Ship: Malice
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Energy Vampire",
                                  "powerTransferRange", ship.getModifiedItemAttr("shipBonus2AF") * level)

########NEW FILE########
__FILENAME__ = shipenergyvampiretransferamountbonusab
# Used by:
# Ship: Bhaalgorn
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Battleship").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Energy Vampire",
                                  "powerTransferAmount", ship.getModifiedItemAttr("shipBonusAB") * level)

########NEW FILE########
__FILENAME__ = shipenergyvampiretransferamountbonusac
# Used by:
# Ship: Ashimmu
# Ship: Vangel
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Energy Vampire",
                                  "powerTransferAmount", ship.getModifiedItemAttr("shipBonusAC") * level)

########NEW FILE########
__FILENAME__ = shipetdamageaf
# Used by:
# Ship: Crusader
# Ship: Imperial Navy Slicer
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Energy Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("shipBonusAF") * level)
########NEW FILE########
__FILENAME__ = shipetoptimalrange2af
# Used by:
# Ship: Imperial Navy Slicer
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Energy Turret"),
                                  "maxRange", ship.getModifiedItemAttr("shipBonus2AF") * level)
########NEW FILE########
__FILENAME__ = shipetspeedbonusab2
# Used by:
# Variations of ship: Armageddon (3 of 5)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Battleship").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Energy Turret"),
                                  "speed", ship.getModifiedItemAttr("shipBonusAB2") * level)
########NEW FILE########
__FILENAME__ = shipfalloffbonusgf
# Used by:
# Ship: Atron
# Ship: Daredevil
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Hybrid Turret"),
                                  "falloff", ship.getModifiedItemAttr("shipBonusGF2") * level)

########NEW FILE########
__FILENAME__ = shipfalloffbonusmf
# Used by:
# Ship: Chremoas
# Ship: Dramiel
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Projectile Turret"),
                                  "falloff", ship.getModifiedItemAttr("shipBonusMF") * level)

########NEW FILE########
__FILENAME__ = shipfighterbomberdamagepiratesupercarrier
# Used by:
# Ship: Revenant
type = "passive"
def handler(fit, ship, context):
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Fighter Bombers"),
                                 "damageMultiplier", ship.getModifiedItemAttr("shipBonusPirateFaction"))

########NEW FILE########
__FILENAME__ = shipfighterbomberhitpointspiratesupercarrier
# Used by:
# Ship: Revenant
type = "passive"
def handler(fit, ship, context):
    for type in ("shieldCapacity", "armorHP", "hp"):
        fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Fighter Bombers"),
                                     type, ship.getModifiedItemAttr("shipBonusPirateFaction"))

########NEW FILE########
__FILENAME__ = shipfighterdamagepiratesupercarrier
# Used by:
# Ship: Revenant
type = "passive"
def handler(fit, ship, context):
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Fighters"),
                                 "damageMultiplier", ship.getModifiedItemAttr("shipBonusPirateFaction"))

########NEW FILE########
__FILENAME__ = shipfighterhitpointspiratesupercarrier
# Used by:
# Ship: Revenant
type = "passive"
def handler(fit, ship, context):
    for type in ("shieldCapacity", "armorHP", "hp"):
        fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Fighters"),
                                     type, ship.getModifiedItemAttr("shipBonusPirateFaction"))

########NEW FILE########
__FILENAME__ = shipgchyieldbonusorefrig2
# Used by:
# Ship: Venture
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Mining Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Gas Cloud Harvesting"),
                                     "duration", module.getModifiedItemAttr("shipBonusOREfrig2") * level)
########NEW FILE########
__FILENAME__ = shipheavyassaultmissileaoecloudsizecbc1
# Used by:
# Ship: Drake Navy Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Battlecruiser").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Assault Missiles"),
                                    "aoeCloudSize", ship.getModifiedItemAttr("shipBonusCBC1") * level)

########NEW FILE########
__FILENAME__ = shipheavyassaultmissileaoecloudsizecc2
# Used by:
# Ship: Caracal Navy Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Cruiser").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Assault Missiles"),
                                    "aoeCloudSize", ship.getModifiedItemAttr("shipBonusCC2") * level)

########NEW FILE########
__FILENAME__ = shipheavyassaultmissileemandexpandkinandthmdmgac1
# Used by:
# Ship: Sacrilege
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Cruiser").level
    damageTypes = ("em", "explosive", "kinetic", "thermal")
    for damageType in damageTypes:
        fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Assault Missiles"),
                                        "{0}Damage".format(damageType), ship.getModifiedItemAttr("shipBonusAC") * level)

########NEW FILE########
__FILENAME__ = shipheavyassaultmissileemdmgpiratecruiser
# Used by:
# Ship: Gnosis
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Assault Missiles"),
                                    "emDamage", ship.getModifiedItemAttr("shipBonusPirateFaction"))

########NEW FILE########
__FILENAME__ = shipheavyassaultmissileexpdmgpiratecruiser
# Used by:
# Ship: Gnosis
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Assault Missiles"),
                                    "explosiveDamage", ship.getModifiedItemAttr("shipBonusPirateFaction"))

########NEW FILE########
__FILENAME__ = shipheavyassaultmissilekindmgpiratecruiser
# Used by:
# Ship: Gnosis
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Assault Missiles"),
                                    "kineticDamage", ship.getModifiedItemAttr("shipBonusPirateFaction"))

########NEW FILE########
__FILENAME__ = shipheavyassaultmissilethermdmgpiratecruiser
# Used by:
# Ship: Gnosis
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Assault Missiles"),
                                    "thermalDamage", ship.getModifiedItemAttr("shipBonusPirateFaction"))

########NEW FILE########
__FILENAME__ = shipheavyassaultmissilevelocitycbc2
# Used by:
# Ship: Drake Navy Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Battlecruiser").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Assault Missiles"),
                                    "maxVelocity", ship.getModifiedItemAttr("shipBonusCBC2") * level)

########NEW FILE########
__FILENAME__ = shipheavymissileaoecloudsizecbc1
# Used by:
# Ship: Drake Navy Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Battlecruiser").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Missiles"),
                                    "aoeCloudSize", ship.getModifiedItemAttr("shipBonusCBC1") * level)

########NEW FILE########
__FILENAME__ = shipheavymissileaoecloudsizecc2
# Used by:
# Ship: Caracal Navy Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Cruiser").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Missiles"),
                                    "aoeCloudSize", ship.getModifiedItemAttr("shipBonusCC2") * level)

########NEW FILE########
__FILENAME__ = shipheavymissileemdmgpiratecruiser
# Used by:
# Ship: Gnosis
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Missiles"),
                                    "emDamage", ship.getModifiedItemAttr("shipBonusPirateFaction"))

########NEW FILE########
__FILENAME__ = shipheavymissileexpdmgpiratecruiser
# Used by:
# Ship: Gnosis
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Missiles"),
                                    "explosiveDamage", ship.getModifiedItemAttr("shipBonusPirateFaction"))

########NEW FILE########
__FILENAME__ = shipheavymissilekindmgpiratecruiser
# Used by:
# Ship: Gnosis
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Missiles"),
                                    "kineticDamage", ship.getModifiedItemAttr("shipBonusPirateFaction"))

########NEW FILE########
__FILENAME__ = shipheavymissilethermdmgpiratecruiser
# Used by:
# Ship: Gnosis
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Missiles"),
                                    "thermalDamage", ship.getModifiedItemAttr("shipBonusPirateFaction"))

########NEW FILE########
__FILENAME__ = shipheavymissilevelocitycbc2
# Used by:
# Ship: Drake Navy Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Battlecruiser").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Missiles"),
                                    "maxVelocity", ship.getModifiedItemAttr("shipBonusCBC2") * level)

########NEW FILE########
__FILENAME__ = shiphrangebonuscc
# Used by:
# Ship: Eagle
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Hybrid Turret"),
                                  "maxRange", ship.getModifiedItemAttr("shipBonusCC") * level)

########NEW FILE########
__FILENAME__ = shiphtdamagebonuscc
# Used by:
# Ship: Moa
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Hybrid Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("shipBonusCC") * level)

########NEW FILE########
__FILENAME__ = shiphtdmgbonusfixedgc
# Used by:
# Variations of ship: Thorax (3 of 4)
# Ship: Adrestia
# Ship: Arazu
# Ship: Exequror Navy Issue
# Ship: Guardian-Vexor
# Ship: Lachesis
# Ship: Vexor
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Hybrid Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("shipBonusGC") * level)

########NEW FILE########
__FILENAME__ = shiphtdmgbonusgb
# Used by:
# Ships named like: Hyperion (2 of 2)
# Ship: Dominix Navy Issue
# Ship: Kronos
# Ship: Megathron Federate Issue
# Ship: Sin
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Battleship").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Hybrid Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("shipBonusGB") * level)

########NEW FILE########
__FILENAME__ = shiphttrackingbonusgb
# Used by:
# Ship: Vindicator
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Battleship").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Hybrid Turret"),
                                  "trackingSpeed", ship.getModifiedItemAttr("shipBonusGB") * level)

########NEW FILE########
__FILENAME__ = shiphttrackingbonusgb2
# Used by:
# Ships named like: Megathron (3 of 3)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Battleship").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Hybrid Turret"),
                                  "trackingSpeed", ship.getModifiedItemAttr("shipBonusGB2") * level)

########NEW FILE########
__FILENAME__ = shiphturretfalloffbonusgc
# Used by:
# Ship: Vigilant
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Hybrid Turret"),
                                  "falloff", ship.getModifiedItemAttr("shipBonusGC") * level)

########NEW FILE########
__FILENAME__ = shiphybriddamagebonuscbc2
# Used by:
# Ship: Naga
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Battlecruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Hybrid Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("shipBonusCBC2") * level)

########NEW FILE########
__FILENAME__ = shiphybriddamagebonuscf
# Used by:
# Ship: Raptor
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Hybrid Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("shipBonusCF") * level)
########NEW FILE########
__FILENAME__ = shiphybriddamagebonuscf2
# Used by:
# Ships named like: Merlin (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Hybrid Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("shipBonusCF2") * level)

########NEW FILE########
__FILENAME__ = shiphybriddamagebonusgbc2
# Used by:
# Ship: Talos
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Battlecruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Hybrid Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("shipBonusGBC2") * level)

########NEW FILE########
__FILENAME__ = shiphybriddmg1gbc1
# Used by:
# Variations of ship: Brutix (3 of 3)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Battlecruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Hybrid Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("shipBonusGBC1") * level)

########NEW FILE########
__FILENAME__ = shiphybriddmgpiratebattleship
# Used by:
# Ship: Vindicator
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Hybrid Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("shipBonusPirateFaction"))

########NEW FILE########
__FILENAME__ = shiphybriddmgpiratecruiser
# Used by:
# Ship: Gnosis
# Ship: Vigilant
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Hybrid Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("shipBonusPirateFaction"))

########NEW FILE########
__FILENAME__ = shiphybridfalloff1gd1
# Used by:
# Variations of ship: Catalyst (6 of 7)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Destroyer").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Hybrid Turret"),
                                  "falloff", ship.getModifiedItemAttr("shipBonusGD1") * level)

########NEW FILE########
__FILENAME__ = shiphybridoptimal1cbc1
# Used by:
# Variations of ship: Ferox (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Battlecruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Hybrid Turret"),
                                  "maxRange", ship.getModifiedItemAttr("shipBonusCBC1") * level)

########NEW FILE########
__FILENAME__ = shiphybridoptimalgd1
# Used by:
# Ship: Eris
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Destroyer").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Hybrid Turret"),
                                  "maxRange", ship.getModifiedItemAttr("shipBonusGD1") * level)

########NEW FILE########
__FILENAME__ = shiphybridrange1cd1
# Used by:
# Ship: Cormorant
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Destroyer").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Hybrid Turret"),
                                  "maxRange", ship.getModifiedItemAttr("shipBonusCD1") * level)

########NEW FILE########
__FILENAME__ = shiphybridrangebonuscbc1
# Used by:
# Ship: Naga
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Battlecruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Hybrid Turret"),
                                  "maxRange", ship.getModifiedItemAttr("shipBonusCBC1") * level)

########NEW FILE########
__FILENAME__ = shiphybridrangebonuscf2
# Used by:
# Ship: Harpy
# Ship: Raptor
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Hybrid Turret"),
                                  "maxRange", ship.getModifiedItemAttr("shipBonusCF2") * level)
########NEW FILE########
__FILENAME__ = shiphybridrangebonusrookie
# Used by:
# Ship: Ibis
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Hybrid Turret"),
                                  "maxRange", ship.getModifiedItemAttr("rookieSHTOptimalBonus"))
########NEW FILE########
__FILENAME__ = shiphybridtracking1gd2
# Used by:
# Variations of ship: Catalyst (7 of 7)
# Ship: Algos
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Destroyer").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Hybrid Turret"),
                                  "trackingSpeed", ship.getModifiedItemAttr("shipBonusGD2") * level)

########NEW FILE########
__FILENAME__ = shiphybridtrackingcd2
# Used by:
# Ship: Cormorant
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Destroyer").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Hybrid Turret"),
                                  "trackingSpeed", ship.getModifiedItemAttr("shipBonusCD2") * level)

########NEW FILE########
__FILENAME__ = shiphybridtrackinggbc2
# Used by:
# Ship: Brutix Navy Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Battlecruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Hybrid Turret"),
                                  "trackingSpeed", ship.getModifiedItemAttr("shipBonusGBC2") * level)

########NEW FILE########
__FILENAME__ = shiphybridtrackinggc2
# Used by:
# Ship: Thorax
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Hybrid Turret"),
                                  "trackingSpeed", ship.getModifiedItemAttr("shipBonusGC2") * level)

########NEW FILE########
__FILENAME__ = shiphybridturretrofbonusgc2
# Used by:
# Ship: Exequror Navy Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Hybrid Turret"),
                                  "speed", ship.getModifiedItemAttr("shipBonusGC2") * level)

########NEW FILE########
__FILENAME__ = shiplargehybridtrackingbonusgbc1
# Used by:
# Ship: Talos
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Battlecruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Hybrid Turret"),
                                  "trackingSpeed", ship.getModifiedItemAttr("shipBonusGBC1") * level)

########NEW FILE########
__FILENAME__ = shiplargehybridturretrofgb
# Used by:
# Ship: Megathron
# Ship: Megathron Navy Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Battleship").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Hybrid Turret"),
                                  "speed", ship.getModifiedItemAttr("shipBonusGB") * level)

########NEW FILE########
__FILENAME__ = shiplargelasercapabc1
# Used by:
# Ship: Oracle
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Battlecruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Energy Turret"),
                                  "capacitorNeed", ship.getModifiedItemAttr("shipBonusABC1") * level)

########NEW FILE########
__FILENAME__ = shiplargelaserdamagebonusabc2
# Used by:
# Ship: Oracle
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Battlecruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Energy Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("shipBonusABC2") * level)

########NEW FILE########
__FILENAME__ = shiplasercap1abc2
# Used by:
# Ship: Absolution
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Battlecruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Energy Turret"),
                                  "capacitorNeed", ship.getModifiedItemAttr("shipBonusABC2") * level)

########NEW FILE########
__FILENAME__ = shiplasercapabc1
# Used by:
# Ship: Harbinger
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Battlecruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Energy Turret"),
                                  "capacitorNeed", ship.getModifiedItemAttr("shipBonusABC1") * level)

########NEW FILE########
__FILENAME__ = shiplasercapneed2ad1
# Used by:
# Ship: Coercer
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Destroyer").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Energy Turret"),
                                  "capacitorNeed", ship.getModifiedItemAttr("shipBonusAD1") * level)

########NEW FILE########
__FILENAME__ = shiplaserdamagebonusabc2
# Used by:
# Ships named like: Harbinger (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Battlecruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Energy Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("shipBonusABC2") * level)

########NEW FILE########
__FILENAME__ = shiplaserdamagepiratebattleship
# Used by:
# Ship: Bhaalgorn
# Ship: Nightmare
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Energy Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("shipBonusPirateFaction"))

########NEW FILE########
__FILENAME__ = shiplaserrofac2
# Used by:
# Ship: Omen
# Ship: Zealot
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Energy Turret"),
                                  "speed", ship.getModifiedItemAttr("shipBonusAC2") * level)

########NEW FILE########
__FILENAME__ = shiplasertracking2ad2
# Used by:
# Ship: Coercer
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Destroyer").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Energy Turret"),
                                  "trackingSpeed", ship.getModifiedItemAttr("shipBonusAD2") * level)

########NEW FILE########
__FILENAME__ = shiplightmissilemaxvelocitybonusrookie
# Used by:
# Ship: Taipan
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Light Missiles"),
                                    "maxVelocity", ship.getModifiedItemAttr("rookieLightMissileVelocity"))

########NEW FILE########
__FILENAME__ = shipmaxlockedtargetsbonusaddonline
# Used by:
# Modules from group: Signal Amplifier (11 of 11)
type = "passive"
def handler(fit, module, context):
    fit.ship.increaseItemAttr("maxLockedTargets", module.getModifiedItemAttr("maxLockedTargetsBonus"))

########NEW FILE########
__FILENAME__ = shipmaxtargetrangebonusonline
# Used by:
# Modules from group: Signal Amplifier (11 of 11)
type = "passive"
def handler(fit, module, context):
    fit.ship.boostItemAttr("maxTargetRange", module.getModifiedItemAttr("maxTargetRangeBonus"),
                           stackingPenalties = True)

########NEW FILE########
__FILENAME__ = shipmetcdamagebonusac
# Used by:
# Ship: Augoror Navy Issue
# Ship: Maller
# Ship: Omen Navy Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Energy Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("shipBonusAC") * level)

########NEW FILE########
__FILENAME__ = shipminingbonusore2
# Used by:
# Variations of ship: Covetor (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Mining Barge").level
    groups = ("Strip Miner", "Frequency Mining Laser")
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name in groups,
                                  "miningAmount", ship.getModifiedItemAttr("shipBonusORE2") * level)

########NEW FILE########
__FILENAME__ = shipminingbonusorefrig1
# Used by:
# Ship: Venture
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Mining Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Mining"),
                                  "miningAmount", module.getModifiedItemAttr("shipBonusOREfrig1") * level)
########NEW FILE########
__FILENAME__ = shipmissileassaultmissilevelocitybonuscc2
# Used by:
# Ship: Caracal
# Ship: Osprey Navy Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Cruiser").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Assault Missiles"),
                                    "maxVelocity", ship.getModifiedItemAttr("shipBonusCC2") * level)

########NEW FILE########
__FILENAME__ = shipmissileemdamagecc
# Used by:
# Ship: Osprey Navy Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Cruiser").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Missile Launcher Operation"),
                                    "emDamage", ship.getModifiedItemAttr("shipBonusCC") * level)

########NEW FILE########
__FILENAME__ = shipmissileemdamagemc2
# Used by:
# Ship: Scythe Fleet Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Cruiser").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Missile Launcher Operation"),
                                    "emDamage", ship.getModifiedItemAttr("shipBonusMC2") * level)

########NEW FILE########
__FILENAME__ = shipmissileexpdamagecc
# Used by:
# Ship: Osprey Navy Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Cruiser").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Missile Launcher Operation"),
                                    "explosiveDamage", ship.getModifiedItemAttr("shipBonusCC") * level)

########NEW FILE########
__FILENAME__ = shipmissileexpdamagemc2
# Used by:
# Ship: Scythe Fleet Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Cruiser").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Missile Launcher Operation"),
                                    "explosiveDamage", ship.getModifiedItemAttr("shipBonusMC2") * level)

########NEW FILE########
__FILENAME__ = shipmissileheavyassaultvelocityabc2
# Used by:
# Ship: Damnation
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Battlecruiser").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Assault Missiles"),
                                    "maxVelocity", ship.getModifiedItemAttr("shipBonusABC2") * level)

########NEW FILE########
__FILENAME__ = shipmissileheavyvelocityabc2
# Used by:
# Ship: Damnation
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Battlecruiser").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Missiles"),
                                    "maxVelocity", ship.getModifiedItemAttr("shipBonusABC2") * level)

########NEW FILE########
__FILENAME__ = shipmissileheavyvelocitybonuscc2
# Used by:
# Ship: Caracal
# Ship: Osprey Navy Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Cruiser").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Missiles"),
                                    "maxVelocity", ship.getModifiedItemAttr("shipBonusCC2") * level)

########NEW FILE########
__FILENAME__ = shipmissilekindamagecc2
# Used by:
# Ship: Osprey Navy Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Cruiser").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Missile Launcher Operation"),
                                    "kineticDamage", ship.getModifiedItemAttr("shipBonusCC2") * level)

########NEW FILE########
__FILENAME__ = shipmissilekineticdamagecc
# Used by:
# Ship: Cerberus
# Ship: Onyx
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Cruiser").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Missile Launcher Operation"),
                                    "kineticDamage", ship.getModifiedItemAttr("shipBonusCC") * level)

########NEW FILE########
__FILENAME__ = shipmissilekineticdamagecf
# Used by:
# Ship: Buzzard
# Ship: Caldari Navy Hookbill
# Ship: Condor
# Ship: Hawk
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Frigate").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Missile Launcher Operation"),
                                    "kineticDamage", ship.getModifiedItemAttr("shipBonusCF") * level)

########NEW FILE########
__FILENAME__ = shipmissilekineticdamagemc2
# Used by:
# Ship: Scythe Fleet Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Cruiser").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Missile Launcher Operation"),
                                    "kineticDamage", ship.getModifiedItemAttr("shipBonusMC2") * level)

########NEW FILE########
__FILENAME__ = shipmissilekineticdamagerookie
# Used by:
# Ship: Ibis
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Missile Launcher Operation"),
                                    "kineticDamage", ship.getModifiedItemAttr("rookieMissileKinDamageBonus"))

########NEW FILE########
__FILENAME__ = shipmissilelauncherspeedbonusmc2
# Used by:
# Ship: Bellicose
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Cruiser").level
    groups = ("Missile Launcher Rapid Light", "Missile Launcher Heavy", "Missile Launcher Heavy Assault")
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name in groups,
                                  "speed", ship.getModifiedItemAttr("shipBonusMC2") * level)

########NEW FILE########
__FILENAME__ = shipmissilelightvelocitybonuscc2
# Used by:
# Ship: Caracal
# Ship: Osprey Navy Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Cruiser").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Light Missiles"),
                                    "maxVelocity", ship.getModifiedItemAttr("shipBonusCC2") * level)

########NEW FILE########
__FILENAME__ = shipmissilelightvelocitybonuscf2
# Used by:
# Ship: Caldari Navy Hookbill
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Frigate").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Light Missiles"),
                                    "maxVelocity", ship.getModifiedItemAttr("shipBonusCF2") * level)

########NEW FILE########
__FILENAME__ = shipmissilerocketvelocitybonuscf2
# Used by:
# Ship: Caldari Navy Hookbill
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Frigate").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Rockets"),
                                    "maxVelocity", ship.getModifiedItemAttr("shipBonusCF2") * level)

########NEW FILE########
__FILENAME__ = shipmissilerofcc
# Used by:
# Ships named like: Caracal (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Cruiser").level
    groups = ("Missile Launcher Heavy", "Missile Launcher Rapid Light", "Missile Launcher Heavy Assault")
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name in groups,
                                  "speed", ship.getModifiedItemAttr("shipBonusCC") * level)

########NEW FILE########
__FILENAME__ = shipmissilerofmf2
# Used by:
# Ship: Breacher
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Missile Launcher Operation"),
                                  "speed", ship.getModifiedItemAttr("shipBonusMF2") * level)



########NEW FILE########
__FILENAME__ = shipmissilespeedbonusaf
# Used by:
# Ship: Malediction
# Ship: Vengeance
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Missile Launcher Operation"),
                                  "speed", ship.getModifiedItemAttr("shipBonus2AF") * level)

########NEW FILE########
__FILENAME__ = shipmissilespeedbonuscf
# Used by:
# Ship: Buzzard
# Ship: Hawk
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Missile Launcher Operation"),
                                  "speed", ship.getModifiedItemAttr("shipBonusCF2") * level)

########NEW FILE########
__FILENAME__ = shipmissilethermdamagecc
# Used by:
# Ship: Osprey Navy Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Cruiser").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Missile Launcher Operation"),
                                    "thermalDamage", ship.getModifiedItemAttr("shipBonusCC") * level)

########NEW FILE########
__FILENAME__ = shipmissilethermdamagemc2
# Used by:
# Ship: Scythe Fleet Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Cruiser").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Missile Launcher Operation"),
                                    "thermalDamage", ship.getModifiedItemAttr("shipBonusMC2") * level)

########NEW FILE########
__FILENAME__ = shipmissilevelocitycd1
# Used by:
# Ship: Flycatcher
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Destroyer").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Missile Launcher Operation"),
                                    "maxVelocity", ship.getModifiedItemAttr("shipBonusCD1") * level)

########NEW FILE########
__FILENAME__ = shipmissilevelocitycf
# Used by:
# Ship: Crow
# Ship: Kestrel
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Frigate").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Missile Launcher Operation"),
                                    "maxVelocity", ship.getModifiedItemAttr("shipBonusCF") * level)

########NEW FILE########
__FILENAME__ = shipmissilevelocitypiratefactioncruise
# Used by:
# Ship: Rattlesnake
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Cruise Missiles"),
                                    "maxVelocity", ship.getModifiedItemAttr("shipBonusPirateFaction"))
########NEW FILE########
__FILENAME__ = shipmissilevelocitypiratefactionfrigate
# Used by:
# Ship: Worm
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Light Missiles") or mod.charge.requiresSkill("Rockets"),
                                    "maxVelocity", ship.getModifiedItemAttr("shipBonusPirateFaction"))

########NEW FILE########
__FILENAME__ = shipmissilevelocitypiratefactionheavy
# Used by:
# Ship: Gila
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Missiles"),
                                    "maxVelocity", ship.getModifiedItemAttr("shipBonusPirateFaction"))

########NEW FILE########
__FILENAME__ = shipmissilevelocitypiratefactionheavyassault
# Used by:
# Ship: Gila
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Assault Missiles"),
                                    "maxVelocity", ship.getModifiedItemAttr("shipBonusPirateFaction"))

########NEW FILE########
__FILENAME__ = shipmissilevelocitypiratefactionlight
# Used by:
# Ship: Corax
# Ship: Gila
# Ship: Talwar
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Light Missiles"),
                                    "maxVelocity", ship.getModifiedItemAttr("shipBonusPirateFaction"))

########NEW FILE########
__FILENAME__ = shipmissilevelocitypiratefactionrocket
# Used by:
# Ship: Corax
# Ship: Talwar
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Rockets"),
                                    "maxVelocity", ship.getModifiedItemAttr("shipBonusPirateFaction"))

########NEW FILE########
__FILENAME__ = shipmissilevelocitypiratefactiontorp
# Used by:
# Ship: Rattlesnake
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Torpedoes"),
                                    "maxVelocity", ship.getModifiedItemAttr("shipBonusPirateFaction"))
########NEW FILE########
__FILENAME__ = shipmtfalloffbonusatc
# Used by:
# Ship: Mimir
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Projectile Turret"),
                                  "falloff", ship.getModifiedItemAttr("shipBonusATC2"))

########NEW FILE########
__FILENAME__ = shipmtfalloffbonusatf
# Used by:
# Ship: Freki
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Projectile Turret"),
                                  "falloff", ship.getModifiedItemAttr("shipBonusATF2"))
########NEW FILE########
__FILENAME__ = shipmtmaxrangebonusatc
# Used by:
# Ship: Mimir
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Projectile Turret"),
                                  "maxRange", ship.getModifiedItemAttr("shipBonusATC2"))

########NEW FILE########
__FILENAME__ = shipmtmaxrangebonusatf
# Used by:
# Ship: Freki
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Projectile Turret"),
                                  "maxRange", ship.getModifiedItemAttr("shipBonusATF2"))

########NEW FILE########
__FILENAME__ = shipneutdestabilizationamountbonusrookie
# Used by:
# Ship: Hematos
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Energy Destabilizer",
                                  "energyDestabilizationAmount", ship.getModifiedItemAttr("rookieNeutDrain"))

########NEW FILE########
__FILENAME__ = shipnostransferamountbonusrookie
# Used by:
# Ship: Hematos
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Energy Vampire",
                                  "powerTransferAmount", ship.getModifiedItemAttr("rookieNosDrain"))

########NEW FILE########
__FILENAME__ = shippdmgbonusmf
# Used by:
# Variations of ship: Rifter (3 of 3)
# Variations of ship: Slasher (3 of 3)
# Ship: Cheetah
# Ship: Freki
# Ship: Republic Fleet Firetail
# Ship: Rifter Krusual Edition
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Projectile Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("shipBonusMF") * level)

########NEW FILE########
__FILENAME__ = shipprojectiledamagemd1
# Used by:
# Variations of ship: Thrasher (3 of 3)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Destroyer").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Projectile Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("shipBonusMD1") * level)

########NEW FILE########
__FILENAME__ = shipprojectiledmgmc
# Used by:
# Ship: Mimir
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Projectile Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("shipBonusMC") * level)

########NEW FILE########
__FILENAME__ = shipprojectiledmgmc2
# Used by:
# Ship: Cynabal
# Ship: Moracha
# Ship: Muninn
# Ship: Rupture
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Projectile Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("shipBonusMC2") * level)

########NEW FILE########
__FILENAME__ = shipprojectiledmgpiratecruiser
# Used by:
# Ship: Gnosis
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Projectile Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("shipBonusPirateFaction"))

########NEW FILE########
__FILENAME__ = shipprojectilefalloffbonusmbc2
# Used by:
# Ship: Tornado
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Battlecruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Projectile Turret"),
                                  "falloff", ship.getModifiedItemAttr("shipBonusMBC2") * level)

########NEW FILE########
__FILENAME__ = shipprojectileoptimalbonusemf2
# Used by:
# Ship: Cheetah
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Projectile Turret"),
                                  "maxRange", ship.getModifiedItemAttr("shipBonusMF2") * level)

########NEW FILE########
__FILENAME__ = shipprojectilerof1mbc2
# Used by:
# Ships named like: Hurricane (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Battlecruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Projectile Turret"),
                                  "speed", ship.getModifiedItemAttr("shipBonusMBC2") * level)

########NEW FILE########
__FILENAME__ = shipprojectilerofbonusmbc1
# Used by:
# Ship: Tornado
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Battlecruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Projectile Turret"),
                                  "speed", ship.getModifiedItemAttr("shipBonusMBC1") * level)

########NEW FILE########
__FILENAME__ = shipprojectilerofpiratebattleship
# Used by:
# Ship: Machariel
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Projectile Turret"),
                                  "speed", ship.getModifiedItemAttr("shipBonusPirateFaction"))

########NEW FILE########
__FILENAME__ = shipprojectilerofpiratecruiser
# Used by:
# Ship: Cynabal
# Ship: Moracha
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Projectile Turret"),
                                  "speed", ship.getModifiedItemAttr("shipBonusPirateFaction"))

########NEW FILE########
__FILENAME__ = shipprojectiletracking1md2
# Used by:
# Variations of ship: Thrasher (3 of 3)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Destroyer").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Projectile Turret"),
                                  "trackingSpeed", ship.getModifiedItemAttr("shipBonusMD2") * level)

########NEW FILE########
__FILENAME__ = shipprojectiletrackinggf
# Used by:
# Ship: Chremoas
# Ship: Dramiel
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Projectile Turret"),
                                  "trackingSpeed", ship.getModifiedItemAttr("shipBonusGF") * level)

########NEW FILE########
__FILENAME__ = shipprojectiletrackingmf2
# Used by:
# Variations of ship: Slasher (3 of 3)
# Ship: Jaguar
# Ship: Republic Fleet Firetail
# Ship: Wolf
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Projectile Turret"),
                                  "trackingSpeed", ship.getModifiedItemAttr("shipBonusMF2") * level)

########NEW FILE########
__FILENAME__ = shipptdmgbonusmb
# Used by:
# Variations of ship: Tempest (3 of 4)
# Ship: Machariel
# Ship: Panther
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Battleship").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Projectile Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("shipBonusMB") * level)

########NEW FILE########
__FILENAME__ = shipptspeedbonusmb2
# Used by:
# Ships named like: Maelstrom (2 of 2)
# Variations of ship: Tempest (4 of 4)
# Ship: Panther
# Ship: Typhoon Fleet Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Battleship").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Projectile Turret"),
                                  "speed", ship.getModifiedItemAttr("shipBonusMB2") * level)

########NEW FILE########
__FILENAME__ = shippturretfalloffbonusgb
# Used by:
# Ship: Machariel
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Battleship").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Projectile Turret"),
                                  "falloff", ship.getModifiedItemAttr("shipBonusGB") * level)
########NEW FILE########
__FILENAME__ = shippturretfalloffbonusgc
# Used by:
# Ship: Cynabal
# Ship: Moracha
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Projectile Turret"),
                                  "falloff", ship.getModifiedItemAttr("shipBonusGC") * level)

########NEW FILE########
__FILENAME__ = shippturretfalloffbonusmc2
# Used by:
# Ship: Stabber
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Projectile Turret"),
                                  "falloff", ship.getModifiedItemAttr("shipBonusMC2") * level)

########NEW FILE########
__FILENAME__ = shippturretspeedbonusmc
# Used by:
# Variations of ship: Rupture (3 of 3)
# Variations of ship: Stabber (3 of 3)
# Ship: Huginn
# Ship: Rapier
# Ship: Scythe Fleet Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Projectile Turret"),
                                  "speed", ship.getModifiedItemAttr("shipBonusMC") * level)

########NEW FILE########
__FILENAME__ = shipremotearmorrange1
# Used by:
# Ship: Oneiros
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Armor Repairer",
                                  "maxRange", ship.getModifiedItemAttr("shipBonusGC") * level)
########NEW FILE########
__FILENAME__ = shipremotearmorrange2
# Used by:
# Ship: Guardian
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Armor Repairer",
                                  "maxRange", ship.getModifiedItemAttr("shipBonusAC2") * level)

########NEW FILE########
__FILENAME__ = shipremotesensordampenercapneedgf
# Used by:
# Variations of ship: Maulus (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Sensor Damper",
                                  "capacitorNeed", ship.getModifiedItemAttr("shipBonusGF") * level)

########NEW FILE########
__FILENAME__ = shiprocketemdmgaf
# Used by:
# Ship: Anathema
# Ship: Vengeance
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Frigate").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Rockets"),
                                    "emDamage", ship.getModifiedItemAttr("shipBonusAF") * level)

########NEW FILE########
__FILENAME__ = shiprocketexplosivedmgaf
# Used by:
# Ship: Anathema
# Ship: Vengeance
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Frigate").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Rockets"),
                                    "explosiveDamage", ship.getModifiedItemAttr("shipBonusAF") * level)

########NEW FILE########
__FILENAME__ = shiprocketexplosivedmgmd1
# Used by:
# Ship: Talwar
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Destroyer").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Rockets"),
                                    "explosiveDamage", ship.getModifiedItemAttr("shipBonusMD1") * level)

########NEW FILE########
__FILENAME__ = shiprocketkineticdmgaf
# Used by:
# Ship: Anathema
# Ship: Vengeance
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Frigate").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Rockets"),
                                    "kineticDamage", ship.getModifiedItemAttr("shipBonusAF") * level)

########NEW FILE########
__FILENAME__ = shiprocketkineticdmgcd1
# Used by:
# Ship: Corax
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Destroyer").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Rockets"),
                                    "kineticDamage", ship.getModifiedItemAttr("shipBonusCD1") * level)

########NEW FILE########
__FILENAME__ = shiprocketmaxvelocitybonusrookie
# Used by:
# Ship: Taipan
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Rockets"),
                                    "maxVelocity", ship.getModifiedItemAttr("rookieRocketVelocity"))

########NEW FILE########
__FILENAME__ = shiprocketthermaldmgaf
# Used by:
# Ship: Anathema
# Ship: Vengeance
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Frigate").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Rockets"),
                                    "thermalDamage", ship.getModifiedItemAttr("shipBonusAF") * level)

########NEW FILE########
__FILENAME__ = shipscanprobestrengthbonuspiratecruiser
# Used by:
# Ships named like: Stratios (2 of 2)
# Ship: Astero
# Ship: Gnosis
type = "passive"
def handler(fit, container, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Astrometrics"),
                                    "baseSensorStrength", container.getModifiedItemAttr("shipBonusPirateFaction2"))

########NEW FILE########
__FILENAME__ = shipscanprobestrengthbonuspiratefaction
# Used by:
# Ship: Nestor
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Astrometrics"),
                                    "baseSensorStrength", ship.getModifiedItemAttr("shipBonusPirateFaction"))

########NEW FILE########
__FILENAME__ = shipscanresolutionbonusonline
# Used by:
# Modules from group: Signal Amplifier (11 of 11)
# Module: QA Damage Module
type = "passive"
def handler(fit, module, context):
    fit.ship.boostItemAttr("scanResolution", module.getModifiedItemAttr("scanResolutionBonus"),
                           stackingPenalties = True)

########NEW FILE########
__FILENAME__ = shipsetdmgbonus2af
# Used by:
# Ships named like: Punisher (2 of 2)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Energy Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("shipBonus2AF") * level)

########NEW FILE########
__FILENAME__ = shipsetdmgbonusaf
# Used by:
# Ship: Executioner
# Ship: Gold Magnate
# Ship: Silver Magnate
# Ship: Tormentor
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Energy Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("shipBonusAF") * level)

########NEW FILE########
__FILENAME__ = shipsetdmgbonusrookie
# Used by:
# Ship: Hematos
# Ship: Immolator
# Ship: Impairor
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Energy Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("rookieSETDamageBonus"))

########NEW FILE########
__FILENAME__ = shipsetoptimalbonusrookie
# Used by:
# Ship: Immolator
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Energy Turret"),
                                  "maxRange", ship.getModifiedItemAttr("rookieSETOptimal"))

########NEW FILE########
__FILENAME__ = shipsettrackingbonusaf
# Used by:
# Ship: Retribution
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Energy Turret"),
                                  "trackingSpeed", ship.getModifiedItemAttr("shipBonusAF") * level)

########NEW FILE########
__FILENAME__ = shipsettrackingbonusrookie
# Used by:
# Ship: Immolator
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Energy Turret"),
                                  "trackingSpeed", ship.getModifiedItemAttr("rookieSETTracking"))

########NEW FILE########
__FILENAME__ = shipshieldboost1mbc1
# Used by:
# Variations of ship: Cyclone (2 of 2)
# Ship: Sleipnir
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Battlecruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Shield Operation"),
                                  "shieldBonus", ship.getModifiedItemAttr("shipBonusMBC1") * level)

########NEW FILE########
__FILENAME__ = shipshieldboostmf
# Used by:
# Ship: Breacher
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Shield Operation"),
                                  "shieldBonus", ship.getModifiedItemAttr("shipBonusMF") * level)

########NEW FILE########
__FILENAME__ = shipshieldboostrookie
# Used by:
# Ship: Immolator
# Ship: Reaper
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Shield Operation"),
                                  "shieldBonus", ship.getModifiedItemAttr("rookieShieldBoostBonus"))

########NEW FILE########
__FILENAME__ = shipshieldemresistance1cbc2
# Used by:
# Variations of ship: Ferox (2 of 2)
# Ship: Drake
# Ship: Nighthawk
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Battlecruiser").level
    fit.ship.boostItemAttr("shieldEmDamageResonance", ship.getModifiedItemAttr("shipBonusCBC2") * level)

########NEW FILE########
__FILENAME__ = shipshieldemresistancecc2
# Used by:
# Variations of ship: Moa (4 of 4)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Cruiser").level
    fit.ship.boostItemAttr("shieldEmDamageResonance", ship.getModifiedItemAttr("shipBonusCC2") * level)

########NEW FILE########
__FILENAME__ = shipshieldemresistancecf2
# Used by:
# Variations of ship: Merlin (3 of 4)
# Ship: Cambion
# Ship: Merlin Nugoeihuvi Edition
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Frigate").level
    fit.ship.boostItemAttr("shieldEmDamageResonance", ship.getModifiedItemAttr("shipBonusCF") * level)

########NEW FILE########
__FILENAME__ = shipshieldemresistancemc2
# Used by:
# Ship: Broadsword
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Cruiser").level
    fit.ship.boostItemAttr("shieldEmDamageResonance", ship.getModifiedItemAttr("shipBonusMC2") * level)

########NEW FILE########
__FILENAME__ = shipshieldemresistancerookie
# Used by:
# Ship: Ibis
# Ship: Taipan
type = "passive"
def handler(fit, ship, context):
    fit.ship.boostItemAttr("shieldEmDamageResonance", ship.getModifiedItemAttr("rookieShieldResistBonus"))

########NEW FILE########
__FILENAME__ = shipshieldexplosiveresistance1cbc2
# Used by:
# Variations of ship: Ferox (2 of 2)
# Ship: Drake
# Ship: Nighthawk
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Battlecruiser").level
    fit.ship.boostItemAttr("shieldExplosiveDamageResonance", ship.getModifiedItemAttr("shipBonusCBC2") * level)

########NEW FILE########
__FILENAME__ = shipshieldexplosiveresistancecc2
# Used by:
# Variations of ship: Moa (4 of 4)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Cruiser").level
    fit.ship.boostItemAttr("shieldExplosiveDamageResonance", ship.getModifiedItemAttr("shipBonusCC2") * level)

########NEW FILE########
__FILENAME__ = shipshieldexplosiveresistancecf2
# Used by:
# Variations of ship: Merlin (3 of 4)
# Ship: Cambion
# Ship: Merlin Nugoeihuvi Edition
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Frigate").level
    fit.ship.boostItemAttr("shieldExplosiveDamageResonance", ship.getModifiedItemAttr("shipBonusCF") * level)

########NEW FILE########
__FILENAME__ = shipshieldexplosiveresistancemc2
# Used by:
# Ship: Broadsword
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Cruiser").level
    fit.ship.boostItemAttr("shieldExplosiveDamageResonance", ship.getModifiedItemAttr("shipBonusMC2") * level)

########NEW FILE########
__FILENAME__ = shipshieldexplosiveresistancerookie
# Used by:
# Ship: Ibis
# Ship: Taipan
type = "passive"
def handler(fit, ship, context):
    fit.ship.boostItemAttr("shieldExplosiveDamageResonance", ship.getModifiedItemAttr("rookieShieldResistBonus"))

########NEW FILE########
__FILENAME__ = shipshieldkineticresistance1cbc2
# Used by:
# Variations of ship: Ferox (2 of 2)
# Ship: Drake
# Ship: Nighthawk
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Battlecruiser").level
    fit.ship.boostItemAttr("shieldKineticDamageResonance", ship.getModifiedItemAttr("shipBonusCBC2") * level)

########NEW FILE########
__FILENAME__ = shipshieldkineticresistancecc2
# Used by:
# Variations of ship: Moa (4 of 4)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Cruiser").level
    fit.ship.boostItemAttr("shieldKineticDamageResonance", ship.getModifiedItemAttr("shipBonusCC2") * level)

########NEW FILE########
__FILENAME__ = shipshieldkineticresistancecf2
# Used by:
# Variations of ship: Merlin (3 of 4)
# Ship: Cambion
# Ship: Merlin Nugoeihuvi Edition
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Frigate").level
    fit.ship.boostItemAttr("shieldKineticDamageResonance", ship.getModifiedItemAttr("shipBonusCF") * level)

########NEW FILE########
__FILENAME__ = shipshieldkineticresistancemc2
# Used by:
# Ship: Broadsword
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Cruiser").level
    fit.ship.boostItemAttr("shieldKineticDamageResonance", ship.getModifiedItemAttr("shipBonusMC2") * level)

########NEW FILE########
__FILENAME__ = shipshieldkineticresistancerookie
# Used by:
# Ship: Ibis
# Ship: Taipan
type = "passive"
def handler(fit, ship, context):
    fit.ship.boostItemAttr("shieldKineticDamageResonance", ship.getModifiedItemAttr("rookieShieldResistBonus"))

########NEW FILE########
__FILENAME__ = shipshieldthermalresistance1cbc2
# Used by:
# Variations of ship: Ferox (2 of 2)
# Ship: Drake
# Ship: Nighthawk
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Battlecruiser").level
    fit.ship.boostItemAttr("shieldThermalDamageResonance", ship.getModifiedItemAttr("shipBonusCBC2") * level)

########NEW FILE########
__FILENAME__ = shipshieldthermalresistancecc2
# Used by:
# Variations of ship: Moa (4 of 4)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Cruiser").level
    fit.ship.boostItemAttr("shieldThermalDamageResonance", ship.getModifiedItemAttr("shipBonusCC2") * level)

########NEW FILE########
__FILENAME__ = shipshieldthermalresistancecf2
# Used by:
# Variations of ship: Merlin (3 of 4)
# Ship: Cambion
# Ship: Merlin Nugoeihuvi Edition
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Frigate").level
    fit.ship.boostItemAttr("shieldThermalDamageResonance", ship.getModifiedItemAttr("shipBonusCF") * level)

########NEW FILE########
__FILENAME__ = shipshieldthermalresistancemc2
# Used by:
# Ship: Broadsword
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Cruiser").level
    fit.ship.boostItemAttr("shieldThermalDamageResonance", ship.getModifiedItemAttr("shipBonusMC2") * level)

########NEW FILE########
__FILENAME__ = shipshieldthermalresistancerookie
# Used by:
# Ship: Ibis
# Ship: Taipan
type = "passive"
def handler(fit, ship, context):
    fit.ship.boostItemAttr("shieldThermalDamageResonance", ship.getModifiedItemAttr("rookieShieldResistBonus"))

########NEW FILE########
__FILENAME__ = shipshieldtransferrange1
# Used by:
# Ship: Basilisk
# Ship: Etana
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Shield Booster",
                                  "shieldTransferRange", ship.getModifiedItemAttr("shipBonusCC") * level)

########NEW FILE########
__FILENAME__ = shipshieldtransferrange2
# Used by:
# Ship: Scimitar
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Shield Booster",
                                  "shieldTransferRange", ship.getModifiedItemAttr("shipBonusMC2") * level)

########NEW FILE########
__FILENAME__ = shipshtdmgbonusgf
# Used by:
# Variations of ship: Incursus (3 of 3)
# Ship: Atron
# Ship: Federation Navy Comet
# Ship: Helios
# Ship: Incursus Aliastra Edition
# Ship: Police Pursuit Comet
# Ship: Taranis
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Hybrid Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("shipBonusGF") * level)

########NEW FILE########
__FILENAME__ = shipshtdmgbonusrookie
# Used by:
# Ship: Velator
# Ship: Violator
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Hybrid Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("rookieSHTDamageBonus"))

########NEW FILE########
__FILENAME__ = shipshtfalloffbonusrookie
# Used by:
# Ship: Violator
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Hybrid Turret"),
                                  "falloff", ship.getModifiedItemAttr("rookieSHTFalloff"))

########NEW FILE########
__FILENAME__ = shipshtoptimalbonusgf
# Used by:
# Ship: Ares
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Hybrid Turret"),
                                  "maxRange", ship.getModifiedItemAttr("shipBonusGF") * level)

########NEW FILE########
__FILENAME__ = shipshttrackingspeedbonusrookie
# Used by:
# Ship: Violator
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Hybrid Turret"),
                                  "trackingSpeed", ship.getModifiedItemAttr("rookieSHTTracking"))

########NEW FILE########
__FILENAME__ = shipsiegelauncherrofbonus2cb
# Used by:
# Ship: Raven
# Ship: Raven State Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Battleship").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Missile Launcher Torpedo",
                                  "speed", ship.getModifiedItemAttr("shipBonus2CB") * level)

########NEW FILE########
__FILENAME__ = shipsmallmissiledmgad1
# Used by:
# Ship: Heretic
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Destroyer").level
    for damageType in ("em", "thermal", "explosive", "kinetic"):
        fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Rockets") or mod.charge.requiresSkill("Light Missiles"),
                                        "%sDamage" % damageType, ship.getModifiedItemAttr("shipBonusAD1") * level)

########NEW FILE########
__FILENAME__ = shipsmallmissileemdmgcf2
# Used by:
# Ship: Kestrel
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Frigate").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Rockets") or mod.charge.requiresSkill("Light Missiles"),
                                    "emDamage", ship.getModifiedItemAttr("shipBonusCF2") * level)

########NEW FILE########
__FILENAME__ = shipsmallmissileexpdmgcf2
# Used by:
# Ship: Kestrel
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Frigate").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Rockets") or mod.charge.requiresSkill("Light Missiles"),
                                    "explosiveDamage", ship.getModifiedItemAttr("shipBonusCF2") * level)

########NEW FILE########
__FILENAME__ = shipsmallmissilekindmgcf2
# Used by:
# Ship: Crow
# Ship: Kestrel
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Frigate").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Rockets") or mod.charge.requiresSkill("Light Missiles"),
                                    "kineticDamage", ship.getModifiedItemAttr("shipBonusCF2") * level)

########NEW FILE########
__FILENAME__ = shipsmallmissilethermdmgcf2
# Used by:
# Ship: Kestrel
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Frigate").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Rockets") or mod.charge.requiresSkill("Light Missiles"),
                                    "thermalDamage", ship.getModifiedItemAttr("shipBonusCF2") * level)

########NEW FILE########
__FILENAME__ = shipsptdmgbonusrookie
# Used by:
# Ship: Echo
# Ship: Reaper
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Projectile Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("rookieSPTDamageBonus"))

########NEW FILE########
__FILENAME__ = shipsptfalloffbonusrookie
# Used by:
# Ship: Echo
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Projectile Turret"),
                                  "falloff", ship.getModifiedItemAttr("rookieSPTFalloff"))

########NEW FILE########
__FILENAME__ = shipsptoptimalbonusmf
# Used by:
# Ship: Chremoas
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Projectile Turret"),
                                  "maxRange", ship.getModifiedItemAttr("shipBonusMF") * level)

########NEW FILE########
__FILENAME__ = shipsptoptimalrangebonusrookie
# Used by:
# Ship: Echo
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Projectile Turret"),
                                  "maxRange", ship.getModifiedItemAttr("rookieSPTOptimal"))

########NEW FILE########
__FILENAME__ = shipspttrackingspeedbonusrookie
# Used by:
# Ship: Echo
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Projectile Turret"),
                                  "trackingSpeed", ship.getModifiedItemAttr("rookieSPTTracking"))

########NEW FILE########
__FILENAME__ = shipstasiswebrangebonusmb
# Used by:
# Ship: Bhaalgorn
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Battleship").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Stasis Web",
                                  "maxRange", ship.getModifiedItemAttr("shipBonusMB") * level)

########NEW FILE########
__FILENAME__ = shipstasiswebstrengthbonusmc2
# Used by:
# Ship: Ashimmu
# Ship: Vigilant
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Stasis Web",
                                  "speedFactor", ship.getModifiedItemAttr("shipBonusMC2") * level)

########NEW FILE########
__FILENAME__ = shipstasiswebstrengthbonusmf2
# Used by:
# Ship: Cruor
# Ship: Daredevil
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Frigate").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Stasis Web",
                                  "speedFactor", ship.getModifiedItemAttr("shipBonusMF2") * level)

########NEW FILE########
__FILENAME__ = shiptcapneedbonusac
# Used by:
# Ship: Devoter
# Ship: Omen
# Ship: Zealot
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Energy Turret"),
                                  "capacitorNeed", ship.getModifiedItemAttr("shipBonusAC") * level)

########NEW FILE########
__FILENAME__ = shiptorpedoaoecloudsize1cb
# Used by:
# Ship: Raven Navy Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Battleship").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Torpedoes"),
                                    "aoeCloudSize", ship.getModifiedItemAttr("shipBonusCB") * level)

########NEW FILE########
__FILENAME__ = shiptorpedorofcb
# Used by:
# Ship: Scorpion Navy Issue
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Battleship").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Missile Launcher Torpedo",
                                  "speed", ship.getModifiedItemAttr("shipBonusCB") * level)

########NEW FILE########
__FILENAME__ = shiptorpedosvelocitybonuscb3
# Used by:
# Variations of ship: Raven (3 of 4)
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Battleship").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Torpedoes"),
                                    "maxVelocity", ship.getModifiedItemAttr("shipBonusCB3") * level)

########NEW FILE########
__FILENAME__ = shiptrackingbonusab
# Used by:
# Ship: Nightmare
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Battleship").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Large Energy Turret"),
                                  "trackingSpeed", ship.getModifiedItemAttr("shipBonusAB2") * level)

########NEW FILE########
__FILENAME__ = shiptrackinglinkrange1fixed
# Used by:
# Ship: Scimitar
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Tracking Computer",
                                  "maxRange", ship.getModifiedItemAttr("shipBonusMC") * level)

########NEW FILE########
__FILENAME__ = shiptrackinglinkrange2group
# Used by:
# Ship: Oneiros
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Cruiser").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Tracking Computer",
                                  "maxRange", ship.getModifiedItemAttr("shipBonusGC2") * level)

########NEW FILE########
__FILENAME__ = shipvelocitybonusai
# Used by:
# Variations of ship: Bestower (2 of 2)
# Ship: Prorator
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Industrial").level
    fit.ship.boostItemAttr("maxVelocity", ship.getModifiedItemAttr("shipBonusAI") * level)

########NEW FILE########
__FILENAME__ = shipvelocitybonusatc1
# Used by:
# Ship: Adrestia
# Ship: Mimir
type = "passive"
def handler(fit, ship, context):
    fit.ship.boostItemAttr("maxVelocity", ship.getModifiedItemAttr("shipBonusATC1"))

########NEW FILE########
__FILENAME__ = shipvelocitybonusmi
# Used by:
# Variations of ship: Mammoth (2 of 2)
# Ship: Hoarder
# Ship: Mammoth Nefantar Edition
# Ship: Prowler
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Industrial").level
    fit.ship.boostItemAttr("maxVelocity", ship.getModifiedItemAttr("shipBonusMI") * level)

########NEW FILE########
__FILENAME__ = shipvelocitybonusrookie
# Used by:
# Ship: Reaper
type = "passive"
def handler(fit, ship, context):
    fit.ship.boostItemAttr("maxVelocity", ship.getModifiedItemAttr("rookieShipVelocityBonus"))

########NEW FILE########
__FILENAME__ = shipwebvelocitybonusrookie
# Used by:
# Ship: Hematos
# Ship: Violator
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Stasis Web",
                                  "speedFactor", ship.getModifiedItemAttr("rookieWebAmount"))

########NEW FILE########
__FILENAME__ = shipxlprojectiledamagerole
# Used by:
# Ship: Naglfar
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Projectile Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("shipBonusPirateFaction"))

########NEW FILE########
__FILENAME__ = shirmishwarfaremindlink
# Used by:
# Implant: Federation Navy Warfare Mindlink
# Implant: Republic Fleet Warfare Mindlink
# Implant: Skirmish Warfare Mindlink
type = "passive"
def handler(fit, implant, context):
    fit.character.getSkill("Skirmish Warfare Specialist").suppress()
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Skirmish Warfare Specialist"),
                                  "commandBonus", implant.getModifiedItemAttr("mindlinkBonus"))

########NEW FILE########
__FILENAME__ = siegemodeeffect6
# Used by:
# Variations of module: Siege Module I (2 of 2)
type = "active"
runTime = "early"
def handler(fit, module, context):
    #Turrets
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Energy Turret") or \
                                  mod.item.requiresSkill("Capital Hybrid Turret") or \
                                  mod.item.requiresSkill("Capital Projectile Turret"),
                                  "damageMultiplier", module.getModifiedItemAttr("damageMultiplierBonus"))

    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Energy Turret") or \
                                  mod.item.requiresSkill("Capital Hybrid Turret") or \
                                  mod.item.requiresSkill("Capital Projectile Turret"),
                                  "trackingSpeed", module.getModifiedItemAttr("trackingSpeedBonus"))

    #Missiles
    for type in ("kinetic", "thermal", "explosive", "em"):
        fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Citadel Torpedoes") or \
                                        mod.charge.requiresSkill("Citadel Cruise Missiles"),
                                        "%sDamage" % type, module.getModifiedItemAttr("damageMultiplierBonus"))

    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Citadel Torpedoes") or \
                                    mod.charge.requiresSkill("Citadel Cruise Missiles"),
                                    "aoeVelocity", module.getModifiedItemAttr("aoeVelocityBonus"))

    #Shield Boosters
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Shield Operation"),
                                  "duration", module.getModifiedItemAttr("shieldBonusDurationBonus"),
                                  stackingPenalties=True)
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Shield Operation"),
                                  "shieldBonus", module.getModifiedItemAttr("shieldBoostMultiplier"),
                                  stackingPenalties=True)

    #Armor Reppers
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Armor Repair Unit",
                                  "armorDamageAmount", module.getModifiedItemAttr("armorDamageAmountBonus"),
                                  stackingPenalties=True)
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Armor Repair Unit",
                                  "duration", module.getModifiedItemAttr("armorDamageDurationBonus"),
                                  stackingPenalties=True)

    #Speed penalty
    fit.ship.boostItemAttr("maxVelocity", module.getModifiedItemAttr("speedFactor"))

    #Mass
    fit.ship.multiplyItemAttr("mass", module.getModifiedItemAttr("massMultiplier"))

    #Scan resolution
    fit.ship.multiplyItemAttr("scanResolution", module.getModifiedItemAttr("scanResolutionMultiplier"),
                              stackingPenalties=True)

    #Max locked targets
    fit.ship.forceItemAttr("maxLockedTargets", module.getModifiedItemAttr("maxLockedTargets"))

    #Block Hostile EWAR and friendly effects
    fit.ship.forceItemAttr("disallowOffensiveModifiers", module.getModifiedItemAttr("disallowOffensiveModifiers"))
    fit.ship.forceItemAttr("disallowAssistance", module.getModifiedItemAttr("disallowAssistance"))

########NEW FILE########
__FILENAME__ = siegesquadroncommand
# Used by:
# Skill: Siege Warfare Specialist
runTime = "early"
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Siege Warfare Specialist"),
                                  "commandBonus", skill.getModifiedItemAttr("squadronCommandBonus") * skill.level)

########NEW FILE########
__FILENAME__ = siegewarfaremindlink
# Used by:
# Implant: Caldari Navy Warfare Mindlink
# Implant: Republic Fleet Warfare Mindlink
# Implant: Siege Warfare Mindlink
type = "passive"
def handler(fit, implant, context):
    fit.character.getSkill("Siege Warfare Specialist").suppress()
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Siege Warfare Specialist"),
                                  "commandBonus", implant.getModifiedItemAttr("mindlinkBonus"))

########NEW FILE########
__FILENAME__ = signatureanalysisscanresolutionbonuspostpercentscanresolutionship
# Used by:
# Implants named like: Zainou 'Gypsy' Signature Analysis SA (6 of 6)
# Modules named like: Targeting System Subcontroller (8 of 8)
# Implant: Quafe Zero
# Skill: Signature Analysis
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    penalized = False if "skill" in context or "implant" in context or "booster" in context else True
    fit.ship.boostItemAttr("scanResolution", container.getModifiedItemAttr("scanResolutionBonus") * level,
                           stackingPenalties=penalized)

########NEW FILE########
__FILENAME__ = signatureradiuspreassignment
# Used by:
# Subsystems from group: Defensive Systems (16 of 16)
type = "passive"
runTime = "early"
def handler(fit, module, context):
    fit.ship.preAssignItemAttr("signatureRadius", module.getModifiedItemAttr("signatureRadius"))

########NEW FILE########
__FILENAME__ = skilladvancedweaponupgradespowerneedbonus
# Used by:
# Skill: Advanced Weapon Upgrades
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Gunnery") or mod.item.requiresSkill("Missile Launcher Operation"),
                                  "power", skill.getModifiedItemAttr("powerNeedBonus") * skill.level)

########NEW FILE########
__FILENAME__ = skilladvancedweaponupgradespowerneedbonusbomblaunchers
# Used by:
# Skill: Advanced Weapon Upgrades
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Bomb Deployment"),
                                  "power", skill.getModifiedItemAttr("powerNeedBonus") * skill.level)

########NEW FILE########
__FILENAME__ = skillbombdeploymentmodulereactivationdelaybonus
# Used by:
# Skill: Bomb Deployment
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Missile Launcher Bomb",
                                  "moduleReactivationDelay", skill.getModifiedItemAttr("rofBonus") * skill.level)

########NEW FILE########
__FILENAME__ = skillcapitalremotehullrepairsystemscapneedbonus
# Used by:
# Skill: Capital Remote Hull Repair Systems
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Remote Hull Repair Systems"),
                                  "capacitorNeed", skill.getModifiedItemAttr("capNeedBonus") * skill.level)

########NEW FILE########
__FILENAME__ = skillcapitalshipsadvancedagility
# Used by:
# Skill: Capital Ships
type = "passive"
def handler(fit, skill, context):
    if fit.ship.item.requiresSkill("Capital Ships"):
        fit.ship.boostItemAttr("agility", skill.getModifiedItemAttr("agilityBonus") * skill.level)

########NEW FILE########
__FILENAME__ = skillfighterbombersdmgbonus
# Used by:
# Skill: Fighter Bombers
type = "passive"
def handler(fit, skill, context):
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Fighter Bombers"),
                                 "damageMultiplier", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)

########NEW FILE########
__FILENAME__ = skillfreightbonus
# Used by:
# Modules named like: Cargohold Optimization (8 of 8)
type = "passive"
def handler(fit, module, context):
    fit.ship.boostItemAttr("capacity", module.getModifiedItemAttr("cargoCapacityBonus"))

########NEW FILE########
__FILENAME__ = skillindustrialreconfigurationconsumptionquantitybonus
# Used by:
# Skill: Industrial Reconfiguration
type = "passive"
def handler(fit, skill, context):
    amount = -skill.getModifiedItemAttr("consumptionQuantityBonus")
    fit.modules.filteredItemIncrease(lambda mod: mod.item.requiresSkill(skill),
                                     "consumptionQuantity", amount * skill.level)

########NEW FILE########
__FILENAME__ = skilljumpdriveconsumptionamountbonuspercentage
# Used by:
# Skill: Jump Fuel Conservation
type = "passive"
def handler(fit, skill, context):
    fit.ship.boostItemAttr("jumpDriveConsumptionAmount", skill.getModifiedItemAttr("consumptionQuantityBonusPercentage") * skill.level)
########NEW FILE########
__FILENAME__ = skillmjddurationbonus
# Used by:
# Skill: Micro Jump Drive Operation
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Micro Jump Drive Operation"),
                                  "duration", skill.getModifiedItemAttr("durationBonus") * skill.level)

########NEW FILE########
__FILENAME__ = skillreactivearmorhardenercapneedbonus
# Used by:
# Skill: Armor Resistance Phasing
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Armor Resistance Shift Hardener",
                                  "capacitorNeed", skill.getModifiedItemAttr("capNeedBonus") * skill.level)

########NEW FILE########
__FILENAME__ = skillreactivearmorhardenerdurationbonus
# Used by:
# Skill: Armor Resistance Phasing
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Armor Resistance Shift Hardener",
                                  "duration", skill.getModifiedItemAttr("durationBonus") * skill.level)

########NEW FILE########
__FILENAME__ = skillremoteecmdurationbonus
# Used by:
# Skill: Projected Electronic Counter Measures
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote ECM Burst",
                                  "duration", skill.getModifiedItemAttr("projECMDurationBonus") * skill.level)

########NEW FILE########
__FILENAME__ = skillremotehullrepairsystemscapneedbonus
# Used by:
# Skill: Remote Hull Repair Systems
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Remote Hull Repair Systems"),
                                  "capacitorNeed", skill.getModifiedItemAttr("capNeedBonus") * skill.level)

########NEW FILE########
__FILENAME__ = skillsiegemoduleconsumptionquantitybonus
# Used by:
# Skill: Tactical Weapon Reconfiguration
type = "passive"
def handler(fit, skill, context):
    amount = -skill.getModifiedItemAttr("consumptionQuantityBonus")
    fit.modules.filteredItemIncrease(lambda mod: mod.item.requiresSkill(skill),
                                     "consumptionQuantity", amount * skill.level)

########NEW FILE########
__FILENAME__ = skillsuperweapondmgbonus
# Used by:
# Skill: Doomsday Operation
type = "passive"
def handler(fit, skill, context):
    damageTypes = ("em", "explosive", "kinetic", "thermal")
    for dmgType in damageTypes:
        dmgAttr = "{0}Damage".format(dmgType)
        fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Super Weapon" and dmgAttr in mod.itemModifiedAttributes,
                                      dmgAttr, skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)

########NEW FILE########
__FILENAME__ = skilltargetbreakercapneedbonus2
# Used by:
# Skill: Target Breaker Amplification
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Target Breaker",
                                  "capacitorNeed", skill.getModifiedItemAttr("capNeedBonus") * skill.level)

########NEW FILE########
__FILENAME__ = skilltargetbreakerdurationbonus2
# Used by:
# Skill: Target Breaker Amplification
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Target Breaker",
                                  "duration", skill.getModifiedItemAttr("durationBonus") * skill.level)

########NEW FILE########
__FILENAME__ = skilltriagemoduleconsumptionquantitybonus
# Used by:
# Skill: Tactical Logistics Reconfiguration
type = "passive"
def handler(fit, skill, context):
    amount = -skill.getModifiedItemAttr("consumptionQuantityBonus")
    fit.modules.filteredItemIncrease(lambda mod: mod.item.requiresSkill(skill),
                                     "consumptionQuantity", amount * skill.level)

########NEW FILE########
__FILENAME__ = skirmishsquadroncommand
# Used by:
# Skill: Skirmish Warfare Specialist
runTime = "early"
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Skirmish Warfare Specialist"),
                                  "commandBonus", skill.getModifiedItemAttr("squadronCommandBonus") * skill.level)

########NEW FILE########
__FILENAME__ = skirmishwarfareagilitybonus
# Used by:
# Implant: Federation Navy Warfare Mindlink
# Implant: Republic Fleet Warfare Mindlink
# Implant: Skirmish Warfare Mindlink
# Skill: Skirmish Warfare
type = "gang"
gangBoost = "agility"
gangBonus = "agilityBonus"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.ship.boostItemAttr(gangBoost, container.getModifiedItemAttr(gangBonus) * level)

########NEW FILE########
__FILENAME__ = slotmodifier
# Used by:
# Items from category: Subsystem (80 of 80)
type = "passive"
def handler(fit, module, context):
    fit.ship.increaseItemAttr("hiSlots", module.getModifiedItemAttr("hiSlotModifier"))
    fit.ship.increaseItemAttr("medSlots", module.getModifiedItemAttr("medSlotModifier"))
    fit.ship.increaseItemAttr("lowSlots", module.getModifiedItemAttr("lowSlotModifier"))

########NEW FILE########
__FILENAME__ = smallenergymaxrangebonus
# Used by:
# Ship: Coercer
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Energy Turret"),
                                  "maxRange", ship.getModifiedItemAttr("maxRangeBonus"))

########NEW FILE########
__FILENAME__ = smallenergyturretdamagemultiplierbonuspostpercentdamagemultiplierlocationshipmodulesrequiringsmallenergyturret
# Used by:
# Implants named like: Inherent Implants 'Lancer' Small Energy Turret SE (6 of 6)
# Skill: Small Energy Turret
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Energy Turret"),
                                  "damageMultiplier", container.getModifiedItemAttr("damageMultiplierBonus") * level)

########NEW FILE########
__FILENAME__ = smallhybridmaxrangebonus
# Used by:
# Variations of ship: Catalyst (6 of 7)
# Ship: Cormorant
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Hybrid Turret"),
                                  "maxRange", ship.getModifiedItemAttr("maxRangeBonus"))
########NEW FILE########
__FILENAME__ = smallhybridturretdamagemultiplierbonuspostpercentdamagemultiplierlocationshipmodulesrequiringsmallhybridturret
# Used by:
# Implants named like: Zainou 'Deadeye' Small Hybrid Turret SH (6 of 6)
# Skill: Small Hybrid Turret
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Hybrid Turret"),
                                  "damageMultiplier", container.getModifiedItemAttr("damageMultiplierBonus") * level)

########NEW FILE########
__FILENAME__ = smallprojectilemaxrangebonus
# Used by:
# Ships named like: Thrasher (2 of 2)
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Projectile Turret"),
                                  "maxRange", ship.getModifiedItemAttr("maxRangeBonus"))

########NEW FILE########
__FILENAME__ = smallprojectileturretdamagemultiplierbonuspostpercentdamagemultiplierlocationshipmodulesrequiringsmallprojectileturret
# Used by:
# Implants named like: Eifyr and Co. 'Gunslinger' Small Projectile Turret SP (6 of 6)
# Skill: Small Projectile Turret
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Small Projectile Turret"),
                                  "damageMultiplier", container.getModifiedItemAttr("damageMultiplierBonus") * level)

########NEW FILE########
__FILENAME__ = speedboostmassaddition
# Used by:
# Variations of module: 100MN Afterburner I (24 of 24)
# Variations of module: 10MN Afterburner I (14 of 14)
# Variations of module: 1MN Afterburner I (15 of 15)
# Module: Civilian Afterburner
type = "active"
runTime = "late"
def handler(fit, module, context):
    fit.ship.increaseItemAttr("mass", module.getModifiedItemAttr("massAddition"))
    speedBoost = module.getModifiedItemAttr("speedFactor")
    mass = fit.ship.getModifiedItemAttr("mass")
    thrust = module.getModifiedItemAttr("speedBoostFactor")
    fit.ship.boostItemAttr("maxVelocity", speedBoost * thrust / mass)

########NEW FILE########
__FILENAME__ = speedboostmasssigrad
# Used by:
# Variations of module: 100MN Microwarpdrive I (24 of 24)
# Variations of module: 10MN Microwarpdrive I (14 of 14)
# Variations of module: 1MN Microwarpdrive I (15 of 15)
type = "active"
runTime = "late"
def handler(fit, module, context):
    fit.ship.increaseItemAttr("mass", module.getModifiedItemAttr("massAddition"))
    speedBoost = module.getModifiedItemAttr("speedFactor")
    mass = fit.ship.getModifiedItemAttr("mass")
    thrust = module.getModifiedItemAttr("speedBoostFactor")
    fit.ship.boostItemAttr("maxVelocity", speedBoost * thrust / mass)
    fit.ship.boostItemAttr("signatureRadius", module.getModifiedItemAttr("signatureRadiusBonus"), stackingPenalties = True)

########NEW FILE########
__FILENAME__ = squadroncommand
# Used by:
# Skill: Warfare Link Specialist
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Gang Coordinator",
                                  "commandBonus", skill.getModifiedItemAttr("squadronCommandBonus") * skill.level)

########NEW FILE########
__FILENAME__ = squadroncommandhidden
# Used by:
# Skill: Warfare Link Specialist
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Gang Coordinator",
                                  "commandBonusHidden", skill.getModifiedItemAttr("squadronCommandBonus") * skill.level)

########NEW FILE########
__FILENAME__ = standardmissilesskillboostmissilevelocitybonus
# Used by:
# Skill: Defender Missiles
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Defender Missiles"),
                                    "maxVelocity", skill.getModifiedItemAttr("missileVelocityBonus") * skill.level)
########NEW FILE########
__FILENAME__ = stripminermaxrangebonus
# Used by:
# Implants named like: Low grade Harvest (5 of 6)
type = "passive"
def handler(fit, implant, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Strip Miner",
                                  "maxRange", implant.getModifiedItemAttr("maxRangeBonus"))

########NEW FILE########
__FILENAME__ = structuralanalysiseffect
# Used by:
# Implants named like: Inherent Implants 'Noble' Repair Proficiency RP (6 of 6)
# Modules named like: Auxiliary Nano Pump (8 of 8)
# Modules named like: QA Multiship Module Players (4 of 4)
# Implant: Imperial Navy Modified 'Noble' Implant
type = "passive"
def handler(fit, container, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Repair Systems"),
                                  "armorDamageAmount", container.getModifiedItemAttr("repairBonus"),
                                  stackingPenalties = "implant" not in context)

########NEW FILE########
__FILENAME__ = structurehpmultiply
# Used by:
# Modules from group: Nanofiber Internal Structure (14 of 14)
# Modules from group: Reinforced Bulkhead (12 of 12)
# Modules named like: QA Multiship Module Players (4 of 4)
type = "passive"
def handler(fit, module, context):
    fit.ship.multiplyItemAttr("hp", module.getModifiedItemAttr("structureHPMultiplier"))
########NEW FILE########
__FILENAME__ = structurehpmultiplypassive
# Used by:
# Modules from group: Expanded Cargohold (13 of 13)
type = "passive"
def handler(fit, module, context):
    fit.ship.multiplyItemAttr("hp", module.getModifiedItemAttr("structureHPMultiplier"))
########NEW FILE########
__FILENAME__ = structurerepair
# Used by:
# Modules from group: Hull Repair Unit (21 of 21)
type = "active"
runTime = "late"
def handler(fit, module, context):
    amount = module.getModifiedItemAttr("structureDamageAmount")
    speed = module.getModifiedItemAttr("duration") / 1000.0
    fit.extraAttributes.increase("hullRepair", amount / speed)
########NEW FILE########
__FILENAME__ = structurestealthemitterarraysigdecrease
# Used by:
# Implants named like: Halo (10 of 12)
# Implants named like: X Instinct Booster (4 of 4)
type = "passive"
def handler(fit, implant, context):
    fit.ship.boostItemAttr("signatureRadius", implant.getModifiedItemAttr("signatureRadiusBonus"))

########NEW FILE########
__FILENAME__ = subsystembonusamarrdefensive2remotearmorrepairamount
# Used by:
# Subsystem: Legion Defensive - Adaptive Augmenter
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Amarr Defensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Armor Repairer",
                                  "armorDamageAmount", module.getModifiedItemAttr("subsystemBonusAmarrDefensive2") * level)

########NEW FILE########
__FILENAME__ = subsystembonusamarrdefensivearmoredwarfare
# Used by:
# Subsystem: Legion Defensive - Warfare Processor
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Amarr Defensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Armored Warfare Specialist"),
                                  "commandBonus", module.getModifiedItemAttr("subsystemBonusAmarrDefensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonusamarrdefensivearmorhp
# Used by:
# Subsystem: Legion Defensive - Augmented Plating
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Amarr Defensive Systems").level
    fit.ship.boostItemAttr("armorHP", module.getModifiedItemAttr("subsystemBonusAmarrDefensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonusamarrdefensivearmorrepairamount
# Used by:
# Subsystem: Legion Defensive - Nanobot Injector
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Amarr Defensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Repair Systems"),
                                  "armorDamageAmount", module.getModifiedItemAttr("subsystemBonusAmarrDefensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonusamarrdefensivearmorresistance
# Used by:
# Subsystem: Legion Defensive - Adaptive Augmenter
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Amarr Defensive Systems").level
    for type in ("Em", "Explosive", "Kinetic", "Thermal"):
        fit.ship.boostItemAttr("armor{0}DamageResonance".format(type), module.getModifiedItemAttr("subsystemBonusAmarrDefensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonusamarrdefensiveinformationwarfare
# Used by:
# Subsystem: Legion Defensive - Warfare Processor
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Amarr Defensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Information Warfare Specialist"),
                                  "commandBonus", module.getModifiedItemAttr("subsystemBonusAmarrDefensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonusamarrdefensiveinformationwarfarehidden
# Used by:
# Subsystem: Legion Defensive - Warfare Processor
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Amarr Defensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Information Warfare Specialist"),
                                  "commandBonusHidden", module.getModifiedItemAttr("subsystemBonusAmarrDefensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonusamarrdefensiveskirmishwarfare
# Used by:
# Subsystem: Legion Defensive - Warfare Processor
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Amarr Defensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Skirmish Warfare Specialist"),
                                  "commandBonus", module.getModifiedItemAttr("subsystemBonusAmarrDefensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonusamarrelectronic2maxtargetingrange
# Used by:
# Subsystem: Legion Electronics - Dissolution Sequencer
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Amarr Electronic Systems").level
    fit.ship.boostItemAttr("maxTargetRange", module.getModifiedItemAttr("subsystemBonusAmarrElectronic2") * level)

########NEW FILE########
__FILENAME__ = subsystembonusamarrelectronic2scanresolution
# Used by:
# Subsystem: Legion Electronics - Tactical Targeting Network
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Amarr Electronic Systems").level
    fit.ship.boostItemAttr("scanResolution", module.getModifiedItemAttr("subsystemBonusAmarrElectronic2") * level)

########NEW FILE########
__FILENAME__ = subsystembonusamarrelectronic2tractorbeamrange
# Used by:
# Subsystem: Legion Electronics - Emergent Locus Analyzer
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Amarr Electronic Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Tractor Beam",
                                  "maxRange", module.getModifiedItemAttr("subsystemBonusAmarrElectronic2") * level)

########NEW FILE########
__FILENAME__ = subsystembonusamarrelectronic2tractorbeamvelocity
# Used by:
# Subsystem: Legion Electronics - Emergent Locus Analyzer
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Amarr Electronic Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Tractor Beam",
                                  "maxTractorVelocity", module.getModifiedItemAttr("subsystemBonusAmarrElectronic2") * level)

########NEW FILE########
__FILENAME__ = subsystembonusamarrelectronicenergydestabilizeramount
# Used by:
# Subsystem: Legion Electronics - Energy Parasitic Complex
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Amarr Electronic Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Energy Destabilizer",
                                  "energyDestabilizationAmount", module.getModifiedItemAttr("subsystemBonusAmarrElectronic") * level)

########NEW FILE########
__FILENAME__ = subsystembonusamarrelectronicenergyvampireamount
# Used by:
# Subsystem: Legion Electronics - Energy Parasitic Complex
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Amarr Electronic Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Energy Vampire",
                                  "powerTransferAmount", module.getModifiedItemAttr("subsystemBonusAmarrElectronic") * level)

########NEW FILE########
__FILENAME__ = subsystembonusamarrelectronicscanprobestrength
# Used by:
# Subsystem: Legion Electronics - Emergent Locus Analyzer
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Amarr Electronic Systems").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.group.name == "Scanner Probe",
                                    "baseSensorStrength", module.getModifiedItemAttr("subsystemBonusAmarrElectronic") * level)

########NEW FILE########
__FILENAME__ = subsystembonusamarrelectronicscanstrengthradar
# Used by:
# Subsystem: Legion Electronics - Dissolution Sequencer
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Amarr Electronic Systems").level
    fit.ship.boostItemAttr("scanRadarStrength", module.getModifiedItemAttr("subsystemBonusAmarrElectronic") * level)

########NEW FILE########
__FILENAME__ = subsystembonusamarrengineeringcapacitorcapacity
# Used by:
# Subsystem: Legion Engineering - Augmented Capacitor Reservoir
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Amarr Engineering Systems").level
    fit.ship.boostItemAttr("capacitorCapacity", module.getModifiedItemAttr("subsystemBonusAmarrEngineering") * level)

########NEW FILE########
__FILENAME__ = subsystembonusamarrengineeringcapacitorrecharge
# Used by:
# Subsystem: Legion Engineering - Capacitor Regeneration Matrix
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Amarr Engineering Systems").level
    fit.ship.boostItemAttr("rechargeRate", module.getModifiedItemAttr("subsystemBonusAmarrEngineering") * level)

########NEW FILE########
__FILENAME__ = subsystembonusamarrengineeringheatdamagereduction
# Used by:
# Subsystem: Legion Engineering - Supplemental Coolant Injector
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Amarr Engineering Systems").level
    fit.modules.filteredItemBoost(lambda mod: True, "heatDamage",
                                  module.getModifiedItemAttr("subsystemBonusAmarrEngineering") * level)

########NEW FILE########
__FILENAME__ = subsystembonusamarrengineeringpoweroutput
# Used by:
# Subsystem: Legion Engineering - Power Core Multiplier
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Amarr Engineering Systems").level
    fit.ship.boostItemAttr("powerOutput", module.getModifiedItemAttr("subsystemBonusAmarrEngineering") * level)

########NEW FILE########
__FILENAME__ = subsystembonusamarroffensive2energyweaponcapacitorneed
# Used by:
# Subsystem: Legion Offensive - Drone Synthesis Projector
# Subsystem: Legion Offensive - Liquid Crystal Magnifiers
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Amarr Offensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Energy Turret"),
                                  "capacitorNeed", module.getModifiedItemAttr("subsystemBonusAmarrOffensive2") * level)

########NEW FILE########
__FILENAME__ = subsystembonusamarroffensive2hamemdamage
# Used by:
# Subsystem: Legion Offensive - Assault Optimization
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Amarr Offensive Systems").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Assault Missiles"),
                                    "emDamage", module.getModifiedItemAttr("subsystemBonusAmarrOffensive2") * level)

########NEW FILE########
__FILENAME__ = subsystembonusamarroffensive2hamexplosivedamage
# Used by:
# Subsystem: Legion Offensive - Assault Optimization
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Amarr Offensive Systems").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Assault Missiles"),
                                    "explosiveDamage", module.getModifiedItemAttr("subsystemBonusAmarrOffensive2") * level)

########NEW FILE########
__FILENAME__ = subsystembonusamarroffensive2hamkineticdamage
# Used by:
# Subsystem: Legion Offensive - Assault Optimization
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Amarr Offensive Systems").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Assault Missiles"),
                                    "kineticDamage", module.getModifiedItemAttr("subsystemBonusAmarrOffensive2") * level)

########NEW FILE########
__FILENAME__ = subsystembonusamarroffensive2hamthermaldamage
# Used by:
# Subsystem: Legion Offensive - Assault Optimization
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Amarr Offensive Systems").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Assault Missiles"),
                                    "thermalDamage", module.getModifiedItemAttr("subsystemBonusAmarrOffensive2") * level)

########NEW FILE########
__FILENAME__ = subsystembonusamarroffensive3dronehp
# Used by:
# Subsystem: Legion Offensive - Drone Synthesis Projector
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Amarr Offensive Systems").level
    for layer in ("shieldCapacity", "armorHP", "hp"):
        fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"), layer,
                                     module.getModifiedItemAttr("subsystemBonusAmarrOffensive3") * level)

########NEW FILE########
__FILENAME__ = subsystembonusamarroffensive3energyweaponmaxrange
# Used by:
# Subsystem: Legion Offensive - Liquid Crystal Magnifiers
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Amarr Offensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Energy Turret"),
                                  "maxRange", module.getModifiedItemAttr("subsystemBonusAmarrOffensive3") * level)

########NEW FILE########
__FILENAME__ = subsystembonusamarroffensiveassaultmissilelauncherrof
# Used by:
# Subsystem: Legion Offensive - Assault Optimization
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Amarr Offensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Missile Launcher Rapid Light",
                                  "speed", module.getModifiedItemAttr("subsystemBonusAmarrOffensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonusamarroffensivedronedamagemultiplier
# Used by:
# Subsystem: Legion Offensive - Drone Synthesis Projector
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Amarr Offensive Systems").level
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                 "damageMultiplier", module.getModifiedItemAttr("subsystemBonusAmarrOffensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonusamarroffensiveenergyweaponcapacitorneed
# Used by:
# Subsystem: Legion Offensive - Covert Reconfiguration
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Amarr Offensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Energy Turret"),
                                  "capacitorNeed", module.getModifiedItemAttr("subsystemBonusAmarrOffensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonusamarroffensiveenergyweapondamagemultiplier
# Used by:
# Subsystem: Legion Offensive - Liquid Crystal Magnifiers
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Amarr Offensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Energy Turret"),
                                  "damageMultiplier", module.getModifiedItemAttr("subsystemBonusAmarrOffensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonusamarroffensiveheavyassaultmissilelauncherrof
# Used by:
# Subsystem: Legion Offensive - Assault Optimization
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Amarr Offensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Missile Launcher Heavy Assault",
                                  "speed", module.getModifiedItemAttr("subsystemBonusAmarrOffensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonusamarroffensiveheavymissilelauncherrof
# Used by:
# Subsystem: Legion Offensive - Assault Optimization
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Amarr Offensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Missile Launcher Heavy",
                                  "speed", module.getModifiedItemAttr("subsystemBonusAmarrOffensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonusamarrpropulsionafterburnerspeedfactor
# Used by:
# Subsystem: Legion Propulsion - Fuel Catalyst
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Amarr Propulsion Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Afterburner"),
                                  "speedFactor", module.getModifiedItemAttr("subsystemBonusAmarrPropulsion") * level)

########NEW FILE########
__FILENAME__ = subsystembonusamarrpropulsionagility
# Used by:
# Subsystem: Legion Propulsion - Interdiction Nullifier
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Amarr Propulsion Systems").level
    fit.ship.boostItemAttr("agility", module.getModifiedItemAttr("subsystemBonusAmarrPropulsion") * level)

########NEW FILE########
__FILENAME__ = subsystembonusamarrpropulsionmaxvelocity
# Used by:
# Subsystem: Legion Propulsion - Chassis Optimization
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Amarr Propulsion Systems").level
    fit.ship.boostItemAttr("maxVelocity", module.getModifiedItemAttr("subsystemBonusAmarrPropulsion") * level)

########NEW FILE########
__FILENAME__ = subsystembonusamarrpropulsionmwdpenalty
# Used by:
# Subsystem: Legion Propulsion - Wake Limiter
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Amarr Propulsion Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("High Speed Maneuvering"),
                                  "signatureRadiusBonus", module.getModifiedItemAttr("subsystemBonusAmarrPropulsion") * level)

########NEW FILE########
__FILENAME__ = subsystembonuscaldaridefensive2remoteshieldtransporteramount
# Used by:
# Subsystem: Tengu Defensive - Adaptive Shielding
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Caldari Defensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Shield Booster",
                                  "shieldBonus", module.getModifiedItemAttr("subsystemBonusCaldariDefensive2") * level)

########NEW FILE########
__FILENAME__ = subsystembonuscaldaridefensiveinformationwarfare
# Used by:
# Subsystem: Tengu Defensive - Warfare Processor
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Caldari Defensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Information Warfare Specialist"),
                                  "commandBonus", module.getModifiedItemAttr("subsystemBonusCaldariDefensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonuscaldaridefensiveinformationwarfarehidden
# Used by:
# Subsystem: Tengu Defensive - Warfare Processor
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Caldari Defensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Information Warfare Specialist"),
                                  "commandBonusHidden", module.getModifiedItemAttr("subsystemBonusCaldariDefensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonuscaldaridefensiveshieldboostamount
# Used by:
# Subsystem: Tengu Defensive - Amplification Node
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Caldari Defensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Shield Operation"),
                                  "shieldBonus", module.getModifiedItemAttr("subsystemBonusCaldariDefensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonuscaldaridefensiveshieldhp
# Used by:
# Subsystem: Tengu Defensive - Supplemental Screening
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Caldari Defensive Systems").level
    fit.ship.boostItemAttr("shieldCapacity", module.getModifiedItemAttr("subsystemBonusCaldariDefensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonuscaldaridefensiveshieldresistance
# Used by:
# Subsystem: Tengu Defensive - Adaptive Shielding
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Caldari Defensive Systems").level
    for type in ("Em", "Explosive", "Kinetic", "Thermal"):
        fit.ship.boostItemAttr("shield{0}DamageResonance".format(type), module.getModifiedItemAttr("subsystemBonusCaldariDefensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonuscaldaridefensivesiegewarfare
# Used by:
# Subsystem: Tengu Defensive - Warfare Processor
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Caldari Defensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Siege Warfare Specialist"),
                                  "commandBonus", module.getModifiedItemAttr("subsystemBonusCaldariDefensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonuscaldaridefensiveskirmishwarfare
# Used by:
# Subsystem: Tengu Defensive - Warfare Processor
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Caldari Defensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Skirmish Warfare Specialist"),
                                  "commandBonus", module.getModifiedItemAttr("subsystemBonusCaldariDefensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonuscaldarielectronic2maxtargetingrange
# Used by:
# Subsystem: Tengu Electronics - Dissolution Sequencer
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Caldari Electronic Systems").level
    fit.ship.boostItemAttr("maxTargetRange", module.getModifiedItemAttr("subsystemBonusCaldariElectronic2") * level)

########NEW FILE########
__FILENAME__ = subsystembonuscaldarielectronic2tractorbeamrange
# Used by:
# Subsystem: Tengu Electronics - Emergent Locus Analyzer
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Caldari Electronic Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Tractor Beam",
                                  "maxRange", module.getModifiedItemAttr("subsystemBonusCaldariElectronic2") * level)

########NEW FILE########
__FILENAME__ = subsystembonuscaldarielectronic2tractorbeamvelocity
# Used by:
# Subsystem: Tengu Electronics - Emergent Locus Analyzer
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Caldari Electronic Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Tractor Beam",
                                  "maxTractorVelocity", module.getModifiedItemAttr("subsystemBonusCaldariElectronic2") * level)

########NEW FILE########
__FILENAME__ = subsystembonuscaldarielectroniccpu
# Used by:
# Subsystem: Tengu Electronics - CPU Efficiency Gate
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Caldari Electronic Systems").level
    fit.ship.boostItemAttr("cpuOutput", module.getModifiedItemAttr("subsystemBonusCaldariElectronic") * level)

########NEW FILE########
__FILENAME__ = subsystembonuscaldarielectronicecmrange
# Used by:
# Subsystem: Tengu Electronics - Obfuscation Manifold
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Caldari Electronic Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "ECM",
                                  "maxRange", module.getModifiedItemAttr("subsystemBonusCaldariElectronic") * level)

########NEW FILE########
__FILENAME__ = subsystembonuscaldarielectronicscanprobestrength
# Used by:
# Subsystem: Tengu Electronics - Emergent Locus Analyzer
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Caldari Electronic Systems").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.group.name == "Scanner Probe",
                                    "baseSensorStrength", module.getModifiedItemAttr("subsystemBonusCaldariElectronic") * level)

########NEW FILE########
__FILENAME__ = subsystembonuscaldarielectronicscanstrengthgravimetric
# Used by:
# Subsystem: Tengu Electronics - Dissolution Sequencer
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Caldari Electronic Systems").level
    fit.ship.boostItemAttr("scanGravimetricStrength", module.getModifiedItemAttr("subsystemBonusCaldariElectronic") * level)

########NEW FILE########
__FILENAME__ = subsystembonuscaldariengineeringcapacitorcapacity
# Used by:
# Subsystem: Tengu Engineering - Augmented Capacitor Reservoir
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Caldari Engineering Systems").level
    fit.ship.boostItemAttr("capacitorCapacity", module.getModifiedItemAttr("subsystemBonusCaldariEngineering") * level)

########NEW FILE########
__FILENAME__ = subsystembonuscaldariengineeringcapacitorrecharge
# Used by:
# Subsystem: Tengu Engineering - Capacitor Regeneration Matrix
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Caldari Engineering Systems").level
    fit.ship.boostItemAttr("rechargeRate", module.getModifiedItemAttr("subsystemBonusCaldariEngineering") * level)

########NEW FILE########
__FILENAME__ = subsystembonuscaldariengineeringheatdamagereduction
# Used by:
# Subsystem: Tengu Engineering - Supplemental Coolant Injector
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Caldari Engineering Systems").level
    fit.modules.filteredItemBoost(lambda mod: True, "heatDamage",
                                  module.getModifiedItemAttr("subsystemBonusCaldariEngineering") * level)

########NEW FILE########
__FILENAME__ = subsystembonuscaldariengineeringpoweroutput
# Used by:
# Subsystem: Tengu Engineering - Power Core Multiplier
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Caldari Engineering Systems").level
    fit.ship.boostItemAttr("powerOutput", module.getModifiedItemAttr("subsystemBonusCaldariEngineering") * level)

########NEW FILE########
__FILENAME__ = subsystembonuscaldarioffensive2hybridweapondamagemultiplier
# Used by:
# Subsystem: Tengu Offensive - Magnetic Infusion Basin
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Caldari Offensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Hybrid Turret"),
                                  "damageMultiplier", module.getModifiedItemAttr("subsystemBonusCaldariOffensive2") * level)

########NEW FILE########
__FILENAME__ = subsystembonuscaldarioffensive2missilelauncherkineticdamage
# Used by:
# Subsystem: Tengu Offensive - Accelerated Ejection Bay
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Caldari Offensive Systems").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Missile Launcher Operation"),
                                    "kineticDamage", module.getModifiedItemAttr("subsystemBonusCaldariOffensive2") * level)

########NEW FILE########
__FILENAME__ = subsystembonuscaldarioffensive3ewstrengthgrav
# Used by:
# Subsystem: Tengu Offensive - Rifling Launcher Pattern
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Caldari Offensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "ECM",
                                  "scanGravimetricStrengthBonus", module.getModifiedItemAttr("subsystemBonusCaldariOffensive3") * level)

########NEW FILE########
__FILENAME__ = subsystembonuscaldarioffensive3ewstrengthladar
# Used by:
# Subsystem: Tengu Offensive - Rifling Launcher Pattern
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Caldari Offensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "ECM",
                                  "scanLadarStrengthBonus", module.getModifiedItemAttr("subsystemBonusCaldariOffensive3") * level)

########NEW FILE########
__FILENAME__ = subsystembonuscaldarioffensive3ewstrengthmagn
# Used by:
# Subsystem: Tengu Offensive - Rifling Launcher Pattern
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Caldari Offensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "ECM",
                                  "scanMagnetometricStrengthBonus", module.getModifiedItemAttr("subsystemBonusCaldariOffensive3") * level)

########NEW FILE########
__FILENAME__ = subsystembonuscaldarioffensive3ewstrengthradar
# Used by:
# Subsystem: Tengu Offensive - Rifling Launcher Pattern
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Caldari Offensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "ECM",
                                  "scanRadarStrengthBonus", module.getModifiedItemAttr("subsystemBonusCaldariOffensive3") * level)

########NEW FILE########
__FILENAME__ = subsystembonuscaldarioffensive3heavyassaultmissilevelocity
# Used by:
# Subsystem: Tengu Offensive - Accelerated Ejection Bay
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Caldari Offensive Systems").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Assault Missiles"),
                                    "maxVelocity", module.getModifiedItemAttr("subsystemBonusCaldariOffensive3") * level)

########NEW FILE########
__FILENAME__ = subsystembonuscaldarioffensive3heavymissilevelocity
# Used by:
# Subsystem: Tengu Offensive - Accelerated Ejection Bay
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Caldari Offensive Systems").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Heavy Missiles"),
                                    "maxVelocity", module.getModifiedItemAttr("subsystemBonusCaldariOffensive3") * level)

########NEW FILE########
__FILENAME__ = subsystembonuscaldarioffensiveassaultmissilelauncherrof
# Used by:
# Variations of subsystem: Tengu Offensive - Accelerated Ejection Bay (3 of 4)
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Caldari Offensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Missile Launcher Rapid Light",
                                  "speed", module.getModifiedItemAttr("subsystemBonusCaldariOffensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonuscaldarioffensiveheavyassaultmissilelauncherrof
# Used by:
# Variations of subsystem: Tengu Offensive - Accelerated Ejection Bay (3 of 4)
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Caldari Offensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Missile Launcher Heavy Assault",
                                  "speed", module.getModifiedItemAttr("subsystemBonusCaldariOffensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonuscaldarioffensiveheavymissilelauncherrof
# Used by:
# Variations of subsystem: Tengu Offensive - Accelerated Ejection Bay (3 of 4)
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Caldari Offensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Missile Launcher Heavy",
                                  "speed", module.getModifiedItemAttr("subsystemBonusCaldariOffensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonuscaldarioffensivehybridweaponmaxrange
# Used by:
# Subsystem: Tengu Offensive - Magnetic Infusion Basin
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Caldari Offensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Hybrid Turret"),
                                  "maxRange", module.getModifiedItemAttr("subsystemBonusCaldariOffensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonuscaldaripropulsion2warpcapacitor2
# Used by:
# Subsystem: Tengu Propulsion - Gravitational Capacitor
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Caldari Propulsion Systems").level
    fit.ship.boostItemAttr("warpCapacitorNeed", module.getModifiedItemAttr("subsystemBonusCaldariPropulsion2") * level)

########NEW FILE########
__FILENAME__ = subsystembonuscaldaripropulsionafterburnerspeedfactor
# Used by:
# Subsystem: Tengu Propulsion - Fuel Catalyst
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Caldari Propulsion Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Afterburner"),
                                  "speedFactor", module.getModifiedItemAttr("subsystemBonusCaldariPropulsion") * level)

########NEW FILE########
__FILENAME__ = subsystembonuscaldaripropulsionagility
# Used by:
# Subsystem: Tengu Propulsion - Intercalated Nanofibers
# Subsystem: Tengu Propulsion - Interdiction Nullifier
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Caldari Propulsion Systems").level
    fit.ship.boostItemAttr("agility", module.getModifiedItemAttr("subsystemBonusCaldariPropulsion") * level)

########NEW FILE########
__FILENAME__ = subsystembonuscaldaripropulsionwarpspeed
# Used by:
# Subsystem: Tengu Propulsion - Gravitational Capacitor
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Caldari Propulsion Systems").level
    fit.ship.boostItemAttr("baseWarpSpeed", module.getModifiedItemAttr("subsystemBonusCaldariPropulsion") * level)

########NEW FILE########
__FILENAME__ = subsystembonusgallentedefensive2remotearmorrepairamount
# Used by:
# Subsystem: Proteus Defensive - Adaptive Augmenter
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Gallente Defensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Armor Repairer",
                                  "armorDamageAmount", module.getModifiedItemAttr("subsystemBonusGallenteDefensive2") * level)

########NEW FILE########
__FILENAME__ = subsystembonusgallentedefensivearmoredwarfare
# Used by:
# Subsystem: Proteus Defensive - Warfare Processor
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Gallente Defensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Armored Warfare Specialist"),
                                  "commandBonus", module.getModifiedItemAttr("subsystemBonusGallenteDefensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonusgallentedefensivearmorhp
# Used by:
# Subsystem: Proteus Defensive - Augmented Plating
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Gallente Defensive Systems").level
    fit.ship.boostItemAttr("armorHP", module.getModifiedItemAttr("subsystemBonusGallenteDefensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonusgallentedefensivearmorrepairamount
# Used by:
# Subsystem: Proteus Defensive - Nanobot Injector
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Gallente Defensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Repair Systems"),
                                  "armorDamageAmount", module.getModifiedItemAttr("subsystemBonusGallenteDefensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonusgallentedefensivearmorresistance
# Used by:
# Subsystem: Proteus Defensive - Adaptive Augmenter
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Gallente Defensive Systems").level
    for type in ("Em", "Explosive", "Kinetic", "Thermal"):
        fit.ship.boostItemAttr("armor{0}DamageResonance".format(type),
                               module.getModifiedItemAttr("subsystemBonusGallenteDefensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonusgallentedefensiveinformationwarfare
# Used by:
# Subsystem: Proteus Defensive - Warfare Processor
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Gallente Defensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Information Warfare Specialist"),
                                  "commandBonus", module.getModifiedItemAttr("subsystemBonusGallenteDefensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonusgallentedefensiveinformationwarfarehidden
# Used by:
# Subsystem: Proteus Defensive - Warfare Processor
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Gallente Defensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Information Warfare Specialist"),
                                  "commandBonusHidden", module.getModifiedItemAttr("subsystemBonusGallenteDefensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonusgallentedefensiveskirmishwarfare
# Used by:
# Subsystem: Proteus Defensive - Warfare Processor
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Gallente Defensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Skirmish Warfare Specialist"),
                                  "commandBonus", module.getModifiedItemAttr("subsystemBonusGallenteDefensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonusgallenteelectronic2maxtargetingrange
# Used by:
# Subsystem: Proteus Electronics - Dissolution Sequencer
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Gallente Electronic Systems").level
    fit.ship.boostItemAttr("maxTargetRange", module.getModifiedItemAttr("subsystemBonusGallenteElectronic2") * level)

########NEW FILE########
__FILENAME__ = subsystembonusgallenteelectronic2tractorbeamrange
# Used by:
# Subsystem: Proteus Electronics - Emergent Locus Analyzer
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Gallente Electronic Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Tractor Beam",
                                  "maxRange", module.getModifiedItemAttr("subsystemBonusGallenteElectronic2") * level)

########NEW FILE########
__FILENAME__ = subsystembonusgallenteelectronic2tractorbeamvelocity
# Used by:
# Subsystem: Proteus Electronics - Emergent Locus Analyzer
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Gallente Electronic Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Tractor Beam",
                                  "maxTractorVelocity", module.getModifiedItemAttr("subsystemBonusGallenteElectronic2") * level)

########NEW FILE########
__FILENAME__ = subsystembonusgallenteelectroniccpu
# Used by:
# Subsystem: Proteus Electronics - CPU Efficiency Gate
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Gallente Electronic Systems").level
    fit.ship.boostItemAttr("cpuOutput", module.getModifiedItemAttr("subsystemBonusGallenteElectronic") * level)

########NEW FILE########
__FILENAME__ = subsystembonusgallenteelectronicscanprobestrength
# Used by:
# Subsystem: Proteus Electronics - Emergent Locus Analyzer
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Gallente Electronic Systems").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.group.name == "Scanner Probe",
                                    "baseSensorStrength", module.getModifiedItemAttr("subsystemBonusGallenteElectronic") * level)

########NEW FILE########
__FILENAME__ = subsystembonusgallenteelectronicscanstrengthmagnetometric
# Used by:
# Subsystem: Proteus Electronics - Dissolution Sequencer
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Gallente Electronic Systems").level
    fit.ship.boostItemAttr("scanMagnetometricStrength", module.getModifiedItemAttr("subsystemBonusGallenteElectronic") * level)

########NEW FILE########
__FILENAME__ = subsystembonusgallenteelectronicwarpscramblerange
# Used by:
# Subsystem: Proteus Electronics - Friction Extension Processor
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Gallente Electronic Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Warp Scrambler",
                                  "maxRange", module.getModifiedItemAttr("subsystemBonusGallenteElectronic") * level)

########NEW FILE########
__FILENAME__ = subsystembonusgallenteengineering2dronemwd
# Used by:
# Subsystem: Proteus Engineering - Augmented Capacitor Reservoir
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Gallente Engineering Systems").level
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"), "maxVelocity",
                                 module.getModifiedItemAttr("subsystemBonusGallenteEngineering2") * level)

########NEW FILE########
__FILENAME__ = subsystembonusgallenteengineeringcapacitorrecharge
# Used by:
# Subsystem: Proteus Engineering - Capacitor Regeneration Matrix
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Gallente Engineering Systems").level
    fit.ship.boostItemAttr("rechargeRate", module.getModifiedItemAttr("subsystemBonusGallenteEngineering") * level)

########NEW FILE########
__FILENAME__ = subsystembonusgallenteengineeringdronehp
# Used by:
# Subsystem: Proteus Engineering - Augmented Capacitor Reservoir
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Gallente Engineering Systems").level
    for layer in ("shieldCapacity", "armorHP", "hp"):
        fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"), layer,
                                     module.getModifiedItemAttr("subsystemBonusGallenteEngineering") * level)

########NEW FILE########
__FILENAME__ = subsystembonusgallenteengineeringheatdamagereduction
# Used by:
# Subsystem: Proteus Engineering - Supplemental Coolant Injector
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Gallente Engineering Systems").level
    fit.modules.filteredItemBoost(lambda mod: True, "heatDamage",
                                  module.getModifiedItemAttr("subsystemBonusGallenteEngineering") * level)

########NEW FILE########
__FILENAME__ = subsystembonusgallenteengineeringpoweroutput
# Used by:
# Subsystem: Proteus Engineering - Power Core Multiplier
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Gallente Engineering Systems").level
    fit.ship.boostItemAttr("powerOutput", module.getModifiedItemAttr("subsystemBonusGallenteEngineering") * level)

########NEW FILE########
__FILENAME__ = subsystembonusgallenteoffensive2hybridweapondamagemultiplier
# Used by:
# Variations of subsystem: Proteus Offensive - Dissonic Encoding Platform (3 of 4)
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Gallente Offensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Hybrid Turret"),
                                  "damageMultiplier", module.getModifiedItemAttr("subsystemBonusGallenteOffensive2") * level)

########NEW FILE########
__FILENAME__ = subsystembonusgallenteoffensive3dronedamagemultiplier
# Used by:
# Subsystem: Proteus Offensive - Drone Synthesis Projector
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Gallente Offensive Systems").level
    fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"),
                                 "damageMultiplier", module.getModifiedItemAttr("subsystemBonusGallenteOffensive3") * level)

########NEW FILE########
__FILENAME__ = subsystembonusgallenteoffensive3turrettracking
# Used by:
# Subsystem: Proteus Offensive - Dissonic Encoding Platform
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Gallente Offensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Hybrid Turret"),
                                  "trackingSpeed", module.getModifiedItemAttr("subsystemBonusGallenteOffensive3") * level)

########NEW FILE########
__FILENAME__ = subsystembonusgallenteoffensivedronehp
# Used by:
# Subsystem: Proteus Offensive - Drone Synthesis Projector
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Gallente Offensive Systems").level
    for layer in ("shieldCapacity", "armorHP", "hp"):
        fit.drones.filteredItemBoost(lambda drone: drone.item.requiresSkill("Drones"), layer,
                                     module.getModifiedItemAttr("subsystemBonusGallenteOffensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonusgallenteoffensivehybridweapondamagemultiplier
# Used by:
# Subsystem: Proteus Offensive - Covert Reconfiguration
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Gallente Offensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Hybrid Turret"),
                                  "damageMultiplier", module.getModifiedItemAttr("subsystemBonusGallenteOffensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonusgallenteoffensivehybridweaponfalloff
# Used by:
# Subsystem: Proteus Offensive - Dissonic Encoding Platform
# Subsystem: Proteus Offensive - Hybrid Propulsion Armature
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Gallente Offensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Hybrid Turret"),
                                  "falloff", module.getModifiedItemAttr("subsystemBonusGallenteOffensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonusgallentepropulsion2warpcapacitor
# Used by:
# Subsystem: Proteus Propulsion - Gravitational Capacitor
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Gallente Propulsion Systems").level
    fit.ship.boostItemAttr("warpCapacitorNeed", module.getModifiedItemAttr("subsystemBonusGallentePropulsion2") * level)

########NEW FILE########
__FILENAME__ = subsystembonusgallentepropulsionabmwdcapneed
# Used by:
# Subsystem: Proteus Propulsion - Localized Injectors
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Gallente Propulsion Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Propulsion Module",
                                  "capacitorNeed", module.getModifiedItemAttr("subsystemBonusGallentePropulsion") * level)

########NEW FILE########
__FILENAME__ = subsystembonusgallentepropulsionagility
# Used by:
# Subsystem: Proteus Propulsion - Interdiction Nullifier
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Gallente Propulsion Systems").level
    fit.ship.boostItemAttr("agility", module.getModifiedItemAttr("subsystemBonusGallentePropulsion") * level)

########NEW FILE########
__FILENAME__ = subsystembonusgallentepropulsionmwdpenalty
# Used by:
# Subsystem: Proteus Propulsion - Wake Limiter
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Gallente Propulsion Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("High Speed Maneuvering"),
                                  "signatureRadiusBonus", module.getModifiedItemAttr("subsystemBonusGallentePropulsion") * level)

########NEW FILE########
__FILENAME__ = subsystembonusgallentepropulsionwarpspeed
# Used by:
# Subsystem: Proteus Propulsion - Gravitational Capacitor
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Gallente Propulsion Systems").level
    fit.ship.boostItemAttr("baseWarpSpeed", module.getModifiedItemAttr("subsystemBonusGallentePropulsion") * level)

########NEW FILE########
__FILENAME__ = subsystembonusminmatardefensive2remoteshieldtransporteramount
# Used by:
# Subsystem: Loki Defensive - Adaptive Shielding
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Minmatar Defensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Remote Shield Booster",
                                  "shieldBonus", module.getModifiedItemAttr("subsystemBonusMinmatarDefensive2") * level)

########NEW FILE########
__FILENAME__ = subsystembonusminmatardefensivearmoredwarfare
# Used by:
# Subsystem: Loki Defensive - Warfare Processor
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Minmatar Defensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Armored Warfare Specialist"),
                                  "commandBonus", module.getModifiedItemAttr("subsystemBonusMinmatarDefensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonusminmatardefensivearmorresistance
# Used by:
# Subsystem: Loki Defensive - Adaptive Augmenter
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Minmatar Defensive Systems").level
    for type in ("Em", "Explosive", "Kinetic", "Thermal"):
        fit.ship.boostItemAttr("armor{0}DamageResonance".format(type),
                               module.getModifiedItemAttr("subsystemBonusMinmatarDefensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonusminmatardefensiveshieldresistance
# Used by:
# Subsystem: Loki Defensive - Adaptive Shielding
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Minmatar Defensive Systems").level
    for type in ("Em", "Explosive", "Kinetic", "Thermal"):
        fit.ship.boostItemAttr("shield{0}DamageResonance".format(type), module.getModifiedItemAttr("subsystemBonusMinmatarDefensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonusminmatardefensivesiegewarfare
# Used by:
# Subsystem: Loki Defensive - Warfare Processor
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Minmatar Defensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Siege Warfare Specialist"),
                                  "commandBonus", module.getModifiedItemAttr("subsystemBonusMinmatarDefensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonusminmatardefensivesignatureradius
# Used by:
# Subsystem: Loki Defensive - Amplification Node
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Minmatar Defensive Systems").level
    fit.ship.boostItemAttr("signatureRadius", module.getModifiedItemAttr("subsystemBonusMinmatarDefensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonusminmatardefensiveskirmishwarfare
# Used by:
# Subsystem: Loki Defensive - Warfare Processor
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Minmatar Defensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Skirmish Warfare Specialist"),
                                  "commandBonus", module.getModifiedItemAttr("subsystemBonusMinmatarDefensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonusminmatarelectronic2maxtargetingrange
# Used by:
# Subsystem: Loki Electronics - Dissolution Sequencer
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Minmatar Electronic Systems").level
    fit.ship.boostItemAttr("maxTargetRange", module.getModifiedItemAttr("subsystemBonusMinmatarElectronic2") * level)

########NEW FILE########
__FILENAME__ = subsystembonusminmatarelectronic2scanresolution
# Used by:
# Subsystem: Loki Electronics - Tactical Targeting Network
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Minmatar Electronic Systems").level
    fit.ship.boostItemAttr("scanResolution", module.getModifiedItemAttr("subsystemBonusMinmatarElectronic2") * level)

########NEW FILE########
__FILENAME__ = subsystembonusminmatarelectronic2tractorbeamrange
# Used by:
# Subsystem: Loki Electronics - Emergent Locus Analyzer
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Minmatar Electronic Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Tractor Beam",
                                  "maxRange", module.getModifiedItemAttr("subsystemBonusMinmatarElectronic2") * level)

########NEW FILE########
__FILENAME__ = subsystembonusminmatarelectronic2tractorbeamvelocity
# Used by:
# Subsystem: Loki Electronics - Emergent Locus Analyzer
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Minmatar Electronic Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Tractor Beam",
                                  "maxTractorVelocity", module.getModifiedItemAttr("subsystemBonusMinmatarElectronic2") * level)

########NEW FILE########
__FILENAME__ = subsystembonusminmatarelectronicscanprobestrength
# Used by:
# Subsystem: Loki Electronics - Emergent Locus Analyzer
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Minmatar Electronic Systems").level
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.group.name == "Scanner Probe",
                                    "baseSensorStrength", module.getModifiedItemAttr("subsystemBonusMinmatarElectronic") * level)

########NEW FILE########
__FILENAME__ = subsystembonusminmatarelectronicscanstrengthladar
# Used by:
# Subsystem: Loki Electronics - Dissolution Sequencer
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Minmatar Electronic Systems").level
    fit.ship.boostItemAttr("scanLadarStrength", module.getModifiedItemAttr("subsystemBonusMinmatarElectronic") * level)

########NEW FILE########
__FILENAME__ = subsystembonusminmatarelectronicstasiswebifierrange
# Used by:
# Subsystem: Loki Electronics - Immobility Drivers
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Minmatar Electronic Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Stasis Web",
                                  "maxRange", module.getModifiedItemAttr("subsystemBonusMinmatarElectronic") * level)

########NEW FILE########
__FILENAME__ = subsystembonusminmatarengineeringcapacitorcapacity
# Used by:
# Subsystem: Loki Engineering - Augmented Capacitor Reservoir
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Minmatar Engineering Systems").level
    fit.ship.boostItemAttr("capacitorCapacity", module.getModifiedItemAttr("subsystemBonusMinmatarEngineering") * level)

########NEW FILE########
__FILENAME__ = subsystembonusminmatarengineeringcapacitorrecharge
# Used by:
# Subsystem: Loki Engineering - Capacitor Regeneration Matrix
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Minmatar Engineering Systems").level
    fit.ship.boostItemAttr("rechargeRate", module.getModifiedItemAttr("subsystemBonusMinmatarEngineering") * level)

########NEW FILE########
__FILENAME__ = subsystembonusminmatarengineeringheatdamagereduction
# Used by:
# Subsystem: Loki Engineering - Supplemental Coolant Injector
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Minmatar Engineering Systems").level
    fit.modules.filteredItemBoost(lambda mod: True, "heatDamage",
                                  module.getModifiedItemAttr("subsystemBonusMinmatarEngineering") * level)

########NEW FILE########
__FILENAME__ = subsystembonusminmatarengineeringpoweroutput
# Used by:
# Subsystem: Loki Engineering - Power Core Multiplier
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Minmatar Engineering Systems").level
    fit.ship.boostItemAttr("powerOutput", module.getModifiedItemAttr("subsystemBonusMinmatarEngineering") * level)

########NEW FILE########
__FILENAME__ = subsystembonusminmataroffensive2projectileweapondamagemultiplier
# Used by:
# Subsystem: Loki Offensive - Turret Concurrence Registry
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Minmatar Offensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Projectile Turret"),
                                  "damageMultiplier", module.getModifiedItemAttr("subsystemBonusMinmatarOffensive2") * level)

########NEW FILE########
__FILENAME__ = subsystembonusminmataroffensive2projectileweaponrof
# Used by:
# Subsystem: Loki Offensive - Hardpoint Efficiency Configuration
# Subsystem: Loki Offensive - Projectile Scoping Array
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Minmatar Offensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Projectile Turret"),
                                  "speed", module.getModifiedItemAttr("subsystemBonusMinmatarOffensive2") * level)

########NEW FILE########
__FILENAME__ = subsystembonusminmataroffensive3turrettracking
# Used by:
# Subsystem: Loki Offensive - Turret Concurrence Registry
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Minmatar Offensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Projectile Turret"),
                                  "trackingSpeed", module.getModifiedItemAttr("subsystemBonusMinmatarOffensive3") * level)

########NEW FILE########
__FILENAME__ = subsystembonusminmataroffensiveassaultmissilelauncherrof
# Used by:
# Subsystem: Loki Offensive - Hardpoint Efficiency Configuration
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Minmatar Offensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Missile Launcher Rapid Light",
                                  "speed", module.getModifiedItemAttr("subsystemBonusMinmatarOffensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonusminmataroffensiveheavyassaultmissilelauncherrof
# Used by:
# Subsystem: Loki Offensive - Hardpoint Efficiency Configuration
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Minmatar Offensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Missile Launcher Heavy Assault",
                                  "speed", module.getModifiedItemAttr("subsystemBonusMinmatarOffensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonusminmataroffensiveheavymissilelauncherrof
# Used by:
# Subsystem: Loki Offensive - Hardpoint Efficiency Configuration
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Minmatar Offensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Missile Launcher Heavy",
                                  "speed", module.getModifiedItemAttr("subsystemBonusMinmatarOffensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonusminmataroffensiveprojectileweaponfalloff
# Used by:
# Subsystem: Loki Offensive - Projectile Scoping Array
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Minmatar Offensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Projectile Turret"),
                                  "falloff", module.getModifiedItemAttr("subsystemBonusMinmatarOffensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonusminmataroffensiveprojectileweaponmaxrange
# Used by:
# Subsystem: Loki Offensive - Turret Concurrence Registry
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Minmatar Offensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Projectile Turret"),
                                  "maxRange", module.getModifiedItemAttr("subsystemBonusMinmatarOffensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonusminmataroffensiveprojectileweaponrof
# Used by:
# Subsystem: Loki Offensive - Covert Reconfiguration
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Minmatar Offensive Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Medium Projectile Turret"),
                                  "speed", module.getModifiedItemAttr("subsystemBonusMinmatarOffensive") * level)

########NEW FILE########
__FILENAME__ = subsystembonusminmatarpropulsionafterburnerspeedfactor
# Used by:
# Subsystem: Loki Propulsion - Fuel Catalyst
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Minmatar Propulsion Systems").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Afterburner"),
                                  "speedFactor", module.getModifiedItemAttr("subsystemBonusMinmatarPropulsion") * level)

########NEW FILE########
__FILENAME__ = subsystembonusminmatarpropulsionagility
# Used by:
# Subsystem: Loki Propulsion - Intercalated Nanofibers
# Subsystem: Loki Propulsion - Interdiction Nullifier
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Minmatar Propulsion Systems").level
    fit.ship.boostItemAttr("agility", module.getModifiedItemAttr("subsystemBonusMinmatarPropulsion") * level)

########NEW FILE########
__FILENAME__ = subsystembonusminmatarpropulsionmaxvelocity
# Used by:
# Subsystem: Loki Propulsion - Chassis Optimization
type = "passive"
def handler(fit, module, context):
    level = fit.character.getSkill("Minmatar Propulsion Systems").level
    fit.ship.boostItemAttr("maxVelocity", module.getModifiedItemAttr("subsystemBonusMinmatarPropulsion") * level)

########NEW FILE########
__FILENAME__ = subsystembonusoffensivejumpharmonics
# Used by:
# Subsystems named like: Offensive Covert Reconfiguration (4 of 4)
type = "passive"
def handler(fit, module, context):
    fit.ship.forceItemAttr("jumpHarmonics", module.getModifiedItemAttr("jumpHarmonicsModifier"))

########NEW FILE########
__FILENAME__ = subsystembonusscanprobelaunchercpu
# Used by:
# Subsystems named like: Electronics Emergent Locus Analyzer (4 of 4)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Scan Probe Launcher",
                                  "cpu", module.getModifiedItemAttr("cpuNeedBonus"))

########NEW FILE########
__FILENAME__ = subsystembonuswarpbubbleimmune
# Used by:
# Subsystems named like: Propulsion Interdiction Nullifier (4 of 4)
type = "passive"
def handler(fit, module, context):
    fit.ship.forceItemAttr("warpBubbleImmune", module.getModifiedItemAttr("warpBubbleImmuneModifier"))

########NEW FILE########
__FILENAME__ = superweaponamarr
# Used by:
# Module: Judgement
type = 'active'
def handler(fit, module, context):
    pass

########NEW FILE########
__FILENAME__ = superweaponcaldari
# Used by:
# Module: Oblivion
type = 'active'
def handler(fit, module, context):
    pass

########NEW FILE########
__FILENAME__ = superweapongallente
# Used by:
# Module: Aurora Ominae
type = 'active'
def handler(fit, module, context):
    pass

########NEW FILE########
__FILENAME__ = superweaponminmatar
# Used by:
# Module: Gjallarhorn
type = 'active'
def handler(fit, module, context):
    pass

########NEW FILE########
__FILENAME__ = surgicalstrikedamagemultiplierbonuspostpercentdamagemultiplierlocationshipgroupenergyweapon
# Used by:
# Skill: Surgical Strike
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Energy Weapon",
                                  "damageMultiplier", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)

########NEW FILE########
__FILENAME__ = surgicalstrikedamagemultiplierbonuspostpercentdamagemultiplierlocationshipgrouphybridweapon
# Used by:
# Skill: Surgical Strike
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Hybrid Weapon",
                                  "damageMultiplier", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)

########NEW FILE########
__FILENAME__ = surgicalstrikedamagemultiplierbonuspostpercentdamagemultiplierlocationshipgroupprojectileweapon
# Used by:
# Skill: Surgical Strike
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Projectile Weapon",
                                  "damageMultiplier", skill.getModifiedItemAttr("damageMultiplierBonus") * skill.level)

########NEW FILE########
__FILENAME__ = surgicalstrikedamagemultiplierbonuspostpercentdamagemultiplierlocationshipmodulesrequiringgunnery
# Used by:
# Implants named like: Cerebral Accelerator (3 of 3)
# Implants named like: Eifyr and Co. 'Gunslinger' Surgical Strike SS (6 of 6)
type = "passive"
def handler(fit, implant, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Gunnery"),
                                  "damageMultiplier", implant.getModifiedItemAttr("damageMultiplierBonus"))

########NEW FILE########
__FILENAME__ = surgicalstrikefalloffbonuspostpercentfallofflocationshipmodulesrequiringgunnery
# Used by:
# Implants named like: Sooth Sayer Booster (4 of 4)
# Implants named like: Zainou 'Deadeye' Trajectory Analysis TA (6 of 6)
# Skill: Trajectory Analysis
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Gunnery"),
                                  "falloff", container.getModifiedItemAttr("falloffBonus") * level)

########NEW FILE########
__FILENAME__ = surveyscanspeedbonuspostpercentdurationlocationshipmodulesrequiringelectronics
# Used by:
# Modules named like: Signal Focusing Kit (8 of 8)
# Skill: Survey
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("CPU Management"),
                                  "duration", container.getModifiedItemAttr("scanspeedBonus") * level)

########NEW FILE########
__FILENAME__ = systemagility
# Used by:
# Celestials named like: Black Hole Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, beacon, context):
    fit.ship.multiplyItemAttr("agility", beacon.getModifiedItemAttr("agilityMultiplier"))

########NEW FILE########
__FILENAME__ = systemaoevelocity
# Used by:
# Celestials named like: Magnetar Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, beacon, context):
    fit.modules.filteredChargeMultiply(lambda mod: mod.charge.requiresSkill("Missile Launcher Operation"),
                                       "aoeVelocity", beacon.getModifiedItemAttr("aoeVelocityMultiplier"))

########NEW FILE########
__FILENAME__ = systemarmoremresistance
# Used by:
# Celestials named like: Incursion Effect (2 of 2)
# Celestials named like: Pulsar Effect Beacon Class (6 of 6)
# Celestials named like: Wolf Rayet Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, beacon, context):
    fit.ship.boostItemAttr("armorEmDamageResonance", beacon.getModifiedItemAttr("armorEmDamageResistanceBonus"),
                           stackingPenalties = True)

########NEW FILE########
__FILENAME__ = systemarmorexplosiveresistance
# Used by:
# Celestials named like: Incursion Effect (2 of 2)
# Celestials named like: Pulsar Effect Beacon Class (6 of 6)
# Celestials named like: Wolf Rayet Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, beacon, context):
    fit.ship.boostItemAttr("armorExplosiveDamageResonance", beacon.getModifiedItemAttr("armorExplosiveDamageResistanceBonus"),
                           stackingPenalties = True)

########NEW FILE########
__FILENAME__ = systemarmorkineticresistance
# Used by:
# Celestials named like: Incursion Effect (2 of 2)
# Celestials named like: Pulsar Effect Beacon Class (6 of 6)
# Celestials named like: Wolf Rayet Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, beacon, context):
    fit.ship.boostItemAttr("armorKineticDamageResonance", beacon.getModifiedItemAttr("armorKineticDamageResistanceBonus"),
                           stackingPenalties = True)

########NEW FILE########
__FILENAME__ = systemarmorremoterepairamount
# Used by:
# Celestials named like: Cataclysmic Variable Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.group.name == "Remote Armor Repairer",
                                     "armorDamageAmount", module.getModifiedItemAttr("armorDamageAmountMultiplierRemote"))

########NEW FILE########
__FILENAME__ = systemarmorrepairamount
# Used by:
# Celestials named like: Cataclysmic Variable Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.group.name == "Armor Repair Unit",
                                     "armorDamageAmount", module.getModifiedItemAttr("armorDamageAmountMultiplier"),
                                     stackingPenalties = True, penaltyGroup="postMul")

########NEW FILE########
__FILENAME__ = systemarmorthermalresistance
# Used by:
# Celestials named like: Incursion Effect (2 of 2)
# Celestials named like: Pulsar Effect Beacon Class (6 of 6)
# Celestials named like: Wolf Rayet Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, beacon, context):
    fit.ship.boostItemAttr("armorThermalDamageResonance", beacon.getModifiedItemAttr("armorThermalDamageResistanceBonus"),
                           stackingPenalties = True)

########NEW FILE########
__FILENAME__ = systemcapacitorcapacity
# Used by:
# Celestials named like: Cataclysmic Variable Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, beacon, context):
    fit.ship.multiplyItemAttr("capacitorCapacity", beacon.getModifiedItemAttr("capacitorCapacityMultiplierSystem"))

########NEW FILE########
__FILENAME__ = systemcapacitorrecharge
# Used by:
# Celestials named like: Cataclysmic Variable Effect Beacon Class (6 of 6)
# Celestials named like: Pulsar Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, beacon, context):
    fit.ship.multiplyItemAttr("rechargeRate", beacon.getModifiedItemAttr("rechargeRateMultiplier"))

########NEW FILE########
__FILENAME__ = systemdamagedrones
# Used by:
# Celestials named like: Magnetar Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, beacon, context):
    fit.drones.filteredItemMultiply(lambda drone: drone.item.requiresSkill("Drones"),
                                    "damageMultiplier", beacon.getModifiedItemAttr("damageMultiplierMultiplier"))

########NEW FILE########
__FILENAME__ = systemdamageemmissiles
# Used by:
# Celestials named like: Magnetar Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, beacon, context):
    fit.modules.filteredChargeMultiply(lambda mod: mod.charge.requiresSkill("Missile Launcher Operation"),
                                       "emDamage", beacon.getModifiedItemAttr("damageMultiplierMultiplier"),
                                       stackingPenalties = True)

########NEW FILE########
__FILENAME__ = systemdamageexplosivemissiles
# Used by:
# Celestials named like: Magnetar Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, beacon, context):
    fit.modules.filteredChargeMultiply(lambda mod: mod.charge.requiresSkill("Missile Launcher Operation"),
                                       "explosiveDamage", beacon.getModifiedItemAttr("damageMultiplierMultiplier"),
                                       stackingPenalties = True)

########NEW FILE########
__FILENAME__ = systemdamagefighters
# Used by:
# Celestials named like: Magnetar Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, beacon, context):
    fit.drones.filteredItemMultiply(lambda drone: drone.item.requiresSkill("Fighters"),
                                    "damageMultiplier", beacon.getModifiedItemAttr("damageMultiplierMultiplier"))

########NEW FILE########
__FILENAME__ = systemdamagekineticmissiles
# Used by:
# Celestials named like: Magnetar Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, beacon, context):
    fit.modules.filteredChargeMultiply(lambda mod: mod.charge.requiresSkill("Missile Launcher Operation"),
                                       "kineticDamage", beacon.getModifiedItemAttr("damageMultiplierMultiplier"),
                                       stackingPenalties = True)

########NEW FILE########
__FILENAME__ = systemdamagemultipliergunnery
# Used by:
# Celestials named like: Magnetar Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, beacon, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.requiresSkill("Gunnery"),
                                     "damageMultiplier", beacon.getModifiedItemAttr("damageMultiplierMultiplier"),
                                     stackingPenalties = True)

########NEW FILE########
__FILENAME__ = systemdamagethermalmissiles
# Used by:
# Celestials named like: Magnetar Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, beacon, context):
    fit.modules.filteredChargeMultiply(lambda mod: mod.charge.requiresSkill("Missile Launcher Operation"),
                                       "thermalDamage", beacon.getModifiedItemAttr("damageMultiplierMultiplier"),
                                       stackingPenalties = True)

########NEW FILE########
__FILENAME__ = systemdronecontrolrange
# Used by:
# Celestials named like: Black Hole Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, beacon, context):
    amount = beacon.getModifiedItemAttr("droneRangeMultiplier")
    fit.extraAttributes.multiply("droneControlRange", amount)

########NEW FILE########
__FILENAME__ = systemdronespeed
# Used by:
# Celestials named like: Magnetar Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, beacon, context):
    fit.drones.filteredItemMultiply(lambda drone: True,
                                    "maxVelocity", beacon.getModifiedItemAttr("maxDroneVelocityMultiplier"))

########NEW FILE########
__FILENAME__ = systemfalloffrangegunnery
# Used by:
# Celestials named like: Black Hole Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.requiresSkill("Gunnery"),
                                     "falloff", module.getModifiedItemAttr("fallofMultiplier"))

########NEW FILE########
__FILENAME__ = systemheatdamage
# Used by:
# Celestials named like: Red Giant Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: "heatDamage" in mod.itemModifiedAttributes,
                                     "heatDamage", module.getModifiedItemAttr("heatDamageMultiplier"))

########NEW FILE########
__FILENAME__ = systemmaxvelocity
# Used by:
# Celestials named like: Black Hole Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, beacon, context):
    fit.ship.multiplyItemAttr("maxVelocity", beacon.getModifiedItemAttr("maxVelocityMultiplier"))

########NEW FILE########
__FILENAME__ = systemmissilevelocity
# Used by:
# Celestials named like: Black Hole Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, beacon, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Missile Launcher Operation"),
                                    "maxVelocity", beacon.getModifiedItemAttr("missileVelocityMultiplier"))

########NEW FILE########
__FILENAME__ = systemoptimalrangegunnery
# Used by:
# Celestials named like: Black Hole Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.requiresSkill("Gunnery"),
                                     "maxRange", module.getModifiedItemAttr("maxRangeMultiplier"))

########NEW FILE########
__FILENAME__ = systemoverloadarmor
# Used by:
# Celestials named like: Red Giant Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: "overloadArmorDamageAmount" in mod.itemModifiedAttributes,
                                     "overloadArmorDamageAmount", module.getModifiedItemAttr("overloadBonusMultiplier"))

########NEW FILE########
__FILENAME__ = systemoverloaddamagemodifier
# Used by:
# Celestials named like: Red Giant Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: "overloadDamageModifier" in mod.itemModifiedAttributes,
                                     "overloadDamageModifier", module.getModifiedItemAttr("overloadBonusMultiplier"))

########NEW FILE########
__FILENAME__ = systemoverloaddurationbonus
# Used by:
# Celestials named like: Red Giant Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: "overloadSelfDurationBonus" in mod.itemModifiedAttributes,
                                     "overloadSelfDurationBonus", module.getModifiedItemAttr("overloadBonusMultiplier"))

########NEW FILE########
__FILENAME__ = systemoverloadeccmstrength
# Used by:
# Celestials named like: Red Giant Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: "overloadECCMStrenghtBonus" in mod.itemModifiedAttributes,
                                     "overloadECCMStrenghtBonus", module.getModifiedItemAttr("overloadBonusMultiplier"))

########NEW FILE########
__FILENAME__ = systemoverloadecmstrength
# Used by:
# Celestials named like: Red Giant Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: "overloadECMStrenghtBonus" in mod.itemModifiedAttributes,
                                     "overloadECMStrenghtBonus", module.getModifiedItemAttr("overloadBonusMultiplier"))

########NEW FILE########
__FILENAME__ = systemoverloadhardening
# Used by:
# Celestials named like: Red Giant Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: "overloadHardeningBonus" in mod.itemModifiedAttributes,
                                     "overloadHardeningBonus", module.getModifiedItemAttr("overloadBonusMultiplier"))

########NEW FILE########
__FILENAME__ = systemoverloadrange
# Used by:
# Celestials named like: Red Giant Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: "overloadRangeBonus" in mod.itemModifiedAttributes,
                                     "overloadRangeBonus", module.getModifiedItemAttr("overloadBonusMultiplier"))

########NEW FILE########
__FILENAME__ = systemoverloadrof
# Used by:
# Celestials named like: Red Giant Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: "overloadRofBonus" in mod.itemModifiedAttributes,
                                     "overloadRofBonus", module.getModifiedItemAttr("overloadBonusMultiplier"))

########NEW FILE########
__FILENAME__ = systemoverloadselfduration
# Used by:
# Celestials named like: Red Giant Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: "overloadSelfDurationBonus" in mod.itemModifiedAttributes,
                                     "overloadSelfDurationBonus", module.getModifiedItemAttr("overloadBonusMultiplier"))

########NEW FILE########
__FILENAME__ = systemoverloadshieldbonus
# Used by:
# Celestials named like: Red Giant Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: "overloadShieldBonus" in mod.itemModifiedAttributes,
                                     "overloadShieldBonus", module.getModifiedItemAttr("overloadBonusMultiplier"))

########NEW FILE########
__FILENAME__ = systemoverloadspeedfactor
# Used by:
# Celestials named like: Red Giant Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: "overloadSpeedFactorBonus" in mod.itemModifiedAttributes,
                                     "overloadSpeedFactorBonus", module.getModifiedItemAttr("overloadBonusMultiplier"))

########NEW FILE########
__FILENAME__ = systemrocketemdamage
# Used by:
# Celestials named like: Wolf Rayet Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, beacon, context):
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.requiresSkill("Rockets"),
                                    "emDamage", beacon.getModifiedItemAttr("smallWeaponDamageMultiplier"),
                                    stackingPenalties = True)

########NEW FILE########
__FILENAME__ = systemrocketexplosivedamage
# Used by:
# Celestials named like: Wolf Rayet Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, beacon, context):
    fit.modules.filteredChargeMultiply(lambda mod: mod.charge.requiresSkill("Rockets"),
                                       "explosiveDamage", beacon.getModifiedItemAttr("smallWeaponDamageMultiplier"),
                                       stackingPenalties = True)

########NEW FILE########
__FILENAME__ = systemrocketkineticdamage
# Used by:
# Celestials named like: Wolf Rayet Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, beacon, context):
    fit.modules.filteredChargeMultiply(lambda mod: mod.charge.requiresSkill("Rockets"),
                                       "kineticDamage", beacon.getModifiedItemAttr("smallWeaponDamageMultiplier"),
                                       stackingPenalties = True)

########NEW FILE########
__FILENAME__ = systemrocketthermaldamage
# Used by:
# Celestials named like: Wolf Rayet Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, beacon, context):
    fit.modules.filteredChargeMultiply(lambda mod: mod.charge.requiresSkill("Rockets"),
                                       "thermalDamage", beacon.getModifiedItemAttr("smallWeaponDamageMultiplier"),
                                       stackingPenalties = True)

########NEW FILE########
__FILENAME__ = systemscandurationmodulemodifier
# Used by:
# Modules from group: Scanning Upgrade Time (2 of 2)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Astrometrics"),
                                  "duration", module.getModifiedItemAttr("scanDurationBonus"))

########NEW FILE########
__FILENAME__ = systemscandurationskillastrometrics
# Used by:
# Implants named like: Poteque 'Prospector' Astrometric Acquisition AQ (3 of 3)
# Skill: Astrometric Acquisition
# Skill: Astrometrics
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Astrometrics"),
                                  "duration", container.getModifiedItemAttr("durationBonus") * level)

########NEW FILE########
__FILENAME__ = systemshieldemresistance
# Used by:
# Celestials named like: Wolf Rayet Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, beacon, context):
    fit.ship.boostItemAttr("shieldEmDamageResonance", beacon.getModifiedItemAttr("shieldEmDamageResistanceBonus"),
                           stackingPenalties = True)

########NEW FILE########
__FILENAME__ = systemshieldexplosiveresistance
# Used by:
# Celestials named like: Wolf Rayet Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, beacon, context):
    fit.ship.boostItemAttr("shieldExplosiveDamageResonance", beacon.getModifiedItemAttr("shieldExplosiveDamageResistanceBonus"),
                           stackingPenalties = True)

########NEW FILE########
__FILENAME__ = systemshieldhp
# Used by:
# Celestials named like: Pulsar Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, beacon, context):
    fit.ship.multiplyItemAttr("shieldCapacity", beacon.getModifiedItemAttr("shieldCapacityMultiplier"))

########NEW FILE########
__FILENAME__ = systemshieldkineticresistance
# Used by:
# Celestials named like: Wolf Rayet Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, beacon, context):
    fit.ship.boostItemAttr("shieldKineticDamageResonance", beacon.getModifiedItemAttr("shieldKineticDamageResistanceBonus"),
                           stackingPenalties = True)

########NEW FILE########
__FILENAME__ = systemshieldremoterepairamount
# Used by:
# Celestials named like: Cataclysmic Variable Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.group.name == "Remote Shield Booster",
                                     "shieldBonus", module.getModifiedItemAttr("shieldBonusMultiplierRemote"))

########NEW FILE########
__FILENAME__ = systemshieldrepairamountshieldskills
# Used by:
# Celestials named like: Cataclysmic Variable Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.requiresSkill("Shield Operation") or mod.item.requiresSkill("Capital Shield Operation"),
                                     "shieldBonus", module.getModifiedItemAttr("shieldBonusMultiplier"),
                                     stackingPenalties = True, penaltyGroup="postMul")

########NEW FILE########
__FILENAME__ = systemshieldthermalresistance
# Used by:
# Celestials named like: Wolf Rayet Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, beacon, context):
    fit.ship.boostItemAttr("shieldThermalDamageResonance", beacon.getModifiedItemAttr("shieldThermalDamageResistanceBonus"),
                           stackingPenalties = True)

########NEW FILE########
__FILENAME__ = systemsignatureradius
# Used by:
# Celestials named like: Pulsar Effect Beacon Class (6 of 6)
# Celestials named like: Wolf Rayet Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, beacon, context):
    fit.ship.multiplyItemAttr("signatureRadius", beacon.getModifiedItemAttr("signatureRadiusMultiplier"))

########NEW FILE########
__FILENAME__ = systemsmallenergydamage
# Used by:
# Celestials named like: Wolf Rayet Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.requiresSkill("Small Energy Turret"),
                                     "damageMultiplier", module.getModifiedItemAttr("smallWeaponDamageMultiplier"),
                                     stackingPenalties = True)

########NEW FILE########
__FILENAME__ = systemsmallhybriddamage
# Used by:
# Celestials named like: Wolf Rayet Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.requiresSkill("Small Hybrid Turret"),
                                     "damageMultiplier", module.getModifiedItemAttr("smallWeaponDamageMultiplier"),
                                     stackingPenalties = True)

########NEW FILE########
__FILENAME__ = systemsmallprojectiledamage
# Used by:
# Celestials named like: Wolf Rayet Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.requiresSkill("Small Projectile Turret"),
                                     "damageMultiplier", module.getModifiedItemAttr("smallWeaponDamageMultiplier"),
                                     stackingPenalties = True)

########NEW FILE########
__FILENAME__ = systemsmartbombemdamage
# Used by:
# Celestials named like: Red Giant Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.group.name == "Smart Bomb",
                                     "emDamage", module.getModifiedItemAttr("smartbombDamageMultiplier"))

########NEW FILE########
__FILENAME__ = systemsmartbombexplosivedamage
# Used by:
# Celestials named like: Red Giant Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.group.name == "Smart Bomb",
                                     "explosiveDamage", module.getModifiedItemAttr("smartbombDamageMultiplier"))

########NEW FILE########
__FILENAME__ = systemsmartbombkineticdamage
# Used by:
# Celestials named like: Red Giant Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.group.name == "Smart Bomb",
                                     "kineticDamage", module.getModifiedItemAttr("smartbombDamageMultiplier"))

########NEW FILE########
__FILENAME__ = systemsmartbombrange
# Used by:
# Celestials named like: Red Giant Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.group.name == "Smart Bomb",
                                     "empFieldRange", module.getModifiedItemAttr("empFieldRangeMultiplier"))

########NEW FILE########
__FILENAME__ = systemsmartbombthermaldamage
# Used by:
# Celestials named like: Red Giant Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.group.name == "Smart Bomb",
                                     "thermalDamage", module.getModifiedItemAttr("smartbombDamageMultiplier"))

########NEW FILE########
__FILENAME__ = systemstandardmissileemdamage
# Used by:
# Celestials named like: Wolf Rayet Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, beacon, context):
    fit.modules.filteredChargeMultiply(lambda mod: mod.charge.requiresSkill("Light Missiles"),
                                       "emDamage", beacon.getModifiedItemAttr("smallWeaponDamageMultiplier"),
                                       stackingPenalties = True)

########NEW FILE########
__FILENAME__ = systemstandardmissileexplosivedamage
# Used by:
# Celestials named like: Wolf Rayet Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, beacon, context):
    fit.modules.filteredChargeMultiply(lambda mod: mod.charge.requiresSkill("Light Missiles"),
                                       "explosiveDamage", beacon.getModifiedItemAttr("smallWeaponDamageMultiplier"),
                                       stackingPenalties = True)

########NEW FILE########
__FILENAME__ = systemstandardmissilekineticdamage
# Used by:
# Celestials named like: Wolf Rayet Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, beacon, context):
    fit.modules.filteredChargeMultiply(lambda mod: mod.charge.requiresSkill("Light Missiles"),
                                       "kineticDamage", beacon.getModifiedItemAttr("smallWeaponDamageMultiplier"),
                                       stackingPenalties = True)

########NEW FILE########
__FILENAME__ = systemstandardmissilethermaldamage
# Used by:
# Celestials named like: Wolf Rayet Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, beacon, context):
    fit.modules.filteredChargeMultiply(lambda mod: mod.charge.requiresSkill("Light Missiles"),
                                       "thermalDamage", beacon.getModifiedItemAttr("smallWeaponDamageMultiplier"),
                                       stackingPenalties = True)

########NEW FILE########
__FILENAME__ = systemtargetingrange
# Used by:
# Celestials named like: Magnetar Effect Beacon Class (6 of 6)
# Celestials named like: Pulsar Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, beacon, context):
    fit.ship.multiplyItemAttr("maxTargetRange", beacon.getModifiedItemAttr("maxTargetRangeMultiplier"))

########NEW FILE########
__FILENAME__ = systemtracking
# Used by:
# Celestials named like: Magnetar Effect Beacon Class (6 of 6)
runTime = "early"
type = ("projected", "offline")
def handler(fit, module, context):
    fit.modules.filteredItemMultiply(lambda mod: mod.item.requiresSkill("Gunnery"),
                                     "trackingSpeed", module.getModifiedItemAttr("trackingSpeedMultiplier"))

########NEW FILE########
__FILENAME__ = tacticalshieldmanipulationskillboostuniformitybonus
# Used by:
# Skill: Tactical Shield Manipulation
type = "passive"
def handler(fit, skill, context):
    fit.ship.increaseItemAttr("shieldUniformity", skill.getModifiedItemAttr("uniformityBonus") * skill.level)

########NEW FILE########
__FILENAME__ = targetarmorrepair
# Used by:
# Modules from group: Remote Armor Repairer (38 of 38)
# Drones named like: Armor Maintenance Bot (6 of 6)
# Module: QA Remote Armor Repair System - 5 Players
type = "projected", "active"
def handler(fit, container, context):
    if "projected" in context:
        bonus = container.getModifiedItemAttr("armorDamageAmount")
        duration = container.getModifiedItemAttr("duration") / 1000.0
        fit.extraAttributes.increase("armorRepair", bonus / duration)

########NEW FILE########
__FILENAME__ = targetattack
# Used by:
# Drones from group: Combat Drone (73 of 73)
# Drones from group: Fighter Drone (4 of 4)
# Modules from group: Energy Weapon (183 of 183)
type = 'active'
def handler(fit, module, context):
    # Set reload time to 1 second
    module.reloadTime = 1000

########NEW FILE########
__FILENAME__ = targetbreaker
# Used by:
# Module: Target Spectrum Breaker
type = "active"
def handler(fit, module, context):
    pass

########NEW FILE########
__FILENAME__ = targetgunnerymaxrangeandtrackingspeedandfalloffbonushostile
# Used by:
# Modules from group: Tracking Disruptor (10 of 10)
type= "projected", "active"
def handler(fit, module, context):
    if "projected" in context:
        fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Gunnery"),
                                      "trackingSpeed", module.getModifiedItemAttr("trackingSpeedBonus"),
                                      stackingPenalties = True)
        fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Gunnery"),
                                      "maxRange", module.getModifiedItemAttr("maxRangeBonus"),
                                      stackingPenalties = True)
        fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Gunnery"),
                                      "falloff", module.getModifiedItemAttr("falloffBonus"),
                                      stackingPenalties = True)

########NEW FILE########
__FILENAME__ = targetgunnerymaxrangefallofftrackingspeedbonusassistance
# Used by:
# Modules from group: Remote Tracking Computer (10 of 10)
type= "projected", "active"
def handler(fit, module, context):
    if "projected" in context:
        fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Gunnery"),
                                      "trackingSpeed", module.getModifiedItemAttr("trackingSpeedBonus"),
                                      stackingPenalties = True)
        fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Gunnery"),
                                      "maxRange", module.getModifiedItemAttr("maxRangeBonus"),
                                      stackingPenalties = True)
        fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Gunnery"),
                                      "falloff", module.getModifiedItemAttr("falloffBonus"),
                                      stackingPenalties = True)

########NEW FILE########
__FILENAME__ = targethostiles
# Used by:
# Modules from group: Automated Targeting System (6 of 6)
type = "active"
def handler(fit, module, context):
    # This effect enables the ACTIVE state for auto targeting systems.
    pass

########NEW FILE########
__FILENAME__ = targetingmaxtargetbonusmodaddmaxlockedtargetslocationchar
# Used by:
# Skills named like: Target Management (2 of 2)
type = "passive"
def handler(fit, skill, context):
    amount = skill.getModifiedItemAttr("maxTargetBonus") * skill.level
    fit.extraAttributes.increase("maxTargetsLockedFromSkills", amount)

########NEW FILE########
__FILENAME__ = targetmaxtargetrangeandscanresolutionbonusassistance
# Used by:
# Modules from group: Remote Sensor Booster (8 of 8)
type= "projected", "active"
def handler(fit, module, context):
    if "projected" not in context:
        return

    fit.ship.boostItemAttr("maxTargetRange", module.getModifiedItemAttr("maxTargetRangeBonus"),
                           stackingPenalties = True)
    fit.ship.boostItemAttr("scanResolution", module.getModifiedItemAttr("scanResolutionBonus"),
                           stackingPenalties = True)

########NEW FILE########
__FILENAME__ = targetmaxtargetrangeandscanresolutionbonushostile
# Used by:
# Modules from group: Remote Sensor Damper (9 of 9)
type= "projected", "active"
def handler(fit, module, context):
    if "projected" not in context:
        return
    fit.ship.boostItemAttr("maxTargetRange", module.getModifiedItemAttr("maxTargetRangeBonus"),
                           stackingPenalties = True)
    fit.ship.boostItemAttr("scanResolution", module.getModifiedItemAttr("scanResolutionBonus"),
                           stackingPenalties = True)

########NEW FILE########
__FILENAME__ = thermalshieldcompensationhardeningbonusgroupshieldamp
# Used by:
# Skill: Thermic Shield Compensation
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Shield Amplifier",
                                  "thermalDamageResistanceBonus", skill.getModifiedItemAttr("hardeningBonus") * skill.level)
########NEW FILE########
__FILENAME__ = thermicarmorcompensationhardeningbonusgrouparmorcoating
# Used by:
# Skill: Thermic Armor Compensation
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Armor Coating",
                                  "thermalDamageResistanceBonus", skill.getModifiedItemAttr("hardeningBonus") * skill.level)
########NEW FILE########
__FILENAME__ = thermicarmorcompensationhardeningbonusgroupenergized
# Used by:
# Skill: Thermic Armor Compensation
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Armor Plating Energized",
                                  "thermalDamageResistanceBonus", skill.getModifiedItemAttr("hardeningBonus") * skill.level)
########NEW FILE########
__FILENAME__ = thermodynamicsskilldamagebonus
# Used by:
# Skill: Thermodynamics
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: True, "heatDamage",
                                  skill.getModifiedItemAttr("thermodynamicsHeatDamage") * skill.level)

########NEW FILE########
__FILENAME__ = titanamarrgangcaprecharge2
# Used by:
# Ship: Avatar
type = "gang"
gangBoost = "rechargeRate"
gangBonus = "titanAmarrBonus2"
def handler(fit, ship, context):
    fit.ship.boostItemAttr(gangBoost, ship.getModifiedItemAttr(gangBonus))

########NEW FILE########
__FILENAME__ = titanamarrlaserdmg3
# Used by:
# Ship: Avatar
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Titan").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Energy Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("titanAmarrBonus3") * level)

########NEW FILE########
__FILENAME__ = titanamarrleadershipmoduleamount4
# Used by:
# Ship: Avatar
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Amarr Titan").level
    fit.modules.filteredItemIncrease(lambda mod: mod.item.group.name == "Gang Coordinator",
                                     "maxGroupActive", ship.getModifiedItemAttr("titanAmarrBonus4") * level)

########NEW FILE########
__FILENAME__ = titanamarrskilllevel2
# Used by:
# Skill: Amarr Titan
type = "passive"
def handler(fit, skill, context):
    fit.ship.multiplyItemAttr("titanAmarrBonus2", skill.level)

########NEW FILE########
__FILENAME__ = titancaldarigangshieldhp2
# Used by:
# Ship: Leviathan
type = "gang"
gangBoost = "shieldCapacity"
gangBonus = "shipBonusCT2"
def handler(fit, ship, context):
    fit.ship.boostItemAttr(gangBoost, ship.getModifiedItemAttr(gangBonus))

########NEW FILE########
__FILENAME__ = titancaldarileadershipmoduleamount4
# Used by:
# Ship: Leviathan
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Titan").level
    fit.modules.filteredItemIncrease(lambda mod: mod.item.group.name == "Gang Coordinator",
                                     "maxGroupActive", ship.getModifiedItemAttr("titanCaldariBonus4") * level)

########NEW FILE########
__FILENAME__ = titancaldarimissilekineticdmg2
# Used by:
# Ship: Leviathan
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Caldari Titan").level
    groups = ("Citadel Torpedo", "Citadel Cruise")
    fit.modules.filteredChargeBoost(lambda mod: mod.charge.group.name in groups,
                                    "kineticDamage", ship.getModifiedItemAttr("shipBonusCT1") * level)

########NEW FILE########
__FILENAME__ = titancaldariskilllevel2
# Used by:
# Skill: Caldari Titan
type = "passive"
def handler(fit, skill, context):
    fit.ship.multiplyItemAttr("shipBonusCT2", skill.level)

########NEW FILE########
__FILENAME__ = titangallentegangarmorhp2
# Used by:
# Ship: Erebus
type = "gang"
gangBoost = "armorHP"
gangBonus = "titanGallenteBonus2"
def handler(fit, ship, context):
    fit.ship.boostItemAttr(gangBoost, ship.getModifiedItemAttr(gangBonus))

########NEW FILE########
__FILENAME__ = titangallentehybriddamage1
# Used by:
# Ship: Erebus
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Titan").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Hybrid Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("titanGallenteBonus1") * level)

########NEW FILE########
__FILENAME__ = titangallenteleadershipmoduleamount4
# Used by:
# Ship: Erebus
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Gallente Titan").level
    fit.modules.filteredItemIncrease(lambda mod: mod.item.group.name == "Gang Coordinator",
                                  "maxGroupActive", ship.getModifiedItemAttr("titanGallenteBonus4") * level)

########NEW FILE########
__FILENAME__ = titangallenteskilllevel2
# Used by:
# Skill: Gallente Titan
type = "passive"
def handler(fit, skill, context):
    fit.ship.multiplyItemAttr("titanGallenteBonus2", skill.level)

########NEW FILE########
__FILENAME__ = titanminmatargangsigradius2
# Used by:
# Ship: Ragnarok
type = "gang"
gangBoost = "signatureRadius"
gangBonus = "titanMinmatarBonus2"
def handler(fit, ship, context):
    fit.ship.boostItemAttr(gangBoost, ship.getModifiedItemAttr(gangBonus))

########NEW FILE########
__FILENAME__ = titanminmatarleadershipmoduleamount4
# Used by:
# Ship: Ragnarok
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Titan").level
    fit.modules.filteredItemIncrease(lambda mod: mod.item.group.name == "Gang Coordinator",
                                     "maxGroupActive", ship.getModifiedItemAttr("titanMinmatarBonus4") * level)

########NEW FILE########
__FILENAME__ = titanminmatarprojectiledmg3
# Used by:
# Ship: Ragnarok
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Minmatar Titan").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Projectile Turret"),
                                  "damageMultiplier", ship.getModifiedItemAttr("titanMinmatarBonus3") * level)

########NEW FILE########
__FILENAME__ = titanminmatarskilllevel2
# Used by:
# Skill: Minmatar Titan
type = "passive"
def handler(fit, skill, context):
    fit.ship.multiplyItemAttr("titanMinmatarBonus2", skill.level)

########NEW FILE########
__FILENAME__ = titanturretdamagescaling
# Used by:
# Ships from group: Titan (4 of 4)
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemIncrease(lambda mod: mod.item.requiresSkill("Gunnery"),
                                     "turretDamageScalingRadius", ship.getModifiedItemAttr("titanBonusScalingRadius"))

########NEW FILE########
__FILENAME__ = trackingspeedbonuseffecthybrids
# Used by:
# Modules named like: Hybrid Metastasis Adjuster (8 of 8)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Hybrid Weapon",
                                  "trackingSpeed", module.getModifiedItemAttr("trackingSpeedBonus"),
                                  stackingPenalties = True)

########NEW FILE########
__FILENAME__ = trackingspeedbonuseffectlasers
# Used by:
# Modules named like: Energy Metastasis Adjuster (8 of 8)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Energy Weapon",
                                  "trackingSpeed", module.getModifiedItemAttr("trackingSpeedBonus"),
                                  stackingPenalties = True)

########NEW FILE########
__FILENAME__ = trackingspeedbonuseffectprojectiles
# Used by:
# Modules named like: Projectile Metastasis Adjuster (8 of 8)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Projectile Weapon",
                                  "trackingSpeed", module.getModifiedItemAttr("trackingSpeedBonus"),
                                  stackingPenalties = True)

########NEW FILE########
__FILENAME__ = trackingspeedbonuspassiverequiringgunnerytrackingspeedbonus
# Used by:
# Implants named like: Drop Booster (4 of 4)
# Implants named like: Eifyr and Co. 'Gunslinger' Motion Prediction MR (6 of 6)
# Implant: Ogdin's Eye Coordination Enhancer
# Skill: Motion Prediction
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Gunnery"),
                                  "trackingSpeed", container.getModifiedItemAttr("trackingSpeedBonus") * level)

########NEW FILE########
__FILENAME__ = tractorbeamcan
# Used by:
# Modules from group: Tractor Beam (4 of 4)
type = "active"
def handler(fit, module, context):
    pass
########NEW FILE########
__FILENAME__ = triagemodeeffect3
# Used by:
# Module: Triage Module I
type = "active"
def handler(fit, module, context):
    # Remote armor reps
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Remote Armor Repair Systems"),
                                  "duration", module.getModifiedItemAttr("remoteArmorDamageDurationBonus"))
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Remote Armor Repair Systems"),
                                  "armorDamageAmount", module.getModifiedItemAttr("remoteArmorDamageAmountBonus"))

    # Remote hull reppers
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Remote Hull Repair Systems"),
                                  "structureDamageAmount", module.getModifiedItemAttr("remoteHullDamageAmountBonus"))
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Remote Hull Repair Systems"),
                                  "duration", module.getModifiedItemAttr("remoteHullDamageDurationBonus"))

    # Shield Transporters
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Shield Emission Systems"),
                                  "shieldBonus", module.getModifiedItemAttr("shieldTransportAmountBonus"))
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Shield Emission Systems"),
                                  "duration", module.getModifiedItemAttr("shieldTransportDurationBonus"))

    # Energy Transfer Arrays
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Capacitor Emission Systems"),
                                  "powerTransferAmount", module.getModifiedItemAttr("powerTransferAmountBonus"))
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Capacitor Emission Systems"),
                                  "duration", module.getModifiedItemAttr("powerTransferDurationBonus"))

    # Shield boosters
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Shield Operation"),
                                  "shieldBonus", module.getModifiedItemAttr("shieldBoostMultiplier"))
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Shield Operation"),
                                  "duration", module.getModifiedItemAttr("shieldBonusDurationBonus"))

    # Armor reps
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Armor Repair Unit",
                                  "armorDamageAmount", module.getModifiedItemAttr("armorDamageAmountBonus"))
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Armor Repair Unit",
                                  "duration", module.getModifiedItemAttr("armorDamageDurationBonus"))

    # Speed bonus
    fit.ship.boostItemAttr("maxVelocity", module.getModifiedItemAttr("speedFactor"))

    # Scan resolution multiplier
    fit.ship.multiplyItemAttr("scanResolution", module.getModifiedItemAttr("scanResolutionMultiplier"))

    # Mass multiplier
    fit.ship.multiplyItemAttr("mass", module.getModifiedItemAttr("massMultiplier"))

    # Lock range
    fit.ship.multiplyItemAttr("maxTargetRange", module.getModifiedItemAttr("maxTargetRangeMultiplier"))

    # Max locked targets
    fit.ship.increaseItemAttr("maxLockedTargets", module.getModifiedItemAttr("maxLockedTargetsBonus"))

    # Block EWAR & projected effects
    fit.ship.forceItemAttr("disallowOffensiveModifiers", module.getModifiedItemAttr("disallowOffensiveModifiers"))
    fit.ship.forceItemAttr("disallowAssistance", module.getModifiedItemAttr("disallowAssistance"))

########NEW FILE########
__FILENAME__ = triagemodeeffect7
# Used by:
# Module: Triage Module II
type = "active"
def handler(fit, module, context):
    # Remote armor reps
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Remote Armor Repair Systems"),
                                  "duration", module.getModifiedItemAttr("remoteArmorDamageDurationBonus"))
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Remote Armor Repair Systems"),
                                  "armorDamageAmount", module.getModifiedItemAttr("remoteArmorDamageAmountBonus"))

    # Remote hull reppers
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Remote Hull Repair Systems"),
                                  "structureDamageAmount", module.getModifiedItemAttr("remoteHullDamageAmountBonus"))
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Remote Hull Repair Systems"),
                                  "duration", module.getModifiedItemAttr("remoteHullDamageDurationBonus"))

    # Shield Transporters
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Shield Emission Systems"),
                                  "shieldBonus", module.getModifiedItemAttr("shieldTransportAmountBonus"))
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Shield Emission Systems"),
                                  "duration", module.getModifiedItemAttr("shieldTransportDurationBonus"))

    # Energy Transfer Arrays
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Capacitor Emission Systems"),
                                  "powerTransferAmount", module.getModifiedItemAttr("powerTransferAmountBonus"))
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Capacitor Emission Systems"),
                                  "duration", module.getModifiedItemAttr("powerTransferDurationBonus"))

    # Shield boosters
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Shield Operation"),
                                  "shieldBonus", module.getModifiedItemAttr("shieldBoostMultiplier"))
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Shield Operation"),
                                  "duration", module.getModifiedItemAttr("shieldBonusDurationBonus"))

    # Armor reps
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Armor Repair Unit",
                                  "armorDamageAmount", module.getModifiedItemAttr("armorDamageAmountBonus"))
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Armor Repair Unit",
                                  "duration", module.getModifiedItemAttr("armorDamageDurationBonus"))

    # Speed bonus
    fit.ship.boostItemAttr("maxVelocity", module.getModifiedItemAttr("speedFactor"))

    # Scan resolution multiplier
    fit.ship.multiplyItemAttr("scanResolution", module.getModifiedItemAttr("scanResolutionMultiplier"))

    # Mass multiplier
    fit.ship.multiplyItemAttr("mass", module.getModifiedItemAttr("massMultiplier"))

    # Lock range
    fit.ship.multiplyItemAttr("maxTargetRange", module.getModifiedItemAttr("maxTargetRangeMultiplier"))

    # Max locked targets
    fit.ship.increaseItemAttr("maxLockedTargets", module.getModifiedItemAttr("maxLockedTargetsBonus"))

    # Block EWAR & projected effects
    fit.ship.forceItemAttr("disallowOffensiveModifiers", module.getModifiedItemAttr("disallowOffensiveModifiers"))
    fit.ship.forceItemAttr("disallowAssistance", module.getModifiedItemAttr("disallowAssistance"))

    # RR cap consumption
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Remote Armor Repair Systems"),
                                  "capacitorNeed", module.getModifiedItemAttr("triageRemoteModuleCapNeed"))
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Remote Hull Repair Systems"),
                                  "capacitorNeed", module.getModifiedItemAttr("triageRemoteModuleCapNeed"))
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Capital Shield Emission Systems"),
                                  "capacitorNeed", module.getModifiedItemAttr("triageRemoteModuleCapNeed"))

########NEW FILE########
__FILENAME__ = turretweaponrangefallofftrackingspeedmultiplytargethostile
# Used by:
# Drones named like: TD (3 of 3)
type = "projected", "active"
def handler(fit, container, context):
    if "projected" in context:
        fit.modules.filteredItemMultiply(lambda mod: mod.item.requiresSkill("Gunnery"),
                                         "trackingSpeed", container.getModifiedItemAttr("trackingSpeedMultiplier"),
                                         stackingPenalties = True, penaltyGroup="postMul")
        fit.modules.filteredItemMultiply(lambda mod: mod.item.requiresSkill("Gunnery"),
                                         "maxRange", container.getModifiedItemAttr("maxRangeMultiplier"),
                                         stackingPenalties = True, penaltyGroup="postMul")
        fit.modules.filteredItemMultiply(lambda mod: mod.item.requiresSkill("Gunnery"),
                                         "falloff", container.getModifiedItemAttr("fallofMultiplier"),
                                         stackingPenalties = True, penaltyGroup="postMul")

########NEW FILE########
__FILENAME__ = usemissiles
# Used by:
# Modules from group: Missile Launcher Citadel (4 of 4)
# Modules from group: Missile Launcher Heavy (12 of 12)
# Modules from group: Missile Launcher Rocket (14 of 14)
# Modules named like: Launcher (137 of 137)
type = 'active'
def handler(fit, module, context):
    # Set reload time to 10 seconds
    module.reloadTime = 10000

########NEW FILE########
__FILENAME__ = velocitybonusonline
# Used by:
# Modules from group: Nanofiber Internal Structure (14 of 14)
# Modules from group: Overdrive Injector System (14 of 14)
type = "passive"
def handler(fit, module, context):
    fit.ship.boostItemAttr("maxVelocity", module.getModifiedItemAttr("implantBonusVelocity"),
                           stackingPenalties = True)
########NEW FILE########
__FILENAME__ = velocitybonuspassive
# Used by:
# Modules named like: Polycarbon Engine Housing (8 of 8)
type = "passive"
def handler(fit, module, context):
    fit.ship.boostItemAttr("maxVelocity", module.getModifiedItemAttr("implantBonusVelocity"),
                           stackingPenalties = True)
########NEW FILE########
__FILENAME__ = warfarelinkcpuaddition
# Used by:
# Modules from group: Gang Coordinator (30 of 31)
type = "passive"
def handler(fit, module, context):
    module.increaseItemAttr("cpu", module.getModifiedItemAttr("warfareLinkCPUAdd") or 0)

########NEW FILE########
__FILENAME__ = warfarelinkcpupenalty
# Used by:
# Subsystems from group: Defensive Systems (12 of 16)
type = "passive"
def handler(fit, module, context):
    fit.modules.filteredItemIncrease(lambda mod: mod.item.requiresSkill("Leadership"),
                                     "warfareLinkCPUAdd", module.getModifiedItemAttr("warfareLinkCPUPenalty"))


########NEW FILE########
__FILENAME__ = warpdisruptsphere
# Used by:
# Modules from group: Warp Disrupt Field Generator (2 of 2)
type = "active"
runTime = "early"
def handler(fit, module, context):
    fit.ship.boostItemAttr("mass", module.getModifiedItemAttr("massBonusPercentage"))
    fit.ship.boostItemAttr("signatureRadius", module.getModifiedItemAttr("signatureRadiusBonus"))
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Propulsion Module",
                                  "speedBoostFactor", module.getModifiedItemAttr("speedBoostFactorBonus"))
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Propulsion Module",
                                  "speedFactor", module.getModifiedItemAttr("speedFactorBonus"))
    fit.ship.forceItemAttr("disallowAssistance", 1)

########NEW FILE########
__FILENAME__ = warpdriveoperationwarpcapacitorneedbonuspostpercentwarpcapacitorneedlocationship
# Used by:
# Implants named like: Eifyr and Co. 'Rogue' Warp Drive Operation WD (6 of 6)
type = "passive"
def handler(fit, implant, context):
    fit.ship.boostItemAttr("warpCapacitorNeed", implant.getModifiedItemAttr("warpCapacitorNeedBonus"))

########NEW FILE########
__FILENAME__ = warpdriveoperationwarpcapacitorneedbonuspostpercentwarpcapacitorneedlocationshipgrouppropulsion
# Used by:
# Modules named like: Warp Core Optimizer (8 of 8)
# Skill: Warp Drive Operation
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.ship.boostItemAttr("warpCapacitorNeed", container.getModifiedItemAttr("warpCapacitorNeedBonus") * level,
                           stackingPenalties = "skill" not in context)

########NEW FILE########
__FILENAME__ = warpscramble
# Used by:
# Variations of module: Warp Disruptor I (19 of 19)
# Module: Civilian Warp Disruptor
type = "projected", "active"
def handler(fit, module, context):
    fit.ship.increaseItemAttr("warpScrambleStatus", module.getModifiedItemAttr("warpScrambleStrength"))
########NEW FILE########
__FILENAME__ = warpscrambletargetmwdblockactivation
# Used by:
# Variations of module: Warp Scrambler I (19 of 19)
runTime = "early"
type = "projected", "active"
def handler(fit, module, context):
    if "projected" not in context:
        return

    fit.ship.increaseItemAttr("warpScrambleStatus", module.getModifiedItemAttr("warpScrambleStrength"))

########NEW FILE########
__FILENAME__ = warpskillspeed
# Used by:
# Implants named like: Ascendancy (10 of 12)
# Implants named like: Eifyr and Co. 'Rogue' Warp Drive Speed WS (6 of 6)
# Modules named like: Hyperspatial Velocity Optimizer (8 of 8)
type = "passive"
def handler(fit, container, context):
    fit.ship.boostItemAttr("baseWarpSpeed", container.getModifiedItemAttr("WarpSBonus"))

########NEW FILE########
__FILENAME__ = weaponupgradescpuneedbonuspostpercentcpulocationshipmodulesrequiringbomblauncher
# Used by:
# Skill: Weapon Upgrades
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Bomb Deployment"),
                                  "cpu", skill.getModifiedItemAttr("cpuNeedBonus") * skill.level)
########NEW FILE########
__FILENAME__ = weaponupgradescpuneedbonuspostpercentcpulocationshipmodulesrequiringenergypulseweapons
# Used by:
# Skill: Weapon Upgrades
type = "passive"
def handler(fit, skill, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Energy Pulse Weapons"),
                                  "cpu", skill.getModifiedItemAttr("cpuNeedBonus") * skill.level)
########NEW FILE########
__FILENAME__ = weaponupgradescpuneedbonuspostpercentcpulocationshipmodulesrequiringgunnery
# Used by:
# Implants named like: Zainou 'Gnome' Weapon Upgrades WU (6 of 6)
# Skill: Weapon Upgrades
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Gunnery"),
                                  "cpu", container.getModifiedItemAttr("cpuNeedBonus") * level)

########NEW FILE########
__FILENAME__ = weaponupgradescpuneedbonuspostpercentcpulocationshipmodulesrequiringmissilelauncheroperation
# Used by:
# Implants named like: Zainou 'Gnome' Launcher CPU Efficiency LE (6 of 6)
# Skill: Weapon Upgrades
type = "passive"
def handler(fit, container, context):
    level = container.level if "skill" in context else 1
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Missile Launcher Operation"),
                                  "cpu", container.getModifiedItemAttr("cpuNeedBonus") * level)

########NEW FILE########
__FILENAME__ = zcolinarmorhpperlvl
# Used by:
# Ship: Impel
# Ship: Occator
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Transport Ships").level
    fit.ship.boostItemAttr("armorHP", ship.getModifiedItemAttr("shipBonusHPExtender1") * level)

########NEW FILE########
__FILENAME__ = zcolinorcacargobonus
# Used by:
# Ship: Orca
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Industrial Command Ships").level
    fit.ship.boostItemAttr("capacity", ship.getModifiedItemAttr("shipOrcaCargoBonusOrca1") * level)

########NEW FILE########
__FILENAME__ = zcolinorcaforemanmodbonus
# Used by:
# Ship: Orca
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Industrial Command Ships").level
    fit.modules.filteredItemBoost(lambda mod: mod.item.requiresSkill("Mining Director"),
                                  "commandBonus", ship.getModifiedItemAttr("shipOrcaForemanBonus") * level)

########NEW FILE########
__FILENAME__ = zcolinorcasurveyscannerbonus
# Used by:
# Ship: Orca
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Survey Scanner",
                                  "surveyScanRange", ship.getModifiedItemAttr("shipOrcaSurveyScannerBonus"))

########NEW FILE########
__FILENAME__ = zcolinorcatractorrangebonus
# Used by:
# Ship: Orca
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Tractor Beam",
                                  "maxRange", ship.getModifiedItemAttr("shipOrcaTractorBeamRangeBonus1"))

########NEW FILE########
__FILENAME__ = zcolinorcatractorvelocitybonus
# Used by:
# Ship: Orca
type = "passive"
def handler(fit, ship, context):
    fit.modules.filteredItemBoost(lambda mod: mod.item.group.name == "Tractor Beam",
                                  "maxTractorVelocity", ship.getModifiedItemAttr("shipOrcaTractorBeamVelocityBonus2"))

########NEW FILE########
__FILENAME__ = zcolinshieldhpperlvl
# Used by:
# Ship: Bustard
# Ship: Mastodon
type = "passive"
def handler(fit, ship, context):
    level = fit.character.getSkill("Transport Ships").level
    fit.ship.boostItemAttr("shieldCapacity", ship.getModifiedItemAttr("shipBonusHPExtender1") * level)

########NEW FILE########
__FILENAME__ = enum
class Enum():
    @classmethod
    def getTypes(cls):
        for stuff in cls.__dict__:
            if stuff.upper() == stuff:
                yield stuff

    @classmethod
    def getName(cls, v):
        map = getattr(cls, "_map", None)
        if map is None:
            map = cls._map = {}
            for type in cls.getTypes():
                map[cls.getValue(type)] = type

        return map.get(v)

    @classmethod
    def getValue(cls, type):
        return cls.__dict__[type]

########NEW FILE########
__FILENAME__ = eqBase
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

class EqBase(object):
    def __eq__(self, other):
        return type(self) == type(other) and self.ID == other.ID

    def __ne__(self, other):
        return type(self) != type(other) or self.ID != other.ID

    def __hash__(self):
        return id(type(self)) + self.ID
########NEW FILE########
__FILENAME__ = eveapi
#-----------------------------------------------------------------------------
# eveapi - EVE Online API access
#
# Copyright (c)2007 Jamie "Entity" van den Berge <entity@vapor.com>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation
# files (the "Software"), to deal in the Software without
# restriction, including without limitation the rights to use,
# copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following
# conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
# OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE
#
#-----------------------------------------------------------------------------
# Version: 1.1.9-2 - 30 September 2011
# - merge workaround provided by Entity to make it work with http proxies
# Version: 1.1.9 - 2 September 2011
# - added workaround for row tags with attributes that were not defined
#   in their rowset (this should fix AssetList)
#
# Version: 1.1.8 - 1 September 2011
# - fix for inconsistent columns attribute in rowsets.
#
# Version: 1.1.7 - 1 September 2011
# - auth() method updated to work with the new authentication scheme.
#
# Version: 1.1.6 - 27 May 2011
# - Now supports composite keys for IndexRowsets.
# - Fixed calls not working if a path was specified in the root url.
#
# Version: 1.1.5 - 27 Januari 2011
# - Now supports (and defaults to) HTTPS. Non-SSL proxies will still work by
#   explicitly specifying http:// in the url.
#
# Version: 1.1.4 - 1 December 2010
# - Empty explicit CDATA tags are now properly handled.
# - _autocast now receives the name of the variable it's trying to typecast,
#   enabling custom/future casting functions to make smarter decisions.
#
# Version: 1.1.3 - 6 November 2010
# - Added support for anonymous CDATA inside row tags. This makes the body of
#   mails in the rows of char/MailBodies available through the .data attribute.
#
# Version: 1.1.2 - 2 July 2010
# - Fixed __str__ on row objects to work properly with unicode strings.
#
# Version: 1.1.1 - 10 Januari 2010
# - Fixed bug that causes nested tags to not appear in rows of rowsets created
#   from normal Elements. This should fix the corp.MemberSecurity method,
#   which now returns all data for members. [jehed]
#
# Version: 1.1.0 - 15 Januari 2009
# - Added Select() method to Rowset class. Using it avoids the creation of
#   temporary row instances, speeding up iteration considerably.
# - Added ParseXML() function, which can be passed arbitrary API XML file or
#   string objects.
# - Added support for proxy servers. A proxy can be specified globally or
#   per api connection instance. [suggestion by graalman]
# - Some minor refactoring.
# - Fixed deprecation warning when using Python 2.6.
#
# Version: 1.0.7 - 14 November 2008
# - Added workaround for rowsets that are missing the (required!) columns
#   attribute. If missing, it will use the columns found in the first row.
#   Note that this is will still break when expecting columns, if the rowset
#   is empty. [Flux/Entity]
#
# Version: 1.0.6 - 18 July 2008
# - Enabled expat text buffering to avoid content breaking up. [BigWhale]
#
# Version: 1.0.5 - 03 February 2008
# - Added workaround to make broken XML responses (like the "row:name" bug in
#   eve/CharacterID) work as intended.
# - Bogus datestamps before the epoch in XML responses are now set to 0 to
#   avoid breaking certain date/time functions. [Anathema Matou]
#
# Version: 1.0.4 - 23 December 2007
# - Changed _autocast() to use timegm() instead of mktime(). [Invisible Hand]
# - Fixed missing attributes of elements inside rows. [Elandra Tenari]
#
# Version: 1.0.3 - 13 December 2007
# - Fixed keyless columns bugging out the parser (in CorporationSheet for ex.)
#
# Version: 1.0.2 - 12 December 2007
# - Fixed parser not working with indented XML.
#
# Version: 1.0.1
# - Some micro optimizations
#
# Version: 1.0
# - Initial release
#
# Requirements:
#   Python 2.4+
#
#-----------------------------------------------------------------------------

import httplib
import urlparse
import urllib
import copy

from xml.parsers import expat
from time import strptime
from calendar import timegm

proxy = None

#-----------------------------------------------------------------------------

class Error(StandardError):
    def __init__(self, code, message):
        self.code = code
        self.args = (message.rstrip("."),)


def EVEAPIConnection(url="api.eveonline.com", cacheHandler=None, proxy=None):
    # Creates an API object through which you can call remote functions.
    #
    # The following optional arguments may be provided:
    #
    # url - root location of the EVEAPI server
    #
    # proxy - (host,port) specifying a proxy server through which to request
    #         the API pages. Specifying a proxy overrides default proxy.
    #
    # cacheHandler - an object which must support the following interface:
    #
    #      retrieve(host, path, params)
    #
    #          Called when eveapi wants to fetch a document.
    #          host is the address of the server, path is the full path to
    #          the requested document, and params is a dict containing the
    #          parameters passed to this api call (keyID, vCode, etc).
    #          The method MUST return one of the following types:
    #
    #           None - if your cache did not contain this entry
    #           str/unicode - eveapi will parse this as XML
    #           Element - previously stored object as provided to store()
    #           file-like object - eveapi will read() XML from the stream.
    #
    #      store(host, path, params, doc, obj)
    #
    #          Called when eveapi wants you to cache this item.
    #          You can use obj to get the info about the object (cachedUntil
    #          and currentTime, etc) doc is the XML document the object
    #          was generated from. It's generally best to cache the XML, not
    #          the object, unless you pickle the object. Note that this method
    #          will only be called if you returned None in the retrieve() for
    #          this object.
    #

    if not url.startswith("http"):
        url = "https://" + url
    p = urlparse.urlparse(url, "https")
    if p.path and p.path[-1] == "/":
        p.path = p.path[:-1]
    ctx = _RootContext(None, p.path, {}, {})
    ctx._handler = cacheHandler
    ctx._scheme = p.scheme
    ctx._host = p.netloc
    ctx._proxy = proxy or globals()["proxy"]
    return ctx


def ParseXML(file_or_string):
    try:
        return _ParseXML(file_or_string, False, None)
    except TypeError:
        raise TypeError("XML data must be provided as string or file-like object")


def _ParseXML(response, fromContext, storeFunc):
    # pre/post-process XML or Element data

    if fromContext and isinstance(response, Element):
        obj = response
    elif type(response) in (str, unicode):
        obj = _Parser().Parse(response, False)
    elif hasattr(response, "read"):
        obj = _Parser().Parse(response, True)
    else:
        raise TypeError("retrieve method must return None, string, file-like object or an Element instance")

    error = getattr(obj, "error", False)
    if error:
        raise Error(error.code, error.data)

    result = getattr(obj, "result", False)
    if not result:
        raise RuntimeError("API object does not contain result")

    if fromContext and storeFunc:
        # call the cache handler to store this object
        storeFunc(obj)

    # make metadata available to caller somehow
    result._meta = obj

    return result





#-----------------------------------------------------------------------------
# API Classes
#-----------------------------------------------------------------------------

_listtypes = (list, tuple, dict)
_unspecified = []

class _Context(object):

    def __init__(self, root, path, parentDict, newKeywords=None):
        self._root = root or self
        self._path = path
        if newKeywords:
            if parentDict:
                self.parameters = parentDict.copy()
            else:
                self.parameters = {}
            self.parameters.update(newKeywords)
        else:
            self.parameters = parentDict or {}

    def context(self, *args, **kw):
        if kw or args:
            path = self._path
            if args:
                path += "/" + "/".join(args)
            return self.__class__(self._root, path, self.parameters, kw)
        else:
            return self

    def __getattr__(self, this):
        # perform arcane attribute majick trick
        return _Context(self._root, self._path + "/" + this, self.parameters)

    def __call__(self, **kw):
        if kw:
            # specified keywords override contextual ones
            for k, v in self.parameters.iteritems():
                if k not in kw:
                    kw[k] = v
        else:
            # no keywords provided, just update with contextual ones.
            kw.update(self.parameters)

        # now let the root context handle it further
        return self._root(self._path, **kw)


class _AuthContext(_Context):

    def character(self, characterID):
        # returns a copy of this connection object but for every call made
        # through it, it will add the folder "/char" to the url, and the
        # characterID to the parameters passed.
        return _Context(self._root, self._path + "/char", self.parameters, {"characterID":characterID})

    def corporation(self, characterID):
        # same as character except for the folder "/corp"
        return _Context(self._root, self._path + "/corp", self.parameters, {"characterID":characterID})


class _RootContext(_Context):

    def auth(self, **kw):
        if len(kw) == 2 and (("keyID" in kw and "vCode" in kw) or ("userID" in kw and "apiKey" in kw)):
            return _AuthContext(self._root, self._path, self.parameters, kw)
        raise ValueError("Must specify keyID and vCode")

    def setcachehandler(self, handler):
        self._root._handler = handler

    def __call__(self, path, **kw):
        # convert list type arguments to something the API likes
        for k, v in kw.iteritems():
            if isinstance(v, _listtypes):
                kw[k] = ','.join(map(str, list(v)))

        cache = self._root._handler

        # now send the request
        path += ".xml.aspx"

        if cache:
            response = cache.retrieve(self._host, path, kw)
        else:
            response = None

        if response is None:
            if self._scheme == "https":
                connectionclass = httplib.HTTPSConnection
            else:
                connectionclass = httplib.HTTPConnection

            if self._proxy is None:
                if self._scheme == "https":
                    connectionclass = httplib.HTTPSConnection
                else:
                    connectionclass = httplib.HTTPConnection

                http = connectionclass(self._host)
                if kw:
                    http.request("POST", path, urllib.urlencode(kw), {"Content-type": "application/x-www-form-urlencoded"})
                else:
                    http.request("GET", path)
            else:
                connectionclass = httplib.HTTPConnection
                http = connectionclass(*self._proxy)
                if kw:
                    http.request("POST", self._scheme+'://'+self._host+path, urllib.urlencode(kw), {"Content-type": "application/x-www-form-urlencoded"})
                else:
                    http.request("GET", self._scheme+'://'+self._host+path)

            response = http.getresponse()
            if response.status != 200:
                if response.status == httplib.NOT_FOUND:
                    raise AttributeError("'%s' not available on API server (404 Not Found)" % path)
                else:
                    raise RuntimeError("'%s' request failed (%d %s)" % (path, response.status, response.reason))

            if cache:
                store = True
                response = response.read()
            else:
                store = False
        else:
            store = False

        retrieve_fallback = cache and getattr(cache, "retrieve_fallback", False)
        if retrieve_fallback:
            # implementor is handling fallbacks...
            try:
                return _ParseXML(response, True, store and (lambda obj: cache.store(self._host, path, kw, response, obj)))
            except Error, reason:
                response = retrieve_fallback(self._host, path, kw, reason=e)
                if response is not None:
                    return response
                raise
        else:
            # implementor is not handling fallbacks...
            return _ParseXML(response, True, store and (lambda obj: cache.store(self._host, path, kw, response, obj)))

#-----------------------------------------------------------------------------
# XML Parser
#-----------------------------------------------------------------------------

def _autocast(key, value):
    # attempts to cast an XML string to the most probable type.
    try:
        if value.strip("-").isdigit():
            return int(value)
    except ValueError:
        pass

    try:
        return float(value)
    except ValueError:
        pass

    if len(value) == 19 and value[10] == ' ':
        # it could be a date string
        try:
            return max(0, int(timegm(strptime(value, "%Y-%m-%d %H:%M:%S"))))
        except OverflowError:
            pass
        except ValueError:
            pass

    # couldn't cast. return string unchanged.
    return value



class _Parser(object):

    def Parse(self, data, isStream=False):
        self.container = self.root = None
        self._cdata = False
        p = expat.ParserCreate()
        p.StartElementHandler = self.tag_start
        p.CharacterDataHandler = self.tag_cdata
        p.StartCdataSectionHandler = self.tag_cdatasection_enter
        p.EndCdataSectionHandler = self.tag_cdatasection_exit
        p.EndElementHandler = self.tag_end
        p.ordered_attributes = True
        p.buffer_text = True

        if isStream:
            p.ParseFile(data)
        else:
            p.Parse(data, True)
        return self.root


    def tag_cdatasection_enter(self):
        # encountered an explicit CDATA tag.
        self._cdata = True

    def tag_cdatasection_exit(self):
        if self._cdata:
            # explicit CDATA without actual data. expat doesn't seem
            # to trigger an event for this case, so do it manually.
            # (_cdata is set False by this call)
            self.tag_cdata("")
        else:
            self._cdata = False

    def tag_start(self, name, attributes):
        # <hack>
        # If there's a colon in the tag name, cut off the name from the colon
        # onward. This is a workaround to make certain bugged XML responses
        # (such as eve/CharacterID.xml.aspx) work.
        if ":" in name:
            name = name[:name.index(":")]
        # </hack>

        if name == "rowset":
            # for rowsets, use the given name
            try:
                columns = attributes[attributes.index('columns')+1].replace(" ", "").split(",")
            except ValueError:
                # rowset did not have columns tag set (this is a bug in API)
                # columns will be extracted from first row instead.
                columns = []

            try:
                priKey = attributes[attributes.index('key')+1]
                this = IndexRowset(cols=columns, key=priKey)
            except ValueError:
                this = Rowset(cols=columns)


            this._name = attributes[attributes.index('name')+1]
            this.__catch = "row" # tag to auto-add to rowset.
        else:
            this = Element()
            this._name = name

        this.__parent = self.container

        if self.root is None:
            # We're at the root. The first tag has to be "eveapi" or we can't
            # really assume the rest of the xml is going to be what we expect.
            if name != "eveapi":
                raise RuntimeError("Invalid API response")
            self.root = this

        if isinstance(self.container, Rowset) and (self.container.__catch == this._name):
            # <hack>
            # - check for missing columns attribute (see above)
            # - check for extra attributes that were not defined in the rowset,
            #   such as rawQuantity in the assets lists.
            # In either case the tag is assumed to be correct and the rowset's
            # columns are overwritten with the tag's version.
            if not self.container._cols or (len(attributes)/2 > len(self.container._cols)):
                self.container._cols = attributes[0::2]
            # </hack>

            self.container.append([_autocast(attributes[i], attributes[i+1]) for i in xrange(0, len(attributes), 2)])
            this._isrow = True
            this._attributes = this._attributes2 = None
        else:
            this._isrow = False
            this._attributes = attributes
            this._attributes2 = []

        self.container = this


    def tag_cdata(self, data):
        if self._cdata:
            # unset cdata flag to indicate it's been handled.
            self._cdata = False
        else:
            if data in ("\r\n", "\n") or data.strip() != data:
                return

        this = self.container
        data = _autocast(this._name, data)

        if this._isrow:
            # sigh. anonymous data inside rows makes Entity cry.
            # for the love of Jove, CCP, learn how to use rowsets.
            parent = this.__parent
            _row = parent._rows[-1]
            _row.append(data)
            if len(parent._cols) < len(_row):
                parent._cols.append("data")

        elif this._attributes:
            # this tag has attributes, so we can't simply assign the cdata
            # as an attribute to the parent tag, as we'll lose the current
            # tag's attributes then. instead, we'll assign the data as
            # attribute of this tag.
            this.data = data
        else:
            # this was a simple <tag>data</tag> without attributes.
            # we won't be doing anything with this actual tag so we can just
            # bind it to its parent (done by __tag_end)
            setattr(this.__parent, this._name, data)

    def tag_end(self, name):
        this = self.container
        if this is self.root:
            del this._attributes
            #this.__dict__.pop("_attributes", None)
            return

        # we're done with current tag, so we can pop it off. This means that
        # self.container will now point to the container of element 'this'.
        self.container = this.__parent
        del this.__parent

        attributes = this.__dict__.pop("_attributes")
        attributes2 = this.__dict__.pop("_attributes2")
        if attributes is None:
            # already processed this tag's closure early, in tag_start()
            return

        if self.container._isrow:
            # Special case here. tags inside a row! Such tags have to be
            # added as attributes of the row.
            parent = self.container.__parent

            # get the row line for this element from its parent rowset
            _row = parent._rows[-1]

            # add this tag's value to the end of the row
            _row.append(getattr(self.container, this._name, this))

            # fix columns if neccessary.
            if len(parent._cols) < len(_row):
                parent._cols.append(this._name)
        else:
            # see if there's already an attribute with this name (this shouldn't
            # really happen, but it doesn't hurt to handle this case!
            sibling = getattr(self.container, this._name, None)
            if sibling is None:
                self.container._attributes2.append(this._name)
                setattr(self.container, this._name, this)
            # Note: there aren't supposed to be any NON-rowset tags containing
            # multiples of some tag or attribute. Code below handles this case.
            elif isinstance(sibling, Rowset):
                # its doppelganger is a rowset, append this as a row to that.
                row = [_autocast(attributes[i], attributes[i+1]) for i in xrange(0, len(attributes), 2)]
                row.extend([getattr(this, col) for col in attributes2])
                sibling.append(row)
            elif isinstance(sibling, Element):
                # parent attribute is an element. This means we're dealing
                # with multiple of the same sub-tag. Change the attribute
                # into a Rowset, adding the sibling element and this one.
                rs = Rowset()
                rs.__catch = rs._name = this._name
                row = [_autocast(attributes[i], attributes[i+1]) for i in xrange(0, len(attributes), 2)]+[getattr(this, col) for col in attributes2]
                rs.append(row)
                row = [getattr(sibling, attributes[i]) for i in xrange(0, len(attributes), 2)]+[getattr(sibling, col) for col in attributes2]
                rs.append(row)
                rs._cols = [attributes[i] for i in xrange(0, len(attributes), 2)]+[col for col in attributes2]
                setattr(self.container, this._name, rs)
            else:
                # something else must have set this attribute already.
                # (typically the <tag>data</tag> case in tag_data())
                pass

        # Now fix up the attributes and be done with it.
        for i in xrange(0, len(attributes), 2):
            this.__dict__[attributes[i]] = _autocast(attributes[i], attributes[i+1])

        return




#-----------------------------------------------------------------------------
# XML Data Containers
#-----------------------------------------------------------------------------
# The following classes are the various container types the XML data is
# unpacked into.
#
# Note that objects returned by API calls are to be treated as read-only. This
# is not enforced, but you have been warned.
#-----------------------------------------------------------------------------

class Element(object):
    # Element is a namespace for attributes and nested tags
    def __str__(self):
        return "<Element '%s'>" % self._name

_fmt = u"%s:%s".__mod__
class Row(object):
    # A Row is a single database record associated with a Rowset.
    # The fields in the record are accessed as attributes by their respective
    # column name.
    #
    # To conserve resources, Row objects are only created on-demand. This is
    # typically done by Rowsets (e.g. when iterating over the rowset).

    def __init__(self, cols=None, row=None):
        self._cols = cols or []
        self._row = row or []

    def __nonzero__(self):
        return True

    def __ne__(self, other):
        return self.__cmp__(other)

    def __eq__(self, other):
        return self.__cmp__(other) == 0

    def __cmp__(self, other):
        if type(other) != type(self):
            raise TypeError("Incompatible comparison type")
        return cmp(self._cols, other._cols) or cmp(self._row, other._row)

    def __getattr__(self, this):
        try:
            return self._row[self._cols.index(this)]
        except:
            raise AttributeError, this

    def __getitem__(self, this):
        return self._row[self._cols.index(this)]

    def __str__(self):
        return "Row(" + ','.join(map(_fmt, zip(self._cols, self._row))) + ")"


class Rowset(object):
    # Rowsets are collections of Row objects.
    #
    # Rowsets support most of the list interface:
    #   iteration, indexing and slicing
    #
    # As well as the following methods:
    #
    #   IndexedBy(column)
    #     Returns an IndexRowset keyed on given column. Requires the column to
    #     be usable as primary key.
    #
    #   GroupedBy(column)
    #     Returns a FilterRowset keyed on given column. FilterRowset objects
    #     can be accessed like dicts. See FilterRowset class below.
    #
    #   SortBy(column, reverse=True)
    #     Sorts rowset in-place on given column. for a descending sort,
    #     specify reversed=True.
    #
    #   SortedBy(column, reverse=True)
    #     Same as SortBy, except this returns a new rowset object instead of
    #     sorting in-place.
    #
    #   Select(columns, row=False)
    #     Yields a column values tuple (value, ...) for each row in the rowset.
    #     If only one column is requested, then just the column value is
    #     provided instead of the values tuple.
    #     When row=True, each result will be decorated with the entire row.
    #

    def IndexedBy(self, column):
        return IndexRowset(self._cols, self._rows, column)

    def GroupedBy(self, column):
        return FilterRowset(self._cols, self._rows, column)

    def SortBy(self, column, reverse=False):
        ix = self._cols.index(column)
        self.sort(key=lambda e: e[ix], reverse=reverse)

    def SortedBy(self, column, reverse=False):
        rs = self[:]
        rs.SortBy(column, reverse)
        return rs

    def Select(self, *columns, **options):
        if len(columns) == 1:
            i = self._cols.index(columns[0])
            if options.get("row", False):
                for line in self._rows:
                    yield (line, line[i])
            else:
                for line in self._rows:
                    yield line[i]
        else:
            i = map(self._cols.index, columns)
            if options.get("row", False):
                for line in self._rows:
                    yield line, [line[x] for x in i]
            else:
                for line in self._rows:
                    yield [line[x] for x in i]


    # -------------

    def __init__(self, cols=None, rows=None):
        self._cols = cols or []
        self._rows = rows or []

    def append(self, row):
        if isinstance(row, list):
            self._rows.append(row)
        elif isinstance(row, Row) and len(row._cols) == len(self._cols):
            self._rows.append(row._row)
        else:
            raise TypeError("incompatible row type")

    def __add__(self, other):
        if isinstance(other, Rowset):
            if len(other._cols) == len(self._cols):
                self._rows += other._rows
        raise TypeError("rowset instance expected")

    def __nonzero__(self):
        return not not self._rows

    def __len__(self):
        return len(self._rows)

    def copy(self):
        return self[:]

    def __getitem__(self, ix):
        if type(ix) is slice:
            return Rowset(self._cols, self._rows[ix])
        return Row(self._cols, self._rows[ix])

    def sort(self, *args, **kw):
        self._rows.sort(*args, **kw)

    def __str__(self):
        return ("Rowset(columns=[%s], rows=%d)" % (','.join(self._cols), len(self)))

    def __getstate__(self):
        return (self._cols, self._rows)

    def __setstate__(self, state):
        self._cols, self._rows = state



class IndexRowset(Rowset):
    # An IndexRowset is a Rowset that keeps an index on a column.
    #
    # The interface is the same as Rowset, but provides an additional method:
    #
    #   Get(key [, default])
    #     Returns the Row mapped to provided key in the index. If there is no
    #     such key in the index, KeyError is raised unless a default value was
    #     specified.
    #

    def Get(self, key, *default):
        row = self._items.get(key, None)
        if row is None:
            if default:
                return default[0]
            raise KeyError, key
        return Row(self._cols, row)

    # -------------

    def __init__(self, cols=None, rows=None, key=None):
        try:
            if "," in key:
                self._ki = ki = [cols.index(k) for k in key.split(",")]
                self.composite = True
            else:
                self._ki = ki = cols.index(key)
                self.composite = False
        except IndexError:
            raise ValueError("Rowset has no column %s" % key)

        Rowset.__init__(self, cols, rows)
        self._key = key

        if self.composite:
            self._items = dict((tuple([row[k] for k in ki]), row) for row in self._rows)
        else:
            self._items = dict((row[ki], row) for row in self._rows)

    def __getitem__(self, ix):
        if type(ix) is slice:
            return IndexRowset(self._cols, self._rows[ix], self._key)
        return Rowset.__getitem__(self, ix)

    def append(self, row):
        Rowset.append(self, row)
        if self.composite:
            self._items[tuple([row[k] for k in self._ki])] = row
        else:
            self._items[row[self._ki]] = row

    def __getstate__(self):
        return (Rowset.__getstate__(self), self._items, self._ki)

    def __setstate__(self, state):
        state, self._items, self._ki = state
        Rowset.__setstate__(self, state)


class FilterRowset(object):
    # A FilterRowset works much like an IndexRowset, with the following
    # differences:
    # - FilterRowsets are accessed much like dicts
    # - Each key maps to a Rowset, containing only the rows where the value
    #   of the column this FilterRowset was made on matches the key.

    def __init__(self, cols=None, rows=None, key=None, key2=None, dict=None):
        if dict is not None:
            self._items = items = dict
        elif cols is not None:
            self._items = items = {}

            idfield = cols.index(key)
            if not key2:
                for row in rows:
                    id = row[idfield]
                    if id in items:
                        items[id].append(row)
                    else:
                        items[id] = [row]
            else:
                idfield2 = cols.index(key2)
                for row in rows:
                    id = row[idfield]
                    if id in items:
                        items[id][row[idfield2]] = row
                    else:
                        items[id] = {row[idfield2]:row}

        self._cols = cols
        self.key = key
        self.key2 = key2
        self._bind()

    def _bind(self):
        items = self._items
        self.keys = items.keys
        self.iterkeys = items.iterkeys
        self.__contains__ = items.__contains__
        self.has_key = items.has_key
        self.__len__ = items.__len__
        self.__iter__ = items.__iter__

    def copy(self):
        return FilterRowset(self._cols[:], None, self.key, self.key2, dict=copy.deepcopy(self._items))

    def get(self, key, default=_unspecified):
        try:
            return self[key]
        except KeyError:
            if default is _unspecified:
                raise
        return default

    def __getitem__(self, i):
        if self.key2:
            return IndexRowset(self._cols, None, self.key2, self._items.get(i, {}))
        return Rowset(self._cols, self._items[i])

    def __getstate__(self):
        return (self._cols, self._rows, self._items, self.key, self.key2)

    def __setstate__(self, state):
        self._cols, self._rows, self._items, self.key, self.key2 = state
        self._bind()

########NEW FILE########
__FILENAME__ = gamedata
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import re

from sqlalchemy.orm import reconstructor

from eqBase import EqBase

import traceback

try:
    from collections import OrderedDict
except ImportError:
    from gui.utils.compat import OrderedDict

class Effect(EqBase):
    '''
    The effect handling class, it is used to proxy and load effect handler code,
    as well as a container for extra information regarding effects coming
    from the gamedata db.

    @ivar ID: the ID of this effect
    @ivar name: The name of this effect
    @ivar description: The description of this effect, this is usualy pretty useless
    @ivar published: Wether this effect is published or not, unpublished effects are typicaly unused.
    '''
    #Filter to change names of effects to valid python method names
    nameFilter = re.compile("[^A-Za-z0-9]")

    @reconstructor
    def init(self):
        '''
        Reconstructor, composes the object as we grab it from the database
        '''
        self.__generated = False
        self.handlerName = re.sub(self.nameFilter, "", self.name).lower()

    @property
    def handler(self):
        '''
        The handler for the effect,
        It is automaticly fetched from effects/<effectName>.py if the file exists
        the first time this property is accessed.
        '''
        if not self.__generated:
            self.__generateHandler()

        return self.__handler

    @property
    def runTime(self):
        '''
        The runTime that this effect should be run at.
        This property is also automaticly fetched from effects/<effectName>.py if the file exists.
        the possible values are:
        None, "early", "normal", "late"
        None and "normal" are equivalent, and are also the default.

        effects with an early runTime will be ran first when things are calculated,
        followed by effects with a normal runTime and as last effects with a late runTime are ran.
        '''
        if not self.__generated:
            self.__generateHandler()

        return self.__runTime

    @property
    def type(self):
        '''
        The type of the effect, automaticly fetched from effects/<effectName>.py if the file exists.

        Valid values are:
        "passive", "active", "projected", "gang"

        Each gives valuable information to eos about what type the module having
        the effect is. passive vs active gives eos clues about wether to module
        is activatable or not (duh!) and projected and gang each tell eos that the
        module can be projected onto other fits, or used as a gang booster module respectivly
        '''
        if not self.__generated:
            self.__generateHandler()

        return self.__type

    @property
    def isImplemented(self):
        '''
        Wether this effect is implemented in code or not,
        unimplemented effects simply do nothing at all when run
        '''
        return self.handler != effectDummy

    def isType(self, type):
        '''
        Check if this effect is of the passed type
        '''
        return self.type is not None and type in self.type

    def __generateHandler(self):
        '''
        Grab the handler, type and runTime from the effect code if it exists,
        if it doesn't, set dummy values and add a dummy handler
        '''
        try:
            self.__effectModule = effectModule = __import__('eos.effects.' + self.handlerName, fromlist=True)
            self.__handler = getattr(effectModule, "handler")
            try:
                self.__runTime = getattr(effectModule, "runTime") or "normal"
            except AttributeError:
                self.__runTime = "normal"

            try:
                t = getattr(effectModule, "type")
            except AttributeError:
                t = None

            t = t if isinstance(t, tuple) or t is None else (t,)
            self.__type = t
        except ImportError as e:
            self.__handler = effectDummy
            self.__runTime = "normal"
            self.__type = None
        except Exception as e:
            traceback.print_exc(e)

        self.__generated = True

    def getattr(self, key):
        if not self.__generated:
            self.__generateHandler()

        return getattr(self.__effectModule, key, None)

def effectDummy(*args, **kwargs):
    pass

class Item(EqBase):
    MOVE_ATTRS = (4,   # Mass
                  38,  # Capacity
                  161) # Volume

    MOVE_ATTR_INFO = None

    @classmethod
    def getMoveAttrInfo(cls):
        info = getattr(cls, "MOVE_ATTR_INFO", None)
        if info is None:
            cls.MOVE_ATTR_INFO = info = []
            import eos.db
            for id in cls.MOVE_ATTRS:
                info.append(eos.db.getAttributeInfo(id))

        return info

    def moveAttrs(self):
        self.__moved = True
        for info in self.getMoveAttrInfo():
            val = getattr(self, info.name, 0)
            if val != 0:
                attr = Attribute()
                attr.info = info
                attr.value = val
                self.__attributes[info.name] = attr

    @reconstructor
    def init(self):
        self.__race = None
        self.__requiredSkills = None
        self.__moved = False
        self.__offensive = None
        self.__assistive = None

    @property
    def attributes(self):
        if not self.__moved:
            self.moveAttrs()

        return self.__attributes

    def getAttribute(self, key):
        if key in self.attributes:
            return self.attributes[key].value

    def isType(self, type):
        for effect in self.effects.itervalues():
            if effect.isType(type):
                return True

        return False

    @property
    def requiredSkills(self):
        if self.__requiredSkills is None:
            # This import should be here to make sure it's fully initialized
            from eos import db
            requiredSkills = OrderedDict()
            self.__requiredSkills = requiredSkills
            # Map containing attribute IDs we may need for required skills
            # { requiredSkillX : requiredSkillXLevel }
            srqIDMap = {182: 277, 183: 278, 184: 279, 1285: 1286, 1289: 1287, 1290: 1288}
            combinedAttrIDs = set(srqIDMap.iterkeys()).union(set(srqIDMap.itervalues()))
            # Map containing result of the request
            # { attributeID : attributeValue }
            skillAttrs = {}
            # Get relevant attribute values from db (required skill IDs and levels) for our item
            for attrInfo in db.directAttributeRequest((self.ID,), tuple(combinedAttrIDs)):
                attrID = attrInfo[1]
                attrVal = attrInfo[2]
                skillAttrs[attrID] = attrVal
            # Go through all attributeID pairs
            for srqIDAtrr, srqLvlAttr in srqIDMap.iteritems():
                # Check if we have both in returned result
                if srqIDAtrr in skillAttrs and srqLvlAttr in skillAttrs:
                    skillID = int(skillAttrs[srqIDAtrr])
                    skillLvl = skillAttrs[srqLvlAttr]
                    # Fetch item from database and fill map
                    item = db.getItem(skillID)
                    requiredSkills[item] = skillLvl
        return self.__requiredSkills

    @property
    def race(self):
        if self.__race is None:
            # Define race map
            map = {1: "caldari",
                   2: "minmatar",
                   4: "amarr",
                   5: "sansha", # Caldari + Amarr
                   6: "blood", # Minmatar + Amarr
                   8: "gallente",
                   9: "guristas", # Caldari + Gallente
                   10: "angelserp", # Minmatar + Gallente, final race depends on the order of skills
                   12: "sisters", # Amarr + Gallente
                   16: "jove",
                   32: "sansha", # Incrusion Sansha
                   128: "ore"}
            # Race is None by default
            race = None
            # Check primary and secondary required skills' races
            if race is None:
                skills = self.requiredSkills.keys()
                skillPrimaryRace = (skills[0].raceID if len(skills) >= 1 else 0) or 0
                skillSecondaryRace = (skills[1].raceID if len(skills) >= 2 else 0) or 0
                skillRaces = (skillPrimaryRace, skillSecondaryRace)
                if sum(skillRaces) in map:
                    race = map[sum(skillRaces)]
                    if race == "angelserp":
                        if skillRaces == (2, 8):
                            race = "angel"
                        else:
                            race = "serpentis"

            # Rely on item's own raceID as last resort
            if race is None:
                race = map.get(self.raceID, None)

            # Store our final value
            self.__race = race
        return self.__race

    @property
    def assistive(self):
        """Detects if item can be used as assistance"""
        # Make sure we cache results
        if self.__assistive is None:
            assistive = False
            # Go through all effects and find first assistive
            for effect in self.effects.itervalues():
                if effect.info.isAssistance is True:
                    # If we find one, stop and mark item as assistive
                    assistive = True
                    break
            self.__assistive = assistive
        return self.__assistive

    @property
    def offensive(self):
        """Detects if item can be used as something offensive"""
        # Make sure we cache results
        if self.__offensive is None:
            offensive = False
            # Go through all effects and find first offensive
            for effect in self.effects.itervalues():
                if effect.info.isOffensive is True:
                    # If we find one, stop and mark item as offensive
                    offensive = True
                    break
            self.__offensive = offensive
        return self.__offensive

    def requiresSkill(self, skill, level=None):
        for s, l in self.requiredSkills.iteritems():
            if isinstance(skill, basestring):
                if s.name == skill and (level is None or l == level):
                    return True

            elif isinstance(skill, int) and (level is None or l == level):
                if s.ID == skill:
                    return True

            elif skill == s and (level is None or l == level):
                return True

            elif hasattr(skill, "item") and skill.item == s and (level is None or l == level):
                return True

        return False

class MetaData(EqBase):
    def __init__(self, name, val=None):
        self.fieldName = name
        self.fieldValue = val

class EffectInfo(EqBase):
    pass

class AttributeInfo(EqBase):
    pass

class Attribute(EqBase):
    pass

class Category(EqBase):
    pass

class Group(EqBase):
    pass

class Icon(EqBase):
    pass

class MarketGroup(EqBase):
    pass

class MetaGroup(EqBase):
    pass

class MetaType(EqBase):
    pass

class Unit(EqBase):
    pass

class Traits(EqBase):
    pass
########NEW FILE########
__FILENAME__ = fitDps
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from eos.graph import Graph, Data
from eos.types import Hardpoint, State
from math import log, sin, radians

class FitDpsGraph(Graph):
    defaults = {"angle": 0,
                "distance": 0,
                "signatureRadius": None,
                "velocity": 0}

    def __init__(self, fit, data=None):
        Graph.__init__(self, fit, self.calcDps, data if data is not None else self.defaults)
        self.fit = fit

    def calcDps(self, data):
        fit = self.fit
        total = 0
        distance = data["distance"] * 1000
        for mod in fit.modules:
            if mod.hardpoint == Hardpoint.TURRET:
                if mod.state >= State.ACTIVE:
                    total += mod.dps * self.calculateTurretMultiplier(mod, data)

            elif mod.hardpoint == Hardpoint.MISSILE:
                if mod.state >= State.ACTIVE and mod.maxRange >= distance:
                    total += mod.dps * self.calculateMissileMultiplier(mod, data)

        if distance <= fit.extraAttributes["droneControlRange"]:
            for drone in fit.drones:
                multiplier = 1 if drone.getModifiedItemAttr("maxVelocity") > 0 else self.calculateTurretMultiplier(drone, data)
                total += drone.dps * multiplier

        return total

    def calculateMissileMultiplier(self, mod, data):
        targetSigRad = data["signatureRadius"]
        targetVelocity = data["velocity"]
        explosionRadius = mod.getModifiedChargeAttr("aoeCloudSize")
        targetSigRad = explosionRadius if targetSigRad is None else targetSigRad
        explosionVelocity = mod.getModifiedChargeAttr("aoeVelocity")
        damageReductionFactor = mod.getModifiedChargeAttr("aoeDamageReductionFactor")
        damageReductionSensitivity = mod.getModifiedChargeAttr("aoeDamageReductionSensitivity")

        sigRadiusFactor = targetSigRad / explosionRadius
        if targetVelocity:
            velocityFactor = (explosionVelocity / explosionRadius * targetSigRad / targetVelocity) ** (log(damageReductionFactor) / log(damageReductionSensitivity))
        else:
            velocityFactor = 1
        return min(sigRadiusFactor, velocityFactor, 1)

    def calculateTurretMultiplier(self, mod, data):
        #Source for most of turret calculation info: http://wiki.eveonline.com/en/wiki/Falloff
        chanceToHit = self.calculateTurretChanceToHit(mod, data)
        if chanceToHit > 0.01:
            #AvgDPS = Base Damage * [ ( ChanceToHit^2 + ChanceToHit + 0.0499 ) / 2 ]
            multiplier = (chanceToHit ** 2 + chanceToHit + 0.0499) / 2
        else:
            #All hits are wreckings
            multiplier = chanceToHit * 3
        dmgScaling = mod.getModifiedItemAttr("turretDamageScalingRadius")
        if dmgScaling:
            targetSigRad = data["signatureRadius"]
            multiplier = min(1, (float(targetSigRad) / dmgScaling) ** 2)
        return multiplier

    def calculateTurretChanceToHit(self, mod, data):
        distance = data["distance"] * 1000
        tracking = mod.getModifiedItemAttr("trackingSpeed")
        turretOptimal = mod.maxRange
        turretFalloff = mod.falloff
        turretSigRes = mod.getModifiedItemAttr("optimalSigRadius")
        targetSigRad = data["signatureRadius"]
        targetSigRad = turretSigRes if targetSigRad is None else targetSigRad
        transversal = sin(radians(data["angle"])) * data["velocity"]
        trackingEq = (((transversal / (distance * tracking)) *
                       (turretSigRes / targetSigRad)) ** 2)
        rangeEq = ((max(0, distance - turretOptimal)) / turretFalloff) ** 2

        return 0.5 ** (trackingEq + rangeEq)

########NEW FILE########
__FILENAME__ = mathUtils
#===============================================================================
# Copyright (C) 2010 Anton Vorobyov
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import decimal

def floorFloat(value):
    """Round float down to integer"""
    # We have to convert float to str to keep compatibility with
    # decimal module in python 2.6
    value = str(value)
    # Do the conversions for proper rounding down, avoiding float
    # representation errors
    result = int(decimal.Decimal(value).to_integral_value(rounding=decimal.ROUND_DOWN))
    return result

########NEW FILE########
__FILENAME__ = modifiedAttributeDict
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from math import exp
import collections

defaultValuesCache = {}

class ItemAttrShortcut(object):
    def getModifiedItemAttr(self, key):
        if key in self.itemModifiedAttributes:
            return self.itemModifiedAttributes[key]
        else:
            return None

class ChargeAttrShortcut(object):
    def getModifiedChargeAttr(self, key):
        if key in self.chargeModifiedAttributes:
            return self.chargeModifiedAttributes[key]
        else:
            return None

class ModifiedAttributeDict(collections.MutableMapping):
    class CalculationPlaceholder():
        pass

    def __init__(self, fit = None):
        self.fit = fit
        # Stores original values of the entity
        self.__original = None
        # Modified values during calculations
        self.__intermediary = {}
        # Final modified values
        self.__modified = {}
        # Affected by entities
        self.__affectedBy = {}
        # Dictionaries for various value modification types
        self.__forced = {}
        self.__preAssigns = {}
        self.__preIncreases = {}
        self.__multipliers = {}
        self.__penalizedMultipliers = {}
        self.__postIncreases = {}

    def clear(self):
        self.__intermediary.clear()
        self.__modified.clear()
        self.__affectedBy.clear()
        self.__forced.clear()
        self.__preAssigns.clear()
        self.__preIncreases.clear()
        self.__multipliers.clear()
        self.__penalizedMultipliers.clear()
        self.__postIncreases.clear()

    @property
    def original(self):
        return self.__original

    @original.setter
    def original(self, val):
        self.__original = val
        self.__modified.clear()

    def __getitem__(self, key):
        # Check if we have final calculated value
        if key in self.__modified:
            if self.__modified[key] == self.CalculationPlaceholder:
                self.__modified[key] = self.__calculateValue(key)
            return self.__modified[key]
        # Then in values which are not yet calculated
        elif key in self.__intermediary:
            return self.__intermediary[key]
        # Original value is the least priority
        else:
            return self.getOriginal(key)

    def __delitem__(self, key):
        if key in self.__modified:
            del self.__modified[key]
        if key in self.__intermediary:
            del self.__intermediary[key]

    def getOriginal(self, key):
        val = self.__original.get(key)
        if val is None:
            return None

        return val.value if hasattr(val, "value") else val

    def __setitem__(self, key, val):
        self.__intermediary[key] = val

    def __iter__(self):
        all = dict(self.__original, **self.__modified)
        return (key for key in all)

    def __contains__(self, key):
        return (self.__original is not None and key in self.__original) or key in self.__modified or key in self.__intermediary

    def __placehold(self, key):
        """Create calculation placeholder in item's modified attribute dict"""
        self.__modified[key] = self.CalculationPlaceholder

    def __len__(self):
        keys = set()
        keys.update(self.__original.iterkeys())
        keys.update(self.__modified.iterkeys())
        keys.update(self.__intermediary.iterkeys())
        return len(keys)

    def __calculateValue(self, key):
        # If value is forced, we don't have to calculate anything,
        # just return forced value instead
        force = self.__forced[key] if key in self.__forced else None
        if force is not None:
            return force
        # Grab our values if they're there, otherwise we'll take default values
        preIncrease = self.__preIncreases[key] if key in self.__preIncreases else 0
        multiplier = self.__multipliers[key] if key in self.__multipliers else 1
        penalizedMultiplierGroups = self.__penalizedMultipliers[key] if key in self.__penalizedMultipliers else {}
        postIncrease = self.__postIncreases[key] if key in self.__postIncreases else 0

        # Grab initial value, priorities are:
        # Results of ongoing calculation > preAssign > original > 0
        try:
            default = defaultValuesCache[key]
        except KeyError:
            from eos.db.gamedata.queries import getAttributeInfo
            attrInfo = getAttributeInfo(key)
            if attrInfo is None:
                default = defaultValuesCache[key] = 0.0
            else:
                dv = attrInfo.defaultValue
                default = defaultValuesCache[key] = dv if dv is not None else 0.0
        val = self.__intermediary[key] if key in self.__intermediary else self.__preAssigns[key] if key in self.__preAssigns else self.getOriginal(key) if key in self.__original else default

        # We'll do stuff in the following order:
        # preIncrease > multiplier > stacking penalized multipliers > postIncrease
        val += preIncrease
        val *= multiplier
        # Each group is penalized independently
        # Things in different groups will not be stack penalized between each other
        for penalizedMultipliers in penalizedMultiplierGroups.itervalues():
            # A quick explanation of how this works:
            # 1: Bonuses and penalties are calculated seperately, so we'll have to filter each of them
            l1 = filter(lambda val: val > 1, penalizedMultipliers)
            l2 = filter(lambda val: val < 1, penalizedMultipliers)
            # 2: The most significant bonuses take the smallest penalty,
            # This means we'll have to sort
            abssort = lambda val: -abs(val - 1)
            l1.sort(key=abssort)
            l2.sort(key=abssort)
            # 3: The first module doesn't get penalized at all
            # Any module after the first takes penalties according to:
            # 1 + (multiplier - 1) * math.exp(- math.pow(i, 2) / 7.1289)
            for l in (l1, l2):
                for i in xrange(len(l)):
                    bonus = l[i]
                    val *= 1 + (bonus - 1) * exp(- i ** 2 / 7.1289)
        val += postIncrease

        return val

    def getAfflictions(self, key):
        return self.__affectedBy[key] if key in self.__affectedBy else {}

    def iterAfflictions(self):
        return self.__affectedBy.__iter__()

    def __afflict(self, attributeName, operation, bonus):
        """Add modifier to list of things affecting current item"""
        # Do nothing if no fit is assigned
        if self.fit is None:
            return
        # Create dictionary for given attribute and give it alias
        if attributeName not in self.__affectedBy:
            self.__affectedBy[attributeName] = {}
        affs = self.__affectedBy[attributeName]
        # If there's no set for current fit in dictionary, create it
        if self.fit not in affs:
            affs[self.fit] = set()
        # Reassign alias to set
        affs = affs[self.fit]
        # Get modifier which helps to compose 'Affected by' map
        modifier = self.fit.getModifier()
        # Add current affliction to set
        affs.add((modifier, operation, bonus))

    def preAssign(self, attributeName, value):
        """Overwrites original value of the entity with given one, allowing further modification"""
        self.__preAssigns[attributeName] = value
        self.__placehold(attributeName)
        # Add to afflictions only if preassigned value differs from original
        if value != self.getOriginal(attributeName):
            self.__afflict(attributeName, "=", value)

    def increase(self, attributeName, increase, position="pre"):
        """Increase value of given attribute by given number"""
        # Increases applied before multiplications and after them are
        # written in separate maps
        if position == "pre":
            tbl = self.__preIncreases
        elif position == "post":
            tbl = self.__postIncreases
        else:
            raise ValueError("position should be either pre or post")
        if not attributeName in tbl:
            tbl[attributeName] = 0
        tbl[attributeName] += increase
        self.__placehold(attributeName)
        # Add to list of afflictions only if we actually modify value
        if increase != 0:
            self.__afflict(attributeName, "+", increase)

    def multiply(self, attributeName, multiplier, stackingPenalties=False, penaltyGroup="default"):
        """Multiply value of given attribute by given factor"""
        # If we're asked to do stacking penalized multiplication, append values
        # to per penalty group lists
        if stackingPenalties:
            if not attributeName in self.__penalizedMultipliers:
                self.__penalizedMultipliers[attributeName] = {}
            if not penaltyGroup in self.__penalizedMultipliers[attributeName]:
                self.__penalizedMultipliers[attributeName][penaltyGroup] = []
            tbl = self.__penalizedMultipliers[attributeName][penaltyGroup]
            tbl.append(multiplier)
        # Non-penalized multiplication factors go to the single list
        else:
            if not attributeName in self.__multipliers:
                self.__multipliers[attributeName] = 1
            self.__multipliers[attributeName] *= multiplier
        self.__placehold(attributeName)
        # Add to list of afflictions only if we actually modify value
        if multiplier != 1:
            self.__afflict(attributeName, "%s*" % ("s" if stackingPenalties else ""), multiplier)

    def boost(self, attributeName, boostFactor, *args, **kwargs):
        """Boost value by some percentage"""
        # We just transform percentage boost into multiplication factor
        self.multiply(attributeName, 1 + boostFactor / 100.0, *args, **kwargs)

    def force(self, attributeName, value):
        """Force value to attribute and prohibit any changes to it"""
        self.__forced[attributeName] = value
        self.__placehold(attributeName)
        self.__afflict(attributeName, u"\u2263", value)

class Affliction():
    def __init__(self, type, amount):
        self.type = type
        self.amount = amount

########NEW FILE########
__FILENAME__ = booster
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from eos.modifiedAttributeDict import ModifiedAttributeDict, ItemAttrShortcut
from eos.effectHandlerHelpers import HandledItem
from sqlalchemy.orm import reconstructor, validates

class Booster(HandledItem, ItemAttrShortcut):
    def __init__(self, item):
        self.__slot = self.__calculateSlot(item)
        self.itemID = item.ID
        self.__item = item
        self.active = True
        self.build()

    @reconstructor
    def init(self):
        self.__item = None

    def build(self):
        self.__itemModifiedAttributes = ModifiedAttributeDict()
        self.__itemModifiedAttributes.original = self.__item.attributes
        self.__sideEffects = []
        for effect in self.item.effects.itervalues():
            if effect.isType("boosterSideEffect"):
                s = SideEffect(self)
                s.effect = effect
                s.active = effect.ID in self.__activeSideEffectIDs
                self.__sideEffects.append(s)

    def __fetchItemInfo(self):
        import eos.db
        self.__item = eos.db.getItem(self.itemID)
        self.__slot = self.__calculateSlot(self.__item)
        self.build()

    def iterSideEffects(self):
        return self.__sideEffects.__iter__()

    def getSideEffect(self, name):
        for sideEffect in self.iterSideEffects():
            if sideEffect.effect.name == name:
                return sideEffect

        raise KeyError("SideEffect with %s as name not found" % name)

    @property
    def itemModifiedAttributes(self):
        if self.__item is None:
            self.__fetchItemInfo()

        return self.__itemModifiedAttributes

    @property
    def slot(self):
        if self.__item is None:
            self.__fetchItemInfo()

        return self.__slot

    @property
    def item(self):
        if self.__item is None:
            self.__fetchItemInfo()

        return self.__item

    def __calculateSlot(self, item):
        if not "boosterness" in item.attributes:
            raise ValueError("Passed item is not a booster")

        return int(item.attributes["boosterness"].value)

    def clear(self):
        self.itemModifiedAttributes.clear()

    def calculateModifiedAttributes(self, fit, runTime, forceProjected = False):
        if forceProjected: return
        if self.active == False: return
        for effect in self.item.effects.itervalues():
            if effect.runTime == runTime and effect.isType("passive"):
                effect.handler(fit, self, ("booster",))

        for sideEffect in self.iterSideEffects():
            if sideEffect.active and sideEffect.effect.runTime == runTime:
                sideEffect.effect.handler(fit, self, ("boosterSideEffect",))

    @validates("ID", "itemID", "ammoID", "active")
    def validator(self, key, val):
        map = {"ID": lambda val: isinstance(val, int),
               "itemID" : lambda val: isinstance(val, int),
               "ammoID" : lambda val: isinstance(val, int),
               "active" : lambda val: isinstance(val, bool),
               "slot" : lambda val: isinstance(val, int) and val >= 1 and val <= 3}

        if map[key](val) == False: raise ValueError(str(val) + " is not a valid value for " + key)
        else: return val

    def __deepcopy__(self, memo):
        copy = Booster(self.item)
        copy.active = self.active
        origSideEffects = list(self.iterSideEffects())
        copySideEffects = list(copy.iterSideEffects())
        i = 0
        while i < len(origSideEffects):
            copySideEffects[i].active = origSideEffects[i].active
            i += 1

        return copy


class SideEffect(object):
    def __init__(self, owner):
        self.__owner = owner
        self.__active = False
        self.__effect = None

    @property
    def active(self):
        return self.__active

    @active.setter
    def active(self, active):
        if not isinstance(active, bool):
            raise TypeError("Expecting a bool, not a " + type(active))

        if active != self.__active:
            if active:
                self.__owner._Booster__activeSideEffectIDs.append(self.effect.ID)
            else:
                self.__owner._Booster__activeSideEffectIDs.remove(self.effect.ID)

            self.__active = active

    @property
    def effect(self):
        return self.__effect

    @effect.setter
    def effect(self, effect):
        if not hasattr(effect, "handler"):
            raise TypeError("Need an effect with a handler")

        self.__effect = effect

########NEW FILE########
__FILENAME__ = cargo
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from eos.modifiedAttributeDict import ModifiedAttributeDict, ItemAttrShortcut, ChargeAttrShortcut
from eos.effectHandlerHelpers import HandledItem, HandledCharge
from sqlalchemy.orm import validates, reconstructor

# Cargo class copied from Implant class and hacked to make work. \o/
# @todo: clean me up, Scotty
class Cargo(HandledItem, HandledCharge, ItemAttrShortcut, ChargeAttrShortcut):

    def __init__(self, item):
        self.__item = item
        self.itemID = item.ID
        self.active = True
        self.amount = 0
        self.__itemModifiedAttributes = ModifiedAttributeDict()
        self.__itemModifiedAttributes.original = self.item.attributes

    @reconstructor
    def init(self):
        self.__item = None

    def __fetchItemInfo(self):
        import eos.db
        self.__item = eos.db.getItem(self.itemID)
        self.__itemModifiedAttributes = ModifiedAttributeDict()
        self.__itemModifiedAttributes.original = self.__item.attributes

    @property
    def itemModifiedAttributes(self):
        if self.__item is None:
            self.__fetchItemInfo()

        return self.__itemModifiedAttributes

    @property
    def item(self):
        if self.__item is None:
            self.__fetchItemInfo()

        return self.__item

    def clear(self):
        self.itemModifiedAttributes.clear()

    @validates("fitID", "itemID", "active")
    def validator(self, key, val):
        map = {"fitID": lambda val: isinstance(val, int),
               "itemID" : lambda val: isinstance(val, int),
               "active": lambda val: isinstance(val, bool)}

        if map[key](val) == False: raise ValueError(str(val) + " is not a valid value for " + key)
        else: return val

    def __deepcopy__(self, memo):
        copy = Cargo(self.item)
        copy.active = self.active
        return copy
########NEW FILE########
__FILENAME__ = character
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================


import urllib2

from eos.effectHandlerHelpers import HandledItem
from sqlalchemy.orm import validates, reconstructor
import sqlalchemy.orm.exc as exc
from eos import eveapi
import eos

class Character(object):
    __all5 = None
    __all0 = None
    __itemList = None
    __itemIDMap = None
    __itemNameMap = None

    @classmethod
    def getSkillList(cls):
        if cls.__itemList is None:
            import eos.db
            cls.__itemList = eos.db.getItemsByCategory("Skill")

        return cls.__itemList

    @classmethod
    def setSkillList(cls, list):
        cls.__itemList = list

    @classmethod
    def getSkillIDMap(cls):
        if cls.__itemIDMap is None:
            map = {}
            for skill in cls.getSkillList():
                map[skill.ID] = skill

            cls.__itemIDMap = map

        return cls.__itemIDMap

    @classmethod
    def getSkillNameMap(cls):
        if cls.__itemNameMap is None:
            map = {}
            for skill in cls.getSkillList():
                map[skill.name] = skill

            cls.__itemNameMap = map

        return cls.__itemNameMap

    @classmethod
    def getAll5(cls):
        if cls.__all5 is None:
            import eos.db
            all5 = eos.db.getCharacter("All 5")
            if all5 is None:
                all5 = Character("All 5")
                all5.defaultLevel = 5
                eos.db.add(all5)

            cls.__all5 = all5
        return cls.__all5

    @classmethod
    def getAll0(cls):
        if cls.__all0 is None:
            import eos.db
            all0 = eos.db.getCharacter("All 0")
            if all0 is None:
                all0 = Character("All 0")
                eos.db.add(all0)

            cls.__all0 = all0
        return cls.__all0

    def __init__(self, name):
        self.name = name
        self.__owner = None
        self.defaultLevel = None
        self.__skills = []
        self.__skillIdMap = {}
        self.__implants = eos.saveddata.fit.HandledImplantBoosterList()
        self.apiKey = None

    @reconstructor
    def init(self):
        self.__skillIdMap = {}
        for skill in self.__skills:
            self.__skillIdMap[skill.itemID] = skill

    def apiCharList(self, proxy=None):
        api = eveapi.EVEAPIConnection(proxy=proxy)
        auth = api.auth(keyID=self.apiID, vCode=self.apiKey)
        apiResult = auth.account.Characters()
        return map(lambda c: unicode(c.name), apiResult.characters)

    def apiFetch(self, charName, proxy=None):
        api = eveapi.EVEAPIConnection(proxy=proxy)
        auth = api.auth(keyID=self.apiID, vCode=self.apiKey)
        apiResult = auth.account.Characters()
        charID = None
        for char in apiResult.characters:
            if char.name == charName:
                charID = char.characterID

        if charID == None:
            return

        sheet = auth.character(charID).CharacterSheet()
        self.apiUpdateCharSheet(sheet)

    def apiUpdateCharSheet(self, sheet):
        del self.__skills[:]
        self.__skillIdMap.clear()
        for skillRow in sheet.skills:
            self.addSkill(Skill(skillRow["typeID"], skillRow["level"]))

    @property
    def owner(self):
        return self.__owner

    @owner.setter
    def owner(self, owner):
        self.__owner = owner

    def addSkill(self, skill):
        self.__skills.append(skill)
        self.__skillIdMap[skill.itemID] = skill

    def removeSkill(self, skill):
        self.__skills.remove(skill)
        del self.__skillIdMap[skill.itemID]

    def getSkill(self, item):
        if isinstance(item, basestring):
            item = self.getSkillNameMap()[item]
        elif isinstance(item, int):
            item = self.getSkillIDMap()[item]

        skill = self.__skillIdMap.get(item.ID)

        if skill is None:
            if self.defaultLevel is None:
                skill = Skill(item, 0, False, False)
            else:
                skill = Skill(item, self.defaultLevel, False, True)

            self.addSkill(skill)

        return skill

    @property
    def implants(self):
        return self.__implants

    def iterSkills(self):
        if self.defaultLevel is not None:
            return self.iterDefaultLevel()
        else:
            return self.__skills.__iter__()

    def iterDefaultLevel(self):
        for item in self.getSkillList():
            yield self.getSkill(item)

    def filteredSkillIncrease(self, filter, *args, **kwargs):
        for element in self.iterSkills():
            if filter(element):
                element.increaseItemAttr(*args, **kwargs)

    def filteredSkillMultiply(self, filter, *args, **kwargs):
        for element in self.iterSkills():
            if filter(element):
                element.multiplyItemAttr(*args, **kwargs)

    def filteredSkillBoost(self, filter, *args, **kwargs):
        for element in self.iterSkills():
            if filter(element):
                element.boostItemAttr(*args, **kwargs)

    def calculateModifiedAttributes(self, fit, runTime, forceProjected = False):
        if forceProjected: return
        for skill in self.iterSkills():
            fit.register(skill)
            skill.calculateModifiedAttributes(fit, runTime)

    def clear(self):
        for skill in self.iterSkills():
            skill.clear()

    def __deepcopy__(self, memo):
        copy = Character("%s copy" % self.name)
        copy.apiKey = self.apiKey
        copy.apiID = self.apiID
        for skill in self.iterSkills():
            copy.addSkill(Skill(skill.itemID, skill.level, False, skill.learned))

        return copy

    @validates("ID", "name", "apiKey", "ownerID")
    def validator(self, key, val):
        map = {"ID": lambda val: isinstance(val, int),
               "name" : lambda val: True,
               "apiKey" : lambda val: val is None or (isinstance(val, basestring) and len(val) > 0),
               "ownerID" : lambda val: isinstance(val, int)}

        if map[key](val) == False: raise ValueError(str(val) + " is not a valid value for " + key)
        else: return val

class Skill(HandledItem):
    def __init__(self, item, level = 0, ro = False, learned = True):
        self.__item = item if not isinstance(item, int) else None
        self.itemID = item.ID if not isinstance(item, int) else item
        self.__level = level if learned else None
        self.commandBonus = 0
        self.learned = learned
        self.build(ro)

    @reconstructor
    def init(self):
        self.build(False)
        self.learned = self.__level is not None
        self.__item = None

    def build(self, ro):
        self.__ro = ro
        self.__suppressed = False

    @property
    def level(self):
        if not self.learned: return 0
        else: return self.__level or 0

    @level.setter
    def level(self, level):
        if (level < 0 or level > 5) and level is not None:
            raise ValueError(str(level) + " is not a valid value for level")

        if hasattr(self, "_Skill__ro") and self.__ro == True:
            raise ReadOnlyException()

        self.__level = level
        self.learned = True

    @property
    def item(self):
        if self.__item is None:
            self.__item = item = Character.getSkillIDMap().get(self.itemID)
            if item is None:
                #This skill is no longer in the database and thus invalid it, get rid of it.
                self.character.removeSkill(self)

        return self.__item

    def getModifiedItemAttr(self, key):
        return self.item.attributes[key].value

    def calculateModifiedAttributes(self, fit, runTime):
        if self.__suppressed or not self.learned: return
        item = self.item
        if item is None:
            return

        for effect in item.effects.itervalues():
                if effect.runTime == runTime and effect.isType("passive"):
                    try:
                        effect.handler(fit, self, ("skill",))
                    except AttributeError:
                        continue

    def clear(self):
        self.__suppressed = False
        self.commandBonus = 0

    def suppress(self):
        self.__suppressed = True

    def isSuppressed(self):
        return self.__suppressed

    @validates("characterID", "skillID", "level")
    def validator(self, key, val):
        if hasattr(self, "_Skill__ro") and self.__ro == True and key != "characterID":
            raise ReadOnlyException()

        map = {"characterID": lambda val: isinstance(val, int),
               "skillID" : lambda val: isinstance(val, int)}

        if map[key](val) == False: raise ValueError(str(val) + " is not a valid value for " + key)
        else: return val

    def __deepcopy__(self, memo):
        copy = Skill(self.item, self.level, self.__ro)
        return copy

class ReadOnlyException(Exception):
    pass

########NEW FILE########
__FILENAME__ = damagePattern
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import re

class DamagePattern(object):
    DAMAGE_TYPES = ("em", "thermal", "kinetic", "explosive")

    def __init__(self, emAmount = 25, thermalAmount = 25, kineticAmount = 25, explosiveAmount = 25):
        self.emAmount = emAmount
        self.thermalAmount = thermalAmount
        self.kineticAmount = kineticAmount
        self.explosiveAmount = explosiveAmount

    def calculateEhp(self, fit):
        ehp = {}
        for (type, attr) in (('shield', 'shieldCapacity'), ('armor', 'armorHP'), ('hull', 'hp')):
            rawCapacity = fit.ship.getModifiedItemAttr(attr)
            ehp[type] = self.effectivify(fit, rawCapacity, type)

        return ehp

    def calculateEffectiveTank(self, fit, tankInfo):
        ehps = {}
        passiveShield = fit.calculateShieldRecharge()
        ehps["passiveShield"] = self.effectivify(fit, passiveShield, "shield")
        for type in ("shield", "armor", "hull"):
            ehps["%sRepair" % type] = self.effectivify(fit, tankInfo["%sRepair" % type], type)

        return ehps

    def effectivify(self, fit, amount, type):
        type = type if type != "hull" else ""
        totalDamage = sum((self.emAmount, self.thermalAmount, self.kineticAmount, self.explosiveAmount))
        specificDivider = 0
        for damageType in self.DAMAGE_TYPES:
            #Compose an attribute name, then make sure the first letter is NOT capitalized
            attrName = "%s%sDamageResonance" % (type, damageType.capitalize())
            attrName = attrName[0].lower() + attrName[1:]

            resonance = fit.ship.getModifiedItemAttr(attrName)
            damage = getattr(self, "%sAmount" % damageType)

            specificDivider += damage / float(totalDamage or 1) * resonance

        return amount / (specificDivider or 1)

    importMap = {"em": "em",
                 "therm": "thermal",
                 "kin": "kinetic",
                 "exp": "explosive"}
    @classmethod
    def importPatterns(cls, text):
        lines = re.split('[\n\r]+', text)
        patterns = []
        for line in lines:
            line = line.split('#',1)[0] # allows for comments
            name, data = line.rsplit('=',1)
            name, data = name.strip(), ''.join(data.split()) # whitespace

            fields = {}
            for entry in data.split(','):
                key, val = entry.split(':')
                fields["%sAmount" % cls.importMap[key.lower()]] = float(val)

            pattern = DamagePattern(**fields)
            pattern.name = name
            patterns.append(pattern)

        return patterns

    EXPORT_FORMAT = "%s = EM:%d, Therm:%d, Kin:%d, Exp:%d\n"
    @classmethod
    def exportPatterns(cls, *patterns):
        out = ""
        for dp in patterns:
            out += cls.EXPORT_FORMAT % (dp.name, dp.emAmount, dp.thermalAmount, dp.kineticAmount, dp.explosiveAmount)

        return out.strip()

    def __deepcopy__(self, memo):
        p = DamagePattern(self.emAmount, self.thermalAmount, self.kineticAmount, self.explosiveAmount)
        p.name = "%s copy" % self.name
        return p

########NEW FILE########
__FILENAME__ = drone
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from eos.modifiedAttributeDict import ModifiedAttributeDict, ItemAttrShortcut, ChargeAttrShortcut
from eos.effectHandlerHelpers import HandledItem, HandledCharge
from sqlalchemy.orm import validates, reconstructor

class Drone(HandledItem, HandledCharge, ItemAttrShortcut, ChargeAttrShortcut):
    DAMAGE_ATTRIBUTES = ("emDamage", "kineticDamage", "explosiveDamage", "thermalDamage")

    def __init__(self, item):
        if item.category.name != "Drone":
            raise ValueError("Passed item is not a drone")

        self.__item = item
        self.__charge = None
        self.itemID = item.ID
        self.amount = 0
        self.amountActive = 0
        self.__dps = None
        self.projected = False
        self.__itemModifiedAttributes = ModifiedAttributeDict()
        self.itemModifiedAttributes.original = self.item.attributes

    @reconstructor
    def init(self):
        self.__dps = None
        self.__item = None
        self.__charge = None

    def __fetchItemInfo(self):
        import eos.db
        self.__item = eos.db.getItem(self.itemID)
        self.__charge = None
        self.__itemModifiedAttributes = ModifiedAttributeDict()
        self.__itemModifiedAttributes.original = self.item.attributes

    def __fetchChargeInfo(self):
        chargeID = self.getModifiedItemAttr("entityMissileTypeID")
        self.__chargeModifiedAttributes = ModifiedAttributeDict()
        if chargeID is not None:
            import eos.db
            charge = eos.db.getItem(int(chargeID))
            self.__charge = charge

            self.chargeModifiedAttributes.original = charge.attributes
        else:
            self.__charge = 0

    @property
    def itemModifiedAttributes(self):
        if self.__item is None:
            self.__fetchItemInfo()

        return self.__itemModifiedAttributes

    @property
    def chargeModifiedAttributes(self):
        if self.__charge is None:
            self.__fetchChargeInfo()

        return self.__chargeModifiedAttributes

    @property
    def item(self):
        if self.__item is None:
            self.__fetchItemInfo()

        return self.__item

    @property
    def charge(self):
        if self.__charge is None:
            self.__fetchChargeInfo()

        return self.__charge if self.__charge != 0 else None

    @property
    def dealsDamage(self):
        for attr in ("emDamage", "kineticDamage", "explosiveDamage", "thermalDamage"):
            if attr in self.itemModifiedAttributes or attr in self.chargeModifiedAttributes:
                return True

    @property
    def hasAmmo(self):
        return self.charge is not None

    @property
    def dps(self):
        if self.__dps == None:
            if self.dealsDamage is True and self.amountActive > 0:
                if self.hasAmmo:
                    attr = "missileLaunchDuration"
                    getter = self.getModifiedChargeAttr
                else:
                    attr =  "speed"
                    getter = self.getModifiedItemAttr

                cycleTime = self.getModifiedItemAttr(attr)
                volley = sum(map(lambda d: getter(d), self.DAMAGE_ATTRIBUTES)) * self.amountActive
                volley *= self.getModifiedItemAttr("damageMultiplier") or 1
                self.__dps = volley / (cycleTime / 1000.0)
            else:
                self.__dps = 0

        return self.__dps

    @property
    def maxRange(self):
        attrs = ("shieldTransferRange", "powerTransferRange",
                 "energyDestabilizationRange", "empFieldRange",
                 "ecmBurstRange", "maxRange")
        for attr in attrs:
            maxRange = self.getModifiedItemAttr(attr)
            if maxRange is not None: return maxRange
        if self.charge is not None:
            delay = self.getModifiedChargeAttr("explosionDelay")
            speed = self.getModifiedChargeAttr("maxVelocity")
            if delay is not None and speed is not None:
                return delay / 1000.0 * speed

    # Had to add this to match the falloff property in modules.py
    # Fscking ship scanners. If you find any other falloff attributes,
    # Put them in the attrs tuple.
    @property
    def falloff(self):
        attrs = ("falloff",)
        for attr in attrs:
            falloff = self.getModifiedItemAttr(attr)
            if falloff is not None: return falloff

    @validates("ID", "itemID", "chargeID", "amount", "amountActive")
    def validator(self, key, val):
        map = {"ID": lambda val: isinstance(val, int),
               "itemID" : lambda val: isinstance(val, int),
               "chargeID" : lambda val: isinstance(val, int),
               "amount" : lambda val: isinstance(val, int) and val >= 0,
               "amountActive" : lambda val: isinstance(val, int) and val <= self.amount and val >= 0}

        if map[key](val) == False: raise ValueError(str(val) + " is not a valid value for " + key)
        else: return val

    def clear(self):
        self.__dps = None
        self.itemModifiedAttributes.clear()
        self.chargeModifiedAttributes.clear()

    def canBeApplied(self, projectedOnto):
        """Check if drone can engage specific fitting"""
        item = self.item
        # Do not allow to apply offensive modules on ship with offensive module immunite, with few exceptions
        # (all effects which apply instant modification are exception, generally speaking)
        if item.offensive and projectedOnto.ship.getModifiedItemAttr("disallowOffensiveModifiers") == 1:
            offensiveNonModifiers = set(("energyDestabilizationNew", "leech"))
            if not offensiveNonModifiers.intersection(set(item.effects)):
                return False
        # If assistive modules are not allowed, do not let to apply these altogether
        if item.assistive and projectedOnto.ship.getModifiedItemAttr("disallowAssistance") == 1:
            return False
        else:
            return True

    def calculateModifiedAttributes(self, fit, runTime, forceProjected = False):
        if self.projected or forceProjected:
            context = "projected", "drone"
            projected = True
        else:
            context = ("drone",)
            projected = False

        for effect in self.item.effects.itervalues():
            if effect.runTime == runTime and \
            ((projected == True and effect.isType("projected")) or \
             projected == False and effect.isType("passive")):
                i = 0
                while i != self.amountActive:
                    effect.handler(fit, self, context)
                    i += 1

        if self.charge:
            for effect in self.charge.effects.itervalues():
                if effect.runTime == runTime:
                    effect.handler(fit, self, ("droneCharge",))

    def __deepcopy__(self, memo):
        copy = Drone(self.item)
        copy.amount = self.amount
        copy.amountActive = self.amountActive
        return copy

    def fits(self, fit):
        fitDroneGroupLimits = set()
        for i in xrange(1, 3):
            groneGrp = fit.ship.getModifiedItemAttr("allowedDroneGroup%d" % i)
            if groneGrp is not None:
                fitDroneGroupLimits.add(int(groneGrp))
        if len(fitDroneGroupLimits) == 0:
            return True
        if self.item.groupID in fitDroneGroupLimits:
            return True
        return False

########NEW FILE########
__FILENAME__ = fit
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from eos.effectHandlerHelpers import HandledList, HandledModuleList, HandledDroneList, HandledImplantBoosterList, \
HandledProjectedFitList, HandledProjectedModList, HandledProjectedDroneList, HandledCargoList
from eos.modifiedAttributeDict import ModifiedAttributeDict
from sqlalchemy.orm import validates, reconstructor
from itertools import chain
from eos import capSim
from copy import deepcopy
from math import sqrt, log, asinh
from eos.types import Drone, Cargo, Ship, Character, State, Slot, Module, Implant, Booster, Skill
from eos.saveddata.module import State
import re
import xml.dom
import time

try:
    from collections import OrderedDict
except ImportError:
    from gui.utils.compat import OrderedDict

class Fit(object):
    """Represents a fitting, with modules, ship, implants, etc."""
    EXTRA_ATTRIBUTES = {"armorRepair": 0,
                        "hullRepair": 0,
                        "shieldRepair": 0,
                        "maxActiveDrones": 0,
                        "maxTargetsLockedFromSkills": 2,
                        "droneControlRange": 20000,
                        "cloaked": False,
                        "siege": False}

    PEAK_RECHARGE = 0.25

    def __init__(self):
        self.__modules = HandledModuleList()
        self.__drones = HandledDroneList()
        self.__cargo = HandledCargoList()
        self.__implants = HandledImplantBoosterList()
        self.__boosters = HandledImplantBoosterList()
        self.__projectedFits = HandledProjectedFitList()
        self.__projectedModules = HandledProjectedModList()
        self.__projectedDrones = HandledProjectedDroneList()
        self.__character = None
        self.__owner = None
        self.shipID = None
        self.projected = False
        self.name = ""
        self.fleet = None
        self.boostsFits = set()
        self.gangBoosts = None
        self.timestamp = time.time()
        self.build()

    @classmethod
    def importAuto(cls, string, sourceFileName=None, activeFit=None):
        # Get first line and strip space symbols of it
        # to avoid possible detection errors
        firstLine = re.split("[\n\r]+", string.strip(), maxsplit=1)[0]
        firstLine = firstLine.strip()

        # If string is from in-game copy of fitting window
        # We match " power" instead of "High power" in case a fit has no high modules
        if " power" in firstLine and activeFit is not None:
            return "FIT", (cls.importFittingWindow(string, activeFit),)
        # If we have "<url=fitting", fit is coming from eve chat
        # Gather data and send to DNA
        chatDna = re.search("<url=fitting:(.*::)>.*</url>", firstLine)
        if chatDna:
            return "DNA", (cls.importDna(chatDna.group(1)),)
        # If we have a CREST kill link
        killLink = re.search("http://public-crest.eveonline.com/killmails/(.*)/", firstLine)
        if killLink:
            return "CREST", (cls.importCrest(tuple(killLink.group(1).split("/"))),)
        # If we have "<url=killReport", fit is killmail from eve chat
        killReport = re.search("<url=killReport:(.*)>.*</url>", firstLine)
        if killReport:
            return "CREST", (cls.importCrest(tuple(killReport.group(1).split(":"))),)
        # If XML-style start of tag encountered, detect as XML
        if re.match("<", firstLine):
            return "XML", cls.importXml(string)
        # If we've got source file name which is used to describe ship name
        # and first line contains something like [setup name], detect as eft config file
        elif re.match("\[.*\]", firstLine) and sourceFileName is not None:
            shipName = sourceFileName.rsplit('.')[0]
            return "EFT Config", cls.importEftCfg(shipName, string)
        # If no file is specified and there's comma between brackets,
        # consider that we have [ship, setup name] and detect like eft export format
        elif re.match("\[.*,.*\]", firstLine):
            return "EFT", (cls.importEft(string),)
        # Use DNA format for all other cases
        else:
            return "DNA", (cls.importDna(string),)

    @classmethod
    def importFittingWindow(cls, string, activeFit):
        from eos import db
        activeFit = db.getFit(activeFit)

        # if the current fit has mods, do not mess with it. Instead, make new fit
        if activeFit.modCount > 0:
            fit = Fit()
            fit.ship = Ship(db.getItem(activeFit.ship.item.ID))
            fit.name = "%s (copy)"%activeFit.name
        else:
            fit = activeFit
        lines = re.split('[\n\r]+', string)

        droneMap = {}
        cargoMap = {}
        modules = []

        for i in range(1, len(lines)):
            line = lines[i].strip()
            if not line:
                continue

            try:
                amount, modName = line.split("x ")
                amount = int(amount)
                item = db.getItem(modName, eager="group.category")
            except:
                # if no data can be found (old names)
                continue

            if item.category.name == "Drone":
                if not modName in droneMap:
                    droneMap[modName] = 0
                droneMap[modName] += amount
            elif item.category.name == "Charge":
                if not modName in cargoMap:
                    cargoMap[modName] = 0
                cargoMap[modName] += amount
            else:
                for i in xrange(amount):
                    try:
                        m = Module(item)
                    except ValueError:
                        continue
                    # If we are importing T3 ship, we must apply subsystems first, then
                    # calcModAttr() to get the ship slots
                    if m.slot == Slot.SUBSYSTEM and m.fits(fit):
                        fit.modules.append(m)
                    else:
                        modules.append(m)

        fit.clear()
        fit.calculateModifiedAttributes()

        for m in modules:
            # we check to see if module fits as a basic sanity check
            # if it doesn't then the imported fit is most likely invalid
            # (ie: user tried to import Legion fit to a Rifter)
            if m.fits(fit):
                fit.modules.append(m)
                if m.isValidState(State.ACTIVE):
                    m.state = State.ACTIVE
                m.owner = fit #not sure why this is required when it's not for other import methods, but whatever
            else:
                return

        for droneName in droneMap:
            d = Drone(db.getItem(droneName))
            d.amount = droneMap[droneName]
            fit.drones.append(d)

        for cargoName in cargoMap:
            c = Cargo(db.getItem(cargoName))
            c.amount = cargoMap[cargoName]
            fit.cargo.append(c)

        return fit

    @classmethod
    def importCrest(cls, info):
        from eos import db
        import urllib2
        import json

        try:
            response = urllib2.urlopen("https://public-crest.eveonline.com/killmails/%s/%s/" % info)
        except:
            return

        kill = (json.loads(response.read()))['victim']

        fit = Fit()
        fit.ship = Ship(db.getItem(kill['shipType']['name']))
        fit.name = "CREST: %s's %s" % (kill['character']['name'], kill['shipType']['name'])

        # sort based on flag to get proper rack position
        items  = sorted(kill['items'], key=lambda k: k['flag'])

        # We create a relation between module flag and module position on fit at time of append:
        # this allows us to know which module to apply charges to if need be (see below)
        flagMap = {}

        # Charges may show up before or after the module. We process modules first,
        # storing any charges that are fitted in a dict and noting their flag (module).
        charges = {}

        for mod in items:
            if mod['flag'] == 5: # throw out cargo
                continue

            item = db.getItem(mod['itemType']['name'], eager="group.category")

            if item.category.name == "Drone":
                d = Drone(item)
                d.amount = mod['quantityDropped'] if 'quantityDropped' in mod else mod['quantityDestroyed']
                fit.drones.append(d)
            elif item.category.name == "Charge":
                charges[mod['flag']] = item
            else:
                m = Module(item)
                if m.isValidState(State.ACTIVE):
                    m.state = State.ACTIVE
                fit.modules.append(m)
                flagMap[mod['flag']] = fit.modules.index(m)

        for flag, item in charges.items():
            # we do not need to verify valid charge as it comes directly from CCP
            fit.modules[flagMap[flag]].charge = item

        return fit

    @classmethod
    def importDna(cls, string):
        from eos import db
        info = string.split(":")
        f = Fit()
        f.ship = Ship(db.getItem(int(info[0])))
        f.name = "{0} - DNA Imported".format(f.ship.item.name)
        for itemInfo in info[1:]:
            if itemInfo:
                itemID, amount = itemInfo.split(";")
                item = db.getItem(int(itemID), eager="group.category")

                if item.category.name == "Drone":
                    d = Drone(item)
                    d.amount = int(amount)
                    f.drones.append(d)
                elif item.category.name == "Charge":
                    c = Cargo(item)
                    c.amount = int(amount)
                    f.cargo.append(c)
                else:
                    for i in xrange(int(amount)):
                        try:
                            m = Module(item)
                            f.modules.append(m)
                        except:
                            pass
                        if m.isValidState(State.ACTIVE):
                            m.state = State.ACTIVE

        return f

    @classmethod
    def importEft(cls, eftString):
        from eos import db
        offineSuffix = " /OFFLINE"

        fit = cls()
        eftString = eftString.strip()
        lines = re.split('[\n\r]+', eftString)
        info = lines[0][1:-1].split(",", 1)

        if len(info) == 2:
            shipType = info[0].strip()
            fitName = info[1].strip()
        else:
            shipType = info[0].strip()
            fitName = "Imported %s" % shipType

        try:
            fit.ship = Ship(db.getItem(shipType))
            fit.name = fitName
        except:
            return

        # maintain map of drones and their quantities
        droneMap = {}
        cargoMap = {}
        for i in range(1, len(lines)):
            ammoName = None
            extraAmount = None

            line = lines[i].strip()
            if not line:
                continue

            setOffline = line.endswith(offineSuffix)
            if setOffline == True:
                # remove offline suffix from line
                line = line[:len(line) - len(offineSuffix)]

            modAmmo = line.split(",")
            # matches drone and cargo with x{qty}
            modExtra = modAmmo[0].split(" x")

            if len(modAmmo) == 2:
                # line with a module and ammo
                ammoName = modAmmo[1].strip()
                modName = modAmmo[0].strip()
            elif len(modExtra) == 2:
                # line with drone/cargo and qty
                extraAmount = modExtra[1].strip()
                modName = modExtra[0].strip()
            else:
                # line with just module
                modName = modExtra[0].strip()

            try:
                # get item information. If we are on a Drone/Cargo line, throw out cargo
                item = db.getItem(modName, eager="group.category")
            except:
                # if no data can be found (old names)
                continue

            if item.category.name == "Drone":
                extraAmount = int(extraAmount) if extraAmount is not None else 1
                if not modName in droneMap:
                    droneMap[modName] = 0
                droneMap[modName] += extraAmount
            if len(modExtra) == 2 and item.category.name != "Drone":
                extraAmount = int(extraAmount) if extraAmount is not None else 1
                if not modName in cargoMap:
                    cargoMap[modName] = 0
                cargoMap[modName] += extraAmount
            elif item.category.name == "Implant":
                fit.implants.append(Implant(item))
            else:
                try:
                    m = Module(item)
                except ValueError:
                    continue
                if ammoName:
                    try:
                        ammo = db.getItem(ammoName)
                        if m.isValidCharge(ammo) and m.charge is None:
                            m.charge = ammo
                    except:
                        pass

                if setOffline == True and m.isValidState(State.OFFLINE):
                    m.state = State.OFFLINE
                elif m.isValidState(State.ACTIVE):
                    m.state = State.ACTIVE

                fit.modules.append(m)

        for droneName in droneMap:
            d = Drone(db.getItem(droneName))
            d.amount = droneMap[droneName]
            fit.drones.append(d)

        for cargoName in cargoMap:
            c = Cargo(db.getItem(cargoName))
            c.amount = cargoMap[cargoName]
            fit.cargo.append(c)

        return fit

    @classmethod
    def importEftCfg(cls, shipname, contents):
        """Handle import from EFT config store file"""
        # Check if we have such ship in database, bail if we don't
        from eos import db
        try:
            db.getItem(shipname)
        except:
            return
        # If client didn't take care of encoding file contents into Unicode,
        # do it using fallback encoding ourselves
        if isinstance(contents, str):
            contents = unicode(contents, "cp1252")
        # List for fits
        fits = []
        # List for starting line numbers for each fit
        fitIndices = []
        # Separate string into lines
        lines = re.split('[\n\r]+', contents)
        for line in lines:
            # Detect fit header
            if line[:1] == "[" and line[-1:] == "]":
                # Line index where current fit starts
                startPos = lines.index(line)
                fitIndices.append(startPos)

        for i, startPos in enumerate(fitIndices):
            # End position is last file line if we're trying to get it for last fit,
            # or start position of next fit minus 1
            endPos = len(lines) if i == len(fitIndices) - 1 else fitIndices[i + 1]
            # Finally, get lines for current fitting
            fitLines = lines[startPos:endPos]
            try:
                # Create fit object
                f = Fit()
                # Strip square brackets and pull out a fit name
                f.name = fitLines[0][1:-1]
                # Assign ship to fitting
                f.ship = Ship(db.getItem(shipname))

                for i in range(1, len(fitLines)):
                    line = fitLines[i]
                    if not line:
                        continue
                    # Parse line into some data we will need
                    misc = re.match("(Drones|Implant|Booster)_(Active|Inactive)=(.+)",line)
                    cargo = re.match("Cargohold=(.+)",line)
                    if misc:
                        entityType = misc.group(1)
                        entityState = misc.group(2)
                        entityData = misc.group(3)
                        if entityType == "Drones":
                            droneData = re.match("(.+),([0-9]+)", entityData)
                            # Get drone name and attempt to detect drone number
                            droneName = droneData.group(1) if droneData else entityData
                            droneAmount = int(droneData.group(2)) if droneData else 1
                            # Bail if we can't get item or it's not from drone category
                            try:
                                droneItem = db.getItem(droneName, eager="group.category")
                            except:
                                continue
                            if droneItem.category.name != "Drone":
                                continue
                            # Add drone to the fitting
                            d = Drone(droneItem)
                            d.amount = droneAmount
                            if entityState == "Active":
                                d.amountActive = droneAmount
                            elif entityState == "Inactive":
                                d.amountActive = 0
                            f.drones.append(d)
                        elif entityType == "Implant":
                            # Bail if we can't get item or it's not from implant category
                            try:
                                implantItem = db.getItem(entityData, eager="group.category")
                            except:
                                continue
                            if implantItem.category.name != "Implant":
                                continue
                            # Add implant to the fitting
                            imp = Implant(implantItem)
                            if entityState == "Active":
                                imp.active = True
                            elif entityState == "Inactive":
                                imp.active = False
                            f.implants.append(imp)
                        elif entityType == "Booster":
                            # Bail if we can't get item or it's not from implant category
                            try:
                                boosterItem = db.getItem(entityData, eager="group.category")
                            except:
                                continue
                            # All boosters have implant category
                            if boosterItem.category.name != "Implant":
                                continue
                            # Add booster to the fitting
                            b = Booster(boosterItem)
                            if entityState == "Active":
                                b.active = True
                            elif entityState == "Inactive":
                                b.active = False
                            f.boosters.append(b)
                    # If we don't have any prefixes, then it's a module
                    elif cargo:
                        cargoData = re.match("(.+),([0-9]+)", cargo.group(1))
                        cargoName = cargoData.group(1) if cargoData else cargo.group(1)
                        cargoAmount = int(cargoData.group(2)) if cargoData else 1
                        # Bail if we can't get item
                        try:
                            item = db.getItem(cargoName)
                        except:
                            continue
                        # Add Cargo to the fitting
                        c = Cargo(item)
                        c.amount = cargoAmount
                        f.cargo.append(c)
                    else:
                        withCharge = re.match("(.+),(.+)", line)
                        modName = withCharge.group(1) if withCharge else line
                        chargeName = withCharge.group(2) if withCharge else None
                        # If we can't get module item, skip it
                        try:
                            modItem = db.getItem(modName)
                        except:
                            continue

                        # Create module and activate it if it's activable
                        m = Module(modItem)
                        if m.isValidState(State.ACTIVE):
                            m.state = State.ACTIVE
                        # Add charge to mod if applicable, on any errors just don't add anything
                        if chargeName:
                            try:
                                chargeItem = db.getItem(chargeName, eager="group.category")
                                if chargeItem.category.name == "Charge":
                                    m.charge = chargeItem
                            except:
                                pass
                        # Append module to fit
                        f.modules.append(m)
                # Append fit to list of fits
                fits.append(f)
            # Skip fit silently if we get an exception
            except Exception:
                pass

        return fits

    @classmethod
    def importXml(cls, text):
        doc = xml.dom.minidom.parseString(text.encode("utf-8"))
        fittings = doc.getElementsByTagName("fittings").item(0)
        fittings = fittings.getElementsByTagName("fitting")
        fits = []
        from eos import db
        for fitting in fittings:
            f = Fit()
            f.name = fitting.getAttribute("name")
            # <localized hint="Maelstrom">Maelstrom</localized>
            shipType = fitting.getElementsByTagName("shipType").item(0).getAttribute("value")
            try:
                f.ship = Ship(db.getItem(shipType))
            except:
                continue
            hardwares = fitting.getElementsByTagName("hardware")
            for hardware in hardwares:
                try:
                    moduleName = hardware.getAttribute("type")
                    try:
                        item = db.getItem(moduleName, eager="group.category")
                    except:
                        continue
                    if item:
                        if item.category.name == "Drone":
                            d = Drone(item)
                            d.amount = int(hardware.getAttribute("qty"))
                            f.drones.append(d)
                        elif hardware.getAttribute("slot").lower() == "cargo":
                            # although the eve client only support charges in cargo, third-party programs
                            # may support items or "refits" in cargo. Support these by blindly adding all
                            # cargo, not just charges
                            c = Cargo(item)
                            c.amount = int(hardware.getAttribute("qty"))
                            f.cargo.append(c)
                        else:
                            try:
                                m = Module(item)
                            # When item can't be added to any slot (unknown item or just charge), ignore it
                            except ValueError:
                                continue
                            if m.isValidState(State.ACTIVE):
                                m.state = State.ACTIVE

                            f.modules.append(m)
                except KeyboardInterrupt:
                    continue
            fits.append(f)

        return fits

    EXPORT_ORDER_EFT = [Slot.LOW, Slot.MED, Slot.HIGH, Slot.RIG, Slot.SUBSYSTEM]
    def exportEft(self):
        offineSuffix = " /OFFLINE"
        export = "[%s, %s]\n" % (self.ship.item.name, self.name)
        stuff = {}
        for module in self.modules:
            slot = module.slot
            if not slot in stuff: stuff[slot] = []
            curr = module.item.name if module.item else ("[Empty %s slot]" % Slot.getName(slot).capitalize() if slot is not None else "")
            if module.charge:
                curr += ", %s" % module.charge.name
            if module.state == State.OFFLINE:
                curr += offineSuffix
            curr += "\n"
            stuff[slot].append(curr)

        for slotType in self.EXPORT_ORDER_EFT:
            data = stuff.get(slotType)
            if data is not None:
                export += "\n"
                for curr in data:
                    export += curr

        if len(self.drones) > 0:
            export += "\n\n"
            for drone in self.drones:
                export += "%s x%s\n" % (drone.item.name, drone.amount)
        if len(self.cargo) > 0:
            for cargo in self.cargo:
                export += "%s x%s\n" % (cargo.item.name, cargo.amount)

        if export[-1] == "\n":
            export = export[:-1]

        return export

    def exportEftImps(self):
        export = self.exportEft()
        if len(self.implants) > 0:
            export += "\n\n\n"
            for implant in self.implants:
                export += "%s\n" % (implant.item.name)

        if export[-1] == "\n":
            export = export[:-1]

        return export

    def exportDna(self):
        dna = str(self.shipID)
        mods = OrderedDict()
        charges = OrderedDict()
        for mod in self.modules:
            if not mod.isEmpty:
                if not mod.itemID in mods:
                    mods[mod.itemID] = 0
                mods[mod.itemID] += 1

                if mod.charge:
                    if not mod.chargeID in charges:
                        charges[mod.chargeID] = 0
                    # `or 1` because some charges (ie scripts) are without qty
                    charges[mod.chargeID] += mod.numShots or 1

        for mod in mods:
            dna += ":{0};{1}".format(mod, mods[mod])

        for drone in self.drones:
            dna += ":{0};{1}".format(drone.itemID, drone.amount)

        for cargo in self.cargo:
            # DNA format is a simple/dumb format. As CCP uses the slot information of the item itself
            # without designating slots in the DNA standard, we need to make sure we only include
            # charges in the DNA export. If modules were included, the EVE Client will interpret these
            # as being "Fitted" to whatever slot they are for, and it causes an corruption error in the
            # client when trying to save the fit
            if cargo.item.category.name == "Charge":
                if not cargo.item.ID in charges:
                    charges[cargo.item.ID] = 0
                charges[cargo.item.ID] += cargo.amount

        for charge in charges:
            dna += ":{0};{1}".format(charge, charges[charge])

        return dna + "::"

    @classmethod
    def exportXml(cls, *fits):
        doc = xml.dom.minidom.Document()
        fittings = doc.createElement("fittings")
        doc.appendChild(fittings)
        for fit in fits:
            fitting = doc.createElement("fitting")
            fitting.setAttribute("name", fit.name)
            fittings.appendChild(fitting)
            description = doc.createElement("description")
            description.setAttribute("value", "")
            fitting.appendChild(description)
            shipType = doc.createElement("shipType")
            shipType.setAttribute("value", fit.ship.item.name)
            fitting.appendChild(shipType)

            charges = {}
            slotNum = {}
            for module in fit.modules:
                if module.isEmpty:
                    continue

                slot = module.slot
                if not slot in slotNum: slotNum[slot] = 0
                slotId = slotNum[slot]
                slotNum[slot] += 1
                hardware = doc.createElement("hardware")
                hardware.setAttribute("type", module.item.name)
                slotName = Slot.getName(slot).lower()
                slotName = slotName if slotName != "high" else "hi"
                hardware.setAttribute("slot", "%s slot %d" % (slotName, slotId))
                fitting.appendChild(hardware)

                if module.charge:
                    if not module.charge.name in charges:
                        charges[module.charge.name] = 0
                    # `or 1` because some charges (ie scripts) are without qty
                    charges[module.charge.name] += module.numShots or 1

            for drone in fit.drones:
                hardware = doc.createElement("hardware")
                hardware.setAttribute("qty", "%d" % drone.amount)
                hardware.setAttribute("slot", "drone bay")
                hardware.setAttribute("type", drone.item.name)
                fitting.appendChild(hardware)

            for cargo in fit.cargo:
                if not cargo.item.name in charges:
                    charges[cargo.item.name] = 0
                charges[cargo.item.name] += cargo.amount

            for name, qty in charges.items():
                hardware = doc.createElement("hardware")
                hardware.setAttribute("qty", "%d" % qty)
                hardware.setAttribute("slot", "cargo")
                hardware.setAttribute("type", name)
                fitting.appendChild(hardware)

        return doc.toprettyxml()

    @reconstructor
    def init(self):
        self.build()

    def build(self):
        from eos import db
        self.__extraDrains = []
        self.__ehp = None
        self.__weaponDPS = None
        self.__weaponVolley = None
        self.__droneDPS = None
        self.__sustainableTank = None
        self.__effectiveSustainableTank = None
        self.__effectiveTank = None
        self.__calculated = False
        self.__capStable = None
        self.__capState = None
        self.__capUsed = None
        self.__capRecharge = None
        self.__calculatedTargets = []
        self.factorReload = False
        self.fleet = None
        self.boostsFits = set()
        self.gangBoosts = None
        self.extraAttributes = ModifiedAttributeDict(self)
        self.extraAttributes.original = self.EXTRA_ATTRIBUTES
        self.ship = Ship(db.getItem(self.shipID)) if self.shipID is not None else None

    @property
    def damagePattern(self):
        return self.__damagePattern

    @damagePattern.setter
    def damagePattern(self, damagePattern):
        self.__damagePattern = damagePattern
        self.__ehp = None
        self.__effectiveTank = None

    @property
    def character(self):
        return self.__character if self.__character is not None else Character.getAll0()

    @character.setter
    def character(self, char):
        self.__character = char

    @property
    def ship(self):
        return self.__ship

    @ship.setter
    def ship(self, ship):
        self.__ship = ship
        self.shipID = ship.item.ID if ship is not None else None

    @property
    def drones(self):
        return self.__drones

    @property
    def cargo(self):
        return self.__cargo

    @property
    def modules(self):
        return self.__modules

    @property
    def implants(self):
        return self.__implants

    @property
    def boosters(self):
        return self.__boosters

    @property
    def projectedModules(self):
        return self.__projectedModules

    @property
    def projectedFits(self):
        return self.__projectedFits

    @property
    def projectedDrones(self):
        return self.__projectedDrones

    @property
    def weaponDPS(self):
        if self.__weaponDPS is None:
            self.calculateWeaponStats()

        return self.__weaponDPS

    @property
    def weaponVolley(self):
        if self.__weaponVolley is None:
            self.calculateWeaponStats()

        return self.__weaponVolley

    @property
    def droneDPS(self):
        if self.__droneDPS is None:
            self.calculateWeaponStats()

        return self.__droneDPS

    @property
    def totalDPS(self):
        return self.droneDPS + self.weaponDPS

    @property
    def maxTargets(self):
        return min(self.extraAttributes["maxTargetsLockedFromSkills"], self.ship.getModifiedItemAttr("maxLockedTargets"))

    @property
    def maxTargetRange(self):
        return min(self.ship.getModifiedItemAttr("maxTargetRange"), 250000)

    @property
    def scanStrength(self):
        return max([self.ship.getModifiedItemAttr("scan%sStrength" % scanType)
                    for scanType in ("Magnetometric", "Ladar", "Radar", "Gravimetric")])

    @property
    def scanType(self):
        maxStr = -1
        type = None
        for scanType in ("Magnetometric", "Ladar", "Radar", "Gravimetric"):
            currStr = self.ship.getModifiedItemAttr("scan%sStrength" % scanType)
            if currStr > maxStr:
                maxStr = currStr
                type = scanType
            elif currStr == maxStr:
                type = "Multispectral"

        return type

    @property
    def alignTime(self):
        agility = self.ship.getModifiedItemAttr("agility")
        mass = self.ship.getModifiedItemAttr("mass")

        return -log(0.25) * agility * mass / 1000000

    @property
    def appliedImplants(self):
        implantsBySlot = {}
        if self.character:
            for implant in self.character.implants:
                implantsBySlot[implant.slot] = implant

        for implant in self.implants:
            implantsBySlot[implant.slot] = implant

        return implantsBySlot.values()

    @validates("ID", "ownerID", "shipID")
    def validator(self, key, val):
        map = {"ID": lambda val: isinstance(val, int),
               "ownerID" : lambda val: isinstance(val, int),
               "shipID" : lambda val: isinstance(val, int) or val is None}

        if map[key](val) == False: raise ValueError(str(val) + " is not a valid value for " + key)
        else: return val

    def clear(self):
        self.__effectiveTank = None
        self.__weaponDPS = None
        self.__weaponVolley = None
        self.__effectiveSustainableTank = None
        self.__sustainableTank = None
        self.__droneDPS = None
        self.__ehp = None
        self.__calculated = False
        self.__capStable = None
        self.__capState = None
        self.__capUsed = None
        self.__capRecharge = None
        del self.__calculatedTargets[:]
        del self.__extraDrains[:]

        if self.ship is not None: self.ship.clear()
        c = chain(self.modules, self.drones, self.boosters, self.implants, self.projectedDrones, self.projectedModules, self.projectedFits, (self.character, self.extraAttributes))
        for stuff in c:
            if stuff is not None and stuff != self: stuff.clear()

    #Methods to register and get the thing currently affecting the fit,
    #so we can correctly map "Affected By"
    def register(self, currModifier):
        self.__modifier = currModifier
        if hasattr(currModifier, "itemModifiedAttributes"):
            currModifier.itemModifiedAttributes.fit = self
        if hasattr(currModifier, "chargeModifiedAttributes"):
            currModifier.chargeModifiedAttributes.fit = self

    def getModifier(self):
        return self.__modifier

    def calculateModifiedAttributes(self, targetFit=None, withBoosters=False, dirtyStorage=None):
        refreshBoosts = False
        if withBoosters is True:
            refreshBoosts = True
        if dirtyStorage is not None and self.ID in dirtyStorage:
            refreshBoosts = True
        if dirtyStorage is not None:
            dirtyStorage.update(self.boostsFits)
        if self.fleet is not None and refreshBoosts is True:
            self.gangBoosts = self.fleet.recalculateLinear(withBoosters=withBoosters, dirtyStorage=dirtyStorage)
        elif self.fleet is None:
            self.gangBoosts = None
        if dirtyStorage is not None:
            try:
                dirtyStorage.remove(self.ID)
            except KeyError:
                pass
        # If we're not explicitly asked to project fit onto something,
        # set self as target fit
        if targetFit is None:
            targetFit = self
            forceProjected = False
        # Else, we're checking all target projectee fits
        elif targetFit not in self.__calculatedTargets:
            self.__calculatedTargets.append(targetFit)
            targetFit.calculateModifiedAttributes(dirtyStorage=dirtyStorage)
            forceProjected = True
        # Or do nothing if target fit is calculated
        else:
            return

        # If fit is calculated and we have nothing to do here, get out
        if self.__calculated == True and forceProjected == False:
            return

        # Mark fit as calculated
        self.__calculated = True

        # There's a few things to keep in mind here
        # 1: Early effects first, then regular ones, then late ones, regardless of anything else
        # 2: Some effects aren't implemented
        # 3: Some effects are implemented poorly and will just explode on us
        # 4: Errors should be handled gracefully and preferably without crashing unless serious
        for runTime in ("early", "normal", "late"):
            # Build a little chain of stuff
            # Avoid adding projected drones and modules when fit is projected onto self
            # TODO: remove this workaround when proper self-projection using virtual duplicate fits is implemented
            if forceProjected is True:
                c = chain((self.character, self.ship), self.drones, self.boosters, self.appliedImplants, self.modules)
            else:
                c = chain((self.character, self.ship), self.drones, self.boosters, self.appliedImplants, self.modules,
                          self.projectedDrones, self.projectedModules)

            for item in c:
                # Registering the item about to affect the fit allows us to track "Affected By" relations correctly
                if item is not None:
                    self.register(item)
                    item.calculateModifiedAttributes(self, runTime, False)
                    if forceProjected is True:
                        targetFit.register(item)
                        item.calculateModifiedAttributes(targetFit, runTime, True)
            if self.gangBoosts is not None:
                #print self.gangBoosts
                contextMap = {Skill: "skill",
                              Ship: "ship",
                              Module: "module",
                              Implant: "implant"}
                for name, info in self.gangBoosts.iteritems():
                    # Unpack all data required to run effect properly
                    effect, thing = info[1]
                    if effect.runTime == runTime:
                        context = ("gang", contextMap[type(thing)])
                        if isinstance(thing, Module):
                            if effect.isType("offline") or (effect.isType("passive") and thing.state >= State.ONLINE) or \
                            (effect.isType("active") and thing.state >= State.ACTIVE):
                                # Run effect, and get proper bonuses applied
                                try:
                                    effect.handler(targetFit, thing, context)
                                except:
                                    pass
                        else:
                            # Run effect, and get proper bonuses applied
                            try:
                                effect.handler(targetFit, thing, context)
                            except:
                                pass
        for fit in self.projectedFits:
            fit.calculateModifiedAttributes(self, dirtyStorage=dirtyStorage)

    def fill(self):
        """
        Fill this fit's module slots with enough dummy slots so that all slots are used.
        This is mostly for making the life of gui's easier.
        GUI's can call fill() and then stop caring about empty slots completely.
        """
        if self.ship is None:
            return

        for slotType in (Slot.LOW, Slot.MED, Slot.HIGH, Slot.RIG, Slot.SUBSYSTEM):
            amount = self.getSlotsFree(slotType, True)
            if amount > 0:
                for _ in xrange(int(amount)):
                    self.modules.append(Module.buildEmpty(slotType))

            if amount < 0:
                #Look for any dummies of that type to remove
                toRemove = []
                for mod in self.modules:
                    if mod.isEmpty and mod.slot == slotType:
                        toRemove.append(mod)
                        amount += 1
                        if amount == 0:
                            break
                for mod in toRemove:
                    self.modules.remove(mod)

    def unfill(self):
        for i in xrange(len(self.modules) - 1, -1, -1):
            mod = self.modules[i]
            if mod.isEmpty:
                del self.modules[i]

    @property
    def modCount(self):
        x=0
        for i in xrange(len(self.modules) - 1, -1, -1):
            mod = self.modules[i]
            if not mod.isEmpty:
                x += 1
        return x

    def getItemAttrSum(self, dict, attr):
        amount = 0
        for mod in dict:
            add = mod.getModifiedItemAttr(attr)
            if add is not None:
                amount += add

        return amount

    def getItemAttrOnlineSum(self, dict, attr):
        amount = 0
        for mod in dict:
            add = mod.getModifiedItemAttr(attr) if mod.state >= State.ONLINE else None
            if add is not None:
                amount += add

        return amount

    def getHardpointsUsed(self, type):
        amount = 0
        for mod in self.modules:
            if mod.hardpoint is type and not mod.isEmpty:
                amount += 1

        return amount

    def getSlotsUsed(self, type, countDummies=False):
        amount = 0
        for mod in self.modules:
            if mod.slot is type and (not mod.isEmpty or countDummies):
                amount += 1

        return amount

    def getSlotsFree(self, type, countDummies=False):
        slots = {Slot.LOW: "lowSlots",
                 Slot.MED: "medSlots",
                 Slot.HIGH: "hiSlots",
                 Slot.RIG: "rigSlots",
                 Slot.SUBSYSTEM: "maxSubSystems"}

        slotsUsed = self.getSlotsUsed(type, countDummies)
        totalSlots = self.ship.getModifiedItemAttr(slots[type]) or 0
        return int(totalSlots - slotsUsed)

    @property
    def calibrationUsed(self):
        return self.getItemAttrSum(self.modules, 'upgradeCost')

    @property
    def pgUsed(self):
        return self.getItemAttrOnlineSum(self.modules, "power")

    @property
    def cpuUsed(self):
        return self.getItemAttrOnlineSum(self.modules, "cpu")

    @property
    def droneBandwidthUsed(self):
        amount = 0
        for d in self.drones:
            amount += d.getModifiedItemAttr("droneBandwidthUsed") * d.amountActive

        return amount

    @property
    def droneBayUsed(self):
        amount = 0
        for d in self.drones:
            amount += d.item.volume * d.amount

        return amount

    @property
    def cargoBayUsed(self):
        amount = 0
        for c in self.cargo:
            amount += c.getModifiedItemAttr("volume") * c.amount

        return amount

    @property
    def activeDrones(self):
        amount = 0
        for d in self.drones:
            amount +=d.amountActive

        return amount

    # Expresses how difficult a target is to probe down with scan probes
    # If this is <1.08, the ship is unproabeable
    @property
    def probeSize(self):
        sigRad = self.ship.getModifiedItemAttr("signatureRadius")
        sensorStr = float(self.scanStrength)
        probeSize = sigRad / sensorStr if sensorStr != 0 else None
        # http://www.eveonline.com/ingameboard.asp?a=topic&threadID=1532170&page=2#42
        if probeSize is not None:
            # http://forum.eve-ru.com/index.php?showtopic=74195&view=findpost&p=1333691
            # http://forum.eve-ru.com/index.php?showtopic=74195&view=findpost&p=1333763
            # Tests by tester128 and several conclusions by me, prove that cap is in range
            # from 1.1 to 1.12, we're picking average value
            probeSize = max(probeSize, 1.11)
        return probeSize

    @property
    def warpSpeed(self):
        base = self.ship.getModifiedItemAttr("baseWarpSpeed") or 1
        multiplier = self.ship.getModifiedItemAttr("warpSpeedMultiplier") or 1
        return base * multiplier

    @property
    def maxWarpDistance(self):
        capacity = self.ship.getModifiedItemAttr("capacitorCapacity")
        mass = self.ship.getModifiedItemAttr("mass")
        warpCapNeed = self.ship.getModifiedItemAttr("warpCapacitorNeed")
        return capacity / (mass * warpCapNeed)

    @property
    def capStable(self):
        if self.__capStable is None:
            self.simulateCap()

        return self.__capStable

    @property
    def capState(self):
        """
        If the cap is stable, the capacitor state is the % at which it is stable.
        If the cap is unstable, this is the amount of time before it runs out
        """
        if self.__capState is None:
            self.simulateCap()

        return self.__capState

    @property
    def capUsed(self):
        if self.__capUsed is None:
            self.simulateCap()

        return self.__capUsed

    @property
    def capRecharge(self):
        if self.__capRecharge is None:
            self.simulateCap()

        return self.__capRecharge


    @property
    def sustainableTank(self):
        if self.__sustainableTank is None:
            self.calculateSustainableTank()

        return self.__sustainableTank

    def calculateSustainableTank(self, effective=True):
        if self.__sustainableTank is None:
            if self.capStable:
                sustainable = {}
                sustainable["armorRepair"] = self.extraAttributes["armorRepair"]
                sustainable["shieldRepair"] = self.extraAttributes["shieldRepair"]
                sustainable["hullRepair"] = self.extraAttributes["hullRepair"]
            else:
                sustainable = {}

                repairers = []
                #Map a repairer type to the attribute it uses
                groupAttrMap = {"Armor Repair Unit": "armorDamageAmount",
                     "Fueled Armor Repairer": "armorDamageAmount",
                     "Hull Repair Unit": "structureDamageAmount",
                     "Shield Booster": "shieldBonus",
                     "Fueled Shield Booster": "shieldBonus",
                     "Remote Armor Repairer": "armorDamageAmount",
                     "Remote Shield Booster": "shieldBonus"}
                #Map repairer type to attribute
                groupStoreMap = {"Armor Repair Unit": "armorRepair",
                                 "Hull Repair Unit": "hullRepair",
                                 "Shield Booster": "shieldRepair",
                                 "Fueled Shield Booster": "shieldRepair",
                                 "Remote Armor Repairer": "armorRepair",
                                 "Remote Shield Booster": "shieldRepair",
                                 "Fueled Armor Repairer": "armorRepair",}

                capUsed = self.capUsed
                for attr in ("shieldRepair", "armorRepair", "hullRepair"):
                    sustainable[attr] = self.extraAttributes[attr]
                    dict = self.extraAttributes.getAfflictions(attr)
                    if self in dict:
                        for mod, _, amount in dict[self]:
                            if mod.projected is False:
                                usesCap = True
                                try:
                                    if mod.capUse:
                                        capUsed -= mod.capUse
                                    else:
                                        usesCap = False
                                except AttributeError:
                                    usesCap = False
                                # Modules which do not use cap are not penalized based on cap use
                                if usesCap:
                                    cycleTime = mod.getModifiedItemAttr("duration")
                                    amount = mod.getModifiedItemAttr(groupAttrMap[mod.item.group.name])
                                    sustainable[attr] -= amount / (cycleTime / 1000.0)
                                    repairers.append(mod)


                #Sort repairers by efficiency. We want to use the most efficient repairers first
                repairers.sort(key=lambda mod: mod.getModifiedItemAttr(groupAttrMap[mod.item.group.name]) / mod.getModifiedItemAttr("capacitorNeed"), reverse = True)

                #Loop through every module until we're above peak recharge
                #Most efficient first, as we sorted earlier.
                #calculate how much the repper can rep stability & add to total
                totalPeakRecharge = self.capRecharge
                for mod in repairers:
                    if capUsed > totalPeakRecharge: break
                    cycleTime = mod.cycleTime
                    capPerSec = mod.capUse
                    if capPerSec is not None and cycleTime is not None:
                        #Check how much this repper can work
                        sustainability = min(1, (totalPeakRecharge - capUsed) / capPerSec)

                        #Add the sustainable amount
                        amount = mod.getModifiedItemAttr(groupAttrMap[mod.item.group.name])
                        sustainable[groupStoreMap[mod.item.group.name]] += sustainability * (amount / (cycleTime / 1000.0))
                        capUsed += capPerSec

            sustainable["passiveShield"] = self.calculateShieldRecharge()
            self.__sustainableTank = sustainable

        return self.__sustainableTank

    def calculateCapRecharge(self, percent = PEAK_RECHARGE):
        capacity = self.ship.getModifiedItemAttr("capacitorCapacity")
        rechargeRate = self.ship.getModifiedItemAttr("rechargeRate") / 1000.0
        return 10 / rechargeRate * sqrt(percent) * (1 - sqrt(percent)) * capacity

    def calculateShieldRecharge(self, percent = PEAK_RECHARGE):
        capacity = self.ship.getModifiedItemAttr("shieldCapacity")
        rechargeRate = self.ship.getModifiedItemAttr("shieldRechargeRate") / 1000.0
        return 10 / rechargeRate * sqrt(percent) * (1 - sqrt(percent)) * capacity

    def addDrain(self, cycleTime, capNeed, clipSize=0):
        self.__extraDrains.append((cycleTime, capNeed, clipSize))

    def removeDrain(self, i):
        del self.__extraDrains[i]

    def iterDrains(self):
        return self.__extraDrains.__iter__()

    def __generateDrain(self):
        drains = []
        capUsed = 0
        capAdded = 0
        for mod in self.modules:
            if mod.state >= State.ACTIVE:
                    cycleTime = mod.rawCycleTime or 0
                    reactivationTime = mod.getModifiedItemAttr("moduleReactivationDelay") or 0
                    fullCycleTime = cycleTime + reactivationTime
                    if fullCycleTime > 0:
                        capNeed = mod.capUse
                        if capNeed > 0:
                            capUsed += capNeed
                        else:
                            capAdded -= capNeed

                        drains.append((int(fullCycleTime), mod.getModifiedItemAttr("capacitorNeed") or 0, mod.numShots or 0))

        for fullCycleTime, capNeed, clipSize in self.iterDrains():
            drains.append((int(fullCycleTime), capNeed, clipSize))
            if capNeed > 0:
                capUsed += capNeed / (fullCycleTime / 1000.0)
            else:
                capAdded += -capNeed / (fullCycleTime / 1000.0)

        return drains, capUsed, capAdded

    def simulateCap(self):
        drains, self.__capUsed, self.__capRecharge = self.__generateDrain()
        self.__capRecharge += self.calculateCapRecharge()
        if len(drains) > 0:
            sim = capSim.CapSimulator()
            sim.init(drains)
            sim.capacitorCapacity = self.ship.getModifiedItemAttr("capacitorCapacity")
            sim.capacitorRecharge = self.ship.getModifiedItemAttr("rechargeRate")
            sim.stagger = True
            sim.scale = False
            sim.t_max = 6 * 60 * 60 * 1000
            sim.reload = self.factorReload
            sim.run()

            capState = (sim.cap_stable_low + sim.cap_stable_high) / (2 * sim.capacitorCapacity)
            self.__capStable = capState > 0
            self.__capState = min(100, capState * 100) if self.__capStable else sim.t / 1000.0
        else:
            self.__capStable = True
            self.__capState = 100

    @property
    def hp(self):
        hp = {}
        for (type, attr) in (('shield', 'shieldCapacity'), ('armor', 'armorHP'), ('hull', 'hp')):
            hp[type] = self.ship.getModifiedItemAttr(attr)

        return hp

    @property
    def ehp(self):
        if self.__ehp is None:
            if self.damagePattern is None:
                ehp = self.hp
            else:
                ehp = self.damagePattern.calculateEhp(self)
            self.__ehp = ehp

        return self.__ehp

    @property
    def tank(self):
        hps = {"passiveShield" : self.calculateShieldRecharge()}
        for type in ("shield", "armor", "hull"):
            hps["%sRepair" % type] = self.extraAttributes["%sRepair" % type]

        return hps

    @property
    def effectiveTank(self):
        if self.__effectiveTank is None:
            if self.damagePattern is None:
                ehps = self.tank
            else:
                ehps = self.damagePattern.calculateEffectiveTank(self, self.extraAttributes)

            self.__effectiveTank = ehps

        return self.__effectiveTank

    @property
    def effectiveSustainableTank(self):
        if self.__effectiveSustainableTank is None:
            if self.damagePattern is None:
                eshps = self.sustainableTank
            else:
                eshps = self.damagePattern.calculateEffectiveTank(self, self.sustainableTank)

            self.__effectiveSustainableTank = eshps

        return self.__effectiveSustainableTank


    def calculateLockTime(self, radius):
        scanRes = self.ship.getModifiedItemAttr("scanResolution")
        if scanRes is not None and scanRes > 0:
            # Yes, this function returns time in seconds, not miliseconds.
            # 40,000 is indeed the correct constant here.
            return min(40000 / scanRes / asinh(radius)**2, 30*60)
        else:
            return self.ship.getModifiedItemAttr("scanSpeed") / 1000.0

    def calculateWeaponStats(self):
        weaponDPS = 0
        droneDPS = 0
        weaponVolley = 0

        for mod in self.modules:
            dps, volley = mod.damageStats
            weaponDPS += dps
            weaponVolley += volley

        for drone in self.drones:
            droneDPS += drone.dps

        self.__weaponDPS = weaponDPS
        self.__weaponVolley = weaponVolley
        self.__droneDPS = droneDPS

    @property
    def fits(self):
        for mod in self.modules:
            if not mod.fits(self):
                return False

        return True

    def __deepcopy__(self, memo):
        copy = Fit()
        #Character and owner are not copied
        copy.character = self.__character
        copy.owner = self.owner
        copy.ship = deepcopy(self.ship, memo)
        copy.name = "%s copy" % self.name
        copy.damagePattern = self.damagePattern

        toCopy = ("modules", "drones", "implants", "boosters", "projectedModules", "projectedDrones")
        for name in toCopy:
            orig = getattr(self, name)
            c = getattr(copy, name)
            for i in orig:
                c.append(deepcopy(i, memo))

        for fit in self.projectedFits:
            copy.projectedFits.append(fit)

        return copy

########NEW FILE########
__FILENAME__ = fleet
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from itertools import chain
from eos.types import Skill, Module, Ship
from copy import deepcopy

class Fleet(object):
    def calculateModifiedAttributes(self):
        #Make sure ALL fits in the gang have been calculated
        for c in chain(self.wings, (self.leader,)):
            if c is not None: c.calculateModifiedAttributes()

        leader = self.leader
        self.booster = booster = self.booster if self.booster is not None else leader
        self.broken = False
        self.store = store = Store()
        store.set(booster, "fleet")
        #Go all the way down for each subtree we have.
        for wing in self.wings:
            wing.calculateGangBonusses(store)

        # Check skill requirements and wing amount to see if we break or not
        if len(self.wings) == 0 or leader is None or leader.character is None or leader.character.getSkill("Fleet Command").level < len(self.wings):
            self.broken = True

        #Now calculate our own if we aren't broken
        if self.broken == False:
            #We only get our own bonuses *Sadface*
            store.apply(leader, "fleet")

    def recalculateLinear(self, withBoosters=True, dirtyStorage=None):
        self.store = Store()
        self.linearBoosts = {}
        if withBoosters is True:
            if self.leader is not None and self.leader.character is not None and self.leader.character.getSkill("Fleet Command").level >= 1:
                self.leader.boostsFits.add(self.wings[0].squads[0].members[0].ID)
                self.leader.calculateModifiedAttributes()
                self.store.set(self.leader, "squad", clearingUpdate=True)
            else:
                self.store = Store()
                if self.leader is not None:
                    try:
                        self.leader.boostsFits.remove(self.wings[0].squads[0].members[0].ID)
                    except KeyError:
                        pass
        self.wings[0].recalculateLinear(self.store, withBoosters=withBoosters, dirtyStorage=dirtyStorage)
        return self.linearBoosts

    def count(self):
        total = 0
        for wing in self.wings:
            total += wing.count()

        return total

    def extend(self):
        self.wings.append(Wing())

    def __deepcopy__(self, memo):
        copy = Fleet()
        copy.name = self.name
        copy.booster = deepcopy(self.booster)
        copy.leader = deepcopy(self.leader)
        for wing in self.wings:
            copy.wings.append(deepcopy(wing))

        return copy

class Wing(object):
    def calculateModifiedAttributes(self):
        for c in chain(self.squads, (self.leader,)):
            if c is not None: c.calculateModifiedAttributes()

    def calculateGangBonusses(self, store):
        self.broken = False
        leader = self.leader
        self.booster = booster = self.booster if self.booster is not None else leader

        store.set(booster, "wing")

        #ALWAYS move down
        for squad in self.squads:
            squad.calculateGangBonusses(store)

        # Check skill requirements and squad amount to see if we break or not
        if len(self.squads) == 0 or leader is None or leader.character is None or leader.character.getSkill("Wing Command").level < len(self.squads):
            self.broken = True

        #Check if we aren't broken, if we aren't, boost
        if self.broken == False:
            store.apply(leader, "wing")
        else:
            #We broke, don't go up
            self.gang.broken = True

    def recalculateLinear(self, store, withBoosters=True, dirtyStorage=None):
        if withBoosters is True:
            if self.leader is not None and self.leader.character is not None and self.leader.character.getSkill("Wing Command").level >= 1:
                self.leader.boostsFits.add(self.squads[0].members[0].ID)
                self.leader.calculateModifiedAttributes()
                store.set(self.leader, "squad", clearingUpdate=False)
            else:
                store = Store()
                if self.gang.leader is not None:
                    try:
                        self.gang.leader.boostsFits.remove(self.squads[0].members[0].ID)
                    except KeyError:
                        pass
                if self.leader is not None:
                    try:
                        self.leader.boostsFits.remove(self.squads[0].members[0].ID)
                    except KeyError:
                        pass
        self.squads[0].recalculateLinear(store, withBoosters=withBoosters, dirtyStorage=dirtyStorage)

    def count(self):
        total = 0 if self.leader is None else 1
        for squad in self.squads:
            total += squad.count()

        return total

    def extend(self):
        self.squads.append(Squad())

    def __deepcopy__(self, memo):
        copy = Wing()
        copy.booster = deepcopy(self.booster)
        copy.leader = deepcopy(self.leader)
        for squad in self.squads:
            copy.squads.append(deepcopy(squad))

        return copy


class Squad(object):
    def calculateModifiedAttributes(self):
        for member in self.members:
            member.calculateModifiedAttributes()

    def calculateGangBonusses(self, store):
        self.broken = False
        leader = self.leader
        self.booster = booster = self.booster if self.booster is not None else leader
        store.set(booster, "squad")

        # Check skill requirements and squad size to see if we break or not
        if len(self.members) <= 0 or leader is None or leader.character is None or leader.character.getSkill("Leadership").level * 2 < len(self.members):
            self.broken = True

        if self.broken == False:
            for member in self.members:
                store.apply(member, "squad")
        else:
            self.wing.broken = True

    def recalculateLinear(self, store, withBoosters=True, dirtyStorage=None):
        if withBoosters is True:
            if self.leader is not None and self.leader.character is not None and self.leader.character.getSkill("Leadership").level >= 1:
                self.leader.boostsFits.add(self.members[0].ID)
                self.leader.calculateModifiedAttributes(dirtyStorage=dirtyStorage)
                store.set(self.leader, "squad", clearingUpdate=False)
            else:
                store = Store()
                if self.leader is not None:
                    try:
                        self.leader.boostsFits.remove(self.members[0].ID)
                    except KeyError:
                        pass
                if self.wing.leader is not None:
                    try:
                        self.wing.leader.boostsFits.remove(self.members[0].ID)
                    except KeyError:
                        pass
                if self.wing.gang.leader is not None:
                    try:
                        self.wing.gang.leader.boostsFits.remove(self.members[0].ID)
                    except KeyError:
                        pass
        if getattr(self.wing.gang, "linearBoosts", None) is None:
            self.wing.gang.linearBoosts = {}
        dict = store.bonuses["squad"]
        for boostedAttr, boostInfoList in dict.iteritems():
            for boostInfo in boostInfoList:
                effect, thing = boostInfo
                # Get current boost value for given attribute, use 0 as fallback if
                # no boosts applied yet
                currBoostAmount = self.wing.gang.linearBoosts.get(boostedAttr, (0,))[0]
                # Attribute name which is used to get boost value
                newBoostAttr = effect.getattr("gangBonus") or "commandBonus"
                # Get boost amount for current boost
                newBoostAmount = thing.getModifiedItemAttr(newBoostAttr) or 0
                # If skill takes part in gang boosting, multiply by skill level
                if type(thing) == Skill:
                    newBoostAmount *= thing.level
                # If new boost is more powerful, replace older one with it
                if abs(newBoostAmount) > abs(currBoostAmount):
                    self.wing.gang.linearBoosts[boostedAttr] = (newBoostAmount, boostInfo)

    def count(self):
        return len(self.members)

    def __deepcopy__(self, memo):
        copy = Squad()
        copy.booster = deepcopy(self.booster)
        copy.leader = deepcopy(self.leader)
        for member in self.members:
            copy.members.append(deepcopy(member))

        return copy

class Store(object):
    def __init__(self):
        # Container for gang boosters and their respective bonuses, three-layered
        self.bonuses = {}
        for dictType in ("fleet", "wing", "squad"):
            self.bonuses[dictType] = {}
        # Container for boosted fits and corresponding boosts applied onto them
        self.boosts = {}

    def set(self, fitBooster, layer, clearingUpdate=True):
        """Add all gang boosts of given fit for given layer to boost store"""
        if fitBooster is None:
            return

        # This dict contains all bonuses for specified layer
        dict = self.bonuses[layer]
        if clearingUpdate is True:
            # Clear existing bonuses
            dict.clear()

        # Go through everything which can be used as gang booster
        for thing in chain(fitBooster.modules, fitBooster.implants, fitBooster.character.iterSkills(), (fitBooster.ship,)):
            if thing.item is None:
                continue
            for effect in thing.item.effects.itervalues():
                # And check if it actually has gang boosting effects
                if effect.isType("gang"):
                    # Attribute which is boosted
                    boostedAttr = effect.getattr("gangBoost")
                    # List which contains all bonuses for given attribute for given layer
                    l = dict.get(boostedAttr)
                    # If there was no list, create it
                    if l is None:
                        l = dict[boostedAttr] = []
                    # And append effect which is used to boost stuff and carrier of this effect
                    l.append((effect, thing))

    contextMap = {Skill: "skill",
                  Ship: "ship",
                  Module: "module"}

    def apply(self, fitBoosted, layer):
        """Applies all boosts onto given fit for given layer"""
        if fitBoosted is None:
            return
        # Boosts dict contains all bonuses applied onto given fit
        self.boosts[fitBoosted] = boosts = {}
        # Go through all bonuses for given layer, and find highest one per boosted attribute
        for currLayer in ("fleet", "wing", "squad"):
            # Dictionary with boosts for given layer
            dict = self.bonuses[currLayer]
            for boostedAttr, boostInfoList in dict.iteritems():
                for boostInfo in boostInfoList:
                    effect, thing = boostInfo
                    # Get current boost value for given attribute, use 0 as fallback if
                    # no boosts applied yet
                    currBoostAmount = boosts.get(boostedAttr, (0,))[0]
                    # Attribute name which is used to get boost value
                    newBoostAttr = effect.getattr("gangBonus") or "commandBonus"
                    # Get boost amount for current boost
                    newBoostAmount = thing.getModifiedItemAttr(newBoostAttr) or 0
                    # If skill takes part in gang boosting, multiply by skill level
                    if type(thing) == Skill:
                        newBoostAmount *= thing.level
                    # If new boost is more powerful, replace older one with it
                    if abs(newBoostAmount) > abs(currBoostAmount):
                        boosts[boostedAttr] = (newBoostAmount, boostInfo)

            # Don't look further down then current layer, wing commanders don't get squad bonuses and all that
            if layer == currLayer:
                break

        self.modify(fitBoosted)

    def getBoosts(self, fit):
        """Return all boosts applied onto given fit"""
        return self.boosts.get(fit)

    def modify(self, fitBoosted):
        # Get all boosts which should be applied onto current fit
        boosts = self.getBoosts(fitBoosted)
        # Now we got it all figured out, actually do the useful part of all this
        for name, info in boosts.iteritems():
            # Unpack all data required to run effect properly
            effect, thing = info[1]
            context = ("gang", self.contextMap[type(thing)])
            # Run effect, and get proper bonuses applied
            try:
                effect.handler(fitBoosted, thing, context)
            except:
                pass

########NEW FILE########
__FILENAME__ = implant
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from eos.modifiedAttributeDict import ModifiedAttributeDict, ItemAttrShortcut
from eos.effectHandlerHelpers import HandledItem
from sqlalchemy.orm import validates, reconstructor

class Implant(HandledItem, ItemAttrShortcut):
    def __init__(self, item):
        self.__slot = self.__calculateSlot(item)
        self.__item = item
        self.itemID = item.ID
        self.active = True
        self.__itemModifiedAttributes = ModifiedAttributeDict()
        self.__itemModifiedAttributes.original = self.item.attributes

    @reconstructor
    def init(self):
        self.__item = None

    def __fetchItemInfo(self):
        import eos.db
        self.__item = eos.db.getItem(self.itemID)
        self.__itemModifiedAttributes = ModifiedAttributeDict()
        self.__itemModifiedAttributes.original = self.__item.attributes
        self.__slot = self.__calculateSlot(self.__item)

    @property
    def itemModifiedAttributes(self):
        if self.__item is None:
            self.__fetchItemInfo()

        return self.__itemModifiedAttributes

    @property
    def slot(self):
        if self.__item is None:
            self.__fetchItemInfo()

        return self.__slot

    @property
    def item(self):
        if self.__item is None:
            self.__fetchItemInfo()

        return self.__item

    def __calculateSlot(self, item):
        if not "implantness" in item.attributes:
            raise ValueError("Passed item is not an implant")

        return int(item.attributes["implantness"].value)

    def clear(self):
        self.itemModifiedAttributes.clear()

    def calculateModifiedAttributes(self, fit, runTime, forceProjected = False):
        if forceProjected: return
        if self.active == False: return
        for effect in self.item.effects.itervalues():
            if effect.runTime == runTime and effect.isType("passive"):
                effect.handler(fit, self, ("implant",))

    @validates("fitID", "itemID", "active")
    def validator(self, key, val):
        map = {"fitID": lambda val: isinstance(val, int),
               "itemID" : lambda val: isinstance(val, int),
               "active": lambda val: isinstance(val, bool)}

        if map[key](val) == False: raise ValueError(str(val) + " is not a valid value for " + key)
        else: return val

    def __deepcopy__(self, memo):
        copy = Implant(self.item)
        copy.active = self.active
        return copy

########NEW FILE########
__FILENAME__ = miscData
#===============================================================================
# Copyright (C) 2011 Anton Vorobyov
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from eos.eqBase import EqBase

class MiscData(EqBase):
    def __init__(self, name, val=None):
        self.fieldName = name
        self.fieldValue = val

########NEW FILE########
__FILENAME__ = module
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from sqlalchemy.orm import validates, reconstructor

from eos.modifiedAttributeDict import ModifiedAttributeDict, ItemAttrShortcut, ChargeAttrShortcut
from eos.effectHandlerHelpers import HandledItem, HandledCharge
from eos.enum import Enum
from eos.mathUtils import floorFloat

class State(Enum):
    OFFLINE = -1
    ONLINE = 0
    ACTIVE = 1
    OVERHEATED = 2

class Slot(Enum):
    LOW = 1
    MED = 2
    HIGH = 3
    RIG = 4
    SUBSYSTEM = 5

class Hardpoint(Enum):
    NONE = 0
    MISSILE = 1
    TURRET = 2

class Module(HandledItem, HandledCharge, ItemAttrShortcut, ChargeAttrShortcut):
    """An instance of this class represents a module together with its charge and modified attributes"""
    DAMAGE_ATTRIBUTES = ("emDamage", "kineticDamage", "explosiveDamage", "thermalDamage")

    def __init__(self, item):
        self.__item = item if item != None else 0
        self.itemID = item.ID if item is not None else None
        self.__charge = 0
        self.projected = False
        self.state = State.ONLINE
        self.__dps = None
        self.__volley = None
        self.__reloadTime = None
        self.__reloadForce = None
        self.__chargeCycles = None
        self.__itemModifiedAttributes = ModifiedAttributeDict()
        self.__slot = None

        if item != None:
            self.__itemModifiedAttributes.original = item.attributes
            self.__hardpoint = self.__calculateHardpoint(item)
            self.__slot = self.__calculateSlot(item)

        self.__chargeModifiedAttributes = ModifiedAttributeDict()

    @reconstructor
    def init(self):
        if self.dummySlot is None:
            self.__item = None
            self.__charge = None
            self.__volley = None
            self.__dps = None
            self.__reloadTime = None
            self.__reloadForce = None
            self.__chargeCycles = None
        else:
            self.__slot = self.dummySlot
            self.__item = 0
            self.__charge = 0
            self.__dps = 0
            self.__volley = 0
            self.__reloadTime = 0
            self.__reloadForce = None
            self.__chargeCycles = 0
            self.__hardpoint = Hardpoint.NONE
            self.__itemModifiedAttributes = ModifiedAttributeDict()
            self.__chargeModifiedAttributes = ModifiedAttributeDict()

    def __fetchItemInfo(self):
        import eos.db
        item = eos.db.getItem(self.itemID)
        self.__item = item
        self.__itemModifiedAttributes = ModifiedAttributeDict()
        self.__itemModifiedAttributes.original = item.attributes
        self.__hardpoint = self.__calculateHardpoint(item)
        self.__slot = self.__calculateSlot(item)

    def __fetchChargeInfo(self):
        self.__chargeModifiedAttributes = ModifiedAttributeDict()
        if self.chargeID is not None:
            import eos.db
            charge = eos.db.getItem(self.chargeID)
            self.__charge = charge
            self.__chargeModifiedAttributes.original = charge.attributes
        else:
            self.__charge = 0

    @classmethod
    def buildEmpty(cls, slot):
        empty = Module(None)
        empty.__slot = slot
        empty.__hardpoint = Hardpoint.NONE
        empty.__item = 0
        empty.__charge = 0
        empty.dummySlot = slot
        empty.__itemModifiedAttributes = ModifiedAttributeDict()
        empty.__chargeModifiedAttributes = ModifiedAttributeDict()

        return empty

    @classmethod
    def buildRack(cls, slot):
        empty = Rack(None)
        empty.__slot = slot
        empty.__hardpoint = Hardpoint.NONE
        empty.__item = 0
        empty.__charge = 0
        empty.dummySlot = slot
        empty.__itemModifiedAttributes = ModifiedAttributeDict()
        empty.__chargeModifiedAttributes = ModifiedAttributeDict()

        return empty

    @property
    def isEmpty(self):
        return self.dummySlot is not None

    @property
    def hardpoint(self):
        if self.__item is None:
            self.__fetchItemInfo()

        return self.__hardpoint

    @property
    def numCharges(self):
        if self.charge is None:
            charges = 0
        else:
            chargeVolume = self.charge.volume
            containerCapacity = self.item.capacity
            if chargeVolume is None or containerCapacity is None:
                charges = 0
            else:
                charges = floorFloat(float(containerCapacity) / chargeVolume)
        return charges

    @property
    def numShots(self):
        if self.charge is None:
            return None
        if self.__chargeCycles is None and self.charge:
            numCharges = self.numCharges
            # Usual ammo like projectiles and missiles
            if numCharges > 0 and "chargeRate" in self.itemModifiedAttributes:
                self.__chargeCycles = self.__calculateAmmoShots()
            # Frequency crystals (combat and mining lasers)
            elif numCharges > 0 and "crystalsGetDamaged" in self.chargeModifiedAttributes:
                self.__chargeCycles = self.__calculateCrystalShots()
            # Scripts and stuff
            else:
                self.__chargeCycles = 0
            return self.__chargeCycles
        else:
            return self.__chargeCycles

    @property
    def hpBeforeReload(self):
        """
        If item is some kind of repairer with charges, calculate
        HP it reps before going into reload.
        """
        cycles = self.numShots
        armorRep = self.getModifiedItemAttr("armorDamageAmount") or 0
        shieldRep = self.getModifiedItemAttr("shieldBonus") or 0
        if not cycles or (not armorRep and not shieldRep):
            return None
        hp = round((armorRep + shieldRep) * cycles)
        return hp

    def __calculateAmmoShots(self):
        if self.charge is not None:
            # Set number of cycles before reload is needed
            chargeRate = self.getModifiedItemAttr("chargeRate")
            numCharges = self.numCharges
            numShots = floorFloat(float(numCharges) / chargeRate)
        else:
            numShots = None
        return numShots

    def __calculateCrystalShots(self):
        if self.charge is not None:
            if self.getModifiedChargeAttr("crystalsGetDamaged") == 1:
                # For depletable crystals, calculate average amount of shots before it's destroyed
                hp = self.getModifiedChargeAttr("hp")
                chance = self.getModifiedChargeAttr("crystalVolatilityChance")
                damage = self.getModifiedChargeAttr("crystalVolatilityDamage")
                crystals = self.numCharges
                numShots = floorFloat(float(crystals * hp) / (damage * chance))
            else:
                # Set 0 (infinite) for permanent crystals like t1 laser crystals
                numShots = 0
        else:
            numShots = None
        return numShots

    @property
    def maxRange(self):
        attrs = ("maxRange", "shieldTransferRange", "powerTransferRange",
                 "energyDestabilizationRange", "empFieldRange",
                 "ecmBurstRange", "warpScrambleRange", "cargoScanRange",
                 "shipScanRange", "surveyScanRange")
        for attr in attrs:
            maxRange = self.getModifiedItemAttr(attr)
            if maxRange is not None: return maxRange
        if self.charge is not None:
            try:
                chargeName = self.charge.group.name
            except AttributeError:
                pass
            else:
                if chargeName in ("Scanner Probe", "Survey Probe"):
                    return None
            # Source: http://www.eveonline.com/ingameboard.asp?a=topic&threadID=1307419&page=1#15
            # D_m = V_m * (T_m + T_0*[exp(- T_m/T_0)-1])
            maxVelocity = self.getModifiedChargeAttr("maxVelocity")
            flightTime = self.getModifiedChargeAttr("explosionDelay") / 1000.0
            mass = self.getModifiedChargeAttr("mass")
            agility = self.getModifiedChargeAttr("agility")
            if maxVelocity and flightTime and mass and agility:
                accelTime =  min(flightTime, mass*agility/1000000)
                # Average distance done during acceleration
                duringAcceleration = maxVelocity / 2 * accelTime
                # Distance done after being at full speed
                fullSpeed = maxVelocity * (flightTime - accelTime)
                return duringAcceleration + fullSpeed

    @property
    def falloff(self):
        attrs = ("falloff", "shipScanFalloff")
        for attr in attrs:
            falloff = self.getModifiedItemAttr(attr)
            if falloff is not None: return falloff

    @property
    def slot(self):
        if self.__item is None:
            self.__fetchItemInfo()

        return self.__slot


    @property
    def itemModifiedAttributes(self):
        if self.__item is None:
            self.__fetchItemInfo()

        return self.__itemModifiedAttributes

    @property
    def chargeModifiedAttributes(self):
        if self.__charge is None:
            self.__fetchChargeInfo()

        return self.__chargeModifiedAttributes

    @property
    def item(self):
        if self.__item is None:
            self.__fetchItemInfo()

        return self.__item if self.__item != 0 else None

    @property
    def charge(self):
        if self.__charge is None:
            self.__fetchChargeInfo()

        return self.__charge if self.__charge != 0 else None

    @charge.setter
    def charge(self, charge):
        self.__charge = charge
        if charge is not None:
            self.chargeID = charge.ID
            self.__chargeModifiedAttributes.original = charge.attributes
        else:
            self.chargeID = None
            self.__chargeModifiedAttributes.original = None

        self.__itemModifiedAttributes.clear()

    @property
    def damageStats(self):
        if self.__dps == None:
            if self.isEmpty:
                self.__dps = 0
                self.__volley = 0
            else:
                if self.state >= State.ACTIVE:
                    if self.charge:
                        volley = sum(map(lambda attr: self.getModifiedChargeAttr(attr) or 0, self.DAMAGE_ATTRIBUTES))
                    else:
                        volley = sum(map(lambda attr: self.getModifiedItemAttr(attr) or 0, self.DAMAGE_ATTRIBUTES))
                    volley *= self.getModifiedItemAttr("damageMultiplier") or 1
                    if volley:
                        cycleTime = self.cycleTime
                        self.__volley = volley
                        self.__dps = volley / (cycleTime / 1000.0)
                    else:
                        self.__volley = 0
                        self.__dps = 0
                else:
                    self.__volley = 0
                    self.__dps = 0

        return self.__dps, self.__volley

    @property
    def dps(self):
        return self.damageStats[0]

    @property
    def volley(self):
        return self.damageStats[1]

    @property
    def reloadTime(self):
        # Get reload time from attrs first, then use
        # custom value specified otherwise (e.g. in effects)
        moduleReloadTime = self.getModifiedItemAttr("reloadTime")
        if moduleReloadTime is None:
            moduleReloadTime = self.__reloadTime
        return moduleReloadTime

    @reloadTime.setter
    def reloadTime(self, milliseconds):
        self.__reloadTime = milliseconds

    @property
    def forceReload(self):
        return self.__reloadForce

    @forceReload.setter
    def forceReload(self, type):
        self.__reloadForce = type

    def fits(self, fit, hardpointLimit=True):
        slot = self.slot
        if fit.getSlotsFree(slot) <= (0 if self.owner != fit else -1):
            return False

        # Check ship type restrictions
        fitsOnType = set()
        fitsOnGroup = set()

        shipType = self.getModifiedItemAttr("fitsToShipType")
        if shipType is not None:
            fitsOnType.add(shipType)

        for i in xrange(1, 5):
            shipType = self.getModifiedItemAttr("canFitShipType%d" % i)
            if shipType is not None:
                fitsOnType.add(shipType)


        # Check ship group restrictions
        for i in xrange(1, 10):
            shipGroup = self.getModifiedItemAttr("canFitShipGroup%d" % i)
            if shipGroup is not None:
                fitsOnGroup.add(shipGroup)

        if (len(fitsOnGroup) > 0 or len(fitsOnType) > 0) and fit.ship.item.group.ID not in fitsOnGroup and fit.ship.item.ID not in fitsOnType:
            return False


        # If the mod is a subsystem, don't let two subs in the same slot fit
        if self.slot == Slot.SUBSYSTEM:
            subSlot = self.getModifiedItemAttr("subSystemSlot")
            for mod in fit.modules:
                if mod.getModifiedItemAttr("subSystemSlot") == subSlot:
                    return False

        # Check rig sizes
        if self.slot == Slot.RIG:
            if self.getModifiedItemAttr("rigSize") != fit.ship.getModifiedItemAttr("rigSize"):
                return False

        # Check max group fitted
        max = self.getModifiedItemAttr("maxGroupFitted")
        if max is not None:
            current = 0 if self.owner != fit else -1
            for mod in fit.modules:
                if mod.item and mod.item.groupID == self.item.groupID:
                    current += 1

            if current >= max:
                return False

        # Check this only if we're told to do so
        if hardpointLimit:
            if self.hardpoint == Hardpoint.TURRET:
                if fit.ship.getModifiedItemAttr('turretSlotsLeft') - fit.getHardpointsUsed(Hardpoint.TURRET) < 1:
                    return False
            elif self.hardpoint == Hardpoint.MISSILE:
                if fit.ship.getModifiedItemAttr('launcherSlotsLeft') - fit.getHardpointsUsed(Hardpoint.MISSILE) < 1:
                    return False

        return True

    def isValidState(self, state):
        """
        Check if the state is valid for this module, without considering other modules at all
        """
        #Check if we're within bounds
        if state < -1 or state > 2:
            return False
        elif state >= State.ACTIVE and not self.item.isType("active"):
            return False
        elif state == State.OVERHEATED and not self.item.isType("overheat"):
            return False
        else:
            return True

    def canHaveState(self, state=None, projectedOnto=None):
        """
        Check with other modules if there are restrictions that might not allow this module to be activated
        """
        # If we're going to set module to offline or online for local modules or offline for projected,
        # it should be fine for all cases
        item = self.item
        if (state <= State.ONLINE and projectedOnto is None) or (state <= State.OFFLINE):
            return True

        # Check if the local module is over it's max limit; if it's not, we're fine
        maxGroupActive = self.getModifiedItemAttr("maxGroupActive")
        if maxGroupActive is None and projectedOnto is None:
            return True

        # Following is applicable only to local modules, we do not want to limit projected
        if projectedOnto is None:
            currActive = 0
            group = item.group.name
            for mod in self.owner.modules:
                currItem = getattr(mod, "item", None)
                if mod.state >= State.ACTIVE and currItem is not None and currItem.group.name == group:
                    currActive += 1
                if currActive > maxGroupActive:
                    break
            return currActive <= maxGroupActive
        # For projected, we're checking if ship is vulnerable to given item
        else:
            # Do not allow to apply offensive modules on ship with offensive module immunite, with few exceptions
            # (all effects which apply instant modification are exception, generally speaking)
            if item.offensive and projectedOnto.ship.getModifiedItemAttr("disallowOffensiveModifiers") == 1:
                offensiveNonModifiers = set(("energyDestabilizationNew", "leech"))
                if not offensiveNonModifiers.intersection(set(item.effects)):
                    return False
            # If assistive modules are not allowed, do not let to apply these altogether
            if item.assistive and projectedOnto.ship.getModifiedItemAttr("disallowAssistance") == 1:
                return False
            return True

    def isValidCharge(self, charge):
        #Check sizes, if 'charge size > module volume' it won't fit
        if charge is None: return True
        chargeVolume = charge.volume
        moduleCapacity = self.item.capacity
        if chargeVolume is not None and moduleCapacity is not None and chargeVolume > moduleCapacity:
            return False

        itemChargeSize = self.getModifiedItemAttr("chargeSize")
        if itemChargeSize is not None:
            chargeSize = charge.getAttribute('chargeSize')
            if itemChargeSize != chargeSize:
                return False

        chargeGroup = charge.groupID
        for i in range(5):
            itemChargeGroup = self.getModifiedItemAttr('chargeGroup' + str(i))
            if itemChargeGroup is None: continue
            if itemChargeGroup == chargeGroup: return True

        return False

    def getValidCharges(self):
        validCharges = set()
        import eos.db
        for i in range(5):
            itemChargeGroup = self.getModifiedItemAttr('chargeGroup' + str(i))
            if itemChargeGroup is not None:
                g = eos.db.getGroup(int(itemChargeGroup), eager=("items.icon", "items.attributes"))
                if g is None:
                    continue
                for i in g.items:
                    if i.published and self.isValidCharge(i):
                        validCharges.add(i)

        return validCharges

    def __calculateHardpoint(self, item):
        effectHardpointMap = {"turretFitted" : Hardpoint.TURRET,
                              "launcherFitted": Hardpoint.MISSILE}

        if item is None:
            return Hardpoint.NONE

        for effectName, slot in effectHardpointMap.iteritems():
            if effectName in item.effects:
                return slot

        return Hardpoint.NONE

    def __calculateSlot(self, item):
        effectSlotMap = {"rigSlot" : Slot.RIG,
                         "loPower" : Slot.LOW,
                         "medPower" : Slot.MED,
                         "hiPower" : Slot.HIGH,
                         "subSystem" : Slot.SUBSYSTEM}
        if item is None:
            return None
        for effectName, slot in effectSlotMap.iteritems():
            if effectName in item.effects:
                return slot
        if item.group.name == "Effect Beacon":
            return Slot.RIG

        raise ValueError("Passed item does not fit in any known slot")

    @validates("ID", "itemID", "ammoID")
    def validator(self, key, val):
        map = {"ID": lambda val: isinstance(val, int),
               "itemID" : lambda val: val is None or isinstance(val, int),
               "ammoID" : lambda val: isinstance(val, int)}

        if map[key](val) == False: raise ValueError(str(val) + " is not a valid value for " + key)
        else: return val

    def clear(self):
        self.__dps = None
        self.__volley = None
        self.__reloadTime = None
        self.__reloadForce = None
        self.__chargeCycles = None
        self.itemModifiedAttributes.clear()
        self.chargeModifiedAttributes.clear()

    def calculateModifiedAttributes(self, fit, runTime, forceProjected = False):
        #We will run the effect when two conditions are met:
        #1: It makes sense to run the effect
        #    The effect is either offline
        #    or the effect is passive and the module is in the online state (or higher)

        #    or the effect is active and the module is in the active state (or higher)
        #    or the effect is overheat and the module is in the overheated state (or higher)
        #2: the runtimes match

        if self.projected or forceProjected:
            context = "projected", "module"
            projected = True
        else:
            context = ("module",)
            projected = False

        if self.charge is not None:
            # fix for #82 and it's regression #106
            if not projected or (self.projected and not forceProjected):
                for effect in self.charge.effects.itervalues():
                    if effect.runTime == runTime:
                        effect.handler(fit, self, ("moduleCharge",))

        if self.item:
            if self.state >= State.OVERHEATED:
                for effect in self.item.effects.itervalues():
                    if effect.runTime == runTime and effect.isType("overheat"):
                        effect.handler(fit, self, context)

            for effect in self.item.effects.itervalues():
                if effect.runTime == runTime and \
                (effect.isType("offline") or
                (effect.isType("passive") and self.state >= State.ONLINE) or \
                (effect.isType("active") and self.state >= State.ACTIVE)) and \
                ((projected and effect.isType("projected")) or not projected):
                        effect.handler(fit, self, context)

    @property
    def cycleTime(self):
        reactivation = (self.getModifiedItemAttr("moduleReactivationDelay") or 0)
        # Reactivation time starts counting after end of module cycle
        speed = self.rawCycleTime + reactivation
        if self.charge:
            reload = self.reloadTime
        else:
            reload = 0.0
        # Determine if we'll take into account reload time or not
        factorReload = self.owner.factorReload if self.forceReload is None else self.forceReload
        # If reactivation is longer than 10 seconds then module can be reloaded
        # during reactivation time, thus we may ignore reload
        if factorReload and reactivation < reload:
            numShots = self.numShots
            # Time it takes to reload module after end of reactivation time,
            # given that we started when module cycle has just over
            additionalReloadTime = (reload - reactivation)
            # Speed here already takes into consideration reactivation time
            speed = (speed * numShots + additionalReloadTime) / numShots if numShots > 0 else speed

        return speed

    @property
    def rawCycleTime(self):
        speed =  self.getModifiedItemAttr("speed") or self.getModifiedItemAttr("duration")
        return speed

    @property
    def capUse(self):
        capNeed = self.getModifiedItemAttr("capacitorNeed")
        if capNeed and self.state >= State.ACTIVE:
            cycleTime = self.cycleTime
            capUsed = capNeed / (cycleTime / 1000.0)
            return capUsed
        else:
            return 0

    def __deepcopy__(self, memo):
        item = self.item
        if item is None:
            copy = Module.buildEmpty(self.slot)
        else:
            copy = Module(self.item)
        copy.charge = self.charge
        copy.state = self.state
        return copy

class Rack(Module):
    '''
    This is simply the Module class named something else to differentiate
    it for app logic. This class does not do anything special
    '''
    pass

########NEW FILE########
__FILENAME__ = price
#===============================================================================
# Copyright (C) 2010 Diego Duclos
# Copyright (C) 2011 Anton Vorobyov
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import time
import urllib2
from xml.dom import minidom

from sqlalchemy.orm import reconstructor

import eos.db

class Price(object):
    # Price validity period, 24 hours
    VALIDITY = 24*60*60
    # Re-request delay for failed fetches, 4 hours
    REREQUEST = 4*60*60

    def __init__(self, typeID):
        self.typeID = typeID
        self.time = 0
        self.failed = None
        self.__item = None

    @reconstructor
    def init(self):
        self.__item = None

    def isValid(self, rqtime=time.time()):
        updateAge = rqtime - self.time
        # Mark price as invalid if it is expired
        validity = updateAge <= self.VALIDITY
        # Price is considered as valid, if it's expired but we had failed
        # fetch attempt recently
        if validity is False and self.failed is not None:
            failedAge = rqtime - self.failed
            validity = failedAge <= self.REREQUEST
            # If it's already invalid, it can't get any better
            if validity is False:
                return validity
            # If failed timestamp refers to future relatively to current
            # system clock, mark price as invalid
            if self.failed > rqtime:
                return False
        # Do the same for last updated timestamp
        if self.time > rqtime:
            return False
        return validity

    @classmethod
    def fetchPrices(cls, prices, proxy=None):
        """Fetch all prices passed to this method"""
        # Set time of the request
        # We have to pass this time to all of our used methods and validity checks
        # Using time of check instead can make extremely rare edge-case bugs to appear
        # (e.g. when item price is already considered as outdated, but c0rp fetch is still
        # valid, just because their update time has been set using slightly older timestamp)
        rqtime = time.time()
        # Dictionary for our price objects
        priceMap = {}
        # Check all provided price objects, and add invalid ones to dictionary
        for price in prices:
            if not price.isValid(rqtime=rqtime):
                priceMap[price.typeID] = price
        # List our price service methods
        services = ((cls.fetchEveCentral, (priceMap,), {"rqtime": rqtime, "proxy": proxy}),
                    (cls.fetchC0rporation, (priceMap,), {"rqtime": rqtime, "proxy": proxy}))
        # Cycle through services
        for svc, args, kwargs in services:
            # Stop cycling if we don't need price data anymore
            if len(priceMap) == 0:
                break
            # Request prices and get some feedback
            noData, abortedData = svc(*args, **kwargs)
            # Mark items with some failure occurred during fetching
            for typeID in abortedData:
                priceMap[typeID].failed = rqtime
            # Clear map from the fetched and failed items, leaving only items
            # for which we've got no data
            toRemove = set()
            for typeID in priceMap:
                if typeID not in noData:
                    toRemove.add(typeID)
            for typeID in toRemove:
                del priceMap[typeID]
        # After we've checked all possible services, assign zero price for items
        # which were not found on any service to avoid re-fetches during validity
        # period
        for typeID in priceMap:
            priceobj = priceMap[typeID]
            priceobj.price = 0
            priceobj.time = rqtime
            priceobj.failed = None

    @classmethod
    def fetchEveCentral(cls, priceMap, rqtime=time.time(), proxy=None):
        """Use Eve-Central price service provider"""
        # This set will contain typeIDs which were requested but no data has been fetched for them
        noData = set()
        # This set will contain items for which data fetch was aborted due to technical reasons
        abortedData = set()
        # Set of items which are still to be requested from this service
        toRequestSvc = set()
        # Compose list of items we're going to request
        for typeID in priceMap:
            # Get item object
            item = eos.db.getItem(typeID)
            # We're not going to request items only with market group, as eve-central
            # doesn't provide any data for items not on the market
            # Items w/o market group will be added to noData in the very end
            if item.marketGroupID:
                toRequestSvc.add(typeID)
        # Do not waste our time if all items are not on the market
        if len(toRequestSvc) == 0:
            noData.update(priceMap.iterkeys())
            return (noData, abortedData)
        # This set will contain typeIDs for which we've got useful data
        fetchedTypeIDs = set()
        # Base request URL
        baseurl = "http://api.eve-central.com/api/marketstat"
        # Area limitation list
        areas = ("usesystem=30000142", # Jita
                 None) # Global
        # Fetch prices from Jita market, if no data was available - check global data
        for area in areas:
            # Append area limitations to base URL
            areaurl = "{0}&{1}".format(baseurl, area) if area else baseurl
            # Set which contains IDs of items which we will fetch for given area
            toRequestArea = toRequestSvc.difference(fetchedTypeIDs).difference(abortedData)
            # As length of URL is limited, make a loop to make sure we request all data
            while(len(toRequestArea) > 0):
                # Set of items we're requesting during this cycle
                requestedThisUrl = set()
                # Always start composing our URL from area-limited URL
                requrl = areaurl
                # Generate final URL, making sure it isn't longer than 255 characters
                for typeID in toRequestArea:
                    # Try to add new typeID argument
                    newrequrl = "{0}&typeid={1}".format(requrl, typeID)
                    # If we didn't exceed our limits
                    if len(newrequrl) <= 255:
                        # Accept new URL
                        requrl = newrequrl
                        # Fill the set for the utility needs
                        requestedThisUrl.add(typeID)
                    # Use previously generated URL if new is out of bounds
                    else:
                        break
                # Do not request same items from the same area
                toRequestArea.difference_update(requestedThisUrl)
                # Replace first ampersand with question mark to separate arguments
                # from URL itself
                requrl = requrl.replace("&", "?", 1)
                # Make the request object
                request = urllib2.Request(requrl, headers={"User-Agent" : "eos"})
                # Attempt to send request and process it
                try:
                    if proxy is not None:
                        proxyHandler = urllib2.ProxyHandler({"http": proxy})
                        opener = urllib2.build_opener(proxyHandler)
                        urllib2.install_opener(opener)
                    data = urllib2.urlopen(request)
                    xml = minidom.parse(data)
                    types = xml.getElementsByTagName("marketstat").item(0).getElementsByTagName("type")
                    # Cycle through all types we've got from request
                    for type in types:
                        # Get data out of each typeID details tree
                        typeID = int(type.getAttribute("id"))
                        sell = type.getElementsByTagName("sell").item(0)
                        # If price data wasn't there, set price to zero
                        try:
                            percprice = float(sell.getElementsByTagName("percentile").item(0).firstChild.data)
                        except (TypeError, ValueError):
                            percprice = 0
                        # Eve-central returns zero price if there was no data, thus modify price
                        # object only if we've got non-zero price
                        if percprice:
                            # Add item id to list of fetched items
                            fetchedTypeIDs.add(typeID)
                            # Fill price data
                            priceobj = priceMap[typeID]
                            priceobj.price = percprice
                            priceobj.time = rqtime
                            priceobj.failed = None
                # If getting or processing data returned any errors
                except:
                    # Consider fetch as aborted
                    abortedData.update(requestedThisUrl)
        # Get actual list of items for which we didn't get data; it includes all requested items
        # (even those which didn't pass filter), excluding items which had problems during fetching
        # and items for which we've successfully fetched price
        noData.update(set(priceMap.iterkeys()).difference(fetchedTypeIDs).difference(abortedData))
        # And return it for future use
        return (noData, abortedData)

    @classmethod
    def fetchC0rporation(cls, priceMap, rqtime=time.time(), proxy=None):
        """Use c0rporation.com price service provider"""
        # it must be here, otherwise eos doesn't load miscData in time
        from eos.types import MiscData
        # Set-container for requested items w/o any data returned
        noData = set()
        # Container for items which had errors during fetching
        abortedData = set()
        # Set with types for which we've got data
        fetchedTypeIDs = set()
        # Container for prices we'll re-request from eve central.
        eveCentralUpdate = {}
        # Check when we updated prices last time
        fieldName = "priceC0rpTime"
        lastUpdatedField = eos.db.getMiscData(fieldName)
        # If this field isn't available, create and add it to session
        if lastUpdatedField is None:
            lastUpdatedField = MiscData(fieldName)
            eos.db.add(lastUpdatedField)
        # Convert field value to float, assigning it zero on any errors
        try:
            lastUpdated = float(lastUpdatedField.fieldValue)
        except (TypeError, ValueError):
            lastUpdated = 0
        # Get age of price
        updateAge = rqtime - lastUpdated
        # Using timestamp we've got, check if fetch results are still valid and make
        # sure system clock hasn't been changed to past
        c0rpValidityUpd = updateAge <= cls.VALIDITY and lastUpdated <= rqtime
        # If prices should be valid according to miscdata last update timestamp,
        # but method was requested to provide prices for some items, we can
        # safely assume that these items are not on the XML (to be more accurate,
        # on its previously fetched version), because all items which are valid
        # (and they are valid only when xml is valid) should be filtered out before
        # passing them to this method
        if c0rpValidityUpd is True:
            noData.update(set(priceMap.iterkeys()))
            return (noData, abortedData)
        # Check when price fetching failed last time
        fieldName = "priceC0rpFailed"
        # If it doesn't exist, add this one to the session too
        lastFailedField = eos.db.getMiscData(fieldName)
        if lastFailedField is None:
            lastFailedField = MiscData(fieldName)
            eos.db.add(lastFailedField)
        # Convert field value to float, assigning it none on any errors
        try:
            lastFailed = float(lastFailedField.fieldValue)
        except (TypeError, ValueError):
            lastFailed = None
        # If we had failed fetch attempt at some point
        if lastFailed is not None:
            failedAge = rqtime - lastFailed
            # Check if we should refetch data now or not (we do not want to do anything until
            # refetch timeout is reached or we have failed timestamp referencing some future time)
            c0rpValidityFail = failedAge <= cls.REREQUEST and lastFailed <= rqtime
            # If it seems we're not willing to fetch any data
            if c0rpValidityFail is True:
                # Consider all requested items as aborted. As we don't store list of items
                # provided by this service, this will include anything passed to this service,
                # even items which are usually not included in xml
                abortedData.update(set(priceMap.iterkeys()))
                return (noData, abortedData)
        # Our request URL
        requrl = "http://prices.c0rporation.com/faction.xml"
        # Generate request
        request = urllib2.Request(requrl, headers={"User-Agent" : "eos"})
        # Attempt to send request and process returned data
        try:
            if proxy is not None:
                proxyHandler = urllib2.ProxyHandler({"http": proxy})
                opener = urllib2.build_opener(proxyHandler)
                urllib2.install_opener(opener)
            data = urllib2.urlopen(request)
            # Parse the data we've got
            xml = minidom.parse(data)
            rowsets = xml.getElementsByTagName("rowset")
            for rowset in rowsets:
                rows = rowset.getElementsByTagName("row")
                # Go through all given data rows; as we don't want to request and process whole xml
                # for each price request, we need to process it in one single run
                for row in rows:
                    typeID = int(row.getAttribute("typeID"))
                    # Median price field may be absent or empty, assign 0 in this case
                    try:
                        medprice = float(row.getAttribute("median"))
                    except (TypeError, ValueError):
                        medprice = 0
                    # Process price only if it's non-zero
                    if medprice:
                        # Add current typeID to the set of fetched types
                        fetchedTypeIDs.add(typeID)
                        # If we have given typeID in the map we've got, pull price object out of it
                        if typeID in priceMap:
                            priceobj = priceMap[typeID]
                        # If we don't, request it from database
                        else:
                            priceobj = eos.db.getPrice(typeID)
                        # If everything failed
                        if priceobj is None:
                            # Create price object ourselves
                            priceobj = Price(typeID)
                            # And let database know that we'd like to keep it
                            eos.db.add(priceobj)
                        # Finally, fill object with data
                        priceobj.price = medprice
                        priceobj.time = rqtime
                        priceobj.failed = None
                        # Check if item has market group assigned
                        item = eos.db.getItem(typeID)
                        if item is not None and item.marketGroupID:
                            eveCentralUpdate[typeID] = priceobj
            # If any items need to be re-requested from EVE-Central, do so
            # We need to do this because c0rp returns prices for lot of items;
            # if returned price is one of requested, it's fetched from eve-central
            # first, which is okay; if it's not, price from c0rp will be written
            # which will prevent further updates from eve-central. As we consider
            # eve-central as more accurate source, ask to update prices for all
            # items we got
            if eveCentralUpdate:
                # We do not need any feedback from it, we just want it to update
                # prices
                cls.fetchEveCentral(eveCentralUpdate, rqtime=rqtime, proxy=proxy)
            # Save current time for the future use
            lastUpdatedField.fieldValue = rqtime
            # Clear the last failed field
            lastFailedField.fieldValue = None
            # Find which items were requested but no data has been returned
            noData.update(set(priceMap.iterkeys()).difference(fetchedTypeIDs))
        # If we failed somewhere during fetching or processing
        except:
            # Consider all items as aborted
            abortedData.update(set(priceMap.iterkeys()))
            # And whole fetch too
            lastFailedField.fieldValue = rqtime
        return (noData, abortedData)

########NEW FILE########
__FILENAME__ = ship
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from eos.modifiedAttributeDict import ModifiedAttributeDict, ItemAttrShortcut
from eos.effectHandlerHelpers import HandledItem

class Ship(ItemAttrShortcut, HandledItem):
    def __init__(self, item):

        if item.category.name != "Ship":
            raise ValueError('Passed item "%s" (category: (%s)) is not under Ship category'%(item.name, item.category.name))

        self.__item = item
        self.__itemModifiedAttributes = ModifiedAttributeDict()
        if not isinstance(item, int):
            self.__buildOriginal()

        self.commandBonus = 0

    def __fetchItemInfo(self):
        import eos.db
        self.__item = eos.db.getItem(self.__item)
        self.__buildOriginal()

    def __buildOriginal(self):
        self.__itemModifiedAttributes.original = self.item.attributes

    @property
    def item(self):
        if isinstance(self.__item, int):
            self.__fetchItemInfo()

        return self.__item

    @property
    def itemModifiedAttributes(self):
        if isinstance(self.__item, int):
            self.__fetchItemInfo()

        return self.__itemModifiedAttributes

    def clear(self):
        self.itemModifiedAttributes.clear()
        self.commandBonus = 0

    def calculateModifiedAttributes(self, fit, runTime, forceProjected = False):
        if forceProjected: return
        for effect in self.item.effects.itervalues():
            if effect.runTime == runTime and effect.isType("passive"):
                effect.handler(fit, self, ("ship",))

    def __deepcopy__(self, memo):
        copy = Ship(self.item)
        return copy

########NEW FILE########
__FILENAME__ = user
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from sqlalchemy.orm import validates
import hashlib
import string
import random

class User(object):
    def __init__(self, username, password = None, admin = False):
        self.username = username
        if password is not None: self.encodeAndSetPassword(password)
        self.admin = admin

    def encodeAndSetPassword(self, pw):
        h = hashlib.new("sha256")
        salt = "".join([random.choice(string.letters) for _ in xrange(32)])
        h.update(pw)
        h.update(salt)
        self.password = ("%s%s" % (h.hexdigest(), salt))

    def isPasswordValid(self, pw):
        if self.password is None: return False
        salt = self.password[-32:]
        h = hashlib.new("sha256")
        h.update(pw)
        h.update(salt)
        return self.password == (u"%s%s" % (h.hexdigest(), salt))

    @validates("ID", "username", "password", "admin")
    def validator(self, key, val):
        map = {"ID": lambda val: isinstance(val, int),
               "username" : lambda val: isinstance(val, basestring),
               "password" : lambda val: isinstance(val, basestring) and len(val) == 96,
               "admin" : lambda val: isinstance(val, bool)}

        if map[key](val) == False: raise ValueError(str(val) + " is not a valid value for " + key)
        else: return val

########NEW FILE########
__FILENAME__ = slotFill
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from eos.types import Slot, Fit, Module, State
import random
import copy
import math
import bisect
import itertools
import time

class SlotFill(object):
    def __init__(self, original, modules, attributeWeights=None, propertyWeights=None, specificWeights=None, defaultState = State.ACTIVE):
        self.original = original
        self.attributeWeights = attributeWeights or {}
        self.propertyWeights = propertyWeights or {}
        self.specificWeights = specificWeights or []
        self.state = State.ACTIVE
        self.modules = map(self.__newModule, modules)

    def __newModule(self, item):
        m = Module(item)
        m.state = self.state
        return m

    def __getMetaParent(self, item):
        metaGroup = item.metaGroup
        return item if metaGroup is None else metaGroup.parent

    def fitness(self, fit, chromosome):
        modList = fit.modules
        modAttr = fit.ship.getModifiedItemAttr

        modList.extend(chromosome)
        fit.clear()
        fit.calculateModifiedAttributes()

        if not fit.fits:
            del modList[-len(chromosome):]
            return 0

        weight = 0
        for attr, value in self.attributeWeights.iteritems():
            weight += modAttr(attr) * (value if value >= 0 else 1.0 / -value)

        for prop, value in self.propertyWeights.iteritems():
            weight += getattr(fit, prop) * (value if value >= 0 else 1.0 / -value)

        for specific in self.specificWeights:
            weight += specific(fit)

        totalVars = (fit.ship.getModifiedItemAttr("powerOutput"),
                     fit.ship.getModifiedItemAttr("cpuOutput"),
                     fit.ship.getModifiedItemAttr('upgradeCapacity'))

        usedVars = (fit.pgUsed, fit.cpuUsed, fit.calibrationUsed)

        total = 0
        used = 0
        for tv, uv in zip(totalVars, usedVars):
            if uv > tv:
                del modList[-len(chromosome):]
                return 0

        del modList[-len(chromosome):]


        return weight


    def run(self, elite = 0.05, crossoverChance = 0.8, slotMutationChance = 0.5, typeMutationChance = 0.5):
        #Use a copy of the original for all our calcs. We don't want to damage it
        fit = copy.deepcopy(self.original)
        fit.unfill()

        #First of all, lets check the number of slots we got to play with
        chromLength = -1
        slotAmounts = {}
        for type in Slot.getTypes():
            slot = Slot.getValue(type)
            amount = fit.getSlotsFree(slot)
            if amount > 0:
                slotAmounts[slot] = amount

            chromLength += amount

        if not slotAmounts:
            #Nothing to do, joy
            return

        slotModules = {}
        metaModules = {}

        for slotType in slotAmounts:
            slotModules[slotType] = modules = []

        for module in self.modules:
            #Store the variations of each base for ease and speed
            metaParent = self.__getMetaParent(module.item)
            metaList = metaModules.get(metaParent)
            if metaList is None:
                metaList = metaModules[metaParent] = []
            metaList.append(module)

            #Sort stuff by slotType for ease and speed
            slot = module.slot
            if slot in slotModules:
                slotModules[slot].append(module)

        for slotType, modules in slotModules.iteritems():
            if len(modules) == 0:
                chromLength -= slotAmounts[slotType]
                del slotAmounts[slotType]

        #Now, we need an initial set, first thing to do is decide how big that set will be
        setSize = 10

        #Grab some variables locally for performance improvements
        rchoice = random.choice
        rrandom = random.random
        rrandint = random.randint
        bbisect = bisect.bisect
        ccopy = copy.copy

        #Get our list for storage of our chromosomes
        chromosomes = []

        # Helpers
        weigher = lambda chromosome: (self.fitness(fit, chromosome), chromosome)
        keyer = lambda info: info[0]

        eliteCutout = int(math.floor(setSize * (1 - elite)))
        lastEl = setSize - 1

        #Generate our initial set entirely randomly
        #Subtelies to take in mind:
        # * modules of the same slotType are kept together for easy cross-overing
        state = self.state
        for _ in xrange(setSize):
            chrom = []
            for type, amount in slotAmounts.iteritems():
                for _ in xrange(amount):
                    chrom.append(rchoice(slotModules[type]))

            chromosomes.append(weigher(chrom))

        #Sort our initial set
        chromosomes.sort(key=keyer)
        currentGeneration = chromosomes

        #Yield the best result from our initial set, this is gonna be pretty bad
        yield currentGeneration[lastEl]

        #Setup's done, now we can actualy apply our genetic algorithm to optimize all this
        while True:
            moo = time.time()
            #First thing we do, we're gonna be elitair
            #Grab the top x%, we'll put em in the next generation
            nextGeneration = []
            for i in xrange(lastEl, eliteCutout - 1, -1):
                nextGeneration.append(currentGeneration[i])

            #Figure out our ratios to do our roulette wheel
            fitnessList = map(keyer, currentGeneration)
            totalFitness = float(sum(fitnessList))

            curr = 0
            ratios = []
            for fitness in fitnessList:
                curr += fitness
                ratios.append(curr / (totalFitness or 1))

            t = 0
            #Do our pairing
            for _ in xrange(0, eliteCutout):
                # Crossover chance
                mother = currentGeneration[bbisect(ratios, rrandom())][1]
                father = currentGeneration[bbisect(ratios, rrandom())][1]
                if rrandom() <= crossoverChance:
                    crosspoint = rrandint(0, chromLength)
                    luke = mother[:crosspoint] + father[crosspoint:]
                else:
                    luke = father

                #Chance for slot mutation
                if rrandom() <= slotMutationChance:
                    target = rrandint(0, chromLength)
                    mod = luke[target]
                    luke[target] = rchoice(slotModules[mod.slot])

                if rrandom() <= typeMutationChance:
                    #Mutation of an item to another one of the same type
                    target = rrandint(0, chromLength)
                    mod = luke[target]
                    vars = metaModules[self.__getMetaParent(mod.item)]
                    luke[target] = rchoice(vars)

                tt = time.time()
                nextGeneration.append(weigher(luke))
                t += time.time() - tt

            print "time spent weighing: ", t

            nextGeneration.sort(key=keyer)
            currentGeneration = nextGeneration
            print "total time spent this iteration:", time.time() - moo
            yield currentGeneration[lastEl]

########NEW FILE########
__FILENAME__ = types
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from eos.gamedata import Attribute, Category, Effect, Group, Icon, Item, MarketGroup, \
MetaGroup, AttributeInfo, Unit, EffectInfo, MetaType, MetaData, Traits
from eos.saveddata.price import Price
from eos.saveddata.user import User
from eos.saveddata.damagePattern import DamagePattern
from eos.saveddata.character import Character, Skill
from eos.saveddata.module import Module, State, Slot, Hardpoint, Rack
from eos.saveddata.drone import Drone
from eos.saveddata.cargo import Cargo
from eos.saveddata.implant import Implant
from eos.saveddata.booster import SideEffect
from eos.saveddata.booster import Booster
from eos.saveddata.ship import Ship
from eos.saveddata.fit import Fit
from eos.saveddata.fleet import Fleet, Wing, Squad
from eos.saveddata.miscData import MiscData
import eos.db

########NEW FILE########
__FILENAME__ = compat
# Backport of OrderedDict() class that runs on Python 2.4, 2.5, 2.6, 2.7 and pypy.
# Passes Python2.7's test suite and incorporates all the latest updates.

try:
    from thread import get_ident as _get_ident
except ImportError:
    from dummy_thread import get_ident as _get_ident

try:
    from _abcoll import KeysView, ValuesView, ItemsView
except ImportError:
    pass


class OrderedDict(dict):
    'Dictionary that remembers insertion order'
    # An inherited dict maps keys to values.
    # The inherited dict provides __getitem__, __len__, __contains__, and get.
    # The remaining methods are order-aware.
    # Big-O running times for all methods are the same as for regular dictionaries.

    # The internal self.__map dictionary maps keys to links in a doubly linked list.
    # The circular doubly linked list starts and ends with a sentinel element.
    # The sentinel element never gets deleted (this simplifies the algorithm).
    # Each link is stored as a list of length three:  [PREV, NEXT, KEY].

    def __init__(self, *args, **kwds):
        '''Initialize an ordered dictionary.  Signature is the same as for
        regular dictionaries, but keyword arguments are not recommended
        because their insertion order is arbitrary.

        '''
        if len(args) > 1:
            raise TypeError('expected at most 1 arguments, got %d' % len(args))
        try:
            self.__root
        except AttributeError:
            self.__root = root = []                     # sentinel node
            root[:] = [root, root, None]
            self.__map = {}
        self.__update(*args, **kwds)

    def __setitem__(self, key, value, dict_setitem=dict.__setitem__):
        'od.__setitem__(i, y) <==> od[i]=y'
        # Setting a new item creates a new link which goes at the end of the linked
        # list, and the inherited dictionary is updated with the new key/value pair.
        if key not in self:
            root = self.__root
            last = root[0]
            last[1] = root[0] = self.__map[key] = [last, root, key]
        dict_setitem(self, key, value)

    def __delitem__(self, key, dict_delitem=dict.__delitem__):
        'od.__delitem__(y) <==> del od[y]'
        # Deleting an existing item uses self.__map to find the link which is
        # then removed by updating the links in the predecessor and successor nodes.
        dict_delitem(self, key)
        link_prev, link_next, key = self.__map.pop(key)
        link_prev[1] = link_next
        link_next[0] = link_prev

    def __iter__(self):
        'od.__iter__() <==> iter(od)'
        root = self.__root
        curr = root[1]
        while curr is not root:
            yield curr[2]
            curr = curr[1]

    def __reversed__(self):
        'od.__reversed__() <==> reversed(od)'
        root = self.__root
        curr = root[0]
        while curr is not root:
            yield curr[2]
            curr = curr[0]

    def clear(self):
        'od.clear() -> None.  Remove all items from od.'
        try:
            for node in self.__map.itervalues():
                del node[:]
            root = self.__root
            root[:] = [root, root, None]
            self.__map.clear()
        except AttributeError:
            pass
        dict.clear(self)

    def popitem(self, last=True):
        '''od.popitem() -> (k, v), return and remove a (key, value) pair.
        Pairs are returned in LIFO order if last is true or FIFO order if false.

        '''
        if not self:
            raise KeyError('dictionary is empty')
        root = self.__root
        if last:
            link = root[0]
            link_prev = link[0]
            link_prev[1] = root
            root[0] = link_prev
        else:
            link = root[1]
            link_next = link[1]
            root[1] = link_next
            link_next[0] = root
        key = link[2]
        del self.__map[key]
        value = dict.pop(self, key)
        return key, value

    # -- the following methods do not depend on the internal structure --

    def keys(self):
        'od.keys() -> list of keys in od'
        return list(self)

    def values(self):
        'od.values() -> list of values in od'
        return [self[key] for key in self]

    def items(self):
        'od.items() -> list of (key, value) pairs in od'
        return [(key, self[key]) for key in self]

    def iterkeys(self):
        'od.iterkeys() -> an iterator over the keys in od'
        return iter(self)

    def itervalues(self):
        'od.itervalues -> an iterator over the values in od'
        for k in self:
            yield self[k]

    def iteritems(self):
        'od.iteritems -> an iterator over the (key, value) items in od'
        for k in self:
            yield (k, self[k])

    def update(*args, **kwds):
        '''od.update(E, **F) -> None.  Update od from dict/iterable E and F.

        If E is a dict instance, does:           for k in E: od[k] = E[k]
        If E has a .keys() method, does:         for k in E.keys(): od[k] = E[k]
        Or if E is an iterable of items, does:   for k, v in E: od[k] = v
        In either case, this is followed by:     for k, v in F.items(): od[k] = v

        '''
        if len(args) > 2:
            raise TypeError('update() takes at most 2 positional '
                            'arguments (%d given)' % (len(args),))
        elif not args:
            raise TypeError('update() takes at least 1 argument (0 given)')
        self = args[0]
        # Make progressively weaker assumptions about "other"
        other = ()
        if len(args) == 2:
            other = args[1]
        if isinstance(other, dict):
            for key in other:
                self[key] = other[key]
        elif hasattr(other, 'keys'):
            for key in other.keys():
                self[key] = other[key]
        else:
            for key, value in other:
                self[key] = value
        for key, value in kwds.items():
            self[key] = value

    __update = update  # let subclasses override update without breaking __init__

    __marker = object()

    def pop(self, key, default=__marker):
        '''od.pop(k[,d]) -> v, remove specified key and return the corresponding value.
        If key is not found, d is returned if given, otherwise KeyError is raised.

        '''
        if key in self:
            result = self[key]
            del self[key]
            return result
        if default is self.__marker:
            raise KeyError(key)
        return default

    def setdefault(self, key, default=None):
        'od.setdefault(k[,d]) -> od.get(k,d), also set od[k]=d if k not in od'
        if key in self:
            return self[key]
        self[key] = default
        return default

    def __repr__(self, _repr_running={}):
        'od.__repr__() <==> repr(od)'
        call_key = id(self), _get_ident()
        if call_key in _repr_running:
            return '...'
        _repr_running[call_key] = 1
        try:
            if not self:
                return '%s()' % (self.__class__.__name__,)
            return '%s(%r)' % (self.__class__.__name__, self.items())
        finally:
            del _repr_running[call_key]

    def __reduce__(self):
        'Return state information for pickling'
        items = [[k, self[k]] for k in self]
        inst_dict = vars(self).copy()
        for k in vars(OrderedDict()):
            inst_dict.pop(k, None)
        if inst_dict:
            return (self.__class__, (items,), inst_dict)
        return self.__class__, (items,)

    def copy(self):
        'od.copy() -> a shallow copy of od'
        return self.__class__(self)

    @classmethod
    def fromkeys(cls, iterable, value=None):
        '''OD.fromkeys(S[, v]) -> New ordered dictionary with keys from S
        and values equal to v (which defaults to None).

        '''
        d = cls()
        for key in iterable:
            d[key] = value
        return d

    def __eq__(self, other):
        '''od.__eq__(y) <==> od==y.  Comparison to another OD is order-sensitive
        while comparison to a regular mapping is order-insensitive.

        '''
        if isinstance(other, OrderedDict):
            return len(self)==len(other) and self.items() == other.items()
        return dict.__eq__(self, other)

    def __ne__(self, other):
        return not self == other

    # -- the following methods are only used in Python 2.7 --

    def viewkeys(self):
        "od.viewkeys() -> a set-like object providing a view on od's keys"
        return KeysView(self)

    def viewvalues(self):
        "od.viewvalues() -> an object providing a view on od's values"
        return ValuesView(self)

    def viewitems(self):
        "od.viewitems() -> a set-like object providing a view on od's items"
        return ItemsView(self)

########NEW FILE########
__FILENAME__ = effectUsedBy
#!/usr/bin/env python3
#======================================================================
# Copyright (C) 2010 Anton Vorobyov
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as
# published by the Free Software Foundation, either version 3 of
# the License, or (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with eos.  If not, see <http://www.gnu.org/licenses/>.
#======================================================================
"""
Go through all effects and fill them with 'used by' comments.

There're several big stages:
Stage 1. Gather all required data into 'global' dictionaries. We have
2 dictionaries per grouping type, one which lists groups per typeid,
and another which lists typeIDs per group.
Stage 2. Cycle through each effect.
Stage 2.1. Compose similar set of dictionaries like in stage 1, but
this time we take into consideration typeIDs affected by effect picked
in stage 2.
Stage 2.2. Create several lists (1 per grouping type) which will keep
IDs of these groups which will describe set of the typeIDs, and start
iterating. Each iteration one ID will be appended to any of the lists.
Stage 2.2.1. Compose score dictionaries per grouping type, and
calculate total score for given grouping type.
Stage 2.2.2. Pick grouping type with highest score, find winner group
inside grouping type, append its ID to corresponding list created in
stage 2.2. If score is less than certain value, stop iterating. If some
items are not covered by set of winners from lists, they'll be
presented as single items.
Stage 2.3. Print results to file if anything has been changed.

Grouping types used are:
Groups (groupID of an item);
Categories (categoryID of groupID of an item);
Base types (variations, like they appear on eve's variation tab);
Market groups + variations (marketGroupID of an item, plus variations
of all items from given market group, excluding items with
marketGroupID).
Type names (various combinations of words taken from typeName of item).
"""

import copy
import itertools
import os.path
import re
import sqlite3
from optparse import OptionParser

usage = "usage: %prog --database=DB [--debug=DEBUG]"
parser = OptionParser(usage=usage)
parser.add_option("-d", "--database", help="path to eve cache data dump in \
sqlite format, default pyfa database path is used if none specified",
type="string", default=os.path.join("~", ".pyfa","eve.db"))
parser.add_option("-e", "--effects", help="explicit comma-separated list of \
effects to process", type="string", default="")
parser.add_option("-u", "--debug", help="debug level, 0 by default",
                  type="int", default=0)
(options, args) = parser.parse_args()

# Show debugging prints?
# 0 - Don't show debugging stuff and perform actual run
# 1 - Show only for first iteration
# 2 - Show for all iterations
DEBUG_LEVEL = options.debug

# Ways to control process:
# Adjust grouping type weights (more number - better chance to pick
# this grouping type)
GROUP_WEIGHT = 1.0
CATEGORY_WEIGHT = 1.0
BASETYPE_WEIGHT = 1.0
MARKETGROUPWITHVARS_WEIGHT = 0.3
TYPENAMECOMBS_WEIGHT = 1.0
# If score drops below this value, remaining items will be listed
# without any grouping
LOWEST_SCORE = 0.7
# Adjust scoring formulae
def calc_innerscore(affected_decribed, affected_undescribed, total,
                    pereffect_totalaffected, weight=1.0):
    """Inner score calculation formula"""
    # Percentage of items affected by effect out of total number of
    # items in this group
    coverage_total = (affected_decribed + affected_undescribed) / total
    # Same, but only described/undescribed items are taken
    coverage_described = affected_decribed / total
    coverage_undescribed = affected_undescribed / total
    # Already described items should have less weight
    coverage_additionalfactor = coverage_undescribed + coverage_described * 0
    # If group has just one item - it should have zero score
    affected_total_factor = affected_decribed + affected_undescribed - 1
    innerscore = (coverage_total ** 0.23) * coverage_additionalfactor * \
    affected_total_factor * weight
    return innerscore
def calc_outerscore(innerscore_dict, pereffect_totalaffected, weight):
    """Outer score calculation formula"""
    # Return just max of the inner scores, including weight factor
    if float(len(innerscore_dict)):
        outerscore = innerscore_dict[max(innerscore_dict, key=lambda a:
        innerscore_dict.get(a))] * weight
        return outerscore
    else: return 0.0

# Connect to database and set up cursor
db = sqlite3.connect(os.path.expanduser(options.database))
cursor = db.cursor()

# Force some of the items to make them published
FORCEPUB_TYPES = ("Ibis", "Impairor", "Velator", "Reaper")
OVERRIDES_TYPEPUB = 'UPDATE invtypes SET published = 1 WHERE typeName = ?'
for typename in FORCEPUB_TYPES:
    cursor.execute(OVERRIDES_TYPEPUB, (typename,))

# Queries to get raw data
QUERY_ALLEFFECTS = 'SELECT effectID, effectName FROM dgmeffects'
# Limit categories to Ships (6), Modules (7), Charges (8), Skills (16),
# Drones (18), Implants (20), Subsystems (32), and groups to
# Effect Beacons (920)
QUERY_PUBLISHEDTYPEIDS = 'SELECT it.typeID FROM invtypes AS it INNER JOIN \
invgroups AS ig ON it.groupID = ig.groupID INNER JOIN invcategories AS ic ON \
ig.categoryID = ic.categoryID WHERE it.published = 1 AND (ic.categoryID IN \
(6, 7, 8, 16, 18, 20, 32) OR ig.groupID = 920)'
QUERY_TYPEID_GROUPID = 'SELECT groupID FROM invtypes WHERE typeID = ? LIMIT 1'
QUERY_GROUPID_CATEGORYID = 'SELECT categoryID FROM invgroups WHERE \
groupID = ? LIMIT 1'
QUERY_TYPEID_PARENTTYPEID = 'SELECT parentTypeID FROM invmetatypes WHERE \
typeID = ? LIMIT 1'
QUERY_TYPEID_MARKETGROUPID = 'SELECT marketGroupID FROM invtypes WHERE \
typeID = ? LIMIT 1'
QUERY_TYPEID_TYPENAME = 'SELECT typeName FROM invtypes WHERE typeID = ? \
LIMIT 1'
QUERY_MARKETGROUPID_PARENTGROUPID = 'SELECT parentGroupID FROM \
invmarketgroups WHERE marketGroupID = ? LIMIT 1'
QUERY_EFFECTID_TYPEID = 'SELECT typeID FROM dgmtypeeffects WHERE effectID = ?'
# Queries for printing
QUERY_GROUPID_GROUPNAME = 'SELECT groupName FROM invgroups WHERE groupID = ? \
LIMIT 1'
QUERY_CATEGORYID_CATEGORYNAME = 'SELECT categoryName FROM invcategories \
WHERE categoryID = ? LIMIT 1'
QUERY_MARKETGROUPID_MARKETGROUPNAME = 'SELECT marketGroupName FROM \
invmarketgroups WHERE marketGroupID = ? LIMIT 1'

# Compose list of effects w/o symbols which eos doesn't take into
# consideration, we'll use it to find proper effect IDs from file
# names
globalmap_effectnameeos_effectid = {}
STRIPSPEC = "[^A-Za-z0-9]"
cursor.execute(QUERY_ALLEFFECTS)
for row in cursor:
    effectid = row[0]
    effectnamedb = row[1]
    effectnameeos = re.sub(STRIPSPEC, "", effectnamedb).lower()
    # There may be different effects with the same name, so form
    # sets of IDs
    if not effectnameeos in globalmap_effectnameeos_effectid:
        globalmap_effectnameeos_effectid[effectnameeos] = set()
    globalmap_effectnameeos_effectid[effectnameeos].add(effectid)

# Stage 1

# Published types set
publishedtypes = set()
cursor.execute(QUERY_PUBLISHEDTYPEIDS)
for row in cursor:
    publishedtypes.add(row[0])

# Compose group maps
# { groupid : set(typeid) }
globalmap_groupid_typeid = {}
# { typeid : groupid }
globalmap_typeid_groupid = {}
for typeid in publishedtypes:
    groupid = 0
    cursor.execute(QUERY_TYPEID_GROUPID, (typeid,))
    for row in cursor:
        groupid = row[0]
    if not groupid in globalmap_groupid_typeid:
        globalmap_groupid_typeid[groupid] = set()
    globalmap_groupid_typeid[groupid].add(typeid)
    globalmap_typeid_groupid[typeid] = groupid

# Category maps
# { categoryid : set(typeid) }
globalmap_categoryid_typeid =  {}
# { typeid : categoryid }
globalmap_typeid_categoryid =  {}
for typeid in publishedtypes:
    categoryid = 0
    cursor.execute(QUERY_GROUPID_CATEGORYID,
                   (globalmap_typeid_groupid[typeid],))
    for row in cursor:
        categoryid = row[0]
    if not categoryid in globalmap_categoryid_typeid:
        globalmap_categoryid_typeid[categoryid] = set()
    globalmap_categoryid_typeid[categoryid].add(typeid)
    globalmap_typeid_categoryid[typeid] = categoryid

# Base type maps
# { basetypeid : set(typeid) }
globalmap_basetypeid_typeid =  {}
# { typeid : basetypeid }
globalmap_typeid_basetypeid =  {}
for typeid in publishedtypes:
    # Not all typeIDs in the database have baseTypeID, so assign some
    # default value to it
    basetypeid = 0
    cursor.execute(QUERY_TYPEID_PARENTTYPEID, (typeid,))
    for row in cursor:
        basetypeid = row[0]
    # If base type is not published or is not set in database, consider
    # item as variation of self
    if basetypeid not in publishedtypes:
        basetypeid = typeid
    if not basetypeid in globalmap_basetypeid_typeid:
        globalmap_basetypeid_typeid[basetypeid] = set()
    globalmap_basetypeid_typeid[basetypeid].add(typeid)
    globalmap_typeid_basetypeid[typeid] = basetypeid

# Market group maps - we won't use these for further processing, but
# just as helper for composing other maps
# { marketgroupid : set(typeid) }
globalmap_marketgroupid_typeid =  {}
# { typeid : set(marketgroupid) }
globalmap_typeid_marketgroupid =  {}
for typeid in publishedtypes:
    marketgroupid = 0
    cursor.execute(QUERY_TYPEID_MARKETGROUPID, (typeid,))
    for row in cursor:
        marketgroupid = row[0]
    if not marketgroupid:
        continue
    if not marketgroupid in globalmap_marketgroupid_typeid:
        globalmap_marketgroupid_typeid[marketgroupid] = set()
    globalmap_marketgroupid_typeid[marketgroupid].add(typeid)
# Copy items to all parent market groups
INITIALMARKETGROUPIDS = tuple(globalmap_marketgroupid_typeid)
for marketgroupid in INITIALMARKETGROUPIDS:
    # Limit depths for case if database will refer to groups making
    # the loop
    cyclingmarketgroupid = marketgroupid
    for depth in range(20):
        cursor_parentmarket = db.cursor()
        cursor_parentmarket.execute(QUERY_MARKETGROUPID_PARENTGROUPID,
                                    (cyclingmarketgroupid,))
        for row in cursor_parentmarket:
            cyclingmarketgroupid = row[0]
        if cyclingmarketgroupid:
            if not cyclingmarketgroupid in globalmap_marketgroupid_typeid:
                globalmap_marketgroupid_typeid[cyclingmarketgroupid] = set()
            globalmap_marketgroupid_typeid[cyclingmarketgroupid].update\
            (globalmap_marketgroupid_typeid[marketgroupid])
        else: break
# Now, make a reverse map
for marketgroupid, typeidset in globalmap_marketgroupid_typeid.items():
    for typeid in typeidset:
        if not typeid in globalmap_typeid_marketgroupid:
            globalmap_typeid_marketgroupid[typeid] = set()
        globalmap_typeid_marketgroupid[typeid].add(marketgroupid)

# Combine market groups and variations
# { marketgroupid : set(typeidwithvariations) }
globalmap_marketgroupid_typeidwithvariations = \
copy.deepcopy(globalmap_marketgroupid_typeid)
# { typeidwithvariations : set(marketgroupid) }
globalmap_typeidwithvariations_marketgroupid = {}
for marketgroupid in globalmap_marketgroupid_typeidwithvariations:
    typestoadd = set()
    for typeid in globalmap_marketgroupid_typeidwithvariations[marketgroupid]:
        if typeid in globalmap_basetypeid_typeid:
            for variationid in globalmap_basetypeid_typeid[typeid]:
                # Do not include items which have market group, even if
                # they're variation
                if not variationid in globalmap_typeid_marketgroupid:
                    typestoadd.add(variationid)
    globalmap_marketgroupid_typeidwithvariations[marketgroupid].update\
    (typestoadd)
# Make reverse map using simple way too
for marketgroupid, typeidwithvariationsset in \
globalmap_marketgroupid_typeidwithvariations.items():
    for typeid in typeidwithvariationsset:
        if not typeid in globalmap_typeidwithvariations_marketgroupid:
            globalmap_typeidwithvariations_marketgroupid[typeid] = set()
        globalmap_typeidwithvariations_marketgroupid[typeid].add(marketgroupid)

# Item names map
# We need to include category ID to avoid combining items from different
# categories (e.g. skills and modules) and length of original name to
# assess word coverage of various type name combinations
# { ((typenamecomb), categoryid) : set(typeid) }
globalmap_typenamecombtuple_typeid =  {}
# { typeid : (set((typenamecomb)), len(typename)) }
globalmap_typeid_typenamecombtuple =  {}
for typeid in publishedtypes:
    typename = ""
    cursor.execute(QUERY_TYPEID_TYPENAME, (typeid,))
    for row in cursor:
        typename = row[0]
    # Split strings into separate words
    typenamesplitted = []
    # Start from the whole type name
    remainingstring = typename
    # We will pick word each iteration
    iterate = True
    while iterate:
        # This regexp helps to split into words with spaces and dashes
        # between them, for example: CX|-|1, Hardwiring| - |Inherent,
        # Zainou| |'Snapshot'
        separatingpattern_general = \
        "((?P<left_part>[^ -]+)(?P<separator>[ -]+)(?P<right_part>([^ -].*)))"
        # This will help to split names like those used in implants,
        # for example: ZET||500, EE||8
        separatingpattern_series = \
        "((?P<left_part>[A-Za-z]{2,4})(?P<right_part>[0-9]{1,4}.*))"
        # Check remainingstring using both criteria
        matchobject_general = re.match(separatingpattern_general,
                                       remainingstring)
        matchobject_series = re.match(separatingpattern_series,
                                      remainingstring)
        # Now, we need to find which criterion satisfies us
        usegeneral = False
        useseries = False
        # If remaining string meets both criteria
        if matchobject_general and matchobject_series:
            # We check which occurs first and pick it
            shift_general = len(matchobject_general.group("left_part"))
            shift_series = len(matchobject_series.group("left_part"))
            if shift_general <= shift_series:
                usegeneral = True
            else:
                useseries = True
        # If only one criterion is met, just pick it
        elif matchobject_general:
            usegeneral = True
        elif matchobject_series:
            useseries = True
        # Now, actually split string into word, separator and remaining
        # string and append word to list of words of current typename
        if usegeneral:
            newword = matchobject_general.group("left_part")
            separator = matchobject_general.group("separator")
            remainingstring = matchobject_general.group("right_part")
            typenamesplitted.append(newword)
        elif useseries:
            newword = matchobject_series.group("left_part")
            separator = ""
            remainingstring = matchobject_series.group("right_part")
            typenamesplitted.append(newword)
        # If we didn't match any regexp, then we see last word - append
        # it too and stop iterating
        else:
            typenamesplitted.append(remainingstring)
            iterate = False
    # Iterate through number of words which will be used to compose
    # combinations
    for wordnumindex in range(len(typenamesplitted)):
        # Iterate through all possible combinations
        for typenamecomb in itertools.combinations(typenamesplitted,
                                                   wordnumindex + 1):
            typenamecombtuple = (typenamecomb,
                                 globalmap_typeid_categoryid[typeid])
            if not typenamecombtuple in globalmap_typenamecombtuple_typeid:
                globalmap_typenamecombtuple_typeid[typenamecombtuple] = set()
            globalmap_typenamecombtuple_typeid[typenamecombtuple].add(typeid)
            if not typeid in globalmap_typeid_typenamecombtuple:
                globalmap_typeid_typenamecombtuple[typeid] = \
                (set(), len(typenamesplitted))
            globalmap_typeid_typenamecombtuple[typeid][0].add(typenamecomb)

# Form list of effects for processing
effects_path = os.path.join("..", "..", "effects")
if options.effects:
    effect_list = options.effects.split(",")
else:
    effect_list = []
    for effect_file in os.listdir(effects_path):
        file_name, file_extension = effect_file.rsplit('.', 1)
        # Ignore non-py files and exclude implementation-specific 'effects'
        if file_extension == "py" and not file_name in ("__init__"):
            effect_list.append(file_name)

# Stage 2

# Go through effect files one-by-one
for effect_name in effect_list:
    effect_file = "{0}.py".format(effect_name)
    # Stage 2.1
    # Set of items which are affected by current effect
    pereffectlist_usedbytypes = set()
    if effect_name in globalmap_effectnameeos_effectid:
        effectids = globalmap_effectnameeos_effectid[effect_name]
    else:
        print("Effect {0} not found and will be skipped".format(effect_name))
        continue
    for effectid in effectids:
        cursor.execute(QUERY_EFFECTID_TYPEID, (effectid,))
        for row in cursor:
            typeid = row[0]
            if typeid in publishedtypes:
                pereffectlist_usedbytypes.add(typeid)
    # Number of items affected by current effect
    pereffect_totalaffected = len(pereffectlist_usedbytypes)

    # Compose per-group map of items which are affected by current
    # effect
    # { groupid : (set(typeid), describes) }
    effectmap_groupid_typeid = {}
    for typeid in pereffectlist_usedbytypes:
        groupid = globalmap_typeid_groupid[typeid]
        if not groupid in effectmap_groupid_typeid:
            effectmap_groupid_typeid[groupid] = [set(), False]
        effectmap_groupid_typeid[groupid][0].add(typeid)

    # Now, per-category map of items
    # { categoryid : (set(typeid), describes) }
    effectmap_categoryid_typeid = {}
    for typeid in pereffectlist_usedbytypes:
        categoryid = globalmap_typeid_categoryid[typeid]
        if not categoryid in effectmap_categoryid_typeid:
            effectmap_categoryid_typeid[categoryid] = [set(), False]
        effectmap_categoryid_typeid[categoryid][0].add(typeid)

    # Per-base type map of variations
    # { basetypeid : (set(typeid), describes) }
    effectmap_basetypeid_typeid = {}
    for typeid in pereffectlist_usedbytypes:
        basetypeid = globalmap_typeid_basetypeid[typeid]
        if not basetypeid in effectmap_basetypeid_typeid:
            effectmap_basetypeid_typeid[basetypeid] = [set(), False]
        effectmap_basetypeid_typeid[basetypeid][0].add(typeid)

    # Per-market group map with item variations
    # { marketgroupid : (set(typeidwithvariations), describes) }
    effectmap_marketgroupid_typeidwithvars = {}
    for typeid in pereffectlist_usedbytypes:
        if typeid in globalmap_typeid_marketgroupid:
            marketGroupIDs = globalmap_typeid_marketgroupid[typeid]
        else:
            marketGroupIDs = set()
        for marketgroupid in marketGroupIDs:
            if not marketgroupid in effectmap_marketgroupid_typeidwithvars:
                effectmap_marketgroupid_typeidwithvars[marketgroupid] = \
                [set(), False]
            effectmap_marketgroupid_typeidwithvars[marketgroupid][0].add\
            (typeid)

    # Per-type name combination map
    # { ((typenamecomb), categoryid) : (set(typeid), describes) }
    effectmap_typenamecombtuple_typeid = {}
    for typeid in pereffectlist_usedbytypes:
        typenamecombs = globalmap_typeid_typenamecombtuple[typeid][0]
        for typenamecomb in typenamecombs:
            typenamecombtuple = (typenamecomb,
                                 globalmap_typeid_categoryid[typeid])
            if not typenamecombtuple in effectmap_typenamecombtuple_typeid:
                effectmap_typenamecombtuple_typeid[typenamecombtuple] = \
                [set(), False]
            effectmap_typenamecombtuple_typeid[typenamecombtuple][0].add\
            (typeid)

    stopdebugprints = False
    if DEBUG_LEVEL >= 1:
        print("\nEffect:", effect_name)
        print("Total items affected: {0}".format(pereffect_totalaffected))

    # Stage 2.2
    # This set holds all ids of already described items
    effect_describedtypes = set()
    # These lists contain ids of each grouping type which are used
    # to describe items from the set above
    describedbygroup = []
    describedbycategory = []
    describedbybasetype = []
    describedbymarketgroupwithvars = []
    describedbytypenamecomb = []

    # Each iteration some group is picked which will be used
    # to describe set of items
    iterate = True
    while iterate:
        # Stage 2.2.1
        # Stores scores for each group which describe set of items
        groupscore = {}
        for groupid in effectmap_groupid_typeid:
            # Skip groups which are already used for item
            # description (have 'describes' flag set to True)
            describesflag = effectmap_groupid_typeid[groupid][1]
            if not describesflag:
                # Items from current group affected by current
                # effect
                affectedset = effectmap_groupid_typeid[groupid][0]
                # Number of affected items from current group;
                # Already described
                affected_decribed = len(affectedset.intersection
                                        (effect_describedtypes))
                # Yet undescribed
                affected_undescribed =  len(affectedset.difference
                                            (effect_describedtypes))
                # Total number of items from this group (not
                # necessarily affected by current effect)
                total = len(globalmap_groupid_typeid[groupid])
                # Calculate inner score and push it into score
                # dictionary for current grouping type
                groupscore[groupid] = calc_innerscore\
                (affected_decribed, affected_undescribed, total,
                 pereffect_totalaffected)
                # Debug prints for inner data
                if DEBUG_LEVEL >= 1 and not stopdebugprints:
                    cursor.execute(QUERY_GROUPID_GROUPNAME, (groupid,))
                    for row in cursor:
                        groupName = row[0]
                    coverage = (affected_decribed +
                    affected_undescribed) / total * 100
                    # If debug level is 1, print results only for
                    # 1st iteration
                    if DEBUG_LEVEL == 1:
                        printstr = "Group: {0}: {1}/{2} ({3:.3}%, inner \
score: {4:.3})"
                        print(printstr.format(groupName,
                              affected_undescribed, total, coverage,
                              groupscore[groupid]))
                    # If it's 2, print results for each
                    # iteration, so we need to include number
                    # of already described items
                    if DEBUG_LEVEL == 2:
                        printstr = "Group: {0}: {1}+{2}/{3} ({4:.3}%, \
inner score: {5:.3})"
                        print(printstr.format(groupName,
                              affected_undescribed, affected_decribed,
                              total, coverage, groupscore[groupid]))
        # Calculate outer score for this grouping type
        groupouterscore = calc_outerscore(groupscore,
                                          pereffect_totalaffected,
                                          GROUP_WEIGHT)
        # Debug print for outer data
        if DEBUG_LEVEL >= 1 and not stopdebugprints:
            printstr = "Groups outer score: {0:.3}"
            print(printstr.format(groupouterscore))

        categoryscore = {}
        for categoryid in effectmap_categoryid_typeid:
            describesflag = effectmap_categoryid_typeid[categoryid][1]
            if not describesflag:
                affectedset = effectmap_categoryid_typeid[categoryid][0]
                affected_decribed = len(affectedset.intersection
                                        (effect_describedtypes))
                affected_undescribed =  len(affectedset.difference
                                            (effect_describedtypes))
                total = len(globalmap_categoryid_typeid[categoryid])
                categoryscore[categoryid] = calc_innerscore\
                (affected_decribed, affected_undescribed, total,
                 pereffect_totalaffected)
                if DEBUG_LEVEL >= 1 and not stopdebugprints:
                    cursor.execute(QUERY_CATEGORYID_CATEGORYNAME,
                                   (categoryid,))
                    for row in cursor:
                        categoryname = row[0]
                    coverage = (affected_decribed +
                    affected_undescribed) / total * 100
                    if DEBUG_LEVEL == 1:
                        printstr = "Category: {0}: {1}/{2} ({3:.3}%, \
inner score: {4:.3})"
                        print(printstr.format(categoryname,
                              affected_undescribed, total, coverage,
                              categoryscore[categoryid]))
                    if DEBUG_LEVEL == 2:
                        printstr = "Category: {0}: {1}+{2}/{3} ({4:.3}%, \
inner score: {5:.3})"
                        print(printstr.format(categoryname,
                              affected_undescribed, affected_decribed,
                              total, coverage, categoryscore[categoryid]))
        categoryouterscore = calc_outerscore(categoryscore,
                                             pereffect_totalaffected,
                                             CATEGORY_WEIGHT)
        if DEBUG_LEVEL >= 1 and not stopdebugprints:
            printstr = "Category outer score: {0:.3}"
            print(printstr.format(categoryouterscore))

        basetypescore = {}
        for basetypeid in effectmap_basetypeid_typeid:
            describesflag = effectmap_basetypeid_typeid[basetypeid][1]
            if not describesflag:
                affectedset = effectmap_basetypeid_typeid[basetypeid][0]
                affected_decribed = len(affectedset.intersection
                                        (effect_describedtypes))
                affected_undescribed =  len(affectedset.difference
                                            (effect_describedtypes))
                total = len(globalmap_basetypeid_typeid[basetypeid])
                basetypescore[basetypeid] = calc_innerscore\
                (affected_decribed, affected_undescribed, total,
                 pereffect_totalaffected)
                if DEBUG_LEVEL >= 1 and not stopdebugprints:
                    cursor.execute(QUERY_TYPEID_TYPENAME, (basetypeid,))
                    for row in cursor:
                        basetypename = row[0]
                    coverage = (affected_decribed +
                    affected_undescribed) / total * 100
                    if DEBUG_LEVEL == 1:
                        printstr = "Base item: {0}: {1}/{2} ({3:.3}%, \
inner score: {4:.3})"
                        print(printstr.format(basetypename,
                              affected_undescribed, total, coverage,
                              basetypescore[basetypeid]))
                    if DEBUG_LEVEL == 2:
                        printstr = "Base item: {0}: {1}+{2}/{3} ({4:.3}%, \
inner score: {5:.3})"
                        print(printstr.format(basetypename,
                              affected_undescribed, affected_decribed,
                              total, coverage, basetypescore[basetypeid]))
        basetypeouterscore = calc_outerscore(basetypescore,
                                             pereffect_totalaffected,
                                             BASETYPE_WEIGHT)
        #Print outer data
        if DEBUG_LEVEL >= 1 and not stopdebugprints:
            printstr = "Base item outer score: {0:.3}"
            print(printstr.format(basetypeouterscore))

        marketgroupwithvarsscore = {}
        for marketgroupid in effectmap_marketgroupid_typeidwithvars:
            describesflag = effectmap_marketgroupid_typeidwithvars\
            [marketgroupid][1]
            if not describesflag:
                affectedset = effectmap_marketgroupid_typeidwithvars\
                [marketgroupid][0]
                affected_decribed = len(affectedset.intersection
                                        (effect_describedtypes))
                affected_undescribed =  len(affectedset.difference
                                            (effect_describedtypes))
                total = len(globalmap_marketgroupid_typeidwithvariations
                            [marketgroupid])
                marketgroupwithvarsscore[marketgroupid] = calc_innerscore\
                (affected_decribed, affected_undescribed, total,
                 pereffect_totalaffected)
                if DEBUG_LEVEL >= 1 and not stopdebugprints:
                    cursor.execute(QUERY_MARKETGROUPID_MARKETGROUPNAME,
                                   (marketgroupid,))
                    for row in cursor:
                        marketgroupname = row[0]
                    # Prepend market group name with its parents
                    # names
                    prependparentid = marketgroupid
                    #Limit depth in case if market groups form a loop
                    for depth in range(20):
                        cursor_parentmarket = db.cursor()
                        cursor_parentmarket.execute\
                        (QUERY_MARKETGROUPID_PARENTGROUPID,
                         (prependparentid,))
                        for row in cursor_parentmarket:
                            prependparentid = row[0]
                        if prependparentid:
                            cursor.execute\
                            (QUERY_MARKETGROUPID_MARKETGROUPNAME,
                             (prependparentid,))
                            for row in cursor:
                                marketgroupname = "{0} > {1}".format\
                                (row[0],marketgroupname)
                        else:
                            break
                    coverage = (affected_decribed +
                    affected_undescribed) / total * 100
                    if DEBUG_LEVEL == 1:
                        printstr = "Market group with variations: {0}: \
{1}/{2} ({3:.3}%, inner score: {4:.3})"
                        print(printstr.format(marketgroupname,
                              affected_undescribed, total, coverage,
                              marketgroupwithvarsscore[marketgroupid]))
                    if DEBUG_LEVEL == 2:
                        printstr = "Market group with variations: {0}: \
{1}+{2}/{3} ({4:.3}%, inner score: {5:.3})"
                        print(printstr.format(marketgroupname,
                              affected_undescribed,
                              affected_decribed, total, coverage,
                              marketgroupwithvarsscore[marketgroupid]))
        marketgroupwithvarsouterscore = calc_outerscore\
        (marketgroupwithvarsscore, pereffect_totalaffected,
         MARKETGROUPWITHVARS_WEIGHT)
        if DEBUG_LEVEL >= 1 and not stopdebugprints:
            printstr = "Market group outer score: {0:.3}"
            print(printstr.format(marketgroupwithvarsouterscore))

        typenamecombscore = {}
        for typenamecombtuple in effectmap_typenamecombtuple_typeid:
            describesflag = effectmap_typenamecombtuple_typeid\
            [typenamecombtuple][1]
            if not describesflag:
                affectedset = effectmap_typenamecombtuple_typeid\
                [typenamecombtuple][0]
                affected_decribed = len(affectedset.intersection
                                        (effect_describedtypes))
                affected_undescribed =  len(affectedset.difference
                                            (effect_describedtypes))
                total = len(globalmap_typenamecombtuple_typeid
                            [typenamecombtuple])
                # Type names are special: wee also need to consider
                # how certain word combination covers full type
                # name
                averagecoverage = 0
                itemsnamedlikethis = effectmap_typenamecombtuple_typeid\
                [typenamecombtuple][0]
                for typeid in itemsnamedlikethis:
                    # Add number of words in combination divided by
                    # total number of words from any given item
                    averagecoverage += len(typenamecombtuple[0]) / \
                    globalmap_typeid_typenamecombtuple[typeid][1]
                # Then divide by number of items we checked, making
                # it real average
                averagecoverage = averagecoverage / len(itemsnamedlikethis)
                # Pass average coverage as additional balancing
                # factor with certain weight factor (80%)
                typenamecombscore[typenamecombtuple] = \
                calc_innerscore(affected_decribed, affected_undescribed,
                                total, pereffect_totalaffected,
                                0.2 + averagecoverage*0.8)
                if DEBUG_LEVEL >= 1 and not stopdebugprints:
                    typenamecombprintable = " ".join(typenamecombtuple[0])
                    coverage = (affected_decribed +
                                affected_undescribed) / total * 100
                    if DEBUG_LEVEL == 1:
                        printstr = "Type name combination: \"{0}\": \
{1}/{2} ({3:.3}%, inner score: {4:.3})"
                        print(printstr.format(typenamecombprintable,
                              affected_undescribed, total, coverage,
                              typenamecombscore[typenamecombtuple]))
                    if DEBUG_LEVEL == 2:
                        printstr = "Type name combination: \"{0}\": \
{1}+{2}/{3} ({4:.3}%, inner score: {5:.3})"
                        print(printstr.format(typenamecombprintable,
                              affected_undescribed, affected_decribed,
                              total, coverage,
                              typenamecombscore[typenamecombtuple]))
        typenamecombouterscore = calc_outerscore(typenamecombscore,
                                                 pereffect_totalaffected,
                                                 TYPENAMECOMBS_WEIGHT)
        if DEBUG_LEVEL >= 1 and not stopdebugprints:
            printstr = "Type name combination outer score: {0:.3}"
            print(printstr.format(typenamecombouterscore))

        # Don't print anything after 1st iteration at 1st debugging
        # level
        if DEBUG_LEVEL == 1:
            stopdebugprints = True

        # Stage 2.2.2
        # Pick max score from outer scores of all grouping types
        maxouterscore = max(groupouterscore, categoryouterscore,
                            basetypeouterscore,
                            marketgroupwithvarsouterscore,
                            typenamecombouterscore)
        # Define lower limit for score, below which there will be
        # no winners
        if maxouterscore >= LOWEST_SCORE:
            # If scores are similar, priorities are:
            # category > group > name > market group > base type
            if maxouterscore == categoryouterscore:
                # Pick ID of category which has highest score among
                # other categories
                categorywinner = max(categoryscore, key=categoryscore.get)
                # Add it to the list of categories which describe
                # set of items
                describedbycategory.append(categorywinner)
                # Add all items described by winning category into
                # set of described items
                effect_describedtypes.update\
                (globalmap_categoryid_typeid[categorywinner])
                # Set 'describes' flag to avoid processing of this
                # category during following iterations
                effectmap_categoryid_typeid[categorywinner][1] = True
                if DEBUG_LEVEL >= 2:
                    printstr = "Category winner: {0}"
                    print(printstr.format(categorywinner))
            elif maxouterscore == groupouterscore:
                groupwinner = max(groupscore, key=groupscore.get)
                describedbygroup.append(groupwinner)
                effect_describedtypes.update\
                (globalmap_groupid_typeid[groupwinner])
                effectmap_groupid_typeid[groupwinner][1] = True
                if DEBUG_LEVEL >= 2:
                    printstr = "Group winner: {0}"
                    print(printstr.format(groupwinner))
            elif maxouterscore == typenamecombouterscore:
                typenamecombwinner = max(typenamecombscore,
                                         key=typenamecombscore.get)
                describedbytypenamecomb.append(typenamecombwinner)
                effect_describedtypes.update\
                (globalmap_typenamecombtuple_typeid[typenamecombwinner])
                effectmap_typenamecombtuple_typeid[typenamecombwinner]\
                [1] = True
                if DEBUG_LEVEL >= 2:
                    printstr = "Named like winner: {0}"
                    print(printstr.format(typenamecombwinner))
            elif maxouterscore == marketgroupwithvarsouterscore:
                marketgroupwithvarswinner = max(marketgroupwithvarsscore,
                key=marketgroupwithvarsscore.get)
                describedbymarketgroupwithvars.append\
                (marketgroupwithvarswinner)
                effect_describedtypes.update\
                (globalmap_marketgroupid_typeidwithvariations
                 [marketgroupwithvarswinner])
                effectmap_marketgroupid_typeidwithvars\
                [marketgroupwithvarswinner][1] = True
                if DEBUG_LEVEL >= 2:
                    printstr = "Market group with variations winner: {0}"
                    print(printstr.format(marketgroupwithvarswinner))
            elif maxouterscore == basetypeouterscore:
                basetypewinner = max(basetypescore, key=basetypescore.get)
                describedbybasetype.append(basetypewinner)
                effect_describedtypes.update\
                (globalmap_basetypeid_typeid[basetypewinner])
                effectmap_basetypeid_typeid[basetypewinner][1] = True
                if DEBUG_LEVEL >= 2:
                    printstr = "Base item winner: {0}"
                    print(printstr.format(basetypewinner))
        # Stop if we have score less than some critical value,
        # all undescribed items will be provided as plain list
        else:
            iterate = False
            if DEBUG_LEVEL >= 2:
                print("No winners this iteration")
        # Also stop if we described all items
        if pereffectlist_usedbytypes.issubset(effect_describedtypes):
            iterate = False
        # Print separator for 2nd debugging level, to separate
        # debug data of one iteration from another
        if DEBUG_LEVEL >= 2:
            print("---")
    singleitems = set(pereffectlist_usedbytypes).difference\
    (effect_describedtypes)
    if DEBUG_LEVEL >= 1:
        print("Effect will be described by:")
        print("Single item IDs:", singleitems)
        print("Group IDs:", describedbygroup)
        print("Category IDs:", describedbycategory)
        print("Base item IDs:", describedbybasetype)
        print("Market group with variations IDs:",
              describedbymarketgroupwithvars)
        print("Type name combinations:", describedbytypenamecomb)

    # Stage 2.1
    # Read effect file and split it into lines
    effectfile = open(os.path.join(effects_path, effect_file), 'r')
    effectcontentssource = effectfile.read()
    effectfile.close()
    effectLines = effectcontentssource.split("\n")
    # Delete old comments from file contents
    numofcommentlines = 0
    for line in effectLines:
        if line:
            if line[0] == "#": numofcommentlines += 1
            else: break
        else: break
    for i in range(numofcommentlines):
        del effectLines[0]

    # These lists will contain IDs and some metadata in tuples
    printing_types = []
    printing_groups = []
    printing_categories = []
    printing_basetypes = []
    printing_marketgroupswithvars = []
    printing_typenamecombtuples = []

    # Gather data for printing in the form of tuples, each tuple has
    # grouping type ID, human-readable name and category name
    for typeid in singleitems:
        typename = ""
        cursor.execute(QUERY_TYPEID_TYPENAME, (typeid,))
        for row in cursor:
            typename = row[0]
        categoryname = ""
        cursor.execute(QUERY_CATEGORYID_CATEGORYNAME,
                       (globalmap_typeid_categoryid[typeid],))
        for row in cursor:
            categoryname = row[0]
        printing_types.append((typeid, typename, categoryname))
    for groupid in describedbygroup:
        groupName = ""
        cursor.execute(QUERY_GROUPID_GROUPNAME, (groupid,))
        for row in cursor:
            groupName = row[0]
        categoryid = 0
        cursor.execute(QUERY_GROUPID_CATEGORYID, (groupid,))
        for row in cursor:
            categoryid = row[0]
        categoryname = ""
        cursor.execute(QUERY_CATEGORYID_CATEGORYNAME, (categoryid,))
        for row in cursor:
            categoryname = row[0]
        printing_groups.append((groupid, groupName, categoryname))
    for categoryid in describedbycategory:
        categoryname = ""
        cursor.execute(QUERY_CATEGORYID_CATEGORYNAME, (categoryid,))
        for row in cursor:
            categoryname = row[0]
        printing_categories.append((categoryid, categoryname))
    for basetypeid in describedbybasetype:
        basetypename = ""
        cursor.execute(QUERY_TYPEID_TYPENAME, (basetypeid,))
        for row in cursor:
            basetypename = row[0]
        categoryname = ""
        cursor.execute(QUERY_CATEGORYID_CATEGORYNAME,
                       (globalmap_typeid_categoryid[basetypeid],))
        for row in cursor:
            categoryname = row[0]
        printing_basetypes.append((basetypeid, basetypename,
                                   categoryname))
    for marketgroupid in describedbymarketgroupwithvars:
        cursor.execute(QUERY_MARKETGROUPID_MARKETGROUPNAME,
                       (marketgroupid,))
        for row in cursor:
            marketgroupname = row[0]
        # Prepend market group name with its parents names
        prependparentid = marketgroupid
        # Limit depth to avoid looping, as usual
        for depth in range(20):
            cursor_parentmarket = db.cursor()
            cursor_parentmarket.execute(QUERY_MARKETGROUPID_PARENTGROUPID,
                                        (prependparentid,))
            for row in cursor_parentmarket:
                prependparentid = row[0]
            if prependparentid:
                cursor.execute(QUERY_MARKETGROUPID_MARKETGROUPNAME,
                               (prependparentid,))
                for row in cursor:
                    marketgroupname = "{0} > {1}".format(row[0],
                                                         marketgroupname)
            else:
                break
        printing_marketgroupswithvars.append((marketgroupid,
                                              marketgroupname))
    for typenamecombtuple in describedbytypenamecomb:
        typenamecombprint = " ".join(typenamecombtuple[0])
        categoryname = ""
        cursor.execute(QUERY_CATEGORYID_CATEGORYNAME,
                       (typenamecombtuple[1],))
        for row in cursor:
            categoryname = row[0]
        printing_typenamecombtuples.append((typenamecombtuple,
                                            typenamecombprint,
                                            categoryname))

    # Use separate list per grouping type to ease grouping type
    # sorting
    printing_typelines = []
    # Sort by item name first
    printing_types = sorted(printing_types, key=lambda tuple: tuple[1])
    # Then sort by category name
    printing_types = sorted(printing_types, key=lambda tuple: tuple[2])
    for type in printing_types:
        # Append line for printing to list
        catname = type[2]
        typename = type[1]
        printstr = "# {0}: {1}"
        printing_typelines.append(printstr.format(catname, typename))
    # Do the same for groups
    printing_grouplines = []
    printing_groups = sorted(printing_groups, key=lambda tuple: tuple[1])
    printing_groups = sorted(printing_groups, key=lambda tuple: tuple[2])
    for group in printing_groups:
        catname = group[2]
        groupname = group[1]
        described = len(effectmap_groupid_typeid[group[0]][0])
        total = len(globalmap_groupid_typeid[group[0]])
        printstr = "# {0}s from group: {1} ({2} of {3})"
        printing_grouplines.append(printstr.format(catname, groupname,
        described, total))
    # Process categories
    printing_categorylines = []
    printing_categories = sorted(printing_categories,
                                 key=lambda tuple: tuple[1])
    for category in printing_categories:
        catname = category[1]
        described = len(effectmap_categoryid_typeid[category[0]][0])
        total = len(globalmap_categoryid_typeid[category[0]])
        printstr = "# Items from category: {0} ({1} of {2})"
        printing_categorylines.append(printstr.format(catname, described,
        total))
    # Process variations
    printing_basetypelines = []
    printing_basetypes = sorted(printing_basetypes,
                                key=lambda tuple: tuple[1])
    printing_basetypes = sorted(printing_basetypes,
                                key=lambda tuple: tuple[2])
    for basetype in printing_basetypes:
        catname = basetype[2].lower()
        basename = basetype[1]
        described = len(effectmap_basetypeid_typeid[basetype[0]][0])
        total = len(globalmap_basetypeid_typeid[basetype[0]])
        printstr = "# Variations of {0}: {1} ({2} of {3})"
        printing_basetypelines.append(printstr.format(catname, basename,
        described, total))
    # Process market groups with variations
    printing_marketgroupwithvarslines = []
    printing_marketgroupswithvars = sorted(printing_marketgroupswithvars,
                                           key=lambda tuple: tuple[1])
    for marketgroup in printing_marketgroupswithvars:
        marketgroupname = marketgroup[1]
        described = len(effectmap_marketgroupid_typeidwithvars
                        [marketgroup[0]][0])
        total = len(globalmap_marketgroupid_typeidwithvariations
                    [marketgroup[0]])
        printstr = "# Items from market group: {0} ({1} of {2})"
        printing_marketgroupwithvarslines.append(printstr.
        format(marketgroupname, described, total))
    # Process type name combinations
    printing_typenamecombtuplelines = []
    printing_typenamecombtuples = sorted(printing_typenamecombtuples,
                                         key=lambda tuple: tuple[1])
    printing_typenamecombtuples = sorted(printing_typenamecombtuples,
                                         key=lambda tuple: tuple[2])
    for typenamecomb in printing_typenamecombtuples:
        catname = typenamecomb[2]
        namedlike = typenamecomb[1]
        described = len(effectmap_typenamecombtuple_typeid
                        [typenamecomb[0]][0])
        total = len(globalmap_typenamecombtuple_typeid[typenamecomb[0]])
        printstr = "# {0}s named like: {1} ({2} of {3})"
        printing_typenamecombtuplelines.append(printstr.format(catname,
        namedlike, described, total))

    # Compose single list of lines using custom sorting
    commentlines = printing_categorylines + printing_grouplines + \
    printing_typenamecombtuplelines + printing_marketgroupwithvarslines + \
    printing_basetypelines + printing_typelines
    # Prepend list with "used by"
    if commentlines:
        commentlines = ["# Used by:"] + commentlines
    # If effect isn't used, write it to file and to terminal
    else:
        commentlines = ["# Not used by any item"]
        print("Warning: effect file " + effect_name +
              " is not used by any item")
    # Combine "used by" comment lines and actual effect lines
    outputlines = commentlines + effectLines
    # Combine all lines into single string
    effectcontentsprocessed = "\n".join(outputlines)
    # If we're not debugging and contents actually changed - write
    # changes to the file
    if DEBUG_LEVEL == 0 and (effectcontentsprocessed !=
                             effectcontentssource):
        effectfile = open(os.path.join(effects_path, effect_file), 'w')
        effectfile.write(effectcontentsprocessed)
        effectfile.close()
    elif DEBUG_LEVEL >= 2:
        print("Comment to write to file:")
        print("\n".join(commentlines))

########NEW FILE########
__FILENAME__ = eveCacheToDb
#!/usr/bin/env python
#===============================================================================
# Copyright (C) 2010 Anton Vorobyov
# Copyright (C) 2010 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

'''
This script pulls data out of EVE cache and makes a database dump. To get most of the data,
you need to just log into game; however, for some special data sometimes you need to dump
it by executing corresponding action in game, for example - open market tree to get data for
invmarketgroups table.
Reverence library by Entity is used, check http://wiki.github.com/ntt/reverence/ for info
As reverence uses the same Python version as EVE client (2.x series), script cannot be converted to python3
Example commands to run the script under Linux with default eve paths for getting SQLite dump:
Tranquility: python eveCacheToDb.py --eve="~/.wine/drive_c/Program Files/CCP/EVE" --cache="~/.wine/drive_c/users/"$USER"/Local Settings/Application Data/CCP/EVE/c_program_files_ccp_eve_tranquility/cache" --dump="sqlite:////home/"$USER"/Desktop/eve.db"
Singularity: python eveCacheToDb.py --eve="~/.wine/drive_c/Program Files/CCP/Singularity" --cache="~/.wine/drive_c/users/"$USER"/Local Settings/Application Data/CCP/EVE/c_program_files_ccp_singularity_singularity/cache" --sisi --dump="sqlite:////home/"$USER"/Desktop/evetest.db"
'''

import os
import sys

# Add eos root path to sys.path
path = os.path.dirname(unicode(__file__, sys.getfilesystemencoding()))
sys.path.append(os.path.realpath(os.path.join(path, "..", "..", "..")))

def get_map():
    """
    Return table name - table class map
    """
    return {"allianceshortnames": None,
            "billtypes": None,
            "certificaterelationships": None,
            "certificates": None,
            "corptickernames": None,
            "dgmattribs": AttributeInfo,
            "dgmeffects": EffectInfo,
            "dgmtypeattribs": Attribute,
            "dgmtypeeffects": Effect,
            "evegraphics": None,
            "evelocations": None,
            "eveowners": None,
            "eveunits": Unit,
            "groupsByCategories": None,
            "icons": Icon,
            "invbptypes": None,
            "invcategories": Category,
            "invcontrabandTypesByFaction": None,
            "invcontrabandTypesByType": None,
            "invgroups": Group,
            "invmetagroups": MetaGroup,
            "invmarketgroups": MarketGroup,
            "invmetatypes": MetaType,
            "invmetatypesByTypeID": None,
            "invreactiontypes": None,
            "invtypes": Item,
            "locationscenes": None,
            "locationwormholeclasses": None,
            "mapcelestialdescriptions": None,
            "ownericons": None,
            "ramactivities": None,
            "ramaltypes": None,
            "ramaltypesdetailpercategory": None,
            "ramaltypesdetailpergroup": None,
            "ramcompletedstatuses": None,
            "ramtyperequirements": None,
            "schematics": None,
            "schematicsByPin": None,
            "schematicsByType": None,
            "schematicspinmap": None,
            "schematicstypemap": None,
            "shiptypes": None,
            "sounds": None,
            "typesByGroups": None,
            "typesByMarketGroups": None}

def get_order():
    """
    Return order for table processing
    """
    return ("icons",
            "invmarketgroups",
            "eveunits",
            "dgmattribs",
            "dgmeffects",
            "invcategories",
            "invgroups",
            "invmetagroups",
            "invtypes",
            "invmetatypes",
            "dgmtypeattribs",
            "dgmtypeeffects")

def get_customcalls():
    """
    Return custom table - call to get data for it map
    """
    return {"invmarketgroups": eve.RemoteSvc("marketProxy").GetMarketGroups()}

def process_table(sourcetable, tablename, tableclass):
    """
    Get all data from cache and write it to database
    """
    # Get data from source and process it
    tabledata = get_table_data(sourcetable, tablename, get_source_headers(sourcetable))
    # Insert everything into table
    insert_table_values(tabledata, tableclass)
    return

def get_source_headers(sourcetable):
    """
    Pull list of headers from the source table
    """
    sourceheaders = None
    guid = getattr(sourcetable, "__guid__", "None")
    # For IndexRowset and IndexedRowLists Reverence provides list of headers
    if guid in ("util.IndexRowset", "util.FilterRowset"):
        sourceheaders = tuple(sourcetable.header)
    # For IndexedRowLists, we need to compose list ourselves
    elif guid == "util.IndexedRowLists":
        headerset = set()
        for item in sourcetable:
            for row in sourcetable[item]:
                for headername in row.__header__.Keys():
                    headerset.add(headername)
        sourceheaders = tuple(headerset)
    return sourceheaders

def get_table_data(sourcetable, tablename, headers):
    """
    Pull data out of source table
    """
    # Each row is enclosed into dictionary, full table is list of these dictionaries
    datarows = []
    guid = getattr(sourcetable, "__guid__", "None")
    # We have Select method for IndexRowset tables
    if guid == "util.IndexRowset":
        for values in sourcetable.Select(*headers):
            # When Select is asked to find single value, it is returned in its raw
            # form. Convert is to tuple for proper further processing
            if not isinstance(values, (list, tuple, set)):
                values = (values,)
            headerslen = len(headers)
            datarow = {}
            # 1 row value should correspond to 1 header, if number or values doesn't
            # correspond to number of headers then something went wrong
            if headerslen != len(values):
                print "Error: malformed data in source table {0}".format(tablename)
                return None
            # Fill row dictionary with values and append it to list
            for i in xrange(headerslen):
                # If we've got ASCII string, convert it to Unicode
                if isinstance(values[i], str):
                    datarow[headers[i]] = unicode(values[i], 'ISO-8859-1')
                else:
                    datarow[headers[i]] = values[i]
            datarows.append(datarow)
    # FilterRowset and IndexedRowLists are accessible almost like dictionaries
    elif guid in ("util.FilterRowset", "util.IndexedRowLists"):
        # Go through all source table elements
        for element in sourcetable.iterkeys():
            # Go through all rows of an element
            for row in sourcetable[element]:
                datarow = {}
                # Fill row dictionary with values we need and append it to the list
                for header in headers:
                    value = getattr(row, header, None)
                    # None and zero values are different, and we want to write zero
                    # values to database
                    if value or value in (0, 0.0):
                        datarow[header] = value
                datarows.append(datarow)

    return datarows

def insert_table_values(tabledata, tableclass):
    """
    Insert values into tables and show progress
    """
    rows = 0
    rows_skipped = 0
    # Go through all table rows
    for row in tabledata:
        instance = tableclass()
        # Print dot each 1k inserted rows
        if rows / 1000.0 == int(rows / 1000.0):
            sys.stdout.write(".")
            sys.stdout.flush()
        try:
            # Go through all fields of a row, process them and insert
            for header in row:
                setattr(instance, header, process_value(row[header], tableclass, header))
            eos.db.gamedata_session.add(instance)
            rows += 1
        except ValueError:
            rows_skipped += 1
    # Print out results and actually commit results to database
    print "\nInserted {0} rows. skipped {1} rows".format(rows, rows_skipped)
    eos.db.gamedata_session.commit()

def process_value(value, tableclass, header):
    # Get column info
    info = tableclass._sa_class_manager.mapper.c.get(header)
    if info is None:
        return

    # Null out non-existent foreign key relations
    foreign_keys = info.foreign_keys
    if len(foreign_keys) > 0:
        for key in foreign_keys:
            col = key.column
            if not query_existence(col, value) and not key.deferrable:
                if info.nullable:
                    return None
                else:
                    raise ValueError("Integrity check failed")
            else:
                return value
    #Turn booleans into actual booleans, don't leave them as integers
    elif type(info.type) == Boolean:
        return bool(value)
    else:
        return value

existence_cache = {}
def query_existence(col, value):
    key = (col, col.table, value)
    info = existence_cache.get(key)
    if info is None:
        info = eos.db.gamedata_session.query(col.table).filter(col == value).count() > 0
        existence_cache[key] = info

    return info

if __name__ == "__main__":
    from ConfigParser import ConfigParser
    from optparse import OptionParser

    from reverence import blue
    from sqlalchemy import Boolean
    from sqlalchemy.orm import class_mapper, ColumnProperty

    import eos.config

    # Parse command line options
    usage = "usage: %prog --eve=EVE --cache=CACHE --dump=DUMP [--release=RELEASE --sisi]"
    parser = OptionParser(usage=usage)
    parser.add_option("-e", "--eve", help="path to eve folder")
    parser.add_option("-c", "--cache", help="path to eve cache folder")
    parser.add_option("-d", "--dump", help="the SQL Alchemy connection string of where we should place our final dump")
    parser.add_option("-r", "--release", help="database release number, defaults to 1", default="1")
    parser.add_option("-s", "--sisi", action="store_true", dest="singularity", help="if you're going to work with Singularity test server data, use this option", default=False)
    (options, args) = parser.parse_args()


    # Exit if we do not have any of required options
    if not options.eve or not options.cache or not options.dump:
        sys.stderr.write("You need to specify paths to eve folder, cache folder and SQL Alchemy connection string. Run script with --help option for further info.\n")
        sys.exit()

    # We can deal either with singularity or tranquility servers
    if options.singularity: server = "singularity"
    else: server = "tranquility"

    # Set static variables for paths
    PATH_EVE = os.path.expanduser(options.eve)
    PATH_CACHE = os.path.expanduser(options.cache)

    eos.config.gamedata_connectionstring = options.dump
    eos.config.debug = False

    from eos.gamedata import *
    import eos.db

    # Get version of EVE client
    config = ConfigParser()
    config.read(os.path.join(PATH_EVE, "common.ini"))

    # Form metadata dictionary for corresponding table
    metadata = {}
    metadata["version"] = config.getint("main", "build")
    metadata["release"] = options.release

    # Initialize Reverence cache manager
    eve = blue.EVE(PATH_EVE, cachepath=PATH_CACHE, server=server)
    cfg = eve.getconfigmgr()

    # Create all tables we need
    eos.db.gamedata_meta.create_all()

    # Add versioning info to the metadata table
    for fieldname in metadata:
        eos.db.gamedata_session.add(MetaData(fieldname, metadata[fieldname]))

    eos.db.gamedata_session.commit()

    # Get table map, processing order and special table data
    TABLE_MAP = get_map()
    TABLE_ORDER = get_order()
    CUSTOM_CALLS = get_customcalls()

    # Warn about various stuff
    for table in cfg.tables:
        if not table in TABLE_MAP:
            # Warn about new tables in cache which are still not described by table map
            print "Warning: unmapped table {0} found in cache".format(table)
    for table in TABLE_MAP:
        if not table in cfg.tables and not table in CUSTOM_CALLS:
            # Warn about mapped tables which are missing in cache
            print "Warning: mapped table {0} cannot be found in cache".format(table)
        if not table in TABLE_ORDER and TABLE_MAP[table] is not None:
            # Warn about mapped tables not specified in processing order
            print "Warning: mapped table {0} is missing in processing order".format(table)
    for table in TABLE_ORDER:
        if not table in TABLE_MAP:
            # Warn about unmapped tables in processing order
            print "Warning: unmapped table {0} is specified in processing order".format(table)

    # Get data from reverence and write it
    for tablename in TABLE_ORDER:
        tableclass = TABLE_MAP[tablename]
        if tableclass is not None:
            # Print currently processed table name
            print "Processing: {0}".format(tablename)
            # Get table object from the Reverence and process it
            source_table = getattr(cfg, tablename) if tablename not in CUSTOM_CALLS else CUSTOM_CALLS[tablename]
            # Gather data regarding columns for current table in cache and eos
            cols_eos = set(prop.key for prop in class_mapper(TABLE_MAP[tablename]).iterate_properties if isinstance(prop, ColumnProperty))
            cols_rev = set(get_source_headers(source_table))
            notineos = cols_rev.difference(cols_eos)
            notinrev = cols_eos.difference(cols_rev)
            if notineos:
                print "Warning: {0} found in cache but missing in eos definitions: {1}".format("column" if len(notineos) == 1 else "columns", ", ".join(sorted(notineos)))
            if notinrev:
                print "Warning: {0} found in eos definitions but missing in cache: {1}".format("column" if len(notinrev) == 1 else "columns", ", ".join(sorted(notinrev)))
            process_table(source_table, tablename, tableclass)

########NEW FILE########
__FILENAME__ = findNonMarket
#!/usr/bin/env python3

import copy
import os.path
import re
import sqlite3

# Connect to database and set up cursor
db = sqlite3.connect(os.path.join("..", "..", "..", "staticdata", "eve.db"))
cursor = db.cursor()

# Queries to get raw data
QUERY_ALLEFFECTS = 'SELECT effectID, effectName FROM dgmeffects'
# Limit categories to
# \Modules (7), Charges (8), Drones (18),
# Implants (20), Subsystems (32)
QUERY_PUBLISHEDTYPEIDS = 'SELECT it.typeID FROM invtypes AS it INNER JOIN \
invgroups AS ig ON it.groupID = ig.groupID INNER JOIN invcategories AS ic ON \
ig.categoryID = ic.categoryID WHERE it.published = 1 AND ic.categoryID IN \
(7, 8, 18, 20, 32)'
QUERY_TYPEID_GROUPID = 'SELECT groupID FROM invtypes WHERE typeID = ? LIMIT 1'
QUERY_GROUPID_CATEGORYID = 'SELECT categoryID FROM invgroups WHERE \
groupID = ? LIMIT 1'
QUERY_TYPEID_PARENTTYPEID = 'SELECT parentTypeID FROM invmetatypes WHERE \
typeID = ? LIMIT 1'
QUERY_TYPEID_MARKETGROUPID = 'SELECT marketGroupID FROM invtypes WHERE \
typeID = ? LIMIT 1'
QUERY_TYPEID_TYPENAME = 'SELECT typeName FROM invtypes WHERE typeID = ? \
LIMIT 1'
QUERY_MARKETGROUPID_PARENTGROUPID = 'SELECT parentGroupID FROM \
invmarketgroups WHERE marketGroupID = ? LIMIT 1'
QUERY_EFFECTID_TYPEID = 'SELECT typeID FROM dgmtypeeffects WHERE effectID = ?'
# Queries for printing
QUERY_GROUPID_GROUPNAME = 'SELECT groupName FROM invgroups WHERE groupID = ? \
LIMIT 1'
QUERY_CATEGORYID_CATEGORYNAME = 'SELECT categoryName FROM invcategories \
WHERE categoryID = ? LIMIT 1'
QUERY_MARKETGROUPID_MARKETGROUPNAME = 'SELECT marketGroupName FROM \
invmarketgroups WHERE marketGroupID = ? LIMIT 1'
QUERY_TYPEID_ATTRIBS = 'SELECT da.attributeName, dta.value FROM dgmattribs AS \
da INNER JOIN dgmtypeattribs AS dta ON dta.attributeID = da.attributeID WHERE \
dta.typeID = ?'
QUERY_TYPEID_BASEATTRIBS = 'SELECT volume, mass, capacity FROM invtypes WHERE \
typeID = ?'
QUERY_TYPEID_METAGROUPID = 'SELECT metaGroupID FROM invmetatypes WHERE typeID = ?'
QUERY_METAGROUPNAME_METAGROUPID = 'SELECT metaGroupName FROM invmetagroups WHERE metaGroupID = ?'

# Compose list of effects w/o symbols which eos doesn't take into
# consideration, we'll use it to find proper effect IDs from file
# names
globalmap_effectnameeos_effectid = {}
STRIPSPEC = "[^A-Za-z0-9]"
cursor.execute(QUERY_ALLEFFECTS)
for row in cursor:
    effectid = row[0]
    effectnamedb = row[1]
    effectnameeos = re.sub(STRIPSPEC, "", effectnamedb)
    # There may be different effects with the same name, so form
    # sets of IDs
    if not effectnameeos in globalmap_effectnameeos_effectid:
        globalmap_effectnameeos_effectid[effectnameeos] = set()
    globalmap_effectnameeos_effectid[effectnameeos].add(effectid)

# Published types set
publishedtypes = set()
cursor.execute(QUERY_PUBLISHEDTYPEIDS)
for row in cursor:
    publishedtypes.add(row[0])

# Compose group maps
# { groupid : set(typeid) }
globalmap_groupid_typeid = {}
# { typeid : groupid }
globalmap_typeid_groupid = {}
for typeid in publishedtypes:
    groupid = 0
    cursor.execute(QUERY_TYPEID_GROUPID, (typeid,))
    for row in cursor:
        groupid = row[0]
    if not groupid in globalmap_groupid_typeid:
        globalmap_groupid_typeid[groupid] = set()
    globalmap_groupid_typeid[groupid].add(typeid)
    globalmap_typeid_groupid[typeid] = groupid

# Category maps
# { categoryid : set(typeid) }
globalmap_categoryid_typeid =  {}
# { typeid : categoryid }
globalmap_typeid_categoryid =  {}
for typeid in publishedtypes:
    categoryid = 0
    cursor.execute(QUERY_GROUPID_CATEGORYID,
                   (globalmap_typeid_groupid[typeid],))
    for row in cursor:
        categoryid = row[0]
    if not categoryid in globalmap_categoryid_typeid:
        globalmap_categoryid_typeid[categoryid] = set()
    globalmap_categoryid_typeid[categoryid].add(typeid)
    globalmap_typeid_categoryid[typeid] = categoryid

# Base type maps
# { basetypeid : set(typeid) }
globalmap_basetypeid_typeid =  {}
# { typeid : basetypeid }
globalmap_typeid_basetypeid =  {}
for typeid in publishedtypes:
    # Not all typeIDs in the database have baseTypeID, so assign some
    # default value to it
    basetypeid = 0
    cursor.execute(QUERY_TYPEID_PARENTTYPEID, (typeid,))
    for row in cursor:
        basetypeid = row[0]
    # If base type is not published or is not set in database, consider
    # item as variation of self
    if basetypeid not in publishedtypes:
        basetypeid = typeid
    if not basetypeid in globalmap_basetypeid_typeid:
        globalmap_basetypeid_typeid[basetypeid] = set()
    globalmap_basetypeid_typeid[basetypeid].add(typeid)
    globalmap_typeid_basetypeid[typeid] = basetypeid

# Market group maps - we won't use these for further processing, but
# just as helper for composing other maps
# { marketgroupid : set(typeid) }
globalmap_marketgroupid_typeid =  {}
# { typeid : set(marketgroupid) }
globalmap_typeid_marketgroupid =  {}
for typeid in publishedtypes:
    marketgroupid = 0
    cursor.execute(QUERY_TYPEID_MARKETGROUPID, (typeid,))
    for row in cursor:
        marketgroupid = row[0]
    if not marketgroupid:
        continue
    if not marketgroupid in globalmap_marketgroupid_typeid:
        globalmap_marketgroupid_typeid[marketgroupid] = set()
    globalmap_marketgroupid_typeid[marketgroupid].add(typeid)
# Copy items to all parent market groups
INITIALMARKETGROUPIDS = tuple(globalmap_marketgroupid_typeid)
for marketgroupid in INITIALMARKETGROUPIDS:
    # Limit depths for case if database will refer to groups making
    # the loop
    cyclingmarketgroupid = marketgroupid
    for depth in range(20):
        cursor_parentmarket = db.cursor()
        cursor_parentmarket.execute(QUERY_MARKETGROUPID_PARENTGROUPID,
                                    (cyclingmarketgroupid,))
        for row in cursor_parentmarket:
            cyclingmarketgroupid = row[0]
        if cyclingmarketgroupid:
            if not cyclingmarketgroupid in globalmap_marketgroupid_typeid:
                globalmap_marketgroupid_typeid[cyclingmarketgroupid] = set()
            globalmap_marketgroupid_typeid[cyclingmarketgroupid].update\
            (globalmap_marketgroupid_typeid[marketgroupid])
        else: break
# Now, make a reverse map
for marketgroupid, typeidset in globalmap_marketgroupid_typeid.items():
    for typeid in typeidset:
        if not typeid in globalmap_typeid_marketgroupid:
            globalmap_typeid_marketgroupid[typeid] = set()
        globalmap_typeid_marketgroupid[typeid].add(marketgroupid)

# Combine market groups and variations
# { marketgroupid : set(typeidwithvariations) }
globalmap_marketgroupid_typeidwithvariations = \
copy.deepcopy(globalmap_marketgroupid_typeid)
# { typeidwithvariations : set(marketgroupid) }
globalmap_typeidwithvariations_marketgroupid = {}
for marketgroupid in globalmap_marketgroupid_typeidwithvariations:
    typestoadd = set()
    for typeid in globalmap_marketgroupid_typeidwithvariations[marketgroupid]:
        if typeid in globalmap_basetypeid_typeid:
            for variationid in globalmap_basetypeid_typeid[typeid]:
                # Do not include items which have market group, even if
                # they're variation
                if not variationid in globalmap_typeid_marketgroupid:
                    typestoadd.add(variationid)
    globalmap_marketgroupid_typeidwithvariations[marketgroupid].update\
    (typestoadd)
# Make reverse map using simple way too
for marketgroupid, typeidwithvariationsset in \
globalmap_marketgroupid_typeidwithvariations.items():
    for typeid in typeidwithvariationsset:
        if not typeid in globalmap_typeidwithvariations_marketgroupid:
            globalmap_typeidwithvariations_marketgroupid[typeid] = set()
        globalmap_typeidwithvariations_marketgroupid[typeid].add(marketgroupid)


nonmarket = set()
for typeid in publishedtypes:
    if not typeid in globalmap_typeidwithvariations_marketgroupid:
        nonmarket.add(typeid)

def getItemAttrs(typeid):
    attrs = {}
    cursor.execute(QUERY_TYPEID_ATTRIBS, (typeid,))
    for row in cursor:
        attrs[row[0]] = row[1]
    cursor.execute(QUERY_TYPEID_BASEATTRIBS, (typeid,))
    for row in cursor:
        if row[0] is not None:
            attrs["volume"] = row[0]
        if row[1] is not None:
            attrs["mass"] = row[1]
        if row[2] is not None:
            attrs["capacity"] = row[2]
    return attrs

def suggestMktGrp(typeid, mode="grp"):
    typecat = globalmap_typeid_categoryid[typeid]
    catname = ""
    cursor.execute(QUERY_CATEGORYID_CATEGORYNAME, (typecat,))
    for row in cursor:
        catname = row[0]
    typename = ""
    cursor.execute(QUERY_TYPEID_TYPENAME, (typeid,))
    for row in cursor:
        typename = row[0]
    if catname.lower() == "module" and "civilian" in typename.lower():
        return 760
    attrs = getItemAttrs(typeid)
    implantness = None
    boosterness = None
    cpu = None
    power = None
    droneBandwidthUsed = None
    volume = None
    if "implantness" in attrs:
        implantness = attrs["implantness"]
    if "boosterness" in attrs:
        boosterness = attrs["boosterness"]
    if "cpu" in attrs:
        cpu = attrs["cpu"]
    if "power" in attrs:
        power = attrs["power"]
    if "droneBandwidthUsed" in attrs:
        droneBandwidthUsed = attrs["droneBandwidthUsed"]
    if "volume" in attrs:
        volume = attrs["volume"]
    if mode == "grp":
        grp = globalmap_typeid_groupid[typeid]
        comrades = globalmap_groupid_typeid[grp]
    elif mode == "cat":
        cat = globalmap_typeid_categoryid[typeid]
        comrades = globalmap_categoryid_typeid[cat]
    mktgrps_w_cos = {}
    for co in comrades:
        marketgroupid = 0
        cursor.execute(QUERY_TYPEID_MARKETGROUPID, (co,))
        for row in cursor:
            marketgroupid = row[0]
        if not marketgroupid:
            continue
        if not marketgroupid in mktgrps_w_cos:
            mktgrps_w_cos[marketgroupid] = 0.0
        similarity_factor = 1.0
        metagrp = 0
        cursor.execute(QUERY_TYPEID_METAGROUPID, (co,))
        for row in cursor:
            metagrp = row[0]
        if not metagrp in (0,1,2,14):
            similarity_factor *= 0.01
        if implantness or boosterness or cpu or power or droneBandwidthUsed or volume:
            cgrpattrs = getItemAttrs(co)
        if implantness:
            if "implantness" in cgrpattrs:
                if cgrpattrs["implantness"] != implantness:
                    similarity_factor *= 0.1
            else:
                similarity_factor *= 0.01
        if boosterness:
            if "boosterness" in cgrpattrs:
                if cgrpattrs["boosterness"] != boosterness:
                    similarity_factor *= 0.1
            else:
                similarity_factor *= 0.01
        if cpu:
            if "cpu" in cgrpattrs and cgrpattrs["cpu"]:
                    fct = cpu / cgrpattrs["cpu"]
                    if fct > 1:
                        fct = 1 / fct
                    similarity_factor *= fct
            else:
                similarity_factor *= 0.01
        if power:
            if "power" in cgrpattrs and cgrpattrs["power"]:
                fct = power / cgrpattrs["power"]
                if fct > 1:
                    fct = 1 / fct
                similarity_factor *= fct
            else:
                similarity_factor *= 0.01
        if droneBandwidthUsed:
            if "droneBandwidthUsed" in cgrpattrs:
                fct = droneBandwidthUsed / cgrpattrs["droneBandwidthUsed"]
                if fct > 1:
                    fct = 1 / fct
                similarity_factor *= fct
            else:
                similarity_factor *= 0.01
        if volume:
            if "volume" in cgrpattrs:
                fct = volume / cgrpattrs["volume"]
                if fct > 1:
                    fct = 1 / fct
                similarity_factor *= fct
            else:
                similarity_factor *= 0.01
        mktgrps_w_cos[marketgroupid] += similarity_factor
    if mktgrps_w_cos:
        winner = max(mktgrps_w_cos.keys(), key=lambda k: mktgrps_w_cos[k])
    else:
        winner = None
    return winner

def suggestMetaGrp(typeid):
    typename = ""
    cursor.execute(QUERY_TYPEID_TYPENAME, (typeid,))
    for row in cursor:
        typename = row[0]
    faction_affixes = ("Arch Angel", "Domination", "Blood", "Guristas", "Sansha", "Sanshas", "Shadow", "Guardian", "Serpentis",
                       "Caldari", "Imperial", "Gallente", "Federation", "Republic",
                       "Ammatar", "Khanid", "Thukker", "Syndicate", "Sisters", "Legion", "ORE",
                       "Nugoehuvi")
    deadspace_affixes = ("Gistii", "Gistum", "Gist",
                         "Corpii", "Corpum", "Corpus",
                         "Pithi", "Pithum", "Pith",
                         "Centii", "Centum", "Centus",
                         "Coreli", "Corelum", "Core")
    storyline_names = {"Akemon", "Michi", "Ogdin", "Pashan", "Shaqil", "Whelan Machorin", "Numon"}
    officer_names = ("Ahremen", "Brokara", "Brynn", "Chelm", "Cormack", "Draclira", "Estamel", "Gotan", "Hakim",
                     "Kaikka", "Mizuro", "Raysere", "Selynne", "Setele", "Tairei", "Thon", "Tuvan", "Vizan")
    storyline_pattern_general = "'[A-Za-z ]+'"
    storyline_pattern_names = "|".join("{0}".format(name) for name in storyline_names)
    faction_pattern = "({0}) ".format("|".join(faction_affixes))
    deadspace_pattern = "({0}) ".format("|".join(deadspace_affixes))
    officer_pattern = "({0}) ".format("|".join("{0}'s".format(name) for name in officer_names))

    attrs = getItemAttrs(typeid)
    if attrs.get("metaLevel") is not None:
        mlvl = attrs["metaLevel"]
        if mlvl in (0, 1, 2, 3, 4):
            meta = 1
        elif mlvl == 5:
            meta = 2
        elif mlvl in (6, 7):
            meta = 3
        elif mlvl in (8, 9):
            meta = 4
        elif mlvl in (11, 12, 13, 14):
            if re.search(deadspace_pattern, typename):
                meta = 6
            else:
                meta = 5
        else:
            meta = 1
    elif re.search(officer_pattern, typename):
        meta = 5
    elif re.search(deadspace_pattern, typename):
        meta = 6
    elif re.search(faction_pattern, typename):
        meta = 4
    elif re.search(storyline_pattern_names, typename):
        meta = 3
    elif re.search(storyline_pattern_general, typename) and not "Hardwiring" in typename:
        meta = 3
    else:
        meta = 1

    return meta


map_typeid_stuff = {}
map_typeid_stuff2 = {}

for typeid in nonmarket:
    typename = ""
    cursor.execute(QUERY_TYPEID_TYPENAME, (typeid,))
    for row in cursor:
        typename = row[0]
    grpname = ""
    cursor.execute(QUERY_GROUPID_GROUPNAME, (globalmap_typeid_groupid[typeid],))
    for row in cursor:
        grpname = row[0]
    mkt = suggestMktGrp(typeid)
    if mkt is None:
        mkt = suggestMktGrp(typeid, mode="cat")
    meta = suggestMetaGrp(typeid)
    attrs = getItemAttrs(typeid)
    if mkt:
        map_typeid_stuff[typeid] = (mkt, meta)
        marketgroupname = ""
        cursor.execute(QUERY_MARKETGROUPID_MARKETGROUPNAME,
                       (mkt,))
        for row in cursor:
            marketgroupname = row[0]
        # Prepend market group name with its parents names
        prependparentid = mkt
        # Limit depth to avoid looping, as usual
        for depth in range(20):
            cursor_parentmarket = db.cursor()
            cursor_parentmarket.execute(QUERY_MARKETGROUPID_PARENTGROUPID,
                                        (prependparentid,))
            for row in cursor_parentmarket:
                prependparentid = row[0]
            if prependparentid:
                cursor_parentmarket2 = db.cursor()
                cursor_parentmarket2.execute(QUERY_MARKETGROUPID_MARKETGROUPNAME,
                               (prependparentid,))
                for row in cursor_parentmarket2:
                    marketgroupname = "{0} > {1}".format(row[0],
                                                         marketgroupname)
            else:
                break
    else:
        marketgroupname = "None"

    map_typeid_stuff2[typename] = (mkt, marketgroupname)


    metagroupname = ""
    cursor.execute(QUERY_METAGROUPNAME_METAGROUPID,
                   (meta,))
    for row in cursor:
        metagroupname = row[0]

    #print("---\nItem: {0}\nGroup: {1}\nSuggested market group: {2} ({3})\nMeta group: {4}".format(typename, grpname, marketgroupname, mkt, metagroupname))

#print("\n\nmap = {{ {0} }}".format(", ".join("{0}: ({1}, {2})".format(key, map_typeid_stuff[key][0], map_typeid_stuff[key][1]) for key in sorted(map_typeid_stuff))))
print("---\n{0}".format("\n".join("\"{0}\": {1}, # {2}".format(key, map_typeid_stuff2[key][0], map_typeid_stuff2[key][1]) for key in sorted(map_typeid_stuff2))))

########NEW FILE########
__FILENAME__ = itemDiff
#!/usr/bin/env python3
#===============================================================================
# Copyright (C) 2010-2011 Anton Vorobyov
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with eos.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================


'''
This script is used to compare two different database versions.
It shows removed/changed/new items with list of changed effects,
changed attributes and effects which were renamed
'''

import argparse
import os.path
import re
import sqlite3

parser = argparse.ArgumentParser(description="Compare two databases generated from eve dump to find eos-related differences")
parser.add_argument("-o", "--old", type=str, required=True, help="path to old cache data dump")
parser.add_argument("-n", "--new", type=str, required=True, help="path to new cache data dump")
parser.add_argument("-g", "--nogroups", action="store_false", default=True, dest="groups", help="don't show changed groups")
parser.add_argument("-e", "--noeffects", action="store_false", default=True, dest="effects", help="don't show list of changed effects")
parser.add_argument("-a", "--noattributes", action="store_false", default=True, dest="attributes", help="don't show list of changed attributes")
parser.add_argument("-r", "--norenames", action="store_false", default=True, dest="renames", help="don't show list of renamed data")
args = parser.parse_args()

# Open both databases and get their cursors
old_db = sqlite3.connect(os.path.expanduser(args.old))
old_cursor = old_db.cursor()
new_db = sqlite3.connect(os.path.expanduser(args.new))
new_cursor = new_db.cursor()

# Force some of the items to make them published
FORCEPUB_TYPES = ("Ibis", "Impairor", "Velator", "Reaper")
OVERRIDES_TYPEPUB = 'UPDATE invtypes SET published = 1 WHERE typeName = ?'
for typename in FORCEPUB_TYPES:
    old_cursor.execute(OVERRIDES_TYPEPUB, (typename,))
    new_cursor.execute(OVERRIDES_TYPEPUB, (typename,))

# Initialization of few things used by both changed/renamed effects list
effectspath = os.path.join("..", "..", "effects")
implemented = set()

for filename in os.listdir(effectspath):
    basename, extension = filename.rsplit('.', 1)
    # Ignore non-py files and exclude implementation-specific 'effect'
    if extension == "py" and basename not in ("__init__",):
        implemented.add(basename)

# Effects' names are used w/o any special symbols by eos
stripspec = "[^A-Za-z0-9]"

# Method to get data if effect is implemented in eos or not
def geteffst(effectname):
    eosname = re.sub(stripspec, "", effectname).lower()
    if eosname in implemented:
        impstate = True
    else:
        impstate = False
    return impstate

def findrenames(ren_dict, query, strip=False):

    old_namedata = {}
    new_namedata = {}

    for cursor, dictionary in ((old_cursor, old_namedata), (new_cursor, new_namedata)):
        cursor.execute(query)
        for row in cursor:
            id = row[0]
            name = row[1]
            if strip is True:
                name = re.sub(stripspec, "", name)
            dictionary[id] = name

    for id in set(old_namedata.keys()).intersection(new_namedata.keys()):
        oldname = old_namedata[id]
        newname = new_namedata[id]
        if oldname != newname:
            ren_dict[id] = (oldname, newname)
    return

def printrenames(ren_dict, title, implementedtag=False):
    if len(ren_dict) > 0:
        print('\nRenamed ' + title + ':')
        for id in sorted(ren_dict):
            couple = ren_dict[id]
            if implementedtag:
                print("\n[{0}] \"{1}\"\n[{2}] \"{3}\"".format(geteffst(couple[0]), couple[0], geteffst(couple[1]), couple[1]))
            else:
                print("\n\"{0}\"\n\"{1}\"".format(couple[0], couple[1]))

groupcats = {}
def getgroupcat(grp):
    """Get group category from the new db"""
    if grp in groupcats:
        cat = groupcats[grp]
    else:
        query = 'SELECT categoryID FROM invgroups WHERE groupID = ?'
        new_cursor.execute(query, (grp,))
        cat = 0
        for row in new_cursor:
            cat = row[0]
        groupcats[grp] = cat
    return cat

itemnames = {}
def getitemname(item):
    """Get item name from the new db"""
    if item in itemnames:
        name = itemnames[item]
    else:
        query = 'SELECT typeName FROM invtypes WHERE typeID = ?'
        new_cursor.execute(query, (item,))
        name = ""
        for row in new_cursor:
            name = row[0]
        if not name:
            old_cursor.execute(query, (item,))
            for row in old_cursor:
                name = row[0]
        itemnames[item] = name
    return name

groupnames = {}
def getgroupname(grp):
    """Get group name from the new db"""
    if grp in groupnames:
        name = groupnames[grp]
    else:
        query = 'SELECT groupName FROM invgroups WHERE groupID = ?'
        new_cursor.execute(query, (grp,))
        name = ""
        for row in new_cursor:
            name = row[0]
        if not name:
            old_cursor.execute(query, (grp,))
            for row in old_cursor:
                name = row[0]
        groupnames[grp] = name
    return name

effectnames = {}
def geteffectname(effect):
    """Get effect name from the new db"""
    if effect in effectnames:
        name = effectnames[effect]
    else:
        query = 'SELECT effectName FROM dgmeffects WHERE effectID = ?'
        new_cursor.execute(query, (effect,))
        name = ""
        for row in new_cursor:
            name = row[0]
        if not name:
            old_cursor.execute(query, (effect,))
            for row in old_cursor:
                name = row[0]
        effectnames[effect] = name
    return name

attrnames = {}
def getattrname(attr):
    """Get attribute name from the new db"""
    if attr in attrnames:
        name = attrnames[attr]
    else:
        query = 'SELECT attributeName FROM dgmattribs WHERE attributeID = ?'
        new_cursor.execute(query, (attr,))
        name = ""
        for row in new_cursor:
            name = row[0]
        if not name:
            old_cursor.execute(query, (attr,))
            for row in old_cursor:
                name = row[0]
        attrnames[attr] = name
    return name

# State table
S = {"unchanged": 0,
     "removed": 1,
     "changed": 2,
     "added": 3 }

if args.effects or args.attributes or args.groups:
    # Format:
    # Key: item id
    # Value: [groupID, set(effects), {attribute id : value}]
    old_itmdata = {}
    new_itmdata = {}

    for cursor, dictionary in ((old_cursor, old_itmdata), (new_cursor, new_itmdata)):
        # Compose list of items we're interested in, filtered by category
        query = 'SELECT it.typeID, it.groupID FROM invtypes AS it INNER JOIN invgroups AS ig ON it.groupID = ig.groupID INNER JOIN invcategories AS ic ON ig.categoryID = ic.categoryID WHERE it.published = 1 AND ic.categoryName IN ("Ship", "Module", "Charge", "Skill", "Drone", "Implant", "Subsystem")'
        cursor.execute(query)
        for row in cursor:
            itemid = row[0]
            groupID = row[1]
            # Initialize container for the data for each item with empty stuff besides groupID
            dictionary[itemid] = [groupID, set(), {}]
        # Add items filtered by group
        query = 'SELECT it.typeID, it.groupID FROM invtypes AS it INNER JOIN invgroups AS ig ON it.groupID = ig.groupID WHERE it.published = 1 AND ig.groupName IN ("Effect Beacon")'
        cursor.execute(query)
        for row in cursor:
            itemid = row[0]
            groupID = row[1]
            dictionary[itemid] = [groupID, set(), {}]

        if args.effects:
            # Pull all eff
            query = 'SELECT it.typeID, de.effectID FROM invtypes AS it INNER JOIN dgmtypeeffects AS dte ON dte.typeID = it.typeID INNER JOIN dgmeffects AS de ON de.effectID = dte.effectID WHERE it.published = 1'
            cursor.execute(query)
            for row in cursor:
                itemid = row[0]
                effectID = row[1]
                # Process only items we need
                if itemid in dictionary:
                    # Add effect to the set
                    effectSet = dictionary[itemid][1]
                    effectSet.add(effectID)

        if args.attributes:
            # Add base attributes to our data
            query = 'SELECT it.typeID, it.mass, it.capacity, it.volume FROM invtypes AS it'
            cursor.execute(query)
            for row in cursor:
                itemid = row[0]
                if itemid in dictionary:
                    attrdict = dictionary[itemid][2]
                    # Add base attributes: mass (4), capacity (38) and volume (161)
                    attrdict[4] = row[1]
                    attrdict[38] = row[2]
                    attrdict[161] = row[3]

            # Add attribute data for other attributes
            query = 'SELECT dta.typeID, dta.attributeID, dta.value FROM dgmtypeattribs AS dta'
            cursor.execute(query)
            for row in cursor:
                itemid = row[0]
                if itemid in dictionary:
                    attrid = row[1]
                    attrval = row[2]
                    attrdict = dictionary[itemid][2]
                    if attrid in attrdict:
                        print("Warning: base attribute is described in non-base attribute table")
                    else:
                        attrdict[attrid] = attrval

    # Get set of IDs from both dictionaries
    items_old = set(old_itmdata.keys())
    items_new = set(new_itmdata.keys())

    # Format:
    # Key: item state
    # Value: {item id: ((group state, old group, new group), {effect state: set(effects)}, {attribute state: {attributeID: (old value, new value)}})}
    global_itmdata = {}

    # Initialize it
    for state in S:
        global_itmdata[S[state]] = {}


    # Fill all the data for removed items
    for item in items_old.difference(items_new):
        # Set item state to removed
        state = S["removed"]
        # Set only old group for item
        oldgroup = old_itmdata[item][0]
        groupdata = (S["unchanged"], oldgroup, None)
        # Set old set of effects and mark all as unchanged
        effectsdata = {}
        effectsdata[S["unchanged"]] = set()
        if args.effects:
            oldeffects = old_itmdata[item][1]
            effectsdata[S["unchanged"]].update(oldeffects)
        # Set old set of attributes and mark all as unchanged
        attrdata = {}
        attrdata[S["unchanged"]] = {}
        if args.attributes:
            oldattrs = old_itmdata[item][2]
            for attr in oldattrs:
                # NULL will mean there's no such attribute in db
                attrdata[S["unchanged"]][attr] = (oldattrs[attr], "NULL")
        # Fill global dictionary with data we've got
        global_itmdata[state][item] = (groupdata, effectsdata, attrdata)


    # Now, for added items
    for item in items_new.difference(items_old):
        # Set item state to added
        state = S["added"]
        # Set only new group for item
        newgroup = new_itmdata[item][0]
        groupdata = (S["unchanged"], None, newgroup)
        # Set new set of effects and mark all as unchanged
        effectsdata = {}
        effectsdata[S["unchanged"]] = set()
        if args.effects:
            neweffects = new_itmdata[item][1]
            effectsdata[S["unchanged"]].update(neweffects)
        # Set new set of attributes and mark all as unchanged
        attrdata = {}
        attrdata[S["unchanged"]] = {}
        if args.attributes:
            newattrs = new_itmdata[item][2]
            for attr in newattrs:
                # NULL will mean there's no such attribute in db
                attrdata[S["unchanged"]][attr] = ("NULL", newattrs[attr])
        # Fill global dictionary with data we've got
        global_itmdata[state][item] = (groupdata, effectsdata, attrdata)

    # Now, check all the items which exist in both databases
    for item in items_old.intersection(items_new):
        # Set group data for an item
        oldgroup = old_itmdata[item][0]
        newgroup = new_itmdata[item][0]
        # If we're not asked to compare groups, mark them as unchanged anyway
        groupdata = (S["changed"] if oldgroup != newgroup and args.groups else S["unchanged"], oldgroup, newgroup)
        # Fill effects data into appropriate groups
        effectsdata = {}
        for state in S:
            # We do not have changed effects whatsoever
            if state != "changed":
                effectsdata[S[state]] = set()
        if args.effects:
            oldeffects = old_itmdata[item][1]
            neweffects = new_itmdata[item][1]
            effectsdata[S["unchanged"]].update(oldeffects.intersection(neweffects))
            effectsdata[S["removed"]].update(oldeffects.difference(neweffects))
            effectsdata[S["added"]].update(neweffects.difference(oldeffects))
        # Go through all attributes, filling global data dictionary
        attrdata = {}
        for state in S:
            attrdata[S[state]] = {}
        if args.attributes:
            oldattrs = old_itmdata[item][2]
            newattrs = new_itmdata[item][2]
            for attr in set(oldattrs.keys()).union(newattrs.keys()):
                # NULL will mean there's no such attribute in db
                oldattr = oldattrs.get(attr, "NULL")
                newattr = newattrs.get(attr, "NULL")
                attrstate = S["unchanged"]
                if oldattr == "NULL" and newattr != "NULL":
                    attrstate = S["added"]
                elif oldattr != "NULL" and newattr == "NULL":
                    attrstate = S["removed"]
                elif oldattr != newattr:
                    attrstate = S["changed"]
                attrdata[attrstate][attr] = (oldattr, newattr)
        # Consider item as unchanged by default and set it to change when we see any changes in sub-items
        state = S["unchanged"]
        if state == S["unchanged"] and groupdata[0] != S["unchanged"]:
            state = S["changed"]
        if state == S["unchanged"] and (len(effectsdata[S["removed"]]) > 0 or len(effectsdata[S["added"]]) > 0):
            state = S["changed"]
        if state == S["unchanged"] and (len(attrdata[S["removed"]]) > 0 or len(attrdata[S["changed"]]) > 0 or len(attrdata[S["added"]]) > 0):
            state = S["changed"]
        # Fill global dictionary with data we've got
        global_itmdata[state][item] = (groupdata, effectsdata, attrdata)

# As eos uses names as unique IDs in lot of places, we have to keep track of name changes
if args.renames:
    ren_effects = {}
    query = 'SELECT effectID, effectName FROM dgmeffects'
    findrenames(ren_effects, query, strip = True)

    ren_attributes = {}
    query = 'SELECT attributeID, attributeName FROM dgmattribs'
    findrenames(ren_attributes, query)

    ren_categories = {}
    query = 'SELECT categoryID, categoryName FROM invcategories'
    findrenames(ren_categories, query)

    ren_groups = {}
    query = 'SELECT groupID, groupName FROM invgroups'
    findrenames(ren_groups, query)

    ren_marketgroups = {}
    query = 'SELECT marketGroupID, marketGroupName FROM invmarketgroups'
    findrenames(ren_marketgroups, query)

    ren_items = {}
    query = 'SELECT typeID, typeName FROM invtypes'
    findrenames(ren_items, query)

# Get db metadata
old_meta = {}
new_meta = {}
query = 'SELECT fieldName, fieldValue FROM metadata'
old_cursor.execute(query)
for row in old_cursor:
    old_meta[row[0]] = row[1]
new_cursor.execute(query)
for row in new_cursor:
    new_meta[row[0]] = row[1]

# Print jobs
print("Comparing databases:\n{0}-{1}\n{2}-{3}\n".format(old_meta.get("version"), old_meta.get("release"),
                                                        new_meta.get("version"), new_meta.get("release")))
if args.effects or args.attributes or args.groups:
    # Print legend only when there're any interesting changes
    if len(global_itmdata[S["removed"]]) > 0 or len(global_itmdata[S["changed"]]) > 0 or len(global_itmdata[S["added"]]) > 0:
        genleg = "[+] - new item\n[-] - removed item\n[*] - changed item\n"
        grpleg = "(x => y) - group changes\n" if args.groups else ""
        attreffleg = "  [+] - effect or attribute has been added to item\n  [-] - effect or attribute has been removed from item\n" if args.attributes or args.effects else ""
        effleg = "  [y] - effect is implemented\n  [n] - effect is not implemented\n" if args.effects else ""
        print("{0}{1}{2}{3}\nItems:".format(genleg, grpleg, attreffleg, effleg))

        # Make sure our states are sorted
        stateorder = sorted(global_itmdata)

        TG = {S["unchanged"]: "+", S["changed"]: "*",
              S["removed"]: "-",
              S["added"]: "+"}

        # Cycle through states
        for itmstate in stateorder:
            # Skip unchanged items
            if itmstate == S["unchanged"]:
                continue
            items = global_itmdata[itmstate]
            # Sort by name first
            itemorder = sorted(items, key=lambda item: getitemname(item))
            # Then by group id
            itemorder = sorted(itemorder, key=lambda item: items[item][0][2] or items[item][0][1])
            # Then by category id
            itemorder = sorted(itemorder, key=lambda item: getgroupcat(items[item][0][2] or items[item][0][1]))

            for item in itemorder:
                groupdata = items[item][0]
                groupstr = " ({0} => {1})".format(getgroupname(groupdata[1]), getgroupname(groupdata[2])) if groupdata[0] == S["changed"] else ""
                print("\n[{0}] {1}{2}".format(TG[itmstate], getitemname(item), groupstr))

                effdata = items[item][1]
                for effstate in stateorder:
                    # Skip unchanged effect sets, but always include them for added or removed ships
                    # Also, always skip empty data
                    if (effstate == S["unchanged"] and itmstate not in (S["removed"], S["added"])) or effstate not in effdata:
                        continue
                    effects = effdata[effstate]
                    efforder = sorted(effects, key=lambda eff: geteffectname(eff))
                    for eff in efforder:
                        # Take tag from item if item was added or removed
                        tag = TG[effstate] if itmstate not in (S["removed"], S["added"]) else TG[itmstate]
                        print("  [{0}|{1}] {2}".format(tag, "y" if geteffst(geteffectname(eff)) else "n", geteffectname(eff)))

                attrdata = items[item][2]
                for attrstate in stateorder:
                    # Skip unchanged and empty attribute sets, also skip attributes display for added and removed items
                    if (attrstate == S["unchanged"] and itmstate != S["added"]) or itmstate in (S["removed"], ) or attrstate not in attrdata:
                        continue
                    attrs = attrdata[attrstate]
                    attrorder = sorted(attrs, key=lambda attr: getattrname(attr))
                    for attr in attrorder:
                        valline = ""
                        if attrs[attr][0] == "NULL" or itmstate == S["added"]:
                            valline = "{0}".format(attrs[attr][1] or 0)
                        elif attrs[attr][1] == "NULL":
                            valline = "{0}".format(attrs[attr][0] or 0)
                        else:
                            valline = "{0} => {1}".format(attrs[attr][0] or 0, attrs[attr][1] or 0)
                        print("  [{0}] {1}: {2}".format(TG[attrstate], getattrname(attr), valline))

if args.renames:
    title = 'effects'
    printrenames(ren_effects, title, implementedtag=True)

    title = 'attributes'
    printrenames(ren_attributes, title)

    title = 'categories'
    printrenames(ren_categories, title)

    title = 'groups'
    printrenames(ren_groups, title)

    title = 'market groups'
    printrenames(ren_marketgroups, title)

    title = 'items'
    printrenames(ren_items, title)

########NEW FILE########
__FILENAME__ = jsonToSql
#!/usr/bin/env python3
#======================================================================
# Copyright (C) 2012 Diego Duclos
#
# This file is part of eos.
#
# eos is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as
# published by the Free Software Foundation, either version 3 of
# the License, or (at your option) any later version.
#
# eos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with eos.  If not, see <http://www.gnu.org/licenses/>.
#======================================================================

import os
import sys

# Add eos root path to sys.path so we can import ourselves
path = os.path.dirname(unicode(__file__, sys.getfilesystemencoding()))
sys.path.append(os.path.realpath(os.path.join(path, "..", "..", "..")))

import sqlite3
import json
import argparse

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="This scripts dumps effects from an sqlite cache dump to mongo")
    parser.add_argument("-d", "--db", required=True, type=str, help="The sqlalchemy connectionstring, example: sqlite:///c:/tq.db")
    parser.add_argument("-j", "--json", required=True, type=str, help="The path to the json dum")
    args = parser.parse_args()

    jsonPath = os.path.expanduser(args.json)

    # Import eos.config first and change it
    import eos.config
    eos.config.gamedata_connectionstring = args.db
    eos.config.debug = False

    # Now thats done, we can import the eos modules using the config
    import eos.db
    import eos.gamedata

    # Create the database tables
    eos.db.gamedata_meta.create_all()

    # Config dict
    tables = {"dgmattribs": eos.gamedata.AttributeInfo,
              "dgmeffects": eos.gamedata.EffectInfo,
              "dgmtypeattribs": eos.gamedata.Attribute,
              "dgmtypeeffects": eos.gamedata.Effect,
              "dgmunits": eos.gamedata.Unit,
              "icons": eos.gamedata.Icon,
              "invcategories": eos.gamedata.Category,
              "invgroups": eos.gamedata.Group,
              "invmetagroups": eos.gamedata.MetaGroup,
              "invmetatypes": eos.gamedata.MetaType,
              "invtypes": eos.gamedata.Item,
              "phobostraits": eos.gamedata.Traits,
              "marketProxy()_GetMarketGroups()": eos.gamedata.MarketGroup}

    fieldMapping = {"icons": {"id": "iconID"}}
    data = {}

    # Dump all data to memory so we can easely cross check ignored rows
    for jsonName, cls in tables.iteritems():
        f = open(os.path.join(jsonPath, "{}.json".format(jsonName)))
        data[jsonName] = json.load(f, encoding='cp1252')

    # Do some preprocessing to make our job easier
    invTypes = set()
    for row in data["invtypes"]:
        if row["published"]:
            invTypes.add(row["typeID"])

    # ignore checker
    def isIgnored(file, row):
        if file == "invtypes" and not row["published"]:
            return True
        elif file == "dgmtypeeffects" and not row["typeID"] in invTypes:
            return True
        elif file == "dgmtypeattribs" and not row["typeID"] in invTypes:
            return True
        elif file == "invmetatypes" and not row["typeID"] in invTypes:
            return True

        return False

    # Loop through each json file and write it away, checking ignored rows
    for jsonName, table in data.iteritems():
        fieldMap = fieldMapping.get(jsonName, {})
        print "processing {}".format(jsonName)
        for row in table:
            # We don't care about some kind of rows, filter it out if so
            if not isIgnored(jsonName, row):
                instance = tables[jsonName]()
                # fix for issue 80
                if jsonName is "icons" and "res:/UI/Texture/Icons/" in str(row['iconFile']):
                    row['iconFile'] = row['iconFile'].replace('res:/UI/Texture/Icons/','').replace('.png','')
                for k, v in row.iteritems():
                    setattr(instance, fieldMap.get(k, k), v)

                eos.db.gamedata_session.add(instance)

        eos.db.gamedata_session.commit()

    print("done")

########NEW FILE########
__FILENAME__ = nighty
#!/usr/bin/env python

from optparse import OptionParser
import os.path
import shutil
import tempfile
import sys
import tarfile
import datetime
import random
import string

class FileStub():
    def write(self, *args):
        pass

    def flush(self, *args):
        pass

def id_generator(size=6, chars=string.ascii_uppercase + string.digits):
    return ''.join(random.choice(chars) for x in range(size))

if __name__ == "__main__":
    oldstd = sys.stdout
    parser = OptionParser()
    parser.add_option("-s", "--skeleton", dest="skeleton", help="Location of skeleton directory")
    parser.add_option("-b", "--base", dest="base", help="location of the base directory")
    parser.add_option("-d", "--destination", dest="destination", help="where to copy our archive")
    parser.add_option("-t", "--static", dest="static", help="directory containing static files")
    parser.add_option("-q", "--quiet", dest="silent", action="store_true")
    options, args = parser.parse_args()

    if options.skeleton is None or options.base is None or options.destination is None:
        print "Need --skeleton argument as well as --base and --destination argument"
        parser.print_help()
        sys.exit()

    if options.silent:
        sys.stdout = FileStub()

    randomId = id_generator()
    infoDict = {}
    skeleton = os.path.expanduser(options.skeleton)
    info = execfile(os.path.join(skeleton, "info.py"), infoDict)
    now = datetime.datetime.now()
    now = "%04d%02d%02d" % (now.year, now.month, now.day)
    dirName = "nighty-build-%s-%s" % (now, randomId)
    dst = os.path.join(os.getcwd(), dirName)
    tmpFile = os.path.join(os.getcwd(), "nighty-build-%s-%s-%s.tar.bz2" % (now, infoDict["os"], randomId))
    config = os.path.join(skeleton, "config.py")
    destination = os.path.expanduser(options.destination)

    i = 0
    gitData = (".git", ".gitignore", ".gitmodules")
    def loginfo(path, names):
        global i
        i += 1
        if i % 10 == 0:
            sys.stdout.write(".")
            sys.stdout.flush()
        return gitData

    try:
        print "copying skeleton to ", dst
        i = 0
        shutil.copytree(skeleton, dst, ignore=loginfo)
        print ""

        base = os.path.join(dst, infoDict["base"])
        print "copying base to ", base

        i = 0
        for stuff in os.listdir(os.path.expanduser(options.base)):
            currSource = os.path.join(os.path.expanduser(options.base), stuff)
            currDest = os.path.join(base, stuff)
            if stuff in gitData:
                continue
            elif os.path.isdir(currSource):
                shutil.copytree(currSource, currDest, ignore=loginfo)
            else:
                shutil.copy2(currSource, currDest)

        print ""
        if os.path.exists(config):
            print "adding skeleton config file"
            shutil.copy2(config, base)


        if options.static is not None and os.path.exists(os.path.expanduser(options.static)):
            print "copying static data to ", os.path.join(base, "staticdata")
            static = os.path.expanduser(options.static)
            shutil.copytree(static, os.path.join(base, "staticdata"), ignore=loginfo)

        print "removing development data"
        paths = []
        paths.append(os.path.join(base, "eos", "tests"))
        paths.append(os.path.join(base, "eos", "utils", "scripts"))
        for path in paths:
            if os.path.exists(path):
                print path
                shutil.rmtree(path)


        print "copying done, making archive: ", tmpFile
        archive = tarfile.open(tmpFile, "w:bz2")
        print "making archive"
        archive.add(dst, arcname=infoDict["arcname"])
        print "closing"
        archive.close()
        print "copying archive to ", destination
        shutil.move(tmpFile, destination)
    except:
        print "encountered an error"
        raise
    finally:
        print "deleting tmp files"
        try:
            shutil.rmtree(dst)
            os.unlink(tmpFile)
        except:
            pass

    sys.stdout = oldstd
    if os.path.isdir(destination):
        print os.path.join(destination, os.path.split(tmpFile)[1])
    else:
        print destination

########NEW FILE########
__FILENAME__ = riskItems
"""
This is ugly, tricky and unreadable script which helps to detect which items should be tested,
based on how its current effects work.
"""
import sqlite3
import os.path
import copy
from optparse import OptionParser

parser = OptionParser()
parser.add_option("-d", "--database", help="path to eve cache data dump in \
sqlite format, default eos database path is used if none specified",
type="string", default=os.path.join("~", ".pyfa","eve.db"))
parser.add_option("-a", "--attr", help="find items with all of these attributes",
type="string", default="")
parser.add_option("-s", "--srq", help="find items with any of these skill requirements",
type="string", default="")
parser.add_option("-g", "--grp", help="find items from any of these groups",
type="string", default="")
parser.add_option("-z", "--nozero", action="store_true", help="ignore attributes with zero values",
default=False)
parser.add_option("-o", "--noone", action="store_true", help="ignore attributes with value equal to 1",
default=False)
parser.add_option("-t", "--tech12", action="store_true", help="show only t12 items (with exception for items with no t1 variations)",
default=False)
(options, args) = parser.parse_args()

if not options.attr:
    import sys

    sys.stderr.write("You need to specify an attribute name.\n")
    sys.exit()

# Connect to database and set up cursor
db = sqlite3.connect(os.path.expanduser(options.database))
cursor = db.cursor()

# As we don't rely on eos's overrides, we need to set them manually
OVERRIDES = '''
UPDATE invtypes SET published = '1' WHERE typeName = 'Freki';
UPDATE invtypes SET published = '1' WHERE typeName = 'Mimir';
UPDATE invtypes SET published = '1' WHERE typeName = 'Utu';
UPDATE invtypes SET published = '1' WHERE typeName = 'Adrestia';
'''
for statement in OVERRIDES.split(";\n"):
    cursor.execute(statement)

# Queries to get raw data
# Limit categories to Celestials (2, only for wormhole effects),
# Ships (6), Modules (7), Charges (8), Skills (16), Drones (18),
# Implants (20), Subsystems (32)
QUERY_PUBLISHEDTYPEIDS = 'SELECT it.typeID FROM invtypes AS it INNER JOIN \
invgroups AS ig ON it.groupID = ig.groupID INNER JOIN invcategories AS ic ON \
ig.categoryID = ic.categoryID WHERE it.published = 1 AND ic.categoryID IN \
(2, 6, 7, 8, 16, 18, 20, 32)'
QUERY_ATTRIBUTEID_TYPEID = "SELECT it.typeID, dta.value FROM invtypes AS it INNER JOIN \
dgmtypeattribs AS dta ON it.typeID = dta.typeID INNER JOIN dgmattribs AS da \
ON dta.attributeID = da.attributeID WHERE da.attributeID = ?"
QUERY_TYPEID_GROUPID = 'SELECT groupID FROM invtypes WHERE typeID = ? LIMIT 1'
QUERY_GROUPID_CATEGORYID = 'SELECT categoryID FROM invgroups WHERE \
groupID = ? LIMIT 1'
QUERY_TYPEID_PARENTTYPEID = 'SELECT parentTypeID FROM invmetatypes WHERE \
typeID = ? LIMIT 1'
QUERY_TYPEID_METAGROUPID = 'SELECT metaGroupID FROM invmetatypes WHERE \
typeID = ? LIMIT 1'
QUERY_TYPEID_SKILLRQ = 'SELECT dta.value FROM dgmtypeattribs AS dta INNER JOIN \
dgmattribs AS da ON da.attributeID = dta.attributeID WHERE (da.attributeName = \
"requiredSkill1" OR da.attributeName = "requiredSkill2" OR da.attributeName = \
"requiredSkill3") AND dta.typeID = ?'
QUERY_TYPEID_MARKETGROUPID = 'SELECT marketGroupID FROM invtypes WHERE \
typeID = ? LIMIT 1'
QUERY_TYPEID_TYPENAME = 'SELECT typeName FROM invtypes WHERE typeID = ? \
LIMIT 1'
QUERY_MARKETGROUPID_PARENTGROUPID = 'SELECT parentGroupID FROM \
invmarketgroups WHERE marketGroupID = ? LIMIT 1'
QUERY_EFFECTID_TYPEID = 'SELECT typeID FROM dgmtypeeffects WHERE effectID = ?'
# Queries for printing
QUERY_GROUPID_GROUPNAME = 'SELECT groupName FROM invgroups WHERE groupID = ? \
LIMIT 1'
QUERY_CATEGORYID_CATEGORYNAME = 'SELECT categoryName FROM invcategories \
WHERE categoryID = ? LIMIT 1'
QUERY_MARKETGROUPID_MARKETGROUPNAME = 'SELECT marketGroupName FROM \
invmarketgroups WHERE marketGroupID = ? LIMIT 1'

QUERY_ATTRIBUTENAME_ATTRIBUTEID = 'SELECT attributeID FROM dgmattribs WHERE attributeName = ?'
QUERY_TYPENAME_TYPEID = 'SELECT typeID FROM invtypes WHERE typeName = ?'
QUERY_GROUPNAME_GROUPID = 'SELECT groupID FROM invgroups WHERE groupName = ?'

if options.srq:
    global_skillrqids = set()
    for srq in options.srq.split(","):
        srqid = 0
        cursor.execute(QUERY_TYPENAME_TYPEID, (srq,))
        for row in cursor:
            srqid = row[0]
        if not srqid:
            import sys
            sys.stderr.write("You need to specify proper skill requirement name.\n")
            sys.exit()
        else:
            global_skillrqids.add(srqid)

if options.grp:
    global_groupids = set()
    for grp in options.grp.split(","):
        grouplist = []
        cursor.execute(QUERY_GROUPNAME_GROUPID, (grp,))
        for row in cursor:
            grouplist.append(row[0])
        if len(grouplist) > 1:
            print("Warning: multiple groups found, using ID", grouplist[0])
        elif len(grouplist) == 0:
            import sys
            sys.stderr.write("You need to specify proper group name.\n")
            sys.exit()
        global_groupids.add(grouplist[0])

# Published types set
publishedtypes = set()
cursor.execute(QUERY_PUBLISHEDTYPEIDS)
for row in cursor:
    publishedtypes.add(row[0])

# We'll use list of items with given attributes as base for any operations
# Term item means item with given attribute
typeswithattr = set()
first = True
for attr in options.attr.split(","):
    tmp = set()
    cursor.execute(QUERY_ATTRIBUTENAME_ATTRIBUTEID, (attr,))
    noattr = True
    for row in cursor:
        noattr = False
        attrid = row[0]
    if noattr:
        import sys
        sys.stderr.write("No \"{0}\" attribute found.\n".format(attr))
        sys.exit()
    cursor.execute(QUERY_ATTRIBUTEID_TYPEID, (attrid,))
    for row in cursor:
        if options.nozero:
            if row[0] in publishedtypes and row[1] not in (None, 0, 0.0):
                tmp.add(row[0])
        elif options.noone:
            if row[0] in publishedtypes and row[1] != 1.0:
                tmp.add(row[0])
        else:
            if row[0] in publishedtypes:
                tmp.add(row[0])
    if first:
        first = False
        typeswithattr = copy.deepcopy(tmp)
    else:
        typeswithattr.intersection_update(tmp)
if len(typeswithattr) == 0:
        import sys
        sys.stderr.write("No items found with all of supplied attributes.\n")
        sys.exit()

# Base type maps
# { basetypeid : set(typeid) }
map_basetypeid_typeid =  {}
# { typeid : basetypeid }
map_typeid_basetypeid =  {}
for typeid in typeswithattr:
    # Not all typeIDs in the database have baseTypeID, so assign some
    # default value to it
    basetypeid = 0
    cursor.execute(QUERY_TYPEID_PARENTTYPEID, (typeid,))
    for row in cursor:
        basetypeid = row[0]
    # If base type is not published or is not set in database, consider
    # item as variation of self
    if basetypeid not in typeswithattr:
        basetypeid = typeid
    if not basetypeid in map_basetypeid_typeid:
        map_basetypeid_typeid[basetypeid] = set()
    map_basetypeid_typeid[basetypeid].add(typeid)
    map_typeid_basetypeid[typeid] = basetypeid

# Meta group maps
# { metagroupid : set(typeid) }
map_metagroupid_typeid =  {}
# { typeid : metagroupid }
map_typeid_metagroupid =  {}
for typeid in typeswithattr:
    # Assume items are tech 1 by default
    metagroupid = 1
    cursor.execute(QUERY_TYPEID_METAGROUPID, (typeid,))
    for row in cursor:
        metagroupid = row[0]
    if not metagroupid in map_metagroupid_typeid:
        map_metagroupid_typeid[metagroupid] = set()
    map_metagroupid_typeid[metagroupid].add(typeid)
    map_typeid_metagroupid[typeid] = metagroupid

# Filter out non-t1/t2 items if we're asked to do so
if options.tech12:
    toremove = set()
    for typeid in typeswithattr:
        if map_typeid_basetypeid[typeid] != typeid and map_typeid_metagroupid[typeid] != 2:
            toremove.add(typeid)
    for id in toremove:
        typeswithattr.remove(id)

print("Attributes:")
for attr in sorted(options.attr.split(",")):
    print(attr)
print("")

# Compose group maps
# { groupid : set(typeid) }
map_groupid_typeid = {}
# { typeid : groupid }
map_typeid_groupid = {}
for typeid in typeswithattr:
    groupid = 0
    cursor.execute(QUERY_TYPEID_GROUPID, (typeid,))
    for row in cursor:
        groupid = row[0]
    if not groupid in map_groupid_typeid:
        map_groupid_typeid[groupid] = set()
    map_groupid_typeid[groupid].add(typeid)
    map_typeid_groupid[typeid] = groupid

# Category maps
# { categoryid : set(typeid) }
map_categoryid_typeid =  {}
# { typeid : categoryid }
map_typeid_categoryid =  {}
for typeid in typeswithattr:
    categoryid = 0
    cursor.execute(QUERY_GROUPID_CATEGORYID,
                   (map_typeid_groupid[typeid],))
    for row in cursor:
        categoryid = row[0]
    if not categoryid in map_categoryid_typeid:
        map_categoryid_typeid[categoryid] = set()
    map_categoryid_typeid[categoryid].add(typeid)
    map_typeid_categoryid[typeid] = categoryid
# { categoryid : set(groupid) }
map_categoryid_groupid =  {}
# { groupid : categoryid }
map_groupid_categoryid =  {}
for groupid in map_groupid_typeid:
    categoryid = 0
    cursor.execute(QUERY_GROUPID_CATEGORYID,
                   (groupid,))
    for row in cursor:
        categoryid = row[0]
    if not categoryid in map_categoryid_groupid:
        map_categoryid_groupid[categoryid] = set()
    map_categoryid_groupid[categoryid].add(groupid)
    map_groupid_categoryid[groupid] = categoryid

# Skill required maps
# { skillid : set(typeid) }
map_skillrq_typeid =  {}
# { typeid : set(skillid) }
map_typeid_skillrq =  {}
# list of items without skill requirements
set_typeid_noskillrq = set()
for typeid in typeswithattr:
    map_typeid_skillrq[typeid] = set()
    cursor.execute(QUERY_TYPEID_SKILLRQ, (typeid,))
    no_rqs = True
    for row in cursor:
        no_rqs = False
        skillid = row[0]
        if not skillid in map_skillrq_typeid:
            map_skillrq_typeid[skillid] = set()
        map_skillrq_typeid[skillid].add(typeid)
        map_typeid_skillrq[typeid].add(skillid)
    if no_rqs:
        set_typeid_noskillrq.add(typeid)

def gettypename(typeid):
    typename = ""
    cursor.execute(QUERY_TYPEID_TYPENAME, (typeid,))
    for row in cursor:
        typename = row[0]
    return typename

def getgroupname(grpid):
    grpname = ""
    cursor.execute(QUERY_GROUPID_GROUPNAME, (grpid,))
    for row in cursor:
        grpname = row[0]
    return grpname

def getcatname(catid):
    catname = ""
    cursor.execute(QUERY_CATEGORYID_CATEGORYNAME, (catid,))
    for row in cursor:
        catname = row[0]
    return catname

if options.grp and options.srq:
    # Set of items which are supposed to be affected
    targetitems = set()
    for groupid in global_groupids:
        for srqid in global_skillrqids:
            if groupid in map_groupid_typeid and srqid in map_skillrq_typeid:
                targetitems.update(map_groupid_typeid[groupid].intersection(map_skillrq_typeid[srqid]))
    targetitems_noskillrqs = targetitems.intersection(set_typeid_noskillrq)
    # All skill requirements of items which are supposed to be affected
    targetitems_skillrqs = set()
    for itemid in targetitems:
        targetitems_skillrqs.update(map_typeid_skillrq[itemid])
    # Remove skill requirement supplied as argument to script
    # we can use that argument when needed manually, and it
    # covers all targetitems which we don't want to do with single skill
    for srqid in global_skillrqids:
        targetitems_skillrqs.remove(srqid)

    if targetitems:
        # Print items which are supposed to be affected
        print("Affected items:")
        for groupid in sorted(global_groupids, key=lambda grid: getgroupname(grid)):
            targetitems_grp = targetitems.intersection(map_groupid_typeid[groupid])
            print("    Items from {0} group:".format(getgroupname(groupid)))
            # Cycle through all required skills
            targetitems_skillrqs_withgiven = copy.deepcopy(targetitems_skillrqs)
            for srqid in global_skillrqids:
                targetitems_skillrqs_withgiven.add(srqid)
            for skillrq in sorted(targetitems_skillrqs_withgiven, key=lambda sk: gettypename(sk)):
                targetitems_grp_srq = targetitems_grp.intersection(map_skillrq_typeid[skillrq])
                if targetitems_grp_srq:
                    print("        Items requiring {0} skill:".format(gettypename(skillrq)))
                    for item in sorted(targetitems_grp_srq, key=lambda item: gettypename(item)):
                        # If item has 3rd skill requirement (besides supplied as argument and
                        # included into header of current section), mention it
                        if len(map_typeid_skillrq[item]) in (2, 3):
                            otherskillrq = copy.deepcopy(map_typeid_skillrq[item])
                            otherskillrq.discard(skillrq)
                            print("            {0} ({1})".format(gettypename(item), ", ".join(sorted(gettypename(id) for id in otherskillrq))))
                        # Just print item names if there's only 1 skill requirement
                        elif len(map_typeid_skillrq[item]) == 1:
                            print("            {0}".format(gettypename(item)))
                        else:
                            print("WARNING: Bad things happened, we never should get here")

    print("\nUnaffected items")


    items_in_groups = set()
    for groupid in global_groupids:
        items_in_groups.update(map_groupid_typeid[groupid])
    items_with_skillrqs = set()
    for srqid in global_skillrqids:
        items_with_skillrqs.update(map_skillrq_typeid[srqid])
    # List items which do not belong to given group, but have given skill requirement
    wskill = typeswithattr.intersection(items_with_skillrqs)
    wogroup = typeswithattr.difference(items_in_groups)
    nontarget_wskill_wogroup = wskill.intersection(wogroup)
    if nontarget_wskill_wogroup:
        print("    With {0} skill requirements, not belonging to {1} groups:".format(", ".join(sorted(gettypename(id) for id in global_skillrqids)), ", ".join(sorted(getgroupname(grid) for grid in global_groupids))))
    for item in sorted(nontarget_wskill_wogroup, key=lambda item: gettypename(item)):
        print("        {0}".format(gettypename(item)))

    # List items which belong to given group, but do not have given skill requirement
    woskill = typeswithattr.difference(items_with_skillrqs)
    wgroup = typeswithattr.intersection(items_in_groups)
    nontarget_woskill_wgroup = woskill.intersection(wgroup)
    if nontarget_woskill_wgroup:
        print("    Without {0} skill requirement, belonging to {1} group:".format(", ".join(sorted(gettypename(id) for id in global_skillrqids)), ", ".join(sorted(getgroupname(grid) for grid in global_groupids))))
    for item in sorted(nontarget_woskill_wgroup, key=lambda item: gettypename(item)):
        print("        {0}".format(gettypename(item)))

    # If any of the above lists is missing, list all unaffected items
    if not nontarget_wskill_wogroup or not nontarget_woskill_wgroup:
        nontarget = typeswithattr.difference(items_in_groups)
        for srqid in global_skillrqids:
            nontarget.difference_update(map_skillrq_typeid[srqid])
        if nontarget_wskill_wogroup:
            nontarget.difference_update(nontarget_wskill_wogroup)
        if nontarget_woskill_wgroup:
            nontarget.difference_update(nontarget_woskill_wgroup)
        nontarget_groups = set()
        nontarget_cats = set()
        print("    Plain list:")
        for item in sorted(nontarget, key=lambda item: gettypename(item)):
            nontarget_groups.add(map_typeid_groupid[item])
            print("        {0} ({1})".format(gettypename(item), getgroupname(map_typeid_groupid[item])))
        #print("  Groups:")
        #for group in sorted(nontarget_groups, key=lambda grp: getgroupname(grp)):
        #    nontarget_cats.add(map_groupid_categoryid[group])
        #    print("    {0} ({1})".format(getgroupname(group), getcatname(map_groupid_categoryid[group])))
        #print("  Categories:")
        #for cat in sorted(nontarget_cats, key=lambda cat: getcatname(cat)):
        #    print("    {0}".format(getcatname(cat)))

elif options.grp:
    # Set of items which are supposed to be affected
    targetitems = set()
    for groupid in global_groupids:
        if groupid in map_groupid_typeid:
            targetitems.update(map_groupid_typeid[groupid])
    # All skill requirements of items which are supposed to be affected
    targetitems_skillrqs = set()
    for itemid in targetitems:
        targetitems_skillrqs.update(map_typeid_skillrq[itemid])
    targetitems_noskillrqs = targetitems.intersection(set_typeid_noskillrq)
    if targetitems:
        # Print items which are supposed to be affected
        print("Affected items:")
        for groupid in sorted(global_groupids, key=lambda grid: getgroupname(grid)):
            print("    From {0} group:".format(getgroupname(groupid)))
            targetitems_grp = targetitems.intersection(map_groupid_typeid[groupid])
            targetitems_noskillrqs_grp = targetitems_noskillrqs.intersection(map_groupid_typeid[groupid])
            # Cycle through all required skills
            for skillrq in sorted(targetitems_skillrqs, key=lambda sk: gettypename(sk)):
                items_grpsrq = targetitems_grp.intersection(map_skillrq_typeid[skillrq])
                if items_grpsrq:
                    print("        Requiring {0} skill:".format(gettypename(skillrq)))
                    for item in sorted(items_grpsrq, key=lambda item: gettypename(item)):
                        # If item has other skill requirements, print them
                        if len(map_typeid_skillrq[item]) == 3 or len(map_typeid_skillrq[item]) == 2:
                            otherskillrq = copy.deepcopy(map_typeid_skillrq[item])
                            otherskillrq.discard(skillrq)
                            print("            {0} ({1})".format(gettypename(item), ", ".join(sorted(gettypename(id) for id in otherskillrq))))
                        # Just print item names if there're only 2 skill requirements
                        elif len(map_typeid_skillrq[item]) == 1:
                            print("            {0}".format(gettypename(item)))
                        else:
                            print("WARNING: Bad things happened, we never should get here")
            if targetitems_noskillrqs:
                print("        Requiring no skills:")
                for item in sorted(targetitems_noskillrqs_grp, key=lambda item: gettypename(item)):
                    print("            {0}".format(gettypename(item)))

    print("\nUnaffected items")

    # List items which are supposed to be unaffected
    nontarget = typeswithattr.difference(targetitems)
    nontarget_groups = set()
    nontarget_cats = set()
    print("    Not belonging to groups {0}:".format(", ".join(getgroupname(id) for id in global_groupids)))

    removeitms = set()
    # Check 1 unaffected item with each skill requirement, if some items with it were affected
    for skillrq in sorted(targetitems_skillrqs, key=lambda srq: gettypename(srq)):
        if nontarget.intersection(map_skillrq_typeid[skillrq]):
            print("        With {0} skill requirement:".format(gettypename(skillrq)))
        for item in sorted(nontarget.intersection(map_skillrq_typeid[skillrq]), key=lambda item: gettypename(item)):
            print("            {0}".format(gettypename(item)))
        removeitms.update(map_skillrq_typeid[skillrq])
    nontarget.difference_update(removeitms)
    print("        With other or no skill requirements:")
    for item in sorted(nontarget, key=lambda item: gettypename(item)):
        nontarget_groups.add(map_typeid_groupid[item])
        print("            {0} ({1})".format(gettypename(item), getgroupname(map_typeid_groupid[item])))

    #print("    Groups:")
    #for group in sorted(nontarget_groups, key=lambda grp: getgroupname(grp)):
    #    nontarget_cats.add(map_groupid_categoryid[group])
    #    print("      {0} ({1})".format(getgroupname(group), getcatname(map_groupid_categoryid[group])))
    #print("    Categories:")
    #for cat in sorted(nontarget_cats, key=lambda cat: getcatname(cat)):
    #    print("      {0}".format(getcatname(cat)))

elif options.srq:
    # Set of items which are supposed to be affected
    targetitems = set()
    for srqid in global_skillrqids:
        if srqid in map_skillrq_typeid:
            targetitems.update(map_skillrq_typeid[srqid])

    # All groups of items which are supposed to be affected
    targetitems_groups = set()
    targetitems_srqs = set()
    targetitems_cats = set()
    for itemid in targetitems:
        targetitems_groups.add(map_typeid_groupid[itemid])
        targetitems_srqs.update(map_typeid_skillrq[itemid])
        targetitems_cats.add(map_typeid_categoryid[itemid])
    if targetitems:
        # Print items which are supposed to be affected
        print("Affected items:")
        for srqid in sorted(global_skillrqids, key=lambda itm: gettypename(itm)):
            print("    With {0} skill requirements:".format(gettypename(srqid)))
            targetitems_srq = targetitems.intersection(map_skillrq_typeid[srqid])
            targetitems_srq_groups = set()
            targetitems_srq_cats = set()
            for itemid in targetitems_srq:
                targetitems_srq_groups.add(map_typeid_groupid[itemid])
                targetitems_srq_cats.add(map_typeid_categoryid[itemid])
            # Cycle through groups
            for groupid in sorted(targetitems_srq_groups, key=lambda grp: getgroupname(grp)):
                print("        From {0} group:".format(getgroupname(groupid)))
                for item in sorted(targetitems_srq.intersection(map_groupid_typeid[groupid]), key=lambda item: gettypename(item)):
                    print("            {0} ({1})".format(gettypename(item), ", ".join(sorted(gettypename(itm) for itm in map_typeid_skillrq[item].difference(global_skillrqids))) or "None"))

    print("\nUnaffected items")

    # List items which are supposed to be unaffected
    nontarget = typeswithattr.difference(targetitems)
    nontarget_groups = set()
    nontarget_cats = set()
    print("    Without {0} skills requirement:".format(", ".join(gettypename(id) for id in global_skillrqids)))
    removeitms = set()
    # Check 1 unaffected item from each group where some items were affected
    for groupid in sorted(targetitems_groups, key=lambda grp: getgroupname(grp)):
        if nontarget.intersection(map_groupid_typeid[groupid]):
            print("        From {0} group:".format(getgroupname(groupid)))
            for skillrqid in sorted(targetitems_srqs.difference(global_skillrqids), key=lambda srq: gettypename(srq)):
                itmset = nontarget.intersection(map_groupid_typeid[groupid]).intersection(map_skillrq_typeid[skillrqid])
                if itmset:
                    print("            Items with {0} skill requirement:".format(gettypename(skillrqid)))
                    for item in sorted(itmset, key=lambda itm: gettypename(itm)):
                        otherskrqs = map_typeid_skillrq[item].difference(global_skillrqids)
                        otherskrqs.remove(skillrqid)
                        print("                {0} ({1})".format(gettypename(item), ", ".join(sorted(gettypename(itm) for itm in otherskrqs)) or "None"))
                    removeitms.update(itmset)
            nontarget.difference_update(removeitms)
            otsk = nontarget.intersection(map_groupid_typeid[groupid]).difference(set_typeid_noskillrq)
            if otsk:
                print("            Items with other skill requirements:")
                for item in sorted(otsk, key=lambda itm: gettypename(itm)):
                    print("                {0} (None)".format(gettypename(item)))
            removeitms.update(otsk)
            nosk = nontarget.intersection(map_groupid_typeid[groupid]).intersection(set_typeid_noskillrq)
            if nosk:
                print("            Items with no skill requirement:")
                for item in sorted(nosk, key=lambda itm: gettypename(itm)):
                    print("                {0} (None)".format(gettypename(item)))
            removeitms.update(nosk)
    nontarget.difference_update(removeitms)
    for catid in sorted(targetitems_cats, key=lambda cat: getcatname(cat)):
        if nontarget.intersection(map_categoryid_typeid[catid]):
            print("        From {0} category:".format(getcatname(catid)))
        for item in sorted(nontarget.intersection(map_categoryid_typeid[catid]), key=lambda item: gettypename(item)):
            print("            {0}".format(gettypename(item)))
        removeitms.update(map_categoryid_typeid[catid])
    nontarget.difference_update(removeitms)
    if nontarget:
        # Check any other unaffected item
        print("        Remaining items:")
        for item in sorted(nontarget, key=lambda item: gettypename(item)):
            nontarget_groups.add(map_typeid_groupid[item])
            print("            {0} ({1})".format(gettypename(item), getgroupname(map_typeid_groupid[item])))
    #print("    Groups:")
    #for group in sorted(nontarget_groups, key=lambda grp: getgroupname(grp)):
    #    nontarget_cats.add(map_groupid_categoryid[group])
    #    print("      {0} ({1})".format(getgroupname(group), getcatname(map_groupid_categoryid[group])))
    #print("    Categories:")
    #for cat in sorted(nontarget_cats, key=lambda cat: getcatname(cat)):
    #    print("      {0}".format(getcatname(cat)))

else:
    print("Affected items")
    targetitems = typeswithattr
    targetitems_groups = set()
    targetitems_cats = set()
    print("    Assumed set of items:")
    for item in sorted(targetitems, key=lambda item: gettypename(item)):
        targetitems_groups.add(map_typeid_groupid[item])
        print("        {0} ({1})".format(gettypename(item), getgroupname(map_typeid_groupid[item])))
    print("    Groups:")
    for group in sorted(targetitems_groups, key=lambda grp: getgroupname(grp)):
        targetitems_cats.add(map_groupid_categoryid[group])
        print("        {0} ({1})".format(getgroupname(group), getcatname(map_groupid_categoryid[group])))
    print("    Categories:")
    for cat in sorted(targetitems_cats, key=lambda cat: getcatname(cat)):
        print("        {0}".format(getcatname(cat)))

########NEW FILE########
__FILENAME__ = aboutData
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================
import config

versionString = "{0} {1} - {2} {3}".format(config.version, config.tag, config.expansionName, config.expansionVersion)
licenses = (
    "pyfa is released under GNU GPLv3 - see included gpl.txt",
    "All EVE-Online related materials are property of CCP hf.",
    "Silk Icons Set by famfamfam.com - Creative Commons Attribution 2.5 License",
    "Fat Cow Icons by fatcow.com - Creative Commons Attribution 3.0 License"
)
developers = ("blitzmann \t(Sable Blitzmann)", "cncfanatics \t(Sakari Orisi)" , "DarkPhoenix \t(Kadesh Priestess) (Project Lead)", "Darriele \t(Darriele)")
credits = ("Entity (Entity) \t\tCapacitor calculations / EVEAPI python lib / Reverence", "Aurora \t\t\tMaths", "Corollax (Aamrr) \tVarious EOS / pyfa improvements")
description = (
    "Pyfa (the Python Fitting Assistant) is an open-source standalone application able to "
    "create and simulate fittings for EVE-Online SciFi MMORPG with a very high degree of "
    "accuracy. Pyfa can run on all platforms where Python and wxWidgets are supported."
)

########NEW FILE########
__FILENAME__ = additionsPane
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import wx
import gui.mainFrame
from gui.boosterView import BoosterView
from gui.droneView import DroneView
from gui.cargoView import CargoView
from gui.implantView import ImplantView
from gui.projectedView import ProjectedView
from gui.pyfatogglepanel import TogglePanel
from gui.gangView import GangView
from gui import bitmapLoader

import gui.chromeTabs

class AdditionsPane(TogglePanel):

    def __init__(self, parent):

        TogglePanel.__init__(self, parent, forceLayout = 1)

        self.SetLabel("Additions")
        pane = self.GetContentPane()

        baseSizer = wx.BoxSizer(wx.HORIZONTAL)
        pane.SetSizer(baseSizer)

        self.mainFrame = gui.mainFrame.MainFrame.getInstance()

        self.notebook = gui.chromeTabs.PFNotebook(pane, False)
        size = wx.Size()
        # This size lets you see 4 drones at a time
        size.SetHeight(180)
        self.notebook.SetMinSize(size)
        baseSizer.Add(self.notebook, 1, wx.EXPAND)

        droneImg = bitmapLoader.getImage("drone_small", "icons")
        implantImg = bitmapLoader.getImage("implant_small", "icons")
        boosterImg = bitmapLoader.getImage("booster_small", "icons")
        projectedImg = bitmapLoader.getImage("projected_small", "icons")
        gangImg = bitmapLoader.getImage("fleet_fc_small", "icons")
        cargoImg = bitmapLoader.getImage("cargo_small", "icons")

        self.notebook.AddPage(DroneView(self.notebook), "Drones", tabImage = droneImg, showClose = False)
        self.notebook.AddPage(CargoView(self.notebook), "Cargo", tabImage = cargoImg, showClose = False)
        self.notebook.AddPage(ImplantView(self.notebook), "Implants", tabImage = implantImg, showClose = False)
        self.notebook.AddPage(BoosterView(self.notebook), "Boosters", tabImage = boosterImg, showClose = False)

        self.projectedPage = ProjectedView(self.notebook)
        self.notebook.AddPage(self.projectedPage, "Projected", tabImage = projectedImg, showClose = False)

        self.gangPage = GangView(self.notebook)
        self.notebook.AddPage(self.gangPage, "Fleet", tabImage = gangImg, showClose = False)
        self.notebook.SetSelection(0)

    PANES = ["Drones", "Cargo", "Implants", "Boosters", "Projected", "Fleet"]
    def select(self, name):
        self.notebook.SetSelection(self.PANES.index(name))

    def getName(self, idx):
        return self.PANES[idx]

########NEW FILE########
__FILENAME__ = bitmapLoader
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import os.path
import config
import wx
import time

try:
    from collections import OrderedDict
except ImportError:
    from gui.utils.compat import OrderedDict

cachedBitmapsCount = 0
cachedBitmaps = OrderedDict()
dontUseCachedBitmaps = False

def getStaticBitmap(name, parent, location):
    static = wx.StaticBitmap(parent)
    static.SetBitmap(getBitmap(name,location))
    return static

locationMap = {"pack": os.path.join(config.staticPath, "icons"),
               "ships": os.path.join(config.staticPath, "icons/ships")}

def getBitmap(name,location):

    global cachedBitmaps
    global cachedBitmapsCount
    global dontUseCachedBitmaps

    if dontUseCachedBitmaps:
        img = getImage(name, location)
        if img is not None:
            return img.ConvertToBitmap()

    path = "%s%s" % (name,location)
    MAX_BMPS = 500
#    start = time.clock()
    if cachedBitmapsCount == MAX_BMPS:
        cachedBitmaps.popitem(False)
        cachedBitmapsCount -=1

    if path not in cachedBitmaps:
        img = getImage(name, location)
        if img is not None:
            bmp = img.ConvertToBitmap()
        else:
            bmp = None
        cachedBitmaps[path] = bmp
        cachedBitmapsCount += 1
    else:
        bmp = cachedBitmaps[path]

#    print "#BMPs:%d - Current took: %.8f" % (cachedBitmapsCount,time.clock() - start)
    return bmp

def getImage(name, location):
    if location in locationMap:
        if location == "pack":
            location = locationMap[location]
            filename = "icon{0}.png".format(name)
            path = os.path.join(location, filename)
        else:
            location = locationMap[location]
            filename = "{0}.png".format(name)
            path = os.path.join(location, filename)

    else:
        location = os.path.join(config.pyfaPath, location)
        filename = "{0}.png".format(name)
        path = os.path.join(location, filename)

    if os.path.exists(path):
        return wx.Image(path)
    else:
        print "Missing icon file: {0}".format(filename)

########NEW FILE########
__FILENAME__ = boosterView
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import wx
import service
import gui.display as d
import gui.globalEvents as GE
import gui.marketBrowser as mb
from gui.builtinViewColumns.state import State
from gui.contextMenu import ContextMenu

class BoosterViewDrop(wx.PyDropTarget):
        def __init__(self, dropFn):
            wx.PyDropTarget.__init__(self)
            self.dropFn = dropFn
            # this is really transferring an EVE itemID
            self.dropData = wx.PyTextDataObject()
            self.SetDataObject(self.dropData)

        def OnData(self, x, y, t):
            if self.GetData():
                data = self.dropData.GetText().split(':')
                self.dropFn(x, y, data)
            return t

class BoosterView(d.Display):
    DEFAULT_COLS = ["State",
                    "attr:boosterness",
                    "Base Name"]

    def __init__(self, parent):
        d.Display.__init__(self, parent, style=wx.LC_SINGLE_SEL | wx.BORDER_NONE)

        self.lastFitId = None

        self.mainFrame.Bind(GE.FIT_CHANGED, self.fitChanged)
        self.mainFrame.Bind(mb.ITEM_SELECTED, self.addItem)

        self.Bind(wx.EVT_LEFT_DCLICK, self.removeItem)
        self.Bind(wx.EVT_LEFT_DOWN, self.click)
        self.Bind(wx.EVT_KEY_UP, self.kbEvent)

        self.SetDropTarget(BoosterViewDrop(self.handleListDrag))

        if "__WXGTK__" in  wx.PlatformInfo:
            self.Bind(wx.EVT_RIGHT_UP, self.scheduleMenu)
        else:
            self.Bind(wx.EVT_RIGHT_DOWN, self.scheduleMenu)

    def handleListDrag(self, x, y, data):
        '''
        Handles dragging of items from various pyfa displays which support it

        data is list with two indices:
            data[0] is hard-coded str of originating source
            data[1] is typeID or index of data we want to manipulate
        '''

        if data[0] == "market":
            wx.PostEvent(self.mainFrame, mb.ItemSelected(itemID=int(data[1])))

    def kbEvent(self,event):
        keycode = event.GetKeyCode()
        if keycode == wx.WXK_DELETE or keycode == wx.WXK_NUMPAD_DELETE:
            row = self.GetFirstSelected()
            if row != -1:
                self.removeBooster(self.boosters[self.GetItemData(row)])

        event.Skip()

    def fitChanged(self, event):
        #Clear list and get out if current fitId is None
        if event.fitID is None and self.lastFitId is not None:
            self.DeleteAllItems()
            self.lastFitId = None
            event.Skip()
            return

        sFit = service.Fit.getInstance()
        fit = sFit.getFit(event.fitID)

        self.origional = fit.boosters if fit is not None else None
        self.boosters = stuff = fit.boosters[:] if fit is not None else None

        if event.fitID != self.lastFitId:
            self.lastFitId = event.fitID

            item = self.GetNextItem(-1, wx.LIST_NEXT_ALL, wx.LIST_STATE_DONTCARE)

            if item != -1:
                self.EnsureVisible(item)

            self.deselectItems()

        self.populate(stuff)
        self.refresh(stuff)
        event.Skip()

    def addItem(self, event):
        cFit = service.Fit.getInstance()
        fitID = self.mainFrame.getActiveFit()
        trigger = cFit.addBooster(fitID, event.itemID)
        if trigger:
            wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=fitID))
            self.mainFrame.additionsPane.select("Boosters")

        event.Skip()

    def removeItem(self, event):
        row, _ = self.HitTest(event.Position)
        if row != -1:
            col = self.getColumn(event.Position)
            if col != self.getColIndex(State):
                self.removeBooster(self.boosters[self.GetItemData(row)])

    def removeBooster(self, booster):
        fitID = self.mainFrame.getActiveFit()
        cFit = service.Fit.getInstance()
        cFit.removeBooster(fitID, self.origional.index(booster))
        wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=fitID))

    def click(self, event):
        event.Skip()
        row, _ = self.HitTest(event.Position)
        if row != -1:
            col = self.getColumn(event.Position)
            if col == self.getColIndex(State):
                fitID = self.mainFrame.getActiveFit()
                cFit = service.Fit.getInstance()
                cFit.toggleBooster(fitID, row)
                wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=fitID))


    def scheduleMenu(self, event):
        event.Skip()
        if self.getColumn(event.Position) != self.getColIndex(State):
            wx.CallAfter(self.spawnMenu)

    def spawnMenu(self):
        sel = self.GetFirstSelected()
        if sel != -1:
            cFit = service.Fit.getInstance()
            fit = cFit.getFit(self.mainFrame.getActiveFit())
            item = fit.boosters[sel]

            srcContext = "boosterItem"
            itemContext = "Booster"
            menu = ContextMenu.getMenu((item,), (srcContext, itemContext))
            self.PopupMenu(menu)

########NEW FILE########
__FILENAME__ = ammoPattern
from gui.contextMenu import ContextMenu
import gui.mainFrame
import service
import wx
import gui.globalEvents as GE

class AmmoPattern(ContextMenu):
    def __init__(self):
        self.mainFrame = gui.mainFrame.MainFrame.getInstance()


    def display(self, srcContext, selection):
        if srcContext not in ("marketItemGroup", "marketItemMisc") or self.mainFrame.getActiveFit() is None:
            return False

        item = selection[0]
        for attr in ("emDamage", "thermalDamage", "explosiveDamage", "kineticDamage"):
            if item.getAttribute(attr) is not None:
                return True

        return False

    def getText(self, itmContext, selection):
        return "Set {0} as Damage Pattern".format(itmContext if itmContext is not None else "Item")

    def activate(self, fullContext, selection, i):
        item = selection[0]
        fit = self.mainFrame.getActiveFit()
        sFit = service.Fit.getInstance()
        sFit.setAsPattern(fit, item)
        wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=fit))

    def getBitmap(self, context, selection):
        return None


AmmoPattern.register()

########NEW FILE########
__FILENAME__ = cargo
from gui.contextMenu import ContextMenu
from gui.itemStats import ItemStatsDialog
import eos.types
import gui.mainFrame
import service
import gui.globalEvents as GE
import wx

class Cargo(ContextMenu):
    def __init__(self):
        self.mainFrame = gui.mainFrame.MainFrame.getInstance()

    def display(self, srcContext, selection):
        # Make sure context menu registers in the correct view
        if srcContext not in ("marketItemGroup", "marketItemMisc") or self.mainFrame.getActiveFit() is None:
            return False
        return True

    def getText(self, itmContext, selection):
        return "Add {0} to Cargo".format(itmContext)

    def activate(self, fullContext, selection, i):
        sFit = service.Fit.getInstance()
        fitID = self.mainFrame.getActiveFit()

        typeID = int(selection[0].ID)
        sFit.addCargo(fitID, typeID)
        self.mainFrame.additionsPane.select("Cargo")
        wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=fitID))

Cargo.register()

class CargoAmount(ContextMenu):
    def __init__(self):
        self.mainFrame = gui.mainFrame.MainFrame.getInstance()

    def display(self, srcContext, selection):
        return srcContext in ("cargoItem",) and selection[0].amount >= 0

    def getText(self, itmContext, selection):
        return "Change {0} Quantity".format(itmContext)

    def activate(self, fullContext, selection, i):
        srcContext = fullContext[0]
        dlg = CargoChanger(self.mainFrame, selection[0], srcContext)
        dlg.ShowModal()
        dlg.Destroy()

CargoAmount.register()

class CargoChanger(wx.Dialog):

    def __init__(self, parent, cargo, context):
        wx.Dialog.__init__(self, parent, title="Select Amount", size=wx.Size(220, 60))
        self.cargo = cargo
        self.context = context

        bSizer1 = wx.BoxSizer(wx.HORIZONTAL)

        self.input = wx.TextCtrl(self, wx.ID_ANY, style=wx.TE_PROCESS_ENTER)

        bSizer1.Add(self.input, 1, wx.ALL, 5)
        self.input.Bind(wx.EVT_CHAR, self.onChar)
        self.input.Bind(wx.EVT_TEXT_ENTER, self.change)
        self.button = wx.Button(self, wx.ID_OK, u"Done")
        bSizer1.Add(self.button, 0, wx.ALL, 5)

        self.SetSizer(bSizer1)
        self.Layout()
        self.Centre(wx.BOTH)
        self.button.Bind(wx.EVT_BUTTON, self.change)

    def change(self, event):
        sFit = service.Fit.getInstance()
        mainFrame = gui.mainFrame.MainFrame.getInstance()
        fitID = mainFrame.getActiveFit()

        sFit.addCargo(fitID, self.cargo.item.ID, int(self.input.GetLineText(0)), replace=True)

        wx.PostEvent(mainFrame, GE.FitChanged(fitID=fitID))

        event.Skip()
        self.Destroy()
    ## checks to make sure it's valid number
    def onChar(self, event):
        key = event.GetKeyCode()

        acceptable_characters = "1234567890"
        acceptable_keycode    = [3, 22, 13, 8, 127] # modifiers like delete, copy, paste
        if key in acceptable_keycode or key >= 255 or (key < 255 and chr(key) in acceptable_characters):
            event.Skip()
            return
        else:
            return False


########NEW FILE########
__FILENAME__ = damagePattern
from gui.contextMenu import ContextMenu
import gui.mainFrame
import service
import gui.globalEvents as GE
import wx
from gui import bitmapLoader

class DamagePattern(ContextMenu):
    def __init__(self):
        self.mainFrame = gui.mainFrame.MainFrame.getInstance()

    def display(self, srcContext, selection):
        return srcContext in ("resistancesViewFull",) and self.mainFrame.getActiveFit() is not None

    def getText(self, itmContext, selection):
        sDP = service.DamagePattern.getInstance()
        self.patterns = sDP.getDamagePatternList()
        self.patterns.sort( key=lambda p: (p.name in ["Selected Ammo",
                            "Uniform"], p.name) )
        m = map(lambda p: p.name, self.patterns)
        return m

    def activate(self, fullContext, selection, i):
        sDP = service.DamagePattern.getInstance()
        sFit = service.Fit.getInstance()
        fitID = self.mainFrame.getActiveFit()
        sFit.setDamagePattern(fitID, self.patterns[i])
        setattr(self.mainFrame,"_activeDmgPattern",self.patterns[i])
        wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=fitID))

    def getBitmap(self, context, selection):
        sFit = service.Fit.getInstance()
        fitID = self.mainFrame.getActiveFit()
        f = sFit.getFit(fitID)
        dp = f.damagePattern
        if dp is None:
            return None

        index = self.patterns.index(dp)
        bitmap = bitmapLoader.getBitmap("state_active_small", "icons")
        l = [None] * len(self.patterns)
        l[index] = bitmap

        return l


DamagePattern.register()

########NEW FILE########
__FILENAME__ = droneRemoveStack
from gui.contextMenu import ContextMenu
import gui.mainFrame
import service
import wx
import gui.globalEvents as GE

class ItemRemove(ContextMenu):
    def __init__(self):
        self.mainFrame = gui.mainFrame.MainFrame.getInstance()

    def display(self, srcContext, selection):
        return srcContext == "droneItem"

    def getText(self, itmContext, selection):
        return "Remove {0} Stack".format(itmContext)

    def activate(self, fullContext, selection, i):
        srcContext = fullContext[0]
        sFit = service.Fit.getInstance()
        fitID = self.mainFrame.getActiveFit()
        cFit = sFit.getFit(fitID)
        
        idx = cFit.drones.index(selection[0])
        sFit.removeDrone(fitID, idx, numDronesToRemove=cFit.drones[idx].amount)
        
        wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=fitID))

ItemRemove.register()
########NEW FILE########
__FILENAME__ = droneSplit
from gui.contextMenu import ContextMenu
from gui.itemStats import ItemStatsDialog
import gui.mainFrame
import gui.globalEvents as GE
import service
import wx

class DroneSplit(ContextMenu):
    def __init__(self):
        self.mainFrame = gui.mainFrame.MainFrame.getInstance()

    def display(self, srcContext, selection):
        return srcContext in ("droneItem", "projectedDrone") and selection[0].amount > 1

    def getText(self, itmContext, selection):
        return "Split {0} Stack".format(itmContext)

    def activate(self, fullContext, selection, i):
        srcContext = fullContext[0]
        dlg = DroneSpinner(self.mainFrame, selection[0], srcContext)
        dlg.ShowModal()
        dlg.Destroy()

DroneSplit.register()


class DroneSpinner(wx.Dialog):

    def __init__(self, parent, drone, context):
        wx.Dialog.__init__(self, parent, title="Select Amount", size=wx.Size(220, 60))
        self.drone = drone
        self.context = context

        bSizer1 = wx.BoxSizer(wx.HORIZONTAL)

        self.spinner = wx.SpinCtrl(self)
        self.spinner.SetRange(1, drone.amount - 1)
        self.spinner.SetValue(1)

        bSizer1.Add(self.spinner, 0, wx.ALL, 5)

        self.button = wx.Button(self, wx.ID_OK, u"Split")
        bSizer1.Add(self.button, 0, wx.ALL, 5)

        self.SetSizer(bSizer1)
        self.Layout()
        self.Centre(wx.BOTH)
        self.button.Bind(wx.EVT_BUTTON, self.split)

    def split(self, event):
        sFit = service.Fit.getInstance()
        mainFrame = gui.mainFrame.MainFrame.getInstance()
        fitID = mainFrame.getActiveFit()
        if self.context == "droneItem":
            sFit.splitDroneStack(fitID, self.drone, self.spinner.GetValue())
        else:
            sFit.splitProjectedDroneStack(fitID, self.drone, self.spinner.GetValue())
        wx.PostEvent(mainFrame, GE.FitChanged(fitID=fitID))
        event.Skip()

########NEW FILE########
__FILENAME__ = factorReload
from gui.contextMenu import ContextMenu
import gui.mainFrame
import service
import gui.globalEvents as GE
import wx
from gui import bitmapLoader

class FactorReload(ContextMenu):
    def __init__(self):
        self.mainFrame = gui.mainFrame.MainFrame.getInstance()

    def display(self, srcContext, selection):
        return srcContext in ("firepowerViewFull",) and self.mainFrame.getActiveFit() is not None

    def getText(self, itmContext, selection):
        return "Factor in Reload Time"

    def activate(self, fullContext, selection, i):
        sFit = service.Fit.getInstance()
        sFit.serviceFittingOptions["useGlobalForceReload"] = not sFit.serviceFittingOptions["useGlobalForceReload"]
        fitID = self.mainFrame.getActiveFit()
        sFit.refreshFit(fitID)
        wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=fitID))

    def getBitmap(self, context, selection):
        sFit = service.Fit.getInstance()
        fitID = self.mainFrame.getActiveFit()
        fit = sFit.getFit(fitID)
        if fit.factorReload:
            return bitmapLoader.getBitmap("state_active_small", "icons")
        else:
            return None


FactorReload.register()

########NEW FILE########
__FILENAME__ = itemRemove
from gui.contextMenu import ContextMenu
import gui.mainFrame
import service
import wx
import gui.globalEvents as GE

class ItemRemove(ContextMenu):
    def __init__(self):
        self.mainFrame = gui.mainFrame.MainFrame.getInstance()

    def display(self, srcContext, selection):
        return srcContext in ("fittingModule", "fittingCharge", "droneItem", "implantItem", "boosterItem", "projectedModule", "projectedCharge",
                               "projectedFit", "projectedDrone")

    def getText(self, itmContext, selection):
        return "Remove {0}".format(itmContext if itmContext is not None else "Item")

    def activate(self, fullContext, selection, i):
        srcContext = fullContext[0]
        sFit = service.Fit.getInstance()
        fitID = self.mainFrame.getActiveFit()
        cFit = sFit.getFit(fitID)
        
        if srcContext == "fittingModule":
            for module in selection:
                if module is not None:
                    sFit.removeModule(fitID,cFit.modules.index(module))
        elif srcContext in ("fittingCharge" , "projectedCharge"):
            sFit.setAmmo(fitID, None, selection)
        elif srcContext == "droneItem":
            sFit.removeDrone(fitID, cFit.drones.index(selection[0]))
        elif srcContext == "implantItem":
            sFit.removeImplant(fitID, cFit.implants.index(selection[0]))
        elif srcContext == "boosterItem":
            sFit.removeBooster(fitID, cFit.boosters.index(selection[0]))
        else:
            sFit.removeProjected(fitID, selection[0])
            
        wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=fitID))




ItemRemove.register()

########NEW FILE########
__FILENAME__ = itemStats
from gui.contextMenu import ContextMenu
from gui.itemStats import ItemStatsDialog
import gui.mainFrame
import service
import wx

class ItemStats(ContextMenu):
    def __init__(self):
        self.mainFrame = gui.mainFrame.MainFrame.getInstance()

    def display(self, srcContext, selection):
        return srcContext in ("marketItemGroup", "marketItemMisc", "fittingModule", "fittingCharge", "fittingShip", "baseShip", "cargoItem",
                              "droneItem", "implantItem", "boosterItem", "skillItem", "projectedModule", "projectedDrone", "projectedCharge")

    def getText(self, itmContext, selection):
        return "{0} Stats".format(itmContext if itmContext is not None else "Item")

    def activate(self, fullContext, selection, i):
        srcContext = fullContext[0]
        if srcContext == "fittingShip":
            fitID = self.mainFrame.getActiveFit()
            cFit = service.Fit.getInstance()
            stuff = cFit.getFit(fitID).ship
        else:
            stuff = selection[0]

        if srcContext == "fittingModule" and stuff.isEmpty:
            return

        mstate = wx.GetMouseState()
        reuse = False

        if mstate.CmdDown():
            reuse = True

        if self.mainFrame.GetActiveStatsWindow() == None and reuse:
            ItemStatsDialog(stuff, fullContext)

        elif reuse:
            lastWnd = self.mainFrame.GetActiveStatsWindow()
            pos = lastWnd.GetPosition()
            maximized = lastWnd.IsMaximized()
            if not maximized:
                size = lastWnd.GetSize()
            else:
                size = wx.DefaultSize
                pos = wx.DefaultPosition
            ItemStatsDialog(stuff, fullContext, pos, size, maximized)
            lastWnd.closeEvent(None)

        else:
            ItemStatsDialog(stuff, fullContext)

ItemStats.register()

########NEW FILE########
__FILENAME__ = marketJump
from gui.contextMenu import ContextMenu
from gui.itemStats import ItemStatsDialog
import gui.mainFrame
import service

class MarketJump(ContextMenu):
    def __init__(self):
        self.mainFrame = gui.mainFrame.MainFrame.getInstance()

    def display(self, srcContext, selection):
        validContexts = ("marketItemMisc", "fittingModule", "fittingCharge", "droneItem", "implantItem",
                         "boosterItem", "projectedModule", "projectedDrone", "projectedCharge", "cargoItem")
        if not srcContext in validContexts:
            return False
        sMkt = service.Market.getInstance()
        if selection is None or len(selection) < 1:
            return False
        item = getattr(selection[0], "item", selection[0])
        mktGrp = sMkt.getMarketGroupByItem(item)
        # 1663 is Special Edition Festival Assets, we don't have root group for it
        if mktGrp is None or mktGrp.ID == 1663:
            return False
        doit =  not selection[0].isEmpty if srcContext == "fittingModule" else True
        return doit

    def getText(self, itmContext, selection):
        return "{0} Market Group".format(itmContext if itmContext is not None else "Item")

    def activate(self, fullContext, selection, i):
        srcContext = fullContext[0]
        if srcContext in ("fittingModule", "droneItem", "implantItem", "boosterItem", "projectedModule", "projectedDrone", "cargoItem"):
            item = selection[0].item
        elif srcContext in ("fittingCharge", "projectedCharge"):
            item = selection[0].charge
        else:
            item = selection[0]

        self.mainFrame.notebookBrowsers.SetSelection(0)
        self.mainFrame.marketBrowser.jump(item)

MarketJump.register()

########NEW FILE########
__FILENAME__ = moduleAmmoPicker
# -*- coding: utf-8 -*-
from gui.contextMenu import ContextMenu
import gui.mainFrame
import service
import wx
from gui import bitmapLoader
from eos.types import Hardpoint
import gui.globalEvents as GE

class ModuleAmmoPicker(ContextMenu):
    def __init__(self):
        self.mainFrame = gui.mainFrame.MainFrame.getInstance()

    def display(self, srcContext, selection):
        if self.mainFrame.getActiveFit() is None or srcContext not in ("fittingModule", "projectedModule"):
            return False

        modules = selection if srcContext == "fittingModule" else (selection[0],)

        validCharges = None
        checkedTypes = set()
        for mod in modules:
            if mod.item.ID in checkedTypes:
                continue
            checkedTypes.add(mod.item.ID)
            currCharges = mod.getValidCharges()
            if len(currCharges) > 0:
                if validCharges is not None and validCharges != currCharges:
                    return False

                validCharges = currCharges
                self.module = mod

        if validCharges is None:
            return False

        self.modules = modules
        self.charges = list(filter(lambda charge: service.Market.getInstance().getPublicityByItem(charge), validCharges))
        return len(self.charges) > 0

    def getText(self, itmContext, selection):
        return "Charge"

    def activate(self, fullContext, selection, i):
        pass

    DAMAGE_TYPES = ("em", "explosive", "kinetic", "thermal")
    def turretSorter(self, charge):
        damage = 0
        range = (self.module.getModifiedItemAttr("maxRange") or 0) * (charge.getAttribute("weaponRangeMultiplier") or 1)
        falloff = (self.module.getModifiedItemAttr("falloff") or 0) * (charge.getAttribute("fallofMultiplier") or 1)
        for type in self.DAMAGE_TYPES:
            d = charge.getAttribute("%sDamage" % type)
            if d > 0:
                damage += d

        # Take optimal and half falloff as range factor
        rangeFactor = range + falloff / 2

        return (- rangeFactor, charge.name.rsplit()[-2:], damage, charge.name)

    MISSILE_ORDER = ("em", "thermal", "kinetic", "explosive", "mixed")
    def missileSorter(self, charge):
        # Get charge damage type and total damage
        chargeDamageType, totalDamage = self.damageInfo(charge)
        # Find its position in sort list
        position = self.MISSILE_ORDER.index(chargeDamageType)
        return (position, totalDamage, charge.name)

    def damageInfo(self, charge):
        # Set up data storage for missile damage stuff
        damageMap = {}
        totalDamage = 0
        # Fill them with the data about charge
        for damageType in self.DAMAGE_TYPES:
            currentDamage = charge.getAttribute("{0}Damage".format(damageType)) or 0
            damageMap[damageType] = currentDamage
            totalDamage += currentDamage
        # Detect type of ammo
        chargeDamageType = None
        for damageType in damageMap:
            # If all damage belongs to certain type purely, set appropriate
            # ammoType
            if damageMap[damageType] == totalDamage:
                chargeDamageType = damageType
                break
        # Else consider ammo as mixed damage
        if chargeDamageType is None:
            chargeDamageType = "mixed"

        return chargeDamageType, totalDamage


    def numericConverter(self, string):
        return int(string) if string.isdigit() else string

    def nameSorter(self, charge):
        parts = charge.name.split(" ")
        return map(self.numericConverter, parts)

    def addCharge(self, menu, charge):
        id = wx.NewId()
        name = charge.name if charge is not None else "Empty"
        self.chargeIds[id] = charge
        item = wx.MenuItem(menu, id, name)
        item.charge = charge
        if charge is not None and charge.icon is not None:
            bitmap = bitmapLoader.getBitmap(charge.icon.iconFile, "pack")
            if bitmap is not None:
                item.SetBitmap(bitmap)

        return item

    def addSeperator(self, m, text):
        id = wx.NewId()
        m.Append(id, u'─ %s ─' % text)
        m.Enable(id, False)

    def getSubMenu(self, context, selection, menu, i):
        self.context = context
        menu.Bind(wx.EVT_MENU, self.handleAmmoSwitch)
        m = wx.Menu()
        m.Bind(wx.EVT_MENU, self.handleAmmoSwitch)
        self.chargeIds = {}
        hardpoint = self.module.hardpoint
        moduleName = self.module.item.name
        # Make sure we do not consider mining turrets as combat turrets
        if hardpoint == Hardpoint.TURRET and self.module.getModifiedItemAttr("miningAmount") is None:
            self.addSeperator(m, "Long Range")
            items = []
            range = None
            nameBase = None
            sub = None
            self.charges.sort(key=self.turretSorter)
            for charge in self.charges:
                # fix issue 71 - will probably have to change if CCP adds more Orbital ammo
                if "Orbital" in charge.name:
                    # uncomment if we ever want to include Oribital ammo in ammo picker - see issue #71
                    # This allows us to hide the ammo, but it's still loadable from the market
                    #item = self.addCharge(m, charge)
                    #items.append(item)
                    continue
                currBase = charge.name.rsplit()[-2:]
                currRange = charge.getAttribute("weaponRangeMultiplier")
                if nameBase is None or range != currRange or nameBase != currBase:
                    if sub is not None:
                        self.addSeperator(sub, "More Damage")

                    sub = None
                    base = charge
                    nameBase = currBase
                    range = currRange
                    item = self.addCharge(m, charge)
                    items.append(item)
                else:
                    if sub is None:
                        sub = wx.Menu()
                        sub.Bind(wx.EVT_MENU, self.handleAmmoSwitch)
                        self.addSeperator(sub, "Less Damage")
                        item.SetSubMenu(sub)
                        sub.AppendItem(self.addCharge(sub, base))

                    sub.AppendItem(self.addCharge(sub, charge))

            if sub is not None:
                self.addSeperator(sub, "More Damage")

            for item in items:
                m.AppendItem(item)

            self.addSeperator(m, "Short Range")
        elif hardpoint == Hardpoint.MISSILE and moduleName != 'Festival Launcher':
            self.charges.sort(key=self.missileSorter)
            type = None
            sub = None
            defender = None
            for charge in self.charges:
                currType = self.damageInfo(charge)[0]

                if currType != type or type is None:
                    if sub is not None:
                        self.addSeperator(sub, "More Damage")

                    type = currType
                    item = wx.MenuItem(m, wx.ID_ANY, type.capitalize())
                    bitmap = bitmapLoader.getBitmap("%s_small" % type, "icons")
                    if bitmap is not None:
                        item.SetBitmap(bitmap)

                    sub = wx.Menu()
                    sub.Bind(wx.EVT_MENU, self.handleAmmoSwitch)
                    self.addSeperator(sub, "Less Damage")
                    item.SetSubMenu(sub)
                    m.AppendItem(item)

                if charge.name not in ("Light Defender Missile I", "Heavy Defender Missile I"):
                    sub.AppendItem(self.addCharge(sub, charge))
                else:
                    defender = charge

            if defender is not None:
                m.AppendItem(self.addCharge(sub, defender))
            if sub is not None:
                self.addSeperator(sub, "More Damage")
        else:
            self.charges.sort(key=self.nameSorter)
            for charge in self.charges:
                m.AppendItem(self.addCharge(m, charge))

        m.AppendItem(self.addCharge(m, None))
        return m

    def handleAmmoSwitch(self, event):
        charge = self.chargeIds.get(event.Id, False)
        if charge is False:
            event.Skip()
            return

        sFit = service.Fit.getInstance()
        fitID = self.mainFrame.getActiveFit()

        sFit.setAmmo(fitID, charge.ID if charge is not None else None, self.modules)
        wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=fitID))

ModuleAmmoPicker.register()

########NEW FILE########
__FILENAME__ = project
from gui.contextMenu import ContextMenu
import gui.mainFrame
import service
import gui.globalEvents as GE
import wx

class Project(ContextMenu):
    def __init__(self):
        self.mainFrame = gui.mainFrame.MainFrame.getInstance()

    def display(self, srcContext, selection):
        if srcContext not in ("marketItemGroup", "marketItemMisc") or self.mainFrame.getActiveFit() is None:
            return False

        item = selection[0]
        return item.isType("projected")

    def getText(self, itmContext, selection):
        return "Project {0} onto Fit".format(itmContext)

    def activate(self, fullContext, selection, i):
        sFit = service.Fit.getInstance()
        fitID = self.mainFrame.getActiveFit()
        trigger = sFit.project(fitID, selection[0])
        if trigger:
            wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=fitID))
            self.mainFrame.additionsPane.select("Projected")

Project.register()

########NEW FILE########
__FILENAME__ = whProjector
from gui.contextMenu import ContextMenu
import gui.mainFrame
import gui.globalEvents as GE
import service
import wx

class WhProjector(ContextMenu):
    def __init__(self):
        self.mainFrame = gui.mainFrame.MainFrame.getInstance()

    def display(self, srcContext, selection):
        return srcContext == "projected"

    def getText(self, itmContext, selection):
        return "Add System Effects"

    def activate(self, fullContext, selection, i):
        pass

    def getSubMenu(self, context, selection, menu, i):
        self.idmap = {}
        menu.Bind(wx.EVT_MENU, self.handleSelection)
        m = wx.Menu()
        sMkt = service.Market.getInstance()
        effdata = sMkt.getSystemWideEffects()
        for swType in sorted(effdata):
            item = wx.MenuItem(m, wx.ID_ANY, swType)
            sub = wx.Menu()
            sub.Bind(wx.EVT_MENU, self.handleSelection)
            item.SetSubMenu(sub)
            m.AppendItem(item)
            for swData in sorted(effdata[swType], key=lambda tpl: tpl[2]):
                wxid = wx.NewId()
                swObj, swName, swClass = swData
                self.idmap[wxid] = (swObj, swName)
                subitem = wx.MenuItem(sub, wxid, swClass)
                sub.AppendItem(subitem)
        return m


    def handleSelection(self, event):
        #Skip events ids that aren't mapped

        swObj, swName = self.idmap.get(event.Id, (False, False))
        if not swObj and not swName:
            event.Skip()
            return

        sFit = service.Fit.getInstance()
        fitID = self.mainFrame.getActiveFit()
        sFit.project(fitID, swObj)
        wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=fitID))

WhProjector.register()

########NEW FILE########
__FILENAME__ = fitDps
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from gui.graph import Graph
import service
from gui import bitmapLoader
from eos.graph.fitDps import FitDpsGraph as FitDps
from eos.graph import Data
import gui.mainFrame
import service

class FitDpsGraph(Graph):
    propertyAttributeMap = {"angle": "maxVelocity",
                            "distance": "maxRange",
                            "signatureRadius": "signatureRadius",
                            "velocity": "maxVelocity"}

    propertyLabelMap = {"angle": "Target Angle (degrees)",
                        "distance": "Distance to Target (km)",
                        "signatureRadius": "Target Signature Radius (m)",
                        "velocity": "Target Velocity (m/s)"}

    defaults = FitDps.defaults.copy()

    def __init__(self):
        Graph.__init__(self)
        self.defaults["distance"] = "0-20"
        self.name = "DPS"
        self.fitDps = None
        self.mainFrame = gui.mainFrame.MainFrame.getInstance()

    def getFields(self):
        return self.defaults

    def getLabels(self):
        return self.propertyLabelMap

    def getIcons(self):
        icons = {}
        sFit = service.Attribute.getInstance()
        for key, attrName in self.propertyAttributeMap.iteritems():
            iconFile = sFit.getAttributeInfo(attrName).icon.iconFile
            bitmap = bitmapLoader.getBitmap(iconFile, "pack")
            if bitmap:
                icons[key] = bitmap

        return icons

    def getPoints(self, fit, fields):
        fitDps = getattr(self, "fitDps", None)
        if fitDps is None or fitDps.fit != fit:
            fitDps = self.fitDps = FitDps(fit)

        fitDps.clearData()
        variable = None
        for fieldName, value in fields.iteritems():
            d = Data(fieldName, value)
            if not d.isConstant():
                if variable is None:
                    variable = fieldName
                else:
                    #We can't handle more then one variable atm, OOPS FUCK OUT
                    return False, "Can only handle 1 variable"

            fitDps.setData(d)

        if variable is None:
            return False, "No variable"

        x = []
        y = []
        for point, val in fitDps.getIterator():
            x.append(point[variable])
            y.append(val)

        return x, y

FitDpsGraph.register()

########NEW FILE########
__FILENAME__ = dummyView
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import wx
from gui.preferenceView import PreferenceView
from gui import bitmapLoader
class DummyView(PreferenceView):
    title = "Dummy"

    def populatePanel(self, panel):

        mainSizer = wx.BoxSizer( wx.VERTICAL )

        headerSizer = self.initHeader(panel)
        mainSizer.Add( headerSizer, 0, wx.EXPAND, 5 )

        self.stline1 = wx.StaticLine( panel, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.LI_HORIZONTAL )
        mainSizer.Add( self.stline1, 0, wx.EXPAND, 5 )

        contentSizer = self.initContent(panel)
        mainSizer.Add( contentSizer, 1, wx.EXPAND|wx.TOP|wx.BOTTOM|wx.LEFT, 10 )

        self.stline2 = wx.StaticLine( panel, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.LI_HORIZONTAL )
        mainSizer.Add( self.stline2, 0, wx.EXPAND, 5 )


        footerSizer = self.initFooter(panel)
        mainSizer.Add( footerSizer, 0, wx.EXPAND, 5 )
        panel.SetSizer( mainSizer )
        panel.Layout()

    def refreshPanel(self, fit):
        pass

    def initHeader(self, panel):
        headerSizer = wx.BoxSizer( wx.VERTICAL )
        self.stTitle = wx.StaticText( panel, wx.ID_ANY, u"Dummy", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.stTitle.Wrap( -1 )
        self.stTitle.SetFont( wx.Font( 14, 70, 90, 90, False, wx.EmptyString ) )
        headerSizer.Add( self.stTitle, 0, wx.ALL, 5)

        return headerSizer

    def initContent(self, panel):
        contentSizer = wx.BoxSizer( wx.VERTICAL )

        self.m_checkBox2 = wx.CheckBox( panel, wx.ID_ANY, u"Check Me!", wx.DefaultPosition, wx.DefaultSize, 0 )
        contentSizer.Add( self.m_checkBox2, 0, wx.ALL, 5 )

        self.m_radioBtn2 = wx.RadioButton( panel, wx.ID_ANY, u"RadioBtn", wx.DefaultPosition, wx.DefaultSize, 0 )
        contentSizer.Add( self.m_radioBtn2, 0, wx.ALL, 5 )

        self.m_slider2 = wx.Slider( panel, wx.ID_ANY, 50, 0, 100, wx.DefaultPosition, wx.DefaultSize, wx.SL_HORIZONTAL )
        contentSizer.Add( self.m_slider2, 0, wx.ALL, 5 )

        self.m_gauge1 = wx.Gauge( panel, wx.ID_ANY, 100, wx.DefaultPosition, wx.DefaultSize, wx.GA_HORIZONTAL )
        contentSizer.Add( self.m_gauge1, 0, wx.ALL, 5 )

        self.m_textCtrl2 = wx.TextCtrl( panel, wx.ID_ANY, wx.EmptyString, wx.DefaultPosition, wx.DefaultSize, 0 )
        contentSizer.Add( self.m_textCtrl2, 0, wx.ALL, 5 )

        return contentSizer

    def initFooter(self, panel):
        footerSizer = wx.BoxSizer( wx.HORIZONTAL )


        footerSizer.AddSpacer( ( 0, 0), 1, wx.EXPAND, 5 )

        self.btnRestore = wx.Button( panel, wx.ID_ANY, u"Restore", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.btnRestore.Enable( False )

        footerSizer.Add( self.btnRestore, 0, wx.ALL, 5 )

        self.btnApply = wx.Button( panel, wx.ID_ANY, u"Apply", wx.DefaultPosition, wx.DefaultSize, 0 )
        footerSizer.Add( self.btnApply, 0, wx.ALL, 5 )
        return footerSizer
DummyView.register()

########NEW FILE########
__FILENAME__ = pyfaGaugePreferences
#!/usr/bin/env python
# -*- coding: utf-8 -*-


import wx
import copy

from gui.preferenceView import PreferenceView
from gui import bitmapLoader
from gui.utils import colorUtils
import gui.utils.drawUtils as drawUtils

###########################################################################
## Class PFGaugePref
###########################################################################

class PFGaugePreview(wx.Window):
    def __init__ (self, parent, id = wx.ID_ANY, value = 0, pos = wx.DefaultPosition, size = wx.DefaultSize, style = 0):
        wx.Window.__init__(self, parent, id, pos = pos, size = size, style = style)

        self.value = float(value)
        self.oldValue = self.value

        self.percS = 0
        self.percE = 0

        self.animate = True
        self.animDir = 1
        self._fractionDigits = 2

        self.colorS = wx.Colour(0,0,0,255)
        self.colorE = wx.Colour(0,0,0,255)
        self.gradientStart = 0

        self.bkColor = wx.Colour(0,0,0,255)
        self.SetMinSize((100,-1))

        self.font = wx.FontFromPixelSize((0,13),wx.SWISS, wx.NORMAL, wx.NORMAL, False)

        self.timerID = wx.NewId()
        self.timer = wx.Timer(self, self.timerID)
        self.timerInterval = 20

        self.Bind(wx.EVT_PAINT, self.OnPaint)
        self.Bind(wx.EVT_ENTER_WINDOW, self.OnWindowEnter)
        self.Bind(wx.EVT_LEAVE_WINDOW, self.OnWindowLeave)
        self.Bind(wx.EVT_TIMER, self.OnTimer)
        self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnEraseBk)

    def OnEraseBk(self, event):
        pass

    def OnTimer(self, event):
        if event.GetId() == self.timerID:
            self.value += self.animDir
            if self.value > 100:
                self.value = 100
                self.animDir = -1
            if self.value <0:
                self.value = 0
                self.animDir = 1
            self.Refresh()

    def OnWindowEnter(self, event):
        if not self.animate:
            return
        self.oldValue = self.value
        if self.timer.IsRunning():
            self.timer.Stop()
        self.timer.Start(self.timerInterval)
        event.Skip()

    def OnWindowLeave(self, event):
        if not self.animate:
            return
        if self.timer.IsRunning():
            self.timer.Stop()
        self.value = self.oldValue
        self.Refresh()
        event.Skip()

    def CanAnimate(self, anim = True):
        self.animate = anim
        if self.timer.IsRunning():
            self.timer.Stop()
        self.value = self.oldValue
        self.Refresh()

    def SetGradientStart(self, value):
        self.gradientStart = value
        self.Refresh()

    def SetColour(self, colorS, colorE):
        self.colorS = colorS
        self.colorE = colorE

        self.Refresh()

    def SetValue(self, value):
        self.value = min(max(value,0),100)
        self.Refresh()

    def SetPercentages(self, start, end):
        self.percS = start
        self.percE = end
        self.Refresh()

    def OnPaint(self, event):
        rect = self.GetClientRect()
        dc = wx.BufferedPaintDC(self)
        dc.SetBackground(wx.Brush(self.bkColor))
        dc.Clear()

        value = float(self.value)
        if self.percS >= 100:
            w = rect.width
        else:
            w = rect.width * (float(value) / 100)
        r = copy.copy(rect)
        r.width = w

        color = colorUtils.CalculateTransitionColor(self.colorS, self.colorE, float(value)/100)
        if self.gradientStart > 0:
            gcolor = colorUtils.BrightenColor(color,  float(self.gradientStart) / 100)
            gMid = colorUtils.BrightenColor(color,  float(self.gradientStart/2) / 100)
        else:
            gcolor = colorUtils.DarkenColor(color,  float(-self.gradientStart) / 100)
            gMid = colorUtils.DarkenColor(color,  float(-self.gradientStart/2) / 100)

        gBmp = drawUtils.DrawGradientBar(r.width, r.height, gMid, color, gcolor)
        dc.DrawBitmap(gBmp,0,0)
        dc.SetFont(self.font)

        r = copy.copy(rect)
        r.left +=1
        r.top +=1


        formatStr = "{0:." + str(self._fractionDigits) + "f}%"
        value = (self.percE - self.percS) * value / (self.percE - self.percS)
        value = self.percS + (self.percE - self.percS) * value / 100

        dc.SetTextForeground(wx.Colour(80,80,80))
        dc.DrawLabel(formatStr.format(value), r, wx.ALIGN_CENTER)

        dc.SetTextForeground(wx.Colour(255,255,255))
        dc.DrawLabel(formatStr.format(value), rect, wx.ALIGN_CENTER)


class PFGaugePref ( PreferenceView):
    title = "Pyfa Gauge Theme"
    def populatePanel( self, panel ):

        self.InitDefaultColours()

        mainSizer = wx.BoxSizer( wx.VERTICAL )

        gSizer1 = wx.BoxSizer( wx.HORIZONTAL )

        self.st0100 = wx.StaticText( panel, wx.ID_ANY, u"0 - 100", wx.DefaultPosition, wx.DefaultSize, wx.ALIGN_RIGHT )
        self.st0100.Wrap( -1 )
        gSizer1.Add( self.st0100, 1, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5 )

        self.cp0100S = wx.ColourPickerCtrl( panel, wx.ID_ANY, wx.BLACK, wx.DefaultPosition, wx.DefaultSize, wx.CLRP_DEFAULT_STYLE | wx.CLRP_SHOW_LABEL )
        gSizer1.Add( self.cp0100S, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5 )

        self.cp0100E = wx.ColourPickerCtrl( panel, wx.ID_ANY, wx.BLACK, wx.DefaultPosition, wx.DefaultSize, wx.CLRP_DEFAULT_STYLE | wx.CLRP_SHOW_LABEL )
        gSizer1.Add( self.cp0100E, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5 )

        self.gauge0100S = PFGaugePreview( panel, wx.ID_ANY, 33, wx.DefaultPosition, wx.DefaultSize, wx.SIMPLE_BORDER )
        gSizer1.Add( self.gauge0100S, 0, wx.ALIGN_CENTER_VERTICAL|wx.LEFT, 5 )

        self.gauge0100M = PFGaugePreview( panel, wx.ID_ANY, 66, wx.DefaultPosition, wx.DefaultSize, wx.SIMPLE_BORDER )
        gSizer1.Add( self.gauge0100M, 0, wx.ALIGN_CENTER_VERTICAL|wx.LEFT, 5 )

        self.gauge0100E = PFGaugePreview( panel, wx.ID_ANY, 100, wx.DefaultPosition, wx.DefaultSize, wx.SIMPLE_BORDER )
        gSizer1.Add( self.gauge0100E, 0, wx.ALIGN_CENTER_VERTICAL|wx.RIGHT|wx.LEFT, 5 )

        mainSizer.Add( gSizer1, 0, wx.EXPAND, 5 )

        gSizer2 = wx.BoxSizer( wx.HORIZONTAL )

        self.st100101 = wx.StaticText( panel, wx.ID_ANY, u"100 - 101", wx.DefaultPosition, wx.DefaultSize, wx.ALIGN_RIGHT )
        self.st100101.Wrap( -1 )
        gSizer2.Add( self.st100101, 1, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5 )

        self.cp100101S = wx.ColourPickerCtrl( panel, wx.ID_ANY, wx.BLACK, wx.DefaultPosition, wx.DefaultSize, wx.CLRP_DEFAULT_STYLE | wx.CLRP_SHOW_LABEL )
        gSizer2.Add( self.cp100101S, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5 )

        self.cp100101E = wx.ColourPickerCtrl( panel, wx.ID_ANY, wx.BLACK, wx.DefaultPosition, wx.DefaultSize, wx.CLRP_DEFAULT_STYLE | wx.CLRP_SHOW_LABEL )
        gSizer2.Add( self.cp100101E, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5 )

        self.gauge100101S = PFGaugePreview( panel, wx.ID_ANY, 33, wx.DefaultPosition, wx.DefaultSize, wx.SIMPLE_BORDER )
        gSizer2.Add( self.gauge100101S, 0, wx.ALIGN_CENTER_VERTICAL|wx.LEFT, 5 )

        self.gauge100101M = PFGaugePreview( panel, wx.ID_ANY, 66, wx.DefaultPosition, wx.DefaultSize, wx.SIMPLE_BORDER )
        gSizer2.Add( self.gauge100101M, 0, wx.ALIGN_CENTER_VERTICAL|wx.LEFT, 5 )

        self.gauge100101E = PFGaugePreview( panel, wx.ID_ANY, 100, wx.DefaultPosition, wx.DefaultSize, wx.SIMPLE_BORDER )
        gSizer2.Add( self.gauge100101E, 0, wx.ALIGN_CENTER_VERTICAL|wx.RIGHT|wx.LEFT, 5 )

        mainSizer.Add( gSizer2, 0, wx.EXPAND, 5 )

        gSizer3 = wx.BoxSizer( wx.HORIZONTAL )

        self.st101103 = wx.StaticText( panel, wx.ID_ANY, u"101 - 103", wx.DefaultPosition, wx.DefaultSize, wx.ALIGN_RIGHT )
        self.st101103.Wrap( -1 )
        gSizer3.Add( self.st101103, 1, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5 )

        self.cp101103S = wx.ColourPickerCtrl( panel, wx.ID_ANY, wx.BLACK, wx.DefaultPosition, wx.DefaultSize, wx.CLRP_DEFAULT_STYLE | wx.CLRP_SHOW_LABEL )
        gSizer3.Add( self.cp101103S, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5 )

        self.cp101103E = wx.ColourPickerCtrl( panel, wx.ID_ANY, wx.BLACK, wx.DefaultPosition, wx.DefaultSize, wx.CLRP_DEFAULT_STYLE | wx.CLRP_SHOW_LABEL )
        gSizer3.Add( self.cp101103E, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5 )

        self.gauge101103S = PFGaugePreview( panel, wx.ID_ANY, 33, wx.DefaultPosition, wx.DefaultSize, wx.SIMPLE_BORDER )
        gSizer3.Add( self.gauge101103S, 0, wx.ALIGN_CENTER_VERTICAL|wx.LEFT, 5 )

        self.gauge101103M = PFGaugePreview( panel, wx.ID_ANY, 66, wx.DefaultPosition, wx.DefaultSize, wx.SIMPLE_BORDER )
        gSizer3.Add( self.gauge101103M, 0, wx.ALIGN_CENTER_VERTICAL|wx.LEFT, 5 )

        self.gauge101103E = PFGaugePreview( panel, wx.ID_ANY, 100, wx.DefaultPosition, wx.DefaultSize, wx.SIMPLE_BORDER )
        gSizer3.Add( self.gauge101103E, 0, wx.ALIGN_CENTER_VERTICAL|wx.RIGHT|wx.LEFT, 5 )

        mainSizer.Add( gSizer3, 0, wx.EXPAND, 5 )

        gSizer4 = wx.BoxSizer( wx.HORIZONTAL )

        self.st103105 = wx.StaticText( panel, wx.ID_ANY, u"103 - 105", wx.DefaultPosition, wx.DefaultSize, wx.ALIGN_RIGHT )
        self.st103105.Wrap( -1 )
        gSizer4.Add( self.st103105, 1, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5 )

        self.cp103105S = wx.ColourPickerCtrl( panel, wx.ID_ANY, wx.BLACK, wx.DefaultPosition, wx.DefaultSize, wx.CLRP_DEFAULT_STYLE | wx.CLRP_SHOW_LABEL )
        gSizer4.Add( self.cp103105S, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5 )

        self.cp103105E = wx.ColourPickerCtrl( panel, wx.ID_ANY, wx.BLACK, wx.DefaultPosition, wx.DefaultSize, wx.CLRP_DEFAULT_STYLE | wx.CLRP_SHOW_LABEL )
        gSizer4.Add( self.cp103105E, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5 )

        self.gauge103105S = PFGaugePreview( panel, wx.ID_ANY, 33, wx.DefaultPosition, wx.DefaultSize, wx.SIMPLE_BORDER )
        gSizer4.Add( self.gauge103105S, 0, wx.ALIGN_CENTER_VERTICAL|wx.LEFT, 5 )

        self.gauge103105M = PFGaugePreview( panel, wx.ID_ANY, 66, wx.DefaultPosition, wx.DefaultSize, wx.SIMPLE_BORDER )
        gSizer4.Add( self.gauge103105M, 0, wx.ALIGN_CENTER_VERTICAL|wx.LEFT, 5 )

        self.gauge103105E = PFGaugePreview( panel, wx.ID_ANY, 100, wx.DefaultPosition, wx.DefaultSize, wx.SIMPLE_BORDER )
        gSizer4.Add( self.gauge103105E, 0, wx.ALIGN_CENTER_VERTICAL|wx.RIGHT|wx.LEFT, 5 )

        mainSizer.Add( gSizer4, 0, wx.EXPAND, 5 )

        footerSizer = wx.BoxSizer( wx.VERTICAL )

        self.sl1 = wx.StaticLine( panel, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.LI_HORIZONTAL )
        footerSizer.Add( self.sl1, 0, wx.EXPAND |wx.ALL, 5 )

        previewSizer = wx.BoxSizer( wx.HORIZONTAL )

        self.wndPreview0100 = PFGaugePreview( panel, wx.ID_ANY, 100, wx.DefaultPosition, wx.DefaultSize, 0)
        previewSizer.Add( self.wndPreview0100, 1, wx.ALIGN_CENTER_VERTICAL, 5 )

        self.wndPreview100101 = PFGaugePreview( panel, wx.ID_ANY, 100, wx.DefaultPosition, wx.DefaultSize, 0)
        previewSizer.Add( self.wndPreview100101, 1, wx.ALIGN_CENTER_VERTICAL, 5 )

        self.wndPreview101103 = PFGaugePreview( panel, wx.ID_ANY, 100, wx.DefaultPosition, wx.DefaultSize, 0)
        previewSizer.Add( self.wndPreview101103, 1, wx.ALIGN_CENTER_VERTICAL, 5 )

        self.wndPreview103105 = PFGaugePreview( panel, wx.ID_ANY, 100, wx.DefaultPosition, wx.DefaultSize, 0)
        previewSizer.Add( self.wndPreview103105, 1, wx.ALIGN_CENTER_VERTICAL, 5 )

        footerSizer.Add( previewSizer, 1, wx.EXPAND | wx.ALL, 5 )

        buttonsSizer = wx.BoxSizer( wx.HORIZONTAL )

        self.cbLink = wx.CheckBox( panel, wx.ID_ANY, u"Link Colors", wx.DefaultPosition, wx.DefaultSize, 0 )
        buttonsSizer.Add( self.cbLink, 0, wx.ALIGN_CENTER_VERTICAL | wx.RIGHT | wx.LEFT, 5 )

        self.sliderGradientStart = wx.Slider( panel, wx.ID_ANY, self.gradientStart, -100, 100, wx.DefaultPosition, (127,-1), wx.SL_HORIZONTAL|wx.SL_LABELS )
        buttonsSizer.Add( self.sliderGradientStart, 1, wx.EXPAND | wx.ALL | wx.ALIGN_CENTER_VERTICAL, 5 )

        self.btnRestore = wx.Button( panel, wx.ID_ANY, u"Restore Defaults", wx.DefaultPosition, wx.DefaultSize, 0 )
        buttonsSizer.Add( self.btnRestore, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 5 )

        self.btnDump = wx.Button( panel, wx.ID_ANY, u"Dump Colors", wx.DefaultPosition, wx.DefaultSize, 0 )
        buttonsSizer.Add( self.btnDump, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 5 )

        self.btnOk = wx.Button( panel, wx.ID_ANY, u"Apply", wx.DefaultPosition, wx.DefaultSize, 0 )
        buttonsSizer.Add( self.btnOk, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 5 )

        footerSizer.Add( buttonsSizer, 1, wx.ALIGN_RIGHT, 5 )
        mainSizer.Add( footerSizer, 0, wx.EXPAND, 5 )

        panel.SetSizer( mainSizer )

        self.SetColours()

#        self.Fit()
#        self.Layout()

        self.sliderGradientStart.Bind(wx.EVT_SCROLL, self.OnGradientStartScroll)
        self.btnRestore.Bind(wx.EVT_BUTTON, self.RestoreDefaults)
        self.btnDump.Bind(wx.EVT_BUTTON, self.DumpColours)
        self.btnOk.Bind(wx.EVT_BUTTON, self.OnOk)

        self.cp0100S.Bind( wx.EVT_COLOURPICKER_CHANGED, self.OnColourChanged )
        self.cp0100E.Bind( wx.EVT_COLOURPICKER_CHANGED, self.OnColourChanged )

        self.cp100101S.Bind( wx.EVT_COLOURPICKER_CHANGED, self.OnColourChanged )
        self.cp100101E.Bind( wx.EVT_COLOURPICKER_CHANGED, self.OnColourChanged )

        self.cp101103S.Bind( wx.EVT_COLOURPICKER_CHANGED, self.OnColourChanged )
        self.cp101103E.Bind( wx.EVT_COLOURPICKER_CHANGED, self.OnColourChanged )

        self.cp103105S.Bind( wx.EVT_COLOURPICKER_CHANGED, self.OnColourChanged )
        self.cp103105E.Bind( wx.EVT_COLOURPICKER_CHANGED, self.OnColourChanged )

    def getImage(self):
        return bitmapLoader.getBitmap("pref-gauges_big", "icons")

    def InitDefaultColours(self):
        self.c0100S = wx.Colour(191, 191, 191, 255)
        self.c0100E = wx.Colour(96, 191, 0, 255)

        self.c100101S = wx.Colour(191, 167, 96, 255)
        self.c100101E = wx.Colour(255, 191, 0, 255)

        self.c101103S = wx.Colour(255, 191, 0, 255)
        self.c101103E = wx.Colour(255, 128, 0, 255)

        self.c103105S = wx.Colour(255, 128, 0, 255)
        self.c103105E = wx.Colour(255, 0, 0, 255)
        self.gradientStart = -35

    def SetColours(self):
        self.cp0100S.SetColour(self.c0100S)
        self.cp0100E.SetColour(self.c0100E)
        self.gauge0100S.SetColour(self.c0100S, self.c0100E)
        self.gauge0100M.SetColour(self.c0100S, self.c0100E)
        self.gauge0100E.SetColour(self.c0100S, self.c0100E)

        self.gauge0100S.SetPercentages(0, 99.99)
        self.gauge0100M.SetPercentages(0, 99.99)
        self.gauge0100E.SetPercentages(0, 99.99)

        self.gauge0100S.SetGradientStart(self.sliderGradientStart.GetValue())
        self.gauge0100M.SetGradientStart(self.sliderGradientStart.GetValue())
        self.gauge0100E.SetGradientStart(self.sliderGradientStart.GetValue())


        self.cp100101S.SetColour(self.c100101S)
        self.cp100101E.SetColour(self.c100101E)
        self.gauge100101S.SetColour(self.c100101S, self.c100101E)
        self.gauge100101M.SetColour(self.c100101S, self.c100101E)
        self.gauge100101E.SetColour(self.c100101S, self.c100101E)

        self.gauge100101S.SetGradientStart(self.sliderGradientStart.GetValue())
        self.gauge100101M.SetGradientStart(self.sliderGradientStart.GetValue())
        self.gauge100101E.SetGradientStart(self.sliderGradientStart.GetValue())

        self.gauge100101S.SetPercentages(100, 100.99)
        self.gauge100101M.SetPercentages(100, 100.99)
        self.gauge100101E.SetPercentages(100, 100.99)

        self.gauge100101S.SetGradientStart(self.sliderGradientStart.GetValue())
        self.gauge100101M.SetGradientStart(self.sliderGradientStart.GetValue())
        self.gauge100101E.SetGradientStart(self.sliderGradientStart.GetValue())


        self.cp101103S.SetColour(self.c101103S)
        self.cp101103E.SetColour(self.c101103E)
        self.gauge101103S.SetColour(self.c101103S, self.c101103E)
        self.gauge101103M.SetColour(self.c101103S, self.c101103E)
        self.gauge101103E.SetColour(self.c101103S, self.c101103E)

        self.gauge101103S.SetPercentages(101, 102.99)
        self.gauge101103M.SetPercentages(101, 102.99)
        self.gauge101103E.SetPercentages(101, 102.99)

        self.gauge101103S.SetGradientStart(self.sliderGradientStart.GetValue())
        self.gauge101103M.SetGradientStart(self.sliderGradientStart.GetValue())
        self.gauge101103E.SetGradientStart(self.sliderGradientStart.GetValue())


        self.cp103105S.SetColour(self.c103105S)
        self.cp103105E.SetColour(self.c103105E)
        self.gauge103105S.SetColour(self.c103105S, self.c103105E)
        self.gauge103105M.SetColour(self.c103105S, self.c103105E)
        self.gauge103105E.SetColour(self.c103105S, self.c103105E)

        self.gauge103105S.SetPercentages(103, 104.99)
        self.gauge103105M.SetPercentages(103, 104.99)
        self.gauge103105E.SetPercentages(103, 104.99)

        self.gauge103105S.SetGradientStart(self.sliderGradientStart.GetValue())
        self.gauge103105M.SetGradientStart(self.sliderGradientStart.GetValue())
        self.gauge103105E.SetGradientStart(self.sliderGradientStart.GetValue())

        self.wndPreview0100.SetColour(self.c0100S, self.c0100E)
        self.wndPreview0100.SetPercentages(0, 99.99)
        self.wndPreview0100.SetGradientStart(self.sliderGradientStart.GetValue())

        self.wndPreview100101.SetColour(self.c100101S, self.c100101E)
        self.wndPreview100101.SetPercentages(100, 100.99)
        self.wndPreview100101.SetGradientStart(self.sliderGradientStart.GetValue())

        self.wndPreview101103.SetColour(self.c101103S, self.c101103E)
        self.wndPreview101103.SetPercentages(101, 102.99)
        self.wndPreview101103.SetGradientStart(self.sliderGradientStart.GetValue())

        self.wndPreview103105.SetColour(self.c103105S, self.c103105E)
        self.wndPreview103105.SetPercentages(103,104.99)
        self.wndPreview103105.SetGradientStart(self.sliderGradientStart.GetValue())

    def OnGradientStartScroll(self, event):
        self.gradientStart = self.sliderGradientStart.GetValue()
        self.SetColours()
        event.Skip()

    def OnOk(self, event):
        #Apply New Settings
        event.Skip()

    def DumpColours(self, event):
        print "Gradient start: %d" % self.sliderGradientStart.GetValue()
        print "  0 <-> 100 Start: ", self.c0100S, " End: ", self.c0100E
        print "100 <-> 101 Start: ", self.c100101S, " End: ", self.c100101E
        print "101 <-> 103 Start: ", self.c101103S, " End: ", self.c101103E
        print "103 <-> 105 Start: ", self.c103105S, " End: ", self.c103105E

        event.Skip()

    def RestoreDefaults(self, event):
        self.InitDefaultColours()
        self.sliderGradientStart.SetValue(self.gradientStart)
        self.SetColours()

        event.Skip()

    def OnColourChanged(self, event):

        color = event.EventObject.GetColour()
        cpObj = event.EventObject

        if cpObj == self.cp0100S:
            self.c0100S = color

        if cpObj == self.cp0100E:
            self.c0100E = color
            if self.cbLink.IsChecked():
                self.c100101S = color

        if cpObj == self.cp100101S:
            self.c100101S = color
            if self.cbLink.IsChecked():
                self.c0100E = color

        if cpObj == self.cp100101E:
            self.c100101E = color
            if self.cbLink.IsChecked():
                self.c101103S = color

        if cpObj == self.cp101103S:
            self.c101103S = color
            if self.cbLink.IsChecked():
                self.c100101E = color

        if cpObj == self.cp101103E:
            self.c101103E = color
            if self.cbLink.IsChecked():
                self.c103105S = color

        if cpObj == self.cp103105S:
            self.c103105S = color
            if self.cbLink.IsChecked():
                self.c101103E = color

        if cpObj == self.cp103105E:
            self.c103105E = color

        self.SetColours()
        event.Skip()

    def __del__( self ):
        pass

PFGaugePref.register()

########NEW FILE########
__FILENAME__ = pyfaGeneralPreferences
import wx
import service
import urllib2

from gui.preferenceView import PreferenceView
from gui import bitmapLoader

import gui.mainFrame
import service
import gui.globalEvents as GE


class PFGeneralPref ( PreferenceView):
    title = "General"

    def populatePanel( self, panel ):
        self.mainFrame = gui.mainFrame.MainFrame.getInstance()
        self.dirtySettings = False
        self.openFitsSettings = service.SettingsProvider.getInstance().getSettings("pyfaPrevOpenFits", {"enabled": False, "pyfaOpenFits": []})

        mainSizer = wx.BoxSizer( wx.VERTICAL )

        self.stTitle = wx.StaticText( panel, wx.ID_ANY, self.title, wx.DefaultPosition, wx.DefaultSize, 0 )
        self.stTitle.Wrap( -1 )
        self.stTitle.SetFont( wx.Font( 12, 70, 90, 90, False, wx.EmptyString ) )

        mainSizer.Add( self.stTitle, 0, wx.ALL, 5 )

        self.m_staticline1 = wx.StaticLine( panel, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.LI_HORIZONTAL )
        mainSizer.Add( self.m_staticline1, 0, wx.EXPAND|wx.TOP|wx.BOTTOM, 5 )

        self.cbGlobalChar = wx.CheckBox( panel, wx.ID_ANY, u"Use global character", wx.DefaultPosition, wx.DefaultSize, 0 )
        mainSizer.Add( self.cbGlobalChar, 0, wx.ALL|wx.EXPAND, 5 )

        self.cbGlobalDmgPattern = wx.CheckBox( panel, wx.ID_ANY, u"Use global damage pattern", wx.DefaultPosition, wx.DefaultSize, 0 )
        mainSizer.Add( self.cbGlobalDmgPattern, 0, wx.ALL|wx.EXPAND, 5 )

        self.cbGlobalForceReload = wx.CheckBox( panel, wx.ID_ANY, u"Factor in reload time", wx.DefaultPosition, wx.DefaultSize, 0 )
        mainSizer.Add( self.cbGlobalForceReload, 0, wx.ALL|wx.EXPAND, 5 )

        self.cbCompactSkills = wx.CheckBox( panel, wx.ID_ANY, u"Compact skills needed tooltip", wx.DefaultPosition, wx.DefaultSize, 0 )
        mainSizer.Add( self.cbCompactSkills, 0, wx.ALL|wx.EXPAND, 5 )

        self.cbFitColorSlots = wx.CheckBox( panel, wx.ID_ANY, u"Color fitting view by slot", wx.DefaultPosition, wx.DefaultSize, 0 )
        mainSizer.Add( self.cbFitColorSlots, 0, wx.ALL|wx.EXPAND, 5 )

        self.cbReopenFits = wx.CheckBox( panel, wx.ID_ANY, u"Reopen previous fits on startup", wx.DefaultPosition, wx.DefaultSize, 0 )
        mainSizer.Add( self.cbReopenFits, 0, wx.ALL|wx.EXPAND, 5 )

        self.cbRackSlots = wx.CheckBox( panel, wx.ID_ANY, u"Separate Racks", wx.DefaultPosition, wx.DefaultSize, 0 )
        mainSizer.Add( self.cbRackSlots, 0, wx.ALL|wx.EXPAND, 5 )

        labelSizer = wx.BoxSizer( wx.VERTICAL )
        self.cbRackLabels = wx.CheckBox( panel, wx.ID_ANY, u"Show Rack Labels", wx.DefaultPosition, wx.DefaultSize, 0 )
        labelSizer.Add( self.cbRackLabels, 0, wx.ALL|wx.EXPAND, 5 )
        mainSizer.Add( labelSizer, 0, wx.LEFT|wx.EXPAND, 30 )

        defCharSizer = wx.BoxSizer( wx.HORIZONTAL )

        self.sFit = service.Fit.getInstance()

        self.cbGlobalChar.SetValue(self.sFit.serviceFittingOptions["useGlobalCharacter"])
        self.cbGlobalDmgPattern.SetValue(self.sFit.serviceFittingOptions["useGlobalDamagePattern"])
        self.cbGlobalForceReload.SetValue(self.sFit.serviceFittingOptions["useGlobalForceReload"])
        self.cbFitColorSlots.SetValue(self.sFit.serviceFittingOptions["colorFitBySlot"] or False)
        self.cbRackSlots.SetValue(self.sFit.serviceFittingOptions["rackSlots"] or False)
        self.cbRackLabels.SetValue(self.sFit.serviceFittingOptions["rackLabels"] or False)
        self.cbCompactSkills.SetValue(self.sFit.serviceFittingOptions["compactSkills"] or False)
        self.cbReopenFits.SetValue(self.openFitsSettings["enabled"])

        self.cbGlobalChar.Bind(wx.EVT_CHECKBOX, self.OnCBGlobalCharStateChange)
        self.cbGlobalDmgPattern.Bind(wx.EVT_CHECKBOX, self.OnCBGlobalDmgPatternStateChange)
        self.cbGlobalForceReload.Bind(wx.EVT_CHECKBOX, self.OnCBGlobalForceReloadStateChange)
        self.cbFitColorSlots.Bind(wx.EVT_CHECKBOX, self.onCBGlobalColorBySlot)
        self.cbRackSlots.Bind(wx.EVT_CHECKBOX, self.onCBGlobalRackSlots)
        self.cbRackLabels.Bind(wx.EVT_CHECKBOX, self.onCBGlobalRackLabels)
        self.cbCompactSkills.Bind(wx.EVT_CHECKBOX, self.onCBCompactSkills)
        self.cbReopenFits.Bind(wx.EVT_CHECKBOX, self.onCBReopenFits)

        self.cbRackLabels.Enable(self.sFit.serviceFittingOptions["rackSlots"] or False)

        panel.SetSizer( mainSizer )
        panel.Layout()

    def onCBGlobalColorBySlot(self, event):
        self.sFit.serviceFittingOptions["colorFitBySlot"] = self.cbFitColorSlots.GetValue()
        fitID = self.mainFrame.getActiveFit()
        self.sFit.refreshFit(fitID)
        wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=fitID))
        event.Skip()

    def onCBGlobalRackSlots(self, event):
        self.sFit.serviceFittingOptions["rackSlots"] = self.cbRackSlots.GetValue()
        self.cbRackLabels.Enable(self.cbRackSlots.GetValue())
        fitID = self.mainFrame.getActiveFit()
        self.sFit.refreshFit(fitID)
        wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=fitID))
        event.Skip()

    def onCBGlobalRackLabels(self, event):
        self.sFit.serviceFittingOptions["rackLabels"] = self.cbRackLabels.GetValue()
        fitID = self.mainFrame.getActiveFit()
        self.sFit.refreshFit(fitID)
        wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=fitID))
        event.Skip()

    def OnCBGlobalForceReloadStateChange(self, event):
        self.sFit.serviceFittingOptions["useGlobalForceReload"] = self.cbGlobalForceReload.GetValue()
        fitID = self.mainFrame.getActiveFit()
        self.sFit.refreshFit(fitID)
        wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=fitID))
        event.Skip()

    def OnCBGlobalCharStateChange(self, event):
        self.sFit.serviceFittingOptions["useGlobalCharacter"] = self.cbGlobalChar.GetValue()
        event.Skip()

    def OnCBGlobalDmgPatternStateChange(self, event):
        self.sFit.serviceFittingOptions["useGlobalDamagePattern"] = self.cbGlobalDmgPattern.GetValue()
        event.Skip()

    def onCBCompactSkills(self, event):
        self.sFit.serviceFittingOptions["compactSkills"] = self.cbCompactSkills.GetValue()
        event.Skip()

    def onCBReopenFits(self, event):
        self.openFitsSettings["enabled"] = self.cbReopenFits.GetValue()

    def getImage(self):
        return bitmapLoader.getBitmap("prefs_settings", "icons")

PFGeneralPref.register()

########NEW FILE########
__FILENAME__ = pyfaHTMLExportPreferences
import wx
import service
import urllib2
import os

from gui.preferenceView import PreferenceView
from gui import bitmapLoader

import gui.mainFrame
import service
import gui.globalEvents as GE


class PFHTMLExportPref ( PreferenceView):
    title = "HTML Export"
    desc  = "HTML Export (File > Export HTML) allows you to export your entire fitting "+\
            "database into an HTML file at the specified location. This file can be "+\
            "used in the in-game browser to easily open and import your fits, or used "+\
            "in a regular web browser to open them at NULL-SEC.com."
    desc2 = "Enabling automatic exporting will update the HTML file after any change "+\
            "to a fit is made. Under certain circumstance, this may cause performance issues."

    def populatePanel( self, panel ):
        self.mainFrame = gui.mainFrame.MainFrame.getInstance()
        self.HTMLExportSettings = service.settings.HTMLExportSettings.getInstance()
        self.dirtySettings = False
        dlgWidth = panel.GetParent().GetParent().ClientSize.width
        mainSizer = wx.BoxSizer( wx.VERTICAL )

        self.stTitle = wx.StaticText( panel, wx.ID_ANY, self.title, wx.DefaultPosition, wx.DefaultSize, 0 )
        self.stTitle.Wrap( -1 )
        self.stTitle.SetFont( wx.Font( 12, 70, 90, 90, False, wx.EmptyString ) )
        mainSizer.Add( self.stTitle, 0, wx.ALL, 5 )

        self.m_staticline1 = wx.StaticLine( panel, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.LI_HORIZONTAL )
        mainSizer.Add( self.m_staticline1, 0, wx.EXPAND|wx.TOP|wx.BOTTOM, 5 )

        self.stDesc = wx.StaticText( panel, wx.ID_ANY, self.desc, wx.DefaultPosition, wx.DefaultSize, 0 )
        self.stDesc.Wrap(dlgWidth - 50)
        mainSizer.Add( self.stDesc, 0, wx.ALL, 5 )

        self.PathLinkCtrl = wx.HyperlinkCtrl( panel, wx.ID_ANY, self.HTMLExportSettings.getPath(), u'file:///{}'.format(self.HTMLExportSettings.getPath()), wx.DefaultPosition, wx.DefaultSize, wx.HL_ALIGN_LEFT|wx.NO_BORDER|wx.HL_CONTEXTMENU )
        mainSizer.Add( self.PathLinkCtrl, 0, wx.ALL|wx.EXPAND, 5)

        self.fileSelectDialog = wx.FileDialog(None, "Save Fitting As...", wildcard = "EVE IGB HTML fitting file (*.html)|*.html", style = wx.FD_SAVE)
        self.fileSelectDialog.SetPath(self.HTMLExportSettings.getPath())
        self.fileSelectDialog.SetFilename(os.path.basename(self.HTMLExportSettings.getPath()));

        self.fileSelectButton = wx.Button(panel, -1, "Set export destination", pos=(0,0))
        self.fileSelectButton.Bind(wx.EVT_BUTTON, self.selectHTMLExportFilePath)
        mainSizer.Add( self.fileSelectButton, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)

        self.stDesc2 = wx.StaticText( panel, wx.ID_ANY, self.desc2, wx.DefaultPosition, wx.DefaultSize, 0 )
        self.stDesc2.Wrap(dlgWidth - 50)
        mainSizer.Add( self.stDesc2, 0, wx.ALL, 5 )

        self.exportEnabled = wx.CheckBox( panel, wx.ID_ANY, u"Enable automatic HTML export", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.exportEnabled.SetValue(self.HTMLExportSettings.getEnabled())
        self.exportEnabled.Bind(wx.EVT_CHECKBOX, self.OnExportEnabledChange)
        mainSizer.Add( self.exportEnabled, 0, wx.ALL|wx.EXPAND, 5 )

        panel.SetSizer( mainSizer )
        panel.Layout()

    def setPathLinkCtrlValues(self, path):
        self.PathLinkCtrl.SetLabel(self.HTMLExportSettings.getPath())
        self.PathLinkCtrl.SetURL(u'file:///{}'.format(self.HTMLExportSettings.getPath()))
        self.PathLinkCtrl.SetSize(wx.DefaultSize);
        self.PathLinkCtrl.Refresh()

    def selectHTMLExportFilePath(self, event):
        if self.fileSelectDialog.ShowModal() == wx.ID_OK:
            self.HTMLExportSettings.setPath(self.fileSelectDialog.GetPath())
            self.dirtySettings = True
            self.setPathLinkCtrlValues(self.HTMLExportSettings.getPath())

    def OnExportEnabledChange(self, event):
        self.HTMLExportSettings.setEnabled(self.exportEnabled.GetValue())

    def getImage(self):
        return bitmapLoader.getBitmap("prefs_html", "icons")

PFHTMLExportPref.register()

########NEW FILE########
__FILENAME__ = pyfaProxyPreferences
import wx
import service
import urllib2

from gui.preferenceView import PreferenceView
from gui import bitmapLoader

import gui.mainFrame
import service
import gui.globalEvents as GE


class PFProxyPref ( PreferenceView):
    title = "Proxy"

    def populatePanel( self, panel ):

        self.mainFrame = gui.mainFrame.MainFrame.getInstance()
        self.proxySettings = service.settings.ProxySettings.getInstance()
        self.dirtySettings = False

        self.nMode = self.proxySettings.getMode()
        self.nAddr = self.proxySettings.getAddress()
        self.nPort = self.proxySettings.getPort()
        self.nType = self.proxySettings.getType()

        mainSizer = wx.BoxSizer( wx.VERTICAL )

        self.stTitle = wx.StaticText( panel, wx.ID_ANY, self.title, wx.DefaultPosition, wx.DefaultSize, 0 )
        self.stTitle.Wrap( -1 )
        self.stTitle.SetFont( wx.Font( 12, 70, 90, 90, False, wx.EmptyString ) )

        mainSizer.Add( self.stTitle, 0, wx.ALL, 5 )

        self.m_staticline1 = wx.StaticLine( panel, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.LI_HORIZONTAL )
        mainSizer.Add( self.m_staticline1, 0, wx.EXPAND|wx.TOP|wx.BOTTOM, 5 )

        ptypeSizer = wx.BoxSizer( wx.HORIZONTAL )

        self.stPType = wx.StaticText( panel, wx.ID_ANY, u"Mode:", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.stPType.Wrap( -1 )
        ptypeSizer.Add( self.stPType, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5 )

        self.chProxyTypeChoices = [ u"No proxy", u"Auto-detected proxy settings", u"Manual proxy settings" ]
        self.chProxyType = wx.Choice( panel, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, self.chProxyTypeChoices, 0 )


        self.chProxyType.SetSelection( self.nMode )

        ptypeSizer.Add( self.chProxyType, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5 )

        mainSizer.Add( ptypeSizer, 0, wx.EXPAND, 5 )

        fgAddrSizer = wx.FlexGridSizer( 2, 2, 0, 0 )
        fgAddrSizer.AddGrowableCol( 1 )
        fgAddrSizer.SetFlexibleDirection( wx.BOTH )
        fgAddrSizer.SetNonFlexibleGrowMode( wx.FLEX_GROWMODE_SPECIFIED )


        self.stPSetAddr = wx.StaticText( panel, wx.ID_ANY, u"Addr:", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.stPSetAddr.Wrap( -1 )
        fgAddrSizer.Add( self.stPSetAddr, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5 )

        self.editProxySettingsAddr = wx.TextCtrl( panel, wx.ID_ANY, self.nAddr, wx.DefaultPosition, wx.DefaultSize, 0 )

        fgAddrSizer.Add( self.editProxySettingsAddr, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL | wx.EXPAND, 5 )

        self.stPSetPort = wx.StaticText( panel, wx.ID_ANY, u"Port:", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.stPSetPort.Wrap( -1 )

        fgAddrSizer.Add( self.stPSetPort, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5 )

        self.editProxySettingsPort = wx.TextCtrl( panel, wx.ID_ANY, self.nPort, wx.DefaultPosition, wx.DefaultSize, 0 )

        fgAddrSizer.Add( self.editProxySettingsPort, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL | wx.EXPAND, 5 )

        mainSizer.Add( fgAddrSizer, 0, wx.EXPAND, 5)

        self.stPSAutoDetected = wx.StaticText( panel, wx.ID_ANY, u"Auto-detected: ", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.stPSAutoDetected.Wrap( -1 )
        mainSizer.Add( self.stPSAutoDetected, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5 )

        btnSizer = wx.BoxSizer( wx.HORIZONTAL )
        btnSizer.AddSpacer( ( 0, 0), 1, wx.EXPAND, 5 )

        self.btnApply = wx.Button( panel, wx.ID_ANY, u"Apply", wx.DefaultPosition, wx.DefaultSize, 0 )

        btnSizer.Add( self.btnApply, 0, wx.ALL, 5 )

        mainSizer.Add(btnSizer, 0, wx.EXPAND,5)

        proxy = self.proxySettings.autodetect()

        if proxy is not None:
            addr,port  =  proxy
            txt = addr + ":" + str(port)
        else:
            txt = "None"

        self.stPSAutoDetected.SetLabel("Auto-detected: " + txt)
        self.stPSAutoDetected.Disable()

        self.chProxyType.Bind(wx.EVT_CHOICE, self.OnCHProxyTypeSelect)
        self.editProxySettingsAddr.Bind(wx.EVT_TEXT, self.OnEditPSAddrText)
        self.editProxySettingsPort.Bind(wx.EVT_TEXT, self.OnEditPSPortText)


        self.btnApply.Bind(wx.EVT_BUTTON, self.OnBtnApply)

        self.UpdateApplyButtonState()

        if self.nMode is not 2:
            self.ToggleProxySettings(False)
        else:
            self.ToggleProxySettings(True)

        panel.SetSizer( mainSizer )
        panel.Layout()

    def OnEditPSAddrText(self, event):
        self.nAddr = self.editProxySettingsAddr.GetValue()
        self.dirtySettings = True
        self.UpdateApplyButtonState()

    def OnEditPSPortText(self, event):
        self.nPort = self.editProxySettingsPort.GetValue()
        self.dirtySettings = True
        self.UpdateApplyButtonState()

    def OnBtnApply(self, event):
        self.dirtySettings = False
        self.UpdateApplyButtonState()
        self.SaveSettings()

    def SaveSettings(self):
        self.proxySettings.setMode(self.nMode)
        self.proxySettings.setAddress(self.nAddr)
        self.proxySettings.setPort(self.nPort)
        self.proxySettings.setType(self.nType)

    def UpdateApplyButtonState(self):
        if self.dirtySettings:
            self.btnApply.Enable()
        else:
            self.btnApply.Disable()

    def OnCHProxyTypeSelect(self, event):
        choice = self.chProxyType.GetSelection()

        self.nMode = choice
        self.dirtySettings = True

        self.UpdateApplyButtonState()

        if choice is not 2:
            self.ToggleProxySettings(False)
        else:
            self.ToggleProxySettings(True)

    def ToggleProxySettings(self, mode):
        if mode:
            self.stPSetAddr.Enable()
            self.editProxySettingsAddr.Enable()
            self.stPSetPort.Enable()
            self.editProxySettingsPort.Enable()
        else:
            self.stPSetAddr.Disable()
            self.editProxySettingsAddr.Disable()
            self.stPSetPort.Disable()
            self.editProxySettingsPort.Disable()

    def getImage(self):
        return bitmapLoader.getBitmap("prefs_proxy", "icons")

PFProxyPref.register()
########NEW FILE########
__FILENAME__ = pyfaUpdatePreferences
import wx
import service
import os

from gui.preferenceView import PreferenceView
from gui import bitmapLoader

import service
import gui.globalEvents as GE


class PFUpdatePref (PreferenceView):
    title = "Updates"
    desc  = "Pyfa can automatically check and notify you of new releases. "+\
            "These options will allow you to choose what kind of updates, "+\
            "if any, you wish to receive notifications for."

    def populatePanel( self, panel ):
        self.UpdateSettings = service.settings.UpdateSettings.getInstance()
        self.dirtySettings = False

        dlgWidth = panel.GetParent().GetParent().ClientSize.width

        mainSizer = wx.BoxSizer( wx.VERTICAL )

        self.stTitle = wx.StaticText( panel, wx.ID_ANY, self.title, wx.DefaultPosition, wx.DefaultSize, 0 )
        self.stTitle.Wrap( -1 )
        self.stTitle.SetFont( wx.Font( 12, 70, 90, 90, False, wx.EmptyString ) )
        mainSizer.Add( self.stTitle, 0, wx.ALL, 5 )

        self.m_staticline1 = wx.StaticLine( panel, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.LI_HORIZONTAL )
        mainSizer.Add( self.m_staticline1, 0, wx.EXPAND|wx.TOP|wx.BOTTOM, 5 )

        self.stDesc = wx.StaticText( panel, wx.ID_ANY, self.desc, wx.DefaultPosition, wx.DefaultSize, 0 )
        self.stDesc.Wrap(dlgWidth - 50)
        mainSizer.Add( self.stDesc, 0, wx.ALL, 5 )

        self.suppressAll = wx.CheckBox( panel, wx.ID_ANY, u"Don't check for updates", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.suppressPrerelease = wx.CheckBox( panel, wx.ID_ANY, u"Allow pre-release notifications", wx.DefaultPosition, wx.DefaultSize, 0 )

        mainSizer.Add( self.suppressAll, 0, wx.ALL|wx.EXPAND, 5 )
        mainSizer.Add( self.suppressPrerelease, 0, wx.ALL|wx.EXPAND, 5 )

        self.suppressAll.Bind(wx.EVT_CHECKBOX, self.OnSuppressAllStateChange)
        self.suppressPrerelease.Bind(wx.EVT_CHECKBOX, self.OnPrereleaseStateChange)

        self.suppressAll.SetValue(self.UpdateSettings.get('all'))
        self.suppressPrerelease.SetValue(not self.UpdateSettings.get('prerelease'))

        if (self.UpdateSettings.get('version')):
            self.versionSizer = wx.BoxSizer( wx.VERTICAL )


            self.versionTitle = wx.StaticText( panel, wx.ID_ANY, "Suppressing "+self.UpdateSettings.get('version')+" Notifications", wx.DefaultPosition, wx.DefaultSize, 0 )
            self.versionTitle.Wrap( -1 )
            self.versionTitle.SetFont( wx.Font( 12, 70, 90, 90, False, wx.EmptyString ) )

            self.versionInfo = "There is a release available which you have chosen to suppress. "+\
                               "You can choose to reset notification suppression for this release, "+\
                               "or download the new release from GitHub."

            self.versionSizer.AddSpacer( ( 5, 5), 0, wx.EXPAND, 5 )

            self.versionSizer.Add( wx.StaticLine( panel, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.LI_HORIZONTAL ), 0, wx.EXPAND, 5 )
            self.versionSizer.AddSpacer( ( 5, 5), 0, wx.EXPAND, 5 )

            self.versionSizer.Add( self.versionTitle, 0, wx.EXPAND, 5 )
            self.versionDesc = wx.StaticText( panel, wx.ID_ANY, self.versionInfo, wx.DefaultPosition, wx.DefaultSize, 0 )
            self.versionDesc.Wrap(dlgWidth - 50)
            self.versionSizer.Add( self.versionDesc, 0, wx.ALL, 5 )

            actionSizer = wx.BoxSizer( wx.HORIZONTAL )
            resetSizer = wx.BoxSizer( wx.VERTICAL )

            self.downloadButton = wx.Button( panel, wx.ID_ANY, "Download", wx.DefaultPosition, wx.DefaultSize, 0 )
            self.downloadButton.Bind(wx.EVT_BUTTON, self.OnDownload)
            resetSizer.Add( self.downloadButton, 0, wx.ALL, 5 )
            actionSizer.Add( resetSizer, 1, wx.EXPAND, 5 )

            self.resetButton = wx.Button( panel, wx.ID_ANY, "Reset Suppression", wx.DefaultPosition, wx.DefaultSize, 0 )
            self.resetButton.Bind(wx.EVT_BUTTON, self.ResetSuppression)
            actionSizer.Add( self.resetButton, 0, wx.ALL, 5 )
            self.versionSizer.Add( actionSizer, 0, wx.EXPAND, 5 )
            mainSizer.Add( self.versionSizer, 0, wx.EXPAND, 5 )

        self.ToggleSuppressAll(self.suppressAll.IsChecked())

        panel.SetSizer( mainSizer )
        panel.Layout()

    def ToggleSuppressAll(self, bool):
        ''' Toggles other inputs on/off depending on value of SuppressAll '''
        if bool:
            self.suppressPrerelease.Disable()
        else:
            self.suppressPrerelease.Enable()

    def OnSuppressAllStateChange(self, event):
        self.UpdateSettings.set('all', self.suppressAll.IsChecked())
        self.ToggleSuppressAll(self.suppressAll.IsChecked())

    def OnPrereleaseStateChange(self, event):
        self.UpdateSettings.set('prerelease', not self.suppressPrerelease.IsChecked())

    def ResetSuppression(self, event):
        self.UpdateSettings.set('version', None)

        # Todo: Find a way to hide the entire panel in one go
        self.versionSizer.Hide(True)
        self.versionTitle.Hide()
        self.versionDesc.Hide()
        self.downloadButton.Hide()
        self.resetButton.Hide()
        self.resetButton.Hide()

    def OnDownload(self, event):
        wx.LaunchDefaultBrowser('https://github.com/DarkFenX/Pyfa/releases/tag/'+self.UpdateSettings.get('version'))

    def getImage(self):
        return bitmapLoader.getBitmap("prefs_update", "icons")

PFUpdatePref.register()
########NEW FILE########
__FILENAME__ = capacitorViewFull
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import wx
from gui.statsView import StatsView
from gui import builtinStatsViews
from gui import bitmapLoader
from gui.utils.numberFormatter import formatAmount

class CapacitorViewFull(StatsView):
    name = "capacitorViewFull"
    def __init__(self, parent):
        StatsView.__init__(self)
        self.parent = parent
    def getHeaderText(self, fit):
        return "Capacitor"

    def getTextExtentW(self, text):
        width, height = self.parent.GetTextExtent( text )
        return width

    def populatePanel(self, contentPanel, headerPanel):
        contentSizer = contentPanel.GetSizer()
        parent = self.panel = contentPanel
        self.headerPanel = headerPanel

        panel = "full"

        sizerCapacitor = wx.GridSizer(1, 2)
        contentSizer.Add(sizerCapacitor, 0, wx.EXPAND, 0)
        # Capacitor capacity and time
        baseBox = wx.BoxSizer(wx.HORIZONTAL)

        sizerCapacitor.Add(baseBox, 0, wx.ALIGN_LEFT)
        bitmap = bitmapLoader.getStaticBitmap("capacitorInfo_big", parent, "icons")
        tooltip = wx.ToolTip("Capacitor stability")
        bitmap.SetToolTip(tooltip)
        baseBox.Add(bitmap, 0, wx.ALIGN_CENTER)

        box = wx.BoxSizer(wx.VERTICAL)
        baseBox.Add(box, 0, wx.ALIGN_LEFT)

        hbox = wx.BoxSizer(wx.HORIZONTAL)
        box.Add(hbox, 0, wx.ALIGN_LEFT)

        hbox.Add(wx.StaticText(parent, wx.ID_ANY, "Total: "), 0, wx.ALIGN_LEFT | wx.LEFT, 3)
        lbl = wx.StaticText(parent, wx.ID_ANY, "0.0")
        setattr(self, "label%sCapacitorCapacity" % panel.capitalize(), lbl)
        hbox.Add(lbl, 0, wx.ALIGN_LEFT)

        hbox.Add(wx.StaticText(parent, wx.ID_ANY, " GJ"), 0, wx.ALIGN_LEFT)

        hbox = wx.BoxSizer(wx.HORIZONTAL)
        box.Add(hbox, 0, wx.ALIGN_LEFT)

        lbl = wx.StaticText(parent, wx.ID_ANY, "Lasts ")
        hbox.Add(lbl, 0, wx.ALIGN_LEFT | wx.LEFT, 3)
        setattr(self, "label%sCapacitorState" % panel.capitalize(), lbl)

        lbl = wx.StaticText(parent, wx.ID_ANY, "0s")
        setattr(self, "label%sCapacitorTime" % panel.capitalize(), lbl)
        hbox.Add(lbl, 0, wx.ALIGN_LEFT)

        # Capacitor balance
        baseBox = wx.BoxSizer(wx.HORIZONTAL)

        sizerCapacitor.Add(baseBox, 0, wx.ALIGN_CENTER_HORIZONTAL)

        tooltip = wx.ToolTip("Capacitor throughput")
        bitmap = bitmapLoader.getStaticBitmap("capacitorRecharge_big", parent, "icons")
        bitmap.SetToolTip(tooltip)
        baseBox.Add(bitmap, 0, wx.ALIGN_CENTER)

        # Recharge
        chargeSizer = wx.FlexGridSizer(2, 3)
        baseBox.Add(chargeSizer, 0, wx.ALIGN_CENTER)

        chargeSizer.Add(wx.StaticText(parent, wx.ID_ANY, "+ "), 0, wx.ALIGN_CENTER)
        lbl = wx.StaticText(parent, wx.ID_ANY, "0.0")
        setattr(self, "label%sCapacitorRecharge" % panel.capitalize(), lbl)
        chargeSizer.Add(lbl, 0, wx.ALIGN_CENTER)
        chargeSizer.Add(wx.StaticText(parent, wx.ID_ANY, " GJ/s"), 0, wx.ALIGN_CENTER)

        # Discharge
        chargeSizer.Add(wx.StaticText(parent, wx.ID_ANY, "- "), 0, wx.ALIGN_CENTER)
        lbl = wx.StaticText(parent, wx.ID_ANY, "0.0")
        setattr(self, "label%sCapacitorDischarge" % panel.capitalize(), lbl)
        chargeSizer.Add(lbl, 0, wx.ALIGN_CENTER)
        chargeSizer.Add(wx.StaticText(parent, wx.ID_ANY, " GJ/s"), 0, wx.ALIGN_CENTER)


    def refreshPanel(self, fit):
        #If we did anything intresting, we'd update our labels to reflect the new fit's stats here
        stats= (("label%sCapacitorCapacity", lambda: fit.ship.getModifiedItemAttr("capacitorCapacity"), 3, 0, 9),
                ("label%sCapacitorRecharge", lambda: fit.capRecharge, 3, 0, 0),
                ("label%sCapacitorDischarge", lambda: fit.capUsed, 3, 0, 0))

        panel = "Full"
        for labelName, value, prec, lowest, highest in stats:
            label = getattr(self, labelName % panel)
            value = value() if fit is not None else 0
            value = value if value is not None else 0
            if isinstance(value, basestring):
                label.SetLabel(value)
                label.SetToolTip(wx.ToolTip(value))
            else:
                label.SetLabel(formatAmount(value, prec, lowest, highest))
                label.SetToolTip(wx.ToolTip("%.1f" % value))

        capState = fit.capState if fit is not None else 0
        capStable = fit.capStable if fit is not None else False
        lblNameTime = "label%sCapacitorTime"
        lblNameState = "label%sCapacitorState"
        if isinstance(capState, tuple):
            t = "%.1f%%-%.1f%%" % capState
            s = ""
        else:
            if capStable:
                t = "%.1f%%" % capState
            else:
                if capState > 60:
                    t = "%dm%ds" % divmod(capState, 60)
                else:
                    t = "%ds" % capState

            s = "Stable: " if capStable else "Lasts "

        getattr(self, lblNameTime % panel).SetLabel(t)
        getattr(self, lblNameState % panel).SetLabel(s)

        self.panel.Layout()
        self.headerPanel.Layout()

CapacitorViewFull.register()

########NEW FILE########
__FILENAME__ = firepowerViewFull
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import wx
from gui.statsView import StatsView
from gui import builtinStatsViews
from gui import bitmapLoader
from gui.utils.numberFormatter import formatAmount

class FirepowerViewFull(StatsView):
    name = "firepowerViewFull"
    def __init__(self, parent):
        StatsView.__init__(self)
        self.parent = parent
        self._cachedValues = []
    def getHeaderText(self, fit):
        return "Firepower"

    def getTextExtentW(self, text):
        width, height = self.parent.GetTextExtent( text )
        return width

    def populatePanel(self, contentPanel, headerPanel):
        contentSizer = contentPanel.GetSizer()
        parent = self.panel = contentPanel
        self.headerPanel = headerPanel

        panel = "full"

        sizerFirepower = wx.FlexGridSizer(1, 3)
        sizerFirepower.AddGrowableCol(1)

        contentSizer.Add( sizerFirepower, 0, wx.EXPAND, 0)

        counter = 0

        for damageType, image in (("weapon", "turret") , ("drone", "droneDPS")):
            baseBox = wx.BoxSizer(wx.HORIZONTAL)
            sizerFirepower.Add(baseBox, 1, wx.ALIGN_LEFT if counter == 0 else wx.ALIGN_CENTER_HORIZONTAL)

            baseBox.Add(bitmapLoader.getStaticBitmap("%s_big" % image, parent, "icons"), 0, wx.ALIGN_CENTER)

            box = wx.BoxSizer(wx.VERTICAL)
            baseBox.Add(box, 0, wx.ALIGN_CENTER)

            box.Add(wx.StaticText(parent, wx.ID_ANY, damageType.capitalize()), 0, wx.ALIGN_LEFT)

            hbox = wx.BoxSizer(wx.HORIZONTAL)
            box.Add(hbox, 1, wx.ALIGN_CENTER)

            lbl = wx.StaticText(parent, wx.ID_ANY, "0.0 DPS")
            setattr(self, "label%sDps%s" % (panel.capitalize() ,damageType.capitalize()), lbl)

            hbox.Add(lbl, 0, wx.ALIGN_CENTER)
#            hbox.Add(wx.StaticText(parent, wx.ID_ANY, " DPS"), 0, wx.ALIGN_CENTER)
            self._cachedValues.append(0)
            counter += 1
        targetSizer = sizerFirepower

        baseBox = wx.BoxSizer(wx.HORIZONTAL)
        targetSizer.Add(baseBox, 0, wx.ALIGN_RIGHT)

        baseBox.Add(bitmapLoader.getStaticBitmap("volley_big", parent, "icons"), 0, wx.ALIGN_CENTER)

        gridS = wx.GridSizer(2,2,0,0)

        baseBox.Add(gridS, 0)

        lbl = wx.StaticText(parent, wx.ID_ANY, "0.0")
        setattr(self, "label%sVolleyTotal" % panel.capitalize(), lbl)
        gridS.Add(wx.StaticText(parent, wx.ID_ANY, " Volley: "), 0, wx.ALL | wx.ALIGN_RIGHT)
        gridS.Add(lbl, 0, wx.ALIGN_LEFT)

        self._cachedValues.append(0)

        lbl = wx.StaticText(parent, wx.ID_ANY, "0.0")
        setattr(self, "label%sDpsTotal" % panel.capitalize(), lbl)
        gridS.Add(wx.StaticText(parent, wx.ID_ANY, " DPS: "), 0, wx.ALL | wx.ALIGN_RIGHT)

        self._cachedValues.append(0)

        gridS.Add(lbl, 0, wx.ALIGN_LEFT)

    def refreshPanel(self, fit):
        #If we did anything intresting, we'd update our labels to reflect the new fit's stats here

        stats = (("labelFullDpsWeapon", lambda: fit.weaponDPS, 3, 0, 0, "%s DPS",None),
                 ("labelFullDpsDrone", lambda: fit.droneDPS, 3, 0, 0, "%s DPS", None),
                 ("labelFullVolleyTotal", lambda: fit.weaponVolley, 3, 0, 0, "%s", "Volley: %.1f"),
                 ("labelFullDpsTotal", lambda: fit.totalDPS, 3, 0, 0, "%s", None))

        counter = 0
        for labelName, value, prec, lowest, highest, valueFormat, altFormat in stats:
            label = getattr(self, labelName)
            value = value() if fit is not None else 0
            value = value if value is not None else 0
            if self._cachedValues[counter] != value:
                valueStr = formatAmount(value, prec, lowest, highest)
                label.SetLabel(valueFormat % valueStr)
                tipStr = valueFormat % valueStr if altFormat is None else altFormat % value
                label.SetToolTip(wx.ToolTip(tipStr))
                self._cachedValues[counter] = value
            counter +=1
        self.panel.Layout()
        self.headerPanel.Layout()

FirepowerViewFull.register()

########NEW FILE########
__FILENAME__ = priceViewFull
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import wx
from gui.statsView import StatsView
from gui import builtinStatsViews
from gui import bitmapLoader
from gui.utils.numberFormatter import formatAmount
import service

class PriceViewFull(StatsView):
    name = "priceViewFull"
    def __init__(self, parent):
        StatsView.__init__(self)
        self.parent = parent
        self._timerId = wx.NewId()
        self._timer = None
        self.parent.Bind(wx.EVT_TIMER, self.OnTimer)
        self._timerRunsBeforeUpdate = 60
        self._timerRuns = 0
        self._timerIdUpdate = wx.NewId()
        self._timerUpdate = None
        self._cachedShip = 0
        self._cachedFittings = 0
        self._cachedTotal = 0

    def OnTimer( self, event):
        if self._timerId == event.GetId():
            if self._timerRuns >= self._timerRunsBeforeUpdate:
                self._timerRuns = 0
                self._timer.Stop()
                self.refreshPanel(self.fit)
            else:
                self.labelEMStatus.SetLabel("Prices update retry in: %d seconds" %(self._timerRunsBeforeUpdate - self._timerRuns))
                self._timerRuns += 1
        if self._timerIdUpdate == event.GetId():
            self._timerUpdate.Stop()
            self.labelEMStatus.SetLabel("")
    def getHeaderText(self, fit):
        return "Price"

    def getTextExtentW(self, text):
        width, height = self.parent.GetTextExtent( text )
        return width

    def populatePanel(self, contentPanel, headerPanel):
        contentSizer = contentPanel.GetSizer()
        self.panel = contentPanel
        self.headerPanel = headerPanel

        gridPrice = wx.GridSizer(1, 3)
        contentSizer.Add( gridPrice, 0, wx.EXPAND | wx.ALL, 0)
        for type in ("ship", "fittings", "total"):
            image = "%sPrice_big" % type if type != "ship" else "ship_big"
            box = wx.BoxSizer(wx.HORIZONTAL)
            gridPrice.Add(box, 0, wx.ALIGN_TOP)

            box.Add(bitmapLoader.getStaticBitmap(image, contentPanel, "icons"), 0, wx.ALIGN_CENTER)

            vbox = wx.BoxSizer(wx.VERTICAL)
            box.Add(vbox, 1, wx.EXPAND)

            vbox.Add(wx.StaticText(contentPanel, wx.ID_ANY, type.capitalize()), 0, wx.ALIGN_LEFT)

            hbox = wx.BoxSizer(wx.HORIZONTAL)
            vbox.Add(hbox)

            lbl = wx.StaticText(contentPanel, wx.ID_ANY, "0.00 ISK")
            setattr(self, "labelPrice%s" % type.capitalize(), lbl)
            hbox.Add(lbl, 0, wx.ALIGN_LEFT)

#            hbox.Add(wx.StaticText(contentPanel, wx.ID_ANY, " ISK"), 0, wx.ALIGN_LEFT)
        self.labelEMStatus = wx.StaticText(contentPanel, wx.ID_ANY, "")
        contentSizer.Add(self.labelEMStatus,0)
    def refreshPanel(self, fit):
        if fit is not None:
            self.fit = fit
            # Compose a list of all the data we need & request it
            typeIDs = []
            typeIDs.append(fit.ship.item.ID)

            for mod in fit.modules:
                if not mod.isEmpty:
                    typeIDs.append(mod.itemID)

            for drone in fit.drones:
                for _ in xrange(drone.amount):
                    typeIDs.append(drone.itemID)
            for cargo in fit.cargo:
                for _ in xrange(cargo.amount):
                    typeIDs.append(cargo.itemID)
            if self._timer:
                if self._timer.IsRunning():
                    self._timer.Stop()
            cMarket = service.Market.getInstance()
            cMarket.getPrices(typeIDs, self.processPrices)
            self.labelEMStatus.SetLabel("Updating prices...")
            if not self._timerUpdate:
                self._timerUpdate = wx.Timer(self.parent, self._timerIdUpdate)
            if self._timerUpdate:
                if not self._timerUpdate.IsRunning():
                    self._timerUpdate.Start(1000)

        else:
            if self._timer:
                if self._timer.IsRunning():
                    self._timer.Stop()
            self.labelEMStatus.SetLabel("")
            self.labelPriceShip.SetLabel("0.0 ISK")
            self.labelPriceFittings.SetLabel("0.0 ISK")
            self.labelPriceTotal.SetLabel("0.0 ISK")
            self._cachedFittings = self._cachedShip = self._cachedTotal = 0
            self.panel.Layout()

    def processPrices(self, prices):
        shipPrice = prices[0].price
        if shipPrice == None:
            if not self._timer:
                self._timer = wx.Timer(self.parent, self._timerId)
            self._timer.Start(1000)
            self._timerRuns = 0
        else:
            if self._timer:
                self._timer.Stop()

            self.labelEMStatus.SetLabel("")

        if shipPrice == None:
            shipPrice = 0
        modPrice = sum(map(lambda p: p.price or 0, prices[1:]))
        if self._cachedShip != shipPrice:
            self.labelPriceShip.SetLabel("%s ISK" % formatAmount(shipPrice, 3, 3, 9, currency=True))
            self.labelPriceShip.SetToolTip(wx.ToolTip("%.2f ISK" % shipPrice))
            self._cachedShip = shipPrice
        if self._cachedFittings != modPrice:
            self.labelPriceFittings.SetLabel("%s ISK" % formatAmount(modPrice, 3, 3, 9, currency=True))
            self.labelPriceFittings.SetToolTip(wx.ToolTip("%.2f ISK" % modPrice))
            self._cachedFittings = modPrice
        if self._cachedTotal != (shipPrice+modPrice):
            self.labelPriceTotal.SetLabel("%s ISK" % formatAmount(shipPrice + modPrice, 3, 3, 9, currency=True))
            self.labelPriceTotal.SetToolTip(wx.ToolTip("%.2f ISK" % (shipPrice + modPrice)))
            self._cachedTotal = shipPrice + modPrice
        self.panel.Layout()

PriceViewFull.register()

########NEW FILE########
__FILENAME__ = rechargeViewFull
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import wx
from gui.statsView import StatsView
from gui import bitmapLoader
from gui.utils.numberFormatter import formatAmount
import gui.mainFrame
import gui.builtinStatsViews.resistancesViewFull as rvf
import service

class RechargeViewFull(StatsView):
    name = "rechargeViewFull"
    def __init__(self, parent):
        StatsView.__init__(self)
        self.parent = parent
        self.mainFrame = gui.mainFrame.MainFrame.getInstance()
        self.mainFrame.Bind(rvf.EFFECTIVE_HP_TOGGLED, self.toggleEffective)
        self.effective = True

    def getHeaderText(self, fit):
        return "Recharge rates"

    def getTextExtentW(self, text):
        width, height = self.parent.GetTextExtent( text )
        return width

    def toggleEffective(self, event):
        self.effective = event.effective
        sFit = service.Fit.getInstance()
        self.refreshPanel(sFit.getFit(self.mainFrame.getActiveFit()))
        event.Skip()

    def populatePanel(self, contentPanel, headerPanel):
        contentSizer = contentPanel.GetSizer()

        self.panel = contentPanel
        self.headerPanel = headerPanel
        sizerTankStats = wx.FlexGridSizer(3, 5)
        for i in xrange(4):
            sizerTankStats.AddGrowableCol(i + 1)

        contentSizer.Add(sizerTankStats, 0, wx.EXPAND, 0)

        #Add an empty label first for correct alignment.
        sizerTankStats.Add(wx.StaticText(contentPanel, wx.ID_ANY, ""), 0)
        toolTipText = {"shieldPassive" : "Passive shield recharge", "shieldActive" : "Active shield boost", "armorActive" : "Armor repair amount", "hullActive" : "Hull repair amount"}
        for tankType in ("shieldPassive", "shieldActive", "armorActive", "hullActive"):
            bitmap = bitmapLoader.getStaticBitmap("%s_big" % tankType, contentPanel, "icons")
            tooltip = wx.ToolTip(toolTipText[tankType])
            bitmap.SetToolTip(tooltip)
            sizerTankStats.Add(bitmap, 0, wx.ALIGN_CENTER)

        toolTipText = {"reinforced" : "Reinforced", "sustained" : "Sustained"}
        for stability in ("reinforced", "sustained"):
            bitmap = bitmapLoader.getStaticBitmap("regen%s_big" % stability.capitalize(), contentPanel, "icons")
            tooltip = wx.ToolTip(toolTipText[stability])
            bitmap.SetToolTip(tooltip)
            sizerTankStats.Add(bitmap, 0, wx.ALIGN_CENTER)
            for tankType in ("shieldPassive", "shieldActive", "armorActive", "hullActive"):
                if stability == "reinforced" and tankType == "shieldPassive":
                    sizerTankStats.Add(wx.StaticText(contentPanel, wx.ID_ANY, ""))
                    continue

                tankTypeCap = tankType[0].capitalize() + tankType[1:]
                lbl = wx.StaticText(contentPanel, wx.ID_ANY, "0.0", style = wx.ALIGN_RIGHT)
                setattr(self, "labelTank%s%s" % (stability.capitalize(), tankTypeCap), lbl)

                box = wx.BoxSizer(wx.HORIZONTAL)
                box.Add(lbl, 0, wx.EXPAND)
                box.Add(wx.StaticText(contentPanel, wx.ID_ANY, " HP/s"), 0, wx.EXPAND)

                sizerTankStats.Add(box, 0, wx.ALIGN_CENTRE)

        contentPanel.Layout()

    def refreshPanel(self, fit):
        #If we did anything intresting, we'd update our labels to reflect the new fit's stats here

        for stability in ("reinforced", "sustained"):
            if stability == "reinforced" and fit != None:
                tank = fit.effectiveTank if self.effective else fit.tank
            elif stability == "sustained" and fit != None:
                tank = fit.effectiveSustainableTank if self.effective else fit.sustainableTank
            else:
                tank = None

            for name in ("shield", "armor", "hull"):
                lbl = getattr(self, "labelTank%s%sActive" % (stability.capitalize(), name.capitalize()))
                if tank is not None:
                    lbl.SetLabel("%.1f" % tank["%sRepair" % name])
                else:
                    lbl.SetLabel("0.0")

        if fit is not None:
            label = getattr(self, "labelTankSustainedShieldPassive")
            value = fit.effectiveTank["passiveShield"] if self.effective else fit.tank["passiveShield"]
            label.SetLabel(formatAmount(value, 3, 0, 9))

        else:
            value = 0
            label = getattr(self, "labelTankSustainedShieldPassive")
            label.SetLabel("0")

        label.SetToolTip(wx.ToolTip("%.3f" % value))
        self.panel.Layout()
        self.headerPanel.Layout()

RechargeViewFull.register()

########NEW FILE########
__FILENAME__ = resistancesViewFull
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import wx
from gui.statsView import StatsView
from gui import builtinStatsViews
from gui import bitmapLoader
from gui import pygauge as PG
from gui.utils.numberFormatter import formatAmount
import service
import gui.mainFrame
import gui.builtinViews.fittingView as fv
import gui.globalEvents as GE

EffectiveHpToggled, EFFECTIVE_HP_TOGGLED = wx.lib.newevent.NewEvent()

class ResistancesViewFull(StatsView):
    name = "resistancesViewFull"
    def __init__(self, parent):
        StatsView.__init__(self)
        self.parent = parent
        self._cachedValues = []
        self.showEffective = True
        self.activeFit = None
        self.mainFrame = gui.mainFrame.MainFrame.getInstance()
        self.mainFrame.Bind(EFFECTIVE_HP_TOGGLED, self.ehpSwitch)

    def getHeaderText(self, fit):
        return "Resistances"

    def getTextExtentW(self, text):
        width, height = self.parent.GetTextExtent( text )
        return width

    def populatePanel(self, contentPanel, headerPanel):
        contentSizer = contentPanel.GetSizer()
        self.panel = contentPanel

        self.headerPanel = headerPanel
        # Custom header  EHP
        headerContentSizer = wx.BoxSizer(wx.HORIZONTAL)
        hsizer = headerPanel.GetSizer()
        hsizer.Add(headerContentSizer,0,0,0)
        self.stEff = wx.StaticText(headerPanel, wx.ID_ANY, "( Effective HP: ")
        headerContentSizer.Add(self.stEff)
        headerPanel.GetParent().AddToggleItem(self.stEff)

        self.labelEhp = wx.StaticText(headerPanel, wx.ID_ANY, "0")
        headerContentSizer.Add(self.labelEhp, 0)
        headerPanel.GetParent().AddToggleItem(self.labelEhp)

        stCls = wx.StaticText(headerPanel, wx.ID_ANY, " )")

        headerPanel.GetParent().AddToggleItem( stCls )
        headerContentSizer.Add( stCls )
#        headerContentSizer.Add(wx.StaticLine(headerPanel, wx.ID_ANY), 1, wx.ALIGN_CENTER)

        # Display table
        col = 0
        row = 0
        sizerResistances = wx.GridBagSizer(0, 0)
        contentSizer.Add( sizerResistances, 0, wx.EXPAND , 0)

        for i in xrange(6):
            sizerResistances.AddGrowableCol(i + 1)

        # Add an empty label, then the rest.
        sizerResistances.Add(wx.StaticText(contentPanel, wx.ID_ANY), wx.GBPosition( row, col ), wx.GBSpan( 1, 1 ))
        col+=1
        toolTipText = {"em" : "Electromagnetic resistance", "thermal" : "Thermal resistance", "kinetic" : "Kinetic resistance", "explosive" : "Explosive resistance"}
        for damageType in ("em", "thermal", "kinetic", "explosive"):
            bitmap = bitmapLoader.getStaticBitmap("%s_big" % damageType, contentPanel, "icons")
            tooltip = wx.ToolTip(toolTipText[damageType])
            bitmap.SetToolTip(tooltip)
            sizerResistances.Add(bitmap, wx.GBPosition( row, col ), wx.GBSpan( 1, 1 ), wx.ALIGN_CENTER)
            col+=1
        self.stEHPs = wx.Button(contentPanel, style = wx.BU_EXACTFIT, label =  "EHP")
        self.stEHPs.SetToolTip(wx.ToolTip("Click to toggle between effective HP and raw HP"))

        self.stEHPs.Bind(wx.EVT_BUTTON, self.toggleEHP)


        sizerResistances.Add(self.stEHPs, wx.GBPosition( row, col ), wx.GBSpan( 1, 1 ), wx.ALIGN_CENTER)
        col=0
        row+=1

        gaugeColours=( ((38,133,198),(52,86,98)), ((198,38,38),(83,65,67)), ((163,163,163),(74,90,93)), ((198,133,38),(81,83,67)) )

        toolTipText = {"shield" : "Shield resistance", "armor" : "Armor resistance", "hull" : "Hull resistance", "damagePattern" : "Incoming damage pattern"}
        for tankType in ("shield", "armor", "hull", "separator", "damagePattern"):
            if tankType != "separator":
                bitmap = bitmapLoader.getStaticBitmap("%s_big" % tankType, contentPanel, "icons")
                tooltip = wx.ToolTip(toolTipText[tankType])
                bitmap.SetToolTip(tooltip)
                sizerResistances.Add(bitmap, wx.GBPosition( row, col ), wx.GBSpan( 1, 1 ), wx.ALIGN_CENTER)
                col+=1

            else:
                sizerResistances.Add(wx.StaticLine(contentPanel, wx.ID_ANY), wx.GBPosition( row, col ), wx.GBSpan( 1, 6 ), wx.EXPAND|wx.ALIGN_CENTER)
                row+=1
                col=0

                continue
            currGColour=0

            for damageType in ("em", "thermal", "kinetic", "explosive"):

                box = wx.BoxSizer(wx.HORIZONTAL)
                sizerResistances.Add(box, wx.GBPosition( row, col ), wx.GBSpan( 1, 1 ), wx.ALIGN_CENTER)


                #Fancy gauges addon

                pgColour= gaugeColours[currGColour]
                fc = pgColour[0]
                bc = pgColour[1]
                currGColour+=1

                lbl = PG.PyGauge(contentPanel, wx.ID_ANY, 100)
                lbl.SetMinSize((48, 16))
                lbl.SetBackgroundColour(wx.Colour(bc[0],bc[1],bc[2]))
                lbl.SetBarColour(wx.Colour(fc[0],fc[1],fc[2]))
                lbl.SetBarGradient()
                lbl.SetFractionDigits(1)

                setattr(self, "gaugeResistance%s%s" % (tankType.capitalize(), damageType.capitalize()), lbl)
                box.Add(lbl, 0, wx.ALIGN_CENTER)

                col+=1
            box = wx.BoxSizer(wx.VERTICAL)
            box.SetMinSize(wx.Size(self.getTextExtentW("WWWWk"), -1))

            lbl = wx.StaticText(contentPanel, wx.ID_ANY, "0" if tankType != "damagePattern" else "")
            box.Add(lbl, 0, wx.ALIGN_CENTER)

            setattr(self, "labelResistance%sEhp" % tankType.capitalize(), lbl)
            sizerResistances.Add(box, wx.GBPosition( row, col ), wx.GBSpan( 1, 1 ), wx.ALIGN_CENTER)
            row+=1
            col=0

        self.stEHPs.SetToolTip(wx.ToolTip("Click to toggle between effective HP and raw HP"))

    def toggleEHP(self, event):
        wx.PostEvent(self.mainFrame, EffectiveHpToggled(effective=self.stEHPs.GetLabel() == "HP"))

    def ehpSwitch(self, event):
        self.showEffective = event.effective
        wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=self.mainFrame.getActiveFit()))

    def refreshPanel(self, fit):
        #If we did anything intresting, we'd update our labels to reflect the new fit's stats here
        if fit is None and not self.showEffective:
            self.showEffective = True
            wx.PostEvent(self.mainFrame, EffectiveHpToggled(effective=True))
            return
        elif fit is not None and fit.ID != self.activeFit and not self.showEffective:
            self.showEffective = True
            wx.PostEvent(self.mainFrame, EffectiveHpToggled(effective=True))
            return

        self.stEHPs.SetLabel("EHP" if self.showEffective else "HP")
        self.activeFit = fit.ID if fit is not None else None

        for tankType in ("shield", "armor", "hull"):
            for damageType in ("em", "thermal", "kinetic", "explosive"):
                if fit is not None:
                    resonanceType = tankType if tankType != "hull" else ""
                    resonance = "%s%sDamageResonance" % (resonanceType, damageType.capitalize())
                    resonance = resonance[0].lower() + resonance[1:]
                    resonance = (1 - fit.ship.getModifiedItemAttr(resonance)) * 100
                else:
                    resonance = 0

                lbl = getattr(self, "gaugeResistance%s%s" % (tankType.capitalize(), damageType.capitalize()))

                lbl.SetValue(resonance)

        ehp = (fit.ehp if self.showEffective else fit.hp) if fit is not None else None
        total = 0
        for tankType in ("shield", "armor", "hull"):
            lbl = getattr(self, "labelResistance%sEhp" % tankType.capitalize())
            if ehp is not None:
                total += ehp[tankType]
                lbl.SetLabel(formatAmount(ehp[tankType], 3, 0, 9))
                lbl.SetToolTip(wx.ToolTip("%s: %d" % (tankType.capitalize(), ehp[tankType])))
            else:
                lbl.SetLabel("0")


        self.labelEhp.SetLabel("%s" % formatAmount(total, 3, 0, 9))
        if self.showEffective:
            self.stEff.SetLabel("( Effective HP: ")
            self.labelEhp.SetToolTip(wx.ToolTip("Effective: %d HP" % total))
        else:
            self.stEff.SetLabel("( Raw HP: ")
            self.labelEhp.SetToolTip(wx.ToolTip("Raw: %d HP" % total))


        damagePattern = fit.damagePattern if fit is not None  and self.showEffective else None
        total = sum((damagePattern.emAmount, damagePattern.thermalAmount,
                    damagePattern.kineticAmount, damagePattern.explosiveAmount)) if damagePattern is not None else 0

        for damageType in ("em", "thermal", "kinetic", "explosive"):
            lbl = getattr(self, "gaugeResistanceDamagepattern%s" % damageType.capitalize())

            if damagePattern is not None:
                lbl.SetValueRange(getattr(damagePattern, "%sAmount" % damageType), total)
            else:
                lbl.SetValue(0)

        self.panel.Layout()
        self.headerPanel.Layout()

ResistancesViewFull.register()


########NEW FILE########
__FILENAME__ = resourcesViewFull
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import wx
from gui.statsView import StatsView
from gui import builtinStatsViews
from gui import bitmapLoader
from gui import pygauge as PG
import gui.mainFrame
import gui.chromeTabs

from eos.types import Hardpoint

from gui.utils.numberFormatter import formatAmount

class ResourcesViewFull(StatsView):
    name = "resourcesViewFull"
    def __init__(self, parent):
        StatsView.__init__(self)
        self.parent = parent
        self.mainFrame = gui.mainFrame.MainFrame.getInstance()
        self.mainFrame.additionsPane.notebook.Bind(gui.chromeTabs.EVT_NOTEBOOK_PAGE_CHANGED, self.pageChanged)

    def pageChanged(self, event):
        page = self.mainFrame.additionsPane.getName(event.GetSelection())
        if page == "Cargo":
            self.toggleCargoGauge(True)
        else:
            self.toggleCargoGauge(False)

    def toggleCargoGauge(self, showCargo = False):
        if showCargo:
            self.bitmapFullCargoBay.Show()
            self.baseFullCargoBay.Show(True)
            self.bitmapFullDroneBay.Hide()
            self.baseFullDroneBay.Hide(True)
        else:
            self.bitmapFullDroneBay.Show()
            self.baseFullDroneBay.Show(True)
            self.bitmapFullCargoBay.Hide()
            self.baseFullCargoBay.Hide(True)

        self.panel.Layout()
        self.headerPanel.Layout()

    def getHeaderText(self, fit):
        return "Resources"

    def getTextExtentW(self, text):
        width, height = self.parent.GetTextExtent( text )
        return width

    def populatePanel(self, contentPanel, headerPanel):

        contentSizer = contentPanel.GetSizer()
        root = wx.BoxSizer(wx.VERTICAL)
        contentSizer.Add(root, 0, wx.EXPAND, 0)

        sizer = wx.GridSizer(1, 4)
        root.Add(sizer, 0, wx.EXPAND)
        root.Add(wx.StaticLine(contentPanel, wx.ID_ANY, style=wx.HORIZONTAL), 0, wx.EXPAND)

        sizerResources = wx.BoxSizer(wx.HORIZONTAL)
        root.Add(sizerResources, 1, wx.EXPAND, 0)

        parent = self.panel = contentPanel
        self.headerPanel = headerPanel
        panel = "full"


        base = sizerResources

        #Turrets & launcher hardslots display
        tooltipText = {"turret":"Turret hardpoints", "launcher":"Launcher hardpoints", "drones":"Drones active", "calibration":"Calibration"}
        for type in ("turret", "launcher", "drones", "calibration"):
            box = wx.BoxSizer(wx.HORIZONTAL)

            bitmap = bitmapLoader.getStaticBitmap("%s_big" % type, parent, "icons")
            tooltip = wx.ToolTip(tooltipText[type])
            bitmap.SetToolTip(tooltip)

            box.Add(bitmap, 0, wx.ALIGN_CENTER)

            sizer.Add(box, 0, wx.ALIGN_CENTER)

            suffix = {'turret':'Hardpoints', 'launcher':'Hardpoints', 'drones':'Active', 'calibration':'Points'}
            lbl = wx.StaticText(parent, wx.ID_ANY, "0")
            setattr(self, "label%sUsed%s%s" % (panel.capitalize(), type.capitalize(), suffix[type].capitalize()), lbl)
            box.Add(lbl, 0, wx.ALIGN_CENTER | wx.LEFT, 5)

            box.Add(wx.StaticText(parent, wx.ID_ANY, "/"), 0, wx.ALIGN_CENTER)

            lbl = wx.StaticText(parent, wx.ID_ANY, "0")
            setattr(self, "label%sTotal%s%s" % (panel.capitalize(), type.capitalize(), suffix[type].capitalize()), lbl)
            box.Add(lbl, 0, wx.ALIGN_CENTER)


        #PG, Cpu & drone stuff
        tooltipText = {"cpu":"CPU", "pg":"PowerGrid", "droneBay":"Drone bay", "droneBandwidth":"Drone bandwidth", "cargoBay":"Cargo bay"}
        for i, group in enumerate((("cpu", "pg"), ("cargoBay", "droneBay", "droneBandwidth"))):
            main = wx.BoxSizer(wx.VERTICAL)
            base.Add(main, 1 , wx.ALIGN_CENTER)

            for type in group:
                capitalizedType = type[0].capitalize() + type[1:]
                bitmap = bitmapLoader.getStaticBitmap(type + "_big", parent, "icons")
                tooltip = wx.ToolTip(tooltipText[type])
                bitmap.SetToolTip(tooltip)

                stats = wx.BoxSizer(wx.VERTICAL)
                absolute =  wx.BoxSizer(wx.HORIZONTAL)
                stats.Add(absolute, 0, wx.EXPAND)

                b = wx.BoxSizer(wx.HORIZONTAL)
                main.Add(b, 1, wx.ALIGN_CENTER)

                b.Add(bitmap, 0, wx.ALIGN_BOTTOM)

                b.Add(stats, 1, wx.EXPAND)

                lbl = wx.StaticText(parent, wx.ID_ANY, "0")
                setattr(self, "label%sUsed%s" % (panel.capitalize(), capitalizedType), lbl)
                absolute.Add(lbl, 0, wx.ALIGN_LEFT | wx.LEFT, 3)

                absolute.Add(wx.StaticText(parent, wx.ID_ANY, "/"), 0, wx.ALIGN_LEFT)

                lbl = wx.StaticText(parent, wx.ID_ANY, "0")
                setattr(self, "label%sTotal%s" % (panel.capitalize(), capitalizedType), lbl)
                absolute.Add(lbl, 0, wx.ALIGN_LEFT)

                units = {"cpu":" tf", "pg":" MW", "droneBandwidth":" mbit/s", "droneBay":u" m\u00B3", "cargoBay":u" m\u00B3"}
                lbl = wx.StaticText(parent, wx.ID_ANY, "%s" % units[type])
                absolute.Add(lbl, 0, wx.ALIGN_LEFT)

                # Gauges modif. - Darriele

                gauge = PG.PyGauge(parent, wx.ID_ANY, 1)
                gauge.SetValueRange(0, 0)
                gauge.SetMinSize((self.getTextExtentW("1.999M/1.99M MW"), 23))
                gauge.SetFractionDigits(2)

                setattr(self, "gauge%s%s" % (panel.capitalize(),capitalizedType), gauge)
                stats.Add(gauge, 0, wx.ALIGN_CENTER)

                setattr(self, "base%s%s" % (panel.capitalize(), capitalizedType), b)
                setattr(self, "bitmap%s%s" % (panel.capitalize(), capitalizedType), bitmap)

        self.toggleCargoGauge(False)

    def refreshPanel(self, fit):
        #If we did anything intresting, we'd update our labels to reflect the new fit's stats here

        stats = (("label%sUsedTurretHardpoints", lambda: fit.getHardpointsUsed(Hardpoint.TURRET), 0, 0, 0),
                         ("label%sTotalTurretHardpoints", lambda: fit.ship.getModifiedItemAttr('turretSlotsLeft'), 0, 0, 0),
                         ("label%sUsedLauncherHardpoints", lambda: fit.getHardpointsUsed(Hardpoint.MISSILE), 0, 0, 0),
                         ("label%sTotalLauncherHardpoints", lambda: fit.ship.getModifiedItemAttr('launcherSlotsLeft'), 0, 0, 0),
                         ("label%sUsedDronesActive", lambda: fit.activeDrones, 0, 0, 0),
                         ("label%sTotalDronesActive", lambda: fit.extraAttributes["maxActiveDrones"], 0, 0, 0),
                         ("label%sUsedCalibrationPoints", lambda: fit.calibrationUsed, 0, 0, 0),
                         ("label%sTotalCalibrationPoints", lambda: fit.ship.getModifiedItemAttr('upgradeCapacity'), 0, 0, 0),
                         ("label%sUsedPg", lambda: fit.pgUsed, 4, 0, 9),
                         ("label%sUsedCpu", lambda: fit.cpuUsed, 4, 0, 9),
                         ("label%sTotalPg", lambda: fit.ship.getModifiedItemAttr("powerOutput"), 4, 0, 9),
                         ("label%sTotalCpu", lambda: fit.ship.getModifiedItemAttr("cpuOutput"), 4, 0, 9),
                         ("label%sUsedDroneBay", lambda: fit.droneBayUsed, 3, 0, 9),
                         ("label%sUsedDroneBandwidth", lambda: fit.droneBandwidthUsed, 3, 0, 9),
                         ("label%sTotalDroneBay", lambda: fit.ship.getModifiedItemAttr("droneCapacity"), 3, 0, 9),
                         ("label%sTotalDroneBandwidth", lambda: fit.ship.getModifiedItemAttr("droneBandwidth"), 3, 0, 9),
                         ("label%sUsedCargoBay", lambda: fit.cargoBayUsed, 3, 0, 9),
                         ("label%sTotalCargoBay", lambda: fit.ship.getModifiedItemAttr("capacity"), 3, 0, 9))
        panel = "Full"
        usedTurretHardpoints = 0
        totalTurretHardpoints = 0
        usedLauncherHardpoints = 0
        totalLauncherHardPoints = 0

        for labelName, value, prec, lowest, highest in stats:
            label = getattr(self, labelName % panel)
            value = value() if fit is not None else 0
            value = value if value is not None else 0
            if labelName % panel == "label%sUsedTurretHardpoints" % panel:
                usedTurretHardpoints = value
                labelUTH = label

            if labelName % panel == "label%sTotalTurretHardpoints" % panel:
                totalTurretHardpoints = value
                labelTTH = label

            if labelName % panel == "label%sUsedLauncherHardpoints" % panel:
                usedLauncherHardpoints = value
                labelULH = label

            if labelName % panel == "label%sTotalLauncherHardpoints" % panel:
                totalLauncherHardPoints = value
                labelTLH = label

            if labelName % panel == "label%sUsedDronesActive" % panel:
                usedDronesActive = value
                labelUDA = label

            if labelName % panel == "label%sTotalDronesActive" % panel:
                totalDronesActive = value
                labelTDA = label

            if labelName % panel == "label%sUsedCalibrationPoints" % panel:
                usedCalibrationPoints = value
                labelUCP = label

            if labelName % panel == "label%sTotalCalibrationPoints" % panel:
                totalCalibrationPoints = value
                labelTCP = label

            if isinstance(value, basestring):
                label.SetLabel(value)
                label.SetToolTip(wx.ToolTip(value))
            else:
                label.SetLabel(formatAmount(value, prec, lowest, highest))
                label.SetToolTip(wx.ToolTip("%.1f" % value))

        colorWarn = wx.Colour(204, 51, 51)
        colorNormal = wx.SystemSettings_GetColour(wx.SYS_COLOUR_WINDOWTEXT)

        if usedTurretHardpoints > totalTurretHardpoints:
            colorT = colorWarn
        else:
            colorT = colorNormal
        if usedLauncherHardpoints > totalLauncherHardPoints:
            colorL = colorWarn
        else:
            colorL = colorNormal
        if usedDronesActive > totalDronesActive:
            colorD = colorWarn
        else:
            colorD = colorNormal
        if usedCalibrationPoints > totalCalibrationPoints:
            colorC = colorWarn
        else:
            colorC = colorNormal

        labelUTH.SetForegroundColour(colorT)
        labelTTH.SetForegroundColour(colorT)
        labelULH.SetForegroundColour(colorL)
        labelTLH.SetForegroundColour(colorL)
        labelUDA.SetForegroundColour(colorD)
        labelTDA.SetForegroundColour(colorD)
        labelUCP.SetForegroundColour(colorC)
        labelTCP.SetForegroundColour(colorC)

        if fit is not None:
            resMax = (lambda: fit.ship.getModifiedItemAttr("cpuOutput"),
                    lambda: fit.ship.getModifiedItemAttr("powerOutput"),
                    lambda: fit.ship.getModifiedItemAttr("droneCapacity"),
                    lambda: fit.ship.getModifiedItemAttr("droneBandwidth"),
                    lambda: fit.ship.getModifiedItemAttr("capacity"))

        i = 0
        for resourceType in ("cpu", "pg", "droneBay", "droneBandwidth", "cargoBay"):
            if fit is not None:
                capitalizedType = resourceType[0].capitalize() + resourceType[1:]

                gauge = getattr(self, "gauge%s%s" % (panel, capitalizedType))
                resUsed = getattr(fit,"%sUsed" % resourceType)

                gauge.SetValueRange(resUsed or 0, resMax[i]() or 0)

                i+=1
            else:
                capitalizedType = resourceType[0].capitalize() + resourceType[1:]

                gauge = getattr(self, "gauge%s%s" % (panel, capitalizedType))

                gauge.SetValueRange(0, 0)

                i+=1

        self.panel.Layout()
        self.headerPanel.Layout()

ResourcesViewFull.register()

########NEW FILE########
__FILENAME__ = targetingMiscViewFull
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import wx
from gui.statsView import StatsView
from gui import builtinStatsViews
from gui.utils.numberFormatter import formatAmount

class TargetingMiscViewFull(StatsView):
    name = "targetingmiscViewFull"
    def __init__(self, parent):
        StatsView.__init__(self)
        self.parent = parent
        self._cachedValues = []
    def getHeaderText(self, fit):
        return "Targeting && Misc"

    def getTextExtentW(self, text):
        width, height = self.parent.GetTextExtent( text )
        return width

    def populatePanel(self, contentPanel, headerPanel):
        contentSizer = contentPanel.GetSizer()

        self.panel = contentPanel
        self.headerPanel = headerPanel
        gridTargetingMisc = wx.FlexGridSizer(1, 3)
        contentSizer.Add( gridTargetingMisc, 0, wx.EXPAND | wx.ALL, 0)
        gridTargetingMisc.AddGrowableCol(0)
        gridTargetingMisc.AddGrowableCol(2)
        # Targeting

        gridTargeting = wx.FlexGridSizer(4, 2)
        gridTargeting.AddGrowableCol(1)

        gridTargetingMisc.Add(gridTargeting, 0, wx.ALIGN_LEFT | wx.ALL, 5)

        labels = (("Targets", "Targets", ""),
                  ("Range", "Range", "km"),
                  ("Scan res.", "ScanRes", "mm"),
                  ("Sensor str.", "SensorStr", ""),
                  ("Drone range", "CtrlRange", "km"))

        for header, labelShort, unit in labels:
            gridTargeting.Add(wx.StaticText(contentPanel, wx.ID_ANY, "%s: " % header), 0, wx.ALIGN_LEFT)

            box = wx.BoxSizer(wx.HORIZONTAL)
            gridTargeting.Add(box, 0, wx.ALIGN_LEFT)

            lbl = wx.StaticText(contentPanel, wx.ID_ANY, "0 %s" %unit)
            setattr(self, "label%s" % labelShort, lbl)
            box.Add(lbl, 0, wx.ALIGN_LEFT)

            self._cachedValues.append(0)

        # Misc
        gridTargetingMisc.Add( wx.StaticLine( contentPanel, wx.ID_ANY, style = wx.VERTICAL),0, wx.EXPAND, 3 )
        gridMisc = wx.FlexGridSizer(4, 2)
        gridMisc.AddGrowableCol(1)
        gridTargetingMisc.Add(gridMisc,0 , wx.ALIGN_LEFT | wx.ALL, 5)

        labels = (("Speed", "Speed", "m/s"),
                  ("Align time", "AlignTime", "s"),
                  ("Signature", "SigRadius", "m"),
                  ("Warp Speed", "WarpSpeed", "AU/s"),
                  ("Cargo", "Cargo", u"m\u00B3"))

        for header, labelShort, unit in labels:
            gridMisc.Add(wx.StaticText(contentPanel, wx.ID_ANY, "%s: " % header), 0, wx.ALIGN_LEFT)

            box = wx.BoxSizer(wx.HORIZONTAL)
            gridMisc.Add(box, 0, wx.ALIGN_LEFT)

            lbl = wx.StaticText(contentPanel, wx.ID_ANY, "0 %s" % unit)
            setattr(self, "labelFull%s" % labelShort, lbl)
            box.Add(lbl, 0, wx.ALIGN_LEFT)

            self._cachedValues.append(0)


    def refreshPanel(self, fit):
        #If we did anything interesting, we'd update our labels to reflect the new fit's stats here

        stats = (("labelTargets", lambda: fit.maxTargets, 3, 0, 0, ""),
                 ("labelRange", lambda: fit.maxTargetRange / 1000, 3, 0, 0, "km"),
                 ("labelScanRes", lambda: fit.ship.getModifiedItemAttr("scanResolution"), 3, 0, 0, "mm"),
                 ("labelSensorStr", lambda: fit.scanStrength, 3, 0, 0, ""),
                 ("labelCtrlRange", lambda: fit.extraAttributes["droneControlRange"] / 1000, 3, 0, 0, "km"),
                 ("labelFullSpeed", lambda: fit.ship.getModifiedItemAttr("maxVelocity"), 3, 0, 0, "m/s"),
                 ("labelFullAlignTime", lambda: fit.alignTime, 3, 0, 0, "s"),
                 ("labelFullSigRadius", lambda: fit.ship.getModifiedItemAttr("signatureRadius"), 3, 0, 9, ""),
                 ("labelFullWarpSpeed", lambda: fit.warpSpeed, 3, 0, 0, "AU/s"),
                 ("labelFullCargo", lambda: fit.ship.getModifiedItemAttr("capacity"), 3, 0, 9, u"m\u00B3"))

        counter = 0
        RADII = [("Pod",25), ("Interceptor",33), ("Frigate",38),
                 ("Destroyer", 83), ("Cruiser", 130),
                 ("Battlecruiser", 265),  ("Battleship",420),
                 ("Carrier", 3000)]
        for labelName, value, prec, lowest, highest, unit in stats:
            label = getattr(self, labelName)
            value = value() if fit is not None else 0
            value = value if value is not None else 0
            if self._cachedValues[counter] != value:
                label.SetLabel("%s %s" %(formatAmount(value, prec, lowest, highest), unit))
                # Tooltip stuff
                if fit:
                    if labelName == "labelScanRes":
                        lockTime = "%s\n" % "Lock Times".center(30)
                        for size, radius in RADII:
                            left = "%.1fs" % fit.calculateLockTime(radius)
                            right = "%s [%d]" % (size, radius)
                            lockTime += "%5s\t%s\n" % (left,right)
                        # print lockTime # THIS IS ALIGNED!
                        label.SetToolTip(wx.ToolTip(lockTime))
                    elif labelName == "labelSensorStr":
                        label.SetToolTip(wx.ToolTip("Type: %s - %.1f" % (fit.scanType, value)))
                    elif labelName == "labelFullSigRadius":
                        label.SetToolTip(wx.ToolTip("Probe Size: %.3f" % (fit.probeSize or 0) ))
                    elif labelName == "labelFullWarpSpeed":
                        label.SetToolTip(wx.ToolTip("Max Warp Distance: %.1f AU" % fit.maxWarpDistance))
                    elif labelName == "labelFullAlignTime":
                        label.SetToolTip(wx.ToolTip("%.3f" % value))
                    elif labelName == "labelFullCargo":
                        tip  = u"Capacity: %sm\u00B3\n"% fit.ship.getModifiedItemAttr("capacity")
                        tip += u"Available: %.1fm\u00B3" % (fit.ship.getModifiedItemAttr("capacity")-fit.cargoBayUsed)
                        label.SetToolTip(wx.ToolTip(tip))
                    else:
                        label.SetToolTip(wx.ToolTip("%.1f" % value))
                else:
                    label.SetToolTip(wx.ToolTip(""))
                self._cachedValues[counter] = value
            elif labelName == "labelFullWarpSpeed":
                if fit:
                    label.SetToolTip(wx.ToolTip("Max Warp Distance: %.1f AU" % fit.maxWarpDistance))
                else:
                    label.SetToolTip(wx.ToolTip(""))
            elif labelName == "labelFullCargo":
                if fit:
                    # if you add stuff to cargo, the capacity doesn't change and thus it is still cached
                    # This assures us that we force refresh of cargo tooltip
                    tip  = u"Capacity: %sm\u00B3\n"% fit.ship.getModifiedItemAttr("capacity")
                    tip += u"Available: %.1fm\u00B3" % (fit.ship.getModifiedItemAttr("capacity")-fit.cargoBayUsed)
                    label.SetToolTip(wx.ToolTip(tip))
                else:
                    label.SetToolTip(wx.ToolTip(""))

            counter += 1

        self.panel.Layout()
        self.headerPanel.Layout()

TargetingMiscViewFull.register()

########NEW FILE########
__FILENAME__ = ammo
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from gui import builtinViewColumns
from gui.viewColumn import ViewColumn
from gui import bitmapLoader
import wx

class Ammo(ViewColumn):
    name = "Ammo"
    def __init__(self, fittingView, params):
        ViewColumn.__init__(self, fittingView)
        self.mask = wx.LIST_MASK_IMAGE
        self.imageId = fittingView.imageList.GetImageIndex("damagePattern_small", "icons")
        self.bitmap = bitmapLoader.getBitmap("damagePattern_small", "icons")

    def getText(self, stuff):
        if getattr(stuff, "charge", None) is not None:
            shots = stuff.numShots
            if shots > 0:
                text = "%s (%s)" % (stuff.charge.name, stuff.numShots)
            else:
                text = stuff.charge.name
        else:
            text = ""

        return text


    def getImageId(self, mod):
        return -1

Ammo.register()

########NEW FILE########
__FILENAME__ = ammoIcon
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from gui import builtinViewColumns
from gui.viewColumn import ViewColumn
from gui import bitmapLoader
import wx
from eos.types import Module

class AmmoIcon(ViewColumn):
    name = "Ammo Icon"
    def __init__(self, fittingView, params):
        ViewColumn.__init__(self, fittingView)
        self.size = 16
        self.maxsize = self.size
        self.mask = wx.LIST_MASK_IMAGE
        self.columnText = ""

    def getText(self, mod):
        return ""

    def getImageId(self, stuff):
        if not isinstance(stuff, Module):
            return -1

        if stuff.charge is None:
            return -1
        else:
            iconFile = stuff.charge.icon.iconFile if stuff.item.icon else ""
            if iconFile:
                return self.fittingView.imageList.GetImageIndex(iconFile, "pack")
            else:
                return -1

AmmoIcon.register()

########NEW FILE########
__FILENAME__ = attributeDisplay
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from gui import builtinViewColumns
from gui.viewColumn import ViewColumn
from gui import bitmapLoader
from gui.utils.numberFormatter import formatAmount

import service
import wx

class AttributeDisplay(ViewColumn):
    name = "attr"
    def __init__(self, fittingView, params):
        ViewColumn.__init__(self, fittingView)
        cAttribute = service.Attribute.getInstance()
        info = cAttribute.getAttributeInfo(params["attribute"])
        self.info = info
        if params["showIcon"]:
            if info.name == "power":
                iconFile = "pg_small"
                iconType = "icons"
            else:
                iconFile = info.icon.iconFile if info.icon else None
                iconType = "pack"
            if iconFile:
                self.imageId = fittingView.imageList.GetImageIndex(iconFile, iconType)
                self.bitmap = bitmapLoader.getBitmap(iconFile, iconType)
            else:
                self.imageId = -1

            self.mask = wx.LIST_MASK_IMAGE
        else:
            self.imageId = -1

        if params["displayName"] or self.imageId == -1:
            self.columnText = info.displayName if info.displayName != "" else info.name
            self.mask |= wx.LIST_MASK_IMAGE

        if params["direct"]:
            self.direct = True
            self.view = fittingView
            originalRefresh = fittingView.refresh
            sMarket = service.Market.getInstance()
            #Hack into our master view and add a callback for ourselves to know when to query
            def refresh(stuff):
                self.directInfo = sMarket.directAttrRequest(stuff, info) if stuff else None
                originalRefresh(stuff)

            fittingView.refresh = refresh

    def getText(self, mod):
        if hasattr(mod, "item"):
            attr = mod.getModifiedItemAttr(self.info.name)
        else:
            if self.direct:
                info = self.directInfo
                attr = info.get(mod.ID, "") if info else ""
            else:
                attr = mod.getAttribute(self.info.name)

        if self.info.name == "volume":
            str = (formatAmount(attr, 3, 0, 3))
            if hasattr(mod, "amount"):
                str = str + u"m\u00B3 (%s m\u00B3)"%(formatAmount(attr*mod.amount, 3, 0, 3))
            attr = str

        if isinstance(attr, (float, int)):
            attr = (formatAmount(attr, 3, 0, 3))

        return attr if attr is not None else ""

    def getImageId(self, mod):
        return -1

    @staticmethod
    def getParameters():
        return (("attribute", str, None),
                ("displayName", bool, False),
                ("showIcon", bool, True),
                ("direct", bool, False))

AttributeDisplay.register()

########NEW FILE########
__FILENAME__ = baseIcon
from gui import builtinViewColumns
from gui.viewColumn import ViewColumn
from gui import bitmapLoader
import wx
from eos.types import Drone, Fit, Module, Slot, Rack

class BaseIcon(ViewColumn):
    name = "Base Icon"
    def __init__(self, fittingView, params):
        ViewColumn.__init__(self, fittingView)
        self.size = 16
        self.maxsize = self.size
        self.mask = wx.LIST_MASK_IMAGE
        self.columnText = ""
        self.shipImage = fittingView.imageList.GetImageIndex("ship_small", "icons")

    def getImageId(self, stuff):
        if isinstance(stuff, Drone):
            return -1
        if isinstance(stuff, Fit):
            return self.shipImage
        if isinstance(stuff, Rack):
            return -1
        if isinstance(stuff, Module):
            if stuff.isEmpty:
                return self.fittingView.imageList.GetImageIndex("slot_%s_small" % Slot.getName(stuff.slot).lower(), "icons")
            else:
                return self.loadIconFile(stuff.item.icon.iconFile if stuff.item.icon else "")

        item = getattr(stuff, "item", stuff)
        return self.loadIconFile(item.icon.iconFile if item.icon else "")

    def loadIconFile(self, iconFile):
        if iconFile:
            return self.fittingView.imageList.GetImageIndex(iconFile, "pack")
        else:
            return -1

BaseIcon.register()

########NEW FILE########
__FILENAME__ = baseName
# -*- coding: utf-8 -*-
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from gui import builtinViewColumns
from gui.viewColumn import ViewColumn
from gui import bitmapLoader
import wx
from eos.types import Drone, Cargo, Fit, Module, Slot, Rack
import service

class BaseName(ViewColumn):
    name = "Base Name"
    def __init__(self, fittingView, params):
        ViewColumn.__init__(self, fittingView)
        self.columnText = "Name"
        self.shipImage = fittingView.imageList.GetImageIndex("ship_small", "icons")
        self.mask = wx.LIST_MASK_TEXT

    def getText(self, stuff):
        if isinstance(stuff, Drone):
            return "%dx %s" % (stuff.amount, stuff.item.name)
        elif isinstance(stuff, Cargo):
            return "%dx %s" % (stuff.amount, stuff.item.name)
        elif isinstance(stuff, Fit):
            return "%s (%s)" % (stuff.name, stuff.ship.item.name)
        elif isinstance(stuff, Rack):
            if service.Fit.getInstance().serviceFittingOptions["rackLabels"]:
                return u'─ {} Slots ─'.format(Slot.getName(stuff.slot).capitalize())
            else:
                return ""
        elif isinstance(stuff, Module):
            if stuff.isEmpty:
                return "%s Slot" % Slot.getName(stuff.slot).capitalize()
            else:
                return stuff.item.name
        else:
            item = getattr(stuff, "item", stuff)
            return item.name

BaseName.register()

########NEW FILE########
__FILENAME__ = capacitorUse
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import wx
import service

from gui.utils.numberFormatter import formatAmount
from gui.viewColumn import ViewColumn
from gui import bitmapLoader

class CapacitorUse(ViewColumn):
    name = "Capacitor Usage"
    def __init__(self, fittingView, params):
        ViewColumn.__init__(self, fittingView)

        self.mask = wx.LIST_MASK_IMAGE

        cAttribute = service.Attribute.getInstance()
        info = cAttribute.getAttributeInfo("capacitorNeed")
        self.imageId = fittingView.imageList.GetImageIndex(info.icon.iconFile, "pack")
        self.bitmap = bitmapLoader.getBitmap(info.icon.iconFile, "pack")


    def getText(self, mod):
        capUse = mod.capUse
        if capUse:
            return "%s%s" % ("+" if capUse < 0 else "", (formatAmount(-capUse, 3, 0, 3)))
        else:
            return ""

    def getImageId(self, mod):
        return -1

CapacitorUse.register()

########NEW FILE########
__FILENAME__ = maxRange
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from gui import builtinViewColumns
from gui.viewColumn import ViewColumn
from gui import bitmapLoader
import service
from gui.utils.numberFormatter import formatAmount
import wx

class MaxRange(ViewColumn):
    name = "Max Range"
    def __init__(self, fittingView, params = None):
        if params == None:
            params = {"showIcon": True,
                      "displayName": False}
        ViewColumn.__init__(self, fittingView)

        cAttribute = service.Attribute.getInstance()
        info = cAttribute.getAttributeInfo("maxRange")
        self.info = info
        if params["showIcon"]:
            iconFile = info.icon.iconFile if info.icon else None
            if iconFile:
                self.imageId = fittingView.imageList.GetImageIndex(iconFile, "pack")
                self.bitmap = bitmapLoader.getBitmap(iconFile, "pack")
            else:
                self.imageId = -1
            self.mask = wx.LIST_MASK_IMAGE
        else:
            self.imageId = -1

        if params["displayName"] or self.imageId == -1:
            self.columnText = info.displayName if info.displayName != "" else info.name
            self.mask |= wx.LIST_MASK_TEXT

    def getText(self, stuff):
        maxRange = stuff.maxRange if hasattr(stuff, "maxRange") else stuff.getModifiedItemAttr("maxRange")
        falloff = stuff.falloff
        if falloff:
            falloff = "+%sm" % formatAmount(falloff, 3, 0, 3)
        else:
            falloff = ""

        if maxRange:
            return "%sm%s" % (formatAmount(maxRange, 3, 0, 3), falloff)
        else:
            return "" + falloff

    def getImageId(self, mod):
        return -1

    def getParameters(self):
        return (("displayName", bool, False),
                ("showIcon", bool, True))

MaxRange.register()

########NEW FILE########
__FILENAME__ = misc
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================


import gui.mainFrame
from gui import builtinViewColumns
from gui.viewColumn import ViewColumn
from gui import bitmapLoader
from gui.utils.numberFormatter import formatAmount
from gui.utils.listFormatter import formatList
from service.fit import Fit

import wx

class Miscellanea(ViewColumn):
    name = "Miscellanea"
    def __init__(self, fittingView, params = None):
        if params == None:
            params = {"showIcon": True,
                      "displayName": False}
        ViewColumn.__init__(self, fittingView)
        if params["showIcon"]:
            self.imageId = fittingView.imageList.GetImageIndex("column_misc", "icons")
            self.bitmap = bitmapLoader.getBitmap("column_misc", "icons")
            self.mask = wx.LIST_MASK_IMAGE
        else:
            self.imageId = -1

        if params["displayName"] or self.imageId == -1:
            self.columnText = "Misc data"
            self.mask |= wx.LIST_MASK_TEXT
        self.mainFrame = gui.mainFrame.MainFrame.getInstance()

    def getText(self, stuff):
        text = self.__getData(stuff)[0]
        return text

    def getToolTip(self, mod):
        text = self.__getData(mod)[1]
        return text

    def getImageId(self, mod):
        return -1

    def getParameters(self):
        return (("displayName", bool, False),
                ("showIcon", bool, True))


    def __getData(self, stuff):
        item = stuff.item
        if item is None:
            return "", None
        itemGroup = item.group.name
        if itemGroup in ("Energy Weapon", "Hybrid Weapon", "Projectile Weapon", "Combat Drone", "Fighter Drone"):
            trackingSpeed = stuff.getModifiedItemAttr("trackingSpeed")
            if not trackingSpeed:
                return "", None
            text = "{0}".format(formatAmount(trackingSpeed, 3, 0, 3))
            tooltip = "Tracking speed"
            return text, tooltip
        elif itemGroup == "Energy Destabilizer":
            neutAmount = stuff.getModifiedItemAttr("energyDestabilizationAmount")
            cycleTime = stuff.cycleTime
            if not neutAmount or not cycleTime:
                return "", None
            capPerSec = float(-neutAmount) * 1000 / cycleTime
            text = "{0}/s".format(formatAmount(capPerSec, 3, 0, 3))
            tooltip = "Energy neutralization per second"
            return text, tooltip
        elif itemGroup == "Energy Vampire":
            neutAmount = stuff.getModifiedItemAttr("powerTransferAmount")
            cycleTime = stuff.cycleTime
            if not neutAmount or not cycleTime:
                return "", None
            capPerSec = float(-neutAmount) * 1000 / cycleTime
            text = "{0}/s".format(formatAmount(capPerSec, 3, 0, 3))
            tooltip = "Energy neutralization per second"
            return text, tooltip
        elif itemGroup == "Salvager":
            chance = stuff.getModifiedItemAttr("accessDifficultyBonus")
            if not chance:
                return "", None
            text = "{0}%".format(formatAmount(chance, 3, 0, 3))
            tooltip = "Item retrieval chance"
            return text, tooltip
        elif itemGroup == "Data Miners":
            strength = stuff.getModifiedItemAttr("virusStrength")
            coherence = stuff.getModifiedItemAttr("virusCoherence")
            if not strength or not coherence:
                return "", None
            text = "{0} | {1}".format(formatAmount(strength, 3, 0, 3), formatAmount(coherence, 3, 0, 3))
            tooltip = "Virus strength and coherence"
            return text, tooltip
        elif itemGroup in ("Warp Scrambler", "Warp Core Stabilizer"):
            scramStr = stuff.getModifiedItemAttr("warpScrambleStrength")
            if not scramStr:
                return "", None
            text = "{0}".format(formatAmount(-scramStr, 3, 0, 3, forceSign=True))
            tooltip = "Warp core strength modification"
            return text, tooltip
        elif itemGroup in ("Stasis Web", "Stasis Webifying Drone"):
            speedFactor = stuff.getModifiedItemAttr("speedFactor")
            if not speedFactor:
                return "", None
            text = "{0}%".format(formatAmount(speedFactor, 3, 0, 3))
            tooltip = "Speed reduction"
            return text, tooltip
        elif itemGroup == "Target Painter":
            sigRadBonus = stuff.getModifiedItemAttr("signatureRadiusBonus")
            if not sigRadBonus:
                return "", None
            text = "{0}%".format(formatAmount(sigRadBonus, 3, 0, 3, forceSign=True))
            tooltip = "Signature radius increase"
            return text, tooltip
        elif itemGroup == "Remote Sensor Damper":
            lockRangeBonus = stuff.getModifiedItemAttr("maxTargetRangeBonus")
            scanResBonus = stuff.getModifiedItemAttr("scanResolutionBonus")
            if lockRangeBonus is None or scanResBonus is None:
                return "", None
            display = 0
            for bonus in (lockRangeBonus, scanResBonus):
                if abs(bonus) > abs(display):
                    display = bonus
            if not display:
                return "", None
            text = "{0}%".format(formatAmount(display, 3, 0, 3, forceSign=True))
            ttEntries = []
            if display == lockRangeBonus:
                ttEntries.append("lock range")
            if display == scanResBonus:
                ttEntries.append("scan resolution")
            tooltip = "{0} dampening".format(formatList(ttEntries)).capitalize()
            return text, tooltip
        elif itemGroup == "Tracking Disruptor":
            optimalRangeBonus = stuff.getModifiedItemAttr("maxRangeBonus")
            falloffRangeBonus = stuff.getModifiedItemAttr("falloffBonus")
            trackingSpeedBonus = stuff.getModifiedItemAttr("trackingSpeedBonus")
            if optimalRangeBonus is None or falloffRangeBonus is None or trackingSpeedBonus is None:
                return "", None
            display = 0
            for bonus in (optimalRangeBonus, falloffRangeBonus, trackingSpeedBonus):
                if abs(bonus) > abs(display):
                    display = bonus
            if not display:
                return "", None
            text = "{0}%".format(formatAmount(display, 3, 0, 3, forceSign=True))
            ttEntries = []
            if display == optimalRangeBonus:
                ttEntries.append("optimal range")
            if display == falloffRangeBonus:
                ttEntries.append("falloff range")
            if display == trackingSpeedBonus:
                ttEntries.append("tracking speed")
            tooltip = "{0} disruption".format(formatList(ttEntries)).capitalize()
            return text, tooltip
        elif itemGroup in ("ECM", "ECM Burst", "Remote ECM Burst"):
            grav = stuff.getModifiedItemAttr("scanGravimetricStrengthBonus")
            ladar = stuff.getModifiedItemAttr("scanLadarStrengthBonus")
            radar = stuff.getModifiedItemAttr("scanRadarStrengthBonus")
            magnet = stuff.getModifiedItemAttr("scanMagnetometricStrengthBonus")
            if grav is None or ladar is None or radar is None or magnet is None:
                return "", None
            display = max(grav, ladar, radar, magnet)
            if not display:
                return "", None
            text = "{0}".format(formatAmount(display, 3, 0, 3))
            ttEntries = []
            if display == grav:
                ttEntries.append("gravimetric")
            if display == ladar:
                ttEntries.append("ladar")
            if display == magnet:
                ttEntries.append("magnetometric")
            if display == radar:
                ttEntries.append("radar")
            plu = "" if len(ttEntries) == 1 else "s"
            tooltip = "{0} strength{1}".format(formatList(ttEntries), plu).capitalize()
            return text, tooltip
        elif itemGroup in ("Remote Sensor Booster", "Sensor Booster", "Signal Amplifier"):
            scanResBonus = stuff.getModifiedItemAttr("scanResolutionBonus")
            lockRangeBonus = stuff.getModifiedItemAttr("maxTargetRangeBonus")
            if scanResBonus is None or lockRangeBonus is None:
                return "", None
            display = 0
            for bonus in (scanResBonus, lockRangeBonus):
                if abs(bonus) > abs(display):
                    display = bonus
            if not display:
                return "", None
            text = "{0}%".format(formatAmount(display, 3, 0, 3, forceSign=True))
            ttEntries = []
            if display == lockRangeBonus:
                ttEntries.append("lock range")
            if display == scanResBonus:
                ttEntries.append("scan resolution")
            tooltip = "{0} bonus".format(formatList(ttEntries)).capitalize()
            return text, tooltip
        elif itemGroup in ("Projected ECCM", "ECCM", "Sensor Backup Array"):
            grav = stuff.getModifiedItemAttr("scanGravimetricStrengthPercent")
            ladar = stuff.getModifiedItemAttr("scanLadarStrengthPercent")
            radar = stuff.getModifiedItemAttr("scanRadarStrengthPercent")
            magnet = stuff.getModifiedItemAttr("scanMagnetometricStrengthPercent")
            if grav is None or ladar is None or radar is None or magnet is None:
                return "", None
            display = max(grav, ladar, radar, magnet)
            if not display:
                return "", None
            text = "{0}%".format(formatAmount(display, 3, 0, 3, forceSign=True))
            ttEntries = []
            if display == grav:
                ttEntries.append("gravimetric")
            if display == ladar:
                ttEntries.append("ladar")
            if display == magnet:
                ttEntries.append("magnetometric")
            if display == radar:
                ttEntries.append("radar")
            plu = "" if len(ttEntries) == 1 else "s"
            tooltip = "{0} strength{1} bonus".format(formatList(ttEntries), plu).capitalize()
            return text, tooltip
        elif itemGroup == "Cloaking Device":
            recalibration = stuff.getModifiedItemAttr("cloakingTargetingDelay")
            if recalibration is None:
                return "", None
            text = "{0}s".format(formatAmount(float(recalibration)/1000, 3, 0, 3))
            tooltip = "Sensor recalibration time"
            return text, tooltip
        elif itemGroup == "Remote Armor Repairer":
            repAmount = stuff.getModifiedItemAttr("armorDamageAmount")
            cycleTime = stuff.getModifiedItemAttr("duration")
            if not repAmount or not cycleTime:
                return "", None
            repPerSec = float(repAmount) * 1000 / cycleTime
            text = "{0}/s".format(formatAmount(repPerSec, 3, 0, 3, forceSign=True))
            tooltip = "Armor repaired per second"
            return text, tooltip
        elif itemGroup == "Remote Shield Booster":
            repAmount = stuff.getModifiedItemAttr("shieldBonus")
            cycleTime = stuff.cycleTime
            if not repAmount or not cycleTime:
                return "", None
            repPerSec = float(repAmount) * 1000 / cycleTime
            text = "{0}/s".format(formatAmount(repPerSec, 3, 0, 3, forceSign=True))
            tooltip = "Shield transferred per second"
            return text, tooltip
        elif itemGroup == "Remote Capacitor Transmitter":
            repAmount = stuff.getModifiedItemAttr("powerTransferAmount")
            cycleTime = stuff.cycleTime
            if not repAmount or not cycleTime:
                return "", None
            repPerSec = float(repAmount) * 1000 / cycleTime
            text = "{0}/s".format(formatAmount(repPerSec, 3, 0, 3, forceSign=True))
            tooltip = "Energy transferred per second"
            return text, tooltip
        elif itemGroup == "Remote Hull Repairer":
            repAmount = stuff.getModifiedItemAttr("structureDamageAmount")
            cycleTime = stuff.cycleTime
            if not repAmount or not cycleTime:
                return "", None
            repPerSec = float(repAmount) * 1000 / cycleTime
            text = "{0}/s".format(formatAmount(repPerSec, 3, 0, 3, forceSign=True))
            tooltip = "Structure repaired per second"
            return text, tooltip
        elif itemGroup == "Gang Coordinator":
            command = stuff.getModifiedItemAttr("commandBonus") or stuff.getModifiedItemAttr("commandBonusHidden")
            if not command:
                return "", None
            text = "{0}%".format(formatAmount(command, 3, 0, 3, forceSign=True))
            tooltip = "Gang bonus strength"
            return text, tooltip
        elif itemGroup == "Electronic Warfare Drone":
            sigRadBonus = stuff.getModifiedItemAttr("signatureRadiusBonus")
            lockRangeMult = stuff.getModifiedItemAttr("maxTargetRangeMultiplier")
            scanResMult = stuff.getModifiedItemAttr("scanResolutionMultiplier")
            falloffRangeMult = stuff.getModifiedItemAttr("fallofMultiplier")
            optimalRangeMult = stuff.getModifiedItemAttr("maxRangeMultiplier")
            trackingSpeedMult = stuff.getModifiedItemAttr("trackingSpeedMultiplier")
            grav = stuff.getModifiedItemAttr("scanGravimetricStrengthBonus")
            ladar = stuff.getModifiedItemAttr("scanLadarStrengthBonus")
            radar = stuff.getModifiedItemAttr("scanRadarStrengthBonus")
            magnet = stuff.getModifiedItemAttr("scanMagnetometricStrengthBonus")
            if sigRadBonus:
                text = "{0}%".format(formatAmount(sigRadBonus, 3, 0, 3, forceSign=True))
                tooltip = "Signature radius increase"
                return text, tooltip
            if lockRangeMult is not None and scanResMult is not None:
                lockRangeBonus = (lockRangeMult - 1) * 100
                scanResBonus = (scanResMult - 1) * 100
                display = 0
                for bonus in (lockRangeBonus, scanResBonus):
                    if abs(bonus) > abs(display):
                        display = bonus
                if not display:
                    return "", None
                text = "{0}%".format(formatAmount(display, 3, 0, 3, forceSign=True))
                ttEntries = []
                if display == lockRangeBonus:
                    ttEntries.append("lock range")
                if display == scanResBonus:
                    ttEntries.append("scan resolution")
                tooltip = "{0} dampening".format(formatList(ttEntries)).capitalize()
                return text, tooltip
            if falloffRangeMult is not None and optimalRangeMult is not None and trackingSpeedMult is not None:
                falloffRangeBonus = (falloffRangeMult - 1) * 100
                optimalRangeBonus = (optimalRangeMult - 1) * 100
                trackingSpeedBonus = (trackingSpeedMult - 1) * 100
                display = 0
                for bonus in (falloffRangeBonus, optimalRangeBonus, trackingSpeedBonus):
                    if abs(bonus) > abs(display):
                        display = bonus
                if not display:
                    return "", None
                text = "{0}%".format(formatAmount(display, 3, 0, 3), forceSign=True)
                ttEntries = []
                if display == optimalRangeBonus:
                    ttEntries.append("optimal range")
                if display == falloffRangeBonus:
                    ttEntries.append("falloff range")
                if display == trackingSpeedBonus:
                    ttEntries.append("tracking speed")
                tooltip = "{0} disruption".format(formatList(ttEntries)).capitalize()
                return text, tooltip
            if grav is not None and ladar is not None and radar is not None and magnet is not None:
                display = max(grav, ladar, radar, magnet)
                if not display:
                    return "", None
                text = "{0}".format(formatAmount(display, 3, 0, 3))
                ttEntries = []
                if display == grav:
                    ttEntries.append("gravimetric")
                if display == ladar:
                    ttEntries.append("ladar")
                if display == magnet:
                    ttEntries.append("magnetometric")
                if display == radar:
                    ttEntries.append("radar")
                plu = "" if len(ttEntries) == 1 else "s"
                tooltip = "{0} strength{1}".format(formatList(ttEntries), plu).capitalize()
                return text, tooltip
            else:
                return "", None
        elif itemGroup == "Fighter Bomber":
            optimalSig = stuff.getModifiedItemAttr("optimalSigRadius")
            if not optimalSig:
                return "", None
            text = "{0}m".format(formatAmount(optimalSig, 3, 0, 3))
            tooltip = "Optimal signature radius"
            return text, tooltip
        elif itemGroup in ("Frequency Mining Laser", "Strip Miner", "Mining Laser", "Gas Cloud Harvester"):
            miningAmount = stuff.getModifiedItemAttr("miningAmount")
            cycleTime = stuff.cycleTime
            if not miningAmount or not cycleTime:
                return "", None
            minePerSec = float(miningAmount) * 1000 / cycleTime
            text = "{0}/s".format(formatAmount(minePerSec, 3, 0, 3))
            tooltip = "Yield per second"
            return text, tooltip
        elif itemGroup == "Logistic Drone":
            armorAmount = stuff.getModifiedItemAttr("armorDamageAmount")
            shieldAmount = stuff.getModifiedItemAttr("shieldBonus")
            hullAmount = stuff.getModifiedItemAttr("structureDamageAmount")
            repAmount = armorAmount or shieldAmount or hullAmount
            cycleTime = stuff.getModifiedItemAttr("duration")
            if not repAmount or not cycleTime:
                return "", None
            repPerSec = float(repAmount) * 1000 / cycleTime
            text = "{0}/s".format(formatAmount(repPerSec, 3, 0, 3))
            ttEntries = []
            if hullAmount is not None and repAmount == hullAmount:
                ttEntries.append("structure")
            if armorAmount is not None and repAmount == armorAmount:
                ttEntries.append("armor")
            if shieldAmount is not None and repAmount == shieldAmount:
                ttEntries.append("shield")
            tooltip = "{0} repaired per second".format(formatList(ttEntries)).capitalize()
            return text, tooltip
        elif itemGroup == "Cap Drain Drone":
            neutAmount = stuff.getModifiedItemAttr("energyDestabilizationAmount")
            cycleTime = stuff.getModifiedItemAttr("duration")
            if not neutAmount or not cycleTime:
                return "", None
            capPerSec = float(-neutAmount) * 1000 / cycleTime
            text = "{0}/s".format(formatAmount(capPerSec, 3, 0, 3))
            tooltip = "Energy neutralization per second"
            return text, tooltip
        elif itemGroup == "Mining Drone":
            miningAmount = stuff.getModifiedItemAttr("miningAmount")
            cycleTime = stuff.getModifiedItemAttr("duration")
            if not miningAmount or not cycleTime:
                return "", None
            minePerSec = float(miningAmount) * 1000 / cycleTime
            text = "{0}/s".format(formatAmount(minePerSec, 3, 0, 3))
            tooltip = "Yield per second"
            return text, tooltip
        elif itemGroup == "Micro Jump Drive":
            cycleTime = stuff.getModifiedItemAttr("duration") / 1000
            text = "{0}s".format(cycleTime)
            tooltip = "Spoolup time"
            return text, tooltip
        elif itemGroup in ("Fueled Armor Repairer", "Fueled Shield Booster"):
            hp = stuff.hpBeforeReload
            cycles = stuff.numShots
            cycleTime = stuff.cycleTime
            if not hp or not cycleTime or not cycles:
                return "", None
            fit = Fit.getInstance().getFit(self.mainFrame.getActiveFit())
            ehpTotal = fit.ehp
            hpTotal = fit.hp
            useEhp = self.mainFrame.statsPane.nameViewMap["resistancesViewFull"].showEffective
            tooltip = "HP restored over duration using charges"
            if useEhp:
                if itemGroup == "Fueled Armor Repairer":
                    hpRatio = ehpTotal["armor"] / hpTotal["armor"]
                else:
                    hpRatio = ehpTotal["shield"] / hpTotal["shield"]
                tooltip = "E{0}".format(tooltip)
            else:
                hpRatio = 1
            ehp = hp * hpRatio
            duration = cycles * cycleTime / 1000
            text = "{0} / {1}s".format(formatAmount(ehp, 3, 0, 9), formatAmount(duration, 3, 0, 3))

            return text, tooltip
        elif stuff.charge is not None:
            chargeGroup = stuff.charge.group.name
            if chargeGroup in ("Rocket", "Advanced Rocket", "Light Missile", "Advanced Light Missile", "FoF Light Missile",
                               "Heavy Assault Missile", "Advanced Heavy Assault Missile", "Heavy Missile", "Advanced Heavy Missile", "FoF Heavy Missile",
                               "Torpedo", "Advanced Torpedo", "Cruise Missile", "Advanced Cruise Missile", "FoF Cruise Missile",
                               "Citadel Torpedo", "Citadel Cruise"):
                cloudSize = stuff.getModifiedChargeAttr("aoeCloudSize")
                aoeVelocity = stuff.getModifiedChargeAttr("aoeVelocity")
                if not cloudSize or not aoeVelocity:
                    return "", None
                text = "{0}{1} | {2}{3}".format(formatAmount(cloudSize, 3, 0, 3), "m",
                                                formatAmount(aoeVelocity, 3, 0, 3), "m/s")
                tooltip = "Explosion radius and explosion velocity"
                return text, tooltip
            elif chargeGroup == "Bomb":
                cloudSize = stuff.getModifiedChargeAttr("aoeCloudSize")
                if not cloudSize:
                    return "", None
                text = "{0}{1}".format(formatAmount(cloudSize, 3, 0, 3), "m")
                tooltip = "Explosion radius"
                return text, tooltip
            elif chargeGroup in ("Scanner Probe",):
                scanStr = stuff.getModifiedChargeAttr("baseSensorStrength")
                baseRange = stuff.getModifiedChargeAttr("baseScanRange")
                if not scanStr or not baseRange:
                    return "", None
                strTwoAu = scanStr / (2.0 / baseRange)
                text = "{0}".format(formatAmount(strTwoAu, 3, 0, 3))
                tooltip = "Scan strength with 2 AU scan range"
                return text, tooltip
            else:
                return "", None
        else:
            return "", None

Miscellanea.register()

########NEW FILE########
__FILENAME__ = price
#===============================================================================
# Copyright (C) 2010 Diego Duclos, Lucas Thode
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from gui.viewColumn import ViewColumn
from gui import bitmapLoader
from gui.utils.numberFormatter import formatAmount
import wx
import service

class Price(ViewColumn):
    name = "Price"
    def __init__(self, fittingView, params):
        ViewColumn.__init__(self, fittingView)
        self.mask = wx.LIST_MASK_IMAGE
        self.bitmap = bitmapLoader.getBitmap("totalPrice_small", "icons")
        self.imageId = fittingView.imageList.GetImageIndex("totalPrice_small", "icons")

    def getText(self, stuff):
        if stuff.item is None:
            return ""

        sMarket = service.Market.getInstance()
        price = sMarket.getPriceNow(stuff.item.ID)
        return formatAmount(price.price, 3, 3, 9, currency=True) if price and price.price else False

    def delayedText(self, mod, display, colItem):
        def callback(requests):
            price = requests[0].price
            colItem.SetText(formatAmount(price, 3, 3, 9, currency=True) if price else "")
            display.SetItem(colItem)

        service.Market.getInstance().getPrices([mod.item.ID], callback)

    def getImageId(self, mod):
        return -1

Price.register()

########NEW FILE########
__FILENAME__ = propertyDisplay
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from gui.viewColumn import ViewColumn
from gui import bitmapLoader
from gui.utils.numberFormatter import formatAmount
import wx
import service

class PropertyDisplay(ViewColumn):
    name = "prop"
    def __init__(self, fittingView, params):
        ViewColumn.__init__(self, fittingView)
        cAttribute = service.Attribute.getInstance()
        attributeSlave = params["attributeSlave"] or params["property"]
        # This function can throw an exception if the database isn't sane
        # We need to do a sanity check before this runs
        info = cAttribute.getAttributeInfo(attributeSlave)

        self.mask = 0
        self.propertyName = params["property"]
        self.info = info
        if params["showIcon"]:
            if info.name == "power":
                iconFile = "pg_small"
                iconType = "icons"
            else:
                iconFile = info.icon.iconFile if info.icon else None
                iconType = "pack"
            if iconFile:
                self.imageId = fittingView.imageList.GetImageIndex(iconFile, iconType)
            else:
                self.imageId = -1
        else:
            self.imageId = -1

        if params["displayName"] or self.imageId == -1:
            self.columnText = info.displayName if info.displayName != "" else info.name

    def getText(self, stuff):
        attr = getattr(stuff, self.propertyName, None)
        if attr:
            return (formatAmount(attr, 3, 0, 3))
        else:
            return ""

    @staticmethod
    def getParameters():
        return (("property", str, None),
                ("attributeSlave", str, None),
                ("displayName", bool, False),
                ("showIcon", bool, True))

PropertyDisplay.register()

########NEW FILE########
__FILENAME__ = state
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

from gui.viewColumn import ViewColumn
from gui import bitmapLoader
import wx
from eos.types import Drone, Module, Rack
from eos.types import State as State_

class State(ViewColumn):
    name = "State"
    def __init__(self, fittingView, params):
        ViewColumn.__init__(self, fittingView)
        self.resizable = False
        self.size = 16
        self.maxsize = self.size
        self.mask = wx.LIST_MASK_IMAGE
        for name, state in (("checked", wx.CONTROL_CHECKED), ("unchecked", 0)):
            bitmap = wx.EmptyBitmap(16, 16)
            dc = wx.MemoryDC()
            dc.SelectObject(bitmap)
            dc.SetBackground(wx.TheBrushList.FindOrCreateBrush(fittingView.GetBackgroundColour(), wx.SOLID))
            dc.Clear()
            wx.RendererNative.Get().DrawCheckBox(fittingView, dc, wx.Rect(0, 0, 16, 16), state)
            dc.Destroy()
            setattr(self, "%sId" % name, fittingView.imageList.Add(bitmap))

    def getText(self, mod):
        return ""

    def getImageId(self, stuff):
        if isinstance(stuff, Drone):
            return self.checkedId if stuff.amountActive > 0 else self.uncheckedId
        elif isinstance(stuff, Rack):
            return -1
        elif isinstance(stuff, Module):
            if stuff.isEmpty:
                return -1
            else:
                return self.fittingView.imageList.GetImageIndex("state_%s_small" % State_.getName(stuff.state).lower(), "icons")
        else:
            active = getattr(stuff, "active", None)
            if active is None:
                return -1
            else:
                return self.checkedId if active else self.uncheckedId

State.register()

########NEW FILE########
__FILENAME__ = emptyView
import wx
import gui.globalEvents as GE
import gui.chromeTabs
import gui.mainFrame
import service

class BlankPage(wx.Panel):
    def __init__(self, parent):
        wx.Panel.__init__(self, parent, size=(0, 0))

        self.mainFrame = gui.mainFrame.MainFrame.getInstance()
        self.parent = parent

        self.parent.Bind(gui.chromeTabs.EVT_NOTEBOOK_PAGE_CHANGED, self.pageChanged)

        wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=None))

    def Destroy(self):
        self.parent.Unbind(gui.chromeTabs.EVT_NOTEBOOK_PAGE_CHANGED, handler=self.pageChanged)
        wx.Panel.Destroy(self)

    def pageChanged(self, event):
        if self.parent.IsActive(self):
            fitID = None
#            sFit = service.Fit.getInstance()
#            sFit.switchFit(fitID)
            wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=fitID))

        event.Skip()
########NEW FILE########
__FILENAME__ = fittingView
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import wx
import wx.lib.newevent
import service
import gui.mainFrame
import gui.marketBrowser
import gui.display as d
from gui.contextMenu import ContextMenu
import gui.shipBrowser
import gui.multiSwitch
from eos.types import Slot, Rack
from gui.builtinViewColumns.state import State
from gui import bitmapLoader
import gui.builtinViews.emptyView
from gui.utils.exportHtml import exportHtml

import gui.globalEvents as GE

#Tab spawning handler
class FitSpawner(gui.multiSwitch.TabSpawner):
    def __init__(self, multiSwitch):
        self.multiSwitch = multiSwitch
        self.mainFrame = mainFrame = gui.mainFrame.MainFrame.getInstance()
        mainFrame.Bind(gui.shipBrowser.EVT_FIT_SELECTED, self.fitSelected)
        self.multiSwitch.tabsContainer.handleDrag = self.handleDrag

    def fitSelected(self, event):
        count = -1
        for index, page in enumerate(self.multiSwitch.pages):
            try:
                if page.activeFitID == event.fitID:
                    count += 1
                    self.multiSwitch.SetSelection(index)
                    wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=event.fitID))
                    break
            except:
                pass
        if count < 0:
            startup = getattr(event, "startup", False)  # see OpenFitsThread in gui.mainFrame
            mstate = wx.GetMouseState()

            if mstate.CmdDown() or mstate.MiddleDown() or startup:
                self.multiSwitch.AddPage()

            view = FittingView(self.multiSwitch)
            self.multiSwitch.ReplaceActivePage(view)
            view.fitSelected(event)

    def handleDrag(self, type, fitID):
        if type == "fit":
            for page in self.multiSwitch.pages:
                if isinstance(page, FittingView) and page.activeFitID == fitID:
                    index = self.multiSwitch.GetPageIndex(page)
                    self.multiSwitch.SetSelection(index)
                    wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=fitID))
                    return
                elif isinstance(page, gui.builtinViews.emptyView.BlankPage):
                    view = FittingView(self.multiSwitch)
                    self.multiSwitch.ReplaceActivePage(view)
                    view.handleDrag(type, fitID)
                    return

            view = FittingView(self.multiSwitch)
            self.multiSwitch.AddPage(view)
            view.handleDrag(type, fitID)

FitSpawner.register()

#Drag'n'drop handler
class FittingViewDrop(wx.PyDropTarget):
        def __init__(self, dropFn):
            wx.PyDropTarget.__init__(self)
            self.dropFn = dropFn
            # this is really transferring an EVE itemID
            self.dropData = wx.PyTextDataObject()
            self.SetDataObject(self.dropData)

        def OnData(self, x, y, t):
            if self.GetData():
                data = self.dropData.GetText().split(':')
                self.dropFn(x, y, data)
            return t

class FittingView(d.Display):
    DEFAULT_COLS = ["State",
                    "Ammo Icon",
                    "Base Icon",
                    "Base Name",
                    "attr:power",
                    "attr:cpu",
                    "Capacitor Usage",
                    "Max Range",
                    "Miscellanea",
                    "Price",
                    "Ammo",
                    ]

    def __init__(self, parent):
        d.Display.__init__(self, parent, size = (0,0), style =  wx.BORDER_NONE)
        self.Show(False)
        self.parent = parent
        self.mainFrame.Bind(GE.FIT_CHANGED, self.fitChanged)
        self.mainFrame.Bind(gui.shipBrowser.EVT_FIT_RENAMED, self.fitRenamed)
        self.mainFrame.Bind(gui.shipBrowser.EVT_FIT_REMOVED, self.fitRemoved)
        self.mainFrame.Bind(gui.marketBrowser.ITEM_SELECTED, self.appendItem)

        self.Bind(wx.EVT_LEFT_DCLICK, self.removeItem)
        self.Bind(wx.EVT_LIST_BEGIN_DRAG, self.startDrag)
        if "__WXGTK__" in  wx.PlatformInfo:
            self.Bind(wx.EVT_RIGHT_UP, self.scheduleMenu)
        else:
            self.Bind(wx.EVT_RIGHT_DOWN, self.scheduleMenu)

        self.SetDropTarget(FittingViewDrop(self.handleListDrag))
        self.activeFitID = None
        self.FVsnapshot = None
        self.itemCount = 0
        self.itemRect = 0

        self.hoveredRow = None
        self.hoveredColumn = None

        self.Bind(wx.EVT_KEY_UP, self.kbEvent)
        self.Bind(wx.EVT_LEFT_DOWN, self.click)
        self.Bind(wx.EVT_RIGHT_DOWN, self.click)
        self.Bind(wx.EVT_SHOW, self.OnShow)
        self.Bind(wx.EVT_MOTION, self.OnMouseMove)
        self.Bind(wx.EVT_LEAVE_WINDOW, self.OnLeaveWindow)
        self.parent.Bind(gui.chromeTabs.EVT_NOTEBOOK_PAGE_CHANGED, self.pageChanged)

    def OnLeaveWindow(self, event):
        self.SetToolTip(None)
        self.hoveredRow = None
        self.hoveredColumn = None
        event.Skip()

    def OnMouseMove(self, event):
        row, _, col = self.HitTestSubItem(event.Position)
        if row != self.hoveredRow or col != self.hoveredColumn:
            if self.ToolTip is not None:
                self.SetToolTip(None)
            else:
                self.hoveredRow = row
                self.hoveredColumn = col
                if row != -1 and row not in self.blanks and col != -1 and col < len(self.DEFAULT_COLS):
                    mod = self.mods[self.GetItemData(row)]
                    if self.DEFAULT_COLS[col] == "Miscellanea":
                        tooltip = self.activeColumns[col].getToolTip(mod)
                        if tooltip is not None:
                            self.SetToolTipString(tooltip)
                        else:
                            self.SetToolTip(None)
                    else:
                        self.SetToolTip(None)
                else:
                    self.SetToolTip(None)
        event.Skip()

    def handleListDrag(self, x, y, data):
        '''
        Handles dragging of items from various pyfa displays which support it

        data is list with two items:
            data[0] is hard-coded str of originating source
            data[1] is typeID or index of data we want to manipulate
        '''

        if data[0] == "fitting":
            self.swapItems(x, y, int(data[1]))
        elif data[0] == "cargo":
            self.swapCargo(x, y, int(data[1]))
        elif data[0] == "market":
            wx.PostEvent(self.mainFrame, gui.marketBrowser.ItemSelected(itemID=int(data[1])))

    def handleDrag(self, type, fitID):
        #Those are drags coming from pyfa sources, NOT builtin wx drags
        if type == "fit":
            wx.PostEvent(self.mainFrame, gui.shipBrowser.FitSelected(fitID=fitID))

    def Destroy(self):
        self.parent.Unbind(gui.chromeTabs.EVT_NOTEBOOK_PAGE_CHANGED, handler=self.pageChanged)
        self.mainFrame.Unbind(GE.FIT_CHANGED, handler=self.fitChanged)
        self.mainFrame.Unbind(gui.shipBrowser.EVT_FIT_RENAMED, handler=self.fitRenamed)
        self.mainFrame.Unbind(gui.shipBrowser.EVT_FIT_REMOVED, handler=self.fitRemoved)
        self.mainFrame.Unbind(gui.marketBrowser.ITEM_SELECTED, handler=self.appendItem)

        d.Display.Destroy(self)

    def pageChanged(self, event):
        if self.parent.IsActive(self):
            fitID = self.getActiveFit()
            sFit = service.Fit.getInstance()
            sFit.switchFit(fitID)
            wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=fitID))

        event.Skip()

    def getActiveFit(self):
        return self.activeFitID

    def startDrag(self, event):
        row = event.GetIndex()

        if row != -1 and row not in self.blanks:
            data = wx.PyTextDataObject()
            data.SetText("fitting:"+str(self.mods[row].position))

            dropSource = wx.DropSource(self)
            dropSource.SetData(data)
            res = dropSource.DoDragDrop()

    def getSelectedMods(self):
        sel = []
        row = self.GetFirstSelected()
        while row != -1:
            sel.append(self.mods[self.GetItemData(row)])
            row = self.GetNextSelected(row)

        return sel

    def kbEvent(self,event):
        keycode = event.GetKeyCode()
        if keycode == wx.WXK_DELETE or keycode == wx.WXK_NUMPAD_DELETE:
            row = self.GetFirstSelected()
            firstSel = row
            while row != -1:
                if row not in self.blanks:
                    self.removeModule(self.mods[row])
                self.Select(row,0)
                row = self.GetNextSelected(row)

        event.Skip()

    def fitRemoved(self, event):
        '''
        If fit is removed and active, the page is deleted.
        We also refresh the fit of the new current page in case
        delete fit caused change in stats (projected)
        '''
        fitID = event.fitID

        if fitID == self.getActiveFit():
            self.parent.DeletePage(self.parent.GetPageIndex(self))

        try:
            # Sometimes there is no active page after deletion, hence the try block
            cFit = service.Fit.getInstance()
            cFit.refreshFit(self.getActiveFit())
            wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=self.activeFitID))
        except wx._core.PyDeadObjectError:
            pass

        event.Skip()

    def fitRenamed(self, event):
        fitID = event.fitID
        if fitID == self.getActiveFit():
            self.updateTab()

        event.Skip()

    def fitSelected(self, event):
        if self.parent.IsActive(self):
            fitID = event.fitID
            startup = getattr(event, "startup", False)
            self.activeFitID = fitID
            sFit = service.Fit.getInstance()
            self.updateTab()
            if not startup or startup == 2:  # see OpenFitsThread in gui.mainFrame
                self.Show(fitID is not None)
                self.slotsChanged()
                sFit.switchFit(fitID)
                wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=fitID))

        event.Skip()

    def updateTab(self):
        cFit = service.Fit.getInstance()
        fit = cFit.getFit(self.getActiveFit())

        bitmap = bitmapLoader.getImage("race_%s_small" % fit.ship.item.race, "icons")
        text = "%s: %s" % (fit.ship.item.name, fit.name)

        pageIndex = self.parent.GetPageIndex(self)
        if pageIndex is not None:
            self.parent.SetPageTextIcon(pageIndex, text, bitmap)

    def appendItem(self, event):
        if self.parent.IsActive(self):
            itemID = event.itemID
            fitID = self.activeFitID
            if fitID != None:
                cFit = service.Fit.getInstance()
                if cFit.isAmmo(itemID):
                    modules = []
                    sel = self.GetFirstSelected()
                    while sel != -1 and sel not in self.blanks:
                        modules.append(self.mods[self.GetItemData(sel)])
                        sel = self.GetNextSelected(sel)

                    cFit.setAmmo(fitID, itemID, modules)
                    wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=fitID))
                else:
                    populate = cFit.appendModule(fitID, itemID)
                    if populate is not None:
                        self.slotsChanged()
                        wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=fitID))

        event.Skip()

    def removeItem(self, event):
        row, _ = self.HitTest(event.Position)
        if row != -1 and row not in self.blanks:
            col = self.getColumn(event.Position)
            if col != self.getColIndex(State):
                self.removeModule(self.mods[row])
            else:
                if "wxMSW" in wx.PlatformInfo:
                    self.click(event)

    def removeModule(self, module):
        cFit = service.Fit.getInstance()
        fit = cFit.getFit(self.activeFitID)
        populate = cFit.removeModule(self.activeFitID, fit.modules.index(module))

        if populate is not None:
            self.slotsChanged()
            wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=self.activeFitID))

    def swapCargo(self, x, y, srcIdx):
        '''Swap a module from cargo to fitting window'''
        mstate = wx.GetMouseState()

        dstRow, _ = self.HitTest((x, y))
        if dstRow != -1 and dstRow not in self.blanks:
            module = self.mods[dstRow]

            cFit = service.Fit.getInstance()
            cFit.moveCargoToModule(self.mainFrame.getActiveFit(), module.position, srcIdx, mstate.CmdDown() and module.isEmpty)

            wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=self.mainFrame.getActiveFit()))

    def swapItems(self, x, y, srcIdx):
        '''Swap two modules in fitting window'''
        mstate = wx.GetMouseState()
        cFit = service.Fit.getInstance()
        fit = cFit.getFit(self.activeFitID)

        if mstate.CmdDown():
            clone = True
        else:
            clone = False

        dstRow, _ = self.HitTest((x, y))

        if dstRow != -1 and dstRow not in self.blanks:
            mod1 = fit.modules[srcIdx]
            mod2 = self.mods[dstRow]

            # can't swap modules to different racks
            if mod1.slot != mod2.slot:
                return

            if clone and mod2.isEmpty:
                cFit.cloneModule(self.mainFrame.getActiveFit(), mod1.position, mod2.position)
            else:
                cFit.swapModules(self.mainFrame.getActiveFit(), mod1.position, mod2.position)

            wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=self.mainFrame.getActiveFit()))

    def generateMods(self):
        '''
        Generate module list.

        This also injects dummy modules to visually separate racks. These modules are only
        known to the display, and not the backend, so it's safe.
        '''

        cFit = service.Fit.getInstance()
        fit = cFit.getFit(self.activeFitID)

        slotOrder = [Slot.SUBSYSTEM, Slot.HIGH, Slot.MED, Slot.LOW, Slot.RIG]

        if fit is not None:
            self.mods = fit.modules[:]
            self.mods.sort(key=lambda mod: (slotOrder.index(mod.slot), mod.position))

            self.blanks = []   # preliminary markers where blanks will be inserted

            if cFit.serviceFittingOptions["rackSlots"]:
                # flag to know when to add blanks, based on previous slot
                slotDivider = None if cFit.serviceFittingOptions["rackLabels"] else self.mods[0].slot

                # first loop finds where slot dividers must go before modifying self.mods
                for i, mod in enumerate(self.mods):
                    if mod.slot != slotDivider:
                        slotDivider = mod.slot
                        self.blanks.append((i, slotDivider)) # where and what

                # second loop modifies self.mods, rewrites self.blanks to represent actual index of blanks
                for i, (x, slot) in enumerate(self.blanks):
                    self.blanks[i] = x+i # modify blanks with actual index
                    self.mods.insert(x+i, Rack.buildRack(slot))
        else:
            self.mods = None

    def slotsChanged(self):
        self.generateMods()
        self.populate(self.mods)

    def fitChanged(self, event):
        try:
            if self.activeFitID is not None and self.activeFitID == event.fitID:
                self.generateMods()
                if self.GetItemCount() != len(self.mods):
                    # This only happens when turning on/off slot divisions
                    self.populate(self.mods)
                self.refresh(self.mods)

                exportHtml.getInstance().refreshFittingHtml()

            self.Show(self.activeFitID is not None and self.activeFitID == event.fitID)
        except wx._core.PyDeadObjectError:
            pass
        finally:
            event.Skip()

    def scheduleMenu(self, event):
        event.Skip()
        if self.getColumn(event.Position) != self.getColIndex(State):
            wx.CallAfter(self.spawnMenu)

    def spawnMenu(self):
        if self.activeFitID is None:
            return

        sMkt = service.Market.getInstance()
        selection = []
        sel = self.GetFirstSelected()
        contexts = []

        while sel != -1:
            mod = self.mods[self.GetItemData(sel)]
            if not mod.isEmpty:
                srcContext = "fittingModule"
                itemContext = sMkt.getCategoryByItem(mod.item).name
                fullContext = (srcContext, itemContext)
                if not srcContext in tuple(fCtxt[0] for fCtxt in contexts):
                    contexts.append(fullContext)
                if mod.charge is not None:
                    srcContext = "fittingCharge"
                    itemContext = sMkt.getCategoryByItem(mod.charge).name
                    fullContext = (srcContext, itemContext)
                    if not srcContext in tuple(fCtxt[0] for fCtxt in contexts):
                        contexts.append(fullContext)

                selection.append(mod)

            sel = self.GetNextSelected(sel)

        contexts.append(("fittingShip", "Ship"))

        menu = ContextMenu.getMenu(selection, *contexts)
        self.PopupMenu(menu)

    def click(self, event):
        '''
        Handle click event on modules.

        This is only useful for the State column. If multiple items are selected,
        and we have clicked the State column, iterate through the selections and
        change State
        '''
        row, _, col = self.HitTestSubItem(event.Position)

        # only do State column and ignore invalid rows
        if row != -1 and row not in self.blanks and col == self.getColIndex(State):
            sel = []
            curr = self.GetFirstSelected()

            while curr != -1 and row not in self.blanks :
                sel.append(curr)
                curr = self.GetNextSelected(curr)

            if row not in sel:
                mods = [self.mods[self.GetItemData(row)]]
            else:
                mods = self.getSelectedMods()

            sFit = service.Fit.getInstance()
            fitID = self.mainFrame.getActiveFit()
            ctrl = wx.GetMouseState().CmdDown()
            click = "ctrl" if ctrl is True else "right" if event.Button == 3 else "left"
            sFit.toggleModulesState(fitID, self.mods[self.GetItemData(row)], mods, click)
            wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=self.mainFrame.getActiveFit()))
        else:
            event.Skip()

    slotColourMap = {1: wx.Colour(250, 235, 204), # yellow = low slots
                     2: wx.Colour(188,215,241),   # blue   = mid slots
                     3: wx.Colour(235,204,209),   # red    = high slots
                     4: '',
                     5: ''}

    def slotColour(self, slot):
        return self.slotColourMap[slot] or self.GetBackgroundColour()

    def refresh(self, stuff):
        '''
        Displays fitting

        Sends data to d.Display.refresh where the rows and columns are set up, then does a
        bit of post-processing (colors)
        '''
        self.Freeze()
        d.Display.refresh(self, stuff)

        sFit = service.Fit.getInstance()
        fit = sFit.getFit(self.activeFitID)
        slotMap = {}

        # test for too many modules (happens with t3s / CCP change in slot layout)
        for slotType in Slot.getTypes():
            slot = Slot.getValue(slotType)
            slotMap[slot] = fit.getSlotsFree(slot) < 0

        font = (self.GetClassDefaultAttributes()).font
        for i, mod in enumerate(self.mods):
            if slotMap[mod.slot]:
                self.SetItemBackgroundColour(i, wx.Colour(204, 51, 51))
            elif sFit.serviceFittingOptions["colorFitBySlot"] and not isinstance(mod, Rack):
                self.SetItemBackgroundColour(i, self.slotColour(mod.slot))
            else:
                self.SetItemBackgroundColour(i, self.GetBackgroundColour())

            if i in self.blanks and sFit.serviceFittingOptions["rackSlots"] and sFit.serviceFittingOptions["rackLabels"]:
                font.SetWeight(wx.FONTWEIGHT_BOLD)
                self.SetItemFont(i, font)
            else:
                font.SetWeight(wx.FONTWEIGHT_NORMAL)
                self.SetItemFont(i, font)

        self.Thaw()
        self.itemCount = self.GetItemCount()
        self.itemRect = self.GetItemRect(0)

        if 'wxMac' in wx.PlatformInfo:
            try:
                self.MakeSnapshot()
            except:
               pass

    def OnShow(self, event):
        if not event.GetShow():
            try:
                self.MakeSnapshot()
            except:
                pass
        event.Skip()

    def Snapshot(self):
        return self.FVsnapshot

    def MakeSnapshot(self, maxColumns = 1337):

        if self.FVsnapshot:
            del self.FVsnapshot

        tbmp = wx.EmptyBitmap(16,16)
        tdc = wx.MemoryDC()
        tdc.SelectObject(tbmp)
        font = wx.SystemSettings_GetFont(wx.SYS_DEFAULT_GUI_FONT)
        tdc.SetFont(font)

        columnsWidths = []
        for i in xrange(len(self.DEFAULT_COLS)):
            columnsWidths.append(0)

        sFit = service.Fit.getInstance()
        try:
            fit = sFit.getFit(self.activeFitID)
        except:
            return

        if fit is None:
            return

        slotMap = {}
        for slotType in Slot.getTypes():
            slot = Slot.getValue(slotType)
            slotMap[slot] = fit.getSlotsFree(slot) < 0

        padding = 2
        isize = 16
        headerSize = max(isize, tdc.GetTextExtent("W")[0]) + padding * 2

        maxWidth = 0
        maxRowHeight = isize
        rows = 0
        for id,st in enumerate(self.mods):
            for i, col in enumerate(self.activeColumns):
                if i>maxColumns:
                    break
                name = col.getText(st)

                if not isinstance(name, basestring):
                    name = ""

                nx,ny = tdc.GetTextExtent(name)
                imgId = col.getImageId(st)
                cw = 0
                if imgId != -1:
                    cw += isize + padding
                if name != "":
                    cw += nx + 4*padding

                if imgId == -1 and name == "":
                    cw += isize +padding

                maxRowHeight = max(ny, maxRowHeight)
                columnsWidths[i] = max(columnsWidths[i], cw)

            rows += 1

        render = wx.RendererNative.Get()

        #Fix column widths (use biggest between header or items)

        for i, col in enumerate(self.activeColumns):
            if i > maxColumns:
                break

            name = col.columnText
            imgId = col.imageId

            if not isinstance(name, basestring):
                name = ""

            opts = wx.HeaderButtonParams()

            if name != "":
                opts.m_labelText = name

            if imgId != -1:
                opts.m_labelBitmap = wx.EmptyBitmap(isize,isize)

            width = render.DrawHeaderButton(self, tdc, (0, 0, 16, 16),
                                sortArrow = wx.HDR_SORT_ICON_NONE, params = opts)

            columnsWidths[i] = max(columnsWidths[i], width)

        tdc.SelectObject(wx.NullBitmap)


        maxWidth = padding * 2

        for i in xrange(len(self.DEFAULT_COLS)):
            if i > maxColumns:
                break
            maxWidth += columnsWidths[i]


        mdc = wx.MemoryDC()
        mbmp = wx.EmptyBitmap(maxWidth, (maxRowHeight) * rows + padding*4 + headerSize)

        mdc.SelectObject(mbmp)

        mdc.SetBackground(wx.Brush(wx.SystemSettings_GetColour(wx.SYS_COLOUR_WINDOW)))
        mdc.Clear()

        mdc.SetFont(font)
        mdc.SetTextForeground(wx.SystemSettings_GetColour(wx.SYS_COLOUR_WINDOWTEXT))

        cx = padding
        for i, col in enumerate(self.activeColumns):
            if i > maxColumns:
                break

            name = col.columnText
            imgId = col.imageId

            if not isinstance(name, basestring):
                name = ""

            opts = wx.HeaderButtonParams()
            opts.m_labelAlignment = wx.ALIGN_LEFT
            if name != "":
                opts.m_labelText = name

            if imgId != -1:
                bmp = col.bitmap
                opts.m_labelBitmap = bmp

            width = render.DrawHeaderButton (self, mdc, (cx, padding, columnsWidths[i], headerSize), wx.CONTROL_CURRENT,
                                sortArrow = wx.HDR_SORT_ICON_NONE, params = opts)

            cx += columnsWidths[i]

        brush = wx.Brush(wx.Colour(224, 51, 51))
        pen = wx.Pen(wx.Colour(224, 51, 51))

        mdc.SetPen(pen)
        mdc.SetBrush(brush)

        cy = padding*2 + headerSize
        for id,st in enumerate(self.mods):
            cx = padding

            if slotMap[st.slot]:
                mdc.DrawRectangle(cx,cy,maxWidth - cx,maxRowHeight)

            for i, col in enumerate(self.activeColumns):
                if i>maxColumns:
                    break

                name = col.getText(st)
                if not isinstance(name, basestring):
                    name = ""

                imgId = col.getImageId(st)
                tcx = cx

                if imgId != -1:
                    self.imageList.Draw(imgId,mdc,cx,cy,wx.IMAGELIST_DRAW_TRANSPARENT,False)
                    tcx += isize + padding

                if name != "":
                    nx,ny = mdc.GetTextExtent(name)
                    rect = wx.Rect()
                    rect.top = cy
                    rect.left = cx + 2*padding
                    rect.width = nx
                    rect.height = maxRowHeight + padding
                    mdc.DrawLabel(name, rect, wx.ALIGN_CENTER_VERTICAL)
                    tcx += nx + padding

                cx += columnsWidths[i]

            cy += maxRowHeight

        mdc.SelectObject(wx.NullBitmap)

        self.FVsnapshot = mbmp

########NEW FILE########
__FILENAME__ = fleetView
import wx.gizmos
import gui.fleetBrowser
import service
from gui import bitmapLoader

#Tab spawning handler
class FleetSpawner(gui.multiSwitch.TabSpawner):
    def __init__(self, multiSwitch):
        self.multiSwitch = multiSwitch
        mainFrame = gui.mainFrame.MainFrame.getInstance()
        mainFrame.Bind(gui.fleetBrowser.EVT_FLEET_SELECTED, self.fleetSelected)

    def fleetSelected(self, event):
        if self.multiSwitch.GetPageCount() == 0:
            self.multiSwitch.AddPage(wx.Panel(self.multiSwitch, size = (0,0)), "Empty Tab")

        view = FleetView(self.multiSwitch)
        self.multiSwitch.ReplaceActivePage(view)
        view.populate(event.fleetID)
        view.Show()

FleetSpawner.register()

class FleetView(wx.gizmos.TreeListCtrl):
    def __init__(self, parent, size = (0,0)):
        wx.gizmos.TreeListCtrl.__init__(self, parent, size = size)

        self.tabManager = parent

        self.fleetId = None
        self.fleetImg = bitmapLoader.getImage("53_16", "pack")

        self.imageList = wx.ImageList(16, 16)
        self.SetImageList(self.imageList)

        for col in ("", "Fit", "Shiptype", "Character", "Bonusses"):
            self.AddColumn(col)

        self.SetMainColumn(1)
        self.icons = {}
        self.addImage = self.imageList.Add(bitmapLoader.getBitmap("add_small", "icons"))
        for icon in ("fb", "fc", "sb", "sc", "wb", "wc"):
            self.icons[icon] = self.imageList.Add(bitmapLoader.getBitmap("fleet_%s_small" % icon, "icons"))

        self.Bind(wx.EVT_TREE_ITEM_ACTIVATED, self.checkNew)
        self.mainFrame = gui.mainFrame.MainFrame.getInstance()

        self.mainFrame.Bind(gui.fleetBrowser.EVT_FLEET_RENAMED, self.fleetRenamed)
        self.mainFrame.Bind(gui.fleetBrowser.EVT_FLEET_REMOVED, self.fleetRemoved)

    def Destroy(self):
        self.mainFrame.Unbind(gui.fleetBrowser.EVT_FLEET_REMOVED, handler = self.fleetRemoved)
        self.mainFrame.Unbind(gui.fleetBrowser.EVT_FLEET_RENAMED, handler = self.fleetRenamed)
        wx.gizmos.TreeListCtrl.Destroy(self)

    def fleetRenamed(self, event):
        if event.fleetID == self.fleetId:
            sFleet = service.Fleet.getInstance()
            f = sFleet.getFleetByID(event.fleetID)
            self.UpdateTab(f.name, self.fleetImg)

        event.Skip()

    def fleetRemoved(self, event):
        if event.fleetID == self.fleetId:
            self.tabManager.DeletePage(self.tabManager.GetPageIndex(self))

        event.Skip()

    def checkNew(self, event):
        data = self.GetPyData(event.Item)
        if data and isinstance(data, tuple) and data[0] == "add":
            layer = data[1]


    def UpdateTab(self, name, img):
        self.tabManager.SetPageTextIcon(self.tabManager.GetSelection(), name, img)

    def populate(self, fleetID):
        sFleet = service.Fleet.getInstance()
        f = sFleet.getFleetByID(fleetID)
        self.fleetId = fleetID

        self.UpdateTab( f.name, self.fleetImg)
        self.fleet = f
        self.DeleteAllItems()
        root = self.AddRoot("")

        self.setEntry(root, f.leader, "fleet", f)
        for wing in f.wings:
            wingId = self.AppendItem(root, "")
            self.setEntry(wingId, wing.leader, "wing", wing)
            for squad in wing.squads:
                for member in squad.members:
                    memberId = self.AppendItem(wingId, "")
                    self.setEntry(memberId, member, "squad", squad)

            self.addAdder(wingId, "squad")

        self.addAdder(root, "wing")

        self.ExpandAll(root)
        self.SetColumnWidth(0, 16)
        for i in xrange(1, 5):
            self.SetColumnWidth(i, wx.LIST_AUTOSIZE_USEHEADER)
            headerWidth = self.GetColumnWidth(i) + 5
            self.SetColumnWidth(i, wx.LIST_AUTOSIZE)
            baseWidth = self.GetColumnWidth(i)
            if baseWidth < headerWidth:
                self.SetColumnWidth(i, headerWidth)
            else:
                self.SetColumnWidth(i, baseWidth)


    def addAdder(self, treeItemId, layer):
        id = self.AppendItem(treeItemId, "Add new %s" % layer.capitalize())
        self.SetPyData(id, ("add", layer))
        self.SetItemImage(id, self.addImage, 1)

    def setEntry(self, treeItemId, fit, layer, info):
        self.SetPyData(treeItemId, info)
        if fit is None:
            self.SetItemText(treeItemId, "%s Commander" % layer.capitalize(), 1)
        else:
            fleet = self.fleet
            if fit == info.booster:
                self.SetItemImage(treeItemId, self.icons["%sb" % layer[0]], 0)
            elif fit == info.leader:
                self.SetItemImage(treeItemId, self.icons["%sc" % layer[0]], 1)

            self.SetItemText(treeItemId, fit.name, 1)
            self.SetItemText(treeItemId, fit.ship.item.name, 2)
            self.SetItemText(treeItemId, fit.character.name, 3)
            boosts = fleet.store.getBoosts(fit)
            if boosts:
                bonusses = []
                for name, info in boosts.iteritems():
                    bonusses.append("%s: %.2g" % (name, info[0]))

                self.SetItemText(treeItemId, ", ".join(bonusses), 3)

########NEW FILE########
__FILENAME__ = cachingImageList
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import wx
import bitmapLoader

class CachingImageList(wx.ImageList):
    def __init__(self, width, height):
        wx.ImageList.__init__(self, width, height)
        self.map = {}

    def GetImageIndex(self, *loaderArgs):
        id = self.map.get(loaderArgs)
        if id is None:
            bitmap = bitmapLoader.getBitmap(*loaderArgs)
            if bitmap is None:
                return -1
            id = self.map[loaderArgs] = wx.ImageList.Add(self,bitmap)
        return id

########NEW FILE########
__FILENAME__ = cargoView
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import wx
import service
import gui.display as d
import gui.marketBrowser as mb
from gui.builtinViewColumns.state import State
from gui.contextMenu import ContextMenu
import globalEvents as GE

class CargoViewDrop(wx.PyDropTarget):
        def __init__(self, dropFn):
            wx.PyDropTarget.__init__(self)
            self.dropFn = dropFn
            # this is really transferring an EVE itemID
            self.dropData = wx.PyTextDataObject()
            self.SetDataObject(self.dropData)

        def OnData(self, x, y, t):
            if self.GetData():
                data = self.dropData.GetText().split(':')
                self.dropFn(x, y, data)
            return t

#  @todo: Was copied form another class and modified. Look through entire file, refine
class CargoView(d.Display):
    DEFAULT_COLS = ["Base Icon",
                    "Base Name",
                    "attr:volume"]

    def __init__(self, parent):
        d.Display.__init__(self, parent, style=wx.LC_SINGLE_SEL | wx.BORDER_NONE)

        self.lastFitId = None

        self.mainFrame.Bind(GE.FIT_CHANGED, self.fitChanged)
        self.Bind(wx.EVT_LEFT_DCLICK, self.removeItem)
        self.Bind(wx.EVT_KEY_UP, self.kbEvent)

        self.SetDropTarget(CargoViewDrop(self.handleListDrag))
        self.Bind(wx.EVT_LIST_BEGIN_DRAG, self.startDrag)

        if "__WXGTK__" in  wx.PlatformInfo:
            self.Bind(wx.EVT_RIGHT_UP, self.scheduleMenu)
        else:
            self.Bind(wx.EVT_RIGHT_DOWN, self.scheduleMenu)

    def handleListDrag(self, x, y, data):
        '''
        Handles dragging of items from various pyfa displays which support it

        data is list with two indices:
            data[0] is hard-coded str of originating source
            data[1] is typeID or index of data we want to manipulate
        '''

        if data[0] == "fitting":
            self.swapModule(x, y, int(data[1]))
        elif data[0] == "market":
            sFit = service.Fit.getInstance()
            sFit.addCargo(self.mainFrame.getActiveFit(), int(data[1]), 1)
            wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=self.mainFrame.getActiveFit()))

    def startDrag(self, event):
        row = event.GetIndex()

        if row != -1:
            data = wx.PyTextDataObject()
            data.SetText("cargo:"+str(row))

            dropSource = wx.DropSource(self)
            dropSource.SetData(data)
            res = dropSource.DoDragDrop()

    def kbEvent(self,event):
        keycode = event.GetKeyCode()
        if keycode == wx.WXK_DELETE or keycode == wx.WXK_NUMPAD_DELETE:
            fitID = self.mainFrame.getActiveFit()
            cFit = service.Fit.getInstance()
            row = self.GetFirstSelected()
            if row != -1:
                cFit.removeCargo(fitID, self.GetItemData(row))
                wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=fitID))
        event.Skip()

    def swapModule(self, x, y, modIdx):
        '''Swap a module from fitting window with cargo'''
        sFit = service.Fit.getInstance()
        fit = sFit.getFit(self.mainFrame.getActiveFit())
        dstRow, _ = self.HitTest((x, y))
        mstate = wx.GetMouseState()

        # Gather module information to get position
        module = fit.modules[modIdx]

        if dstRow != -1: # we're swapping with cargo
            if mstate.CmdDown(): # if copying, append to cargo
                sFit.addCargo(self.mainFrame.getActiveFit(), module.item.ID)
            else: # else, move / swap
                sFit.moveCargoToModule(self.mainFrame.getActiveFit(), module.position, dstRow)
        else: # dragging to blank spot, append
            sFit.addCargo(self.mainFrame.getActiveFit(), module.item.ID)

            if not mstate.CmdDown(): # if not copying, remove module
               sFit.removeModule(self.mainFrame.getActiveFit(), module.position)

        wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=self.mainFrame.getActiveFit()))

    def fitChanged(self, event):
        #Clear list and get out if current fitId is None
        if event.fitID is None and self.lastFitId is not None:
            self.DeleteAllItems()
            self.lastFitId = None
            event.Skip()
            return

        cFit = service.Fit.getInstance()
        fit = cFit.getFit(event.fitID)

        self.original = fit.cargo if fit is not None else None
        self.cargo = stuff = fit.cargo if fit is not None else None
        if stuff is not None: stuff.sort(key=lambda cargo: cargo.itemID)

        if event.fitID != self.lastFitId:
            self.lastFitId = event.fitID

            item = self.GetNextItem(-1, wx.LIST_NEXT_ALL, wx.LIST_STATE_DONTCARE)

            if item != -1:
                self.EnsureVisible(item)

            self.deselectItems()

        self.populate(stuff)
        self.refresh(stuff)
        event.Skip()

    def removeItem(self, event):
        row, _ = self.HitTest(event.Position)
        if row != -1:
            col = self.getColumn(event.Position)
            if col != self.getColIndex(State):
                fitID = self.mainFrame.getActiveFit()
                cFit = service.Fit.getInstance()
                cargo = self.cargo[self.GetItemData(row)]
                cFit.removeCargo(fitID, self.original.index(cargo))
                wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=fitID))

    def scheduleMenu(self, event):
        event.Skip()
        if self.getColumn(event.Position) != self.getColIndex(State):
            wx.CallAfter(self.spawnMenu)

    def spawnMenu(self):
        sel = self.GetFirstSelected()
        if sel != -1:
            cFit = service.Fit.getInstance()
            fit = cFit.getFit(self.mainFrame.getActiveFit())
            cargo = fit.cargo[sel]

            sMkt = service.Market.getInstance()
            sourceContext = "cargoItem"
            itemContext = sMkt.getCategoryByItem(cargo.item).name

            menu = ContextMenu.getMenu((cargo,), (sourceContext, itemContext))
            self.PopupMenu(menu)

########NEW FILE########
__FILENAME__ = characterEditor
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import wx
import bitmapLoader
import gui.mainFrame
import wx.lib.newevent
import wx.gizmos
from gui import bitmapLoader
import service
import gui.display as d
from gui.contextMenu import ContextMenu
from wx.lib.buttons import GenBitmapButton
import sys
import gui.globalEvents as GE

class CharacterEditor(wx.Frame):
    def __init__(self, parent):
        wx.Frame.__init__ (self, parent, id=wx.ID_ANY, title=u"pyfa: Character Editor", pos=wx.DefaultPosition,
                            size=wx.Size(641, 600), style=wx.DEFAULT_FRAME_STYLE|wx.FRAME_FLOAT_ON_PARENT|wx.TAB_TRAVERSAL)

        i = wx.IconFromBitmap(bitmapLoader.getBitmap("character_small", "icons"))
        self.SetIcon(i)

        self.disableWin=  wx.WindowDisabler(self)
        self.SetSizeHintsSz(wx.Size(640, 600), wx.DefaultSize)
        self.SetBackgroundColour( wx.SystemSettings.GetColour( wx.SYS_COLOUR_BTNFACE ) )

        mainSizer = wx.BoxSizer(wx.VERTICAL)
        self.navSizer = wx.BoxSizer(wx.HORIZONTAL)

        cChar = service.Character.getInstance()
        charList = cChar.getCharacterList()
        charList.sort(key=lambda t: t[1])

        self.btnSave = wx.Button(self, wx.ID_SAVE)
        self.btnSave.Hide()
        self.btnSave.Bind(wx.EVT_BUTTON, self.processRename)

        self.characterRename = wx.TextCtrl(self, wx.ID_ANY, style=wx.TE_PROCESS_ENTER)
        self.characterRename.Hide()
        self.characterRename.Bind(wx.EVT_TEXT_ENTER, self.processRename)

        self.skillTreeChoice = wx.Choice(self, wx.ID_ANY, style=0)

        for id, name, active in charList:
            i = self.skillTreeChoice.Append(name, id)
            if active:
                self.skillTreeChoice.SetSelection(i)

        self.navSizer.Add(self.skillTreeChoice, 1, wx.ALL | wx.EXPAND, 5)

        buttons = (("new", wx.ART_NEW),
                   ("rename", bitmapLoader.getBitmap("rename", "icons")),
                   ("copy", wx.ART_COPY),
                   ("delete", wx.ART_DELETE))

        size = None
        for name, art in buttons:
            bitmap = wx.ArtProvider.GetBitmap(art, wx.ART_BUTTON) if name != "rename" else art
            btn = wx.BitmapButton(self, wx.ID_ANY, bitmap)
            if size is None:
                size = btn.GetSize()

            btn.SetMinSize(size)
            btn.SetMaxSize(size)

            btn.SetToolTipString("%s character" % name.capitalize())
            btn.Bind(wx.EVT_BUTTON, getattr(self, name))
            setattr(self, "btn%s" % name.capitalize(), btn)
            self.navSizer.Add(btn, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 2)


        mainSizer.Add(self.navSizer, 0, wx.ALL | wx.EXPAND, 5)

        self.viewsNBContainer = wx.Notebook(self, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, 0)

        self.sview = SkillTreeView(self.viewsNBContainer)
        self.iview = ImplantsTreeView(self.viewsNBContainer)
        #=======================================================================
        # RC2
        self.iview.Show(False)
        #=======================================================================
        self.aview = APIView(self.viewsNBContainer)

        self.viewsNBContainer.AddPage(self.sview, "Skills")

        #=======================================================================
        # Disabled for RC2
        # self.viewsNBContainer.AddPage(self.iview, "Implants")
        #=======================================================================
        self.viewsNBContainer.AddPage(self.aview, "API")

        mainSizer.Add(self.viewsNBContainer, 1, wx.EXPAND | wx.ALL, 5)

        bSizerButtons = wx.BoxSizer(wx.HORIZONTAL)

        self.btnOK = wx.Button(self, wx.ID_OK)
        bSizerButtons.Add(self.btnOK, 0, wx.ALL, 5)
        self.btnOK.Bind(wx.EVT_BUTTON, self.editingFinished)

        mainSizer.Add(bSizerButtons, 0, wx.ALIGN_RIGHT, 5)


        self.SetSizer(mainSizer)
        self.Layout()

        self.Centre(wx.BOTH)

        charID = self.getActiveCharacter()
        if cChar.getCharName(charID) in ("All 0", "All 5"):
            self.restrict()

        self.registerEvents()

        self.mainFrame = gui.mainFrame.MainFrame.getInstance()

    def editingFinished(self, event):
        del self.disableWin
        wx.PostEvent(self.mainFrame, GE.CharListUpdated())
        self.Destroy()

    def registerEvents(self):
        self.Bind(wx.EVT_CLOSE, self.closeEvent)
        self.skillTreeChoice.Bind(wx.EVT_CHOICE, self.charChanged)

    def closeEvent(self, event):
        del self.disableWin
        wx.PostEvent(self.mainFrame, GE.CharListUpdated())
        self.Destroy()

    def restrict(self):
        self.btnRename.Enable(False)
        self.btnDelete.Enable(False)
        self.aview.inputID.Enable(False)
        self.aview.inputKey.Enable(False)
        self.aview.charChoice.Enable(False)
        self.aview.btnFetchCharList.Enable(False)
        self.aview.btnFetchSkills.Enable(False)
        self.aview.stStatus.SetLabel("")
        self.aview.Layout()

    def unrestrict(self):
        self.btnRename.Enable(True)
        self.btnDelete.Enable(True)
        self.aview.inputID.Enable(True)
        self.aview.inputKey.Enable(True)
        self.aview.btnFetchCharList.Enable(True)
        self.aview.btnFetchSkills.Enable(True)
        self.aview.stStatus.SetLabel("")
        self.aview.Layout()

    def charChanged(self, event):
        self.sview.skillTreeListCtrl.DeleteChildren(self.sview.root)
        self.sview.populateSkillTree()
        cChar = service.Character.getInstance()
        charID = self.getActiveCharacter()
        if cChar.getCharName(charID) in ("All 0", "All 5"):
            self.restrict()
        else:
            self.unrestrict()

        wx.PostEvent(self, GE.CharChanged())
        if event is not None:
            event.Skip()

    def getActiveCharacter(self):
        selection = self.skillTreeChoice.GetCurrentSelection()
        return self.skillTreeChoice.GetClientData(selection) if selection is not None else None

    def new(self, event):
        cChar = service.Character.getInstance()
        charID = cChar.new()
        id = self.skillTreeChoice.Append(cChar.getCharName(charID), charID)
        self.skillTreeChoice.SetSelection(id)
        self.unrestrict()
        self.btnSave.SetLabel("Create")
        self.rename(None)
        self.charChanged(None)

    def rename(self, event):
        if event is not None:
            self.btnSave.SetLabel("Rename")
        self.skillTreeChoice.Hide()
        self.characterRename.Show()
        self.navSizer.Replace(self.skillTreeChoice, self.characterRename)
        self.characterRename.SetFocus()
        for btn in (self.btnNew, self.btnCopy, self.btnRename, self.btnDelete):
            btn.Hide()
            self.navSizer.Remove(btn)

        self.btnSave.Show()
        self.navSizer.Add(self.btnSave, 0, wx.ALIGN_CENTER)
        self.navSizer.Layout()

        cChar = service.Character.getInstance()
        currName = cChar.getCharName(self.getActiveCharacter())
        self.characterRename.SetValue(currName)
        self.characterRename.SetSelection(0, len(currName))

    def processRename(self, event):
        cChar = service.Character.getInstance()
        newName = self.characterRename.GetLineText(0)

        if newName == "All 0" or newName == "All 5":
            newName = newName + " bases are belong to us"

        charID = self.getActiveCharacter()
        cChar.rename(charID, newName)

        self.skillTreeChoice.Show()
        self.characterRename.Hide()
        self.navSizer.Replace(self.characterRename, self.skillTreeChoice)
        for btn in (self.btnNew, self.btnCopy, self.btnRename, self.btnDelete):
            btn.Show()
            self.navSizer.Add(btn, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 2)

        self.navSizer.Remove(self.btnSave)
        self.btnSave.Hide()
        self.navSizer.Layout()
        selection = self.skillTreeChoice.GetCurrentSelection()
        self.skillTreeChoice.Delete(selection)
        self.skillTreeChoice.Insert(newName, selection, charID)
        self.skillTreeChoice.SetSelection(selection)

    def copy(self, event):
        cChar = service.Character.getInstance()
        charID = cChar.copy(self.getActiveCharacter())
        id = self.skillTreeChoice.Append(cChar.getCharName(charID), charID)
        self.skillTreeChoice.SetSelection(id)
        self.unrestrict()
        self.btnSave.SetLabel("Copy")
        self.rename(None)
        wx.PostEvent(self, GE.CharChanged())

    def delete(self, event):
        cChar = service.Character.getInstance()
        cChar.delete(self.getActiveCharacter())
        sel = self.skillTreeChoice.GetSelection()
        self.skillTreeChoice.Delete(sel)
        self.skillTreeChoice.SetSelection(sel - 1)
        newSelection = self.getActiveCharacter()
        if cChar.getCharName(newSelection) in ("All 0", "All 5"):
            self.restrict()

        wx.PostEvent(self, GE.CharChanged())

    def Destroy(self):
        cFit = service.Fit.getInstance()
        fitID = self.mainFrame.getActiveFit()
        if fitID is not None:
            cFit.clearFit(fitID)
            wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=fitID))

        wx.Frame.Destroy(self)

class SkillTreeView (wx.Panel):
    def __init__(self, parent):
        wx.Panel.__init__ (self, parent, id=wx.ID_ANY, pos=wx.DefaultPosition, size=wx.Size(500, 300), style=wx.TAB_TRAVERSAL)

        pmainSizer = wx.BoxSizer(wx.VERTICAL)

        tree = self.skillTreeListCtrl = wx.gizmos.TreeListCtrl(self, wx.ID_ANY, style=wx.TR_DEFAULT_STYLE | wx.TR_HIDE_ROOT)
        pmainSizer.Add(tree, 1, wx.EXPAND | wx.ALL, 5)


        self.imageList = wx.ImageList(16, 16)
        tree.SetImageList(self.imageList)
        self.skillBookImageId = self.imageList.Add(bitmapLoader.getBitmap("skill_small", "icons"))

        tree.AddColumn("Skill")
        tree.AddColumn("Level")
        tree.SetMainColumn(0)

        self.root = tree.AddRoot("Skills")
        tree.SetItemText(self.root, "Levels", 1)

        tree.SetColumnWidth(0, 500)

        self.populateSkillTree()

        tree.Bind(wx.EVT_TREE_ITEM_EXPANDING, self.expandLookup)
        tree.Bind(wx.EVT_TREE_ITEM_RIGHT_CLICK, self.scheduleMenu)

        srcContext = "skillItem"
        itemContext = "Skill"
        context = (srcContext, itemContext)
        self.statsMenu = ContextMenu.getMenu(None, context)
        self.levelChangeMenu = ContextMenu.getMenu(None, context) or wx.Menu()
        self.levelChangeMenu.AppendSeparator()
        self.levelIds = {}

        idUnlearned = wx.NewId()
        self.levelIds[idUnlearned] = "Not learned"
        self.levelChangeMenu.Append(idUnlearned, "Unlearn")

        for level in xrange(6):
            id = wx.NewId()
            self.levelIds[id] = level
            self.levelChangeMenu.Append(id, "Level %d" % level)

        self.levelChangeMenu.Bind(wx.EVT_MENU, self.changeLevel)
        self.SetSizer(pmainSizer)

        self.Layout()

    def populateSkillTree(self):
        cChar = service.Character.getInstance()
        groups = cChar.getSkillGroups()
        imageId = self.skillBookImageId
        root = self.root
        tree = self.skillTreeListCtrl

        for id, name in groups:
            childId = tree.AppendItem(root, name, imageId)
            tree.SetPyData(childId, id)
            tree.AppendItem(childId, "dummy")

        tree.SortChildren(root)

    def expandLookup(self, event):
        root = event.Item
        tree = self.skillTreeListCtrl
        child, cookie = tree.GetFirstChild(root)
        if tree.GetItemText(child) == "dummy":
            tree.Delete(child)

            #Get the real intrestin' stuff
            cChar = service.Character.getInstance()
            char = self.Parent.Parent.getActiveCharacter()
            for id, name in cChar.getSkills(tree.GetPyData(root)):
                iconId = self.skillBookImageId
                childId = tree.AppendItem(root, name, iconId, data=wx.TreeItemData(id))
                level = cChar.getSkillLevel(char, id)
                tree.SetItemText(childId, "Level %d" % level if isinstance(level, int) else level, 1)

            tree.SortChildren(root)

    def scheduleMenu(self, event):
        event.Skip()
        wx.CallAfter(self.spawnMenu, event.Item)

    def spawnMenu(self, item):
        self.skillTreeListCtrl.SelectItem(item)
        if self.skillTreeListCtrl.GetChildrenCount(item) > 0:
            return

        cChar = service.Character.getInstance()
        charID = self.Parent.Parent.getActiveCharacter()
        cMarket = service.Market.getInstance()
        if cChar.getCharName(charID) not in ("All 0", "All 5"):
            self.levelChangeMenu.selection = cMarket.getItem(self.skillTreeListCtrl.GetPyData(item))
            self.PopupMenu(self.levelChangeMenu)
        else:
            self.statsMenu.selection = cMarket.getItem(self.skillTreeListCtrl.GetPyData(item))
            self.PopupMenu(self.statsMenu)

    def changeLevel(self, event):
        level = self.levelIds.get(event.Id)
        if level is not None:
            cChar = service.Character.getInstance()
            charID = self.Parent.Parent.getActiveCharacter()
            selection = self.skillTreeListCtrl.GetSelection()
            skillID = self.skillTreeListCtrl.GetPyData(selection)

            self.skillTreeListCtrl.SetItemText(selection, "Level %d" % level if isinstance(level, int) else level, 1)
            cChar.changeLevel(charID, skillID, level)

        event.Skip()


class ImplantsTreeView (wx.Panel):
    def addMarketViewImage(self, iconFile):
        if iconFile is None:
            return -1
        bitmap = bitmapLoader.getBitmap(iconFile, "pack")
        if bitmap is None:
            return -1
        else:
            return self.availableImplantsImageList.Add(bitmap)

    def __init__(self, parent):
        wx.Panel.__init__ (self, parent, id=wx.ID_ANY, pos=wx.DefaultPosition, size=wx.Size(500, 300), style=wx.TAB_TRAVERSAL)

        pmainSizer = wx.BoxSizer(wx.HORIZONTAL)

        availableSizer = wx.BoxSizer(wx.VERTICAL)
        pmainSizer.Add(availableSizer, 1, wx.ALL | wx.EXPAND, 5)

        self.availableImplantsSearch = wx.SearchCtrl(self, wx.ID_ANY, style=wx.TE_PROCESS_ENTER)
        self.availableImplantsSearch.ShowCancelButton(True)
        availableSizer.Add(self.availableImplantsSearch, 0, wx.BOTTOM | wx.EXPAND, 2)

        self.availableImplantsTree = wx.TreeCtrl(self, wx.ID_ANY, style=wx.TR_DEFAULT_STYLE | wx.TR_HIDE_ROOT)
        root = self.availableRoot = self.availableImplantsTree.AddRoot("Available")
        self.availableImplantsImageList = wx.ImageList(16, 16)
        self.availableImplantsTree.SetImageList(self.availableImplantsImageList)

        availableSizer.Add(self.availableImplantsTree, 1, wx.EXPAND)

        buttonSizer = wx.BoxSizer(wx.VERTICAL)
        pmainSizer.Add(buttonSizer, 0, wx.TOP, 5)

        self.btnAdd = GenBitmapButton(self, wx.ID_ADD, bitmapLoader.getBitmap("fit_add_small", "icons"), style = wx.BORDER_NONE)
        buttonSizer.Add(self.btnAdd, 0)
        self.btnRemove = GenBitmapButton(self, wx.ID_REMOVE, bitmapLoader.getBitmap("fit_delete_small", "icons"), style = wx.BORDER_NONE)
        buttonSizer.Add(self.btnRemove, 0)

        self.pluggedImplantsTree = AvailableImplantsView(self, style=wx.LC_SINGLE_SEL)

        pmainSizer.Add(self.pluggedImplantsTree, 1, wx.ALL | wx.EXPAND, 5)

        self.SetSizer(pmainSizer)

        # Populate the market tree
        sMkt = service.Market.getInstance()
        for mktGrp in sMkt.getImplantTree():
            iconId = self.addMarketViewImage(sMkt.getIconByMarketGroup(mktGrp))
            childId = self.availableImplantsTree.AppendItem(root, mktGrp.name, iconId, data=wx.TreeItemData(mktGrp.ID))
            if sMkt.marketGroupHasTypesCheck(mktGrp) is False:
                self.availableImplantsTree.AppendItem(childId, "dummy")

        self.availableImplantsTree.SortChildren(self.availableRoot)

        #Bind the event to replace dummies by real data
        self.availableImplantsTree.Bind(wx.EVT_TREE_ITEM_EXPANDING, self.expandLookup)

        #Bind add & remove buttons
        self.btnAdd.Bind(wx.EVT_BUTTON, self.addImplant)
        self.btnRemove.Bind(wx.EVT_BUTTON, self.removeImplant)

        #Bind the change of a character*
        self.Parent.Parent.Bind(GE.CHAR_CHANGED, self.charChanged)
        self.Enable(False)
        self.Layout()

    def update(self, implants):
        self.implants = implants[:]
        self.implants.sort(key=lambda i: int(i.getModifiedItemAttr("implantness")))
        self.pluggedImplantsTree.update(self.implants)

    def charChanged(self, event):
        cChar = service.Character.getInstance()
        charID = self.Parent.Parent.getActiveCharacter()
        name = cChar.getCharName(charID)
        if name == "All 0" or name == "All 5":
            self.Enable(False)
        else:
            self.Enable(True)

        self.update(cChar.getImplants(charID))
        event.Skip()

    def expandLookup(self, event):
        tree = self.availableImplantsTree
        root = event.Item
        child, cookie = tree.GetFirstChild(root)
        text = tree.GetItemText(child)
        if text == "dummy" or text == "itemdummy":
            cMarket = service.Market.getInstance()
            #A DUMMY! Keeeel!!! EBUL DUMMY MUST DIAF!
            tree.Delete(child)

        if text == "dummy":
            #Add 'real stoof!' instead
            for id, name, iconFile, more in cMarket.getChildren(tree.GetPyData(root)):
                iconId = self.addMarketViewImage(iconFile)
                childId = tree.AppendItem(root, name, iconId, data=wx.TreeItemData(id))
                if more:
                    tree.AppendItem(childId, "dummy")
                else:
                    tree.AppendItem(childId, "itemdummy")

        if text == "itemdummy":
            cMarket = service.Market.getInstance()
            data, usedMetas = cMarket.getVariations(tree.GetPyData(root))
            for item in data:
                id = item.ID
                name = item.name
                iconFile = item.icon.iconFile
                iconId = self.addMarketViewImage(iconFile)
                tree.AppendItem(root, name, iconId, data=wx.TreeItemData(id))

        tree.SortChildren(root)

    def addImplant(self, event):
        root = self.availableImplantsTree.GetSelection()

        if not root.IsOk():
            return

        nchilds = self.availableImplantsTree.GetChildrenCount(root)
        cChar = service.Character.getInstance()
        charID = self.Parent.Parent.getActiveCharacter()
        if nchilds == 0:
            itemID = self.availableImplantsTree.GetPyData(root)
            cChar.addImplant(charID, itemID)
            self.update(cChar.getImplants(charID))

    def removeImplant(self, event):
        pos = self.pluggedImplantsTree.GetFirstSelected()
        if pos != -1:
            cChar = service.Character.getInstance()
            charID = self.Parent.Parent.getActiveCharacter()
            cChar.removeImplant(charID, self.implants[pos].slot)
            self.update(cChar.getImplants(charID))

class AvailableImplantsView(d.Display):
    DEFAULT_COLS = ["Base Name",
                    "attr:implantness"]

    def __init__(self, parent, style):
        d.Display.__init__(self, parent, style=style)

class APIView (wx.Panel):
    def __init__(self, parent):
        wx.Panel.__init__ (self, parent, id=wx.ID_ANY, pos=wx.DefaultPosition, size=wx.Size(500, 300), style=wx.TAB_TRAVERSAL)
        self.Parent.Parent.Bind(GE.CHAR_CHANGED, self.charChanged)

        self.apiUrlCreatePredefined = u"https://community.eveonline.com/support/api-key/CreatePredefined?accessMask=8"
        self.apiUrlKeyList = u"https://community.eveonline.com/support/api-key/"

        pmainSizer = wx.BoxSizer(wx.VERTICAL)

        fgSizerInput = wx.FlexGridSizer(3, 2, 0, 0)
        fgSizerInput.AddGrowableCol(1)
        fgSizerInput.SetFlexibleDirection(wx.BOTH)
        fgSizerInput.SetNonFlexibleGrowMode(wx.FLEX_GROWMODE_SPECIFIED)

        self.m_staticIDText = wx.StaticText(self, wx.ID_ANY, u"keyID:", wx.DefaultPosition, wx.DefaultSize, 0)
        self.m_staticIDText.Wrap(-1)
        fgSizerInput.Add(self.m_staticIDText, 0, wx.ALL | wx.ALIGN_RIGHT | wx.ALIGN_CENTER_VERTICAL, 5)

        self.inputID = wx.TextCtrl(self, wx.ID_ANY, wx.EmptyString, wx.DefaultPosition, wx.DefaultSize, 0)
        fgSizerInput.Add(self.inputID, 1, wx.ALL | wx.EXPAND, 5)

        self.m_staticKeyText = wx.StaticText(self, wx.ID_ANY, u"vCode:", wx.DefaultPosition, wx.DefaultSize, 0)
        self.m_staticKeyText.Wrap(-1)
        fgSizerInput.Add(self.m_staticKeyText, 0, wx.ALL | wx.ALIGN_RIGHT | wx.ALIGN_CENTER_VERTICAL, 5)

        self.inputKey = wx.TextCtrl(self, wx.ID_ANY, wx.EmptyString, wx.DefaultPosition, wx.DefaultSize, 0)
        fgSizerInput.Add(self.inputKey, 0, wx.ALL | wx.EXPAND, 5)

        self.m_staticCharText = wx.StaticText(self, wx.ID_ANY, u"Character:", wx.DefaultPosition, wx.DefaultSize, 0)
        self.m_staticCharText.Wrap(-1)
        fgSizerInput.Add(self.m_staticCharText, 0, wx.ALL | wx.ALIGN_RIGHT | wx.ALIGN_CENTER_VERTICAL, 5)

        self.charChoice = wx.Choice(self, wx.ID_ANY, style=0)
        self.charChoice.Append("No Selection", 0)
        fgSizerInput.Add(self.charChoice, 1, wx.ALL | wx.EXPAND, 5)

        self.charChoice.Enable(False)

        pmainSizer.Add(fgSizerInput, 0, wx.EXPAND, 5)

        btnSizer = wx.BoxSizer( wx.HORIZONTAL )
        btnSizer.AddStretchSpacer()

        self.btnFetchCharList = wx.Button(self, wx.ID_ANY, u"Get Characters")
        btnSizer.Add(self.btnFetchCharList, 0, wx.ALL, 2)
        self.btnFetchCharList.Bind(wx.EVT_BUTTON, self.fetchCharList)

        self.btnFetchSkills =  wx.Button(self, wx.ID_ANY, u"Fetch Skills")
        btnSizer.Add(self.btnFetchSkills,  0, wx.ALL, 2)
        self.btnFetchSkills.Bind(wx.EVT_BUTTON, self.fetchSkills)
        self.btnFetchSkills.Enable(False)

        btnSizer.AddStretchSpacer()
        pmainSizer.Add(btnSizer, 0, wx.EXPAND, 5)

        self.stStatus = wx.StaticText(self,  wx.ID_ANY, wx.EmptyString)
        pmainSizer.Add(self.stStatus, 0, wx.ALL, 5)

        pmainSizer.AddStretchSpacer()
        self.stAPITip = wx.StaticText( self, wx.ID_ANY, u"You can create a pre-defined key here (only CharacterSheet is required):", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.stAPITip.Wrap( -1 )

        pmainSizer.Add( self.stAPITip, 0, wx.ALL, 2 )

        self.hlEveAPI = wx.HyperlinkCtrl( self, wx.ID_ANY, self.apiUrlCreatePredefined, self.apiUrlCreatePredefined, wx.DefaultPosition, wx.DefaultSize, wx.HL_DEFAULT_STYLE )
        pmainSizer.Add( self.hlEveAPI, 0, wx.ALL, 2 )

        self.stAPITip2 = wx.StaticText( self, wx.ID_ANY, u"Or, you can choose an existing key from:", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.stAPITip2.Wrap( -1 )
        pmainSizer.Add( self.stAPITip2, 0, wx.ALL, 2 )

        self.hlEveAPI2 = wx.HyperlinkCtrl( self, wx.ID_ANY, self.apiUrlKeyList, self.apiUrlKeyList, wx.DefaultPosition, wx.DefaultSize, wx.HL_DEFAULT_STYLE )
        pmainSizer.Add( self.hlEveAPI2, 0, wx.ALL, 2 )

        self.SetSizer(pmainSizer)
        self.Layout()
        self.charChanged(None)

    def charChanged(self, event):
        cChar = service.Character.getInstance()
        ID, key, char, chars = cChar.getApiDetails(self.Parent.Parent.getActiveCharacter())
        self.inputID.SetValue(str(ID))
        self.inputKey.SetValue(key)

        self.charChoice.Clear()

        if chars:
            for charName in chars:
                i = self.charChoice.Append(charName)
            self.charChoice.SetStringSelection(char)
            self.charChoice.Enable(True)
            self.btnFetchSkills.Enable(True)
        else:
            self.charChoice.Append("No characters...", 0)
            self.charChoice.SetSelection(0)
            self.charChoice.Enable(False)
            self.btnFetchSkills.Enable(False)


        if event is not None:
            event.Skip()

    def fetchCharList(self, event):
        self.stStatus.SetLabel("")
        if self.inputID.GetLineText(0) == "" or self.inputKey.GetLineText(0) == "":
            self.stStatus.SetLabel("Invalid keyID or vCode!")
            return

        cChar = service.Character.getInstance()
        list = cChar.charList(self.Parent.Parent.getActiveCharacter(), self.inputID.GetLineText(0), self.inputKey.GetLineText(0))

        if not list:
            self.stStatus.SetLabel("Unable to fetch characters list from EVE API!")
            return

        self.charChoice.Clear()
        for charName in list:
            i = self.charChoice.Append(charName)

        self.btnFetchSkills.Enable(True)
        self.charChoice.Enable(True)

        self.Layout()

        self.charChoice.SetSelection(0)

    def fetchSkills(self, event):
        charName = self.charChoice.GetString(self.charChoice.GetSelection())
        if charName:
            try:
                cChar = service.Character.getInstance()
                cChar.apiFetch(self.Parent.Parent.getActiveCharacter(), charName)
                self.stStatus.SetLabel("Successfully fetched %s\'s skills from EVE API." % charName)
            except:
                self.stStatus.SetLabel("Unable to retrieve %s\'s skills!" % charName)
########NEW FILE########
__FILENAME__ = characterSelection
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import wx
import service
from gui import characterEditor as ce
from gui import bitmapLoader
import gui.globalEvents as GE
import gui.mainFrame

class CharacterSelection(wx.Panel):
    def __init__(self, parent):
        self.mainFrame = gui.mainFrame.MainFrame.getInstance()

        wx.Panel.__init__(self, parent)
        mainSizer = wx.BoxSizer(wx.HORIZONTAL)
        self.SetSizer(mainSizer)

        mainSizer.Add(wx.StaticText(self, wx.ID_ANY, "Character: "), 0, wx.CENTER | wx.TOP | wx.RIGHT | wx.LEFT, 3)

        self.charChoice = wx.Choice(self)
        mainSizer.Add(self.charChoice, 1, wx.ALIGN_CENTER_VERTICAL | wx.TOP | wx.RIGHT | wx.LEFT, 3)

        self.refreshCharacterList()

        self.cleanSkills = bitmapLoader.getBitmap("skill_big", "icons")
        self.redSkills   = bitmapLoader.getBitmap("skillRed_big", "icons")
        self.greenSkills = bitmapLoader.getBitmap("skillGreen_big", "icons")
        self.refresh     = bitmapLoader.getBitmap("refresh", "icons")

        self.btnRefresh = wx.BitmapButton(self, wx.ID_ANY, self.refresh)
        size = self.btnRefresh.GetSize()

        self.btnRefresh.SetMinSize(size)
        self.btnRefresh.SetMaxSize(size)
        self.btnRefresh.SetToolTipString("Refresh API")

        self.btnRefresh.Bind(wx.EVT_BUTTON, self.refreshApi)
        self.btnRefresh.Enable(False)

        mainSizer.Add(self.btnRefresh, 0, wx.ALIGN_CENTER_VERTICAL | wx.TOP | wx.RIGHT | wx.LEFT, 2)

        self.skillReqsStaticBitmap = wx.StaticBitmap(self)
        self.skillReqsStaticBitmap.SetBitmap(self.cleanSkills)
        mainSizer.Add(self.skillReqsStaticBitmap, 0, wx.ALIGN_CENTER_VERTICAL | wx.TOP | wx.RIGHT | wx.LEFT, 3)

        self.Bind(wx.EVT_CHOICE, self.charChanged)
        self.mainFrame.Bind(GE.CHAR_LIST_UPDATED, self.refreshCharacterList)
        self.mainFrame.Bind(GE.FIT_CHANGED, self.fitChanged)

#        panelSize = wx.Size(-1,30)
#        self.SetMinSize(panelSize)

        self.charChoice.Enable(False)

    def getActiveCharacter(self):
        selection = self.charChoice.GetCurrentSelection()
        return self.charChoice.GetClientData(selection) if selection is not -1 else None

    def refreshCharacterList(self, event=None):
        choice = self.charChoice
        cChar = service.Character.getInstance()
        activeChar = self.getActiveCharacter()

        choice.Clear()
        charList = cChar.getCharacterList()
        cChar.getCharacterList()
        picked = False

        for id, name, active in charList:
            currId = choice.Append(name, id)
            if id == activeChar:
                choice.SetSelection(currId)
                self.charChanged(None)
                picked = True

        if not picked:
            charID = cChar.all5ID()
            self.selectChar(charID)
            fitID = self.mainFrame.getActiveFit()
            cFit = service.Fit.getInstance()
            cFit.changeChar(fitID, charID)

        if event is not None:
            event.Skip()

    def refreshApi(self, event):
        cChar = service.Character.getInstance()
        ID, key, charName, chars = cChar.getApiDetails(self.getActiveCharacter())
        if charName:
            try:
                cChar.apiFetch(self.getActiveCharacter(), charName)
            except:
                # can we do a popup, notifying user of API error?
                pass
        self.refreshCharacterList()

    def charChanged(self, event):
        fitID = self.mainFrame.getActiveFit()
        charID = self.getActiveCharacter()
        cChar = service.Character.getInstance()

        if cChar.getCharName(charID) not in ("All 0", "All 5") and cChar.apiEnabled(charID):
            self.btnRefresh.Enable(True)
        else:
            self.btnRefresh.Enable(False)

        cFit = service.Fit.getInstance()
        cFit.changeChar(fitID, charID)

        wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=fitID))

    def selectChar(self, charID):
        choice = self.charChoice
        numItems = len(choice.GetItems())
        for i in xrange(numItems):
            id = choice.GetClientData(i)
            if id == charID:
                choice.SetSelection(i)
                return True

        return False

    def fitChanged(self, event):
        self.charChoice.Enable(event.fitID != None)
        choice = self.charChoice
        cFit = service.Fit.getInstance()
        currCharID = choice.GetClientData(choice.GetCurrentSelection())
        fit = cFit.getFit(event.fitID)
        newCharID = fit.character.ID if fit is not None else None
        if event.fitID is None:
            self.skillReqsStaticBitmap.SetBitmap(self.cleanSkills)
            self.skillReqsStaticBitmap.SetToolTipString("No active fit")
        else:
            sCharacter = service.Character.getInstance()
            reqs = sCharacter.checkRequirements(fit)
            sCharacter.skillReqsDict = {'charname':fit.character.name, 'skills':[]}
            if len(reqs) == 0:
                tip = "All skill prerequisites have been met"
                self.skillReqsStaticBitmap.SetBitmap(self.greenSkills)
            else:
                tip  = "Skills required:\n"
                condensed = cFit.serviceFittingOptions["compactSkills"]
                if condensed:
                    dict = self._buildSkillsTooltipCondensed(reqs)
                    for key in sorted(dict):
                        tip += "%s: %d\n" % (key, dict[key])
                else:
                    tip += self._buildSkillsTooltip(reqs)
                self.skillReqsStaticBitmap.SetBitmap(self.redSkills)
            self.skillReqsStaticBitmap.SetToolTipString(tip.strip())

        if newCharID == None:
            cChar = service.Character.getInstance()
            self.selectChar(cChar.all5ID())

        elif currCharID != newCharID:
            self.selectChar(newCharID)
            self.charChanged(None)


        event.Skip()

    def _buildSkillsTooltip(self, reqs, currItem = "", tabulationLevel = 0):
        tip = ""
        sCharacter = service.Character.getInstance()

        if tabulationLevel == 0:
            for item, subReqs in reqs.iteritems():
                tip += "%s:\n" % item.name
                tip += self._buildSkillsTooltip(subReqs, item.name, 1)
        else:
            for name, info in reqs.iteritems():
                level, ID, more = info
                sCharacter.skillReqsDict['skills'].append({
                    'item' : currItem,
                    'skillID' : ID,
                    'skill' : name,
                    'level' : level,
                    'indent' : tabulationLevel
                })

                tip += "%s%s: %d\n" % ("    " * tabulationLevel, name, level)
                tip += self._buildSkillsTooltip(more, currItem, tabulationLevel + 1)

        return tip

    def _buildSkillsTooltipCondensed(self, reqs, currItem = "", tabulationLevel = 0, skillsMap = {}):
        sCharacter = service.Character.getInstance()

        if tabulationLevel == 0:
            for item, subReqs in reqs.iteritems():
                skillsMap = self._buildSkillsTooltipCondensed(subReqs, item.name, 1, skillsMap)
            sorted(skillsMap, key=skillsMap.get)
        else:
            for name, info in reqs.iteritems():
                level, ID, more = info
                sCharacter.skillReqsDict['skills'].append({
                    'item' : currItem,
                    'skillID' : ID,
                    'skill' : name,
                    'level' : level,
                    'indent' : tabulationLevel
                })

                if name not in skillsMap:
                    skillsMap[name] = level
                elif skillsMap[name] < level:
                    skillsMap[name] = level

                skillMap = self._buildSkillsTooltipCondensed(more, currItem, tabulationLevel + 1, skillsMap)

        return skillsMap
########NEW FILE########
__FILENAME__ = chromeTabs
#!/usr/bin/env python

# --------------------------------------------------------------------------------- #
# Pyfa's custom Notebook core python IMPLEMENTATION
#
# Darriele (homeworld using gmail point com) - 10/27/2010
# Updated: 11/11/2010
#
# --------------------------------------------------------------------------------- #

import wx
import wx.lib.newevent
import copy
import time
import gui.utils.colorUtils as colorUtils
import gui.utils.drawUtils as drawUtils
from gui import bitmapLoader

_PageChanging, EVT_NOTEBOOK_PAGE_CHANGING = wx.lib.newevent.NewEvent()
_PageChanged, EVT_NOTEBOOK_PAGE_CHANGED = wx.lib.newevent.NewEvent()
_PageAdding, EVT_NOTEBOOK_PAGE_ADDING = wx.lib.newevent.NewEvent()
_PageClosing, EVT_NOTEBOOK_PAGE_CLOSING = wx.lib.newevent.NewEvent()
PageAdded, EVT_NOTEBOOK_PAGE_ADDED = wx.lib.newevent.NewEvent()
PageClosed, EVT_NOTEBOOK_PAGE_CLOSED = wx.lib.newevent.NewEvent()

class VetoAble():
    def __init__(self):
        self.__vetoed = False

    def Veto(self):
        self.__vetoed = True

    def isVetoed(self):
        return self.__vetoed

class NotebookTabChangeEvent():

    def __init__(self, old, new):
        self.__old = old
        self.__new = new

    def GetOldSelection(self):
        return self.__old

    def GetSelection(self):
        return self.__new

    OldSelection = property(GetOldSelection)
    Selection = property(GetSelection)

class PageChanging(_PageChanging, NotebookTabChangeEvent, VetoAble):
    def __init__(self, old, new):
        NotebookTabChangeEvent.__init__(self, old, new)
        _PageChanging.__init__(self)
        VetoAble.__init__(self)

class PageChanged(_PageChanged, NotebookTabChangeEvent):
    def __init__(self, old, new):
        NotebookTabChangeEvent.__init__(self, old, new)
        _PageChanged.__init__(self)

class PageClosing(_PageClosing, VetoAble):
    def __init__(self, i):
        self.__index = i
        _PageClosing.__init__(self)
        VetoAble.__init__(self)
        self.Selection = property(self.GetSelection)

    def GetSelection(self):
        return self.__index

class PageAdding(_PageAdding, VetoAble):
    def __init__(self):
        _PageAdding.__init__(self)
        VetoAble.__init__(self)

class PFNotebook(wx.Panel):
    def __init__(self, parent, canAdd = True):
        wx.Panel.__init__(self, parent, wx.ID_ANY,size = (-1,-1))

        self.pages = []
        self.activePage = None

        mainSizer = wx.BoxSizer( wx.VERTICAL )

        tabsSizer = wx.BoxSizer( wx.VERTICAL )

        self.tabsContainer = PFTabsContainer(self, canAdd = canAdd)
        tabsSizer.Add( self.tabsContainer, 0, wx.EXPAND )

        mainSizer.Add( tabsSizer, 0, wx.EXPAND, 5 )

        contentSizer = wx.BoxSizer( wx.VERTICAL )
        if 'wxMSW' in wx.PlatformInfo:
            style = wx.DOUBLE_BORDER
        else:
            style = wx.SIMPLE_BORDER
        self.pageContainer = wx.Panel(self, style = style)
        self.pageContainer.SetBackgroundColour(wx.SystemSettings_GetColour(wx.SYS_COLOUR_WINDOW))
        contentSizer.Add( self.pageContainer, 1, wx.EXPAND, 5 )

        mainSizer.Add( contentSizer, 1, wx.EXPAND | wx.BOTTOM, 2 )

        self.SetSizer( mainSizer )
        self.Bind(wx.EVT_SIZE, self.OnSize)
        self.Layout()


    def GetPage(self, i):
        return self.pages[i]

    def SetPage(self, i, page):
        if i >= len(self.pages) or i is None or page is None:
            return

        oldPage = self.pages[i]
        self.pages[i] = page
        if oldPage == self.activePage:
            oldPage.Destroy()
            self.activePage = page
        else:
            oldPage.Destroy()
        page.Reparent(self.pageContainer)

        if self.activePage == page:
            self.ShowActive()


    def GetBorders(self):
        bx = wx.SystemSettings_GetMetric(wx.SYS_BORDER_X)
        by = wx.SystemSettings_GetMetric(wx.SYS_BORDER_Y)
        if bx<0:
            bx = 1
        if by<0:
            by = 1
        return (bx,by)

    def ReplaceActivePage(self, page):
        self.SetPage(self.GetSelection(), page)

    def GetSelectedPage(self):
        return self.activePage

    def GetPageIndex(self, page):
        return self.pages.index(page) if page in self.pages else None

    def GetSelection(self):
        return self.GetPageIndex(self.activePage)

    def GetCurrentPage(self):
        return self.activePage

    def GetPageCount(self):
        return len(self.pages)

    def NextPage(self):
        cpage = self.GetSelection()

        if cpage is None:
            return

        if cpage < self.GetPageCount() - 1:
            self.SetSelection(cpage + 1)
            npage = cpage +1
        else:
            self.SetSelection(0)
            npage = 0

        wx.PostEvent(self, PageChanged(cpage, npage))

    def PrevPage(self):
        cpage = self.GetSelection()

        if cpage is None:
            return

        if cpage > 0:
            self.SetSelection(cpage - 1)
            npage = cpage -1
        else:
            self.SetSelection(self.GetPageCount() - 1)
            npage = self.GetPageCount() - 1

        wx.PostEvent(self, PageChanged(cpage, npage))

    def AddPage(self, tabWnd = None, tabTitle ="Empty Tab", tabImage = None, showClose = True):
        if self.activePage:
            self.activePage.Hide()
        if not tabWnd:
            tabWnd = wx.Panel(self)
        tabWnd.Reparent(self.pageContainer)
        self.pageContainer.Layout()

        self.pages.append(tabWnd)
        self.tabsContainer.AddTab(tabTitle, tabImage, showClose)

        self.activePage = tabWnd
        self.ShowActive(True)


    def SetSelection(self, page):
        oldsel = self.GetSelection()
        if oldsel != page:
            self.activePage.Hide()
            self.activePage = self.pages[page]
            self.tabsContainer.SetSelected(page)
            self.ShowActive()

    def DeletePage(self, n, internal = False):
        page = self.pages[n]

        self.pages.remove(page)

        page.Destroy()

        if not internal:
            self.tabsContainer.DeleteTab(n, True)

        sel = self.tabsContainer.GetSelected()
        if sel is not None:
            self.activePage = self.pages[sel]
            self.ShowActive()
            wx.PostEvent(self, PageChanged(-1, sel))
        else:
            self.activePage = None


    def SwitchPages(self, src, dest, internal = False):
        self.pages[src], self.pages[dest] = self.pages[dest], self.pages[src]

    def ShowActive(self, resizeOnly = False):
        size = self.pageContainer.GetSize()
        bx, by = self.GetBorders()
        ww,wh = size
        ww -= bx * 4
        wh -= by * 4
        self.activePage.SetSize((ww,wh))
        self.activePage.SetPosition((0,0))
        if not resizeOnly:
            self.activePage.Show()
        self.Layout()


    def IsActive(self, page):
        return self.activePage == page

    def SetPageText(self, i, text, refresh=True):
        tab = self.tabsContainer.tabs[i]
        tab.text = text
        if refresh:
            self.tabsContainer.AdjustTabsSize()
            self.Refresh()

    def SetPageIcon(self, i, icon, refresh=True):
        tab = self.tabsContainer.tabs[i]
        tab.tabImg = icon
        if refresh:
            self.tabsContainer.AdjustTabsSize()
            self.Refresh()

    def SetPageTextIcon(self, i, text=wx.EmptyString, icon=None):
        self.SetPageText(i, text, False)
        self.SetPageIcon(i, icon, False)
        self.tabsContainer.AdjustTabsSize()
        self.Refresh()

    def Refresh(self):
        self.tabsContainer.Refresh()

    def OnSize(self, event):
        w,h= self.GetSize()
        self.tabsContainer.SetSize((w, -1))
        self.tabsContainer.UpdateSize()
        self.tabsContainer.Refresh()
        self.Layout()

        if self.activePage:
            self.ShowActive()
        event.Skip()

class PFTabRenderer:
    def __init__(self, size = (36,24), text = wx.EmptyString, img = None, inclination = 6 , closeButton = True, fontSize = 14):

        # tab left/right zones inclination
        self.ctabLeft = bitmapLoader.getImage("ctableft", "icons")
        self.ctabMiddle = bitmapLoader.getImage("ctabmiddle", "icons")
        self.ctabRight = bitmapLoader.getImage("ctabright", "icons")
        self.ctabClose = bitmapLoader.getImage("ctabclose", "icons")

        self.leftWidth = self.ctabLeft.GetWidth()
        self.rightWidth = self.ctabRight.GetWidth()
        self.middleWidth = self.ctabMiddle.GetWidth()
        self.closeBtnWidth  = self.ctabClose.GetWidth()

        width, height = size
        if width < self.leftWidth + self.rightWidth + self.middleWidth:
            width = self.leftWidth + self.rightWidth + self.middleWidth
        if height < self.ctabMiddle.GetHeight():
            height = self.ctabMiddle.GetHeight()

        self.inclination = inclination
        self.text = text
        self.tabSize = (width, height)
        self.closeButton = closeButton
        self.fontSize = fontSize
        self.selected = False
        self.closeBtnHovering = False
        self.tabBitmap = None
        self.tabBackBitmap = None
        self.cbSize = 5
        self.padding = 4
        self.font = wx.FontFromPixelSize((0, self.fontSize), wx.SWISS, wx.NORMAL, wx.NORMAL, False)

        self.tabImg = img
        self.position = (0, 0) # Not used internaly for rendering - helper for tab container
        self.InitTab()

    def SetPosition(self, position):
        self.position = position

    def GetPosition(self):
        return self.position

    def GetSize(self):
        return self.tabSize

    def SetSize(self, size):
        otw,oth = self.tabSize
        w,h = size
        if w< self.leftWidth + self.rightWidth + self.middleWidth:
            w = self.leftWidth + self.rightWidth + self.middleWidth
        if h < self.ctabMiddle.GetHeight():
            h = self.ctabMiddle.GetHeight()

        self.tabSize = (w,h)

        self.InitTab()

    def SetSelected(self, sel = True):
        self.selected = sel
        self.InitTab()

    def GetSelected(self):
        return self.selected

    def IsSelected(self):
        return self.selected

    def ShowCloseButtonHovering(self, hover = True):
        if self.closeBtnHovering != hover:
            self.closeBtnHovering = hover
            self._Render()

    def GetCloseButtonHoverStatus(self):
        return self.closeBtnHovering

    def GetTabRegion(self):
        nregion = self.CopyRegion(self.tabRegion)
        nregion.SubtractRegion(self.closeBtnRegion) if self.closeButton else self.tabRegion
        return nregion

    def GetCloseButtonRegion(self):
        return self.CopyRegion(self.closeBtnRegion)

    def GetMinSize(self):
        ebmp = wx.EmptyBitmap(1,1)
        mdc = wx.MemoryDC()
        mdc.SelectObject(ebmp)
        mdc.SetFont(self.font)
        textSizeX, textSizeY = mdc.GetTextExtent(self.text)
        totalSize = self.leftWidth + self.rightWidth + textSizeX + self.closeBtnWidth/2 + 16 + self.padding*2
        mdc.SelectObject(wx.NullBitmap)
        return (totalSize, self.tabHeight)

    def SetTabImage(self, img):
        self.tabImg = img

    def CopyRegion(self, region):
        rect = region.GetBox()

        newRegion = wx.Region(rect.X, rect.Y, rect.Width, rect.Height)
        newRegion.IntersectRegion(region)

        return newRegion

    def InitTab(self, skipLRzones = False):
        self.tabWidth, self.tabHeight = self.tabSize

        # content width is tabWidth - (left+right) zones

        self.contentWidth = self.tabWidth - self.leftWidth - self.rightWidth
        self.tabRegion = None
        self.closeBtnRegion = None

        self.InitColors()
        self.InitBitmaps()

        self.ComposeTabBack()
        self.InitTabRegions()
        self._Render()

    def InitBitmaps(self):

        if self.selected:
            tr,tg,tb = self.selectedColor
        else:
            tr,tg,tb = self.inactiveColor

        ctabLeft = self.ctabLeft.Copy()
        ctabRight = self.ctabRight.Copy()
        ctabMiddle = self.ctabMiddle.Copy()

        ctabLeft.Replace(0,0,0,tr, tg, tb)
        ctabRight.Replace(0,0,0,tr, tg, tb)
        ctabMiddle.Replace(0,0,0,tr, tg, tb)

        self.ctabLeftBmp = wx.BitmapFromImage(ctabLeft)
        self.ctabRightBmp = wx.BitmapFromImage(ctabRight)
        self.ctabMiddleBmp = wx.BitmapFromImage(ctabMiddle)
        self.ctabCloseBmp = wx.BitmapFromImage(self.ctabClose)



    def ComposeTabBack(self):

        bkbmp = wx.EmptyBitmap(self.tabWidth, self.tabHeight)

        mdc = wx.MemoryDC()
        mdc.SelectObject(bkbmp)

        mdc.SetBackground( wx.Brush((0x12,0x23,0x32)))
        mdc.Clear()

        mdc.DrawBitmap(self.ctabLeftBmp, 0, 0)
        cm = self.ctabMiddleBmp.ConvertToImage()
        mimg = cm.Scale(self.contentWidth, self.ctabMiddle.GetHeight(), wx.IMAGE_QUALITY_NORMAL)
        mbmp = wx.BitmapFromImage(mimg)
        mdc.DrawBitmap(mbmp, self.leftWidth, 0 )
        mdc.DrawBitmap(self.ctabRightBmp, self.contentWidth + self.leftWidth, 0 )
        mdc.SelectObject(wx.NullBitmap)
        bkbmp.SetMaskColour( (0x12, 0x23, 0x32) )
        if self.tabBackBitmap:
            del self.tabBackBitmap

        self.tabBackBitmap = bkbmp

    def InitTabRegions(self):
        self.tabRegion = wx.RegionFromBitmap(self.tabBackBitmap)
        self.closeBtnRegion = wx.RegionFromBitmap(self.ctabCloseBmp)
        self.closeBtnRegion.Offset(self.contentWidth+self.leftWidth - self.ctabCloseBmp.GetWidth()/2, (self.tabHeight - self.ctabCloseBmp.GetHeight())/2)


    def InitColors(self):
        self.tabColor = wx.SystemSettings_GetColour(wx.SYS_COLOUR_3DFACE)
        self.inactiveColor = colorUtils.GetSuitableColor(self.tabColor, 0.25)
        self.selectedColor = colorUtils.GetSuitableColor(self.tabColor, 0.10)

    def Render(self):
        return self.tabBitmap

    def _Render(self):
        if self.tabBitmap:
            del self.tabBitmap

        inc = 6
        height = self.tabHeight
        width = self.tabWidth
        contentWidth = self.contentWidth

        rect = wx.Rect(0,0,self.tabWidth, self.tabHeight)

        canvas = wx.EmptyBitmap(rect.width, rect.height)

        mdc = wx.MemoryDC()

        mdc.SelectObject(canvas)
        mdc.SetBackground(wx.Brush ((0x12,0x23,0x32)))
        mdc.Clear()


        r = copy.copy(rect)
        r.top = r.left = 0
        r.height = height
        mdc.DrawBitmap(self.tabBackBitmap, 0, 0, True)

        if self.tabImg:
            bmp = wx.BitmapFromImage(self.tabImg)
            if self.contentWidth > 16:
                mdc.DrawBitmap(bmp, self.leftWidth + self.padding  - bmp.GetWidth()/2, (height - bmp.GetHeight())/2)
            textStart = self.leftWidth + self.padding + bmp.GetWidth()/2
        else:
            textStart = self.leftWidth

        mdc.SetFont(self.font)

        maxsize = self.tabWidth - textStart - self.rightWidth - self.padding*4

        if self.selected:
            color = self.selectedColor
        else:
            color = self.inactiveColor

        mdc.SetTextForeground(colorUtils.GetSuitableColor(color, 1))

        text = drawUtils.GetPartialText(mdc, self.text, maxsize, "")

        tx,ty = mdc.GetTextExtent(text)

        mdc.DrawText(text, textStart + self.padding , height / 2 - ty / 2)

        if self.closeButton:
            if self.closeBtnHovering:
                mdc.DrawBitmap(self.ctabCloseBmp,self.contentWidth+self.leftWidth - self.ctabCloseBmp.GetWidth()/2,(height - self.ctabCloseBmp.GetHeight())/2)
            else:
                cimg = self.ctabCloseBmp.ConvertToImage()
                cimg = cimg.AdjustChannels(0.7,0.7,0.7,0.3)
                cbmp = wx.BitmapFromImage(cimg)
                mdc.DrawBitmap(cbmp,self.contentWidth+self.leftWidth - self.ctabCloseBmp.GetWidth()/2,(height - self.ctabCloseBmp.GetHeight())/2)

        mdc.SelectObject(wx.NullBitmap)


        canvas.SetMaskColour((0x12,0x23,0x32))
        img = canvas.ConvertToImage()
        if not img.HasAlpha():
            img.InitAlpha()
        bmp = wx.BitmapFromImage(img)
        self.tabBitmap = bmp

class PFAddRenderer:
    def __init__(self):

        self.addImg = bitmapLoader.getImage("ctabadd", "icons")
        self.width = self.addImg.GetWidth()
        self.height = self.addImg.GetHeight()

        self.region = None
        self.tbmp = wx.BitmapFromImage(self.addImg)
        self.addBitmap = None

        self.position = (0,0)
        self.highlighted = False

        self.InitRenderer()

    def GetPosition(self):
        return self.position

    def SetPosition(self,pos):
        self.position = pos

    def GetSize(self):
        return (self.width, self.height)

    def GetHeight(self):
        return self.height

    def GetWidth(self):
        return self.width

    def InitRenderer(self):

        self.region = self.CreateRegion()
        self._Render()


    def CreateRegion(self):
        region = wx.RegionFromBitmap(self.tbmp)
        return region

    def CopyRegion(self, region):
        rect = region.GetBox()

        newRegion = wx.Region(rect.X, rect.Y, rect.Width, rect.Height)
        newRegion.IntersectRegion(region)

        return newRegion

    def GetRegion(self):
        return self.CopyRegion(self.region)

    def Highlight(self, highlight = False):
        self.highlighted = highlight
        self._Render()

    def IsHighlighted(self):
        return self.highlighted

    def Render(self):
        return self.addBitmap

    def _Render(self):

        rect = wx.Rect(0 ,0 ,self.width, self.height)

        if self.addBitmap:
            del self.addBitmap

        if self.highlighted:
            alpha = 1
        else:
            alpha = 0.3
        img = self.addImg.AdjustChannels(1, 1, 1, alpha)

        bbmp = wx.BitmapFromImage(img)
        self.addBitmap = bbmp



class PFTabsContainer(wx.Panel):
    def __init__(self, parent, pos = (0,0), size = (100,22), id = wx.ID_ANY, canAdd = True):
        wx.Panel.__init__(self, parent, id , pos, size)
        self.tabs = []
        width, height = size
        self.width  = width
        self.height = height
        self.containerHeight = height
        self.startDrag = False
        self.dragging = False

        self.inclination = 7
        if canAdd:
            self.reserved = 48
        else:
            self.reserved = self.inclination * 4


        self.dragTrail = 3
        self.dragx = 0
        self.dragy = 0
        self.draggedTab = None
        self.dragTrigger = self.dragTrail

        self.showAddButton = canAdd

        self.tabContainerWidth = width - self.reserved
        self.tabMinWidth = width
        self.tabShadow = None

        self.addButton = PFAddRenderer()
        self.addBitmap = self.addButton.Render()

        self.previewTimer = None
        self.previewTimerID = wx.ID_ANY
        self.previewWnd = None
        self.previewBmp = None
        self.previewPos = None
        self.previewTab = None

        self.Bind(wx.EVT_TIMER, self.OnTimer)
        self.Bind(wx.EVT_LEAVE_WINDOW, self.OnLeaveWindow)

        self.Bind(wx.EVT_PAINT, self.OnPaint)
        self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnErase)
        self.Bind(wx.EVT_LEFT_DOWN, self.OnLeftDown)
        self.Bind(wx.EVT_LEFT_UP, self.OnLeftUp)
        self.Bind(wx.EVT_MOTION, self.OnMotion)
        self.Bind(wx.EVT_SIZE, self.OnSize)
        self.Bind(wx.EVT_SYS_COLOUR_CHANGED, self.OnSysColourChanged)
        self.tabShadow = PFTabRenderer((self.tabMinWidth, self.height + 1), inclination = self.inclination)

    def OnSysColourChanged(self, event):
        for tab in self.tabs:
            tab.InitTab()
        self.Refresh()

    def OnSize(self, event):
        self.UpdateSize()
        event.Skip()

    def UpdateSize(self):
        width, dummy = self.GetSize()
        if width != self.width:
            self.width = width
            self.tabContainerWidth = self.width - self.reserved
            self.AdjustTabsSize()

    def OnLeftDown(self, event):
        mposx,mposy = event.GetPosition()
        if not self.startDrag:
            tab = self.FindTabAtPos(mposx, mposy)
            if tab:
                self.CheckTabSelected(tab, mposx, mposy)
                if self.showAddButton:
                    self.startDrag = True
                    tx,ty = tab.GetPosition()
                    self.dragx = mposx - tx
                    self.dragy = self.containerHeight - self.height
                self.Refresh()

            self.draggedTab = tab

    def OnLeftUp(self, event):
        mposx,mposy = event.GetPosition()
        if self.startDrag and self.dragging:
            self.dragging = False
            self.startDrag = False
            self.draggedTab = None
            self.dragTrigger = self.dragTrail
            self.UpdateTabsPosition()
            self.Refresh()
            if self.HasCapture():
                self.ReleaseMouse()

            return

        if self.startDrag:
            self.startDrag = False
            self.dragTrigger = self.dragTrail

        if self.CheckAddButton(mposx, mposy):
            return

        if self.GetTabsCount() == 0:
            return
        selTab = self.GetSelectedTab()

        if self.CheckTabClose(selTab, mposx, mposy):
            return

        for tab in self.tabs:

            if self.CheckTabClose(tab, mposx, mposy):
                return

    def GetSelectedTab(self):
        for tab in self.tabs:
            if tab.GetSelected():
                return tab
        return None

    def GetSelected(self):
        for tab in self.tabs:
            if tab.GetSelected():
                return self.tabs.index(tab)
        return None

    def SetSelected(self, tabIndex):
        oldSelTab = self.GetSelectedTab()
        oldSelTab.SetSelected(False)
        self.tabs[tabIndex].SetSelected(True)
        self.Refresh()

    def CheckTabSelected(self,tab, mposx, mposy):
        oldSelTab = self.GetSelectedTab()
        if oldSelTab == tab:
            return True

        if self.TabHitTest(tab, mposx, mposy):
            tab.SetSelected(True)
            oldSelTab.SetSelected(False)

            ev = PageChanging(self.tabs.index(oldSelTab), self.tabs.index(tab))
            wx.PostEvent(self.Parent, ev)
            if ev.isVetoed():
                return False

            self.Refresh()

            selTab = self.tabs.index(tab)
            self.Parent.SetSelection(selTab)

            wx.PostEvent(self.Parent, PageChanged(self.tabs.index(oldSelTab), self.tabs.index(tab)))

            return True

        return False

    def CheckTabClose(self, tab, mposx, mposy):
        if not tab.closeButton:
            return False

        closeBtnReg = tab.GetCloseButtonRegion()
        tabPosX, tabPosY = tab.GetPosition()

        closeBtnReg.Offset(tabPosX,tabPosY)

        if closeBtnReg.Contains(mposx, mposy):
            index = self.tabs.index(tab)
            ev = PageClosing(index)
            wx.PostEvent(self.Parent, ev)
            if ev.isVetoed():
                return False

            index = self.GetTabIndex(tab)
            self.DeleteTab(index)
            wx.PostEvent(self.Parent, PageClosed(index=index))
            sel = self.GetSelected()
            if sel  is not None:
                wx.PostEvent(self.Parent, PageChanged(-1, sel))
            return True
        return False

    def CheckAddButton(self, mposx,mposy):
        if not self.showAddButton:
            return
        reg = self.addButton.GetRegion()
        ax,ay = self.addButton.GetPosition()
        reg.Offset(ax,ay)
        if reg.Contains(mposx, mposy):
            ev = PageAdding()
            wx.PostEvent(self.Parent, ev)
            if ev.isVetoed():
                return False

            self.Parent.AddPage()
            wx.PostEvent(self.Parent, PageAdded())
            return True

    def CheckCloseButtons(self, mposx, mposy):
        dirty = False

        for tab in self.tabs:
            closeBtnReg = tab.GetCloseButtonRegion()
            tabPos = tab.GetPosition()
            tabPosX, tabPosY = tabPos
            closeBtnReg.Offset(tabPosX,tabPosY)
            if closeBtnReg.Contains(mposx,mposy):
                if not tab.GetCloseButtonHoverStatus():
                    tab.ShowCloseButtonHovering(True)
                    dirty = True
            else:
                if tab.GetCloseButtonHoverStatus():
                    tab.ShowCloseButtonHovering(False)
                    dirty = True
        if dirty:
            self.Refresh()

    def FindTabAtPos(self, x, y):
        if self.GetTabsCount() == 0:
            return None
        selTab = self.GetSelectedTab()
        if self.TabHitTest(selTab, x, y):
            return selTab

        for tab in self.tabs:
            if self.TabHitTest(tab, x, y):
                return tab
        return None

    def TabHitTest(self, tab, x, y):
        tabRegion = tab.GetTabRegion()
        tabPos = tab.GetPosition()
        tabPosX, tabPosY = tabPos
        tabRegion.Offset(tabPosX, tabPosY)
        if tabRegion.Contains(x, y):
            return True
        return False

    def GetTabAtLeft(self, tabIndex):
        if tabIndex>0:
            return self.tabs[tabIndex - 1]
        else:
            return None

    def GetTabAtRight(self, tabIndex):
        if tabIndex < self.GetTabsCount() - 1:
            return self.tabs[tabIndex + 1]
        else:
            return None

    def SwitchTabs(self, src, dest, draggedTab = None):
        self.tabs[src], self.tabs[dest] = self.tabs[dest], self.tabs[src]
        self.UpdateTabsPosition(draggedTab)

        self.Parent.SwitchPages(src,dest, True)

        self.Refresh()

    def GetTabIndex(self, tab):
        return self.tabs.index(tab)

    def OnMotion(self, event):
        mposx,mposy = event.GetPosition()
        if self.startDrag:
            if not self.dragging:
                if self.dragTrigger < 0:
                    self.dragging = True
                    self.dragTrigger = self.dragTrail
                    self.CaptureMouse()
                else:
                    self.dragTrigger -= 1
            if self.dragging:
                dtx = mposx - self.dragx
                w,h = self.draggedTab.GetSize()

                if dtx < 0:
                    dtx = 0
                if dtx + w > self.tabContainerWidth + self.inclination * 2:
                    dtx = self.tabContainerWidth - w + self.inclination * 2
                self.draggedTab.SetPosition( (dtx, self.dragy))

                index = self.GetTabIndex(self.draggedTab)

                leftTab = self.GetTabAtLeft(index)
                rightTab = self.GetTabAtRight(index)

                if leftTab:
                    lw,lh = leftTab.GetSize()
                    lx,ly = leftTab.GetPosition()

                    if lx + lw / 2 - self.inclination * 2 > dtx:
                        self.SwitchTabs(index - 1 , index, self.draggedTab)
                        return

                if rightTab:
                    rw,rh = rightTab.GetSize()
                    rx,ry = rightTab.GetPosition()

                    if rx + rw / 2 + self.inclination * 2 < dtx + w:
                        self.SwitchTabs(index + 1 , index, self.draggedTab)
                        return
                self.UpdateTabsPosition(self.draggedTab)
                self.Refresh()
                return
            return
        self.CheckCloseButtons(mposx, mposy)

        self.CheckAddHighlighted(mposx,mposy)
        self.CheckTabPreview(mposx, mposy)
        event.Skip()

    def CheckTabPreview(self, mposx, mposy):

        if self.previewTimer:
            if self.previewTimer.IsRunning():
                if self.previewWnd:
                    self.previewTimer.Stop()
                return

        if self.previewWnd:
            self.previewWnd.Show(False)
            del self.previewWnd
            self.previewWnd = None

        for tab in self.tabs:
            if not tab.GetSelected():
                if self.TabHitTest(tab, mposx, mposy):
                    try:
                        page = self.Parent.GetPage(self.GetTabIndex(tab))
                        if hasattr(page, "Snapshot"):
                            if not self.previewTimer:
                                self.previewTimer = wx.Timer(self, self.previewTimerID)

                            self.previewTab = tab
                            self.previewTimer.Start(1500, True)
                            break
                    except:
                        pass


    def CheckAddHighlighted(self, mposx, mposy):
        if not self.showAddButton:
            return
        reg = self.addButton.GetRegion()
        ax,ay = self.addButton.GetPosition()
        reg.Offset(ax,ay)
        if reg.Contains(mposx, mposy):
            if not self.addButton.IsHighlighted():
                self.addButton.Highlight(True)
                self.Refresh()
        else:
            if self.addButton.IsHighlighted():
                self.addButton.Highlight(False)
                self.Refresh()

    def OnPaint(self, event):

        if "wxGTK" in wx.PlatformInfo:
            mdc = wx.AutoBufferedPaintDC(self)

        else:
            rect = self.GetRect()

            mdc = wx.BufferedPaintDC(self)

        selected = 0

        if 'wxMac' in wx.PlatformInfo:
            color = wx.Colour(0, 0, 0)
            brush = wx.Brush(color)

            from Carbon.Appearance import kThemeBrushDialogBackgroundActive
            brush.MacSetTheme(kThemeBrushDialogBackgroundActive)

        else:
            color = wx.SystemSettings_GetColour(wx.SYS_COLOUR_3DFACE)
            brush = wx.Brush(color)

        if "wxGTK" not in wx.PlatformInfo:
            mdc.SetBackground (brush)
            mdc.Clear()

        selected = None

        tabsWidth = 0

        for tab in self.tabs:
            tabsWidth += tab.tabWidth - self.inclination*2

        pos = tabsWidth

        if self.showAddButton:
            ax,ay = self.addButton.GetPosition()
            mdc.DrawBitmap(self.addButton.Render(), ax, ay, True)

        for i in xrange(len(self.tabs) - 1, -1, -1):
            tab = self.tabs[i]
            width = tab.tabWidth - 6
            posx, posy  = tab.GetPosition()

            if not tab.IsSelected():
                mdc.DrawBitmap(self.efxBmp, posx, posy, True )
                bmp = tab.Render()
                img = bmp.ConvertToImage()
                img = img.AdjustChannels(1, 1, 1, 0.85)
                bmp = wx.BitmapFromImage(img)
                mdc.DrawBitmap(bmp, posx, posy, True)

            else:
                selected = tab

        if selected:
            posx, posy  = selected.GetPosition()
            mdc.DrawBitmap(self.efxBmp, posx, posy, True)

            bmp = selected.Render()

            if self.dragging:
                img = bmp.ConvertToImage()
                img = img.AdjustChannels(1.2, 1.2, 1.2, 0.7)
                bmp = wx.BitmapFromImage(img)

            mdc.DrawBitmap(bmp, posx, posy, True)

    def OnErase(self, event):
        pass

    def UpdateTabFX(self):
        w,h = self.tabShadow.GetSize()
        if w != self.tabMinWidth:
            self.tabShadow.SetSize((self.tabMinWidth, self.height + 1))
            fxBmp = self.tabShadow.Render()

            simg = fxBmp.ConvertToImage()
            if not simg.HasAlpha():
                simg.InitAlpha()
            simg = simg.Blur(2)
            simg = simg.AdjustChannels(0.3,0.3,0.3,0.35)

            self.efxBmp = wx.BitmapFromImage(simg)

    def AddTab(self, title = wx.EmptyString, img = None, showClose = False):
        self.ClearTabsSelected()

        tabRenderer = PFTabRenderer( (120,self.height), title, img, self.inclination, closeButton = showClose)
        tabRenderer.SetSelected(True)

        self.tabs.append( tabRenderer )
        self.AdjustTabsSize()
        self.Refresh()

    def ClearTabsSelected(self):
        for tab in self.tabs:
            tab.SetSelected(False)

    def DeleteTab(self, tab, external = False):
        tabRenderer = self.tabs[tab]
        wasSelected = tabRenderer.GetSelected()
        self.tabs.remove(tabRenderer)

        if tabRenderer:
            del tabRenderer

        if wasSelected and self.GetTabsCount() > 0:
            if tab > self.GetTabsCount() -1:
                self.tabs[self.GetTabsCount() - 1].SetSelected(True)
            else:
                self.tabs[tab].SetSelected(True)
        if not external:
            self.Parent.DeletePage(tab, True)

        self.AdjustTabsSize()
        self.Refresh()

    def GetTabsCount(self):
        return len(self.tabs)

    def AdjustTabsSize(self):

        tabMinWidth = 9000000 # Really, it should be over 9000
        tabMaxWidth = 0
        for tab in self.tabs:
            mw,mh = tab.GetMinSize()
            if tabMinWidth > mw:
                tabMinWidth = mw
            if tabMaxWidth < mw:
                tabMaxWidth = mw
        if tabMaxWidth < 100:
            tabMaxWidth = 100
        if self.GetTabsCount() >0:
            if (self.GetTabsCount()) * (tabMaxWidth - self.inclination * 2) > self.tabContainerWidth:
                self.tabMinWidth = float(self.tabContainerWidth) / float(self.GetTabsCount()) + self.inclination * 2
            else:
                self.tabMinWidth = tabMaxWidth

        if self.tabMinWidth <1:
            self.tabMinWidth = 1
        for tab in self.tabs:
            w,h = tab.GetSize()
            tab.SetSize( (self.tabMinWidth, self.height) )

        if self.GetTabsCount() > 0:
            self.UpdateTabFX()

        self.UpdateTabsPosition()

    def UpdateTabsPosition(self, skipTab = None):
        tabsWidth = 0
        for tab in self.tabs:
            tabsWidth += tab.tabWidth - self.inclination*2

        pos = tabsWidth
        selected = None
        for i in xrange(len(self.tabs) - 1, -1, -1):
            tab = self.tabs[i]
            width = tab.tabWidth - self.inclination*2
            pos -= width
            if not tab.IsSelected():
                tab.SetPosition((pos, self.containerHeight - self.height))
            else:
                selected = tab
                selpos = pos
        if selected is not skipTab:
            selected.SetPosition((selpos, self.containerHeight - self.height))
        self.addButton.SetPosition((round(tabsWidth) + self.inclination*2, self.containerHeight - self.height/2 - self.addButton.GetHeight()/3))

    def OnLeaveWindow(self, event):

        if self.startDrag and not self.dragging:
            self.dragging = False
            self.startDrag = False
            self.draggedTab = None
            self.dragTrigger = self.dragTrail
            if self.HasCapture():
                self.ReleaseMouse()

        if self.previewWnd:
            self.previewWnd.Show(False)
            del self.previewWnd
            self.previewWnd = None
        event.Skip()

    def OnTimer(self, event):
        mposx, mposy = wx.GetMousePosition()
        cposx, cposy = self.ScreenToClient((mposx, mposy))
        if self.FindTabAtPos(cposx, cposy) == self.previewTab:
            if not self.previewTab.GetSelected():
                page = self.Parent.GetPage(self.GetTabIndex(self.previewTab))
                if page.Snapshot():
                    self.previewWnd = PFNotebookPagePreview(self,(mposx+3,mposy+3), page.Snapshot(), self.previewTab.text)
                    self.previewWnd.Show()

        event.Skip()

class PFNotebookPagePreview(wx.Frame):
    def __init__ (self,parent, pos, bitmap, title):
        wx.Frame.__init__(self, parent, id = wx.ID_ANY, title = wx.EmptyString, pos = pos, size = wx.DefaultSize, style =
                                                               wx.NO_BORDER
                                                             | wx.FRAME_NO_TASKBAR
                                                             | wx.STAY_ON_TOP)

        self.title = title
        self.bitmap = bitmap
        self.SetSize((bitmap.GetWidth(), bitmap.GetHeight()))
        self.Bind(wx.EVT_PAINT,self.OnWindowPaint)
        self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnWindowEraseBk)
        self.Bind(wx.EVT_TIMER, self.OnTimer)

        self.timer = wx.Timer(self,wx.ID_ANY)
        self.timerSleep = None
        self.timerSleepId = wx.NewId()
        self.direction = 1
        self.padding = 15
        self.transp = 0

        hfont = wx.FontFromPixelSize((0,14), wx.SWISS, wx.NORMAL,wx.NORMAL, False)
        self.SetFont(hfont)

        tx, ty = self.GetTextExtent(self.title)
        tx +=  self.padding * 2

        if bitmap.GetWidth() < tx:
            width = tx
        else:
            width = bitmap.GetWidth()

        self.SetSize((width, bitmap.GetHeight()+16))

        self.SetTransparent(0)
        self.Refresh()

    def OnTimer(self, event):
        self.transp += 20*self.direction

        if self.transp > 220:
            self.transp = 220
            self.timer.Stop()

        if self.transp < 0:
            self.transp = 0
            self.timer.Stop()
            wx.Frame.Show(self,False)
            self.Destroy()
            return
        self.SetTransparent(self.transp)

    def RaiseParent(self):
        wnd = self
        lastwnd = None
        while wnd is not None:
            lastwnd = wnd
            wnd = wnd.Parent
        if lastwnd:
            lastwnd.Raise()

    def Show(self, showWnd = True):
        if showWnd:
            wx.Frame.Show(self, showWnd)
            self.RaiseParent()
            self.direction = 1
            self.timer.Start(10)
        else:
            self.direction = -1
            self.timer.Start(10)


    def OnWindowEraseBk(self,event):
        pass

    def OnWindowPaint(self,event):
        rect = self.GetRect()
        canvas = wx.EmptyBitmap(rect.width, rect.height)
        mdc = wx.BufferedPaintDC(self)
        mdc.SelectObject(canvas)
        color = wx.SystemSettings_GetColour(wx.SYS_COLOUR_WINDOW)
        mdc.SetBackground(wx.Brush(color))
        mdc.Clear()

        font = wx.FontFromPixelSize((0,14), wx.SWISS, wx.NORMAL,wx.NORMAL, False)
        mdc.SetFont(font)

        x,y = mdc.GetTextExtent(self.title)

        mdc.SetBrush(wx.Brush(wx.SystemSettings_GetColour(wx.SYS_COLOUR_WINDOWTEXT)))
        mdc.DrawRectangle(0,0,rect.width,16)

        mdc.SetTextForeground(wx.SystemSettings_GetColour(wx.SYS_COLOUR_WINDOW))

        mdc.DrawText(self.title, (rect.width - x)/2, (16 -y)/2)

        mdc.DrawBitmap(self.bitmap, 0, 16)

        mdc.SetPen( wx.Pen("#000000", width = 1 ) )
        mdc.SetBrush( wx.TRANSPARENT_BRUSH )

        mdc.DrawRectangle( 0, 16, rect.width,rect.height - 16)

########NEW FILE########
__FILENAME__ = contextMenu
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import wx

class ContextMenu(object):
    menus = []
    @classmethod
    def register(cls):
        ContextMenu.menus.append(cls)

    @classmethod
    def getMenu(cls, selection, *fullContexts):
        menu = wx.Menu()
        menu.info = {}
        menu.selection = selection
        empty = True
        menu.Bind(wx.EVT_MENU, cls.handler)
        for i, fullContext in enumerate(fullContexts):
            amount = 0
            srcContext = fullContext[0]
            try:
                itmContext = fullContext[1]
            except IndexError:
                itmContext = None
            for menuHandler in cls.menus:
                m = menuHandler()
                if m.display(srcContext, selection):
                    amount += 1
                    texts = m.getText(itmContext, selection)
                    if isinstance(texts, basestring):
                        texts = (texts,)

                    bitmap = m.getBitmap(srcContext, selection)
                    multiple = not isinstance(bitmap, wx.Bitmap)
                    for it, text in enumerate(texts):
                        id = wx.NewId()
                        item = wx.MenuItem(menu, id, text)
                        menu.info[id] = (m, fullContext, it)

                        sub = m.getSubMenu(srcContext, selection, menu, it)
                        if sub is not None:
                            item.SetSubMenu(sub)

                        if bitmap is not None:
                            if multiple:
                                bp = bitmap[it]
                                if bp:
                                    item.SetBitmap(bp)
                            else:
                                item.SetBitmap(bitmap)

                        menu.AppendItem(item)

                    empty = False

            if amount > 0 and i != len(fullContexts) - 1:
                menu.AppendSeparator()

        return menu if empty is False else None

    @classmethod
    def handler(cls, event):
        menu = event.EventObject
        stuff = menu.info.get(event.Id)
        if stuff is not None:
            m, context, i = stuff
            selection = menu.selection
            if not hasattr(selection, "__iter__"):
                selection = (selection,)

            m.activate(context, selection, i)
        else:
            event.Skip()

    def display(self, context, selection):
        raise NotImplementedError()

    def activate(self, context, selection, i):
        return None

    def getSubMenu(self, context, selection, menu, i):
        return None

    def getText(self, context, selection):
        raise NotImplementedError()

    def getBitmap(self, context, selection):
        return None


from gui.builtinContextMenus import *

########NEW FILE########
__FILENAME__ = copySelectDialog
#===============================================================================
# Copyright (C) 2010 Lucas Thode
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================


import wx

class CopySelectDialog(wx.Dialog):
    copyFormatEft = 0
    copyFormatEftImps = 1
    copyFormatXml = 2
    copyFormatDna = 3

    def __init__(self, parent):
        wx.Dialog.__init__(self, parent, id = wx.ID_ANY, title = u"Select a format", size = (-1,-1), style = wx.DEFAULT_DIALOG_STYLE)
        mainSizer = wx.BoxSizer(wx.VERTICAL)

        copyFormats = [u"EFT", u"EFT (Implants)", u"XML", u"DNA"]
        copyFormatTooltips = {CopySelectDialog.copyFormatEft: u"EFT text format",
                              CopySelectDialog.copyFormatEftImps: u"EFT text format",
                              CopySelectDialog.copyFormatXml: u"EVE native XML format",
                              CopySelectDialog.copyFormatDna: u"A one-line text format"}
        selector = wx.RadioBox(self, wx.ID_ANY, label = u"Copy to the clipboard using:", choices = copyFormats, style = wx.RA_SPECIFY_ROWS)
        selector.Bind(wx.EVT_RADIOBOX, self.Selected)
        for format, tooltip in copyFormatTooltips.iteritems():
            selector.SetItemToolTip(format, tooltip)

        self.copyFormat = CopySelectDialog.copyFormatEft
        selector.SetSelection(self.copyFormat)

        mainSizer.Add(selector,0,wx.EXPAND | wx.ALL, 5)

        buttonSizer = self.CreateButtonSizer(wx.OK | wx.CANCEL)
        if (buttonSizer):
            mainSizer.Add(buttonSizer,0, wx.EXPAND | wx.ALL, 5)

        self.SetSizer(mainSizer)
        self.Fit()
        self.Center()


    def Selected(self, event):
        self.copyFormat = event.GetSelection()

    def GetSelected(self):
        return self.copyFormat



########NEW FILE########
__FILENAME__ = display
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import sys
import wx
import gui.mainFrame

from gui.viewColumn import ViewColumn
from gui.cachingImageList import CachingImageList

class Display(wx.ListCtrl):
    def __init__(self, parent, size = wx.DefaultSize, style = 0):

        wx.ListCtrl.__init__(self, parent,size = size, style=wx.LC_REPORT |  style )
        self.imageList = CachingImageList(16, 16)
        self.SetImageList(self.imageList, wx.IMAGE_LIST_SMALL)
        self.activeColumns = []
        self.columnsMinWidth = []
        self.Bind(wx.EVT_LIST_COL_END_DRAG, self.resizeChecker)
        self.Bind(wx.EVT_LIST_COL_BEGIN_DRAG, self.resizeSkip)

        if "wxMSW" in wx.PlatformInfo:
            self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnEraseBk)

        self.mainFrame = gui.mainFrame.MainFrame.getInstance()

        i = 0
        for colName in self.DEFAULT_COLS:
            if ":" in colName:
                colName, params = colName.split(":", 1)
                params = params.split(",")
                colClass = ViewColumn.getColumn(colName)
                paramList = colClass.getParameters()
                paramDict = {}
                for x, param in enumerate(paramList):
                    name, type, defaultValue = param
                    value = params[x] if len(params) > x else defaultValue
                    value = value if value != "" else defaultValue
                    if type == bool and isinstance(value, basestring):
                        value = bool(value) if value.lower() != "false" and value != "0" else False
                    paramDict[name] = value
                col = colClass(self, paramDict)
            else:
                col = ViewColumn.getColumn(colName)(self, None)

            self.addColumn(i, col)
            self.columnsMinWidth.append(self.GetColumnWidth(i))
            i += 1

        info = wx.ListItem()
        info.m_mask = wx.LIST_MASK_WIDTH
        self.InsertColumnInfo(i, info)
        self.SetColumnWidth(i, 0)

        self.imageListBase = self.imageList.ImageCount


# Override native HitTestSubItem (doesn't work as it should on GTK)
# Source: ObjectListView

    def HitTestSubItem(self, pt):
        """
        Return a tuple indicating which (item, subItem) the given pt (client coordinates) is over.

        This uses the built-in version on Windows, and poor mans replacement on other platforms.
        """
        # The buildin version works on Windows

        if wx.Platform == "__WXMSW__":
            return wx.ListCtrl.HitTestSubItem(self, pt)

        (rowIndex, flags) = self.HitTest(pt)

        # Did the point hit any item?
        if (flags & wx.LIST_HITTEST_ONITEM) == 0:
            return (-1, 0, -1)

        # If it did hit an item and we are not in report mode, it must be the primary cell
        if not self.InReportView():
            return (rowIndex, wx.LIST_HITTEST_ONITEM, 0)

        # Find which subitem is hit
        right = 0
        scrolledX = self.GetScrollPos(wx.HORIZONTAL) * wx.SystemSettings.GetMetric(wx.SYS_HSCROLL_Y) + pt.x
        for i in range(self.GetColumnCount()):
            left = right
            right += self.GetColumnWidth(i)
            if scrolledX < right:
                if (scrolledX - left) < self.imageList.GetSize(0)[0]:
                    flag = wx.LIST_HITTEST_ONITEMICON
                else:
                    flag = wx.LIST_HITTEST_ONITEMLABEL
                return (rowIndex, flag, i)

        return (rowIndex, 0, -1)


    def OnEraseBk(self,event):
        if self.GetItemCount() >0:
            width, height = self.GetClientSize()
            dc = event.GetDC()

            dc.DestroyClippingRegion()
            dc.SetClippingRegion(0, 0, width, height)
            x,y,w,h = dc.GetClippingBox()

            topItem = self.GetTopItem()
            bottomItem = topItem + self.GetCountPerPage()

            if bottomItem >= self.GetItemCount():
                bottomItem = self.GetItemCount() - 1

            topRect = self.GetItemRect(topItem, wx.LIST_RECT_LABEL)
            bottomRect = self.GetItemRect(bottomItem, wx.LIST_RECT_BOUNDS)


            items_rect = wx.Rect(topRect.left, 0, bottomRect.right - topRect.left, bottomRect.bottom )

            updateRegion = wx.Region(x,y,w,h)
            updateRegion.SubtractRect(items_rect)

            dc.DestroyClippingRegion()
            dc.SetClippingRegionAsRegion(updateRegion)

            dc.SetBackground(wx.Brush(self.GetBackgroundColour(), wx.SOLID))
            dc.Clear()

            dc.DestroyClippingRegion()

        else:
            event.Skip()

    def addColumn(self, i, col):
        self.activeColumns.append(col)
        info = wx.ListItem()
        info.m_mask = col.mask | wx.LIST_MASK_FORMAT | wx.LIST_MASK_WIDTH
        info.m_image = col.imageId
        info.m_text = col.columnText
        info.m_width = -1
        info.m_format = wx.LIST_FORMAT_LEFT
        self.InsertColumnInfo(i, info)
        col.resized = False
        if i == 0 and col.size != wx.LIST_AUTOSIZE_USEHEADER:
            col.size += 4
        self.SetColumnWidth(i, col.size)

    def getColIndex(self, colClass):
        for i, col in enumerate(self.activeColumns):
            if col.__class__ == colClass:
                return i

        return None

    def resizeChecker(self, event):
        # we veto header cell resize by default till we find a way
        # to assure a minimal size for the resized header cell
        column = event.GetColumn()
        wx.CallAfter(self.checkColumnSize,column)
        event.Skip()

    def resizeSkip(self, event):
        column = event.GetColumn()
        if column > len (self.activeColumns)-1:
            self.SetColumnWidth(column, 0)
            event.Veto()
            return
        colItem = self.activeColumns[column]
        if self.activeColumns[column].maxsize != -1:
            event.Veto()
        else:
            event.Skip()

    def checkColumnSize(self,column):
        colItem = self.activeColumns[column]
        if self.GetColumnWidth(column) < self.columnsMinWidth[column]:
            self.SetColumnWidth(column,self.columnsMinWidth[column])
        colItem.resized = True

    def getLastItem( self, state =  wx.LIST_STATE_DONTCARE):
            lastFound = -1
            while True:
                    index = self.GetNextItem(
                            lastFound,
                            wx.LIST_NEXT_ALL,
                            state,
                    )
                    if index == -1:
                            break
                    else:
                            lastFound = index

            return lastFound

    def deselectItems(self):
        sel = self.GetFirstSelected()
        while sel != -1:
            self.SetItemState(sel, 0, wx.LIST_STATE_SELECTED | wx.LIST_STATE_FOCUSED)
            sel = self.GetNextSelected(sel)

    def populate(self, stuff):

        if stuff is not None:
            listItemCount = self.GetItemCount()
            stuffItemCount = len(stuff)

            if listItemCount < stuffItemCount:
                for i in xrange(stuffItemCount - listItemCount):
                    index = self.InsertStringItem(sys.maxint, "")

            if listItemCount > stuffItemCount:
                if listItemCount - stuffItemCount > 20 and stuffItemCount < 20:
                    self.DeleteAllItems()
                    for i in xrange(stuffItemCount):
                        index = self.InsertStringItem(sys.maxint, "")
                else:
                    for i in xrange(listItemCount - stuffItemCount):
                        self.DeleteItem(self.getLastItem())
                    self.Refresh()


    def refresh(self, stuff):
        if stuff == None:
            return

        item = -1
        for id, st in enumerate(stuff):

            item = self.GetNextItem(item)

            for i, col in enumerate(self.activeColumns):
                colItem = self.GetItem(item, i)
                oldText = colItem.GetText()
                oldImageId = colItem.GetImage()
                newText = col.getText(st)
                if newText is False:
                    col.delayedText(st, self, colItem)
                    newText = ""

                newImageId = col.getImageId(st)

                colItem.SetText(newText)
                colItem.SetImage(newImageId)

                mask = 0

                if oldText != newText:
                    mask |= wx.LIST_MASK_TEXT
                    colItem.SetText(newText)
                if oldImageId != newImageId:
                    mask |= wx.LIST_MASK_IMAGE
                    colItem.SetImage(newImageId)

                if mask:
                    colItem.SetMask(mask)
                    self.SetItem(colItem)

                self.SetItemData(item, id)

#        self.Freeze()
        if 'wxMSW' in wx.PlatformInfo:
            for i,col in enumerate(self.activeColumns):
                if not col.resized:
                    self.SetColumnWidth(i, col.size)
        else:
            for i, col in enumerate(self.activeColumns):
                if not col.resized:
                    if col.size == wx.LIST_AUTOSIZE_USEHEADER:
                        self.SetColumnWidth(i, wx.LIST_AUTOSIZE_USEHEADER)
                        headerWidth = self.GetColumnWidth(i)
                        self.SetColumnWidth(i, wx.LIST_AUTOSIZE)
                        baseWidth = self.GetColumnWidth(i)
                        if baseWidth < headerWidth:
                            self.SetColumnWidth(i, headerWidth)
                    else:
                        self.SetColumnWidth(i, col.size)
#        self.Thaw()



    def update(self, stuff):
        self.populate(stuff)
        self.refresh(stuff)

    def getColumn(self, point):
        row, _, col = self.HitTestSubItem(point)
        return col

########NEW FILE########
__FILENAME__ = droneView
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import wx

import service
import gui.globalEvents as GE
import gui.marketBrowser as mb
import gui.display as d
from gui.builtinViewColumns.state import State
from gui.contextMenu import ContextMenu

class DroneViewDrop(wx.PyDropTarget):
        def __init__(self, dropFn):
            wx.PyDropTarget.__init__(self)
            self.dropFn = dropFn
            # this is really transferring an EVE itemID
            self.dropData = wx.PyTextDataObject()
            self.SetDataObject(self.dropData)

        def OnData(self, x, y, t):
            if self.GetData():
                self.dropFn(x, y, int(self.dropData.GetText()))
            return t

class DroneView(d.Display):
    DEFAULT_COLS = ["State",
                    "Base Icon",
                    "Base Name",
                    "prop:droneDps,droneBandwidth",
                    "Max Range",
                    "Miscellanea",
                    "attr:maxVelocity",]

    def __init__(self, parent):
        d.Display.__init__(self, parent, style=wx.LC_SINGLE_SEL | wx.BORDER_NONE)

        self.lastFitId = None

        self.hoveredRow = None
        self.hoveredColumn = None

        self.mainFrame.Bind(GE.FIT_CHANGED, self.fitChanged)
        self.mainFrame.Bind(mb.ITEM_SELECTED, self.addItem)
        self.Bind(wx.EVT_LEFT_DCLICK, self.removeItem)
        self.Bind(wx.EVT_LEFT_DOWN, self.click)
        self.Bind(wx.EVT_KEY_UP, self.kbEvent)
        self.Bind(wx.EVT_MOTION, self.OnMouseMove)
        self.Bind(wx.EVT_LEAVE_WINDOW, self.OnLeaveWindow)

        if "__WXGTK__" in  wx.PlatformInfo:
            self.Bind(wx.EVT_RIGHT_UP, self.scheduleMenu)
        else:
            self.Bind(wx.EVT_RIGHT_DOWN, self.scheduleMenu)


        self.Bind(wx.EVT_LIST_BEGIN_DRAG, self.startDrag)
        self.SetDropTarget(DroneViewDrop(self.mergeDrones))

    def OnLeaveWindow(self, event):
        self.SetToolTip(None)
        self.hoveredRow = None
        self.hoveredColumn = None
        event.Skip()

    def OnMouseMove(self, event):
        row, _, col = self.HitTestSubItem(event.Position)
        if row != self.hoveredRow or col != self.hoveredColumn:
            if self.ToolTip is not None:
                self.SetToolTip(None)
            else:
                self.hoveredRow = row
                self.hoveredColumn = col
                if row != -1 and col != -1 and col < len(self.DEFAULT_COLS):
                    mod = self.drones[self.GetItemData(row)]
                    if self.DEFAULT_COLS[col] == "Miscellanea":
                        tooltip = self.activeColumns[col].getToolTip(mod)
                        if tooltip is not None:
                            self.SetToolTipString(tooltip)
                        else:
                            self.SetToolTip(None)
                    else:
                        self.SetToolTip(None)
                else:
                    self.SetToolTip(None)
        event.Skip()

    def kbEvent(self, event):
        keycode = event.GetKeyCode()
        if keycode == wx.WXK_DELETE or keycode == wx.WXK_NUMPAD_DELETE:
            row = self.GetFirstSelected()
            firstSel = row
            if row != -1:
                drone = self.drones[self.GetItemData(row)]
                self.removeDrone(drone)

        event.Skip()

    def startDrag(self, event):
        row = event.GetIndex()
        if row != -1:
            data = wx.PyTextDataObject()
            data.SetText(str(self.GetItemData(row)))

            dropSource = wx.DropSource(self)
            dropSource.SetData(data)
            res = dropSource.DoDragDrop()

    def mergeDrones(self, x, y, itemID):
        srcRow = self.FindItemData(-1,itemID)
        dstRow, _ = self.HitTest((x, y))
        if srcRow != -1 and dstRow != -1:
            self._merge(srcRow, dstRow)

    def _merge(self, src, dst):
        sFit = service.Fit.getInstance()
        fitID = self.mainFrame.getActiveFit()
        if sFit.mergeDrones(fitID, self.drones[src], self.drones[dst]):
            wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=fitID))

    DRONE_ORDER = ('Light Scout Drones', 'Medium Scout Drones',
                   'Heavy Attack Drones', 'Sentry Drones', 'Fighters',
                   'Fighter Bombers', 'Combat Utility Drones',
                   'Electronic Warfare Drones', 'Logistic Drones', 'Mining Drones', 'Salvage Drones')
    def droneKey(self, drone):
        sMarket = service.Market.getInstance()

        groupName = sMarket.getMarketGroupByItem(drone.item).name

        return (self.DRONE_ORDER.index(groupName),
                drone.item.name)

    def fitChanged(self, event):

        #Clear list and get out if current fitId is None
        if event.fitID is None and self.lastFitId is not None:
            self.DeleteAllItems()
            self.lastFitId = None
            event.Skip()
            return

        cFit = service.Fit.getInstance()
        fit = cFit.getFit(event.fitID)

        self.original = fit.drones if fit is not None else None
        self.drones = stuff = fit.drones[:] if fit is not None else None

        if stuff is not None:
            stuff.sort(key=self.droneKey)


        if event.fitID != self.lastFitId:
            self.lastFitId = event.fitID

            item = self.GetNextItem(-1, wx.LIST_NEXT_ALL, wx.LIST_STATE_DONTCARE)

            if item != -1:
                self.EnsureVisible(item)

            self.deselectItems()

        self.update(stuff)
        event.Skip()


    def addItem(self, event):
        cFit = service.Fit.getInstance()
        fitID = self.mainFrame.getActiveFit()
        trigger = cFit.addDrone(fitID, event.itemID)
        if trigger:
            wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=fitID))
            self.mainFrame.additionsPane.select("Drones")

        event.Skip()

    def removeItem(self, event):
        row, _ = self.HitTest(event.Position)
        if row != -1:
            col = self.getColumn(event.Position)
            if col != self.getColIndex(State):
                drone = self.drones[self.GetItemData(row)]
                self.removeDrone(drone)
                
    def removeDrone(self, drone):
        fitID = self.mainFrame.getActiveFit()
        cFit = service.Fit.getInstance()
        cFit.removeDrone(fitID, self.original.index(drone))
        wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=fitID))

    def click(self, event):
        event.Skip()
        row, _ = self.HitTest(event.Position)
        if row != -1:
            col = self.getColumn(event.Position)
            if col == self.getColIndex(State):
                fitID = self.mainFrame.getActiveFit()
                cFit = service.Fit.getInstance()
                drone = self.drones[row]
                cFit.toggleDrone(fitID, self.original.index(drone))
                wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=fitID))

    def scheduleMenu(self, event):
        event.Skip()
        if self.getColumn(event.Position) != self.getColIndex(State):
            wx.CallAfter(self.spawnMenu)

    def spawnMenu(self):
        sel = self.GetFirstSelected()
        if sel != -1:
            drone = self.drones[sel]

            sMkt = service.Market.getInstance()
            sourceContext = "droneItem"
            itemContext = sMkt.getCategoryByItem(drone.item).name
            menu = ContextMenu.getMenu((drone,), (sourceContext, itemContext))
            self.PopupMenu(menu)

########NEW FILE########
__FILENAME__ = fleetBrowser
import wx
import copy
from gui import bitmapLoader
import gui.mainFrame
from gui.PFListPane import PFListPane
import service.fleet
from gui.utils.drawUtils import GetPartialText

from wx.lib.buttons import GenBitmapButton

import gui.utils.colorUtils as colorUtils
import gui.utils.drawUtils as drawUtils

import gui.sfBrowserItem as SFItem

FleetSelected, EVT_FLEET_SELECTED = wx.lib.newevent.NewEvent()
FleetRenamed, EVT_FLEET_RENAMED = wx.lib.newevent.NewEvent()
FleetRemoved, EVT_FLEET_REMOVED = wx.lib.newevent.NewEvent()


FleetItemSelect, EVT_FLEET_ITEM_SELECT = wx.lib.newevent.NewEvent()
FleetItemDelete, EVT_FLEET_ITEM_DELETE = wx.lib.newevent.NewEvent()
FleetItemNew, EVT_FLEET_ITEM_NEW = wx.lib.newevent.NewEvent()
FleetItemCopy, EVT_FLEET_ITEM_COPY = wx.lib.newevent.NewEvent()
FleetItemRename, EVT_FLEET_ITEM_RENAME = wx.lib.newevent.NewEvent()



class FleetBrowser(wx.Panel):
    def __init__(self, parent):
        wx.Panel.__init__(self, parent)

        self.sFleet = service.fleet.Fleet.getInstance()
        self.mainFrame = gui.mainFrame.MainFrame.getInstance()

        mainSizer = wx.BoxSizer(wx.VERTICAL)

        self.hpane = FleetBrowserHeader(self)
        mainSizer.Add(self.hpane, 0, wx.EXPAND)

        self.m_sl2 = wx.StaticLine( self, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.LI_HORIZONTAL )
        mainSizer.Add( self.m_sl2, 0, wx.EXPAND, 0 )

        self.fleetItemContainer = PFFleetItemContainer(self)

        mainSizer.Add(self.fleetItemContainer, 1, wx.EXPAND)

        self.SetSizer(mainSizer)
        self.Layout()

        self.filter = ""
        self.fleetIDMustEditName = -1

        self.Bind(wx.EVT_SIZE, self.SizeRefreshList)

        self.Bind(EVT_FLEET_ITEM_NEW, self.AddNewFleetItem)
        self.Bind(EVT_FLEET_ITEM_SELECT, self.SelectFleetItem)
        self.Bind(EVT_FLEET_ITEM_DELETE, self.DeleteFleetItem)
        self.Bind(EVT_FLEET_ITEM_COPY, self.CopyFleetItem)
        self.Bind(EVT_FLEET_ITEM_RENAME, self.RenameFleetItem)

        self.PopulateFleetList()

    def AddNewFleetItem(self, event):
        fleetName = event.fleetName
        newFleet = self.sFleet.addFleet()
        self.sFleet.renameFleet(newFleet, fleetName)

        self.fleetIDMustEditName = newFleet.ID
        self.AddItem(newFleet.ID, newFleet.name, newFleet.count())

    def SelectFleetItem(self, event):
        fleetID = event.fleetID
        self.fleetItemContainer.SelectWidgetByFleetID(fleetID)
        wx.PostEvent(self.mainFrame, FleetSelected(fleetID=fleetID))

    def CopyFleetItem(self, event):
        fleetID = event.fleetID
        fleet = self.sFleet.copyFleetByID(fleetID)

        fleetName = fleet.name + " Copy"
        self.sFleet.renameFleet(fleet,fleetName)

        self.fleetIDMustEditName = fleet.ID
        self.AddItem(fleet.ID, fleet.name, fleet.count())

        self.fleetItemContainer.SelectWidgetByFleetID(fleet.ID)
        wx.PostEvent(self.mainFrame, FleetSelected(fleetID=fleet.ID))

    def RenameFleetItem(self, event):
        fleetID = event.fleetID
        fleet = self.sFleet.getFleetByID(fleetID)

        newFleetName = event.fleetName

        self.sFleet.renameFleet(fleet, newFleetName)
        wx.PostEvent(self.mainFrame, FleetRenamed(fleetID = fleet.ID))

    def DeleteFleetItem(self, event):
        self.sFleet.deleteFleetByID(event.fleetID)
        self.PopulateFleetList()
        wx.PostEvent(self.mainFrame, FleetRemoved(fleetID = event.fleetID))

    def AddItem (self, ID, name, count):
        self.fleetItemContainer.AddWidget(FleetItem(self, ID, name, count))
        widget = self.fleetItemContainer.GetWidgetByFleetID(ID)
        self.fleetItemContainer.RefreshList(True)
        self.fleetItemContainer.ScrollChildIntoView(widget)
        wx.PostEvent(self, FleetItemSelect(fleetID = ID))

    def PopulateFleetList(self):
        self.Freeze()
        filter = self.filter
        self.fleetItemContainer.RemoveAllChildren()
        fleetList = self.sFleet.getFleetList()
        for fleetID, fleetName, fleetCount in fleetList:
            if fleetName.lower().find(filter.lower()) != -1:
                self.fleetItemContainer.AddWidget(FleetItem(self, fleetID, fleetName, fleetCount))
        self.fleetItemContainer.RefreshList()
        self.Thaw()

    def SetFilter(self, filter):
        self.filter = filter

    def SizeRefreshList(self, event):
        ewidth, eheight = event.GetSize()
        self.Layout()
        self.fleetItemContainer.Layout()
        self.fleetItemContainer.RefreshList(True)
        event.Skip()


class FleetBrowserHeader (wx.Panel):
    def __init__(self, parent):
        wx.Panel.__init__ (self, parent, id=wx.ID_ANY, pos=wx.DefaultPosition, size=wx.Size(500, 24), style=wx.TAB_TRAVERSAL)
        self.SetBackgroundColour( wx.SystemSettings.GetColour( wx.SYS_COLOUR_BTNFACE ) )

        self.newBmp = bitmapLoader.getBitmap("fit_add_small","icons")
        bmpSize = (16,16)

        mainSizer = wx.BoxSizer(wx.HORIZONTAL)

        if 'wxMac' in wx.PlatformInfo:
            bgcolour = wx.Colour(0, 0, 0, 0)
        else:
            bgcolour = wx.SystemSettings.GetColour( wx.SYS_COLOUR_BTNFACE )

        self.fbNewFleet = PFGenBitmapButton( self, wx.ID_ANY, self.newBmp, wx.DefaultPosition, bmpSize, wx.BORDER_NONE )
        mainSizer.Add(self.fbNewFleet, 0, wx.LEFT | wx.TOP | wx.BOTTOM  | wx.ALIGN_CENTER_VERTICAL , 5)
        self.fbNewFleet.SetBackgroundColour( bgcolour )

        self.sl1 = wx.StaticLine( self, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.LI_VERTICAL )
        mainSizer.Add( self.sl1, 0, wx.EXPAND |wx.LEFT, 5 )

        self.tcFilter = wx.TextCtrl( self, wx.ID_ANY, wx.EmptyString, wx.DefaultPosition, wx.DefaultSize, 0 )
        mainSizer.Add( self.tcFilter, 0, wx.LEFT | wx.ALIGN_CENTER_VERTICAL, 5 )

        self.stStatus = wx.StaticText( self, wx.ID_ANY, u"", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.stStatus.Wrap( -1 )
        mainSizer.Add( self.stStatus, 1, wx.LEFT | wx.ALIGN_CENTER_VERTICAL, 5 )

        self.SetSizer(mainSizer)
        self.Layout()

        self.fbNewFleet.Bind(wx.EVT_ENTER_WINDOW, self.fbNewEnterWindow)
        self.fbNewFleet.Bind(wx.EVT_LEAVE_WINDOW, self.fbHItemLeaveWindow)
        self.fbNewFleet.Bind(wx.EVT_BUTTON, self.OnNewFleetItem)

        self.tcFilter.Bind(wx.EVT_TEXT, self.OnFilterText)

        self.tcFilter.Bind(wx.EVT_ENTER_WINDOW, self.fbFilterEnterWindow)
        self.tcFilter.Bind(wx.EVT_LEAVE_WINDOW, self.fbHItemLeaveWindow)

    def OnFilterText(self, event):
        filter = self.tcFilter.GetValue()
        self.Parent.SetFilter(filter)
        self.Parent.PopulateFleetList()
        event.Skip()

    def OnNewFleetItem(self, event):
        wx.PostEvent(self.Parent, FleetItemNew(fleetName = "New Fleet"))

    def fbNewEnterWindow(self, event):
        self.stStatus.SetLabel("New fleet")
        self.Parent.SetCursor(wx.StockCursor(wx.CURSOR_HAND))
        event.Skip()

    def fbHItemLeaveWindow(self, event):
        self.stStatus.SetLabel("")
        self.Parent.SetCursor(wx.StockCursor(wx.CURSOR_ARROW))
        event.Skip()

    def fbFilterEnterWindow(self, event):
        self.stStatus.SetLabel("Filter list")
        event.Skip()



class PFFleetItemContainer(PFListPane):
    def __init__(self,parent):
        PFListPane.__init__(self,parent)
        self.selectedWidget = -1
        self.Bind(wx.EVT_LEFT_UP, self.OnLeftUp)

    def IsWidgetSelectedByContext(self, widget):
        if self.GetWidgetList()[widget].IsSelected():
            return True
        return False

    def GetWidgetIndex(self, widgetWnd):
        return self.GetWidgetList().index(widgetWnd)

    def GetWidgetByFleetID(self, fleetID):
        for widget in self.GetWidgetList():
            if widget.fleetID == fleetID:
                return widget
        return None

    def SelectWidget(self, widgetWnd):
        wlist = self.GetWidgetList()
        if self.selectedWidget != -1:
            wlist[self.selectedWidget].SetSelected(False)
            wlist[self.selectedWidget].Refresh()
        windex = self.GetWidgetIndex(widgetWnd)
        wlist[windex].SetSelected(True)
        wlist[windex].Refresh()
        self.selectedWidget = windex

    def SelectWidgetByFleetID(self, fleetID):
        widgetWnd = self.GetWidgetByFleetID(fleetID)
        if widgetWnd:
            self.SelectWidget(widgetWnd)

    def RemoveWidget(self, child):
        child.Destroy()
        self.selectedWidget = -1
        self._wList.remove(child)


    def RemoveAllChildren(self):
        for widget in self._wList:
            widget.Destroy()

        self.selectedWidget = -1
        self._wList = []

    def OnLeftUp(self, event):
        event.Skip()

class FleetItem(SFItem.SFBrowserItem):
    def __init__(self, parent, fleetID, fleetName, fleetCount,
                 id=wx.ID_ANY, pos=wx.DefaultPosition,
                 size=(0,40), style=0):
        SFItem.SFBrowserItem.__init__(self, parent, size = size)

        self.fleetBrowser = self.Parent
        self.fleetID = fleetID
        self.fleetName = fleetName
        self.fleetCount = fleetCount

        self.padding = 4

        self.fontBig = wx.FontFromPixelSize((0,15),wx.SWISS, wx.NORMAL, wx.BOLD, False)
        self.fontNormal = wx.FontFromPixelSize((0,14),wx.SWISS, wx.NORMAL, wx.NORMAL, False)
        self.fontSmall = wx.FontFromPixelSize((0,12),wx.SWISS, wx.NORMAL, wx.NORMAL, False)

        self.copyBmp = bitmapLoader.getBitmap("fit_add_small", "icons")
        self.renameBmp = bitmapLoader.getBitmap("fit_rename_small", "icons")
        self.deleteBmp = bitmapLoader.getBitmap("fit_delete_small","icons")
        self.acceptBmp = bitmapLoader.getBitmap("faccept_small", "icons")
        self.fleetBmp = bitmapLoader.getBitmap("fleet_item_big", "icons")

        fleetImg = self.fleetBmp.ConvertToImage()
        fleetImg = fleetImg.Blur(2)

        if not fleetImg.HasAlpha():
            fleetImg.InitAlpha()

        fleetImg = fleetImg.AdjustChannels(1, 1, 1, 0.5)
        self.fleetEffBmp = wx.BitmapFromImage(fleetImg)

        self.toolbar.AddButton(self.copyBmp, "Copy", self.CopyFleetCB)
        self.renameBtn = self.toolbar.AddButton(self.renameBmp, "Rename", self.RenameFleetCB)
        self.toolbar.AddButton(self.deleteBmp, "Delete", self.DeleteFleetCB)

        self.editWidth = 150
        self.tcFleetName = wx.TextCtrl(self, wx.ID_ANY, "%s" % self.fleetName, wx.DefaultPosition, (self.editWidth,-1), wx.TE_PROCESS_ENTER)

        if self.fleetBrowser.fleetIDMustEditName != self.fleetID:
            self.tcFleetName.Show(False)
        else:
            self.tcFleetName.SetFocus()
            self.tcFleetName.SelectAll()
            self.fleetBrowser.fleetIDMustEditName = -1
            self.renameBtn.SetBitmap(self.acceptBmp)
            self.selected = True

        self.tcFleetName.Bind(wx.EVT_KILL_FOCUS, self.OnEditLostFocus)
        self.tcFleetName.Bind(wx.EVT_TEXT_ENTER, self.RenameFleet)
        self.tcFleetName.Bind(wx.EVT_KEY_DOWN, self.EditCheckEsc)


        self.animCount = 0

    def MouseLeftUp(self, event):
        if self.tcFleetName.IsShown():
            self.RestoreEditButton()
        else:
            wx.PostEvent(self.fleetBrowser, FleetItemSelect(fleetID = self.fleetID))

    def CopyFleetCB(self):
        if self.tcFleetName.IsShown():
            self.RestoreEditButton()
            return

        wx.PostEvent(self.fleetBrowser, FleetItemCopy(fleetID = self.fleetID))

    def RenameFleetCB(self):

        if self.tcFleetName.IsShown():

            self.RenameFleet(None)
            self.RestoreEditButton()

        else:
            self.tcFleetName.SetValue(self.fleetName)
            self.tcFleetName.Show()

            self.renameBtn.SetBitmap(self.acceptBmp)
            self.Refresh()

            self.tcFleetName.SetFocus()
            self.tcFleetName.SelectAll()

            self.Refresh()

    def RenameFleet(self, event):

        newFleetName = self.tcFleetName.GetValue()
        self.fleetName = newFleetName

        self.tcFleetName.Show(False)

        wx.PostEvent(self.fleetBrowser, FleetItemRename(fleetID = self.fleetID, fleetName = self.fleetName))
        self.Refresh()

    def DeleteFleetCB(self):
        if self.tcFleetName.IsShown():
            self.RestoreEditButton()
            return
        wx.PostEvent(self.fleetBrowser, FleetItemDelete(fleetID = self.fleetID))

    def RestoreEditButton(self):
            self.tcFleetName.Show(False)
            self.renameBtn.SetBitmap(self.renameBmp)
            self.Refresh()

    def OnEditLostFocus(self, event):
        self.RestoreEditButton()
        self.Refresh()

    def EditCheckEsc(self, event):
        if event.GetKeyCode() == wx.WXK_ESCAPE:
            self.RestoreEditButton()
        else:
            event.Skip()

    def IsSelected(self):
        return self.selected

    def UpdateElementsPos(self, mdc):
        rect = self.GetRect()

        self.toolbarx = rect.width - self.toolbar.GetWidth() - self.padding
        self.toolbary = (rect.height - self.toolbar.GetHeight()) / 2

        self.toolbarx = self.toolbarx + self.animCount

        self.fleetBmpx = self.padding + (rect.height - self.fleetBmp.GetWidth()) / 2
        self.fleetBmpy = (rect.height - self.fleetBmp.GetHeight()) / 2

        self.fleetBmpx -= self.animCount

        self.textStartx = self.fleetBmpx + self.fleetBmp.GetWidth() + self.padding

        self.fleetNamey = (rect.height - self.fleetBmp.GetHeight()) / 2

        mdc.SetFont(self.fontBig)
        wtext, htext = mdc.GetTextExtent(self.fleetName)

        self.fleetCounty = self.fleetNamey + htext

        mdc.SetFont(self.fontSmall)

        wlabel,hlabel = mdc.GetTextExtent(self.toolbar.hoverLabel)

        self.thoverx = self.toolbarx - self.padding - wlabel
        self.thovery = (rect.height - hlabel)/2
        self.thoverw = wlabel

    def DrawItem(self, mdc):
        rect = self.GetRect()

        windowColor = wx.SystemSettings_GetColour(wx.SYS_COLOUR_WINDOW)
        textColor = colorUtils.GetSuitableColor(windowColor, 1)

        mdc.SetTextForeground(textColor)

        self.UpdateElementsPos(mdc)

        self.toolbar.SetPosition((self.toolbarx, self.toolbary))
        mdc.DrawBitmap(self.fleetEffBmp, self.fleetBmpx + 3, self.fleetBmpy + 2)
        mdc.DrawBitmap(self.fleetBmp, self.fleetBmpx,self.fleetBmpy)

        mdc.SetFont(self.fontNormal)

        suffix = "%d ships" % self.fleetCount if self.fleetCount >1 else "%d ship" % self.fleetCount if self.fleetCount == 1 else "No ships"
        fleetCount = "Fleet size: %s" % suffix
        fleetCount = drawUtils.GetPartialText(mdc, fleetCount, self.toolbarx - self.textStartx - self.padding * 2 - self.thoverw)

        mdc.DrawText(fleetCount, self.textStartx, self.fleetCounty)

        mdc.SetFont(self.fontSmall)
        mdc.DrawText(self.toolbar.hoverLabel, self.thoverx, self.thovery)

        mdc.SetFont(self.fontBig)

        pfname = drawUtils.GetPartialText(mdc, self.fleetName, self.toolbarx - self.textStartx - self.padding * 2 - self.thoverw)
        mdc.DrawText(pfname, self.textStartx, self.fleetNamey)

        if self.tcFleetName.IsShown():
            self.AdjustControlSizePos(self.tcFleetName, self.textStartx, self.toolbarx - self.editWidth - self.padding)

    def AdjustControlSizePos(self, editCtl, start, end):
        fnEditSize = editCtl.GetSize()
        wSize = self.GetSize()
        fnEditPosX = end
        fnEditPosY = (wSize.height - fnEditSize.height)/2
        if fnEditPosX < start:
            editCtl.SetSize((self.editWidth + fnEditPosX - start,-1))
            editCtl.SetPosition((start,fnEditPosY))
        else:
            editCtl.SetSize((self.editWidth,-1))
            editCtl.SetPosition((fnEditPosX,fnEditPosY))


class PFGenBitmapButton(GenBitmapButton):
    def __init__(self, parent, id, bitmap, pos, size, style):
        GenBitmapButton.__init__(self, parent, id, bitmap, pos, size, style)
        self.bgcolor = wx.Brush(wx.WHITE)

    def SetBackgroundColour(self, color):
        self.bgcolor = wx.Brush(color)

    def GetBackgroundBrush(self, dc):
        return self.bgcolor
########NEW FILE########
__FILENAME__ = gangView
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================
import wx
from wx.lib.scrolledpanel import ScrolledPanel

import service
import gui.mainFrame
import gui.shipBrowser
import gui.globalEvents as GE

from gui import characterEditor as CharEditor


class GangView ( ScrolledPanel ):

    def __init__( self, parent ):
        ScrolledPanel.__init__ ( self, parent, id = wx.ID_ANY, pos = wx.DefaultPosition, size = wx.Size( 100,20 ), style = wx.TAB_TRAVERSAL | wx.HSCROLL | wx.VSCROLL )
        mainSizer = wx.BoxSizer( wx.VERTICAL )

        self.mainFrame = gui.mainFrame.MainFrame.getInstance()

        self.draggedFitID = None

        help = '''Set fit as booster to display in dropdown, or drag fitting from\nship browser to this window, or right click fit and select booster role.'''
        helpSizer = wx.BoxSizer( wx.HORIZONTAL )
        self.helpText = wx.StaticText( self, wx.ID_ANY, help, wx.DefaultPosition, wx.DefaultSize, wx.ALIGN_CENTRE )
        helpSizer.Add( self.helpText, 1, wx.ALL, 5 )

        self.FitDNDPopupMenu = wx.Menu()

        self.options = ["Fleet booster", "Wing booster", "Squad booster"]

        self.fleet = {}
        for id, option in enumerate(self.options):
            item = self.FitDNDPopupMenu.Append(-1, option)
            # We bind it to the mainFrame because it may be called from either this class or from FitItem via shipBrowser
            self.mainFrame.Bind(wx.EVT_MENU, self.OnPopupItemSelected, item)

            # set content for each commander
            self.fleet[id] = {}
            self.fleet[id]['stLabel']  = wx.StaticText( self, wx.ID_ANY, self.options[id]+':', wx.DefaultPosition, wx.DefaultSize, 0 )
            self.fleet[id]['stText']   = wx.StaticText( self, wx.ID_ANY, 'None', wx.DefaultPosition, wx.DefaultSize, 0 )
            self.fleet[id]['chFit']    = wx.Choice( self, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, [] )
            self.fleet[id]['chChar']   = wx.Choice( self, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, [] )
            self.fleet[id]['fitSizer'] = wx.BoxSizer( wx.VERTICAL )

        contentFGSizer = wx.FlexGridSizer( 5, 3, 0, 0 )
        contentFGSizer.AddGrowableCol( 1 )
        contentFGSizer.SetFlexibleDirection( wx.BOTH )
        contentFGSizer.SetNonFlexibleGrowMode( wx.FLEX_GROWMODE_SPECIFIED )

        ### Header
        self.oneonePlaceholder = wx.StaticText( self, wx.ID_ANY, wx.EmptyString, wx.DefaultPosition, wx.DefaultSize, 0 )
        self.oneonePlaceholder.Wrap( -1 )
        contentFGSizer.Add( self.oneonePlaceholder, 0, wx.ALIGN_CENTER_HORIZONTAL|wx.ALIGN_CENTER_VERTICAL, 5 )

        self.stFits = wx.StaticText( self, wx.ID_ANY, u"Fits", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.stFits.Wrap( -1 )
        self.stFits.SetFont( wx.Font( wx.NORMAL_FONT.GetPointSize(), 70, 90, 92, False, wx.EmptyString ) )
        contentFGSizer.Add( self.stFits, 0, wx.ALIGN_CENTER_VERTICAL|wx.ALIGN_CENTER_HORIZONTAL, 5 )

        self.stCharacters = wx.StaticText( self, wx.ID_ANY, u"Characters", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.stCharacters.Wrap( -1 )
        self.stCharacters.SetFont( wx.Font( wx.NORMAL_FONT.GetPointSize(), 70, 90, 92, False, wx.EmptyString ) )
        contentFGSizer.Add( self.stCharacters, 0, wx.ALIGN_CENTER_VERTICAL|wx.ALIGN_CENTER_HORIZONTAL, 5 )

        self.m_staticline2 = wx.StaticLine( self, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.LI_HORIZONTAL )
        contentFGSizer.Add( self.m_staticline2, 0, wx.EXPAND, 5 )

        self.m_staticline3 = wx.StaticLine( self, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.LI_HORIZONTAL )
        contentFGSizer.Add( self.m_staticline3, 0, wx.EXPAND, 5 )

        self.m_staticline4 = wx.StaticLine( self, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.LI_HORIZONTAL )
        contentFGSizer.Add( self.m_staticline4, 0, wx.EXPAND, 5 )

        ### Content
        for id in self.fleet:
            # set various properties
            self.fleet[id]['stLabel'].Wrap( -1 )
            self.fleet[id]['stLabel'].SetFont( wx.Font( wx.NORMAL_FONT.GetPointSize(), 70, 90, 92, False, wx.EmptyString ) )
            self.fleet[id]['stText'].Wrap( -1 )

            # bind text and choice events
            self.fleet[id]['stText'].Bind(wx.EVT_LEFT_DCLICK, self.RemoveBooster)
            self.fleet[id]['stText'].Bind(wx.EVT_ENTER_WINDOW, self.OnEnterWindow)
            self.fleet[id]['stText'].Bind(wx.EVT_LEAVE_WINDOW, self.OnLeaveWindow)
            self.fleet[id]['stText'].SetToolTip(wx.ToolTip("Double click to remove booster"))
            self.fleet[id]['chChar'].Bind(wx.EVT_CHOICE, self.CharChanged)
            self.fleet[id]['chFit'].Bind(wx.EVT_CHOICE, self.OnFitChoiceSelected)

            # add fit text and choice to the fit sizer
            self.fleet[id]['fitSizer'].Add( self.fleet[id]['stText'], 0, wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5 )
            self.fleet[id]['fitSizer'].Add( self.fleet[id]['chFit'], 0, wx.ALIGN_CENTER_VERTICAL|wx.ALL|wx.EXPAND, 1 )

            # add everything to the content sizer
            contentFGSizer.Add( self.fleet[id]['stLabel'], 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5 )
            contentFGSizer.Add( self.fleet[id]['fitSizer'], 0, wx.ALIGN_CENTER_VERTICAL|wx.ALL|wx.EXPAND, 5 )
            contentFGSizer.Add( self.fleet[id]['chChar'], 0, wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5 )

        mainSizer.Add( contentFGSizer, 1, wx.EXPAND, 0 )
        mainSizer.Add( helpSizer, 0, wx.EXPAND, 0 )

        self.SetSizer( mainSizer )
        self.SetAutoLayout(True)
        self.SetupScrolling()

        self.mainFrame.Bind(GE.CHAR_LIST_UPDATED, self.RefreshCharacterList)
        self.mainFrame.Bind(GE.FIT_CHANGED, self.fitSelected)
        self.mainFrame.Bind(gui.shipBrowser.EVT_FIT_RENAMED, self.fitRenamed)
        self.mainFrame.Bind(gui.shipBrowser.BOOSTER_LIST_UPDATED, self.RefreshBoosterFits)

        self.RefreshBoosterFits()
        self.RefreshCharacterList()

    def OnEnterWindow(self, event):
        obj = event.GetEventObject()
        obj.SetCursor(wx.StockCursor(wx.CURSOR_HAND))
        event.Skip()

    def OnLeaveWindow(self, event):
        obj = event.GetEventObject()
        obj.SetCursor(wx.StockCursor(wx.CURSOR_DEFAULT))
        event.Skip()

    def CharChanged(self, event):
        ''' Change booster character '''
        chBooster = event.GetEventObject()

        type = -1
        for id in self.fleet:
            if chBooster == self.fleet[id]['chChar']: type = id

        if type == -1:
            event.Skip()
            return

        cFit = service.Fit.getInstance()

        fleetSrv = service.Fleet.getInstance()

        activeFitID = self.mainFrame.getActiveFit()
        fit = cFit.getFit(activeFitID)

        cChar = service.Character.getInstance()
        charList = cChar.getCharacterList()

        if activeFitID:
            commanders = fleetSrv.loadLinearFleet(fit)
            if commanders is None:
                fleetCom, wingCom, squadCom = (None, None, None)
            else:
                fleetCom, wingCom, squadCom = commanders

            if type == 0:
                if fleetCom:
                    charID = chBooster.GetClientData(chBooster.GetSelection())
                    cFit.changeChar(fleetCom.ID, charID)
                else:
                    chBooster.SetSelection(0)

            if type == 1:
                if wingCom:
                    charID = chBooster.GetClientData(chBooster.GetSelection())
                    cFit.changeChar(wingCom.ID, charID)
                else:
                    chBooster.SetSelection(0)

            if type == 2:
                if squadCom:
                    charID = chBooster.GetClientData(chBooster.GetSelection())
                    cFit.changeChar(squadCom.ID, charID)
                else:
                    chBooster.SetSelection(0)

            cFit.recalc(fit, withBoosters=True)
            wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=activeFitID))

        else:
            chBooster.SetSelection(0)

    def RemoveBooster(self, event):
        activeFitID = self.mainFrame.getActiveFit()
        if  not activeFitID:
            return

        location = event.GetEventObject()

        for id in self.fleet:
            if location == self.fleet[id]['stText']: type = id

        sFit = service.Fit.getInstance()
        boostee = sFit.getFit(activeFitID)
        booster = None

        fleetSrv = service.Fleet.getInstance()

        if type == 0: fleetSrv.setLinearFleetCom(boostee, booster)
        if type == 1: fleetSrv.setLinearWingCom(boostee, booster)
        if type == 2: fleetSrv.setLinearSquadCom(boostee, booster)

        # Hide stText and, default fit selection, and enable it
        location.Hide()
        choice = self.fleet[type]['chFit']
        choice.SetSelection(0)
        choice.Show()

        sFit.recalc(boostee, withBoosters=True)
        wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=activeFitID))

    def fitRenamed(self, event):
        fleetSrv = service.Fleet.getInstance()
        activeFitID = self.mainFrame.getActiveFit()

        if activeFitID:
            ev = event
            ev.fitID = activeFitID
            self.fitSelected(ev)

    def fitSelected(self, event):
        ''' Fires when active fit is selected and when booster is saved to fit. Update the UI to reflect changes '''
        fleetSrv = service.Fleet.getInstance()

        activeFitID = self.mainFrame.getActiveFit()
        cFit = service.Fit.getInstance()
        fit = cFit.getFit(event.fitID or activeFitID)
        commanders = (None, None, None)

        if activeFitID:
            commanders = fleetSrv.loadLinearFleet(fit)

        for id in self.fleet:
            # try...except here as we're trying 2 different criteria and want to fall back on the same code
            try:
                commander = commanders[id]

                if not activeFitID or commander is None:
                    raise Exception()

                self.fleet[id]['stText'].SetLabel(commander.ship.item.name + ": " + commander.name)
                self.fleet[id]['chChar'].SetStringSelection(commander.character.name if commander.character is not None else "All 0")
                self.fleet[id]['chChar'].Enable()
                self.fleet[id]['chFit'].Hide()
                self.fleet[id]['stText'].Show()
            except:
                #set defaults, disable char selection, and enable fit selection
                self.fleet[id]['stText'].SetLabel("None")
                self.fleet[id]['chChar'].SetStringSelection("All 0")
                self.fleet[id]['chChar'].Disable()
                self.fleet[id]['chFit'].SetSelection(0)
                self.fleet[id]['chFit'].Show()
                self.fleet[id]['stText'].Hide()

        if activeFitID:
            self.Enable()
        else:
            self.Disable()

        self.Layout()
        self.SendSizeEvent()

    def AddCommander(self, fitID, type = None):
        ''' Adds booster to a fit, then recalculates active fit '''
        if type is None:
            return

        activeFitID = self.mainFrame.getActiveFit()
        if activeFitID:
            sFit = service.Fit.getInstance()

            boostee = sFit.getFit(activeFitID)
            booster = sFit.getFit(fitID)

            fleetSrv = service.Fleet.getInstance()

            if type == 0: fleetSrv.setLinearFleetCom(boostee, booster)
            if type == 1: fleetSrv.setLinearWingCom(boostee, booster)
            if type == 2: fleetSrv.setLinearSquadCom(boostee, booster)

            sFit.recalc(boostee)
            wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=activeFitID))

    def RefreshBoosterFits(self, event = None):
        sFit    = service.Fit.getInstance()
        sMarket = service.Market.getInstance()
        fitList = sFit.getBoosterFits()

        for id in self.fleet:
            choice = self.fleet[id]['chFit']
            chCurrSelection = choice.GetSelection()
            chCurrData = -1
            if chCurrSelection != -1:
                chCurrData = choice.GetClientData(chCurrSelection)
                chCurrSelString = choice.GetString(chCurrSelection)
            choice.Clear()
            currSelFound = False
            choice.Append("None", -1)
            for fit in fitList:
                id,name,type = fit
                ship = sMarket.getItem(type)
                choice.Append(ship.name+': '+name, id)
                if chCurrData == id:
                    currSelFound = True

            if chCurrSelection == -1:
                choice.SetSelection(0)
            else:
                if currSelFound:
                    choice.SetStringSelection(chCurrSelString)
                else:
                    choice.SetSelection(0)

    def RefreshCharacterList(self, event = None):
        cChar = service.Character.getInstance()
        charList = cChar.getCharacterList()
        for id in self.fleet:
            choice = self.fleet[id]['chChar']
            chCurrSelection = choice.GetSelection()
            chCurrData = -1
            if chCurrSelection != -1:
                chCurrData = choice.GetClientData(chCurrSelection)
                chCurrSelString = choice.GetString(chCurrSelection)
            choice.Clear()
            currSelFound = False
            for char in charList:
                id,name,_ = char
                choice.Append(name, id)
                if chCurrData == id:
                    currSelFound = True

            if chCurrSelection == -1:
                choice.SetSelection(1)
            else:
                if currSelFound:
                    choice.SetStringSelection(chCurrSelString)
                else:
                    choice.SetSelection(1)

    def handleDrag(self, type, fitID):
        ''' Handle dragging of fit to fleet interface '''
        #Those are drags coming from pyfa sources, NOT builtin wx drags
        self.draggedFitID = None
        if type == "fit":
            activeFit = self.mainFrame.getActiveFit()
            if activeFit:
                self.draggedFitID = fitID

                pos = wx.GetMousePosition()
                pos = self.ScreenToClient(pos)

                self.PopupMenu(self.FitDNDPopupMenu, pos)


    def OnPopupItemSelected(self, event):
        ''' Fired when booster popup item is selected '''
        # Get menu selection ID via self.options
        menuItem = self.FitDNDPopupMenu.FindItemById(event.GetId())
        type = self.options.index(menuItem.GetText())

        if self.draggedFitID:
            sFit = service.Fit.getInstance()
            draggedFit = sFit.getFit(self.draggedFitID)

            self.AddCommander(draggedFit.ID, type)
            self.mainFrame.additionsPane.select("Fleet")

    def OnFitChoiceSelected(self, event):
        ''' Fired when booster choice is selected '''
        sFit = service.Fit.getInstance()

        # set type via choice box used
        chFit = event.GetEventObject()
        fitID = chFit.GetClientData(chFit.GetSelection())

        type = -1
        for id in self.fleet:
            if chFit == self.fleet[id]['chFit']: type = id

        if type == -1 or fitID == -1:
            event.Skip()
            return

        fit = sFit.getFit(fitID)

        self.AddCommander(fit.ID, type)
        self.mainFrame.additionsPane.select("Fleet")
########NEW FILE########
__FILENAME__ = globalEvents
import wx.lib.newevent

FitChanged, FIT_CHANGED = wx.lib.newevent.NewEvent()
CharListUpdated, CHAR_LIST_UPDATED = wx.lib.newevent.NewEvent()
CharChanged, CHAR_CHANGED = wx.lib.newevent.NewEvent()

########NEW FILE########
__FILENAME__ = graph
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

class Graph(object):
    views = []

    @classmethod
    def register(cls):
        Graph.views.append(cls)

    def __init__(self):
        self.name = ""

    def getFields(self, fit, fields):
        raise NotImplementedError()

    def getIcons(self):
        return None

from gui.builtinGraphs import *

########NEW FILE########
__FILENAME__ = graphFrame
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import wx
import bitmapLoader
import gui.display
import gui.globalEvents as GE

from gui.graph import Graph
import service
import gui.mainFrame

enabled = True
mplImported = False

class GraphFrame(wx.Frame):
    def __init__(self, parent, style=wx.DEFAULT_FRAME_STYLE | wx.NO_FULL_REPAINT_ON_RESIZE | wx.FRAME_FLOAT_ON_PARENT):

        global enabled
        global mplImported

        self.legendFix = False
        if not enabled:
            return

        try:
            import matplotlib as mpl
            if not mplImported:
                mpl.use('wxagg')
            from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as Canvas
            from matplotlib.figure import Figure
            enabled = True
            if mpl.__version__[0] != "1":
                print "pyfa: Found matplotlib version ",mpl.__version__, " - activating OVER9000 workarounds"
                print "pyfa: Recommended minimum matplotlib version is 1.0.0"
                self.legendFix = True
        except:
            print "Problems importing matplotlib; continuing without graphs"
            enabled = False
            return

        mplImported = True

        wx.Frame.__init__(self, parent, title=u"pyfa: Graph Generator", style=style, size=(520, 390))

        i = wx.IconFromBitmap(bitmapLoader.getBitmap("graphs_small", "icons"))
        self.SetIcon(i)
        self.mainFrame = gui.mainFrame.MainFrame.getInstance()
        self.CreateStatusBar()

        self.mainSizer = wx.BoxSizer(wx.VERTICAL)
        self.SetSizer(self.mainSizer)

        sFit = service.Fit.getInstance()
        fit = sFit.getFit(self.mainFrame.getActiveFit())
        self.fits = [fit] if fit is not None else []
        self.fitList = FitList(self)
        self.fitList.SetMinSize((270, -1))

        self.fitList.fitList.update(self.fits)

        self.graphSelection = wx.Choice(self, wx.ID_ANY, style=0)
        self.mainSizer.Add(self.graphSelection, 0, wx.EXPAND)

        self.figure = Figure(figsize=(4, 3))

        rgbtuple = wx.SystemSettings.GetColour( wx.SYS_COLOUR_BTNFACE ).Get()
        clr = [c/255. for c in rgbtuple]
        self.figure.set_facecolor( clr )
        self.figure.set_edgecolor( clr )

        self.canvas = Canvas(self, -1, self.figure)
        self.canvas.SetBackgroundColour( wx.Colour( *rgbtuple ) )

        self.subplot = self.figure.add_subplot(111)
        self.subplot.grid(True)

        self.mainSizer.Add(self.canvas, 1, wx.EXPAND)
        self.mainSizer.Add(wx.StaticLine( self, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.LI_HORIZONTAL ), 0 , wx.EXPAND)

        self.gridPanel = wx.Panel(self)
        self.mainSizer.Add(self.gridPanel, 0, wx.EXPAND)

        dummyBox = wx.BoxSizer(wx.VERTICAL)
        self.gridPanel.SetSizer(dummyBox)

        self.gridSizer = wx.FlexGridSizer(0, 4)
        self.gridSizer.AddGrowableCol(1)
        dummyBox.Add(self.gridSizer, 0, wx.EXPAND)

        for view in Graph.views:
            view = view()
            self.graphSelection.Append(view.name, view)

        self.graphSelection.SetSelection(0)
        self.fields = {}
        self.select(0)
        self.sl1 = wx.StaticLine( self, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.LI_HORIZONTAL )
        self.mainSizer.Add(self.sl1,0, wx.EXPAND)
        self.mainSizer.Add(self.fitList, 0, wx.EXPAND)

        self.fitList.fitList.Bind(wx.EVT_LEFT_DCLICK, self.removeItem)
        self.mainFrame.Bind(GE.FIT_CHANGED, self.draw)
        self.Bind(wx.EVT_CLOSE, self.close)

        self.Fit()
        self.SetMinSize(self.GetSize())

    def handleDrag(self, type, fitID):
        if type == "fit":
            self.AppendFitToList(fitID)

    def close(self, event):
        self.fitList.fitList.Unbind(wx.EVT_LEFT_DCLICK, handler=self.removeItem)
        self.mainFrame.Unbind(GE.FIT_CHANGED, handler=self.draw)
        event.Skip()

    def getView(self):
        return self.graphSelection.GetClientData(self.graphSelection.GetSelection())

    def getValues(self):
        values = {}
        for fieldName, field in self.fields.iteritems():
            values[fieldName] = field.GetValue()

        return values

    def select(self, index):
        view = self.getView()
        icons = view.getIcons()
        labels = view.getLabels()
        sizer = self.gridSizer
        self.gridPanel.DestroyChildren()
        self.fields.clear()

        #Setup textboxes
        for field, defaultVal in view.getFields().iteritems():

            textBox = wx.TextCtrl(self.gridPanel, wx.ID_ANY, style=0)
            self.fields[field] = textBox
            textBox.Bind(wx.EVT_TEXT, self.onFieldChanged)
            sizer.Add(textBox, 1, wx.EXPAND | wx.ALIGN_CENTER_VERTICAL  | wx.ALL, 3)
            if defaultVal is not None:
                if not isinstance(defaultVal, basestring):
                    defaultVal = ("%f" % defaultVal).rstrip("0")
                    if defaultVal[-1:] == ".":
                        defaultVal = defaultVal + "0"

                textBox.ChangeValue(defaultVal)

            imgLabelSizer = wx.BoxSizer(wx.HORIZONTAL)
            if icons:
                icon = icons.get(field)
                if icon is not None:
                    static = wx.StaticBitmap(self.gridPanel)
                    static.SetBitmap(icon)
                    imgLabelSizer.Add(static, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 1)

            if labels:
                label = labels.get(field)
                label = label if label is not None else field
            else:
                label = field

            imgLabelSizer.Add(wx.StaticText(self.gridPanel, wx.ID_ANY, label), 0, wx.LEFT | wx.RIGHT | wx.ALIGN_CENTER_VERTICAL, 3)
            sizer.Add(imgLabelSizer, 0, wx.ALIGN_CENTER_VERTICAL)
        self.draw()

    def draw(self, event=None):
        values = self.getValues()
        view = self.getView()
        self.subplot.clear()
        self.subplot.grid(True)
        legend = []

        for fit in self.fits:
            try:
                success, status = view.getPoints(fit, values)
                if not success:
                    #TODO: Add a pwetty statys bar to report errors with
                    self.SetStatusText(status)
                    return

                x, y = success, status

                self.subplot.plot(x, y)
                legend.append(fit.name)
            except:
                self.SetStatusText("Invalid values in '%s'" % fit.name)

        if self.legendFix and len(legend) > 0:
            leg = self.subplot.legend(tuple(legend), "upper right" , shadow = False)
            for t in leg.get_texts():
                t.set_fontsize('small')

            for l in leg.get_lines():
                l.set_linewidth(1)

        elif not self.legendFix and len(legend) >0:
            leg = self.subplot.legend(tuple(legend), "upper right" , shadow = False, frameon = False)
            for t in leg.get_texts():
                t.set_fontsize('small')

            for l in leg.get_lines():
                l.set_linewidth(1)

        self.canvas.draw()
        self.SetStatusText("")
        if event is not None:
            event.Skip()

    def onFieldChanged(self, event):
        self.draw()

    def AppendFitToList(self, fitID):
        sFit = service.Fit.getInstance()
        fit = sFit.getFit(fitID)
        if fit not in self.fits:
            self.fits.append(fit)

        self.fitList.fitList.update(self.fits)
        self.draw()

    def removeItem(self, event):
        row, _ = self.fitList.fitList.HitTest(event.Position)
        if row != -1:
            del self.fits[row]
            self.fitList.fitList.update(self.fits)
            self.draw()


class FitList(wx.Panel):
    def __init__(self, parent):
        wx.Panel.__init__(self, parent)
        self.mainSizer = wx.BoxSizer(wx.VERTICAL)
        self.SetSizer(self.mainSizer)

        self.fitList = FitDisplay(self)
        self.mainSizer.Add(self.fitList, 1, wx.EXPAND)
        fitToolTip = wx.ToolTip("Drag a fit into this list to graph it")
        self.fitList.SetToolTip(fitToolTip)

class FitDisplay(gui.display.Display):
    DEFAULT_COLS = ["Base Icon",
                    "Base Name"]

    def __init__(self, parent):
        gui.display.Display.__init__(self, parent)


########NEW FILE########
__FILENAME__ = implantView
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import wx
import service
import gui.display as d
import gui.marketBrowser as mb
from gui.builtinViewColumns.state import State
from gui.contextMenu import ContextMenu
import globalEvents as GE
class ImplantView(d.Display):
    DEFAULT_COLS = ["State",
                    "attr:implantness",
                    "Base Name"]

    def __init__(self, parent):
        d.Display.__init__(self, parent, style=wx.LC_SINGLE_SEL | wx.BORDER_NONE)

        self.lastFitId = None

        self.mainFrame.Bind(GE.FIT_CHANGED, self.fitChanged)
        self.mainFrame.Bind(mb.ITEM_SELECTED, self.addItem)
        self.Bind(wx.EVT_LEFT_DCLICK, self.removeItem)
        self.Bind(wx.EVT_LEFT_DOWN, self.click)
        self.Bind(wx.EVT_KEY_UP, self.kbEvent)

        if "__WXGTK__" in  wx.PlatformInfo:
            self.Bind(wx.EVT_RIGHT_UP, self.scheduleMenu)
        else:
            self.Bind(wx.EVT_RIGHT_DOWN, self.scheduleMenu)

    def kbEvent(self,event):
        keycode = event.GetKeyCode()
        if keycode == wx.WXK_DELETE or keycode == wx.WXK_NUMPAD_DELETE:
            row = self.GetFirstSelected()
            if row != -1:
                self.removeImplant(self.implants[self.GetItemData(row)])
        event.Skip()

    def fitChanged(self, event):
        #Clear list and get out if current fitId is None
        if event.fitID is None and self.lastFitId is not None:
            self.DeleteAllItems()
            self.lastFitId = None
            event.Skip()
            return

        cFit = service.Fit.getInstance()
        fit = cFit.getFit(event.fitID)

        self.original = fit.implants if fit is not None else None
        self.implants = stuff = fit.implants if fit is not None else None
        if stuff is not None: stuff.sort(key=lambda implant: implant.slot)

        if event.fitID != self.lastFitId:
            self.lastFitId = event.fitID

            item = self.GetNextItem(-1, wx.LIST_NEXT_ALL, wx.LIST_STATE_DONTCARE)

            if item != -1:
                self.EnsureVisible(item)

            self.deselectItems()

        self.populate(stuff)
        self.refresh(stuff)
        event.Skip()

    def addItem(self, event):
        cFit = service.Fit.getInstance()
        fitID = self.mainFrame.getActiveFit()
        trigger = cFit.addImplant(fitID, event.itemID)
        if trigger:
            wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=fitID))
            self.mainFrame.additionsPane.select("Implants")

        event.Skip()

    def removeItem(self, event):
        row, _ = self.HitTest(event.Position)
        if row != -1:
            col = self.getColumn(event.Position)
            if col != self.getColIndex(State):
                self.removeImplant(self.implants[self.GetItemData(row)])
                
    def removeImplant(self, implant):
        fitID = self.mainFrame.getActiveFit()
        cFit = service.Fit.getInstance()
        cFit.removeImplant(fitID, self.original.index(implant))
        wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=fitID))

    def click(self, event):
        event.Skip()
        row, _ = self.HitTest(event.Position)
        if row != -1:
            col = self.getColumn(event.Position)
            if col == self.getColIndex(State):
                fitID = self.mainFrame.getActiveFit()
                cFit = service.Fit.getInstance()
                cFit.toggleImplant(fitID, row)
                wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=fitID))

    def scheduleMenu(self, event):
        event.Skip()
        if self.getColumn(event.Position) != self.getColIndex(State):
            wx.CallAfter(self.spawnMenu)

    def spawnMenu(self):
        sel = self.GetFirstSelected()
        if sel != -1:
            cFit = service.Fit.getInstance()
            fit = cFit.getFit(self.mainFrame.getActiveFit())
            implant = fit.implants[sel]

            sMkt = service.Market.getInstance()
            sourceContext = "implantItem"
            itemContext = sMkt.getCategoryByItem(implant.item).name

            menu = ContextMenu.getMenu((implant,), (sourceContext, itemContext))
            self.PopupMenu(menu)

########NEW FILE########
__FILENAME__ = itemStats
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import wx
import re
import gui.mainFrame
import bitmapLoader
import sys
import wx.lib.mixins.listctrl  as  listmix
import wx.html
from eos.types import Ship, Module, Skill, Booster, Implant, Drone
from gui.utils.numberFormatter import formatAmount
import service

try:
    from collections import OrderedDict
except ImportError:
    from gui.utils.compat import OrderedDict

class ItemStatsDialog(wx.Dialog):
    counter = 0
    def __init__(self, victim, fullContext=None, pos = wx.DefaultPosition, size = wx.DefaultSize, maximized = False):
        wx.Dialog.__init__(self,
                          gui.mainFrame.MainFrame.getInstance(),
                          wx.ID_ANY, title="Item stats", pos = pos, size = size,
                          style = wx.CAPTION | wx.CLOSE_BOX | wx.MINIMIZE_BOX |
                                  wx.MAXIMIZE_BOX | wx.RESIZE_BORDER| wx.SYSTEM_MENU)

        empty = getattr(victim, "isEmpty", False)

        if empty:
            self.Hide()
            self.Destroy()
            return

        srcContext = fullContext[0]
        try:
            itmContext = fullContext[1]
        except IndexError:
            itmContext = None
        item = getattr(victim, "item", None) if srcContext.lower() not in ("projectedcharge", "fittingcharge") else getattr(victim, "charge", None)
        if item is None:
            sMarket = service.Market.getInstance()
            item = sMarket.getItem(victim.ID)
            victim = None
        self.context = itmContext
        if item.icon is not None:
            before,sep,after = item.icon.iconFile.rpartition("_")
            iconFile = "%s%s%s" % (before,sep,"0%s" % after if len(after) < 2 else after)
            itemImg = bitmapLoader.getBitmap(iconFile, "pack")
            if itemImg is not None:
                self.SetIcon(wx.IconFromBitmap(itemImg))
        self.SetTitle("%s: %s" % ("%s Stats" % itmContext if itmContext is not None else "Stats", item.name))

        self.SetMinSize((300, 200))
        self.SetSize((500, 300))
        self.SetMaxSize((500, -1))
        self.mainSizer = wx.BoxSizer(wx.VERTICAL)
        self.container = ItemStatsContainer(self, victim, item, itmContext)
        self.mainSizer.Add(self.container, 1, wx.EXPAND)

        if "wxGTK" in wx.PlatformInfo:
            self.closeBtn = wx.Button( self, wx.ID_ANY, u"Close", wx.DefaultPosition, wx.DefaultSize, 0 )
            self.mainSizer.Add( self.closeBtn, 0, wx.ALL|wx.ALIGN_RIGHT, 5 )
            self.closeBtn.Bind(wx.EVT_BUTTON, self.closeEvent)

        self.SetSizer(self.mainSizer)

        self.parentWnd = gui.mainFrame.MainFrame.getInstance()

        dlgsize = self.GetSize()
        psize = self.parentWnd.GetSize()
        ppos = self.parentWnd.GetPosition()

        ItemStatsDialog.counter += 1
        self.dlgOrder = ItemStatsDialog.counter

        counter = ItemStatsDialog.counter
        dlgStep = 30
        if counter * dlgStep > ppos.x+psize.width-dlgsize.x or counter * dlgStep > ppos.y+psize.height-dlgsize.y:
            ItemStatsDialog.counter = 1

        dlgx = ppos.x + counter * dlgStep
        dlgy = ppos.y + counter * dlgStep
        if pos == wx.DefaultPosition:
            self.SetPosition((dlgx,dlgy))
        else:
            self.SetPosition(pos)
        if maximized:
            self.Maximize(True)
        else:
            if size != wx.DefaultSize:
                self.SetSize(size)
        self.parentWnd.RegisterStatsWindow(self)

        self.Show()

        self.Bind(wx.EVT_CLOSE, self.closeEvent)
        self.Bind(wx.EVT_ACTIVATE, self.OnActivate)

    def OnActivate(self, event):
        self.parentWnd.SetActiveStatsWindow(self)

    def closeEvent(self, event):

        if self.dlgOrder==ItemStatsDialog.counter:
            ItemStatsDialog.counter -= 1
        self.parentWnd.UnregisterStatsWindow(self)

        self.Destroy()

###########################################################################
## Class ItemStatsContainer
###########################################################################

class ItemStatsContainer ( wx.Panel ):

    def __init__( self, parent, stuff, item, context = None):
        wx.Panel.__init__ ( self, parent )
        mainSizer = wx.BoxSizer( wx.VERTICAL )

        self.nbContainer = wx.Notebook( self, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, 0 )
        mainSizer.Add( self.nbContainer, 1, wx.EXPAND |wx.ALL, 2 )

        if len(item.traits) != 0:
            self.traits = ItemTraits(self.nbContainer, stuff, item)
            self.nbContainer.AddPage(self.traits, "Traits")

        self.desc = ItemDescription(self.nbContainer, stuff, item)
        self.nbContainer.AddPage(self.desc, "Description")

        self.params = ItemParams(self.nbContainer, stuff, item, context)
        self.nbContainer.AddPage(self.params, "Attributes")

        self.reqs = ItemRequirements(self.nbContainer, stuff, item)
        self.nbContainer.AddPage(self.reqs, "Requirements")

        self.effects = ItemEffects(self.nbContainer, stuff, item)
        self.nbContainer.AddPage(self.effects, "Effects")

        if stuff is not None:
            self.affectedby = ItemAffectedBy(self.nbContainer, stuff, item)
            self.nbContainer.AddPage(self.affectedby, "Affected by")

        self.nbContainer.Bind(wx.EVT_LEFT_DOWN, self.mouseHit)
        self.SetSizer(mainSizer)
        self.Layout()

    def __del__( self ):
        pass

    def mouseHit(self, event):
        tab, _ = self.nbContainer.HitTest(event.Position)
        if tab != -1:
            self.nbContainer.SetSelection(tab)

###########################################################################
## Class AutoListCtrl
###########################################################################

class AutoListCtrl(wx.ListCtrl, listmix.ListCtrlAutoWidthMixin, listmix.ListRowHighlighter):

    def __init__(self, parent, ID, pos=wx.DefaultPosition,
                 size=wx.DefaultSize, style=0):
        wx.ListCtrl.__init__(self, parent, ID, pos, size, style)
        listmix.ListCtrlAutoWidthMixin.__init__(self)
        listmix.ListRowHighlighter.__init__(self)

###########################################################################
## Class AutoListCtrl
###########################################################################

class AutoListCtrlNoHighlight(wx.ListCtrl, listmix.ListCtrlAutoWidthMixin, listmix.ListRowHighlighter):

    def __init__(self, parent, ID, pos=wx.DefaultPosition,
                 size=wx.DefaultSize, style=0):
        wx.ListCtrl.__init__(self, parent, ID, pos, size, style)
        listmix.ListCtrlAutoWidthMixin.__init__(self)

###########################################################################
## Class ItemTraits
###########################################################################

class ItemTraits ( wx.Panel ):

    def __init__(self, parent, stuff, item):
        wx.Panel.__init__ (self, parent)
        mainSizer = wx.BoxSizer(wx.VERTICAL)
        self.SetSizer(mainSizer)

        self.traits = wx.html.HtmlWindow(self)

        # Format: {skill name: [bonus text]}
        traitData = {}
        for trait in item.traits:
            skillData = traitData.setdefault(trait.skillName, [])
            skillData.append(trait.bonusText)

        def getSection(header, rows):
            sectionRows = [header]
            for row in sorted(rows):
                sectionRows.append(row)
            return u'<br />'.join(sectionRows)

        textRows = []
        for skillName in sorted(traitData):
            # Skills always go 1st
            if skillName is None:
                continue
            header = u"<b>{} bonuses (per skill level):</b>".format(skillName)
            textRows.append(getSection(header, traitData[skillName]))

        if None in traitData:
            textRows.append(getSection("<b>Role Bonus:</b>", traitData[None]))

        fullText = u"<br /><br />".join(textRows)
        self.traits.SetPage(fullText)

        mainSizer.Add(self.traits, 1, wx.ALL|wx.EXPAND, 0)
        self.Layout()

###########################################################################
## Class ItemDescription
###########################################################################

class ItemDescription ( wx.Panel ):

    def __init__(self, parent, stuff, item):
        wx.Panel.__init__ (self, parent)
        mainSizer = wx.BoxSizer(wx.VERTICAL)
        self.SetSizer(mainSizer)

        bgcolor = wx.SystemSettings_GetColour(wx.SYS_COLOUR_WINDOW)
        fgcolor = wx.SystemSettings_GetColour(wx.SYS_COLOUR_WINDOWTEXT)

        self.description = wx.html.HtmlWindow(self)
        desc = item.description.replace("\r", "<br>")
        # Strip font tags
        desc = re.sub("<( *)font( *)color( *)=(.*?)>(?P<inside>.*?)<( *)/( *)font( *)>", "\g<inside>", desc)
        # Strip URLs
        desc = re.sub("<( *)a(.*?)>(?P<inside>.*?)<( *)/( *)a( *)>", "\g<inside>", desc)
        desc = "<body bgcolor='" + bgcolor.GetAsString(wx.C2S_HTML_SYNTAX) + "' text='" + fgcolor.GetAsString(wx.C2S_HTML_SYNTAX) + "' >" + desc + "</body>"

        self.description.SetPage(desc)

        mainSizer.Add(self.description, 1, wx.ALL|wx.EXPAND, 0)
        self.Layout()

###########################################################################
## Class ItemParams
###########################################################################

class ItemParams (wx.Panel):
    def __init__(self, parent, stuff, item, context = None):
        wx.Panel.__init__ (self, parent)
        mainSizer = wx.BoxSizer( wx.VERTICAL )

        self.paramList = AutoListCtrl(self, wx.ID_ANY,
                                     style = #wx.LC_HRULES |
                                      #wx.LC_NO_HEADER |
                                      wx.LC_REPORT |wx.LC_SINGLE_SEL |wx.LC_VRULES |wx.NO_BORDER)
        mainSizer.Add( self.paramList, 1, wx.ALL|wx.EXPAND, 0 )
        self.SetSizer( mainSizer )

        self.toggleView = 1
        self.stuff = stuff
        self.item = item

        self.m_staticline = wx.StaticLine( self, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.LI_HORIZONTAL )
        mainSizer.Add( self.m_staticline, 0, wx.EXPAND)
        bSizer = wx.BoxSizer( wx.HORIZONTAL )

        self.totalAttrsLabel = wx.StaticText( self, wx.ID_ANY, u" ", wx.DefaultPosition, wx.DefaultSize, 0 )
        bSizer.Add( self.totalAttrsLabel, 0, wx.ALIGN_CENTER_VERTICAL|wx.RIGHT)

        self.toggleViewBtn = wx.ToggleButton( self, wx.ID_ANY, u"Toggle view mode", wx.DefaultPosition, wx.DefaultSize, 0 )
        bSizer.Add( self.toggleViewBtn, 0, wx.ALIGN_CENTER_VERTICAL)

        if stuff is not None:
            self.refreshBtn = wx.Button( self, wx.ID_ANY, u"Refresh", wx.DefaultPosition, wx.DefaultSize, 0 )
            bSizer.Add( self.refreshBtn, 0, wx.ALIGN_CENTER_VERTICAL)
            self.refreshBtn.Bind( wx.EVT_BUTTON, self.RefreshValues )

        mainSizer.Add( bSizer, 0, wx.ALIGN_RIGHT)

        self.PopulateList()

        self.toggleViewBtn.Bind(wx.EVT_TOGGLEBUTTON,self.ToggleViewMode)

    def UpdateList(self):
        self.Freeze()
        self.paramList.ClearAll()
        self.PopulateList()
        self.Thaw()
        self.paramList.resizeLastColumn(100)

    def RefreshValues(self, event):
        self.UpdateList()
        event.Skip()

    def ToggleViewMode(self, event):
        self.toggleView *=-1
        self.UpdateList()
        event.Skip()

    def PopulateList(self):
        self.paramList.InsertColumn(0,"Attribute")
        self.paramList.InsertColumn(1,"Value")
        self.paramList.SetColumnWidth(1,150)
        self.paramList.setResizeColumn(1)
        self.imageList = wx.ImageList(16, 16)
        self.paramList.SetImageList(self.imageList,wx.IMAGE_LIST_SMALL)
        if self.stuff is None or self.stuff.item == self.item:
            attrs = self.stuff.itemModifiedAttributes if self.stuff is not None else self.item.attributes
            attrsInfo = self.item.attributes if self.stuff is None else self.stuff.item.attributes
        else:
            attrs = self.stuff.chargeModifiedAttributes if self.stuff is not None else self.item.attributes
            attrsInfo = self.item.attributes if self.stuff is None else self.stuff.charge.attributes

        names = list(attrs.iterkeys())
        names.sort()

        idNameMap = {}
        idCount = 0
        for name in names:
            info = attrsInfo.get(name)


            att = attrs[name]
            val = getattr(att, "value", None)
            value = val if val is not None else att

            if info and info.displayName and self.toggleView == 1:
                attrName = info.displayName
            else:
                attrName = name

            if info:
                if info.icon is not None:
                    iconFile = info.icon.iconFile
                    icon = bitmapLoader.getBitmap(iconFile, "pack")

                    if icon is None:
                        icon = bitmapLoader.getBitmap("transparent16x16", "icons")

                    attrIcon = self.imageList.Add(icon)
                else:
                    attrIcon = self.imageList.Add(bitmapLoader.getBitmap("07_15", "pack"))
            else:
                attrIcon = self.imageList.Add(bitmapLoader.getBitmap("07_15", "pack"))


            index = self.paramList.InsertImageStringItem(sys.maxint, attrName,attrIcon)
            idNameMap[idCount] = attrName
            self.paramList.SetItemData(index, idCount)
            idCount += 1

            if self.toggleView != 1:
                valueUnit = str(value)
            elif info and info.unit:
                valueUnit = self.TranslateValueUnit(value, info.unit.displayName, info.unit.name)
            else:
                valueUnit = formatAmount(value, 3, 0, 0)


            self.paramList.SetStringItem(index, 1, valueUnit)



        self.paramList.SortItems(lambda id1, id2: cmp(idNameMap[id1], idNameMap[id2]))
        self.paramList.RefreshRows()
        self.totalAttrsLabel.SetLabel("%d attributes. " %idCount)
        self.Layout()

    def TranslateValueUnit(self, value, unitName, unitDisplayName):
        def itemIDCallback():
            item = service.Market.getInstance().getItem(value)
            return "%s (%d)" % (item.name, value) if item is not None else str(value)

        def groupIDCallback():
            group = service.Market.getInstance().getGroup(value)
            return "%s (%d)" % (group.name, value) if group is not None else str(value)

        def attributeIDCallback():
            attribute = service.Attribute.getInstance().getAttributeInfo(value)
            return "%s (%d)" % (attribute.name.capitalize(), value)

        trans = {"Inverse Absolute Percent": (lambda: (1-value)*100, unitName),
                 "Inversed Modifier Percent": (lambda: (1-value) * 100, unitName),
                 "Modifier Percent": (lambda: ("%+.2f" if ((value - 1) * 100) % 1 else "%+d") % ((value - 1) * 100), unitName),
                 "Volume": (lambda: value, u"m\u00B3"),
                 "Sizeclass": (lambda: value, ""),
                 "Absolute Percent": (lambda: (value * 100) , unitName),
                 "Milliseconds": (lambda: value / 1000.0, unitName),
                 "typeID": (itemIDCallback, ""),
                 "groupID": (groupIDCallback,""),
                 "attributeID": (attributeIDCallback, "")}

        override = trans.get(unitDisplayName)
        if override is not None:

            if type(override[0]()) == type(str()):
                fvalue = override[0]()
            else:
                v = override[0]()
                if isinstance(v, (int, float, long)):
                    fvalue = formatAmount(v, 3, 0, 0)
                else:
                    fvalue = v
            return "%s %s" % (fvalue , override[1])
        else:
            return "%s %s" % (formatAmount(value, 3, 0),unitName)

###########################################################################
## Class ItemRequirements
###########################################################################

class ItemRequirements ( wx.Panel ):

    def __init__(self, parent, stuff, item):
        wx.Panel.__init__ (self, parent, style = wx.TAB_TRAVERSAL)

        #itemId is set by the parent.
        self.romanNb = ["0","I","II","III","IV","V","VI","VII","VIII","IX","X"]
        self.skillIdHistory=[]
        mainSizer = wx.BoxSizer( wx.VERTICAL )

        self.reqTree = wx.TreeCtrl(self, style = wx.TR_DEFAULT_STYLE | wx.TR_HIDE_ROOT | wx.NO_BORDER)

        mainSizer.Add(self.reqTree, 1, wx.ALL|wx.EXPAND, 0)

        self.SetSizer(mainSizer)
        self.root = self.reqTree.AddRoot("WINRARZOR")
        self.reqTree.SetPyData(self.root, None)

        self.imageList = wx.ImageList(16, 16)
        self.reqTree.SetImageList(self.imageList)
        skillBookId = self.imageList.Add(bitmapLoader.getBitmap("skill_small", "icons"))

        self.getFullSkillTree(item,self.root,skillBookId)

        self.reqTree.ExpandAll()

        self.Layout()

    def getFullSkillTree(self,parentSkill,parent,sbIconId):
        for skill, level in parentSkill.requiredSkills.iteritems():
            child = self.reqTree.AppendItem(parent,"%s  %s" %(skill.name,self.romanNb[int(level)]), sbIconId)
            if skill.ID not in self.skillIdHistory:
                self.getFullSkillTree(skill,child,sbIconId)
                self.skillIdHistory.append(skill.ID)


###########################################################################
## Class ItemEffects
###########################################################################

class ItemEffects (wx.Panel):
    def __init__(self, parent, stuff, item):
        wx.Panel.__init__ (self, parent)
        mainSizer = wx.BoxSizer( wx.VERTICAL )

        self.effectList = AutoListCtrl(self, wx.ID_ANY,
                                     style =
                                      #wx.LC_HRULES |
                                      #wx.LC_NO_HEADER |
                                      wx.LC_REPORT |wx.LC_SINGLE_SEL |wx.LC_VRULES |wx.NO_BORDER)
        mainSizer.Add( self.effectList, 1, wx.ALL|wx.EXPAND, 0 )
        self.SetSizer( mainSizer )

        self.effectList.InsertColumn(0,"Name")
        self.effectList.InsertColumn(1,"Implemented")

        self.effectList.SetColumnWidth(0,385)

        self.effectList.setResizeColumn(0)

        self.effectList.SetColumnWidth(1,80)

        effects = item.effects
        names = list(effects.iterkeys())
        names.sort()

        for name in names:
            index = self.effectList.InsertStringItem(sys.maxint, name)

            try:
                implemented = "Yes" if effects[name].isImplemented else "No"
            except:
                implemented = "Erroneous"

            self.effectList.SetStringItem(index, 1, implemented)

        self.effectList.RefreshRows()
        self.Layout()


###########################################################################
## Class ItemAffectedBy
###########################################################################


class ItemAffectedBy (wx.Panel):
    ORDER = [Ship, Module, Drone, Implant, Booster, Skill]
    def __init__(self, parent, stuff, item):
        wx.Panel.__init__ (self, parent)
        self.stuff = stuff
        self.item = item

        self.toggleView = 1
        self.expand = -1

        mainSizer = wx.BoxSizer(wx.VERTICAL)

        self.affectedBy = wx.TreeCtrl(self, style = wx.TR_DEFAULT_STYLE | wx.TR_HIDE_ROOT | wx.NO_BORDER)
        mainSizer.Add(self.affectedBy, 1, wx.ALL|wx.EXPAND, 0)

        self.m_staticline = wx.StaticLine( self, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.LI_HORIZONTAL )

        mainSizer.Add( self.m_staticline, 0, wx.EXPAND)
        bSizer = wx.BoxSizer( wx.HORIZONTAL )

        self.toggleExpandBtn = wx.ToggleButton( self, wx.ID_ANY, u"Expand / Collapse", wx.DefaultPosition, wx.DefaultSize, 0 )
        bSizer.Add( self.toggleExpandBtn, 0, wx.ALIGN_CENTER_VERTICAL)

        self.toggleViewBtn = wx.ToggleButton( self, wx.ID_ANY, u"Toggle view mode", wx.DefaultPosition, wx.DefaultSize, 0 )
        bSizer.Add( self.toggleViewBtn, 0, wx.ALIGN_CENTER_VERTICAL)

        if stuff is not None:
            self.refreshBtn = wx.Button( self, wx.ID_ANY, u"Refresh", wx.DefaultPosition, wx.DefaultSize, 0 )
            bSizer.Add( self.refreshBtn, 0, wx.ALIGN_CENTER_VERTICAL)
            self.refreshBtn.Bind( wx.EVT_BUTTON, self.RefreshTree )

        self.toggleViewBtn.Bind(wx.EVT_TOGGLEBUTTON,self.ToggleViewMode)
        self.toggleExpandBtn.Bind(wx.EVT_TOGGLEBUTTON,self.ToggleExpand)

        mainSizer.Add( bSizer, 0, wx.ALIGN_RIGHT)
        self.SetSizer(mainSizer)
        self.PopulateTree()
        self.Layout()

    def ExpandCollapseTree(self):

        self.Freeze()
        if self.expand == 1:
            self.affectedBy.ExpandAll()
        else:
            try:
                self.affectedBy.CollapseAll()
            except:
                pass

        self.Thaw()

    def ToggleExpand(self,event):
        self.expand *= -1
        self.ExpandCollapseTree()

    def ToggleViewTree(self):
        self.Freeze()

        root = self.affectedBy.GetRootItem()
        child,cookie = self.affectedBy.GetFirstChild(root)
        while child.IsOk():
            item,childcookie = self.affectedBy.GetFirstChild(child)
            while item.IsOk():
                change = self.affectedBy.GetPyData(item)
                display = self.affectedBy.GetItemText(item)
                self.affectedBy.SetItemText(item,change)
                self.affectedBy.SetPyData(item,display)
                item,childcookie = self.affectedBy.GetNextChild(child,childcookie)

            child,cookie = self.affectedBy.GetNextChild(root,cookie)

        self.Thaw()

    def UpdateTree(self):
        self.Freeze()
        self.affectedBy.DeleteAllItems()
        self.PopulateTree()
        self.Thaw()

    def RefreshTree(self, event):
        self.UpdateTree()
        event.Skip()

    def ToggleViewMode(self, event):
        self.toggleView *=-1
        self.ToggleViewTree()
        event.Skip()

    def PopulateTree(self):
        root = self.affectedBy.AddRoot("WINPWNZ0R")
        self.affectedBy.SetPyData(root, None)

        self.imageList = wx.ImageList(16, 16)
        self.affectedBy.SetImageList(self.imageList)


        cont = self.stuff.itemModifiedAttributes if self.item == self.stuff.item else self.stuff.chargeModifiedAttributes
        things = {}
        for attrName in cont.iterAfflictions():
            if cont[attrName] == (cont.getOriginal(attrName) or 0):
                continue

            for fit, afflictors in cont.getAfflictions(attrName).iteritems():
                for afflictor, modifier, amount in afflictors:
                    if afflictor.item is None:
                        continue
                    if afflictor.item.name not in things:
                        things[afflictor.item.name] = [type(afflictor), set(), set()]

                    info = things[afflictor.item.name]
                    info[1].add(afflictor)
                    info[2].add((attrName, modifier, amount))

        order = things.keys()
        order.sort(key=lambda x: (self.ORDER.index(things[x][0]), x))
        for itemName in order:
            info = things[itemName]

            afflictorType, afflictors, attrData = info
            counter = len(afflictors)

            baseAfflictor = afflictors.pop()
            if afflictorType == Ship:
                itemIcon = self.imageList.Add(bitmapLoader.getBitmap("ship_small", "icons"))
            elif baseAfflictor.item.icon:
                bitmap = bitmapLoader.getBitmap(baseAfflictor.item.icon.iconFile, "pack")
                itemIcon = self.imageList.Add(bitmap) if bitmap else -1
            else:
                itemIcon = -1

            child = self.affectedBy.AppendItem(root, "%s" % itemName if counter == 1 else "%s x %d" % (itemName,counter), itemIcon)

            if counter > 0:
                attributes = []
                for attrName, attrModifier, attrAmount in attrData:
                    attrInfo = self.stuff.item.attributes.get(attrName)
                    displayName = attrInfo.displayName if attrInfo else ""

                    if attrInfo:
                        if attrInfo.icon is not None:
                            iconFile = attrInfo.icon.iconFile
                            icon = bitmapLoader.getBitmap(iconFile, "pack")
                            if icon is None:
                                icon = bitmapLoader.getBitmap("transparent16x16", "icons")

                            attrIcon = self.imageList.Add(icon)
                        else:
                            attrIcon = self.imageList.Add(bitmapLoader.getBitmap("07_15", "pack"))
                    else:
                        attrIcon = self.imageList.Add(bitmapLoader.getBitmap("07_15", "pack"))

                    if attrModifier == "s*":
                        attrModifier = "*"
                        penalized = "(penalized)"
                    else:
                        penalized = ""

                    attributes.append((attrName, (displayName if displayName != "" else attrName), attrModifier, attrAmount, penalized, attrIcon))

                attrSorted = sorted(attributes, key = lambda attribName: attribName[0])

                for attr in attrSorted:
                    attrName, displayName, attrModifier, attrAmount, penalized, attrIcon = attr
                    if self.toggleView == 1:
                        treeitem = self.affectedBy.AppendItem(child, "%s %s %.2f %s" % ((displayName if displayName != "" else attrName), attrModifier, attrAmount, penalized), attrIcon)
                        self.affectedBy.SetPyData(treeitem,"%s %s %.2f %s" % (attrName, attrModifier, attrAmount, penalized))
                    else:
                        treeitem = self.affectedBy.AppendItem(child, "%s %s %.2f %s" % (attrName, attrModifier, attrAmount, penalized), attrIcon)
                        self.affectedBy.SetPyData(treeitem,"%s %s %.2f %s" % ((displayName if displayName != "" else attrName), attrModifier, attrAmount, penalized))

        self.ExpandCollapseTree()


########NEW FILE########
__FILENAME__ = mainFrame
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import sys
import os.path

import sqlalchemy
import wx
import time

from wx._core import PyDeadObjectError
from wx.lib.wordwrap import wordwrap

import service
import config
import threading

import gui.aboutData
import gui.chromeTabs
import gui.utils.animUtils as animUtils
import gui.globalEvents as GE

from gui import bitmapLoader
from gui.mainMenuBar import MainMenuBar
from gui.additionsPane import AdditionsPane
from gui.marketBrowser import MarketBrowser
from gui.multiSwitch import MultiSwitch
from gui.statsPane import StatsPane
from gui.shipBrowser import ShipBrowser, FitSelected
from gui.characterEditor import CharacterEditor
from gui.characterSelection import CharacterSelection
from gui.patternEditor import DmgPatternEditorDlg
from gui.preferenceDialog import PreferenceDialog
from gui.graphFrame import GraphFrame
from gui.copySelectDialog import CopySelectDialog
from gui.utils.clipboard import toClipboard, fromClipboard
from gui.fleetBrowser import FleetBrowser
from gui.updateDialog import UpdateDialog
from gui.builtinViews import *

#dummy panel(no paint no erasebk)
class PFPanel(wx.Panel):
    def __init__(self,parent):
        wx.Panel.__init__(self,parent)
        self.Bind(wx.EVT_PAINT, self.OnPaint)
        self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnBkErase)

    def OnPaint(self, event):
        event.Skip()
    def OnBkErase(self, event):
        pass

class OpenFitsThread(threading.Thread):
    def __init__(self, fits, callback):
        threading.Thread.__init__(self)
        self.mainFrame = MainFrame.getInstance()
        self.callback = callback
        self.fits = fits
        self.start()

    def run(self):
        time.sleep(0.5)  # Give GUI some time to finish drawing

        # `startup` tells FitSpawner that we are loading fits are startup, and
        # has 3 values:
        # False = Set as default in FitSpawner itself, never set here
        # 1 = Create new fit page, but do not calculate page
        # 2 = Create new page and calculate
        # We use 1 for all fits except the last one where we use 2 so that we
        # have correct calculations displayed at startup
        for fitID in self.fits[:-1]:
            wx.PostEvent(self.mainFrame, FitSelected(fitID=fitID, startup=1))

        wx.PostEvent(self.mainFrame, FitSelected(fitID=self.fits[-1], startup=2))
        wx.CallAfter(self.callback)

class MainFrame(wx.Frame):
    __instance = None
    @classmethod
    def getInstance(cls):
        return cls.__instance if cls.__instance is not None else MainFrame()

    def __init__(self):
        wx.Frame.__init__(self, None, wx.ID_ANY, title="pyfa - Python Fitting Assistant")

        MainFrame.__instance = self

        #Load stored settings (width/height/maximized..)
        self.LoadMainFrameAttribs()

        #Fix for msw (have the frame background color match panel color
        if 'wxMSW' in wx.PlatformInfo:
            self.SetBackgroundColour( wx.SystemSettings.GetColour( wx.SYS_COLOUR_BTNFACE ) )

        #Load and set the icon for pyfa main window
        i = wx.IconFromBitmap(bitmapLoader.getBitmap("pyfa", "icons"))
        self.SetIcon(i)

        #Create the layout and windows
        mainSizer = wx.BoxSizer(wx.HORIZONTAL)

        self.splitter = wx.SplitterWindow(self, style = wx.SP_LIVE_UPDATE)

        mainSizer.Add(self.splitter,1,wx.EXPAND | wx.LEFT, 2)

        self.FitviewAdditionsPanel = PFPanel(self.splitter)
        faSizer = wx.BoxSizer(wx.VERTICAL)

        self.fitMultiSwitch = MultiSwitch(self.FitviewAdditionsPanel)

        faSizer.Add(self.fitMultiSwitch,1,wx.EXPAND)

        self.additionsPane = AdditionsPane(self.FitviewAdditionsPanel)
        faSizer.Add(self.additionsPane, 0, wx.EXPAND)

        self.FitviewAdditionsPanel.SetSizer(faSizer)


        self.notebookBrowsers = gui.chromeTabs.PFNotebook(self.splitter, False)

        marketImg = bitmapLoader.getImage("market_small", "icons")
        shipBrowserImg = bitmapLoader.getImage("ship_small", "icons")

        self.marketBrowser = MarketBrowser(self.notebookBrowsers)
        self.notebookBrowsers.AddPage(self.marketBrowser, "Market", tabImage = marketImg, showClose = False)

        self.shipBrowser = ShipBrowser(self.notebookBrowsers)
        self.notebookBrowsers.AddPage(self.shipBrowser, "Ships", tabImage = shipBrowserImg, showClose = False)

        #=======================================================================
        # DISABLED FOR RC2 RELEASE
        #self.fleetBrowser = FleetBrowser(self.notebookBrowsers)
        #self.notebookBrowsers.AddPage(self.fleetBrowser, "Fleets", showClose = False)
        #=======================================================================

        self.notebookBrowsers.SetSelection(1)

        self.splitter.SplitVertically(self.notebookBrowsers, self.FitviewAdditionsPanel)
        self.splitter.SetMinimumPaneSize(204)
        self.splitter.SetSashPosition(300)

        cstatsSizer = wx.BoxSizer(wx.VERTICAL)

        self.charSelection = CharacterSelection(self)
        cstatsSizer.Add(self.charSelection, 0, wx.EXPAND)

        self.statsPane = StatsPane(self)
        cstatsSizer.Add(self.statsPane, 0, wx.EXPAND)

        mainSizer.Add(cstatsSizer, 0 , wx.EXPAND)

        self.SetSizer(mainSizer)

        #Add menu
        self.addPageId = wx.NewId()
        self.closePageId = wx.NewId()

        self.widgetInspectMenuID = wx.NewId()
        self.SetMenuBar(MainMenuBar())
        self.registerMenu()

        #Internal vars to keep track of other windows (graphing/stats)
        self.graphFrame = None
        self.statsWnds = []
        self.activeStatsWnd = None

        self.Bind(wx.EVT_CLOSE, self.OnClose)

        #Show ourselves
        self.Show()

        self.LoadPreviousOpenFits()

        #Check for updates
        self.sUpdate = service.Update.getInstance()
        self.sUpdate.CheckUpdate(self.ShowUpdateBox)

    def ShowUpdateBox(self, release):
        dlg = UpdateDialog(self, release)
        dlg.ShowModal()
        dlg.Destroy()

    def LoadPreviousOpenFits(self):
        self.prevOpenFits = service.SettingsProvider.getInstance().getSettings("pyfaPrevOpenFits", {"enabled": False, "pyfaOpenFits": []})
        fits = self.prevOpenFits['pyfaOpenFits']

        if not self.prevOpenFits['enabled'] or len(fits) is 0:
            # add blank page if there are no fits to be loaded
            self.fitMultiSwitch.AddPage()
            return

        self.waitDialog = animUtils.WaitDialog(self, title="Opening previous fits")
        OpenFitsThread(fits, self.closeWaitDialog)
        self.waitDialog.ShowModal()


    def LoadMainFrameAttribs(self):
        mainFrameDefaultAttribs = {"wnd_width":1000, "wnd_height": 700, "wnd_maximized": False}
        self.mainFrameAttribs = service.SettingsProvider.getInstance().getSettings("pyfaMainWindowAttribs", mainFrameDefaultAttribs)

        if self.mainFrameAttribs["wnd_maximized"]:
            width = mainFrameDefaultAttribs["wnd_width"]
            height = mainFrameDefaultAttribs["wnd_height"]
            self.Maximize()
        else:
            width = self.mainFrameAttribs["wnd_width"]
            height = self.mainFrameAttribs["wnd_height"]

        self.SetSize((width, height))
        self.SetMinSize((mainFrameDefaultAttribs["wnd_width"], mainFrameDefaultAttribs["wnd_height"]))

    def UpdateMainFrameAttribs(self):
        if self.IsIconized():
            return
        width,height = self.GetSize()

        self.mainFrameAttribs["wnd_width"] = width
        self.mainFrameAttribs["wnd_height"] = height
        self.mainFrameAttribs["wnd_maximized"] = self.IsMaximized()

    def SetActiveStatsWindow(self, wnd):
        self.activeStatsWnd = wnd

    def GetActiveStatsWindow(self):
        if self.activeStatsWnd in self.statsWnds:
            return self.activeStatsWnd

        if len(self.statsWnds) > 0:
            return self.statsWnds[len(self.statsWnds) - 1]
        else:
            return None

    def RegisterStatsWindow(self, wnd):
        self.statsWnds.append(wnd)

    def UnregisterStatsWindow(self, wnd):
        self.statsWnds.remove(wnd)

    def getActiveFit(self):
        p = self.fitMultiSwitch.GetSelectedPage()
        m = getattr(p, "getActiveFit", None)
        return m() if m is not None else None

    def getActiveView(self):
        sel = self.fitMultiSwitch.GetSelectedPage()

    def CloseCurrentPage(self, evt):
        ms = self.fitMultiSwitch

        page = ms.GetSelection()
        if page is not None:
            ms.DeletePage(page)

    def OnClose(self, event):
        self.UpdateMainFrameAttribs()

        # save open fits
        self.prevOpenFits['pyfaOpenFits'] = [] # clear old list
        for page in self.fitMultiSwitch.pages:
            m = getattr(page, "getActiveFit", None)
            if m is not None:
                 self.prevOpenFits['pyfaOpenFits'].append(m())

        # save all teh settingz
        service.SettingsProvider.getInstance().saveAll()
        event.Skip()

    def ExitApp(self, event):
        self.Close()
        event.Skip()

    def ShowAboutBox(self, evt):
        info = wx.AboutDialogInfo()
        info.Name = "pyfa"
        info.Version = gui.aboutData.versionString
        info.Description = wordwrap(gui.aboutData.description + "\n\nDevelopers:\n\t" +
                                     "\n\t".join(gui.aboutData.developers) +
                                     "\n\nAdditional credits:\n\t" +
                                     "\n\t".join(gui.aboutData.credits) +
                                     "\n\nLicenses:\n\t" +
                                     "\n\t".join(gui.aboutData.licenses) +
                                     "\n\nPython: \t" + sys.version +
                                     "\nwxPython: \t" + wx.__version__ +
                                     "\nSQLAlchemy: \t" + sqlalchemy.__version__,
            700, wx.ClientDC(self))
        if "__WXGTK__" in  wx.PlatformInfo:
            forumUrl = "http://forums.eveonline.com/default.aspx?g=posts&amp;t=247609"
        else:
            forumUrl = "http://forums.eveonline.com/default.aspx?g=posts&t=247609"
        info.WebSite = (forumUrl, "pyfa thread at EVE Online forum")
        wx.AboutBox(info)


    def showCharacterEditor(self, event):
        dlg=CharacterEditor(self)
        dlg.Show()

    def showDamagePatternEditor(self, event):
        dlg=DmgPatternEditorDlg(self)
        dlg.ShowModal()
        dlg.Destroy()

    def showImportDialog(self, event):
        fits = []
        sFit = service.Fit.getInstance()
        dlg=wx.FileDialog(
            self,
            "Open One Or More Fitting Files",
            wildcard = "EFT text fitting files (*.cfg)|*.cfg|" \
                       "EVE XML fitting files (*.xml)|*.xml|" \
                       "All Files (*)|*",
            style = wx.FD_OPEN | wx.FD_FILE_MUST_EXIST | wx.FD_MULTIPLE)
        if (dlg.ShowModal() == wx.ID_OK):
            self.waitDialog = animUtils.WaitDialog(self, title = "Importing")
            sFit.importFitsThreaded(dlg.GetPaths(), self.importCallback)
            dlg.Destroy()
            self.waitDialog.ShowModal()

    def importCallback(self, fits):
        self.waitDialog.Destroy()
        sFit = service.Fit.getInstance()
        IDs = sFit.saveImportedFits(fits)
        self._openAfterImport(len(fits), IDs)

    def _openAfterImport(self, importCount, fitIDs):
        if importCount == 1:
            wx.PostEvent(self, FitSelected(fitID=fitIDs[0]))

        self.shipBrowser.RefreshContent()

    def showExportDialog(self, event):
        dlg=wx.FileDialog(
            self,
            "Save Fitting As...",
            wildcard = "EVE XML fitting files (*.xml)|*.xml",
            style = wx.FD_SAVE)
        if (dlg.ShowModal() == wx.ID_OK):
            sFit = service.Fit.getInstance()
            format = dlg.GetFilterIndex()
            output = ""
            path = dlg.GetPath()
            if (format == 0):
                output = sFit.exportXml(self.getActiveFit())
                if '.' not in os.path.basename(path):
                    path += ".xml"
            else:
                print "oops, invalid fit format %d" % format
                dlg.Destroy()
                return
            file = open(path, "w")
            file.write(output)
            file.close()
        dlg.Destroy()

    def showPreferenceDialog(self, event):
        dlg = PreferenceDialog(self)
        dlg.ShowModal()
        dlg.Destroy()

    def goWiki(self, event):
        wx.LaunchDefaultBrowser('https://github.com/DarkFenX/Pyfa/wiki')

    def goForums(self, event):
        wx.LaunchDefaultBrowser('https://forums.eveonline.com/default.aspx?g=posts&t=247609')

    def registerMenu(self):
        menuBar = self.GetMenuBar()
        # Quit
        self.Bind(wx.EVT_MENU, self.ExitApp, id=wx.ID_EXIT)
        # Widgets Inspector
        if config.debug:
            self.Bind(wx.EVT_MENU, self.openWXInspectTool, id = self.widgetInspectMenuID)
        # About
        self.Bind(wx.EVT_MENU, self.ShowAboutBox, id=wx.ID_ABOUT)
        # Char editor
        self.Bind(wx.EVT_MENU, self.showCharacterEditor, id=menuBar.characterEditorId)
        # Damage pattern editor
        self.Bind(wx.EVT_MENU, self.showDamagePatternEditor, id=menuBar.damagePatternEditorId)
        # Import dialog
        self.Bind(wx.EVT_MENU, self.showImportDialog, id=wx.ID_OPEN)
        # Export dialog
        self.Bind(wx.EVT_MENU, self.showExportDialog, id=wx.ID_SAVEAS)
        # Import from Clipboard
        self.Bind(wx.EVT_MENU, self.importFromClipboard, id=wx.ID_PASTE)
        # Backup fits
        self.Bind(wx.EVT_MENU, self.backupToXml, id=menuBar.backupFitsId)
        # Export skills needed
        self.Bind(wx.EVT_MENU, self.exportSkillsNeeded, id=menuBar.exportSkillsNeededId)
        # Import character
        self.Bind(wx.EVT_MENU, self.importCharacter, id=menuBar.importCharacterId)
        # Export HTML
        self.Bind(wx.EVT_MENU, self.exportHtml, id=menuBar.exportHtmlId)
        # Preference dialog
        self.Bind(wx.EVT_MENU, self.showPreferenceDialog, id=wx.ID_PREFERENCES)
        # User guide
        self.Bind(wx.EVT_MENU, self.goWiki, id = menuBar.wikiId)
        # EVE Forums
        self.Bind(wx.EVT_MENU, self.goForums, id = menuBar.forumId)

        #Clipboard exports
        self.Bind(wx.EVT_MENU, self.exportToClipboard, id=wx.ID_COPY)

        #Graphs
        self.Bind(wx.EVT_MENU, self.openGraphFrame, id=menuBar.graphFrameId)

        toggleShipMarketId = wx.NewId()
        ctabnext = wx.NewId()
        ctabprev = wx.NewId()

        self.additionstab1 = wx.NewId()
        self.additionstab2 = wx.NewId()
        self.additionstab3 = wx.NewId()
        self.additionstab4 = wx.NewId()
        self.additionstab5 = wx.NewId()

        # Close Page
        self.Bind(wx.EVT_MENU, self.CloseCurrentPage, id=self.closePageId)
        self.Bind(wx.EVT_MENU, self.HAddPage, id = self.addPageId)
        self.Bind(wx.EVT_MENU, self.toggleShipMarket, id = toggleShipMarketId)
        self.Bind(wx.EVT_MENU, self.CTabNext, id = ctabnext)
        self.Bind(wx.EVT_MENU, self.CTabPrev, id = ctabprev)

        self.Bind(wx.EVT_MENU, self.AdditionsTabSelect, id = self.additionstab1)
        self.Bind(wx.EVT_MENU, self.AdditionsTabSelect, id = self.additionstab2)
        self.Bind(wx.EVT_MENU, self.AdditionsTabSelect, id = self.additionstab3)
        self.Bind(wx.EVT_MENU, self.AdditionsTabSelect, id = self.additionstab4)
        self.Bind(wx.EVT_MENU, self.AdditionsTabSelect, id = self.additionstab5)

        actb = [(wx.ACCEL_CTRL, ord('T'), self.addPageId),
                (wx.ACCEL_CMD, ord('T'), self.addPageId),

                (wx.ACCEL_CTRL, ord("W"), self.closePageId),
                (wx.ACCEL_CTRL, wx.WXK_F4, self.closePageId),
                (wx.ACCEL_CMD, ord("W"), self.closePageId),

                (wx.ACCEL_CTRL, ord(" "), toggleShipMarketId),
                (wx.ACCEL_CMD, ord(" "), toggleShipMarketId),

                (wx.ACCEL_CTRL, wx.WXK_TAB, ctabnext),
                (wx.ACCEL_CTRL | wx.ACCEL_SHIFT, wx.WXK_TAB, ctabprev),
                (wx.ACCEL_CMD, wx.WXK_TAB, ctabnext),
                (wx.ACCEL_CMD | wx.ACCEL_SHIFT, wx.WXK_TAB, ctabprev),

                (wx.ACCEL_CTRL, ord('1'), self.additionstab1),
                (wx.ACCEL_CTRL, ord('2'), self.additionstab2),
                (wx.ACCEL_CTRL, ord('3'), self.additionstab3),
                (wx.ACCEL_CTRL, ord('4'), self.additionstab4),
                (wx.ACCEL_CTRL, ord('5'), self.additionstab5),
                (wx.ACCEL_CMD, ord('1'), self.additionstab1),
                (wx.ACCEL_CMD, ord('2'), self.additionstab2),
                (wx.ACCEL_CMD, ord('3'), self.additionstab3),
                (wx.ACCEL_CMD, ord('4'), self.additionstab4),
                (wx.ACCEL_CMD, ord('5'), self.additionstab5)
                ]
        atable = wx.AcceleratorTable(actb)
        self.SetAcceleratorTable(atable)

    def AdditionsTabSelect(self, event):
        selTab = None
        if event.GetId() == self.additionstab1:
            selTab = 0
        if event.GetId() == self.additionstab2:
            selTab = 1
        if event.GetId() == self.additionstab3:
            selTab = 2
        if event.GetId() == self.additionstab4:
            selTab = 3
        if event.GetId() == self.additionstab5:
            selTab = 4
        if selTab is not None:
            self.additionsPane.notebook.SetSelection(selTab)

    def CTabNext(self, event):
        self.fitMultiSwitch.NextPage()

    def CTabPrev(self, event):
        self.fitMultiSwitch.PrevPage()

    def HAddPage(self,event):
        self.fitMultiSwitch.AddPage()

    def toggleShipMarket(self, event):
        sel = self.notebookBrowsers.GetSelection()
        self.notebookBrowsers.SetSelection(0 if sel == 1 else 1)

    def clipboardEft(self):
        sFit = service.Fit.getInstance()
        toClipboard(sFit.exportFit(self.getActiveFit()))

    def clipboardEftImps(self):
        sFit = service.Fit.getInstance()
        toClipboard(sFit.exportEftImps(self.getActiveFit()))

    def clipboardDna(self):
        sFit = service.Fit.getInstance()
        toClipboard(sFit.exportDna(self.getActiveFit()))

    def clipboardXml(self):
        sFit = service.Fit.getInstance()
        toClipboard(sFit.exportXml(self.getActiveFit()))

    def importFromClipboard(self, event):
        sFit = service.Fit.getInstance()
        try:
            fits = sFit.importFitFromBuffer(fromClipboard(), self.getActiveFit())
            IDs = sFit.saveImportedFits(fits)
            self._openAfterImport(len(fits), IDs)
        except:
            pass


    def exportToClipboard(self, event):
        CopySelectDict = {CopySelectDialog.copyFormatEft: self.clipboardEft,
                          CopySelectDialog.copyFormatEftImps: self.clipboardEftImps,
                          CopySelectDialog.copyFormatXml: self.clipboardXml,
                          CopySelectDialog.copyFormatDna: self.clipboardDna}
        dlg = CopySelectDialog(self)
        dlg.ShowModal()
        selected = dlg.GetSelected()
        try:
            CopySelectDict[selected]()
        except:
            pass
        dlg.Destroy()

    def backupToXml(self, event):
        sFit = service.Fit.getInstance()
        saveDialog = wx.FileDialog(
            self,
            "Save Backup As...",
            wildcard = "EVE XML fitting file (*.xml)|*.xml",
            style = wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT)
        if (saveDialog.ShowModal() == wx.ID_OK):
            filePath = saveDialog.GetPath()
            if '.' not in os.path.basename(filePath):
                filePath += ".xml"
            self.waitDialog = animUtils.WaitDialog(self)
            sFit.backupFits(filePath, self.closeWaitDialog)
            self.waitDialog.ShowModal()

        saveDialog.Destroy()

    def exportSkillsNeeded(self, event):
        sCharacter = service.Character.getInstance()
        saveDialog = wx.FileDialog(
            self,
            "Export Skills Needed As...",
            wildcard = "EVEMon skills training file (*.emp)|*.emp|" \
                       "EVEMon skills training XML file (*.xml)|*.xml|" \
                       "Text skills training file (*.txt)|*.txt",
            style = wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT)
        if (saveDialog.ShowModal() == wx.ID_OK):
            saveFmtInt = saveDialog.GetFilterIndex()
            saveFmt = ""
            if saveFmtInt == 0:  # Per ordering of wildcards above
                saveFmt = "emp"
            elif saveFmtInt == 1:
                saveFmt = "xml"
            else:
                saveFmt = "txt"
            filePath = saveDialog.GetPath()
            if '.' not in os.path.basename(filePath):
                filePath += ".{0}".format(saveFmt)
            self.waitDialog = animUtils.WaitDialog(self)
            sCharacter.backupSkills(filePath, saveFmt, self.getActiveFit(), self.closeWaitDialog)
            self.waitDialog.ShowModal()

        saveDialog.Destroy()

    def importCharacter(self, event):
        sCharacter = service.Character.getInstance()
        dlg=wx.FileDialog(
            self,
            "Open One Or More Character Files",
            wildcard = "EVE CCP API XML character files (*.xml)|*.xml|" \
                       "All Files (*)|*",
            style = wx.FD_OPEN | wx.FD_FILE_MUST_EXIST | wx.FD_MULTIPLE)
        if (dlg.ShowModal() == wx.ID_OK):
            self.waitDialog = animUtils.WaitDialog(self, title = "Importing Character")
            sCharacter.importCharacter(dlg.GetPaths(), self.importCharacterCallback)
            dlg.Destroy()
            self.waitDialog.ShowModal()

    def exportHtml(self, event):
        from gui.utils.exportHtml import exportHtml
        self.waitDialog = animUtils.WaitDialog(self)
        exportHtml.getInstance().refreshFittingHtml(True, self.closeWaitDialog)
        self.waitDialog.ShowModal()

    def importCharacterCallback(self):
        self.waitDialog.Destroy()
        wx.PostEvent(self, GE.CharListUpdated())

    def closeWaitDialog(self):
        self.waitDialog.Destroy()

    def openGraphFrame(self, event):
        if not self.graphFrame:
            self.graphFrame = GraphFrame(self)
            if gui.graphFrame.enabled:
                self.graphFrame.Show()
        else:
            self.graphFrame.SetFocus()

    def openWXInspectTool(self,event):
        from wx.lib.inspection import InspectionTool
        if not InspectionTool().initialized:
            InspectionTool().Init()

        # Find a widget to be selected in the tree.  Use either the
        # one under the cursor, if any, or this frame.
        wnd = wx.FindWindowAtPointer()
        if not wnd:
            wnd = self
        InspectionTool().Show(wnd, True)


########NEW FILE########
__FILENAME__ = mainMenuBar
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import wx
import config
import bitmapLoader
import gui.mainFrame
import gui.graphFrame
import gui.globalEvents as GE

class MainMenuBar(wx.MenuBar):
    def __init__(self):
        self.characterEditorId = wx.NewId()
        self.damagePatternEditorId = wx.NewId()
        self.graphFrameId = wx.NewId()
        self.backupFitsId = wx.NewId()
        self.exportSkillsNeededId = wx.NewId()
        self.importCharacterId = wx.NewId()
        self.exportHtmlId = wx.NewId()
        self.wikiId = wx.NewId()
        self.forumId = wx.NewId()

        self.mainFrame = gui.mainFrame.MainFrame.getInstance()

        wx.MenuBar.__init__(self)

        # File menu
        fileMenu = wx.Menu()
        self.Append(fileMenu, "&File")

        fileMenu.Append(self.mainFrame.addPageId, "&New Tab\tCTRL+T", "Open a new fitting tab")
        fileMenu.Append(self.mainFrame.closePageId, "&Close Tab\tCTRL+W", "Close the current fit")
        fileMenu.AppendSeparator()

        fileMenu.Append(self.backupFitsId, "&Backup All Fittings", "Backup all fittings to a XML file")
        fileMenu.Append(wx.ID_OPEN, "&Import Fittings\tCTRL+O", "Import fittings into pyfa")
        fileMenu.Append(wx.ID_SAVEAS, "&Export Fitting\tCTRL+S", "Export fitting to another format")
        fileMenu.AppendSeparator()
        fileMenu.Append(self.exportHtmlId, "Export HTML", "Export fits to HTML file (set in Preferences)")
        fileMenu.Append(self.exportSkillsNeededId, "Export &Skills Needed", "Export skills needed for this fitting")
        fileMenu.Append(self.importCharacterId, "Import C&haracter File", "Import characters into pyfa from file")
        fileMenu.AppendSeparator()
        fileMenu.Append(wx.ID_EXIT)

        # Edit menu
        editMenu = wx.Menu()
        self.Append(editMenu, "&Edit")

        #editMenu.Append(wx.ID_UNDO)
        #editMenu.Append(wx.ID_REDO)

        copyText = "&To Clipboard" + ("\tCTRL+C" if 'wxMSW' in wx.PlatformInfo else "")
        pasteText = "&From Clipboard" + ("\tCTRL+V" if 'wxMSW' in wx.PlatformInfo else "")
        editMenu.Append(wx.ID_COPY, copyText, "Export a fit to the clipboard")
        editMenu.Append(wx.ID_PASTE, pasteText, "Import a fit from the clipboard")

        # Character menu
        windowMenu = wx.Menu()
        self.Append(windowMenu, "&Window")

        charEditItem = wx.MenuItem(windowMenu, self.characterEditorId, "&Character Editor\tCTRL+E")
        charEditItem.SetBitmap(bitmapLoader.getBitmap("character_small", "icons"))
        windowMenu.AppendItem(charEditItem)

        damagePatternEditItem = wx.MenuItem(windowMenu, self.damagePatternEditorId, "Damage Pattern Editor\tCTRL+D")
        damagePatternEditItem.SetBitmap(bitmapLoader.getBitmap("damagePattern_small", "icons"))
        windowMenu.AppendItem(damagePatternEditItem)

        graphFrameItem = wx.MenuItem(windowMenu, self.graphFrameId, "Graphs\tCTRL+G")
        graphFrameItem.SetBitmap(bitmapLoader.getBitmap("graphs_small", "icons"))
        windowMenu.AppendItem(graphFrameItem)

        preferencesItem = wx.MenuItem(windowMenu, wx.ID_PREFERENCES, "Preferences\tCTRL+P")
        preferencesItem.SetBitmap(bitmapLoader.getBitmap("preferences_small", "icons"))
        windowMenu.AppendItem(preferencesItem)

        # Help menu
        helpMenu = wx.Menu()
        self.Append(helpMenu, "&Help")
        helpMenu.Append(self.wikiId, "Wiki", "Go to wiki on GitHub")
        helpMenu.Append(self.forumId, "Forums", "Go to EVE Online Forum thread")
        helpMenu.AppendSeparator()
        helpMenu.Append(wx.ID_ABOUT)

        if config.debug:
            helpMenu.Append( self.mainFrame.widgetInspectMenuID, "Open Widgets Inspect tool", "Open Widgets Inspect tool")

        self.mainFrame.Bind(GE.FIT_CHANGED, self.fitChanged)

    def fitChanged(self, event):
        enable = event.fitID is not None
        self.Enable(wx.ID_SAVEAS, enable)
        self.Enable(wx.ID_COPY, enable)
        self.Enable(self.exportSkillsNeededId, enable)
        event.Skip()


########NEW FILE########
__FILENAME__ = marketBrowser
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import wx
import service
import gui.display as d
from gui.cachingImageList import CachingImageList
from gui.contextMenu import ContextMenu
import gui.PFSearchBox as SBox

from gui import bitmapLoader

ItemSelected, ITEM_SELECTED = wx.lib.newevent.NewEvent()

RECENTLY_USED_MODULES = -2
MAX_RECENTLY_USED_MODULES = 20

class MarketBrowser(wx.Panel):
    def __init__(self, parent):
        wx.Panel.__init__(self, parent)
        vbox = wx.BoxSizer(wx.VERTICAL)
        self.SetSizer(vbox)

        # Add a search box on top
        self.search = SearchBox(self)
        vbox.Add(self.search, 0, wx.EXPAND)

        self.splitter = wx.SplitterWindow(self, style = wx.SP_LIVE_UPDATE)
        vbox.Add(self.splitter, 1, wx.EXPAND)

        # Grab market service instance and create child objects
        self.sMarket = service.Market.getInstance()
        self.searchMode = False
        self.marketView = MarketTree(self.splitter, self)
        self.itemView = ItemView(self.splitter, self)

        self.splitter.SplitHorizontally(self.marketView, self.itemView)
        self.splitter.SetMinimumPaneSize(250)

        # Setup our buttons for metaGroup selection
        # Same fix as for search box on macs,
        # need some pixels of extra space or everything clips and is ugly
        p = wx.Panel(self)
        box = wx.BoxSizer(wx.HORIZONTAL)
        p.SetSizer(box)
        vbox.Add(p, 0, wx.EXPAND)
        self.metaButtons = []
        for name in self.sMarket.META_MAP.keys():
            btn = wx.ToggleButton(p, wx.ID_ANY, name.capitalize(), style=wx.BU_EXACTFIT)
            setattr(self, name, btn)
            box.Add(btn, 1, wx.ALIGN_CENTER)
            btn.Bind(wx.EVT_TOGGLEBUTTON, self.toggleMetaButton)
            btn.metaName = name
            self.metaButtons.append(btn)
        # Make itemview to set toggles according to list contents
        self.itemView.setToggles()

        p.SetMinSize((wx.SIZE_AUTO_WIDTH, btn.GetSize()[1] + 5))

    def toggleMetaButton(self, event):
        """Process clicks on toggle buttons"""
        ctrl = wx.GetMouseState().CmdDown()
        ebtn = event.EventObject
        if not ctrl:
            for btn in self.metaButtons:
                if btn.Enabled:
                    if btn == ebtn:
                        btn.SetValue(True)
                    else:
                        btn.SetValue(False)
        else:
            # Note: using the 'wrong' value for clicked button might seem weird,
            # But the button is toggled by wx and we should deal with it
            activeBtns = set()
            for btn in self.metaButtons:
                if (btn.GetValue() is True and btn != ebtn) or (btn.GetValue() is False and btn == ebtn):
                    activeBtns.add(btn)
            # Do 'nothing' if we're trying to turn last active button off
            if len(activeBtns) == 1 and activeBtns.pop() == ebtn:
                # Keep button in the same state
                ebtn.SetValue(True)
                return
        # Leave old unfiltered list contents, just re-filter them and show
        self.itemView.filterItemStore()

    def jump(self, item):
        self.marketView.jump(item)

class SearchBox(SBox.PFSearchBox):
    def __init__(self, parent):
        SBox.PFSearchBox.__init__(self, parent)
        cancelBitmap = bitmapLoader.getBitmap("fit_delete_small","icons")
        searchBitmap = bitmapLoader.getBitmap("fsearch_small","icons")
        self.SetSearchBitmap(searchBitmap)
        self.SetCancelBitmap(cancelBitmap)
        self.ShowSearchButton()
        self.ShowCancelButton()

class MarketTree(wx.TreeCtrl):
    def __init__(self, parent, marketBrowser):
        wx.TreeCtrl.__init__(self, parent, style=wx.TR_DEFAULT_STYLE | wx.TR_HIDE_ROOT)
        self.root = self.AddRoot("root")

        self.imageList = CachingImageList(16, 16)
        self.SetImageList(self.imageList)

        self.sMarket = marketBrowser.sMarket
        self.marketBrowser = marketBrowser

        # Form market tree root
        sMkt = self.sMarket
        for mktGrp in sMkt.getMarketRoot():
            iconId = self.addImage(sMkt.getIconByMarketGroup(mktGrp))
            childId = self.AppendItem(self.root, mktGrp.name, iconId, data=wx.TreeItemData(mktGrp.ID))
            # All market groups which were never expanded are dummies, here we assume
            # that all root market groups are expandable
            self.AppendItem(childId, "dummy")
        self.SortChildren(self.root)

        # Add recently used modules node
        rumIconId = self.addImage("market_small", "icons")
        self.AppendItem(self.root, "Recently Used Modules", rumIconId, data = wx.TreeItemData(RECENTLY_USED_MODULES))

        # Bind our lookup method to when the tree gets expanded
        self.Bind(wx.EVT_TREE_ITEM_EXPANDING, self.expandLookup)

    def addImage(self, iconFile, location = "pack"):
        if iconFile is None:
            return -1
        return self.imageList.GetImageIndex(iconFile, location)

    def expandLookup(self, event):
        """Process market tree expands"""
        root = event.Item
        child = self.GetFirstChild(root)[0]
        # If child of given market group is a dummy
        if self.GetItemText(child) == "dummy":
            # Delete it
            self.Delete(child)
            # And add real market group contents
            sMkt = self.sMarket
            currentMktGrp = sMkt.getMarketGroup(self.GetPyData(root), eager="children")
            for childMktGrp in sMkt.getMarketGroupChildren(currentMktGrp):
                # If market should have items but it doesn't, do not show it
                if sMkt.marketGroupValidityCheck(childMktGrp) is False:
                    continue
                iconId = self.addImage(sMkt.getIconByMarketGroup(childMktGrp))
                try:
                    childId = self.AppendItem(root, childMktGrp.name, iconId, data=wx.TreeItemData(childMktGrp.ID))
                except:
                    continue
                if sMkt.marketGroupHasTypesCheck(childMktGrp) is False:
                    self.AppendItem(childId, "dummy")

            self.SortChildren(root)

    def jump(self, item):
        """Open market group and meta tab of given item"""
        self.marketBrowser.searchMode = False
        sMkt = self.sMarket
        mg = sMkt.getMarketGroupByItem(item)
        metaId = sMkt.getMetaGroupIdByItem(item)

        jumpList = []
        while mg is not None:
            jumpList.append(mg.ID)
            mg = mg.parent

        for id in sMkt.ROOT_MARKET_GROUPS:
            if id in jumpList:
                jumpList = jumpList[:jumpList.index(id)+1]

        item = self.root
        for i in range(len(jumpList) -1, -1, -1):
            target = jumpList[i]
            child, cookie = self.GetFirstChild(item)
            while self.GetItemPyData(child) != target:
                child, cookie = self.GetNextChild(item, cookie)

            item = child
            self.Expand(item)

        self.SelectItem(item)
        self.marketBrowser.itemView.selectionMade(forcedMetaSelect=metaId)

class ItemView(d.Display):
    DEFAULT_COLS = ["Base Icon",
                    "Base Name",
                    "attr:power,,,True",
                    "attr:cpu,,,True"]

    def __init__(self, parent, marketBrowser):
        d.Display.__init__(self, parent)
        marketBrowser.Bind(wx.EVT_TREE_SEL_CHANGED, self.selectionMade)

        self.unfilteredStore = set()
        self.filteredStore = set()
        self.recentlyUsedModules = set()
        self.sMarket = marketBrowser.sMarket
        self.searchMode = marketBrowser.searchMode

        self.marketBrowser = marketBrowser
        self.marketView = marketBrowser.marketView

        # Make sure our search actually does interesting stuff
        self.marketBrowser.search.Bind(SBox.EVT_TEXT_ENTER, self.scheduleSearch)
        self.marketBrowser.search.Bind(SBox.EVT_SEARCH_BTN, self.scheduleSearch)
        self.marketBrowser.search.Bind(SBox.EVT_CANCEL_BTN, self.clearSearch)
        self.marketBrowser.search.Bind(SBox.EVT_TEXT, self.scheduleSearch)

        # Make sure WE do interesting stuff too
        self.Bind(wx.EVT_CONTEXT_MENU, self.contextMenu)
        self.Bind(wx.EVT_LIST_ITEM_ACTIVATED, self.itemActivated)
        self.Bind(wx.EVT_LIST_BEGIN_DRAG, self.startDrag)

        # Make reverse map, used by sorter
        self.metaMap = self.makeReverseMetaMap()

        # Fill up recently used modules set
        for itemID in self.sMarket.serviceMarketRecentlyUsedModules["pyfaMarketRecentlyUsedModules"]:
            self.recentlyUsedModules.add(self.sMarket.getItem(itemID))

    def startDrag(self, event):
        row = self.GetFirstSelected()

        if row != -1:
            data = wx.PyTextDataObject()
            data.SetText("market:"+str(self.active[row].ID))

            dropSource = wx.DropSource(self)
            dropSource.SetData(data)
            res = dropSource.DoDragDrop()


    def itemActivated(self, event=None):
        # Check if something is selected, if so, spawn the menu for it
        sel = self.GetFirstSelected()
        if sel == -1:
            return

        if self.mainFrame.getActiveFit():

            self.storeRecentlyUsedMarketItem(self.active[sel].ID)
            self.recentlyUsedModules = set()
            for itemID in self.sMarket.serviceMarketRecentlyUsedModules["pyfaMarketRecentlyUsedModules"]:
                self.recentlyUsedModules.add(self.sMarket.getItem(itemID))

        wx.PostEvent(self.mainFrame, ItemSelected(itemID=self.active[sel].ID))

    def storeRecentlyUsedMarketItem(self, itemID):
        if len(self.sMarket.serviceMarketRecentlyUsedModules["pyfaMarketRecentlyUsedModules"]) > MAX_RECENTLY_USED_MODULES:
            self.sMarket.serviceMarketRecentlyUsedModules["pyfaMarketRecentlyUsedModules"].pop(0)

        self.sMarket.serviceMarketRecentlyUsedModules["pyfaMarketRecentlyUsedModules"].append(itemID)

    def selectionMade(self, event=None, forcedMetaSelect=None):
        self.marketBrowser.searchMode = False
        # Grab the threeview selection and check if it's fine
        sel = self.marketView.GetSelection()
        if sel.IsOk():
            # Get data field of the selected item (which is a marketGroup ID if anything was selected)
            seldata = self.marketView.GetPyData(sel)
            if seldata is not None and seldata != RECENTLY_USED_MODULES:
                # If market group treeview item doesn't have children (other market groups or dummies),
                # then it should have items in it and we want to request them
                if self.marketView.ItemHasChildren(sel) is False:
                    sMkt = self.sMarket
                    # Get current market group
                    mg = sMkt.getMarketGroup(seldata, eager=("items", "items.metaGroup"))
                    # Get all its items
                    items = sMkt.getItemsByMarketGroup(mg)
                else:
                    items = set()
            else:
                # If method was called but selection wasn't actually made or we have a hit on recently used modules
                if seldata == RECENTLY_USED_MODULES:
                    items = self.recentlyUsedModules
                else:
                    items = set()

            # Fill store
            self.updateItemStore(items)

            # Set toggle buttons / use search mode flag if recently used modules category is selected (in order to have all modules listed and not filtered)
            if seldata is not RECENTLY_USED_MODULES:
                self.setToggles(forcedMetaSelect=forcedMetaSelect)
            else:
                self.marketBrowser.searchMode = True
                self.setToggles()

            # Update filtered items
            self.filterItemStore()

    def updateItemStore(self, items):
        self.unfilteredStore = items

    def filterItemStore(self):
        sMkt = self.sMarket
        selectedMetas = set()
        for btn in self.marketBrowser.metaButtons:
            if btn.GetValue():
                selectedMetas.update(sMkt.META_MAP[btn.metaName])
        self.filteredStore = sMkt.filterItemsByMeta(self.unfilteredStore, selectedMetas)
        self.update(list(self.filteredStore))

    def setToggles(self, forcedMetaSelect=None):
        metaIDs = set()
        sMkt = self.sMarket
        for item in self.unfilteredStore:
            metaIDs.add(sMkt.getMetaGroupIdByItem(item))
        anySelection = False
        for btn in self.marketBrowser.metaButtons:
            btnMetas = sMkt.META_MAP[btn.metaName]
            if len(metaIDs.intersection(btnMetas)) > 0:
                btn.Enable(True)
                # Select all available buttons if we're searching
                if self.marketBrowser.searchMode is True:
                    btn.SetValue(True)
                # Select explicitly requested button
                if forcedMetaSelect is not None:
                    btn.SetValue(True if forcedMetaSelect in btnMetas else False)
            else:
                btn.Enable(False)
                btn.SetValue(False)
            if btn.GetValue():
                anySelection = True
        # If no buttons are pressed, press first active
        if anySelection is False:
            for btn in self.marketBrowser.metaButtons:
                if btn.Enabled:
                    btn.SetValue(True)
                    break

    def scheduleSearch(self, event=None):
        search = self.marketBrowser.search.GetLineText(0)
        # Make sure we do not count wildcard as search symbol
        realsearch = search.replace("*", "")
        # Re-select market group if search query has zero length
        if len(realsearch) == 0:
            self.selectionMade()
            return
        # Show nothing if query is too short
        elif len(realsearch) < 3:
            self.clearSearch()
            return

        self.marketBrowser.searchMode = True
        self.sMarket.searchItems(search, self.populateSearch)

    def clearSearch(self, event=None):
        # Wipe item store and update everything to accomodate with it
        # If clearSearch was generated by SearchCtrl's Cancel button, clear the content also

        if event:
            self.marketBrowser.search.Clear()

        self.marketBrowser.searchMode = False
        self.updateItemStore(set())
        self.setToggles()
        self.filterItemStore()

    def populateSearch(self, items):
        # If we're no longer searching, dump the results
        if self.marketBrowser.searchMode is False:
            return
        self.updateItemStore(items)
        self.setToggles()
        self.filterItemStore()

    def itemSort(self, item):
        sMkt = self.sMarket
        catname = sMkt.getCategoryByItem(item).name
        try:
            mktgrpid = sMkt.getMarketGroupByItem(item).ID
        except AttributeError:
            mktgrpid = None
            print "unable to find market group for", item.name
        parentname = sMkt.getParentItemByItem(item).name
        # Get position of market group
        metagrpid = sMkt.getMetaGroupIdByItem(item)
        metatab = self.metaMap.get(metagrpid)
        metalvl =  self.metalvls.get(item.ID, 0)
        return (catname, mktgrpid, parentname, metatab, metalvl, item.name)

    def contextMenu(self, event):
        # Check if something is selected, if so, spawn the menu for it
        sel = self.GetFirstSelected()
        if sel == -1:
            return

        item = self.active[sel]

        sMkt = self.sMarket
        sourceContext = "marketItemGroup" if self.marketBrowser.searchMode is False else "marketItemMisc"
        itemContext = sMkt.getCategoryByItem(item).name

        menu = ContextMenu.getMenu((item,), (sourceContext, itemContext))
        self.PopupMenu(menu)

    def populate(self, items):
        if len(items) > 0:
            # Get dictionary with meta level attribute
            sAttr = service.Attribute.getInstance()
            attrs = sAttr.getAttributeInfo("metaLevel")
            sMkt = self.sMarket
            self.metalvls = sMkt.directAttrRequest(items, attrs)
            # Clear selection
            self.deselectItems()
            # Perform sorting, using item's meta levels besides other stuff
            items.sort(key=self.itemSort)
        # Mark current item list as active
        self.active = items
        # Show them
        d.Display.populate(self, items)

    def refresh(self, items):
        if len(items) > 1:
            # Get dictionary with meta level attribute
            sAttr = service.Attribute.getInstance()
            attrs = sAttr.getAttributeInfo("metaLevel")
            sMkt = self.sMarket
            self.metalvls = sMkt.directAttrRequest(items, attrs)
            # Re-sort stuff
            items.sort(key=self.itemSort)
        d.Display.refresh(self, items)

    def makeReverseMetaMap(self):
        """
        Form map which tells in which tab items of given metagroup are located
        """
        revmap = {}
        i = 0
        for mgids in self.sMarket.META_MAP.itervalues():
            for mgid in mgids:
                revmap[mgid] = i
            i += 1
        return revmap

########NEW FILE########
__FILENAME__ = multiSwitch
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import gui.chromeTabs
import gui.builtinViews.emptyView


class MultiSwitch(gui.chromeTabs.PFNotebook):
    def __init__(self, parent):
        gui.chromeTabs.PFNotebook.__init__(self, parent)
        #self.AddPage() # now handled by mainFrame
        self.handlers = handlers = []
        for type in TabSpawner.tabTypes:
            handlers.append(type(self))

    def handleDrag(self, type, info):
        for handler in self.handlers:
            h = getattr(handler, "handleDrag", None)
            if h:
                h(type, info)

    def AddPage(self, tabWnd=None, tabTitle="Empty Tab", tabImage=None):
        if tabWnd is None:
            tabWnd = gui.builtinViews.emptyView.BlankPage(self)
            tabWnd.handleDrag = lambda type, info: self.handleDrag(type, info)

        gui.chromeTabs.PFNotebook.AddPage(self, tabWnd, tabTitle, tabImage, True)

    def DeletePage(self, n, *args, **kwargs):
        gui.chromeTabs.PFNotebook.DeletePage(self, n, *args, **kwargs)
        if self.GetPageCount() == 0:
            self.AddPage()


class TabSpawner(object):
    tabTypes = []

    @classmethod
    def register(cls):
        TabSpawner.tabTypes.append(cls)

########NEW FILE########
__FILENAME__ = patternEditor
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.    See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.    If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import wx
import bitmapLoader
import service
from wx.lib.intctrl import IntCtrl
from gui.utils.clipboard import toClipboard, fromClipboard

###########################################################################
## Class DmgPatternEditorDlg
###########################################################################

class DmgPatternEditorDlg (wx.Dialog):

    def __init__(self, parent):
        wx.Dialog.__init__ (self, parent, id = wx.ID_ANY, title = u"Damage Pattern Editor", size = wx.Size( 400,240 ))

        self.block = False
        self.SetSizeHintsSz(wx.DefaultSize, wx.DefaultSize)

        mainSizer = wx.BoxSizer(wx.VERTICAL)

        self.headerSizer = headerSizer = wx.BoxSizer(wx.HORIZONTAL)

        cDP = service.DamagePattern.getInstance()

        self.choices = cDP.getDamagePatternList()
        # Remove "Selected Ammo" Damage Pattern
        for dp in self.choices:
            if dp.name == "Selected Ammo":
                self.choices.remove(dp)
        # Sort the remaining list and continue on
        self.choices.sort(key=lambda p: p.name)
        self.ccDmgPattern = wx.Choice(self, choices=map(lambda p: p.name, self.choices))
        self.ccDmgPattern.Bind(wx.EVT_CHOICE, self.patternChanged)
        self.ccDmgPattern.SetSelection(0)

        self.namePicker = wx.TextCtrl(self, style=wx.TE_PROCESS_ENTER)
        self.namePicker.Bind(wx.EVT_TEXT_ENTER, self.processRename)
        self.namePicker.Hide()

        self.btnSave = wx.Button(self, wx.ID_SAVE)
        self.btnSave.Hide()
        self.btnSave.Bind(wx.EVT_BUTTON, self.processRename)

        size = None
        headerSizer.Add(self.ccDmgPattern, 1, wx.ALIGN_CENTER_VERTICAL | wx.RIGHT|wx.LEFT, 3)
        buttons = (("new", wx.ART_NEW),
                   ("rename", bitmapLoader.getBitmap("rename", "icons")),
                   ("copy", wx.ART_COPY),
                   ("delete", wx.ART_DELETE))
        for name, art in buttons:
                bitmap = wx.ArtProvider.GetBitmap(art, wx.ART_BUTTON) if name != "rename" else art
                btn = wx.BitmapButton(self, wx.ID_ANY, bitmap)
                if size is None:
                    size = btn.GetSize()

                btn.SetMinSize(size)
                btn.SetMaxSize(size)

                btn.Layout()
                setattr(self, name, btn)
                btn.Enable(True)
                btn.SetToolTipString("%s pattern" % name.capitalize())
                headerSizer.Add(btn, 0, wx.ALIGN_CENTER_VERTICAL)


        mainSizer.Add(headerSizer, 0, wx.EXPAND | wx.ALL, 2)

        self.sl = wx.StaticLine(self)
        mainSizer.Add(self.sl, 0, wx.EXPAND | wx.TOP | wx.BOTTOM, 5)

        contentSizer = wx.BoxSizer(wx.VERTICAL)
        self.embitmap = bitmapLoader.getBitmap("em_big", "icons")
        self.thermbitmap = bitmapLoader.getBitmap("thermal_big", "icons")
        self.kinbitmap = bitmapLoader.getBitmap("kinetic_big", "icons")
        self.expbitmap = bitmapLoader.getBitmap("explosive_big", "icons")

        dmgeditSizer = wx.FlexGridSizer(2, 4, 0, 2)
        dmgeditSizer.AddGrowableCol(0)
        dmgeditSizer.AddGrowableCol(3)
        dmgeditSizer.SetFlexibleDirection(wx.BOTH)
        dmgeditSizer.SetNonFlexibleGrowMode(wx.FLEX_GROWMODE_SPECIFIED)

        width = -1
        defSize = wx.Size(width,-1)

        self.bmpEM = wx.StaticBitmap(self, wx.ID_ANY, self.embitmap)
        dmgeditSizer.Add(self.bmpEM, 0, wx.ALIGN_CENTER_VERTICAL | wx.ALIGN_RIGHT, 5)
        self.editEm = IntCtrl(self, wx.ID_ANY, 0, wx.DefaultPosition, defSize)
        dmgeditSizer.Add(self.editEm, 0, wx.BOTTOM | wx.TOP | wx.ALIGN_CENTER_VERTICAL, 5)

        self.bmpTHERM = wx.StaticBitmap(self, wx.ID_ANY, self.thermbitmap)
        dmgeditSizer.Add(self.bmpTHERM, 0, wx.ALIGN_CENTER_VERTICAL | wx.ALIGN_RIGHT | wx.LEFT, 25)
        self.editThermal = IntCtrl(self, wx.ID_ANY, 0, wx.DefaultPosition, defSize, 0)
        dmgeditSizer.Add(self.editThermal, 0, wx.BOTTOM | wx.TOP | wx.ALIGN_CENTER_VERTICAL, 5)

        self.bmpKIN = wx.StaticBitmap(self, wx.ID_ANY, self.kinbitmap)
        dmgeditSizer.Add(self.bmpKIN, 0, wx.ALIGN_CENTER_VERTICAL | wx.ALIGN_RIGHT, 5)
        self.editKinetic = IntCtrl(self, wx.ID_ANY, 0, wx.DefaultPosition, defSize)
        dmgeditSizer.Add(self.editKinetic, 0, wx.BOTTOM | wx.TOP | wx.ALIGN_CENTER_VERTICAL, 5)

        self.bmpEXP = wx.StaticBitmap(self, wx.ID_ANY, self.expbitmap)
        dmgeditSizer.Add(self.bmpEXP, 0, wx.ALIGN_CENTER_VERTICAL | wx.ALIGN_RIGHT | wx.LEFT, 25)
        self.editExplosive = IntCtrl(self, wx.ID_ANY, 0, wx.DefaultPosition, defSize, 0)
        dmgeditSizer.Add(self.editExplosive, 0, wx.BOTTOM | wx.TOP | wx.ALIGN_CENTER_VERTICAL, 5)

        contentSizer.Add(dmgeditSizer, 1, wx.EXPAND | wx.ALL, 5)
        self.slfooter = wx.StaticLine(self)
        contentSizer.Add(self.slfooter, 0, wx.EXPAND | wx.TOP, 5)

        footerSizer = wx.BoxSizer(wx.HORIZONTAL)
        perSizer = wx.BoxSizer(wx.VERTICAL)

        self.stPercentages = wx.StaticText(self, wx.ID_ANY, u"")
        self.stPercentages.Wrap(-1)
        perSizer.Add(self.stPercentages, 0, wx.BOTTOM | wx.TOP | wx.LEFT, 5)

        footerSizer.Add(perSizer, 1,  wx.ALIGN_CENTER_VERTICAL, 5)

        self.totSizer = wx.BoxSizer(wx.VERTICAL)

        contentSizer.Add(footerSizer, 0, wx.EXPAND, 5)

        mainSizer.Add(contentSizer, 1, wx.EXPAND, 0)

        if "wxGTK" in wx.PlatformInfo:
            self.closeBtn = wx.Button( self, wx.ID_ANY, u"Close", wx.DefaultPosition, wx.DefaultSize, 0 )
            mainSizer.Add( self.closeBtn, 0, wx.ALL|wx.ALIGN_RIGHT, 5 )
            self.closeBtn.Bind(wx.EVT_BUTTON, self.closeEvent)

        self.SetSizer(mainSizer)

        importExport = (("Import", wx.ART_FILE_OPEN, "from"),
                        ("Export", wx.ART_FILE_SAVE_AS, "to"))
        for name, art, direction in importExport:
                bitmap = wx.ArtProvider.GetBitmap(art, wx.ART_BUTTON)
                btn = wx.BitmapButton(self, wx.ID_ANY, bitmap)

                btn.SetMinSize( btn.GetSize() )
                btn.SetMaxSize( btn.GetSize() )

                btn.Layout()
                setattr(self, name, btn)
                btn.Enable(True)
                btn.SetToolTipString("%s patterns %s clipboard" % (name, direction) )
                footerSizer.Add(btn, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_RIGHT)

        self.Layout()
        bsize = self.GetBestSize()
        self.SetSize((-1,bsize.height))

        self.editEm.SetLimited(True)
        self.editThermal.SetLimited(True)
        self.editKinetic.SetLimited(True)
        self.editExplosive.SetLimited(True)

        self.editEm.SetMin(0)
        self.editThermal.SetMin(0)
        self.editKinetic.SetMin(0)
        self.editExplosive.SetMin(0)

        self.editEm.SetMax(99999)
        self.editThermal.SetMax(99999)
        self.editKinetic.SetMax(99999)
        self.editExplosive.SetMax(99999)


        self.new.Bind(wx.EVT_BUTTON, self.newPattern)
        self.rename.Bind(wx.EVT_BUTTON, self.renamePattern)
        self.copy.Bind(wx.EVT_BUTTON, self.copyPattern)
        self.delete.Bind(wx.EVT_BUTTON, self.deletePattern)
        self.Import.Bind(wx.EVT_BUTTON, self.importPatterns)
        self.Export.Bind(wx.EVT_BUTTON, self.exportPatterns)

        self.editEm.Bind(wx.EVT_TEXT, self.ValuesUpdated)
        self.editThermal.Bind(wx.EVT_TEXT, self.ValuesUpdated)
        self.editKinetic.Bind(wx.EVT_TEXT, self.ValuesUpdated)
        self.editExplosive.Bind(wx.EVT_TEXT, self.ValuesUpdated)

        self.patternChanged()

    def closeEvent(self, event):
        self.Destroy()

    def ValuesUpdated(self, event=None):
        if self.block:
            return

        p = self.getActivePattern()
        p.emAmount = self._EM = self.editEm.GetValue()
        p.thermalAmount = self._THERM = self.editThermal.GetValue()
        p.kineticAmount = self._KIN = self.editKinetic.GetValue()
        p.explosiveAmount = self._EXP = self.editExplosive.GetValue()
        total = self._EM + self._THERM + self._KIN + self._EXP
        format = "EM: %d%%,    THERM: %d%%,    KIN: %d%%,    EXP: %d%%"
        if total > 0:
            ltext = format %(self._EM*100/total, self._THERM*100/total, self._KIN*100/total, self._EXP*100/total)
        else:
            ltext = format %(0, 0, 0, 0)

        self.stPercentages.SetLabel(ltext)
        self.totSizer.Layout()

        if event is not None:
            event.Skip()

        service.DamagePattern.getInstance().saveChanges(p)

    def restrict(self):
        self.editEm.Enable(False)
        self.editExplosive.Enable(False)
        self.editKinetic.Enable(False)
        self.editThermal.Enable(False)
        self.rename.Enable(False)
        self.delete.Enable(False)

    def unrestrict(self):
        self.editEm.Enable()
        self.editExplosive.Enable()
        self.editKinetic.Enable()
        self.editThermal.Enable()
        self.rename.Enable()
        self.delete.Enable()

    def getActivePattern(self):
        if len(self.choices) == 0:
            return None

        return self.choices[self.ccDmgPattern.GetSelection()]

    def patternChanged(self, event=None):
        p = self.getActivePattern()
        if p is None:
            return

        if p.name == "Uniform" or p.name == "Selected Ammo":
            self.restrict()
        else:
            self.unrestrict()

        self.block = True
        for field in ("em", "thermal", "kinetic", "explosive"):
            edit = getattr(self, "edit%s" % field.capitalize())
            amount = getattr(p, "%sAmount" % field)
            edit.SetValue(amount)

        self.block = False
        self.ValuesUpdated()

    def newPattern(self,event):
        cDP = service.DamagePattern.getInstance()
        p = cDP.newPattern()
        self.choices.append(p)
        id = self.ccDmgPattern.Append(p.name)
        self.ccDmgPattern.SetSelection(id)
        self.btnSave.SetLabel("Create")
        self.renamePattern()

    def renamePattern(self,event=None):
        if event is not None:
            self.btnSave.SetLabel("Rename")

        self.ccDmgPattern.Hide()
        self.namePicker.Show()
        self.headerSizer.Replace(self.ccDmgPattern, self.namePicker)
        self.namePicker.SetFocus()
        self.namePicker.SetValue(self.getActivePattern().name)

        for btn in (self.new, self.rename, self.delete, self.copy):
            btn.Hide()
            self.headerSizer.Remove(btn)

        self.headerSizer.Add(self.btnSave, 0, wx.ALIGN_CENTER)
        self.btnSave.Show()
        self.headerSizer.Layout()
        if event is not None:
            event.Skip()

    def processRename(self, event):
        newName = self.namePicker.GetLineText(0)
        self.stPercentages.SetLabel("")

        p = self.getActivePattern()
        for pattern in self.choices:
            if pattern.name == newName and p != pattern:
                self.stPercentages.SetLabel("Name already used, please pick another")
                return

        if newName == "":
            self.stPercentages.SetLabel("Invalid name.")
            return

        cDP = service.DamagePattern.getInstance()
        cDP.renamePattern(p, newName)

        self.headerSizer.Replace(self.namePicker, self.ccDmgPattern)
        self.ccDmgPattern.Show()
        self.namePicker.Hide()
        self.btnSave.Hide()
        self.headerSizer.Remove(self.btnSave)
        for btn in (self.new, self.rename, self.delete, self.copy):
            self.headerSizer.Add(btn, 0, wx.ALIGN_CENTER_VERTICAL)
            btn.Show()

        sel = self.ccDmgPattern.GetSelection()
        self.ccDmgPattern.Delete(sel)
        self.ccDmgPattern.Insert(newName, sel)
        self.ccDmgPattern.SetSelection(sel)
        self.ValuesUpdated()
        self.unrestrict()

    def copyPattern(self,event):
        cDP = service.DamagePattern.getInstance()
        p = cDP.copyPattern(self.getActivePattern())
        self.choices.append(p)
        id = self.ccDmgPattern.Append(p.name)
        self.ccDmgPattern.SetSelection(id)
        self.btnSave.SetLabel("Copy")
        self.renamePattern()
        self.patternChanged()

    def deletePattern(self,event):
        cDP = service.DamagePattern.getInstance()
        sel = self.ccDmgPattern.GetSelection()
        cDP.deletePattern(self.getActivePattern())
        self.ccDmgPattern.Delete(sel)
        self.ccDmgPattern.SetSelection(max(0, sel - 1))
        del self.choices[sel]
        self.patternChanged()

    def __del__( self ):
        pass

    def importPatterns(self, event):
        text = fromClipboard()
        if text:
            sDP = service.DamagePattern.getInstance()
            sDP.importPatterns(text)
            self.stPercentages.SetLabel("Patterns imported from clipboard")
        else:
            self.stPercentages.SetLabel("Could not import from clipboard")

    def exportPatterns(self, event):
        sDP = service.DamagePattern.getInstance()
        toClipboard( sDP.exportPatterns() )
        self.stPercentages.SetLabel("Patterns exported to clipboard")

########NEW FILE########
__FILENAME__ = PFListPane
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import wx

class PFListPane(wx.ScrolledWindow):
    def __init__(self, parent):
        wx.ScrolledWindow.__init__ (self, parent, id=wx.ID_ANY, pos=wx.DefaultPosition, size=wx.Size(1, 1), style=wx.TAB_TRAVERSAL)

        self._wList = []
        self._wCount = 0
        self.itemsHeight = 1

        self.SetBackgroundColour(wx.SystemSettings_GetColour(wx.SYS_COLOUR_WINDOW))


        self.SetVirtualSize((1, 1))
        self.SetScrollRate(0, 1)

        self.Bind(wx.EVT_SCROLLWIN_LINEUP, self.MScrollUp)
        self.Bind(wx.EVT_SCROLLWIN_LINEDOWN, self.MScrollDown)
#        self.Bind(wx.EVT_CHILD_FOCUS, self.OnChildFocus)
#        self.Bind(wx.EVT_LEFT_DOWN, self.ForceFocus)
        self.SetFocus()
#        self.Bind(wx.EVT_MOUSE_CAPTURE_CHANGED, self.ForceFocus)
        self.Bind(wx.EVT_SCROLLWIN_THUMBRELEASE, self.ForceFocus)

    def ForceFocus(self,event):
        if self.FindFocus() and self.FindFocus().Parent != self:
            self.SetFocus()
        event.Skip()

    def OnChildFocus(self, event):
        event.Skip()
        child = event.GetWindow()
        self.ScrollChildIntoView(child)

    def MScrollUp(self, event):

        posy = self.GetScrollPos(wx.VERTICAL)
        posy -= self.itemsHeight
        self.Scroll(0, posy)

        event.Skip()

    def MScrollDown(self, event):

        posy = self.GetScrollPos(wx.VERTICAL)
        posy += self.itemsHeight
        self.Scroll(0, posy)

        event.Skip()


    def ScrollChildIntoView(self, child):
        """
        Scrolls the panel such that the specified child window is in view.
        """
        sppu_x, sppu_y = self.GetScrollPixelsPerUnit()
        vs_x, vs_y   = self.GetViewStart()
        cr = child.GetRect()
        clntsz = self.GetSize()
        new_vs_x, new_vs_y = -1, -1

        # is it before the left edge?
        if cr.x < 0 and sppu_x > 0:
            new_vs_x = vs_x + (cr.x / sppu_x)

        # is it above the top?
        if cr.y < 0 and sppu_y > 0:
            new_vs_y = vs_y + (cr.y / sppu_y)

        # For the right and bottom edges, scroll enough to show the
        # whole control if possible, but if not just scroll such that
        # the top/left edges are still visible

        # is it past the right edge ?
        if cr.right > clntsz.width and sppu_x > 0:
            diff = (cr.right - clntsz.width + 1) / sppu_x
            if cr.x - diff * sppu_x > 0:
                new_vs_x = vs_x + diff
            else:
                new_vs_x = vs_x + (cr.x / sppu_x)

        # is it below the bottom ?
        if cr.bottom > clntsz.height and sppu_y > 0:
            diff = (cr.bottom - clntsz.height + 1) / sppu_y
            if cr.y - diff * sppu_y > 0:
                new_vs_y = vs_y + diff
            else:
                new_vs_y = vs_y + (cr.y / sppu_y)

        # if we need to adjust
        if new_vs_x != -1 or new_vs_y != -1:
            self.Scroll(new_vs_x, new_vs_y)



    def AddWidget(self, widget):
        widget.Reparent(self)
        self._wList.append(widget)
        self._wCount += 1

    def GetWidgetList(self):
        return self._wList

    # Override this method if needed ( return False by default if we do not want to scroll to selected widget)
    def IsWidgetSelectedByContext(self, widget):
        return False

    def RefreshList(self, doRefresh = False, doFocus = False):
        ypos = 0
        maxy = 0
        scrollTo = 0

        selected = None
        for i in xrange( len(self._wList) ):
            iwidth, iheight = self._wList[i].GetSize()
            xa, ya = self.CalcScrolledPosition((0, maxy))
            self._wList[i].SetPosition((xa, ya))
            if self.IsWidgetSelectedByContext(i):
                selected = self._wList[i]
            maxy += iheight

        self.SetVirtualSize((1, maxy))
        cwidth, cheight = self.GetVirtualSize()

        if selected:
            self.ScrollChildIntoView(selected)
            #selected.SetFocus()
        elif doFocus:
            self.SetFocus()

        clientW,clientH = self.GetSize()
        for i in xrange( len(self._wList) ):
            iwidth, iheight = self._wList[i].GetSize()
            itemX,itemY = self._wList[i].GetPosition()
            self._wList[i].SetSize((cwidth, iheight))
            if doRefresh == True:
                self._wList[i].Refresh()
            self.itemsHeight = max(self.itemsHeight, iheight - 1)

    def RemoveWidget(self, child):
        child.Destroy()
        self._wList.remove(child)


    def RemoveAllChildren(self):
        for widget in self._wList:
            widget.Destroy()

        self._wList = []

########NEW FILE########
__FILENAME__ = PFSearchBox
import wx
import gui.utils.colorUtils as colorUtils
import gui.utils.drawUtils as drawUtils
from gui import bitmapLoader


SearchButton, EVT_SEARCH_BTN = wx.lib.newevent.NewEvent()
CancelButton, EVT_CANCEL_BTN = wx.lib.newevent.NewEvent()
TextEnter, EVT_TEXT_ENTER = wx.lib.newevent.NewEvent()
TextTyped, EVT_TEXT = wx.lib.newevent.NewEvent()

class PFSearchBox(wx.Window):
    def __init__(self, parent, id = wx.ID_ANY, value = "", pos = wx.DefaultPosition, size = wx.Size(-1,24), style = 0):
        wx.Window.__init__(self, parent, id, pos, size, style = 0)

        self.isSearchButtonVisible = False
        self.isCancelButtonVisible = False

        self.descriptiveText = "Search"

        self.searchBitmap = None
        self.cancelBitmap = None
        self.bkBitmap = None

        self.resized = True

        self.searchButtonX = 0
        self.searchButtonY = 0
        self.searchButtonPressed = False

        self.cancelButtonX = 0
        self.cancelButtonY = 0
        self.cancelButtonPressed = False

        self.editX = 0
        self.editY = 0


        self.padding = 4

        self._hl = False

        w,h = size
        self.EditBox = wx.TextCtrl(self, wx.ID_ANY, "", wx.DefaultPosition, (-1, h - 2 if 'wxGTK' in wx.PlatformInfo else -1 ), wx.TE_PROCESS_ENTER | (wx.BORDER_NONE if 'wxGTK' in wx.PlatformInfo else 0))

        self.Bind(wx.EVT_PAINT, self.OnPaint)
        self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnEraseBk)
        self.Bind(wx.EVT_SIZE, self.OnSize)

        self.Bind(wx.EVT_LEFT_DOWN, self.OnLeftDown)
        self.Bind(wx.EVT_LEFT_UP, self.OnLeftUp)
        self.Bind(wx.EVT_MOTION, self.OnMouseMove)

        self.Bind(wx.EVT_ENTER_WINDOW, self.OnEnterLeaveWindow)
        self.Bind(wx.EVT_LEAVE_WINDOW, self.OnEnterLeaveWindow)

#        self.EditBox.ChangeValue(self.descriptiveText)

        self.EditBox.Bind(wx.EVT_SET_FOCUS, self.OnEditSetFocus)
        self.EditBox.Bind(wx.EVT_KILL_FOCUS, self.OnEditKillFocus)

        self.EditBox.Bind(wx.EVT_TEXT, self.OnText)
        self.EditBox.Bind(wx.EVT_TEXT_ENTER, self.OnTextEnter)

        self.SetMinSize(size)

    def OnEnterLeaveWindow(self, event):
        self.SetCursor(wx.StockCursor(wx.CURSOR_ARROW))
        self._hl = False

    def OnText(self, event):
        wx.PostEvent(self, TextTyped())

    def OnTextEnter(self, event):
        wx.PostEvent(self, TextEnter())

    def OnEditSetFocus(self, event):
#        value = self.EditBox.GetValue()
#        if value == self.descriptiveText:
#            self.EditBox.ChangeValue("")
        pass

    def OnEditKillFocus(self, event):
        if self.EditBox.GetValue() == "":
            self.Clear()

    def Clear(self):
        self.EditBox.Clear()
#        self.EditBox.ChangeValue(self.descriptiveText)

    def SetValue(self, value):
        self.EditBox.SetValue(value)

    def ChangeValue(self, value):
        self.EditBox.ChangeValue(value)

    def GetValue(self):
        return self.EditBox.GetValue()

    def GetLineText(self, lineno):
        return self.EditBox.GetLineText(lineno)

    def HitTest(self, target, position, area):
        x, y = target
        px, py = position
        aX, aY = area
        if (px > x and px < x + aX) and (py > y and py < y + aY):
            return True
        return False

    def GetButtonsPos(self):
        btnpos = []
        btnpos.append( (self.searchButtonX, self.searchButtonY) )
        btnpos.append( (self.cancelButtonX, self.cancelButtonY) )
        return btnpos

    def GetButtonsSize(self):
        btnsize = []

        if self.searchBitmap:
            sw = self.searchBitmap.GetWidth()
            sh = self.searchBitmap.GetHeight()
        else:
            sw = 0
            sh = 0

        if self.cancelBitmap:
            cw = self.cancelBitmap.GetWidth()
            ch = self.cancelBitmap.GetHeight()
        else:
            cw = 0
            ch = 0

        btnsize.append( (sw,sh))
        btnsize.append( (cw,ch))
        return btnsize

    def OnMouseMove(self, event):
        btnpos = self.GetButtonsPos()
        btnsize = self.GetButtonsSize()
        for btn in xrange(2):
            if self.HitTest(btnpos[btn], event.GetPosition(), btnsize[btn]):
                if not self._hl:
                    self.SetCursor(wx.StockCursor(wx.CURSOR_HAND))
                    self._hl = True
                break
            else:
                if self._hl:
                    self.SetCursor(wx.StockCursor(wx.CURSOR_ARROW))
                    self._hl = False

    def OnLeftDown(self, event):
        btnpos = self.GetButtonsPos()
        btnsize = self.GetButtonsSize()

        self.CaptureMouse()
        for btn in xrange(2):
            if self.HitTest(btnpos[btn], event.GetPosition(), btnsize[btn]):
                if btn == 0:
                    if not self.searchButtonPressed:
                        self.searchButtonPressed = True
                        self.Refresh()
                if btn == 1:
                    if not self.cancelButtonPressed:
                        self.cancelButtonPressed = True
                        self.Refresh()

    def OnLeftUp(self, event):
        btnpos = self.GetButtonsPos()
        btnsize = self.GetButtonsSize()

        if self.HasCapture():
            self.ReleaseMouse()

        for btn in xrange(2):
            if self.HitTest(btnpos[btn], event.GetPosition(), btnsize[btn]):
                if btn == 0:
                    if self.searchButtonPressed:
                        self.searchButtonPressed = False
                        self.Refresh()
                        self.SetFocus()
                        wx.PostEvent(self, SearchButton())
                if btn == 1:
                    if self.cancelButtonPressed:
                        self.cancelButtonPressed = False
                        self.Refresh()
                        self.SetFocus()
                        wx.PostEvent(self, CancelButton())
            else:
                if btn == 0:
                    if self.searchButtonPressed:
                        self.searchButtonPressed = False
                        self.Refresh()
                if btn == 1:
                    if self.cancelButtonPressed:
                        self.cancelButtonPressed = False
                        self.Refresh()

    def OnSize(self, event):
        self.resized = True
        self.Refresh()

    def OnEraseBk(self, event):
        pass

    def UpdateElementsPos(self, dc):
        rect = self.GetRect()

        if self.searchBitmap and self.isSearchButtonVisible:
            sw = self.searchBitmap.GetWidth()
            sh = self.searchBitmap.GetHeight()
        else:
            sw = 0
            sh = 0

        if self.cancelBitmap and self.isCancelButtonVisible:
            cw = self.cancelBitmap.GetWidth()
            ch = self.cancelBitmap.GetHeight()
        else:
            cw = 0
            ch = 0

        cwidth = rect.width
        cheight = rect.height

        self.searchButtonX = self.padding
        self.searchButtonY = (cheight - sh) / 2
        self.cancelButtonX = cwidth - self.padding - cw
        self.cancelButtonY = (cheight - ch) / 2

        self.editX = self.searchButtonX + self.padding + sw

        editWidth, editHeight = self.EditBox.GetSize()

        self.editY = (cheight - editHeight)/2
        self.EditBox.SetPosition((self.editX, self.editY))
        self.EditBox.SetSize( (self.cancelButtonX - self.padding - self.editX, -1))

    def OnPaint(self, event):
        dc = wx.BufferedPaintDC(self)

        bkColor = wx.SystemSettings_GetColour(wx.SYS_COLOUR_WINDOW)
        sepColor = colorUtils.GetSuitableColor(bkColor, 0.2)
        rect = self.GetRect()

        if self.resized:
            self.bkBitmap = drawUtils.RenderGradientBar(bkColor, rect.width, rect.height, 0.1, 0.1, 0.2, 2)
            self.UpdateElementsPos(dc)
            self.resized = False

        dc.DrawBitmap(self.bkBitmap, 0, 0)

        if self.isSearchButtonVisible:
            if self.searchBitmap:
                if self.searchButtonPressed:
                    spad = 1
                else:
                    spad = 0

                dc.DrawBitmap(self.searchBitmapShadow, self.searchButtonX + 1, self.searchButtonY + 1)
                dc.DrawBitmap(self.searchBitmap, self.searchButtonX + spad, self.searchButtonY + spad)


        if self.isCancelButtonVisible:
            if self.cancelBitmap:
                if self.cancelButtonPressed:
                    cpad = 1
                else:
                    cpad = 0
                dc.DrawBitmap(self.cancelBitmapShadow, self.cancelButtonX + 1, self.cancelButtonY + 1)
                dc.DrawBitmap(self.cancelBitmap, self.cancelButtonX + cpad, self.cancelButtonY + cpad)

        dc.SetPen(wx.Pen(sepColor,1))
        dc.DrawLine(0,rect.height - 1, rect.width, rect.height - 1)

    def SetSearchBitmap(self, bitmap):
        self.searchBitmap = bitmap
        self.searchBitmapShadow = drawUtils.CreateDropShadowBitmap(bitmap, 0.2)

    def SetCancelBitmap(self, bitmap):
        self.cancelBitmap = bitmap
        self.cancelBitmapShadow = drawUtils.CreateDropShadowBitmap(bitmap, 0.2)

    def IsSearchButtonVisible(self):
        return self.isSearchButtonVisible

    def IsCancelButtonVisible(self):
        return self.isCancelButtonVisible

    def ShowSearchButton(self, show = True):
        self.isSearchButtonVisible = show

    def ShowCancelButton(self, show = True):
        self.isCancelButtonVisible = show

    def SetDescriptiveText(self, text):
        self.descriptiveText = text

    def GetDescriptiveText(self):
        return self.descriptiveText


########NEW FILE########
__FILENAME__ = preferenceDialog
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import wx
from gui.preferenceView import PreferenceView
import bitmapLoader

class PreferenceDialog(wx.Dialog):

    def __init__(self, parent):
        wx.Dialog.__init__(self, parent, id=wx.ID_ANY, size=wx.DefaultSize, style=wx.DEFAULT_DIALOG_STYLE)
        self.SetTitle("pyfa - Preferences")
        i = wx.IconFromBitmap(bitmapLoader.getBitmap("preferences_small", "icons"))
        self.SetIcon(i)
        mainSizer = wx.BoxSizer(wx.VERTICAL)

        self.listbook = wx.Listbook(self, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.LB_DEFAULT)

        self.listview = self.listbook.GetListView()
        self.listview.SetMinSize((500, -1))
        self.listview.SetSize((500, -1))

        self.imageList = wx.ImageList(32,32)
        self.listbook.SetImageList(self.imageList)

        mainSizer.Add(self.listbook, 1, wx.EXPAND | wx.TOP|wx.BOTTOM|wx.LEFT, 5)

        self.m_staticline2 = wx.StaticLine( self, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.LI_HORIZONTAL )
        mainSizer.Add( self.m_staticline2, 0, wx.EXPAND, 5 )

        btnSizer = wx.BoxSizer( wx.HORIZONTAL )
        btnSizer.AddSpacer( ( 0, 0), 1, wx.EXPAND, 5 )
        self.btnOK = wx.Button( self, wx.ID_ANY, u"OK", wx.DefaultPosition, wx.DefaultSize, 0 )
        btnSizer.Add( self.btnOK, 0, wx.ALL, 5 )
        mainSizer.Add(btnSizer,0 , wx.EXPAND, 5)
        self.SetSizer(mainSizer)

        self.Centre(wx.BOTH)

        for prefView in PreferenceView.views:
            page = wx.Panel(self.listbook)
            bmp = prefView.getImage()
            if bmp:
                imgID = self.imageList.Add(bmp)
            else:
                imgID = -1
            prefView.populatePanel(page)
            self.listbook.AddPage(page, prefView.title, imageId = imgID)

        # Set the height based on a condition. Can all the panels fit in the current height?
        # If not, use the .GetBestVirtualSize() to ensure that all content is available.
        minHeight = 360
        bestFit   = self.GetBestVirtualSize()
        if minHeight > bestFit[1]:
            self.SetSizeWH(450, minHeight)
        else:
            self.SetSizeWH(450, bestFit[1])

        self.Layout()

        self.btnOK.Bind(wx.EVT_BUTTON, self.OnBtnOK)

    def OnBtnOK(self, event):
        self.Destroy()
########NEW FILE########
__FILENAME__ = preferenceView
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import wx

class PreferenceView(object):
    views = []
    def __init__(self):
        pass

    @classmethod
    def register(cls):
        PreferenceView.views.append(cls())

    def populatePanel(self, panel):
        raise NotImplementedError()

    def refreshPanel(self, fit):
        raise NotImplementedError()

    def getImage(self):
        return wx.NullBitmap

from gui.builtinPreferenceViews import *


########NEW FILE########
__FILENAME__ = projectedView
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import wx
import gui.display as d
import gui.globalEvents as GE
import service
import gui.droneView
from gui.builtinViewColumns.state import State
from gui.contextMenu import ContextMenu
import eos.types

class ProjectedViewDrop(wx.PyDropTarget):
        def __init__(self, dropFn):
            wx.PyDropTarget.__init__(self)
            self.dropFn = dropFn
            # this is really transferring an EVE itemID
            self.dropData = wx.PyTextDataObject()
            self.SetDataObject(self.dropData)

        def OnData(self, x, y, t):
            if self.GetData():
                data = self.dropData.GetText().split(':')
                self.dropFn(x, y, data)
            return t

class ProjectedView(d.Display):
    DEFAULT_COLS = ["State",
                    "Ammo Icon",
                    "Base Icon",
                    "Base Name",
                    "Ammo"]

    def __init__(self, parent):
        d.Display.__init__(self, parent, style = wx.LC_SINGLE_SEL | wx.BORDER_NONE)

        self.lastFitId = None

        self.mainFrame.Bind(GE.FIT_CHANGED, self.fitChanged)
        self.Bind(wx.EVT_LEFT_DOWN, self.click)
        self.Bind(wx.EVT_RIGHT_DOWN, self.click)
        self.Bind(wx.EVT_LEFT_DCLICK, self.remove)
        self.Bind(wx.EVT_KEY_UP, self.kbEvent)

        self.droneView = gui.droneView.DroneView

        if "__WXGTK__" in  wx.PlatformInfo:
            self.Bind(wx.EVT_RIGHT_UP, self.scheduleMenu)
        else:
            self.Bind(wx.EVT_RIGHT_DOWN, self.scheduleMenu)

        self.Bind(wx.EVT_LIST_BEGIN_DRAG, self.startDrag)
        self.SetDropTarget(ProjectedViewDrop(self.handleListDrag))

    def handleListDrag(self, x, y, data):
        '''
        Handles dragging of items from various pyfa displays which support it

        data is list with two indices:
            data[0] is hard-coded str of originating source
            data[1] is typeID or index of data we want to manipulate
        '''

        if data[0] == "projected":
            # if source is coming from projected, we are trying to combine drones.
            self.mergeDrones(x, y, int(data[1]))
        elif data[0] == "market":
            sFit = service.Fit.getInstance()
            fitID = self.mainFrame.getActiveFit()
            sFit.project(fitID, int(data[1]))
            wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=self.mainFrame.getActiveFit()))

    def kbEvent(self,event):
        keycode = event.GetKeyCode()
        if keycode == wx.WXK_DELETE or keycode == wx.WXK_NUMPAD_DELETE:
            fitID = self.mainFrame.getActiveFit()
            cFit = service.Fit.getInstance()
            row = self.GetFirstSelected()
            if row != -1:
                cFit.removeProjected(fitID, self.get(row))
                wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=fitID))

        event.Skip()

    def handleDrag(self, type, fitID):
        #Those are drags coming from pyfa sources, NOT builtin wx drags
        if type == "fit":
            activeFit = self.mainFrame.getActiveFit()
            if activeFit:
                sFit = service.Fit.getInstance()
                draggedFit = sFit.getFit(fitID)
                sFit.project(activeFit, draggedFit)
                wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=activeFit))

    def startDrag(self, event):
        row = event.GetIndex()
        if row != -1 and isinstance(self.get(row), eos.types.Drone):
            data = wx.PyTextDataObject()
            data.SetText("projected:"+str(self.GetItemData(row)))

            dropSource = wx.DropSource(self)
            dropSource.SetData(data)
            dropSource.DoDragDrop()

    def mergeDrones(self, x, y, itemID):
        srcRow = self.FindItemData(-1,itemID)
        dstRow, _ = self.HitTest((x, y))
        if srcRow != -1 and dstRow != -1:
            self._merge(srcRow, dstRow)

    def _merge(self, src, dst):
        dstDrone = self.get(dst)
        if isinstance(dstDrone, eos.types.Drone):
            sFit = service.Fit.getInstance()
            fitID = self.mainFrame.getActiveFit()
            if sFit.mergeDrones(fitID, self.get(src), dstDrone, True):
                wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=fitID))


    def moduleSort(self, module):
        return module.item.name

    def droneSort(self, drone):
        item = drone.item
        if item.marketGroup is None:
            item = item.metaGroup.parent

        return (self.droneView.DRONE_ORDER.index(item.marketGroup.name),
                drone.item.name)

    def fitSort(self, fit):
        return fit.name

    def fitChanged(self, event):
        #Clear list and get out if current fitId is None
        if event.fitID is None and self.lastFitId is not None:
            self.DeleteAllItems()
            self.lastFitId = None
            event.Skip()
            return

        cFit = service.Fit.getInstance()
        fit = cFit.getFit(event.fitID)
        stuff = []
        if fit is not None:
            self.modules = fit.projectedModules[:]
            self.drones = fit.projectedDrones[:]
            self.fits = fit.projectedFits[:]

            self.modules.sort(key=self.moduleSort)
            self.drones.sort(key=self.droneSort)
            self.fits.sort(key=self.fitSort)

            stuff.extend(self.modules)
            stuff.extend(self.drones)
            stuff.extend(self.fits)

        if event.fitID != self.lastFitId:
            self.lastFitId = event.fitID

            item = self.GetNextItem(-1, wx.LIST_NEXT_ALL, wx.LIST_STATE_DONTCARE)

            if item != -1:
                self.EnsureVisible(item)

            self.deselectItems()
        self.update(stuff)

    def get(self, row):
        numMods = len(self.modules)
        numDrones = len(self.drones)
        if row < numMods:
            stuff = self.modules[row]
        elif row - numMods < numDrones:
            stuff = self.drones[row - numMods]
        else:
            stuff = self.fits[row - numMods - numDrones]

        return stuff

    def click(self, event):
        event.Skip()
        row, _ = self.HitTest(event.Position)
        if row != -1:
            item = self.get(row)
            col = self.getColumn(event.Position)
            if col == self.getColIndex(State):
                fitID = self.mainFrame.getActiveFit()
                sFit = service.Fit.getInstance()
                sFit.toggleProjected(fitID, item, "right" if event.Button == 3 else "left")
                wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=fitID))

    def scheduleMenu(self, event):
        event.Skip()
        if self.getColumn(event.Position) != self.getColIndex(State):
            wx.CallAfter(self.spawnMenu)

    def spawnMenu(self):
        sel = self.GetFirstSelected()
        menu = None
        if sel != -1:
            item = self.get(sel)
            sMkt = service.Market.getInstance()
            if isinstance(item, eos.types.Drone):
                srcContext = "projectedDrone"
                itemContext = sMkt.getCategoryByItem(item.item).name
                context = ((srcContext, itemContext),)
            elif isinstance(item, eos.types.Module):
                modSrcContext = "projectedModule"
                modItemContext = sMkt.getCategoryByItem(item.item).name
                modFullContext = (modSrcContext, modItemContext)
                if item.charge is not None:
                    chgSrcContext = "projectedCharge"
                    chgItemContext = sMkt.getCategoryByItem(item.charge).name
                    chgFullContext = (chgSrcContext, chgItemContext)
                    context = (modFullContext, chgFullContext)
                else:
                    context = (modFullContext,)
            else:
                fitSrcContext = "projectedFit"
                fitItemContext = item.name
                context = ((fitSrcContext,fitItemContext),)
            context = context + (("projected",),)
            menu = ContextMenu.getMenu((item,), *context)
        elif sel == -1:
            fitID = self.mainFrame.getActiveFit()
            if fitID is None:
                return
            context = (("projected",),)
            menu = ContextMenu.getMenu([], *context)
        if menu is not None:
            self.PopupMenu(menu)

    def remove(self, event):
        row, _ = self.HitTest(event.Position)
        if row != -1:
            col = self.getColumn(event.Position)
            if col != self.getColIndex(State):
                fitID = self.mainFrame.getActiveFit()
                cFit = service.Fit.getInstance()
                cFit.removeProjected(fitID, self.get(row))
                wx.PostEvent(self.mainFrame, GE.FitChanged(fitID=fitID))

########NEW FILE########
__FILENAME__ = pyfatogglepanel
# -*- coding: utf-8 -*-

###########################################################################
## pyfatogllepanel.py
##
## Author: Darriele - HomeWorld
##
## Project home: http://github.com/DarkFenX/Pyfa - pyfa project
## Some portions of code are based on
## AGW:pycollapsiblepane generic implementation of wx.CollapsiblePane
## AGW:pycollapsiblepane credits ( from the original source file used ):
##      Andrea Gavana, @ 09 Aug 2007
##      Latest Revision: 12 Apr 2010, 12.00 GMT
##
## Module description:
##      TogglePanel class is a wx.collipsablepane like implementation that uses
##      some optimization from awg::pycollipsablepane to provide certain
##      features tailored for PYFA needs.
##
## This module is part of PYFA (PYthon Fitting Assitant) and it shares the same
## licence ( read PYFA licence notice: gpl.txt )
##
## Notes: leave the commented code as it is, those line will be removed someday
###########################################################################

import wx
from gui import bitmapLoader

###########################################################################
## Class TogglePanel
###########################################################################

class TogglePanel ( wx.Panel ):

    def __init__( self, parent , forceLayout = -1):
        wx.Panel.__init__ ( self, parent, id = wx.ID_ANY, pos = wx.DefaultPosition, size = wx.Size( -1,-1 ), style = wx.TAB_TRAVERSAL )

        self._toggle = 1
        self.parent = parent
        self.forceLayout = forceLayout
        self.bkColour = self.GetBackgroundColour()

        #    Create the main sizer of this panel

        self.mainSizer = wx.BoxSizer( wx.VERTICAL )
        self.SetSizer( self.mainSizer )
        parentSize = parent.GetMinSize()

        #    Create the header panel

        self.headerPanel = wx.Panel(self)

        self.mainSizer.Add(self.headerPanel,0,wx.EXPAND | wx.TOP|wx.BOTTOM|wx.RIGHT, 1)

        #    Load expanded/collapsed bitmaps from the icons folder

        self.bmpExpanded = bitmapLoader.getBitmap("down-arrow2","icons")
        self.bmpCollapsed = bitmapLoader.getBitmap("up-arrow2","icons")

        #    Make the bitmaps have the same color as window text

        sysTextColour = wx.SystemSettings.GetColour( wx.SYS_COLOUR_WINDOWTEXT )

        img = self.bmpExpanded.ConvertToImage()
        img.Replace(0, 0, 0, sysTextColour[0], sysTextColour[1], sysTextColour[2])
        self.bmpExpanded = wx.BitmapFromImage(img)

        img = self.bmpCollapsed.ConvertToImage()
        img.Replace(0, 0, 0, sysTextColour[0], sysTextColour[1], sysTextColour[2])
        self.bmpCollapsed = wx.BitmapFromImage(img)

        self.headerBmp = wx.StaticBitmap(self.headerPanel )
        self.headerBmp.SetBitmap( self.bmpExpanded)

        #    Create the header sizer and add static bitmap and static text controls to it

        headerSizer = wx.BoxSizer( wx.HORIZONTAL )
        self.headerPanel.SetSizer( headerSizer)

        hbmpSizer = wx.BoxSizer( wx.HORIZONTAL )
        hlblSizer = wx.BoxSizer( wx.HORIZONTAL )
        self.hcntSizer = wx.BoxSizer( wx.HORIZONTAL)

        hbmpSizer.Add( self.headerBmp, 0,0, 5 )

        self.headerLabel = wx.StaticText( self.headerPanel, wx.ID_ANY, u"PYFA", wx.DefaultPosition, wx.DefaultSize, 0 )
        hlblSizer.Add( self.headerLabel, 0, wx.EXPAND , 5 )

        headerSizer.Add( hbmpSizer, 0,  wx.RIGHT, 5 )
        headerSizer.Add( hlblSizer, 0, wx.RIGHT, 5 )
        headerSizer.Add( self.hcntSizer, 0, wx.RIGHT, 5)

        #    Set the static text font weight to BOLD

        headerFont=parent.GetFont()
        headerFont.SetWeight(wx.BOLD)
        self.headerLabel.SetFont(headerFont)

        #    Create the content panel and its main sizer

        self.contentSizer = wx.BoxSizer( wx.VERTICAL )
        self.contentPanel = wx.Panel(self)
        self.contentPanel.SetSizer(self.contentSizer)

        self.mainSizer.Add( self.contentPanel, 0, wx.EXPAND | wx.RIGHT | wx.LEFT , 5)


        self.Layout()

        #    Connect Events

        self.headerLabel.Bind( wx.EVT_LEFT_UP, self.toggleContent )
        self.headerBmp.Bind( wx.EVT_LEFT_UP, self.toggleContent )
        self.headerPanel.Bind( wx.EVT_LEFT_UP, self.toggleContent )

    def __del__( self ):
        pass

    def AddToggleItem(self, hitem):
        hitem.Bind( wx.EVT_LEFT_UP, self.toggleContent )

    def GetHeaderContentSizer(self):
        return self.hcntSizer

    def GetHeaderPanel(self):
        return self.headerPanel

    def InsertItemInHeader(self, item):
        self.hcntSizer.Add(item,0,0,0)
        self.Layout()

    def AddSizer(self, sizer):
        self.contentSizer.Add(sizer, 0, wx.EXPAND | wx.ALL, 0)
        self.Layout()

    def GetContentPane(self):
        return self.contentPanel

    def SetLabel(self, label):
        self.headerLabel.SetLabel(label)

    def IsCollapsed(self):
        """ Returns ``True`` if the pane window is currently hidden. """
        if self._toggle == 1:
            return False
        else:
            return True


    def IsExpanded(self):
        """ Returns ``True`` if the pane window is currently shown. """
        if self._toggle == 1:
            return False
        else:
            return True


    def OnStateChange(self, sz):
        """
        Handles the status changes (collapsing/expanding).

        :param `sz`: an instance of `wx.Size`.
        """

        # minimal size has priority over the best size so set here our min size
        self.SetMinSize(sz)
        self.SetSize(sz)

        self.parent.GetSizer().SetSizeHints(self.parent)


        if self.IsCollapsed():
                # expanded . collapsed transition
            if self.parent.GetSizer():
                # we have just set the size hints...
                sz = self.parent.GetSizer().CalcMin()

                # use SetClientSize() and not SetSize() otherwise the size for
                # e.g. a wxFrame with a menubar wouldn't be correctly set
                self.parent.SetClientSize(sz)

            else:
                self.parent.Layout()

        else:

                    # collapsed . expanded transition

                    # force our parent to "fit", i.e. expand so that it can honour
                    # our minimal size
            self.parent.Fit()


    # Toggle the content panel (hide/show)

    def toggleContent( self, event ):
        self.Freeze()
        if self._toggle == 1:
            self.contentMinSize = self.contentPanel.GetSize()
            self.contentPanel.SetMinSize(wx.Size(self.contentMinSize[0],0))
            self.headerBmp.SetBitmap( self.bmpCollapsed)


        else:
            self.contentPanel.SetMinSize(self.contentMinSize)

            self.headerBmp.SetBitmap( self.bmpExpanded)


        self._toggle *=-1

        self.Thaw()
        if self.forceLayout == -1:
            self.OnStateChange(self.GetBestSize())
        else:
            self.parent.Layout()

########NEW FILE########
__FILENAME__ = pygauge
# --------------------------------------------------------------------------------- #
# PYFAGAUGE wxPython IMPLEMENTATION
#
# Darriele, @ 08/30/2010
# Updated: 09/07/2010
# Based on AWG : pygauge code
# --------------------------------------------------------------------------------- #

"""
PyfaGauge is a generic Gauge implementation tailored for PYFA (Python Fitting Assistant)
It uses the easeOutQuad equation from caurina.transitions.Tweener to do the animation stuff
"""

import wx
import copy
import math

from gui.utils import colorUtils
import gui.utils.drawUtils as drawUtils
import gui.utils.animEffects as animEffects

class PyGauge(wx.PyWindow):
    """
    This class provides a visual alternative for `wx.Gauge`. It currently
    only support determinant mode (see SetValue and SetRange)
    """

    def __init__(self, parent, id=wx.ID_ANY, range=100, pos=wx.DefaultPosition,
                 size=(-1,30), style=0):
        """
        Default class constructor.

        :param `parent`: parent window. Must not be ``None``;
        :param `id`: window identifier. A value of -1 indicates a default value;
        :param `pos`: the control position. A value of (-1, -1) indicates a default position,
         chosen by either the windowing system or wxPython, depending on platform;
        :param `size`: the control size. A value of (-1, -1) indicates a default size,
         chosen by either the windowing system or wxPython, depending on platform.
        """

        wx.PyWindow.__init__(self, parent, id, pos, size, style)

        self._size = size

        self._border_colour = wx.BLACK
        self._barColour    = self._barColourSorted   = [wx.Colour(212,228,255)]
        self._barGradient  = self._barGradientSorted = None

        self._border_padding = 0
        self._range = range
        self._value = 0

        self._fractionDigits = 0

        self._timerId = wx.NewId()
        self._timer = None

        self._oldValue = 0

        self._animDuration = 500
        self._animStep = 0
        self._period = 20
        self._animValue = 0
        self._animDirection = 0
        self.animEffect = animEffects.OUT_QUAD

        self.transitionsColors = [( wx.Colour(191, 191, 191, 255)  , wx.Colour(96, 191, 0, 255) ),
                                 ( wx.Colour(191, 167, 96, 255)  ,  wx.Colour(255, 191, 0, 255) ),
                                 ( wx.Colour(255, 191, 0, 255)  ,  wx.Colour(255, 128, 0, 255) ),
                                 ( wx.Colour(255, 128, 0, 255)  ,  wx.Colour(255, 0, 0, 255) )]
        self.gradientEffect = -35

        self._percentage = 0
        self._oldPercentage = 0
        self._showRemaining = False

        self.font = wx.FontFromPixelSize((0,14),wx.SWISS, wx.NORMAL, wx.NORMAL, False)

        self.SetBarGradient((wx.Colour(119,119,119),wx.Colour(153,153,153)))
        self.SetBackgroundColour(wx.Colour(51,51,51))
        self._tooltip = wx.ToolTip("")
        self.SetToolTip(self._tooltip)
        self._tooltip.SetTip("0/0")

        self.Bind(wx.EVT_PAINT, self.OnPaint)
        self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnEraseBackground)
        self.Bind(wx.EVT_TIMER, self.OnTimer)
        self.Bind(wx.EVT_ENTER_WINDOW, self.OnWindowEnter)
        self.Bind(wx.EVT_LEAVE_WINDOW, self.OnWindowLeave)

    def OnWindowEnter(self, event):
        self._showRemaining = True
        self.Refresh()

    def OnWindowLeave(self, event):
        self._showRemaining = False
        self.Refresh()

    def DoGetBestSize(self):
        """
        Overridden base class virtual. Determines the best size of the
        button based on the label and bezel size.
        """

        return wx.Size(self._size[0], self._size[1])


    def GetBorderColour(self):
        return self._border_colour

    def SetBorderColour(self, colour):
        self._border_colour = colour

    SetBorderColor = SetBorderColour
    GetBorderColor = GetBorderColour

    def GetBarColour(self):
        return self._barColour[0]

    def SetBarColour(self, colour):
        if type(colour) != type([]):
            self._barColour = [colour]
        else:
            self._barColour = list(colour)

    SetBarColor = SetBarColour
    GetBarColor = GetBarColour

    def SetFractionDigits(self, digits):
        self._fractionDigits=digits

    def GetBarGradient(self):
        """ Returns a tuple containing the gradient start and end colours. """

        if self._barGradient == None:
            return None

        return self._barGradient[0]

    def SetBarGradient(self, gradient = None):
        """
        Sets the bar gradient. This overrides the BarColour.

        :param `gradient`: a tuple containing the gradient start and end colours.
        """
        if gradient == None:
            self._barGradient = None
        else:
            if type(gradient) != type([]):
                self._barGradient = [gradient]
            else:
                self._barGradient = list(gradient)


    def GetBorderPadding(self):
        """ Gets the border padding. """

        return self._border_padding

    def SetBorderPadding(self, padding):
        """
        Sets the border padding.

        :param `padding`: pixels between the border and the progress bar.
        """

        self._border_padding = padding


    def GetRange(self):
        """ Returns the maximum value of the gauge. """

        return self._range

    def Animate(self):
        if not self._timer:
            self._timer = wx.Timer(self, self._timerId)
        self._animStep = 0
        self._timer.Start(self._period)

    def SetRange(self, range, reinit = False):
        """
        Sets the range of the gauge. The gauge length is its
        value as a proportion of the range.

        :param `range`: The maximum value of the gauge.
        """

        if self._range == range:
            return

        range = float(range)

        if range <= 0:
            self._range = 0.01
        else:
            self._range = range

        if reinit is False:
            self._oldPercentage = self._percentage
            self._percentage = (self._value/self._range) * 100
        else:
            self._oldPercentage = self._percentage
            self._percentage = 0
            self._value = 0

        self.Animate()


        self._tooltip.SetTip("%.2f/%.2f" % (self._value, self._range if self._range >0.01 else 0))


    def GetValue(self):
        """ Returns the current position of the gauge. """

        return self._value

    def SetValue(self, value):
        """ Sets the current position of the gauge. """
        if self._value == value:
            return

        value = float(value)
        self._oldPercentage = self._percentage
        self._value = value
        if value < 0:
            self._value = 0
        self._percentage = (self._value/self._range) * 100

        self.Animate()

        self._tooltip.SetTip("%.2f/%.2f" % (self._value, self._range))

    def SetValueRange(self, value, range, reinit = False):
        if self._value == value and self._range == range:
            return

        range = float(range)

        if range <= 0:
            self._range = 0.01
        else:
            self._range = range

        value = float(value)

        self._value = value
        if value < 0:
            self._value = float(0)

        if reinit is False:
            self._oldPercentage = self._percentage
            self._percentage = (self._value/self._range) * 100

        else:
            self._oldPercentage = self._percentage
            self._percentage = 0


        self.Animate()
        self._tooltip.SetTip("%.2f/%.2f" % (self._value, self._range if self._range >0.01 else 0))

    def OnEraseBackground(self, event):
        """
        Handles the ``wx.EVT_ERASE_BACKGROUND`` event for L{PyGauge}.

        :param `event`: a `wx.EraseEvent` event to be processed.

        :note: This method is intentionally empty to reduce flicker.
        """

        pass

    def OnPaint(self, event):
        """
        Handles the ``wx.EVT_PAINT`` event for L{PyGauge}.

        :param `event`: a `wx.PaintEvent` event to be processed.
        """

        dc = wx.BufferedPaintDC(self)
        rect = self.GetClientRect()

        dc.SetBackground(wx.Brush(self.GetBackgroundColour()))
        dc.Clear()

        colour = self.GetBackgroundColour()

        dc.SetBrush(wx.Brush(colour))
        dc.SetPen(wx.Pen(colour))

        dc.DrawRectangleRect(rect)

        value = self._percentage
        if self._timer:
            if self._timer.IsRunning():
                value = self._animValue

        if self._border_colour:
            dc.SetPen(wx.Pen(self.GetBorderColour()))
            dc.DrawRectangleRect(rect)
            pad = 1 + self.GetBorderPadding()
            rect.Deflate(pad,pad)

        if self.GetBarGradient():

            if value > 100:
                w = rect.width
            else:
                w = rect.width * (float(value) / 100)
            r = copy.copy(rect)
            r.width = w


            pv = value
            xv=1
            transition = 0

            if pv <= 100:
                xv = pv/100
                transition = 0

            elif pv <=101:
                xv = pv -100
                transition = 1

            elif pv <= 103:
                xv = (pv -101)/2
                transition = 2

            elif pv <= 105:
                xv = (pv -103)/2
                transition = 3

            else:
                pv = 106
                xv = pv -100
                transition = -1

            if transition != -1:
                colorS,colorE = self.transitionsColors[transition]
                color = colorUtils.CalculateTransitionColor(colorS, colorE, xv)
            else:
                color = wx.Colour(191,48,48)

            if self.gradientEffect > 0:
                gcolor = colorUtils.BrightenColor(color,  float(self.gradientEffect) / 100)
                gMid = colorUtils.BrightenColor(color,  float(self.gradientEffect/2) / 100)
            else:
                gcolor = colorUtils.DarkenColor(color,  float(-self.gradientEffect) / 100)
                gMid = colorUtils.DarkenColor(color,  float(-self.gradientEffect/2) / 100)

            gBmp = drawUtils.DrawGradientBar(r.width, r.height, gMid, color, gcolor)
            dc.DrawBitmap(gBmp,r.left, r.top)
        else:
            colour=self.GetBarColour()
            dc.SetBrush(wx.Brush(colour))
            dc.SetPen(wx.Pen(colour))
            if value > 100:
                w = rect.width
            else:
                w = rect.width * (float(value) / 100)
            r = copy.copy(rect)
            r.width = w
            dc.DrawRectangleRect(r)

        dc.SetFont(self.font)

        r = copy.copy(rect)
        r.left +=1
        r.top +=1
        if self._range == 0.01 and self._value > 0:
            formatStr =  u'\u221e'
            dc.SetTextForeground(wx.Colour(80,80,80))
            dc.DrawLabel(formatStr, r, wx.ALIGN_CENTER)

            dc.SetTextForeground(wx.Colour(255,255,255))
            dc.DrawLabel(formatStr, rect, wx.ALIGN_CENTER)
        else:
            if self.GetBarGradient() and self._showRemaining:
                formatStr = "{0:." + str(self._fractionDigits) + "f} left"
                range = self._range if self._range > 0.01 else 0
                value = max( range - self._value , 0)
            else:
                formatStr = "{0:." + str(self._fractionDigits) + "f}%"

            dc.SetTextForeground(wx.Colour(80,80,80))
            dc.DrawLabel(formatStr.format(value), r, wx.ALIGN_CENTER)

            dc.SetTextForeground(wx.Colour(255,255,255))
            dc.DrawLabel(formatStr.format(value), rect, wx.ALIGN_CENTER)


    def OnTimer(self,event):
        """
        Handles the ``wx.EVT_TIMER`` event for L{PyfaGauge}.

        :param `event`: a timer event
        """
        oldValue=self._oldPercentage
        value=self._percentage
        start = 0

        direction = 1 if oldValue < value else -1

        end = direction * (value - oldValue)

        self._animDirection = direction
        step = self.animEffect(self._animStep, start, end, self._animDuration)

        self._animStep += self._period

        if self._timerId == event.GetId():
            stop_timer = False

            if self._animStep > self._animDuration:
                stop_timer = True

            if direction == 1:
                if (oldValue+step) < value:
                    self._animValue = oldValue+step
                else:
                    stop_timer = True
            else:
                if (oldValue-step) > value:
                    self._animValue = oldValue-step

                else:
                    stop_timer = True

            if stop_timer:
                self._timer.Stop()

            self.Refresh()


########NEW FILE########
__FILENAME__ = sfBrowserItem
import wx
import gui.utils.colorUtils as colorUtils
import gui.utils.drawUtils as drawUtils

SB_ITEM_NORMAL = 0
SB_ITEM_SELECTED = 1
SB_ITEM_HIGHLIGHTED = 2
SB_ITEM_DISABLED = 4

BTN_NORMAL   = 1
BTN_PRESSED  = 2
BTN_HOVER    = 4
BTN_DISABLED = 8


class PFBaseButton(object):
    def __init__(self, normalBitmap = wx.NullBitmap,label = "", callback = None, hoverBitmap = None, disabledBitmap = None, show = True):

        self.normalBmp = normalBitmap
        self.dropShadowOpacity = 0.2
        self.dropShadowBmp = drawUtils.CreateDropShadowBitmap(self.normalBmp, self.dropShadowOpacity)
        self.hoverBmp = hoverBitmap
        self.disabledBmp = disabledBitmap
        self.label = label
        self.show = show

        self.callback = callback

        self.state = BTN_NORMAL
        # state : BTN_STUFF

    def Show(self, show):
        self.show = show

    def Hide(self):
        self.show = False

    def IsVisible(self):
        return self.show

    def SetCallback(self, callback):
        self.callback = callback

    def GetCallback(self):
        return self.callback

    def DoCallback(self):
        if self.callback:
            self.callback()

    def SetState(self, state = BTN_NORMAL):
        self.state = state

    def GetState(self):
        return self.state

    def GetSize(self):
        w = self.normalBmp.GetWidth()
        h = self.normalBmp.GetHeight()
        return (w,h)

    def GetBitmap(self):
        return self.normalBmp

    def SetBitmap(self, bitmap):
        self.normalBmp = bitmap
        self.dropShadowBmp = drawUtils.CreateDropShadowBitmap(self.normalBmp, self.dropShadowOpacity)

    def GetLabel(self):
        return self.label

    def GetHoverBitmap(self):
        if self.hoverBmp == None:
            return self.normalBmp
        return self.hoverBmp

    def GetDisabledBitmap(self):
        if self.disabledBmp == None:
            return self.normalBmp
        return self.disabledBmp

    def GetDropShadowBitmap(self):
        return self.dropShadowBmp

class PFToolbar(object):
    def __init__(self, parent):
        self.Parent = parent
        self.buttons =[]
        self.toolbarX = 0
        self.toolbarY = 0
        self.padding = 2
        self.hoverLabel = ""

    def SetPosition(self, pos):
        self.toolbarX, self.toolbarY = pos

    def AddButton(self, btnBitmap, label = "", clickCallback = None, hoverBitmap = None, disabledBitmap = None, show = True):
        btn = PFBaseButton(btnBitmap, label, clickCallback, hoverBitmap, disabledBitmap, show)
        self.buttons.append(btn)
        return btn

    def ClearState(self):
        for button in self.buttons:
            button.SetState()
        self.hoverLabel = ""

    def MouseMove(self, event):
        doRefresh = False
        changeCursor = False
        bx = self.toolbarX
        self.hoverLabel = ""

        for button in self.buttons:
            if not button.IsVisible():
                continue

            state = button.GetState()
            if self.HitTest( (bx, self.toolbarY), event.GetPosition(), button.GetSize()):
                changeCursor = True
                if not state & BTN_HOVER:
                    button.SetState(state | BTN_HOVER)
                    self.hoverLabel = button.GetLabel()
                    self.Parent.SetCursor(wx.StockCursor(wx.CURSOR_HAND))
                    doRefresh = True
            else:
                if state & BTN_HOVER:
                    button.SetState(state ^ BTN_HOVER)
                    doRefresh = True

            bwidth, bheight = button.GetSize()
            bx += bwidth + self.padding

        if not changeCursor:
            self.Parent.SetCursor(wx.StockCursor(wx.CURSOR_ARROW))
        return doRefresh

    def MouseClick(self, event):
        mx,my = event.GetPosition()
        bx = self.toolbarX
        for button in self.buttons:
            if not button.IsVisible():
                continue

            state = button.GetState()
            if state & BTN_PRESSED:
                button.SetState(state ^ BTN_PRESSED )
                if self.HitTest( (bx, self.toolbarY), event.GetPosition(), button.GetSize()):
                    return button
                else:
                    return False
            bwidth, bheight = button.GetSize()
            bx += bwidth + self.padding

        bx = self.toolbarX
        for button in self.buttons:
            if not button.IsVisible():
                continue

            state = button.GetState()

            if self.HitTest( (bx, self.toolbarY), event.GetPosition(), button.GetSize()):

                if event.LeftDown() or event.LeftDClick():
                    button.SetState(state | BTN_PRESSED)
                    return button

                elif event.LeftUp():
                    button.SetState(state | (not BTN_PRESSED))
                    return button

            bwidth, bheight = button.GetSize()
            bx += bwidth + self.padding

        return None

    def GetWidth(self):
        bx = 0
        for button in self.buttons:
            if not button.IsVisible():
                continue

            bwidth, bheight = button.GetSize()
            bx += bwidth + self.padding

        return bx

    def GetHeight(self):
        height = 0
        for button in self.buttons:
            if not button.IsVisible():
                continue

            bwidth, bheight = button.GetSize()
            height = max(height, bheight)

        return height

    def HitTest(self, target, position, area):
        x, y = target
        px, py = position
        aX, aY = area
        if (px > x and px < x + aX) and (py > y and py < y + aY):
            return True
        return False

    def Render(self, pdc):
        bx = self.toolbarX
        for button in self.buttons:
            if not button.IsVisible():
                continue

            by = self.toolbarY
            tbx = bx

            btnState = button.GetState()

            bmp = button.GetDisabledBitmap()
            dropShadowBmp = button.GetDropShadowBitmap()

            if btnState & BTN_NORMAL:
                bmp = button.GetBitmap()

            if btnState & BTN_HOVER:
                bmp = button.GetHoverBitmap()

            if btnState & BTN_PRESSED:
                bmp = button.GetBitmap()
                by += self.padding / 2
                tbx += self.padding / 2

            bmpWidth = bmp.GetWidth()

            pdc.DrawBitmap(dropShadowBmp,bx + self.padding / 2, self.toolbarY + self.padding / 2)
            pdc.DrawBitmap(bmp, tbx, by)

            bx += bmpWidth + self.padding


class SFBrowserItem(wx.Window):
    def __init__(self, parent, id = wx.ID_ANY, pos = wx.DefaultPosition, size = (0,16), style = 0):
        wx.Window.__init__(self, parent, id, pos, size, style)

        self.highlighted = False
        self.selected = False
        self.bkBitmap = None

        self.canBeDragged = False

        self.toolbar = PFToolbar(self)


        self.Bind(wx.EVT_PAINT, self.OnPaint)
        self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnEraseBackground)
        self.Bind(wx.EVT_LEFT_UP, self.OnLeftUp)

        if "wxMSW" in wx.PlatformInfo:
            self.Bind(wx.EVT_LEFT_DCLICK, self.OnLeftDown)


        self.Bind(wx.EVT_LEFT_DOWN,self.OnLeftDown)
        self.Bind(wx.EVT_ENTER_WINDOW, self.OnEnterWindow)
        self.Bind(wx.EVT_LEAVE_WINDOW, self.OnLeaveWindow)
        self.Bind(wx.EVT_MOTION, self.OnMotion)

    def Refresh(self):
        self.RenderBackground()
        wx.Window.Refresh(self)

    def OnPaint(self, event):
        mdc = wx.BufferedPaintDC(self)

        self.RenderBackground()

        mdc.DrawBitmap(self.bkBitmap, 0,0)

        self.DrawItem(mdc)
        self.toolbar.Render(mdc)

    def DrawItem(self, mdc):
        pass

    def OnEraseBackground(self, event):
        pass

    def MouseLeftUp(self, event):
        pass

    def MouseLeftDown(self, event):
        pass

    def MouseMove(self, event):
        pass

    def SetDraggable(self, mode = True):
        self.canBeDragged = mode

    def OnLeftUp(self, event):

        if self.HasCapture():
            self.ReleaseMouse()
        if not self.canBeDragged:
            mposx, mposy = wx.GetMousePosition()
            rect = self.GetRect()
            rect.top = rect.left = 0
            cx,cy = self.ScreenToClient((mposx,mposy))
            if not rect.Contains((cx,cy)):
                self.SetHighlighted(False)
                self.toolbar.ClearState()
                self.Refresh()
                return


        btn = self.toolbar.MouseClick(event)

        if btn is not None:
            if btn is not False:
                if btn.GetState() & BTN_NORMAL:
                    btn.DoCallback()
                    self.Refresh()
            else:
                self.Refresh()
            return

        self.MouseLeftUp(event)


    def OnLeftDown(self, event):
        self.CaptureMouse()

        btn = self.toolbar.MouseClick(event)

        if btn is not None:
            if btn.GetState() & BTN_PRESSED:
                self.Refresh()
            return

        self.MouseLeftDown(event)

    def OnEnterWindow(self, event):
        self.SetHighlighted(True)
        self.toolbar.ClearState()
        self.Refresh()
        event.Skip()

    def OnLeaveWindow(self, event):
        self.SetHighlighted(False)
        self.toolbar.ClearState()
        self.Refresh()
        event.Skip()

    def OnMotion(self, event):
        if self.toolbar.MouseMove(event):
            self.Refresh()

        self.MouseMove(event)

        event.Skip()

    def GetType(self):
        return -1

    def SetSelected(self, select = True):
        self.selected = select

    def SetHighlighted(self, highlight = True):
        self.highlighted = highlight

    def GetState(self):

        if self.highlighted and not self.selected:
            state = SB_ITEM_HIGHLIGHTED

        elif self.selected:
            if self.highlighted:
                state = SB_ITEM_SELECTED  | SB_ITEM_HIGHLIGHTED
            else:
                state = SB_ITEM_SELECTED
        else:
            state = SB_ITEM_NORMAL

        return state

    def RenderBackground(self):
        rect = self.GetRect()

        windowColor = wx.SystemSettings_GetColour(wx.SYS_COLOUR_WINDOW)

        state = self.GetState()

        sFactor = 0.2
        mFactor = None
        eFactor = 0

        if state == SB_ITEM_HIGHLIGHTED:
            mFactor = 0.45
            eFactor = 0.30

        elif state == SB_ITEM_SELECTED  | SB_ITEM_HIGHLIGHTED:
            eFactor = 0.3
        elif state == SB_ITEM_SELECTED:
            eFactor = 0.15
        else:
            sFactor = 0.0

        if self.bkBitmap:
            if self.bkBitmap.eFactor == eFactor and self.bkBitmap.sFactor == sFactor and self.bkBitmap.mFactor == mFactor \
             and rect.width == self.bkBitmap.GetWidth() and rect.height == self.bkBitmap.GetHeight() :
                return
            else:
                del self.bkBitmap

        self.bkBitmap = drawUtils.RenderGradientBar(windowColor, rect.width, rect.height, sFactor, eFactor, mFactor)
        self.bkBitmap.state = state
        self.bkBitmap.sFactor = sFactor
        self.bkBitmap.eFactor = eFactor
        self.bkBitmap.mFactor = mFactor
########NEW FILE########
__FILENAME__ = shipBrowser
import wx
import copy
from gui import bitmapLoader
import gui.mainFrame
import gui.globalEvents as GE
import time
from gui.PFListPane import PFListPane
import service

from wx.lib.buttons import GenBitmapButton

import gui.utils.colorUtils as colorUtils
import gui.utils.drawUtils as drawUtils
import gui.utils.animUtils as animUtils
import gui.utils.animEffects as animEffects

import gui.sfBrowserItem as SFItem
from gui.contextMenu import ContextMenu

import service

FitRenamed, EVT_FIT_RENAMED = wx.lib.newevent.NewEvent()
FitSelected, EVT_FIT_SELECTED = wx.lib.newevent.NewEvent()
FitRemoved, EVT_FIT_REMOVED = wx.lib.newevent.NewEvent()

BoosterListUpdated, BOOSTER_LIST_UPDATED = wx.lib.newevent.NewEvent()

Stage1Selected, EVT_SB_STAGE1_SEL = wx.lib.newevent.NewEvent()
Stage2Selected, EVT_SB_STAGE2_SEL = wx.lib.newevent.NewEvent()
Stage3Selected, EVT_SB_STAGE3_SEL = wx.lib.newevent.NewEvent()
SearchSelected, EVT_SB_SEARCH_SEL = wx.lib.newevent.NewEvent()

class PFWidgetsContainer(PFListPane):
    def __init__(self,parent):
        PFListPane.__init__(self,parent)

        self.anim = animUtils.LoadAnimation(self,label = "", size=(100,12))
        self.anim.Stop()
        self.anim.Show(False)

    def ShowLoading(self, mode = True):
        if mode:
            aweight,aheight = self.anim.GetSize()
            cweight,cheight = self.GetSize()
            ax = (cweight - aweight)/2
            ay = (cheight - aheight)/2
            self.anim.SetPosition((ax,ay))
            self.anim.Show()
            self.anim.Play()
        else:
            self.anim.Stop()
            self.anim.Show(False)

    def IsWidgetSelectedByContext(self, widget):
        mainFrame = gui.mainFrame.MainFrame.getInstance()
        stage = self.Parent.GetActiveStage()
        fit = mainFrame.getActiveFit()
        if stage == 3 or stage == 4:
            if self._wList[widget].GetType() == 3:
                if fit == self._wList[widget].fitID:
                    return True
        return False


class RaceSelector(wx.Window):
    def __init__ (self, parent, id = wx.ID_ANY, label = "", pos = wx.DefaultPosition, size = wx.DefaultSize, style = 0, layout = wx.VERTICAL, animate = False):
        wx.Window.__init__(self, parent, id, pos = pos, size = size, style = style)

        self.animTimerID = wx.NewId()
        self.animTimer = wx.Timer(self, self.animTimerID)
        self.animPeriod = 25
        self.animDuration = 250
        self.animStep = 0
        self.maxWidth = 24
        self.minWidth = 5 if animate else self.maxWidth
        self.maxHeight = 24
        self.minHeight = 10 if animate else self.maxHeight

        self.direction = 0 if animate else 1
        self.layout = layout
        self.animate = animate

        if layout == wx.VERTICAL:
            self.SetSize(wx.Size(self.minWidth, -1))
            self.SetMinSize(wx.Size(self.minWidth, -1))
        else:
            self.SetSize(wx.Size(-1, self.minHeight))
            self.SetMinSize(wx.Size(-1, self.minHeight))


        self.checkTimerID = wx.NewId()
        self.checkTimer = wx.Timer(self, self.checkTimerID)
        self.checkPeriod = 250
        self.checkMaximize = True
        self.shipBrowser = self.Parent
        self.raceBmps = []
        self.raceNames = []
        self.hoveredItem = None

        if layout == wx.VERTICAL:
            self.buttonsBarPos = (4,0)
        else:
            self.buttonsBarPos = (0,4)

        self.buttonsPadding = 4

        if layout == wx.VERTICAL:
            self.bmpArrow = bitmapLoader.getBitmap("down-arrow2","icons")
        else:
            self.bmpArrow = bitmapLoader.getBitmap("up-arrow2","icons")

        #    Make the bitmaps have the same color as window text

        sysTextColour = wx.SystemSettings.GetColour( wx.SYS_COLOUR_WINDOWTEXT )

        img = self.bmpArrow.ConvertToImage()
        if layout == wx.VERTICAL:
            img = img.Rotate90(False)
        img.Replace(0, 0, 0, sysTextColour[0], sysTextColour[1], sysTextColour[2])
        if layout == wx.VERTICAL:
            img = img.Scale(self.minWidth, 8, wx.IMAGE_QUALITY_HIGH)

        self.bmpArrow = wx.BitmapFromImage(img)

        self.RebuildRaces(self.shipBrowser.RACE_ORDER)

        self.Bind(wx.EVT_ENTER_WINDOW, self.OnWindowEnter)
        self.Bind(wx.EVT_LEAVE_WINDOW, self.OnWindowLeave)
        self.Bind(wx.EVT_TIMER, self.OnTimer)
        self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnBackgroundErase)
        self.Bind(wx.EVT_PAINT, self.OnPaint)
        self.Bind(wx.EVT_LEFT_UP, self.OnLeftUp)
        self.Bind(wx.EVT_MOTION, self.OnMouseMove)
        self.Bind(wx.EVT_SIZE, self.OnSizeUpdate)

        self.Layout()

    def OnMouseMove(self, event):
        mx,my = event.GetPosition()

        location = self.HitTest(mx,my)
        if location != self.hoveredItem:
            self.hoveredItem = location
            self.Refresh()
            if location is not None:
                self.SetCursor(wx.StockCursor(wx.CURSOR_HAND))
            else:
                self.SetCursor(wx.StockCursor(wx.CURSOR_ARROW))

    def OnSizeUpdate(self,event):
        self.CalcButtonsBarPos()

        self.Refresh()

        event.Skip()

    def CalcButtonsBarPos(self):

        if self.layout == wx.HORIZONTAL:
            rect = self.GetRect()
            width = 0
            height = 0
            for bmp in self.raceBmps:
                width += bmp.GetWidth() + self.buttonsPadding
                height = max(bmp.GetHeight(), height)

            posx = (rect.width - width) / 2
            posy = (rect.height - height) / 2

            self.buttonsBarPos = (posx, posy)

    def OnLeftUp(self, event):

        mx,my = event.GetPosition()

        toggle = self.HitTest(mx,my)

        if toggle is not None:
            self.Refresh()

            self.shipBrowser.ToggleRacesFilter(self.raceNames[toggle])

            stage = self.shipBrowser.GetActiveStage()

            if stage == 2:
                categoryID = self.shipBrowser.GetStageData(stage)
                wx.PostEvent(self.shipBrowser,Stage2Selected(categoryID=categoryID, back = True))
        event.Skip()

    def HitTest(self, mx,my):
        x,y = self.buttonsBarPos
        padding = self.buttonsPadding

        for bmp in self.raceBmps:
            if (mx > x and mx < x + bmp.GetWidth()) and (my > y and my < y + bmp.GetHeight()):
                return self.raceBmps.index(bmp)
            if self.layout == wx.VERTICAL:
                y += bmp.GetHeight() + padding
            else:
                x += bmp.GetWidth() + padding

        return None

    def RebuildRaces(self, races):
        self.raceBmps = []
        for race in races:
            if race:
                self.raceBmps.append(bitmapLoader.getBitmap("race_%s_small" % race, "icons"))
        self.raceNames = races
        self.CalcButtonsBarPos()
        self.Refresh()

    def OnBackgroundErase(self, event):
        pass

    def OnPaint(self, event):
        rect = self.GetRect()

        windowColor = wx.SystemSettings_GetColour(wx.SYS_COLOUR_WINDOW)
        bkColor = colorUtils.GetSuitableColor(windowColor, 0.1)
        sepColor = colorUtils.GetSuitableColor(windowColor, 0.2)

        mdc = wx.BufferedPaintDC(self)

        bkBitmap = drawUtils.RenderGradientBar(windowColor, rect.width, rect.height, 0.1, 0.1, 0.2, 2)
        mdc.DrawBitmap(bkBitmap,0,0,True)


        x ,y = self.buttonsBarPos

        if self.direction == 1:
            for raceBmp in self.raceBmps:
                dropShadow = drawUtils.CreateDropShadowBitmap(raceBmp, 0.2)

                if self.shipBrowser.GetRaceFilterState(self.raceNames[self.raceBmps.index(raceBmp)]):
                    bmp = raceBmp
                else:
                    img = wx.ImageFromBitmap(raceBmp)
                    if self.hoveredItem == self.raceBmps.index(raceBmp):
                        img = img.AdjustChannels(1, 1, 1, 0.7)
                    else:
                        img = img.AdjustChannels(1, 1, 1, 0.4)
                    bmp = wx.BitmapFromImage(img)

                if self.layout == wx.VERTICAL:
                    mdc.DrawBitmap(dropShadow, rect.width - self.buttonsPadding - bmp.GetWidth() + 1, y + 1)
                    mdc.DrawBitmap(bmp, rect.width - self.buttonsPadding - bmp.GetWidth(), y)
                    y+=raceBmp.GetHeight() + self.buttonsPadding
                    mdc.SetPen(wx.Pen(sepColor,1))
                    mdc.DrawLine(rect.width - 1, 0, rect.width -1, rect.height)
                else:
                    mdc.DrawBitmap(dropShadow, x + 1, self.buttonsPadding + 1)
                    mdc.DrawBitmap(bmp, x, self.buttonsPadding)
                    x+=raceBmp.GetWidth() + self.buttonsPadding
                    mdc.SetPen(wx.Pen(sepColor,1))
                    mdc.DrawLine(0, 0, rect.width, 0)

        if self.direction < 1:
            if self.layout == wx.VERTICAL:
                mdc.DrawBitmap(self.bmpArrow, -2, (rect.height - self.bmpArrow.GetHeight()) / 2)
            else:
                mdc.SetPen(wx.Pen(sepColor,1))
                mdc.DrawLine(0, 0, rect.width, 0)
                mdc.DrawBitmap(self.bmpArrow, (rect.width - self.bmpArrow.GetWidth()) / 2, -2)



    def OnTimer(self,event):
        if event.GetId() == self.animTimerID:
            start = 0
            if self.layout == wx.VERTICAL:
                end = self.maxWidth - self.minWidth
            else:
                end = self.maxHeight - self.minHeight

            step = animEffects.OUT_CIRC(self.animStep, start, end, self.animDuration)
            self.animStep += self.animPeriod * self.direction

            self.AdjustSize((self.minWidth if self.layout == wx.VERTICAL else self.minHeight) + step)

            if self.animStep > self.animDuration or self.animStep < 0:
                self.animTimer.Stop()
                self.animStep = self.animDuration if self.direction == 1 else 0
                self.Parent.GetBrowserContainer().RefreshList(True)

        if event.GetId() == self.checkTimerID:
            if self.checkMaximize:
                self.direction = 1
            else:
                self.direction = -1

            if not self.animTimer.IsRunning():
                self.animTimer.Start(self.animPeriod)

    def AdjustSize(self, delta):
        self.SetMinSize(wx.Size(delta,-1) if self.layout == wx.VERTICAL else wx.Size(-1, delta))
        self.Parent.Layout()
        self.Refresh()

    def OnWindowEnter(self, event):
        if not self.animate:
            return

        if not self.checkTimer.IsRunning():
            self.checkTimer.Start(self.checkPeriod, wx.TIMER_ONE_SHOT)
        self.checkMaximize = True

        event.Skip()

    def OnWindowLeave(self, event):
        if self.hoveredItem is not None:
            self.hoveredItem = None
            self.SetCursor(wx.StockCursor(wx.CURSOR_ARROW))
            self.Refresh()

        if not self.animate:
            return

        if not self.checkTimer.IsRunning():
            self.checkTimer.Start(self.checkPeriod, wx.TIMER_ONE_SHOT)
        self.checkMaximize = False

        event.Skip()

class NavigationPanel(SFItem.SFBrowserItem):
    def __init__(self,parent, size = (-1,24)):
        SFItem.SFBrowserItem.__init__(self,parent,size = size)

        self.rewBmpH = bitmapLoader.getBitmap("frewind_small","icons")
        self.forwBmp = bitmapLoader.getBitmap("fforward_small","icons")
        self.searchBmpH = bitmapLoader.getBitmap("fsearch_small","icons")
        self.newBmpH = bitmapLoader.getBitmap("fit_add_small","icons")
        self.resetBmpH = bitmapLoader.getBitmap("freset_small","icons")
        self.switchBmpH = bitmapLoader.getBitmap("fit_switch_view_mode_small","icons")

        self.resetBmp = self.AdjustChannels(self.resetBmpH)
        self.rewBmp = self.AdjustChannels(self.rewBmpH)
        self.searchBmp = self.AdjustChannels(self.searchBmpH)
        self.switchBmp = self.AdjustChannels(self.switchBmpH)
        self.newBmp = self.AdjustChannels(self.newBmpH)

        self.toolbar.AddButton(self.resetBmp, "Ship groups", clickCallback = self.OnHistoryReset, hoverBitmap = self.resetBmpH)
        self.toolbar.AddButton(self.rewBmp, "Back", clickCallback = self.OnHistoryBack, hoverBitmap = self.rewBmpH)
        self.btnNew = self.toolbar.AddButton(self.newBmp, "New fitting", clickCallback = self.OnNewFitting, hoverBitmap = self.newBmpH, show = False)
        self.btnSwitch = self.toolbar.AddButton(self.switchBmp, "Hide empty ship groups", clickCallback  = self.ToggleEmptyGroupsView, hoverBitmap = self.switchBmpH, show = False)
        self.toolbar.AddButton(self.searchBmp, "Search fittings", clickCallback = self.ToggleSearchBox, hoverBitmap = self.searchBmpH)

        self.padding = 4
        self.lastSearch = ""
        self.recentSearches = []
        self.inSearch = False

        self.fontSmall = wx.FontFromPixelSize((0,12),wx.SWISS, wx.NORMAL, wx.NORMAL, False)
        w,h = size
        self.BrowserSearchBox = wx.TextCtrl(self, wx.ID_ANY, "", wx.DefaultPosition, (-1, h - 2 if 'wxGTK' in wx.PlatformInfo else -1 ), wx.TE_PROCESS_ENTER | (wx.BORDER_NONE if 'wxGTK' in wx.PlatformInfo else 0))
        self.BrowserSearchBox.Show(False)

        self.BrowserSearchBox.Bind(wx.EVT_TEXT_ENTER, self.OnBrowserSearchBoxEnter)
        self.BrowserSearchBox.Bind(wx.EVT_KILL_FOCUS, self.OnBrowserSearchBoxLostFocus)
        self.BrowserSearchBox.Bind(wx.EVT_KEY_DOWN, self.OnBrowserSearchBoxEsc)
        self.BrowserSearchBox.Bind(wx.EVT_TEXT, self.OnScheduleSearch)

        self.SetMinSize(size)
        self.shipBrowser = self.Parent
        self.mainFrame = gui.mainFrame.MainFrame.getInstance()

        self.Bind(wx.EVT_SIZE, self.OnResize)


    def OnScheduleSearch(self, event):
        search = self.BrowserSearchBox.GetValue()
        # Make sure we do not count wildcard as search symbol
        realsearch = search.replace("*", "")
        if len(realsearch) < 3 and len(realsearch) >= 0:
            if self.inSearch == True:
                self.inSearch = False
                if len(self.shipBrowser.browseHist) > 0:
                    stage,data = self.shipBrowser.browseHist.pop()
                    self.gotoStage(stage,data)
        else:
            if search:
                wx.PostEvent(self.shipBrowser,SearchSelected(text=search, back = False))
                self.inSearch = True
            else:
                self.inSearch = False

    def ToggleSearchBox(self):
        if self.BrowserSearchBox.IsShown():
            self.BrowserSearchBox.Show(False)
        else:
            self.BrowserSearchBox.Show(True)
            self.BrowserSearchBox.ChangeValue("")
            self.BrowserSearchBox.SetFocus()

    def OnBrowserSearchBoxEnter(self, event):
        self.OnBrowserSearchBoxLostFocus(None)

    def OnBrowserSearchBoxLostFocus(self, event):
        self.lastSearch = self.BrowserSearchBox.GetValue()
        self.BrowserSearchBox.ChangeValue("")
        self.BrowserSearchBox.Show(False)

    def OnBrowserSearchBoxEsc(self, event):
        if event.GetKeyCode() == wx.WXK_ESCAPE:
            self.BrowserSearchBox.Show(False)
        else:
            event.Skip()


    def OnResize(self, event):
        self.Refresh()

    def ToggleEmptyGroupsView(self):
        if self.shipBrowser.filterShipsWithNoFits:
            self.shipBrowser.filterShipsWithNoFits = False
            self.btnSwitch.label = "Hide empty ship groups"
        else:
            self.shipBrowser.filterShipsWithNoFits = True
            self.btnSwitch.label = "Show empty ship groups"
        stage = self.shipBrowser.GetActiveStage()
        if stage == 2:
            categoryID = self.shipBrowser.GetStageData(stage)
            wx.PostEvent(self.shipBrowser,Stage2Selected(categoryID=categoryID, back = True))

    def ShowNewFitButton(self, show):
        self.btnNew.Show(show)
        self.Refresh()

    def ShowSwitchEmptyGroupsButton(self, show):
        self.btnSwitch.Show(show)
        self.Refresh()

    def OnNewFitting(self):
        stage = self.Parent.GetActiveStage()
        if stage == 3:
            shipID = self.Parent.GetStageData(stage)
            shipName = self.Parent.GetStage3ShipName()
            sFit = service.Fit.getInstance()
            fitID = sFit.newFit(shipID, "%s fit" %shipName)
            self.shipBrowser.fitIDMustEditName = fitID
            wx.PostEvent(self.Parent,Stage3Selected(shipID=shipID, back = True))
            wx.PostEvent(self.mainFrame, FitSelected(fitID=fitID))

    def OnHistoryReset(self):
        if self.shipBrowser.browseHist:
            self.shipBrowser.browseHist = []
            self.gotoStage(1,0)

    def OnHistoryBack(self):
        if len(self.shipBrowser.browseHist) > 0:
            stage,data = self.shipBrowser.browseHist.pop()
            self.gotoStage(stage,data)

    def AdjustChannels(self, bitmap):
        img = wx.ImageFromBitmap(bitmap)
        img = img.AdjustChannels(1.05,1.05,1.05,1)
        return wx.BitmapFromImage(img)

    def UpdateElementsPos(self, mdc):
        rect = self.GetRect()

        self.toolbarx = self.padding
        self.toolbary = (rect.height - self.toolbar.GetHeight()) / 2

        mdc.SetFont(self.fontSmall)

        wlabel,hlabel = mdc.GetTextExtent(self.toolbar.hoverLabel)

        self.thoverx = self.toolbar.GetWidth() + self.padding
        self.thovery = (rect.height - hlabel)/2
        self.thoverw = wlabel

        self.browserBoxX = self.thoverx
        bEditBoxWidth, bEditBoxHeight = self.BrowserSearchBox.GetSize()
        self.browserBoxY = (rect.height - bEditBoxHeight) / 2

        self.bEditBoxWidth = rect.width - self.browserBoxX - self.padding

    def DrawItem(self, mdc):
        rect = self.GetRect()

        windowColor = wx.SystemSettings_GetColour(wx.SYS_COLOUR_WINDOW)
        textColor = colorUtils.GetSuitableColor(windowColor, 1)
        sepColor = colorUtils.GetSuitableColor(windowColor, 0.2)

        mdc.SetTextForeground(textColor)

        self.UpdateElementsPos(mdc)
        self.BrowserSearchBox.SetPosition((self.browserBoxX, self.browserBoxY))
        self.BrowserSearchBox.SetSize(wx.Size(self.bEditBoxWidth, -1))

        self.toolbar.SetPosition((self.toolbarx, self.toolbary))
        mdc.SetFont(self.fontSmall)
        mdc.DrawText(self.toolbar.hoverLabel, self.thoverx, self.thovery)
        mdc.SetPen(wx.Pen(sepColor,1))
        mdc.DrawLine(0,rect.height - 1, rect.width, rect.height - 1)

    def RenderBackground(self):
        rect = self.GetRect()

        windowColor = wx.SystemSettings_GetColour(wx.SYS_COLOUR_WINDOW)

        sFactor = 0.1

        shipGroupsFilter = getattr(self.shipBrowser,"filterShipsWithNoFits", None)
        if shipGroupsFilter:
            sFactor = 0.15
            mFactor = 0.25
        else:
            mFactor = 0.2

        eFactor = 0.1

        if self.bkBitmap:
            if self.bkBitmap.eFactor == eFactor and self.bkBitmap.sFactor == sFactor and self.bkBitmap.mFactor == mFactor \
             and rect.width == self.bkBitmap.GetWidth() and rect.height == self.bkBitmap.GetHeight() :
                return
            else:
                del self.bkBitmap

        self.bkBitmap = drawUtils.RenderGradientBar(windowColor, rect.width, rect.height, sFactor, eFactor, mFactor, 2)

        self.bkBitmap.sFactor = sFactor
        self.bkBitmap.eFactor = eFactor
        self.bkBitmap.mFactor = mFactor


    def gotoStage(self,stage, data = None):
        if stage == 1:
            wx.PostEvent(self.Parent,Stage1Selected())
        elif stage == 2:
            wx.PostEvent(self.Parent,Stage2Selected(categoryID=data, back = True))
        elif stage == 3:
            wx.PostEvent(self.Parent,Stage3Selected(shipID=data, back = 1))
        elif stage == 4:
            self.shipBrowser._activeStage = 4
            self.stStatus.SetLabel("Search: %s" % data.capitalize())
            self.Layout()
            wx.PostEvent(self.Parent,SearchSelected(text=data, back = True))
        else:
            wx.PostEvent(self.Parent,Stage1Selected())


class ShipBrowser(wx.Panel):
    def __init__(self, parent):
        wx.Panel.__init__ (self, parent,style = 0)

        self._lastWidth = 0
        self._activeStage = 1
        self._lastStage = 0
        self.browseHist = []
        self.lastStage = (0,0)
        self.mainFrame = gui.mainFrame.MainFrame.getInstance()

        self.categoryList=[]

        self._stage1Data = -1
        self._stage2Data = -1
        self._stage3Data = -1
        self._stage3ShipName = ""
        self.fitIDMustEditName = -1
        self.filterShipsWithNoFits = False

        self.racesFilter = {}

        self.showRacesFilterInStage2Only = True

        for race in self.RACE_ORDER:
            if race:
                self.racesFilter[race] = False

        self.SetSizeHintsSz(wx.DefaultSize, wx.DefaultSize)

        mainSizer = wx.BoxSizer(wx.VERTICAL)

        self.lpane = PFWidgetsContainer(self)
        layout = wx.HORIZONTAL

        self.navpanel = NavigationPanel(self)
        mainSizer.Add(self.navpanel, 0 , wx.EXPAND)
        self.raceselect = RaceSelector(self, layout = layout, animate = False)
        container = wx.BoxSizer(wx.VERTICAL if layout == wx.HORIZONTAL else wx.HORIZONTAL)

        if layout == wx.HORIZONTAL:
            container.Add(self.lpane,1,wx.EXPAND)
            container.Add(self.raceselect,0,wx.EXPAND)
        else:
            container.Add(self.raceselect,0,wx.EXPAND)
            container.Add(self.lpane,1,wx.EXPAND)

        mainSizer.Add(container, 1, wx.EXPAND)
        self.SetSizer(mainSizer)
        self.Layout()
        self.Show()

        self.Bind(wx.EVT_SIZE, self.SizeRefreshList)
        self.Bind(EVT_SB_STAGE2_SEL, self.stage2)
        self.Bind(EVT_SB_STAGE1_SEL, self.stage1)
        self.Bind(EVT_SB_STAGE3_SEL, self.stage3)
        self.Bind(EVT_SB_SEARCH_SEL, self.searchStage)

        self.mainFrame.Bind(GE.FIT_CHANGED, self.RefreshList)

        self.stage1(None)

    def GetBrowserContainer(self):
        return self.lpane

    def RefreshContent(self):
        stage = self.GetActiveStage()
        if stage == 1:
            return
        stageData = self.GetStageData(stage)
        self.navpanel.gotoStage(stage, stageData)

    def RefreshList(self, event):
        stage = self.GetActiveStage()
        if stage == 3 or stage == 4:
            self.lpane.RefreshList(True)
        event.Skip()

    def SizeRefreshList(self, event):
        ewidth, eheight = event.GetSize()
        self.Layout()
        self.lpane.Layout()
        self.lpane.RefreshList(True)
        event.Skip()

    def __del__(self):
        pass

    def GetActiveStage(self):
        return self._activeStage

    def GetLastStage(self):
        return self._lastStage

    def GetStageData(self, stage):
        if stage == 1:
            return self._stage1Data
        if stage == 2:
            return self._stage2Data
        if stage == 3:
            return self._stage3Data
        return -1

    def GetStage3ShipName(self):
        return self._stage3ShipName

    def ToggleRacesFilter(self, race):
        if self.racesFilter[race]:
            self.racesFilter[race] = False
        else:
            self.racesFilter[race] = True

    def GetRaceFilterState(self, race):
        return self.racesFilter[race]

    def stage1(self, event):
        self._lastStage = self._activeStage
        self._activeStage = 1
        self.lastdata = 0

        self.navpanel.ShowNewFitButton(False)
        self.navpanel.ShowSwitchEmptyGroupsButton(False)

        sMarket = service.Market.getInstance()

        self.lpane.ShowLoading(False)

        self.lpane.Freeze()
        self.lpane.RemoveAllChildren()
        if len(self.categoryList) == 0:
            self.categoryList = list(sMarket.getShipRoot())
            self.categoryList.sort(key=lambda ship: ship.name)
        for ship in self.categoryList:
            self.lpane.AddWidget(CategoryItem(self.lpane, ship.ID, (ship.name, 0)))

        self.lpane.RefreshList()
        self.lpane.Thaw()
        self.raceselect.RebuildRaces(self.RACE_ORDER)
        if self.showRacesFilterInStage2Only:
            self.raceselect.Show(False)
            self.Layout()

    RACE_ORDER = ["amarr", "caldari", "gallente", "minmatar", "sisters", "ore", "serpentis", "angel", "blood", "sansha", "guristas", "jove", None]

    def raceNameKey(self, ship):
        return self.RACE_ORDER.index(ship.race), ship.name

    def stage2Callback(self, data):
        if self.GetActiveStage() != 2:
            return
        ships = list(data[1])
        sFit = service.Fit.getInstance()

        ships.sort(key=self.raceNameKey)
        racesList = []
        subRacesFilter = {}

        for ship in ships:
            if ship.race:
                if ship.race not in racesList:
                    racesList.append(ship.race)

        for race,state in self.racesFilter.iteritems():
            if race in racesList:
                subRacesFilter[race] = self.racesFilter[race]

        override = True
        for race, state in subRacesFilter.iteritems():
            if state:
                override = False
                break

        for ship in ships:
            fits = sFit.countFitsWithShip(ship.ID)
            filter = subRacesFilter[ship.race] if ship.race else True

            if override:
                filter = True

            if self.filterShipsWithNoFits:
                if fits>0:
                    if filter:
                        self.lpane.AddWidget(ShipItem(self.lpane, ship.ID, (ship.name, fits), ship.race))
            else:
                if filter:
                    self.lpane.AddWidget(ShipItem(self.lpane, ship.ID, (ship.name, fits), ship.race))

        self.raceselect.RebuildRaces(racesList)


        self.lpane.ShowLoading(False)

        self.lpane.RefreshList()

        if self.showRacesFilterInStage2Only:
            self.raceselect.Show(True)
            self.Layout()

    def stage2(self, event):
        back = event.back

        if not back:
            self.browseHist.append( (1,0) )

        self._lastStage = self._activeStage
        self._activeStage = 2

        categoryID = event.categoryID
        self.lastdata = categoryID

        self.lpane.ShowLoading()

        self.lpane.RemoveAllChildren()


        sMarket = service.Market.getInstance()
        sMarket.getShipListDelayed(categoryID, self.stage2Callback)

        self._stage2Data = categoryID

        self.navpanel.ShowNewFitButton(False)
        self.navpanel.ShowSwitchEmptyGroupsButton(True)

    def nameKey(self, info):
        return info[1]

    def stage3(self, event):

        self.lpane.ShowLoading(False)

        if event.back == 0:
            self.browseHist.append( (2,self._stage2Data) )
        elif event.back == -1:
            if len(self.navpanel.recentSearches)>0:
                self.browseHist.append((4, self.navpanel.lastSearch))

        shipID = event.shipID
        self.lastdata = shipID
        self._lastStage = self._activeStage
        self._activeStage = 3

        sFit = service.Fit.getInstance()
        sMarket = service.Market.getInstance()

        self.lpane.Freeze()
        self.lpane.RemoveAllChildren()
        fitList = sFit.getFitsWithShip(shipID)

        if len(fitList) == 0:
            stage,data = self.browseHist.pop()
            self.lpane.Thaw()
            self.navpanel.gotoStage(stage,data)
            return

        self.navpanel.ShowNewFitButton(True)
        self.navpanel.ShowSwitchEmptyGroupsButton(False)

        if self.showRacesFilterInStage2Only:
            self.raceselect.Show(False)
            self.Layout()

        fitList.sort(key=self.nameKey)
        shipName = sMarket.getItem(shipID).name

        self._stage3ShipName = shipName
        self._stage3Data = shipID

        for ID, name, booster, timestamp in fitList:
            self.lpane.AddWidget(FitItem(self.lpane, ID, (shipName, name, booster, timestamp),shipID))

        self.lpane.RefreshList()
        self.lpane.Thaw()
        self.raceselect.RebuildRaces(self.RACE_ORDER)

    def searchStage(self, event):

        self.lpane.ShowLoading(False)

        self.navpanel.ShowNewFitButton(False)
        self.navpanel.ShowSwitchEmptyGroupsButton(False)

        if not event.back:
            if self._activeStage !=4:
                if len(self.browseHist) >0:
                    self.browseHist.append( (self._activeStage, self.lastdata) )
                else:
                    self.browseHist.append((1,0))
            self._lastStage = self._activeStage
            self._activeStage = 4

        sMarket = service.Market.getInstance()
        sFit = service.Fit.getInstance()
        query = event.text

        self.lpane.Freeze()

        self.lpane.RemoveAllChildren()
        if query:
            ships = sMarket.searchShips(query)
            fitList = sFit.searchFits(query)

            for ship in ships:
                self.lpane.AddWidget(ShipItem(self.lpane, ship.ID, (ship.name, len(sFit.getFitsWithShip(ship.ID))), ship.race))

            for ID, name, shipID, shipName, booster, timestamp in fitList:
                self.lpane.AddWidget(FitItem(self.lpane, ID, (shipName, name, booster, timestamp), shipID))
            if len(ships) == 0 and len(fitList) == 0 :
                self.lpane.AddWidget(PFStaticText(self.lpane, label = u"No matching results."))
            self.lpane.RefreshList(doFocus = False)
        self.lpane.Thaw()

        self.raceselect.RebuildRaces(self.RACE_ORDER)

        if self.showRacesFilterInStage2Only:
            self.raceselect.Show(False)
            self.Layout()

class PFStaticText(wx.Panel):
    def __init__(self, parent, label=wx.EmptyString):
        wx.Panel.__init__ (self, parent, id=wx.ID_ANY, pos=wx.DefaultPosition, size = parent.GetSize())

        mainSizer = wx.BoxSizer(wx.VERTICAL)
        text = wx.StaticText( self, wx.ID_ANY, label, wx.DefaultPosition, wx.DefaultSize, wx.ALIGN_CENTRE )
        text.Wrap( -1 )
        mainSizer.Add( text, 1, wx.EXPAND|wx.TOP, 10  )
        self.SetSizer(mainSizer)
        self.Layout()
    def GetType(self):
        return -1

class PFGenBitmapButton(GenBitmapButton):
    def __init__(self, parent, id, bitmap, pos, size, style):
        GenBitmapButton.__init__(self, parent, id, bitmap, pos, size, style)
        self.bgcolor = wx.Brush(wx.WHITE)

    def SetBackgroundColour(self, color):
        self.bgcolor = wx.Brush(color)

    def GetBackgroundBrush(self, dc):
        return self.bgcolor

class CategoryItem(SFItem.SFBrowserItem):
    def __init__(self,parent, categoryID, fittingInfo, size = (0,16)):
        SFItem.SFBrowserItem.__init__(self,parent,size = size)

        if categoryID:
            self.shipBmp = bitmapLoader.getBitmap("ship_small","icons")
        else:
            self.shipBmp = wx.EmptyBitmap(16,16)

        self.dropShadowBitmap = drawUtils.CreateDropShadowBitmap(self.shipBmp, 0.2)

        self.categoryID = categoryID
        self.fittingInfo = fittingInfo
        self.shipBrowser = self.Parent.Parent

        self.padding = 4

        self.fontBig = wx.FontFromPixelSize((0,15),wx.SWISS, wx.NORMAL, wx.NORMAL, False)

        self.animTimerId = wx.NewId()

        self.animTimer = wx.Timer(self, self.animTimerId)
        self.animStep = 0
        self.animPeriod = 10
        self.animDuration = 100

        self.Bind(wx.EVT_TIMER, self.OnTimer)

        #=======================================================================
        # Disabled - it will be added as an option to Preferences
        self.animCount = 0
        # self.animTimer.Start(self.animPeriod)
        #=======================================================================


    def OnTimer(self, event):
        step = self.OUT_QUAD(self.animStep, 0, 10, self.animDuration)
        self.animCount = 10 - step
        self.animStep += self.animPeriod
        if self.animStep > self.animDuration or self.animCount < 0 :
            self.animCount = 0
            self.animTimer.Stop()
        self.Refresh()

    def OUT_QUAD (self, t, b, c, d):
        t=float(t)
        b=float(b)
        c=float(c)
        d=float(d)

        t/=d

        return -c *(t)*(t-2) + b

    def GetType(self):
        return 1

    def MouseLeftUp(self, event):

        categoryID = self.categoryID
        wx.PostEvent(self.shipBrowser,Stage2Selected(categoryID=categoryID, back=False))

    def UpdateElementsPos(self, mdc):
        rect = self.GetRect()
        self.shipBmpx = self.padding
        self.shipBmpy = (rect.height-self.shipBmp.GetWidth())/2

        self.shipBmpx -= self.animCount

        mdc.SetFont(self.fontBig)
        categoryName, fittings = self.fittingInfo
        wtext, htext = mdc.GetTextExtent(categoryName)


        self.catx = self.shipBmpx + self.shipBmp.GetWidth() + self.padding
        self.caty = (rect.height - htext) / 2

    def DrawItem(self, mdc):
        rect = self.GetRect()

        self.UpdateElementsPos(mdc)

        windowColor = wx.SystemSettings_GetColour(wx.SYS_COLOUR_WINDOW)
        textColor = colorUtils.GetSuitableColor(windowColor, 1)

        mdc.SetTextForeground(textColor)
        mdc.DrawBitmap(self.dropShadowBitmap, self.shipBmpx + 1, self.shipBmpy + 1)
        mdc.DrawBitmap(self.shipBmp,self.shipBmpx,self.shipBmpy,0)

        mdc.SetFont(self.fontBig)

        categoryName, fittings = self.fittingInfo

        mdc.DrawText(categoryName, self.catx, self.caty)

#===============================================================================
#        Waiting for total #fits impl in eos/service
#
#        mdc.SetFont(wx.Font(8, wx.SWISS, wx.NORMAL, wx.NORMAL, False))
#
#        if fittings <1:
#            fformat = "No fits"
#        else:
#            if fittings == 1:
#                fformat = "%d fit"
#            else:
#                fformat = "%d fits"
#
#        if fittings>0:
#            xtext, ytext = mdc.GetTextExtent(fformat % fittings)
#            ypos = (rect.height - ytext)/2
#        else:
#            xtext, ytext = mdc.GetTextExtent(fformat)
#            ypos = (rect.height - ytext)/2
#===============================================================================


class ShipItem(SFItem.SFBrowserItem):
    def __init__(self, parent, shipID=None, shipFittingInfo=("Test", 2), itemData=None,
                 id=wx.ID_ANY, pos=wx.DefaultPosition,
                 size=(0, 40), style=0):
        SFItem.SFBrowserItem.__init__(self, parent, size = size)

        self.mainFrame = gui.mainFrame.MainFrame.getInstance()

        self._itemData = itemData

        self.shipRace = itemData

        self.shipID = shipID

        self.fontBig = wx.FontFromPixelSize((0,15),wx.SWISS, wx.NORMAL, wx.BOLD, False)
        self.fontNormal = wx.FontFromPixelSize((0,14),wx.SWISS, wx.NORMAL, wx.NORMAL, False)
        self.fontSmall = wx.FontFromPixelSize((0,12),wx.SWISS, wx.NORMAL, wx.NORMAL, False)

        self.shipBmp = None
        if shipID:
            self.shipBmp = bitmapLoader.getBitmap(str(shipID),"ships")
        if not self.shipBmp:
            self.shipBmp = bitmapLoader.getBitmap("ship_no_image_big","icons")

        self.shipFittingInfo = shipFittingInfo
        self.shipName, self.shipFits = shipFittingInfo

        self.newBmp = bitmapLoader.getBitmap("fit_add_small", "icons")
        self.acceptBmp = bitmapLoader.getBitmap("faccept_small", "icons")

        self.shipEffBk = bitmapLoader.getBitmap("fshipbk_big","icons")

        img = wx.ImageFromBitmap(self.shipEffBk)
        img = img.Mirror(False)
        self.shipEffBkMirrored = wx.BitmapFromImage(img)

        self.raceBmp = bitmapLoader.getBitmap("race_%s_small" % self.shipRace, "icons")

        if not self.raceBmp:
            self.raceBmp = bitmapLoader.getBitmap("fit_delete_small","icons")

        self.raceDropShadowBmp = drawUtils.CreateDropShadowBitmap(self.raceBmp, 0.2)

        self.shipBrowser = self.Parent.Parent

        self.editWidth = 150
        self.padding = 4

        self.tcFitName = wx.TextCtrl(self, wx.ID_ANY, "%s fit" % self.shipName, wx.DefaultPosition, (120,-1), wx.TE_PROCESS_ENTER)
        self.tcFitName.Show(False)


        self.newBtn = self.toolbar.AddButton(self.newBmp,"New", self.newBtnCB)

        self.tcFitName.Bind(wx.EVT_TEXT_ENTER, self.createNewFit)
        self.tcFitName.Bind(wx.EVT_KILL_FOCUS, self.editLostFocus)
        self.tcFitName.Bind(wx.EVT_KEY_DOWN, self.editCheckEsc)

        self.animTimerId = wx.NewId()

        self.animTimer = wx.Timer(self, self.animTimerId)
        self.animStep = 0
        self.animPeriod = 10
        self.animDuration = 100

        self.Bind(wx.EVT_CONTEXT_MENU, self.OnShowPopup)

        self.marketInstance = service.Market.getInstance()
        self.baseItem = self.marketInstance.getItem(self.shipID)

        #=======================================================================\
        # DISABLED - it will be added as an option in PREFERENCES

        self.animCount = 0

        # if self.shipBrowser.GetActiveStage() != 4 and self.shipBrowser.GetLastStage() !=2:
        #    self.Bind(wx.EVT_TIMER, self.OnTimer)
        #    self.animTimer.Start(self.animPeriod)
        # else:
        #    self.animCount = 0
        #=======================================================================


    def OnShowPopup(self, event):
        pos = event.GetPosition()
        pos = self.ScreenToClient(pos)
        contexts = []
        contexts.append(("baseShip", "Ship Basic"))
        menu = ContextMenu.getMenu(self.baseItem, *contexts)
        self.PopupMenu(menu, pos)

    def OnTimer(self, event):
        step = self.OUT_QUAD(self.animStep, 0, 10, self.animDuration)
        self.animCount = 10 - step
        self.animStep += self.animPeriod
        if self.animStep > self.animDuration or self.animCount < 0 :
            self.animCount = 0
            self.animTimer.Stop()
        self.Refresh()

    def OUT_QUAD (self, t, b, c, d):
        t=float(t)
        b=float(b)
        c=float(c)
        d=float(d)

        t/=d

        return -c *(t)*(t-2) + b

    def GetType(self):
        return 2

    def MouseLeftUp(self, event):
        if self.tcFitName.IsShown():
            self.tcFitName.Show(False)
            self.newBtn.SetBitmap(self.newBmp)
            self.Refresh()
        else:
            shipName, fittings = self.shipFittingInfo
            if fittings > 0:
                wx.PostEvent(self.shipBrowser,Stage3Selected(shipID=self.shipID, back = -1 if self.shipBrowser.GetActiveStage() == 4 else 0))
            else:
                self.newBtnCB()

    def newBtnCB(self):
        if self.tcFitName.IsShown():
            self.tcFitName.Show(False)
            self.createNewFit()
        else:
            self.tcFitName.SetValue("%s fit" % self.shipName)
            self.tcFitName.Show()

            self.tcFitName.SetFocus()
            self.tcFitName.SelectAll()

            self.newBtn.SetBitmap(self.acceptBmp)

            self.Refresh()

    def editLostFocus(self, event):
        self.tcFitName.Show(False)
        self.newBtn.SetBitmap(self.newBmp)
        self.Refresh()

    def editCheckEsc(self, event):
        if event.GetKeyCode() == wx.WXK_ESCAPE:
            self.tcFitName.Show(False)
        else:
            event.Skip()

    def createNewFit(self, event=None):
        self.tcFitName.Show(False)

        sFit = service.Fit.getInstance()
        fitID = sFit.newFit(self.shipID, self.tcFitName.GetValue())

        wx.PostEvent(self.shipBrowser,Stage3Selected(shipID=self.shipID, back=False))
        wx.PostEvent(self.mainFrame, FitSelected(fitID=fitID))

    def UpdateElementsPos(self, mdc):
        rect = self.GetRect()

        self.toolbarx = rect.width - self.toolbar.GetWidth() - self.padding
        self.toolbary = (rect.height - self.toolbar.GetHeight()) / 2

        self.toolbarx = self.toolbarx + self.animCount

        self.shipEffx = self.padding + (rect.height - self.shipEffBk.GetWidth())/2
        self.shipEffy = (rect.height - self.shipEffBk.GetHeight())/2

        self.shipEffx = self.shipEffx - self.animCount

        self.shipBmpx = self.padding + (rect.height - self.shipBmp.GetWidth()) / 2
        self.shipBmpy = (rect.height - self.shipBmp.GetHeight()) / 2

        self.shipBmpx= self.shipBmpx - self.animCount

        self.raceBmpx = self.shipEffx + self.shipEffBk.GetWidth() + self.padding
        self.raceBmpy = (rect.height - self.raceBmp.GetHeight())/2

        self.textStartx = self.raceBmpx + self.raceBmp.GetWidth() + self.padding

        self.shipNamey = (rect.height - self.shipBmp.GetHeight()) / 2

        shipName, fittings = self.shipFittingInfo

        mdc.SetFont(self.fontBig)
        wtext, htext = mdc.GetTextExtent(shipName)

        self.fittingsy = self.shipNamey + htext

        mdc.SetFont(self.fontSmall)

        wlabel,hlabel = mdc.GetTextExtent(self.toolbar.hoverLabel)

        self.thoverx = self.toolbarx - self.padding - wlabel
        self.thovery = (rect.height - hlabel)/2
        self.thoverw = wlabel

    def DrawItem(self, mdc):
        rect = self.GetRect()

        windowColor = wx.SystemSettings_GetColour(wx.SYS_COLOUR_WINDOW)
        textColor = colorUtils.GetSuitableColor(windowColor, 1)

        mdc.SetTextForeground(textColor)

        self.UpdateElementsPos(mdc)

        self.toolbar.SetPosition((self.toolbarx, self.toolbary))

        if self.GetState() & SFItem.SB_ITEM_HIGHLIGHTED:
            shipEffBk = self.shipEffBkMirrored
        else:
            shipEffBk = self.shipEffBk

        mdc.DrawBitmap(shipEffBk, self.shipEffx, self.shipEffy, 0)

        mdc.DrawBitmap(self.shipBmp, self.shipBmpx, self.shipBmpy, 0)

        mdc.DrawBitmap(self.raceDropShadowBmp, self.raceBmpx + 1, self.raceBmpy + 1)
        mdc.DrawBitmap(self.raceBmp,self.raceBmpx, self.raceBmpy)

        shipName, fittings = self.shipFittingInfo

        if fittings <1:
            fformat = "No fits"
        else:
            if fittings == 1:
                fformat = "%d fit"
            else:
                fformat = "%d fits"

        mdc.SetFont(self.fontNormal)
        mdc.DrawText(fformat %fittings if fittings >0 else fformat, self.textStartx, self.fittingsy)

        mdc.SetFont(self.fontSmall)
        mdc.DrawText(self.toolbar.hoverLabel, self.thoverx, self.thovery)

        mdc.SetFont(self.fontBig)

        psname = drawUtils.GetPartialText(mdc, shipName, self.toolbarx - self.textStartx - self.padding * 2 - self.thoverw)

        mdc.DrawText(psname, self.textStartx, self.shipNamey)

        if self.tcFitName.IsShown():
            self.AdjustControlSizePos(self.tcFitName, self.textStartx, self.toolbarx - self.editWidth - self.padding)

    def AdjustControlSizePos(self, editCtl, start, end):
        fnEditSize = editCtl.GetSize()
        wSize = self.GetSize()
        fnEditPosX = end
        fnEditPosY = (wSize.height - fnEditSize.height)/2
        if fnEditPosX < start:
            editCtl.SetSize((self.editWidth + fnEditPosX - start,-1))
            editCtl.SetPosition((start,fnEditPosY))
        else:
            editCtl.SetSize((self.editWidth,-1))
            editCtl.SetPosition((fnEditPosX,fnEditPosY))

class PFBitmapFrame(wx.Frame):
    def __init__ (self,parent, pos, bitmap):
        wx.Frame.__init__(self, parent, id = wx.ID_ANY, title = wx.EmptyString, pos = pos, size = wx.DefaultSize, style =
                                                               wx.NO_BORDER
                                                             | wx.FRAME_NO_TASKBAR
                                                             | wx.STAY_ON_TOP)
        img = bitmap.ConvertToImage()
        img = img.ConvertToGreyscale()
        bitmap = wx.BitmapFromImage(img)
        self.bitmap = bitmap
        self.SetSize((bitmap.GetWidth(), bitmap.GetHeight()))
        self.Bind(wx.EVT_PAINT,self.OnWindowPaint)
        self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnWindowEraseBk)
        self.Bind(wx.EVT_TIMER, self.OnTimer)

        self.timer = wx.Timer(self,wx.ID_ANY)
        self.direction = 1
        self.transp = 0
        self.SetSize((bitmap.GetWidth(),bitmap.GetHeight()))

        self.SetTransparent(0)
        self.Refresh()

    def OnTimer(self, event):
        self.transp += 20*self.direction
        if self.transp > 200:
            self.transp = 200
            self.timer.Stop()
        if self.transp < 0:
            self.transp = 0
            self.timer.Stop()
            wx.Frame.Show(self,False)
            self.Destroy()
            return
        self.SetTransparent(self.transp)

    def Show(self, showWnd = True):
        if showWnd:
            wx.Frame.Show(self, showWnd)
            self.Parent.SetFocus()
            self.direction = 1
            self.timer.Start(5)
        else:
            self.direction = -1
            self.timer.Start(5)

    def OnWindowEraseBk(self,event):
        pass

    def OnWindowPaint(self,event):
        rect = self.GetRect()
        canvas = wx.EmptyBitmap(rect.width, rect.height)
        mdc = wx.BufferedPaintDC(self)
        mdc.SelectObject(canvas)
        mdc.DrawBitmap(self.bitmap, 0, 0)
        mdc.SetPen( wx.Pen("#000000", width = 1 ) )
        mdc.SetBrush( wx.TRANSPARENT_BRUSH )
        mdc.DrawRectangle( 0,0,rect.width,rect.height)


class FitItem(SFItem.SFBrowserItem):
    def __init__(self, parent, fitID=None, shipFittingInfo=("Test", "cnc's avatar", 0, 0 ), shipID = None, itemData=None,
                 id=wx.ID_ANY, pos=wx.DefaultPosition,
                 size=(0, 40), style=0):

        #===============================================================================
        # animCount should be 10 if we enable animation in Preferences
        #===============================================================================

        self.animCount = 0
        self.selectedDelta = 0

        SFItem.SFBrowserItem.__init__(self,parent,size = size)

        self.mainFrame = gui.mainFrame.MainFrame.getInstance()

        self._itemData = itemData

        self.fitID = fitID

        self.shipID = shipID

        self.shipBrowser = self.Parent.Parent

        self.shipBmp = None

        self.deleted = False

        # @todo: replace all getActiveFit() in class with this variable and test
        self.activeFit = self.mainFrame.getActiveFit()

        if shipID:
            self.shipBmp = bitmapLoader.getBitmap(str(shipID),"ships")

        if not self.shipBmp:
            self.shipBmp = bitmapLoader.getBitmap("ship_no_image_big","icons")

        self.shipFittingInfo = shipFittingInfo
        self.shipName, self.fitName, self.fitBooster, self.timestamp = shipFittingInfo

        # access these by index based on toggle for booster fit

        self.fitMenu = wx.Menu()
        self.toggleItem = self.fitMenu.Append(-1, "Booster Fit", kind=wx.ITEM_CHECK)
        self.fitMenu.Check(self.toggleItem.GetId(), self.fitBooster)
        self.Bind(wx.EVT_MENU, self.OnPopupItemSelected, self.toggleItem)

        if self.activeFit:
            # If there is an active fit, get menu for setting individual boosters
            self.fitMenu.AppendSeparator()
            boosterMenu = self.mainFrame.additionsPane.gangPage.FitDNDPopupMenu
            self.fitMenu.AppendMenu(wx.ID_ANY, 'Set Booster', boosterMenu)

        self.boosterBmp = bitmapLoader.getBitmap("fleet_fc_small", "icons")
        self.copyBmp    = bitmapLoader.getBitmap("fit_add_small", "icons")
        self.renameBmp  = bitmapLoader.getBitmap("fit_rename_small", "icons")
        self.deleteBmp  = bitmapLoader.getBitmap("fit_delete_small","icons")
        self.acceptBmp  = bitmapLoader.getBitmap("faccept_small", "icons")

        self.shipEffBk = bitmapLoader.getBitmap("fshipbk_big","icons")

        img = wx.ImageFromBitmap(self.shipEffBk)
        img = img.Mirror(False)
        self.shipEffBkMirrored = wx.BitmapFromImage(img)

        self.dragTLFBmp = None

        self.bkBitmap = None

        self.padding = 4
        self.editWidth = 150

        self.dragging = False
        self.dragged = False
        self.dragMotionTrail = 5
        self.dragMotionTrigger = self.dragMotionTrail
        self.dragWindow = None

        self.fontBig = wx.FontFromPixelSize((0,15),wx.SWISS, wx.NORMAL, wx.BOLD, False)
        self.fontNormal = wx.FontFromPixelSize((0,14),wx.SWISS, wx.NORMAL, wx.NORMAL, False)
        self.fontSmall = wx.FontFromPixelSize((0,12),wx.SWISS, wx.NORMAL, wx.NORMAL, False)

        self.SetDraggable()

        self.boosterBtn = self.toolbar.AddButton(self.boosterBmp,"Booster", show=self.fitBooster)
        self.toolbar.AddButton(self.copyBmp,"Copy", self.copyBtnCB)
        self.renameBtn = self.toolbar.AddButton(self.renameBmp,"Rename", self.renameBtnCB)
        self.toolbar.AddButton(self.deleteBmp, "Delete", self.deleteBtnCB)

        self.tcFitName = wx.TextCtrl(self, wx.ID_ANY, "%s" % self.fitName, wx.DefaultPosition, (self.editWidth,-1), wx.TE_PROCESS_ENTER)

        if self.shipBrowser.fitIDMustEditName != self.fitID:
            self.tcFitName.Show(False)
        else:
            self.tcFitName.SetFocus()
            self.tcFitName.SelectAll()
            self.shipBrowser.fitIDMustEditName = -1
            self.renameBtn.SetBitmap(self.acceptBmp)

        self.tcFitName.Bind(wx.EVT_TEXT_ENTER, self.renameFit)
        self.tcFitName.Bind(wx.EVT_KILL_FOCUS, self.editLostFocus)
        self.tcFitName.Bind(wx.EVT_KEY_DOWN, self.editCheckEsc)

        self.animTimerId = wx.NewId()
        self.animTimer = wx.Timer(self, self.animTimerId)
        self.animStep = 0
        self.animPeriod = 10
        self.animDuration = 100

        self.maxDelta = 48

        self.Bind(wx.EVT_TIMER, self.OnTimer)

        #=======================================================================
        # DISABLED - it will be added as an option in PREFERENCES

        # if self.shipBrowser.GetActiveStage() != 4 and self.shipBrowser.GetLastStage() !=3:
        #    self.animTimer.Start(self.animPeriod)
        # else:
        #    self.animCount = 0
        #=======================================================================

        self.selTimerID = wx.NewId()

        self.selTimer = wx.Timer(self,self.selTimerID)
        self.selTimer.Start(100)

        self.Bind(wx.EVT_RIGHT_UP, self.OnContextMenu)

    def OnPopupItemSelected(self, event):
        ''' Fires when fit menu item is selected '''
        # currently only have one menu option (toggle booster)
        sFit = service.Fit.getInstance()
        sFit.toggleBoostFit(self.fitID)
        self.fitBooster = not self.fitBooster
        self.boosterBtn.Show(self.fitBooster)
        self.fitMenu.Check(self.toggleItem.GetId(), self.fitBooster)
        wx.PostEvent(self.mainFrame, BoosterListUpdated())
        event.Skip()

    def OnContextMenu(self, event):
        ''' Handles context menu for fit. Dragging is handled by MouseLeftUp() '''
        pos = wx.GetMousePosition()
        pos = self.ScreenToClient(pos)
        # Even though we may not select a booster, automatically set this so that the fleet pane knows which fit we're applying
        self.mainFrame.additionsPane.gangPage.draggedFitID = self.fitID
        self.PopupMenu(self.fitMenu, pos)

        event.Skip()

    def GetType(self):
        return 3

    def OnTimer(self, event):

        if self.selTimerID == event.GetId():
            ctimestamp = time.time()
            interval = 5
            if ctimestamp < self.timestamp + interval:
                delta = (ctimestamp - self.timestamp) / interval
                self.selectedDelta = self.CalculateDelta(0x0,self.maxDelta,delta)
                self.Refresh()
            else:
                self.selectedDelta = self.maxDelta
                self.selTimer.Stop()

        if self.animTimerId == event.GetId():
            step = self.OUT_QUAD(self.animStep, 0, 10, self.animDuration)
            self.animCount = 10 - step
            self.animStep += self.animPeriod
            if self.animStep > self.animDuration or self.animCount < 0 :
                self.animCount = 0
                self.animTimer.Stop()
            self.Refresh()

    def CalculateDelta(self, start, end, delta):
        return start + (end-start)*delta

    def OUT_QUAD (self, t, b, c, d):
        t=float(t)
        b=float(b)
        c=float(c)
        d=float(d)

        t/=d

        return -c *(t)*(t-2) + b

    def editLostFocus(self, event):
        self.RestoreEditButton()
        self.Refresh()

    def editCheckEsc(self, event):
        if event.GetKeyCode() == wx.WXK_ESCAPE:
            self.RestoreEditButton()
        else:
            event.Skip()

    def copyBtnCB(self):
        if self.tcFitName.IsShown():
            self.RestoreEditButton()
            return

        self.copyFit()

    def copyFit(self, event=None):
        sFit = service.Fit.getInstance()
        fitID = sFit.copyFit(self.fitID)
        self.shipBrowser.fitIDMustEditName = fitID
        wx.PostEvent(self.shipBrowser,Stage3Selected(shipID=self.shipID, back=True))
        wx.PostEvent(self.mainFrame, FitSelected(fitID=fitID))

    def renameBtnCB(self):
        if self.tcFitName.IsShown():
            self.RestoreEditButton()
            self.renameFit()
        else:
            self.tcFitName.SetValue(self.fitName)
            self.tcFitName.Show()
            self.renameBtn.SetBitmap(self.acceptBmp)
            self.tcFitName.SetFocus()
            self.tcFitName.SelectAll()

            self.Refresh()

    def renameFit(self, event=None):
        sFit = service.Fit.getInstance()
        self.tcFitName.Show(False)
        self.editWasShown = 0
        fitName = self.tcFitName.GetValue()
        if fitName:
            self.fitName = fitName
            sFit.renameFit(self.fitID, self.fitName)
            wx.PostEvent(self.mainFrame, FitRenamed(fitID=self.fitID))
            self.Refresh()
        else:
            self.tcFitName.SetValue(self.fitName)

    def deleteBtnCB(self):
        if self.tcFitName.IsShown():
            self.RestoreEditButton()
            return

        self.deleteFit()

    def deleteFit(self, event=None):
        if self.deleted:
            return
        else:
            self.deleted = True

        sFit = service.Fit.getInstance()

        sFit.deleteFit(self.fitID)

        if self.shipBrowser.GetActiveStage() == 4:
            wx.PostEvent(self.shipBrowser,SearchSelected(text=self.shipBrowser.navpanel.lastSearch,back=True))
        else:
            wx.PostEvent(self.shipBrowser,Stage3Selected(shipID=self.shipID, back=True))

        wx.PostEvent(self.mainFrame, FitRemoved(fitID=self.fitID))

    def MouseLeftUp(self, event):

        if self.dragging and self.dragged:
            self.dragging = False
            self.dragged = False
            if self.HasCapture():
                self.ReleaseMouse()
            self.dragWindow.Show(False)
            self.dragWindow = None

            targetWnd = wx.FindWindowAtPointer()

            if not targetWnd:
                return

            wnd = targetWnd
            while wnd is not None:
                handler = getattr(wnd, "handleDrag", None)
                if handler:
                    handler("fit", self.fitID)
                    break
                else:
                    wnd = wnd.Parent
            event.Skip()
            return

        if self.dragging:
            self.dragging = False

        if self.tcFitName.IsShown():
            self.RestoreEditButton()
        else:
            activeFitID = self.mainFrame.getActiveFit()
            if activeFitID != self.fitID:
                self.selectFit()

    def MouseLeftDown(self, event):
        self.dragging = True

    def MouseMove(self, event):
        pos = self.ClientToScreen(event.GetPosition())
        if self.dragging:
            if not self.dragged:
                if self.dragMotionTrigger < 0:
                    self.CaptureMouse()
                    self.dragWindow = PFBitmapFrame(self, pos, self.dragTLFBmp)
                    self.dragWindow.Show()
                    self.dragged = True
                    self.dragMotionTrigger = self.dragMotionTrail
                else:
                    self.dragMotionTrigger -= 1
            if self.dragWindow:
                pos.x += 3
                pos.y += 3
                self.dragWindow.SetPosition(pos)
            return

    def selectFit(self, event=None):
        wx.PostEvent(self.mainFrame, FitSelected(fitID=self.fitID))

    def RestoreEditButton(self):
            self.tcFitName.Show(False)
            self.renameBtn.SetBitmap(self.renameBmp)
            self.Refresh()

    def UpdateElementsPos(self, mdc):
        rect = self.GetRect()

        self.toolbarx = rect.width - self.toolbar.GetWidth() - self.padding
        self.toolbary = (rect.height - self.toolbar.GetHeight()) / 2

        self.toolbarx = self.toolbarx + self.animCount

        self.shipEffx = self.padding + (rect.height - self.shipEffBk.GetWidth())/2
        self.shipEffy = (rect.height - self.shipEffBk.GetHeight())/2

        self.shipEffx = self.shipEffx - self.animCount

        self.shipBmpx = self.padding + (rect.height - self.shipBmp.GetWidth()) / 2
        self.shipBmpy = (rect.height - self.shipBmp.GetHeight()) / 2

        self.shipBmpx= self.shipBmpx - self.animCount

        self.textStartx = self.shipEffx + self.shipEffBk.GetWidth() + self.padding

        self.fitNamey = (rect.height - self.shipBmp.GetHeight()) / 2

        mdc.SetFont(self.fontBig)
        wtext, htext = mdc.GetTextExtent(self.fitName)

        self.timestampy = self.fitNamey + htext

        mdc.SetFont(self.fontSmall)

        wlabel,hlabel = mdc.GetTextExtent(self.toolbar.hoverLabel)

        self.thoverx = self.toolbarx - self.padding - wlabel
        self.thovery = (rect.height - hlabel)/2
        self.thoverw = wlabel

    def DrawItem(self, mdc):
        rect = self.GetRect()

        windowColor = wx.SystemSettings_GetColour(wx.SYS_COLOUR_WINDOW)
        textColor = colorUtils.GetSuitableColor(windowColor, 1)

        mdc.SetTextForeground(textColor)

        self.UpdateElementsPos(mdc)

        self.toolbar.SetPosition((self.toolbarx, self.toolbary))

        if self.GetState() & SFItem.SB_ITEM_HIGHLIGHTED:
            shipEffBk = self.shipEffBkMirrored
        else:
            shipEffBk = self.shipEffBk

        mdc.DrawBitmap(shipEffBk, self.shipEffx, self.shipEffy, 0)

        mdc.DrawBitmap(self.shipBmp, self.shipBmpx, self.shipBmpy, 0)

        shipName, fittings, booster, timestamp = self.shipFittingInfo

        mdc.SetFont(self.fontNormal)

        fitDate = time.localtime(self.timestamp)
        fitLocalDate = "%d/%02d/%02d %02d:%02d" % ( fitDate[0], fitDate[1], fitDate[2], fitDate[3], fitDate[4])
        pfdate = drawUtils.GetPartialText(mdc, fitLocalDate, self.toolbarx - self.textStartx - self.padding * 2 - self.thoverw)

        mdc.DrawText(pfdate, self.textStartx, self.timestampy)

        mdc.SetFont(self.fontSmall)
        mdc.DrawText(self.toolbar.hoverLabel, self.thoverx, self.thovery)

        mdc.SetFont(self.fontBig)

        psname = drawUtils.GetPartialText(mdc, self.fitName, self.toolbarx - self.textStartx - self.padding * 2 - self.thoverw)

        mdc.DrawText(psname, self.textStartx, self.fitNamey)

        if self.tcFitName.IsShown():
            self.AdjustControlSizePos(self.tcFitName, self.textStartx, self.toolbarx - self.editWidth - self.padding)

        tdc = wx.MemoryDC()
        self.dragTLFBmp = wx.EmptyBitmap((self.toolbarx if self.toolbarx < 200 else 200), rect.height)
        tdc.SelectObject(self.dragTLFBmp)
        tdc.Blit(0, 0, (self.toolbarx if self.toolbarx < 200 else 200), rect.height, mdc, 0, 0, wx.COPY)
        tdc.SelectObject(wx.NullBitmap)

    def AdjustControlSizePos(self, editCtl, start, end):
        fnEditSize = editCtl.GetSize()
        wSize = self.GetSize()
        fnEditPosX = end
        fnEditPosY = (wSize.height - fnEditSize.height)/2
        if fnEditPosX < start:
            editCtl.SetSize((self.editWidth + fnEditPosX - start,-1))
            editCtl.SetPosition((start,fnEditPosY))
        else:
            editCtl.SetSize((self.editWidth,-1))
            editCtl.SetPosition((fnEditPosX,fnEditPosY))

    def GetState(self):
        activeFitID = self.mainFrame.getActiveFit()

        if self.highlighted and not activeFitID == self.fitID:
            state = SFItem.SB_ITEM_HIGHLIGHTED

        else:
            if activeFitID == self.fitID:
                if self.highlighted:
                    state = SFItem.SB_ITEM_SELECTED  | SFItem.SB_ITEM_HIGHLIGHTED
                else:
                    state = SFItem.SB_ITEM_SELECTED
            else:
                state = SFItem.SB_ITEM_NORMAL
        return state

    def RenderBackground(self):
        rect = self.GetRect()

        windowColor = wx.SystemSettings_GetColour(wx.SYS_COLOUR_WINDOW)

        activeFitID = self.mainFrame.getActiveFit()

        state = self.GetState()

        sFactor = 0.2
        mFactor = None
        eFactor = 0

        if state == SFItem.SB_ITEM_HIGHLIGHTED:
            mFactor = 0.45
            eFactor = 0.30

        elif state == SFItem.SB_ITEM_SELECTED  | SFItem.SB_ITEM_HIGHLIGHTED:
            eFactor = 0.3
            mFactor = 0.4

        elif state == SFItem.SB_ITEM_SELECTED:
            eFactor = (self.maxDelta - self.selectedDelta)/100 + 0.25
        else:
            sFactor = 0

        if self.bkBitmap:
            if self.bkBitmap.eFactor == eFactor and self.bkBitmap.sFactor == sFactor and self.bkBitmap.mFactor == mFactor \
             and rect.width == self.bkBitmap.GetWidth() and rect.height == self.bkBitmap.GetHeight() :
                return
            else:
                del self.bkBitmap

        self.bkBitmap = drawUtils.RenderGradientBar(windowColor, rect.width, rect.height, sFactor, eFactor, mFactor)
        self.bkBitmap.state = state
        self.bkBitmap.sFactor = sFactor
        self.bkBitmap.eFactor = eFactor
        self.bkBitmap.mFactor = mFactor


########NEW FILE########
__FILENAME__ = statsPane
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import wx
from gui.statsView import StatsView
import service
from gui.pyfatogglepanel import TogglePanel
import gui.builtinStatsViews
from gui.contextMenu import ContextMenu
#import gui.builtinViews.fittingView as fv
import gui.mainFrame
import gui.globalEvents as GE

class StatsPane(wx.Panel):
    DEFAULT_VIEWS = ["resourcesViewFull", "resistancesViewFull" ,"rechargeViewFull", "firepowerViewFull",
                     "capacitorViewFull", "targetingmiscViewFull", "priceViewFull"]

    def fitChanged(self, event):
        cFit = service.Fit.getInstance()
        fit = cFit.getFit(event.fitID)
        for view in self.views:
            view.refreshPanel(fit)
        event.Skip()

    def __init__(self, parent):
        wx.Panel.__init__(self, parent)

        # Use 25% smaller fonts if MAC or force font size to 8 for msw/linux

        if "__WXMAC__" in  wx.PlatformInfo :
            self.SetWindowVariant(wx.WINDOW_VARIANT_SMALL)
        else:
            standardFont = wx.SystemSettings.GetFont(wx.SYS_DEFAULT_GUI_FONT)
            standardFont.SetPointSize(8)
            self.SetFont(standardFont)

        mainSizer = wx.BoxSizer(wx.VERTICAL)
        self.SetSizer(mainSizer)

        self.views = []
        self.nameViewMap = {}
        maxviews = len(self.DEFAULT_VIEWS)
        i=0
        for viewName in self.DEFAULT_VIEWS:
            tp = TogglePanel(self)
            contentPanel = tp.GetContentPane()
            contentPanel.viewName = viewName

            view = StatsView.getView(viewName)(self)
            self.nameViewMap[viewName] = view
            self.views.append(view)

            headerPanel = tp.GetHeaderPanel()

            view.populatePanel(contentPanel, headerPanel)
            tp.SetLabel(view.getHeaderText(None))
            view.refreshPanel(None)

            contentPanel.Bind(wx.EVT_RIGHT_DOWN, self.contextHandler(contentPanel))
            for child in contentPanel.GetChildren():
                child.Bind(wx.EVT_RIGHT_DOWN, self.contextHandler(contentPanel))

            mainSizer.Add(tp, 0, wx.EXPAND | wx.LEFT, 3)
            if i < maxviews - 1:
                mainSizer.Add(wx.StaticLine(self, wx.ID_ANY, style=wx.HORIZONTAL), 0, wx.EXPAND | wx.ALL,2)
            i+=1
            tp.OnStateChange(tp.GetBestSize())

        width,height = self.GetSize()
        self.SetMinSize((width+9,-1))


        self.mainFrame = gui.mainFrame.MainFrame.getInstance()
        self.mainFrame.Bind(GE.FIT_CHANGED, self.fitChanged)

    def contextHandler(self, contentPanel):
        viewName = contentPanel.viewName
        def handler(event):
            menu = ContextMenu.getMenu(None, (viewName,))
            if menu is not None:
                contentPanel.PopupMenu(menu)

            event.Skip()

        return handler

########NEW FILE########
__FILENAME__ = statsView
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

class StatsView(object):
    views = {}
    def __init__(self):
        pass

    @classmethod
    def register(cls):
        StatsView.views[cls.name] = cls

    @classmethod
    def getView(cls, name):
        return cls.views[name]

    def populatePanel(self, panel):
        raise NotImplementedError()

    def getHeaderText(self, fit):
        raise NotImplementedError()

    def refreshPanel(self, fit):
        raise NotImplementedError()

from gui.builtinStatsViews import *
########NEW FILE########
__FILENAME__ = updateDialog
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import wx
import bitmapLoader
import config
import service
import dateutil.parser

class UpdateDialog(wx.Dialog):

    def __init__(self, parent, release):
        wx.Dialog.__init__ ( self, parent, id = wx.ID_ANY, title = "Pyfa Update", pos = wx.DefaultPosition, size = wx.Size( 400,300 ), style = wx.DEFAULT_DIALOG_STYLE )

        self.UpdateSettings = service.settings.UpdateSettings.getInstance()
        self.releaseInfo = release
        self.SetSizeHintsSz( wx.DefaultSize, wx.DefaultSize )

        mainSizer = wx.BoxSizer( wx.VERTICAL )

        headSizer = wx.BoxSizer( wx.HORIZONTAL )

        self.headingText = wx.StaticText( self, wx.ID_ANY, "Pyfa Update Available!", wx.DefaultPosition, wx.DefaultSize, wx.ALIGN_CENTRE )
        self.headingText.Wrap( -1 )
        self.headingText.SetFont( wx.Font( 14, 74, 90, 92, False) )

        headSizer.Add( self.headingText, 1, wx.ALL, 5 )
        mainSizer.Add( headSizer, 0, wx.EXPAND, 5 )

        mainSizer.Add( wx.StaticLine( self, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.LI_HORIZONTAL ), 0, wx.EXPAND |wx.ALL, 5 )

        versionSizer = wx.BoxSizer( wx.HORIZONTAL )

        if(self.releaseInfo['prerelease']):
            self.releaseText = wx.StaticText( self, wx.ID_ANY, "Pre-release", wx.DefaultPosition, wx.DefaultSize, wx.ALIGN_RIGHT )
            self.releaseText.SetFont( wx.Font( 12, 74, 90, 92, False) )
            self.releaseText.SetForegroundColour( wx.Colour( 230, 0, 0 ) )
        else:
            self.releaseText = wx.StaticText( self, wx.ID_ANY, "Stable", wx.DefaultPosition, wx.DefaultSize, wx.ALIGN_RIGHT )
            self.releaseText.SetFont( wx.Font( 12, 74, 90, 90, False) )

        self.releaseText.Wrap( -1 )

        versionSizer.Add( self.releaseText, 1, wx.ALL, 5 )

        self.versionText = wx.StaticText( self, wx.ID_ANY, self.releaseInfo['tag_name'], wx.DefaultPosition, wx.DefaultSize, wx.ALIGN_LEFT )
        self.versionText.Wrap( -1 )
        self.versionText.SetFont( wx.Font( 12, 74, 90, 90, False) )

        versionSizer.Add( self.versionText, 1, wx.ALL, 5 )
        versionSizer.AddSpacer( ( 15, 5), 0, wx.EXPAND, 5 )

        mainSizer.Add( versionSizer, 0, wx.EXPAND, 5 )
        mainSizer.AddSpacer( ( 0, 5), 0, wx.EXPAND, 5 )

        releaseDate = dateutil.parser.parse(self.releaseInfo['created_at'])
        notesSizer = wx.BoxSizer( wx.HORIZONTAL )
        self.notesTextCtrl = wx.TextCtrl( self, wx.ID_ANY, str(releaseDate.date())+":\n\n"+self.releaseInfo['body'], wx.DefaultPosition, wx.DefaultSize, wx.TE_AUTO_URL|wx.TE_MULTILINE|wx.TE_READONLY|wx.DOUBLE_BORDER|wx.TRANSPARENT_WINDOW )

        notesSizer.Add( self.notesTextCtrl, 1, wx.EXPAND|wx.LEFT|wx.RIGHT, 5 )
        mainSizer.Add( notesSizer, 1, wx.EXPAND, 5 )

        self.supressCheckbox = wx.CheckBox( self, wx.ID_ANY, "Don't remind me again for this release", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.supressCheckbox.Bind(wx.EVT_CHECKBOX, self.SuppressChange)

        mainSizer.Add( self.supressCheckbox, 0, wx.ALL, 5 )
        mainSizer.Add( wx.StaticLine( self, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.LI_HORIZONTAL ), 0, wx.EXPAND |wx.ALL, 5 )

        actionSizer = wx.BoxSizer( wx.HORIZONTAL )

        goSizer = wx.BoxSizer( wx.VERTICAL )
        self.downloadButton = wx.Button( self, wx.ID_ANY, "Download", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.downloadButton.Bind(wx.EVT_BUTTON, self.OnDownload)
        goSizer.Add( self.downloadButton, 0, wx.ALL, 5 )
        actionSizer.Add( goSizer, 1, wx.EXPAND, 5 )

        self.closeButton = wx.Button(self, wx.ID_CLOSE)
        self.closeButton.Bind(wx.EVT_BUTTON, self.OnClose)
        actionSizer.Add( self.closeButton, 0, wx.ALL, 5 )
        mainSizer.Add( actionSizer, 0, wx.EXPAND, 5 )

        self.SetSizer( mainSizer )
        self.Layout()

        # Handle use-case of suppressing a release, then a new version becoming available.
        # If that new version is not suppressed, the old version will remain in the preferences and
        # may cause confusion. If this dialog box is popping up for any reason, that mean we can
        # safely reset this setting
        self.UpdateSettings.set('version', None)

        self.Centre( wx.BOTH )

    def OnClose(self, e):
        self.Destroy()

    def SuppressChange(self, e):
        if (self.supressCheckbox.IsChecked()):
            self.UpdateSettings.set('version', self.releaseInfo['tag_name'])
        else:
            self.UpdateSettings.set('version', None)

    def OnDownload(self, e):
        wx.LaunchDefaultBrowser('https://github.com/DarkFenX/Pyfa/releases/tag/'+self.releaseInfo['tag_name'])
        self.OnClose(e)
########NEW FILE########
__FILENAME__ = animEffects

import math

def OUT_CIRC (t, b, c, d):
    t=float(t)
    b=float(b)
    c=float(c)
    d=float(d)
    t = t/d -1
    return c * math.sqrt(1 - t*t) + b;

def OUT_QUART(t, b, c, d):
    t=float(t)
    b=float(b)
    c=float(c)
    d=float(d)
    t = t/d -1
    return -c * ((t)*t*t*t - 1) + b;

def INOUT_CIRC(t, b, c, d):
    t=float(t)
    b=float(b)
    c=float(c)
    d=float(d)
    t1 = t / (d / 2)

    if ((t / (d/2)) < 1):
        return -c/2 * (math.sqrt(1 - (t/(d/2))**2) - 1) + b
    return c/2 * (math.sqrt(1 - (t1-2)**2) + 1) + b;

def IN_CUBIC (t, b, c, d):
    t=float(t)
    b=float(b)
    c=float(c)
    d=float(d)
    t = t/d
    return c*t*t*t + b

def OUT_QUAD (t, b, c, d):
    t=float(t)
    b=float(b)
    c=float(c)
    d=float(d)

    t/=d

    return -c *(t)*(t-2) + b

def OUT_BOUNCE (t, b, c, d):
    t=float(t)
    b=float(b)
    c=float(c)
    d=float(d)

    t/=d

    if ((t) < (1/2.75)):
        return c*(7.5625*t*t) + b
    else:
        if (t < (2/2.75)):
            t-=(1.5/2.75)
            return c*(7.5625*t*t + .75) + b
        else:
            if (t < (2.5/2.75)):
                t-=(2.25/2.75)
                return c*(7.5625*(t)*t + .9375) + b
            else:
                t-=(2.625/2.75)
                return c*(7.5625*(t)*t + .984375) + b

def INOUT_EXP(t, b, c, d):
    t=float(t)
    b=float(b)
    c=float(c)
    d=float(d)
    t1 = t / (d/2)
    if t==0:
         return b
    if t==d:
         return b+c
    if (t1) < 1:
         return c/2 * math.pow(2, 10 * (t1 - 1)) + b - c * 0.0005
    return c/2 * 1.0005 * (-math.pow(2, -10 * (t1-1)) + 2) + b

########NEW FILE########
__FILENAME__ = animUtils
import wx
import gui.utils.colorUtils as colorUtils

class LoadAnimation(wx.Window):
    def __init__ (self, parent, id = wx.ID_ANY, label = "", pos = wx.DefaultPosition, size = wx.DefaultSize, style = 0):
        wx.Window.__init__(self, parent, id, pos = pos, size = size, style = style)

        self.label = label

        self.animTimerId = wx.NewId()
        self.animTimer = wx.Timer(self, self.animTimerId)
        self.animTimerPeriod = 50

        self.animCount = 0
        self.animDir = 1
        self.bars = 10
        self.padding = 2


        self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnEraseBackground)
        self.Bind(wx.EVT_TIMER, self.OnTimer)
        self.Bind(wx.EVT_PAINT, self.OnPaint)

        self.animTimer.Start(self.animTimerPeriod)

    def Play(self):
        if self.animTimer.IsRunning():
            self.animTimer.Stop()
        self.animCount = 0
        self.animTimer.Start(self.animTimerPeriod)

    def Stop(self):
        if self.animTimer.IsRunning():
            self.animTimer.Stop()

    def OnTimer(self, event):
        self.animCount += self.animDir

        if self.animCount >= self.bars:
            self.animCount = self.bars - 1
            self.animDir = -1

        if self.animCount < 0:
            self.animCount = 0
            self.animDir = 1

        self.Refresh()

    def OnEraseBackground(self, event):
        pass

    def OnPaint(self, event):
        rect = self.GetClientRect()
        dc = wx.BufferedPaintDC(self)
        windowColor = wx.SystemSettings_GetColour(wx.SYS_COLOUR_WINDOW)
        dc.SetBackground(wx.Brush(windowColor))
        dc.Clear()

        barColor = wx.SystemSettings_GetColour(wx.SYS_COLOUR_WINDOWTEXT)
        shadeColor = colorUtils.GetSuitableColor(barColor, 0.75)

        barWidth = (rect.width) / self.bars
        barHeight = rect.height - self.padding * 2

        x = self.padding

        for bar in xrange(self.bars):
            if bar != self.animCount:
                dc.SetPen(wx.Pen(shadeColor))
                dc.SetBrush(wx.Brush(shadeColor))
                bh = barHeight
                y = self.padding
            else:
                barColor = colorUtils.GetSuitableColor(barColor,float(self.animCount/2)/10)
                dc.SetPen(wx.Pen(barColor))
                dc.SetBrush(wx.Brush(barColor))
                bh = rect.height
                y = 0

            dc.DrawRectangle(x, y, barWidth, bh)
            x += barWidth

        textColor = wx.SystemSettings_GetColour(wx.SYS_COLOUR_WINDOWTEXT)
        dc.SetTextForeground(textColor)
        dc.DrawLabel(self.label,rect,wx.ALIGN_CENTER)

class WaitDialog(wx.Dialog):
    def __init__(self, parent, title = "Processing"):
        wx.Dialog.__init__ (self, parent, id=wx.ID_ANY, title = title, size=(300,30),
                           style=wx.NO_BORDER)
        mainSizer = wx.BoxSizer( wx.HORIZONTAL )

        self.progress = LoadAnimation(self,label = title, size=(300,30))
        mainSizer.Add( self.progress, 1, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 0 )
        self.SetSizer( mainSizer )
        self.Layout()
        self.Bind(wx.EVT_CLOSE,self.OnClose)
        self.CenterOnParent()

    def OnClose(self, event):
        pass

########NEW FILE########
__FILENAME__ = clipboard
import wx

def toClipboard(text):
    clip = wx.TheClipboard
    clip.Open()
    data = wx.TextDataObject(text)
    clip.SetData(data)
    clip.Close()

def fromClipboard():
    clip = wx.TheClipboard
    clip.Open()
    data = wx.TextDataObject("")
    if clip.GetData(data):
        clip.Close()
        return data.GetText()
    else:
        clip.Close()
        return None
########NEW FILE########
__FILENAME__ = colorUtils
import wx
import math

#Brightens a color (wx.Colour), factor = [0,1]

def BrightenColor(color, factor):

    r,g,b = color
    a = color.Alpha()

    factor = min(max(factor, 0), 1)

    r+=(255-r)*factor
    b+=(255-b)*factor
    g+=(255-g)*factor

    return wx.Colour(r,g,b,a)

#Darkens a color (wx.Colour), factor = [0, 1]

def DarkenColor(color, factor):
    bkR ,bkG , bkB = color

    alpha = color.Alpha()

    factor = min(max(factor, 0), 1)
    factor = 1 - factor

    r = float(bkR * factor)
    g = float(bkG * factor)
    b = float(bkB * factor)

    r = min(max(r,0),255)
    b = min(max(b,0),255)
    g = min(max(g,0),255)

    return wx.Colour(r, g, b, alpha)


#Calculates the brightness of a color, different options

def GetBrightnessO1(color):
    r,g,b = color
    return (0.299*r + 0.587*g + 0.114*b)

def GetBrightnessO2(color):
    r,g,b = color
    return math.sqrt( 0.241 * r * r + 0.691 * g * g + 0.068 * b * b )



#Calculates a suitable color based on original color (wx.Colour), its brightness, a factor=[0,1] (darken/brighten by factor depending on calculated brightness)

def GetSuitableColor(color, factor):

    brightness = GetBrightnessO1(color)

    if brightness >129:
        return DarkenColor(color, factor)
    else:
        return BrightenColor(color, factor)



#Calculates the color between a given start and end colors, delta = [0,1]
#Colors are wx.Colour objects

def CalculateTransitionColor(startColor, endColor, delta):
    sR,sG,sB = startColor
    eR,eG,eB = endColor

    alphaS = startColor.Alpha()
    alphaE = endColor.Alpha()

    tR = sR + (eR - sR) *  delta
    tG = sG + (eG - sG) *  delta
    tB = sB + (eB - sB) *  delta

    return wx.Colour(tR, tG, tB, (alphaS + alphaE)/2)

########NEW FILE########
__FILENAME__ = compat
# Backport of OrderedDict() class that runs on Python 2.4, 2.5, 2.6, 2.7 and pypy.
# Passes Python2.7's test suite and incorporates all the latest updates.

try:
    from thread import get_ident as _get_ident
except ImportError:
    from dummy_thread import get_ident as _get_ident

try:
    from _abcoll import KeysView, ValuesView, ItemsView
except ImportError:
    pass


class OrderedDict(dict):
    'Dictionary that remembers insertion order'
    # An inherited dict maps keys to values.
    # The inherited dict provides __getitem__, __len__, __contains__, and get.
    # The remaining methods are order-aware.
    # Big-O running times for all methods are the same as for regular dictionaries.

    # The internal self.__map dictionary maps keys to links in a doubly linked list.
    # The circular doubly linked list starts and ends with a sentinel element.
    # The sentinel element never gets deleted (this simplifies the algorithm).
    # Each link is stored as a list of length three:  [PREV, NEXT, KEY].

    def __init__(self, *args, **kwds):
        '''Initialize an ordered dictionary.  Signature is the same as for
        regular dictionaries, but keyword arguments are not recommended
        because their insertion order is arbitrary.

        '''
        if len(args) > 1:
            raise TypeError('expected at most 1 arguments, got %d' % len(args))
        try:
            self.__root
        except AttributeError:
            self.__root = root = []                     # sentinel node
            root[:] = [root, root, None]
            self.__map = {}
        self.__update(*args, **kwds)

    def __setitem__(self, key, value, dict_setitem=dict.__setitem__):
        'od.__setitem__(i, y) <==> od[i]=y'
        # Setting a new item creates a new link which goes at the end of the linked
        # list, and the inherited dictionary is updated with the new key/value pair.
        if key not in self:
            root = self.__root
            last = root[0]
            last[1] = root[0] = self.__map[key] = [last, root, key]
        dict_setitem(self, key, value)

    def __delitem__(self, key, dict_delitem=dict.__delitem__):
        'od.__delitem__(y) <==> del od[y]'
        # Deleting an existing item uses self.__map to find the link which is
        # then removed by updating the links in the predecessor and successor nodes.
        dict_delitem(self, key)
        link_prev, link_next, key = self.__map.pop(key)
        link_prev[1] = link_next
        link_next[0] = link_prev

    def __iter__(self):
        'od.__iter__() <==> iter(od)'
        root = self.__root
        curr = root[1]
        while curr is not root:
            yield curr[2]
            curr = curr[1]

    def __reversed__(self):
        'od.__reversed__() <==> reversed(od)'
        root = self.__root
        curr = root[0]
        while curr is not root:
            yield curr[2]
            curr = curr[0]

    def clear(self):
        'od.clear() -> None.  Remove all items from od.'
        try:
            for node in self.__map.itervalues():
                del node[:]
            root = self.__root
            root[:] = [root, root, None]
            self.__map.clear()
        except AttributeError:
            pass
        dict.clear(self)

    def popitem(self, last=True):
        '''od.popitem() -> (k, v), return and remove a (key, value) pair.
        Pairs are returned in LIFO order if last is true or FIFO order if false.

        '''
        if not self:
            raise KeyError('dictionary is empty')
        root = self.__root
        if last:
            link = root[0]
            link_prev = link[0]
            link_prev[1] = root
            root[0] = link_prev
        else:
            link = root[1]
            link_next = link[1]
            root[1] = link_next
            link_next[0] = root
        key = link[2]
        del self.__map[key]
        value = dict.pop(self, key)
        return key, value

    # -- the following methods do not depend on the internal structure --

    def keys(self):
        'od.keys() -> list of keys in od'
        return list(self)

    def values(self):
        'od.values() -> list of values in od'
        return [self[key] for key in self]

    def items(self):
        'od.items() -> list of (key, value) pairs in od'
        return [(key, self[key]) for key in self]

    def iterkeys(self):
        'od.iterkeys() -> an iterator over the keys in od'
        return iter(self)

    def itervalues(self):
        'od.itervalues -> an iterator over the values in od'
        for k in self:
            yield self[k]

    def iteritems(self):
        'od.iteritems -> an iterator over the (key, value) items in od'
        for k in self:
            yield (k, self[k])

    def update(*args, **kwds):
        '''od.update(E, **F) -> None.  Update od from dict/iterable E and F.

        If E is a dict instance, does:           for k in E: od[k] = E[k]
        If E has a .keys() method, does:         for k in E.keys(): od[k] = E[k]
        Or if E is an iterable of items, does:   for k, v in E: od[k] = v
        In either case, this is followed by:     for k, v in F.items(): od[k] = v

        '''
        if len(args) > 2:
            raise TypeError('update() takes at most 2 positional '
                            'arguments (%d given)' % (len(args),))
        elif not args:
            raise TypeError('update() takes at least 1 argument (0 given)')
        self = args[0]
        # Make progressively weaker assumptions about "other"
        other = ()
        if len(args) == 2:
            other = args[1]
        if isinstance(other, dict):
            for key in other:
                self[key] = other[key]
        elif hasattr(other, 'keys'):
            for key in other.keys():
                self[key] = other[key]
        else:
            for key, value in other:
                self[key] = value
        for key, value in kwds.items():
            self[key] = value

    __update = update  # let subclasses override update without breaking __init__

    __marker = object()

    def pop(self, key, default=__marker):
        '''od.pop(k[,d]) -> v, remove specified key and return the corresponding value.
        If key is not found, d is returned if given, otherwise KeyError is raised.

        '''
        if key in self:
            result = self[key]
            del self[key]
            return result
        if default is self.__marker:
            raise KeyError(key)
        return default

    def setdefault(self, key, default=None):
        'od.setdefault(k[,d]) -> od.get(k,d), also set od[k]=d if k not in od'
        if key in self:
            return self[key]
        self[key] = default
        return default

    def __repr__(self, _repr_running={}):
        'od.__repr__() <==> repr(od)'
        call_key = id(self), _get_ident()
        if call_key in _repr_running:
            return '...'
        _repr_running[call_key] = 1
        try:
            if not self:
                return '%s()' % (self.__class__.__name__,)
            return '%s(%r)' % (self.__class__.__name__, self.items())
        finally:
            del _repr_running[call_key]

    def __reduce__(self):
        'Return state information for pickling'
        items = [[k, self[k]] for k in self]
        inst_dict = vars(self).copy()
        for k in vars(OrderedDict()):
            inst_dict.pop(k, None)
        if inst_dict:
            return (self.__class__, (items,), inst_dict)
        return self.__class__, (items,)

    def copy(self):
        'od.copy() -> a shallow copy of od'
        return self.__class__(self)

    @classmethod
    def fromkeys(cls, iterable, value=None):
        '''OD.fromkeys(S[, v]) -> New ordered dictionary with keys from S
        and values equal to v (which defaults to None).

        '''
        d = cls()
        for key in iterable:
            d[key] = value
        return d

    def __eq__(self, other):
        '''od.__eq__(y) <==> od==y.  Comparison to another OD is order-sensitive
        while comparison to a regular mapping is order-insensitive.

        '''
        if isinstance(other, OrderedDict):
            return len(self)==len(other) and self.items() == other.items()
        return dict.__eq__(self, other)

    def __ne__(self, other):
        return not self == other

    # -- the following methods are only used in Python 2.7 --

    def viewkeys(self):
        "od.viewkeys() -> a set-like object providing a view on od's keys"
        return KeysView(self)

    def viewvalues(self):
        "od.viewvalues() -> an object providing a view on od's values"
        return ValuesView(self)

    def viewitems(self):
        "od.viewitems() -> a set-like object providing a view on od's items"
        return ItemsView(self)

########NEW FILE########
__FILENAME__ = drawUtils
import wx
import gui.utils.colorUtils as colorUtils


def RenderGradientBar(windowColor, width, height, sFactor, eFactor, mFactor = None , fillRatio = 2):

    if sFactor == 0 and eFactor == 0 and mFactor == None:
        return DrawFilledBitmap(width,height, windowColor)

    gStart = colorUtils.GetSuitableColor(windowColor, sFactor)

    if mFactor:
        gMid = colorUtils.GetSuitableColor(windowColor, mFactor)
    else:
         gMid = colorUtils.GetSuitableColor(windowColor, sFactor + (eFactor - sFactor) / 2)

    gEnd = colorUtils.GetSuitableColor(windowColor, eFactor)

    return DrawGradientBar(width, height, gStart, gEnd, gMid, fillRatio)


def DrawFilledBitmap(width, height, color):
    canvas = wx.EmptyBitmap(width,height)

    mdc = wx.MemoryDC()
    mdc.SelectObject(canvas)

    mdc.SetBackground(wx.Brush(color))
    mdc.Clear()

    mdc.SelectObject(wx.NullBitmap)

    return canvas

def DrawGradientBar(width, height, gStart, gEnd, gMid = None, fillRatio = 4):
    canvas = wx.EmptyBitmap(width,height)


    mdc = wx.MemoryDC()
    mdc.SelectObject(canvas)

    r = wx.Rect(0, 0, width, height)
    r.height = height / fillRatio

    if gMid is None:
        gMid = gStart

    mdc.GradientFillLinear(r, gStart, gMid, wx.SOUTH)
    r.top = r.height
    r.height = height * (fillRatio - 1)/fillRatio + (1 if height % fillRatio != 0 else 0)

    mdc.GradientFillLinear(r, gMid, gEnd, wx.SOUTH)

    mdc.SelectObject(wx.NullBitmap)

    return canvas


def GetPartialText(dc, text , maxWidth, defEllipsis = "..."):
        ellipsis = defEllipsis
        base_w, h = dc.GetTextExtent(ellipsis)

        lenText = len(text)
        drawntext = text
        w, dummy = dc.GetTextExtent(text)

        while lenText > 0:

            if w + base_w <= maxWidth:
                break

            w_c, h_c = dc.GetTextExtent(drawntext[-1])
            drawntext = drawntext[0:-1]
            lenText -= 1
            w -= w_c

        while len(ellipsis) > 0 and w + base_w > maxWidth:
            ellipsis = ellipsis[0:-1]
            base_w, h = dc.GetTextExtent(ellipsis)
        if len(text) > lenText:
            return drawntext + ellipsis
        else:
            return text

def GetRoundBitmap( w, h, r ):
    maskColor = wx.Color(0,0,0)
    shownColor = wx.Color(5,5,5)
    b = wx.EmptyBitmap(w,h)
    dc = wx.MemoryDC(b)
    dc.SetBrush(wx.Brush(maskColor))
    dc.DrawRectangle(0,0,w,h)
    dc.SetBrush(wx.Brush(shownColor))
    dc.SetPen(wx.Pen(shownColor))
    dc.DrawRoundedRectangle(0,0,w,h,r)
    dc.SelectObject(wx.NullBitmap)
    b.SetMaskColour(maskColor)
    return b

def GetRoundShape( w, h, r ):
    return wx.RegionFromBitmap( GetRoundBitmap(w,h,r) )

def CreateDropShadowBitmap(bitmap, opacity):
    img = wx.ImageFromBitmap(bitmap)
    img = img.AdjustChannels(0, 0, 0, opacity)
    return wx.BitmapFromImage(img)

########NEW FILE########
__FILENAME__ = exportHtml
import threading
import time
import service
import wx

class exportHtml():
    _instance = None
    @classmethod
    def getInstance(cls):
        if cls._instance == None:
            cls._instance = exportHtml()

        return cls._instance

    def __init__(self):
        self.thread = exportHtmlThread()

    def refreshFittingHtml(self, force = False, callback = False):
        settings = service.settings.HTMLExportSettings.getInstance()

        if (force or settings.getEnabled()):
            self.thread.stop()
            self.thread = exportHtmlThread(callback)
            self.thread.start()

class exportHtmlThread(threading.Thread):

    def __init__(self, callback = False):
        threading.Thread.__init__(self)
        self.callback = callback
        self.stopRunning = False

    def stop(self):
        self.stopRunning = True

    def run(self):
        # wait 1 second just in case a lot of modifications get made
        time.sleep(1);
        if self.stopRunning:
            return;

        sMarket = service.Market.getInstance()
        sFit    = service.Fit.getInstance()
        settings = service.settings.HTMLExportSettings.getInstance()

        HTML = """
<!DOCTYPE html>
<html>
  <head>
  <title>Pyfa Fittings</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="http://code.jquery.com/mobile/1.4.2/jquery.mobile-1.4.2.min.css" />
  <script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
  <script src="http://code.jquery.com/mobile/1.4.2/jquery.mobile-1.4.2.min.js"></script>
  <style>
    /* Basic settings */
    .ui-li-static.ui-collapsible {
        padding: 0;
    }
    .ui-li-static.ui-collapsible > .ui-collapsible-content > .ui-listview,
    .ui-li-static.ui-collapsible > .ui-collapsible-heading {
        margin: 0;
    }
    .ui-li-static.ui-collapsible > .ui-collapsible-content {
        padding-top: 0;
        padding-bottom: 0;
        padding-right: 0;
        border-bottom-width: 0;
    }
    /* collapse vertical borders */
    .ui-li-static.ui-collapsible > .ui-collapsible-content > .ui-listview > li.ui-last-child,
    .ui-li-static.ui-collapsible.ui-collapsible-collapsed > .ui-collapsible-heading > a.ui-btn {
        border-bottom-width: 0;
    }
    .ui-li-static.ui-collapsible > .ui-collapsible-content > .ui-listview > li.ui-first-child,
    .ui-li-static.ui-collapsible > .ui-collapsible-content > .ui-listview > li.ui-first-child > a.ui-btn,
    .ui-li-static.ui-collapsible > .ui-collapsible-heading > a.ui-btn {
        border-top-width: 0;
    }
    /* Remove right borders */
    .ui-li-static.ui-collapsible > .ui-collapsible-heading > a.ui-btn,
    .ui-li-static.ui-collapsible > .ui-collapsible-content > .ui-listview > .ui-li-static,
    .ui-li-static.ui-collapsible > .ui-collapsible-content > .ui-listview > li > a.ui-btn,
    .ui-li-static.ui-collapsible > .ui-collapsible-content {
        border-right-width: 0;
    }
    /* Remove left borders */
    /* Here, we need class ui-listview-outer to identify the outermost listview */
    .ui-listview-outer > .ui-li-static.ui-collapsible .ui-li-static.ui-collapsible.ui-collapsible,
    .ui-listview-outer > .ui-li-static.ui-collapsible > .ui-collapsible-heading > a.ui-btn,
    .ui-li-static.ui-collapsible > .ui-collapsible-content {
        border-left-width: 0;
    }
    .ui-content { max-width: 800px !important; margin: 0 auto !important;  }
    .ui-listview > .ui-li-static.ui-li-has-count { padding-right: 0px }
  </style>

  <script>
    $(document).ready(function() {
      $('a[data-dna]').each(function( index ) {
        var dna = $(this).data('dna');
        if (typeof CCPEVE !== 'undefined') { // inside IGB
          $(this).attr('href', 'javascript:CCPEVE.showFitting("'+dna+'");'); }
        else {                               // outside IGB
          $(this).attr('href', 'https://null-sec.com/hangar/?dna='+dna); }
      });
    });
  </script>
</head>
<body>
<div  id="canvas" data-role="page">
  <div data-role="header">
    <h1>Pyfa fits</h1>
  </div>
  <div data-role="content">

"""
        HTML += '  <ul data-role="listview" class="ui-listview-outer" data-inset="true" data-filter="true">\n'
        categoryList = list(sMarket.getShipRoot())
        categoryList.sort(key=lambda ship: ship.name)
        for group in categoryList:
            # init market group string to give ships something to attach to
            HTMLgroup = ''

            ships = list(sMarket.getShipList(group.ID))
            ships.sort(key=lambda ship: ship.name)

            # Keep track of how many ships per group
            groupFits = 0
            for ship in ships:
                fits = sFit.getFitsWithShip(ship.ID)
                if len(fits) > 0:
                    groupFits += len(fits)

                    if len(fits) == 1:
                        if self.stopRunning:
                            return
                        fit = fits[0]
                        dnaFit = sFit.exportDna(fit[0])
                        HTMLgroup += (
                        '        <li><a data-dna="' + dnaFit + '" target="_blank">' + ship.name + ": " + fit[1] + '</a></li>\n')
                    else:
                        # Ship group header
                        HTMLship = (
                        '        <li data-role="collapsible" data-iconpos="right" data-shadow="false" data-corners="false">\n'
                        '        <h2>' + ship.name + ' <span class="ui-li-count">'+str(len(fits))+'</span></h2>\n'
                        '          <ul data-role="listview" data-shadow="false" data-inset="true" data-corners="false">\n')

                        for fit in fits:
                            if self.stopRunning:
                                return
                            dnaFit = sFit.exportDna(fit[0])
                            HTMLship += '          <li><a data-dna="' + dnaFit + '" target="_blank">' + fit[1] + '</a></li>\n'

                        HTMLgroup += HTMLship + ('          </ul>\n'
                                                 '        </li>\n')
            if groupFits > 0:
                # Market group header
                HTML += (
                '    <li data-role="collapsible" data-iconpos="right" data-shadow="false" data-corners="false">\n'
                '      <h2>' + group.groupName + ' <span class="ui-li-count">'+str(groupFits)+'</span></h2>\n'
                '      <ul data-role="listview" data-shadow="false" data-inset="true" data-corners="false">\n'
                + HTMLgroup +
                '      </ul>\n'
                '    </li>')

        HTML += """
  </ul>
 </div>
</div>
</body>
</html>"""

        try:
            FILE = open(settings.getPath(), "w")
            FILE.write(HTML.encode('utf-8'));
            FILE.close();
        except IOError:
            print "Failed to write to " + settings.getPath()
            pass

        if self.callback:
            wx.CallAfter(self.callback)


########NEW FILE########
__FILENAME__ = listFormatter
def formatList(words):
    """Transforms ("a", "b", "c") into "a, b and c" string"""
    if not words:
        return ""
    if len(words) == 1:
        return words[0]
    last = words[-1:][0]
    beginning = u", ".join(words[:-1])
    return u"{0} and {1}".format(beginning, last)

########NEW FILE########
__FILENAME__ = numberFormatter
import math

def formatAmount(val, prec=3, lowest=0, highest=0, currency=False, forceSign=False):
    """
    Add suffix to value, transform value to match new suffix and round it.

    Keyword arguments:
    val -- value to process
    prec -- precision of final number (number of significant positions to show)
    lowest -- lowest order for suffixizing for numbers 0 < |num| < 1
    highest -- highest order for suffixizing for numbers |num| > 1
    currency -- if currency, billion suffix will be B instead of G
    forceSign -- if True, positive numbers are signed too
    """
    if val is None:
        return ""
    # Define suffix maps
    posSuffixMap = {3: "k", 6: "M", 9: "B" if currency is True else "G"}
    negSuffixMap = {-6: u'\u03bc', -3: "m"}
    # Define tuple of the map keys
    # As we're going to go from the biggest order of abs(key), sort
    # them differently due to one set of values being negative
    # and other positive
    posOrders = tuple(sorted(posSuffixMap.iterkeys(), reverse=True))
    negOrders = tuple(sorted(negSuffixMap.iterkeys(), reverse=False))
    # Find the least abs(key)
    posLowest = min(posOrders)
    negHighest = max(negOrders)
    # By default, mantissa takes just value and no suffix
    mantissa, suffix = val, ""
    # Positive suffixes
    if abs(val) > 1 and highest >= posLowest:
        # Start from highest possible suffix
        for key in posOrders:
            # Find first suitable suffix and check if it's not above highest order
            if abs(val) >= 10**key and key <= highest:
                mantissa, suffix = val/float(10**key), posSuffixMap[key]
                # Do additional step to eliminate results like 999999 => 1000k
                # If we're already using our greatest order, we can't do anything useful
                if posOrders.index(key) == 0:
                    break
                else:
                    # Get order greater than current
                    prevKey = posOrders[posOrders.index(key) - 1]
                    # Check if the key to which we potentially can change is greater
                    # than our highest boundary
                    if prevKey > highest:
                        # If it is, bail - we already have acceptable results
                        break
                    # Find multiplier to get from one order to another
                    orderDiff = 10**(prevKey - key)
                    # If rounded mantissa according to our specifications is greater than
                    # or equal to multiplier
                    if roundToPrec(mantissa, prec) >= orderDiff:
                        # Divide mantissa and use suffix of greater order
                        mantissa, suffix = mantissa/orderDiff, posSuffixMap[prevKey]
                    # Otherwise consider current results as acceptable
                    break
    # Take numbers between 0 and 1, and matching/below highest possible negative suffix
    elif abs(val) < 1 and val != 0 and lowest <= negHighest:
        # Start from lowest possible suffix
        for key in negOrders:
            # Get next order
            try:
                nextKey = negOrders[negOrders.index(key) + 1]
            except IndexError:
                nextKey = 0
            # Check if mantissa with next suffix is in range [1, 1000)
            if abs(val) < 10**(nextKey) and key >= lowest:
                mantissa, suffix = val/float(10**key), negSuffixMap[key]
                # Do additional step to eliminate results like 0.9999 => 1000m
                # Check if the key we're potentially switching to is greater than our
                # upper boundary
                if nextKey > highest:
                    # If it is, leave loop with results we already have
                    break
                # Find the multiplier between current and next order
                orderDiff = 10**(nextKey - key)
                # If rounded mantissa according to our specifications is greater than
                # or equal to multiplier
                if roundToPrec(mantissa, prec) >= orderDiff:
                    # Divide mantissa and use suffix of greater order
                    # Use special handling of zero key as it's not on the map
                    mantissa, suffix = mantissa/orderDiff, posSuffixMap[nextKey] if nextKey != 0 else ""
                # Otherwise consider current results as acceptable
                break
    # Round mantissa according to our prec variable
    mantissa = roundToPrec(mantissa, prec)
    sign = "+" if forceSign is True and mantissa > 0 else ""
    # Round mantissa and add suffix
    result = u"{0}{1}{2}".format(sign, mantissa, suffix)
    return result

def roundToPrec(val, prec):
    # We're not rounding integers anyway
    # Also make sure that we do not ask to calculate logarithm of zero
    if int(val) == val:
        return int(val)
    # Find round factor, taking into consideration that we want to keep at least prec
    # positions for fractions with zero integer part (e.g. 0.0000354 for prec=3)
    roundFactor = int(prec - math.ceil(math.log10(abs(val))))
    # But we don't want to round integers
    if roundFactor < 0:
        roundFactor = 0
    # Do actual rounding
    val = round(val, roundFactor)
    # Make sure numbers with .0 part designating float don't get through
    if int(val) == val:
        val = int(val)
    return val

########NEW FILE########
__FILENAME__ = viewColumn
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import wx

class ViewColumn(object):
    '''
    Abstract class that columns can inherit from.
    Once the missing methods are correctly implemented,
    they can be used as columns in a view.
    '''
    columns = {}
    def __init__(self, fittingView):
        self.fittingView = fittingView
        self.columnText = ""
        self.imageId = -1
        self.size = wx.LIST_AUTOSIZE_USEHEADER
        self.mask = 0
        self.maxsize = -1
        self.bitmap = wx.NullBitmap

    @classmethod
    def register(cls):
        ViewColumn.columns[cls.name] = cls

    @classmethod
    def getColumn(cls, name):
        return ViewColumn.columns[name]

    def getRestrictions(self):
        raise NotImplementedError()

    def getText(self, mod):
        return ""

    def getToolTip(self, mod):
        return ""

    def getImageId(self, mod):
        return -1

    @staticmethod
    def getParameters():
        return tuple()

    def delayedText(self, display, colItem):
        raise NotImplementedError()

from gui.builtinViewColumns import *

########NEW FILE########
__FILENAME__ = pyfa
#!/usr/bin/env python
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import sys
import re

if not hasattr(sys, 'frozen'):

    if sys.version_info < (2,6) or sys.version_info > (3,0):
        print("Pyfa requires python 2.x branch ( >= 2.6 )\nExiting.")
        sys.exit(1)

    try:
        import wxversion
    except ImportError:
        print("Cannot find wxPython\nYou can download wxPython (2.8) from http://www.wxpython.org/")
        sys.exit(1)
    try:
        wxversion.select('2.8')
    except wxversion.VersionError:
        try:
            wxversion.ensureMinimal('2.8')
        except wxversion.VersionError:
            print("Installed wxPython version doesn't meet requirements.\nYou can download wxPython (2.8) from http://www.wxpython.org/")
            sys.exit(1)
        else:
            print("wxPython 2.8 not found; attempting to use newer version, expect errors")

    try:
        import sqlalchemy

        saVersion =  sqlalchemy.__version__
        saMatch = re.match("([0-9]+).([0-9]+)([b\.])([0-9]+)", saVersion)
        if saMatch:
            saMajor = int(saMatch.group(1))
            saMinor = int(saMatch.group(2))
            betaFlag = True if saMatch.group(3) == "b" else False
            saBuild = int(saMatch.group(4)) if not betaFlag else 0
            if saMajor == 0 and (saMinor < 5 or (saMinor == 5 and saBuild < 8)):
                print("Pyfa requires sqlalchemy 0.5.8 at least  but current sqlalchemy version is %s\nYou can download sqlalchemy (0.5.8+) from http://www.sqlalchemy.org/".format(sqlalchemy.__version__))
                sys.exit(1)
        else:
            print("Unknown sqlalchemy version string format, skipping check")

    except ImportError:
        print("Cannot find sqlalchemy.\nYou can download sqlalchemy (0.6+) from http://www.sqlalchemy.org/")
        sys.exit(1)

from optparse import OptionParser

if __name__ == "__main__":
    # Parse command line options
    usage = "usage: %prog [--root]"
    parser = OptionParser(usage=usage)
    parser.add_option("-r", "--root", action="store_true", dest="rootsavedata", help="if you want pyfa to store its data in root folder, use this option", default=False)
    (options, args) = parser.parse_args()

    import config
    # Configure paths
    if options.rootsavedata is True:
        config.saveInRoot = True
    config.defPaths()

    # Import everything
    import wx
    import os
    import os.path

    import eos.db
    import service.prefetch
    from gui.mainFrame import MainFrame

    #Make sure the saveddata db exists
    if not os.path.exists(config.savePath):
        os.mkdir(config.savePath)

    eos.db.saveddata_meta.create_all()

    pyfa = wx.App(False)
    MainFrame()
    pyfa.MainLoop()

########NEW FILE########
__FILENAME__ = attribute
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import eos.db

class Attribute():
    instance = None
    @classmethod
    def getInstance(cls):
        if cls.instance is None:
            cls.instance = Attribute()

        return cls.instance

    def getAttributeInfo(self, identity):
        if isinstance(identity, (int, basestring)):
            info = eos.db.getAttributeInfo(identity, eager=("icon", "unit"))
        elif isinstance(identity, (int, float)):
            id = int(identity)
            info = eos.db.getAttributeInfo(id, eager=("icon", "unit"))
        return info

########NEW FILE########
__FILENAME__ = character
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import eos.db
import eos.types
import copy
import service
import itertools
from eos import eveapi
import config
import json
import os.path
import locale
import threading
import wx
from codecs import open

from xml.etree import ElementTree
from xml.dom import minidom

import gzip

class CharacterImportThread(threading.Thread):
    def __init__(self, paths, callback):
        threading.Thread.__init__(self)
        self.paths = paths
        self.callback = callback

    def run(self):
        paths = self.paths
        sCharacter = Character.getInstance()
        for path in paths:
            with open(path, mode='r') as charFile:
                sheet = eveapi.ParseXML(charFile)
                charID = sCharacter.new()
                sCharacter.rename(charID, sheet.name+" (imported)")
                sCharacter.apiUpdateCharSheet(charID, sheet)

        wx.CallAfter(self.callback)

class SkillBackupThread(threading.Thread):
    def __init__(self, path, saveFmt, activeFit, callback):
        threading.Thread.__init__(self)
        self.path = path
        self.saveFmt = saveFmt
        self.activeFit = activeFit
        self.callback = callback

    def run(self):
        path = self.path
        sCharacter = Character.getInstance()
        sFit = service.Fit.getInstance()
        fit = sFit.getFit(self.activeFit)
        backupData = "";
        if self.saveFmt == "xml" or self.saveFmt == "emp":
            backupData = sCharacter.exportXml()
        else:
            backupData = sCharacter.exportText()
        
        if self.saveFmt == "emp":
            with gzip.open(path, mode='wb') as backupFile:
                backupFile.write(backupData)
        else:
            with open(path, mode='w',encoding='utf-8') as backupFile:
                backupFile.write(backupData)

        wx.CallAfter(self.callback)

class Character(object):
    instance = None
    skillReqsDict = {}

    @classmethod
    def getInstance(cls):
        if cls.instance is None:
            cls.instance = Character()

        return cls.instance

    def exportText(self):
        data  = "Pyfa exported plan for \""+self.skillReqsDict['charname']+"\"\n"
        data += "=" * 79 + "\n"
        data += "\n"
        item = ""
        for s in self.skillReqsDict['skills']:
            if item == "" or not item == s["item"]:
                item = s["item"]
                data += "-" * 79 + "\n"
                data += "Skills required for {}:\n".format(item)
            data += "{}{}: {}\n".format("    " * s["indent"], s["skill"], int(s["level"]))
        data += "-" * 79 + "\n"

        return data

    def exportXml(self):
        root = ElementTree.Element("plan")
        root.attrib["name"] = "Pyfa exported plan for "+self.skillReqsDict['charname']
        root.attrib["revision"] = config.evemonMinVersion
        
        sorts = ElementTree.SubElement(root, "sorting")
        sorts.attrib["criteria"] = "None"
        sorts.attrib["order"] = "None"
        sorts.attrib["groupByPriority"] = "false"
        
        skillsSeen = set()

        for s in self.skillReqsDict['skills']:
            skillKey = str(s["skillID"])+"::"+s["skill"]+"::"+str(int(s["level"]))
            if skillKey in skillsSeen:
                pass   # Duplicate skills confuse EVEMon
            else:
                skillsSeen.add(skillKey)
                entry = ElementTree.SubElement(root, "entry")
                entry.attrib["skillID"] = str(s["skillID"])
                entry.attrib["skill"] = s["skill"]
                entry.attrib["level"] = str(int(s["level"]))
                entry.attrib["priority"] = "3"
                entry.attrib["type"] = "Prerequisite"
                notes = ElementTree.SubElement(entry, "notes")
                notes.text = entry.attrib["skill"]
       
        tree = ElementTree.ElementTree(root)
        data = ElementTree.tostring(root, 'utf-8')
        prettydata = minidom.parseString(data).toprettyxml(indent="  ")

        return prettydata

    def backupSkills(self, path, saveFmt, activeFit, callback):
        thread = SkillBackupThread(path, saveFmt, activeFit, callback)
        thread.start()

    def importCharacter(self, path, callback):
        thread = CharacterImportThread(path, callback)
        thread.start()

    def all0(self):
        all0 = eos.types.Character.getAll0()
        eos.db.commit()
        return all0

    def all0ID(self):
        return self.all0().ID

    def all5(self):
        all5 = eos.types.Character.getAll5()
        eos.db.commit()
        return all5

    def all5ID(self):
        return self.all5().ID

    def getCharacterList(self):
        baseChars = [eos.types.Character.getAll0(), eos.types.Character.getAll5()]
        # Flush incase all0 & all5 weren't in the db yet
        eos.db.commit()
        sFit = service.Fit.getInstance()
        return map(lambda c: (c.ID, c.name, c == sFit.character), eos.db.getCharacterList())

    def getCharacter(self, charID):
        char = eos.db.getCharacter(charID)
        return char

    def getSkillGroups(self):
        cat = eos.db.getCategory(16)
        groups = []
        for grp in cat.groups:
            if grp.published:
                groups.append((grp.ID, grp.name))
        return groups

    def getSkills(self, groupID):
        group = eos.db.getGroup(groupID)
        skills = []
        for skill in group.items:
            if skill.published == True:
                skills.append((skill.ID, skill.name))
        return skills

    def getSkillDescription(self, itemID):
        return eos.db.getItem(itemID).description

    def getGroupDescription(self, groupID):
        return eos.db.getMarketGroup(groupID).description

    def getSkillLevel(self, charID, skillID):
        skill = eos.db.getCharacter(charID).getSkill(skillID)
        return skill.level if skill.learned else "Not learned"

    def rename(self, charID, newName):
        char = eos.db.getCharacter(charID)
        char.name = newName
        eos.db.commit()

    def new(self):
        char = eos.types.Character("New Character")
        eos.db.save(char)
        return char.ID

    def getCharName(self, charID):
        return eos.db.getCharacter(charID).name

    def copy(self, charID):
        char = eos.db.getCharacter(charID)
        newChar = copy.deepcopy(char)
        eos.db.save(newChar)
        return newChar.ID

    def delete(self, charID):
        char = eos.db.getCharacter(charID)
        eos.db.commit()
        eos.db.remove(char)

    def getApiDetails(self, charID):
        char = eos.db.getCharacter(charID)
        if char.chars is not None:
            chars = json.loads(char.chars)
        else:
            chars = None
        return (char.apiID or "", char.apiKey or "", char.defaultChar or "", chars or [])

    def apiEnabled(self, charID):
        id, key, default, _ = self.getApiDetails(charID)
        return id is not "" and key is not "" and default is not ""
        
    def charList(self, charID, userID, apiKey):
        char = eos.db.getCharacter(charID)
        try:
            char.apiID = userID
            char.apiKey = apiKey
            charList = char.apiCharList(proxy = service.settings.ProxySettings.getInstance().getProxySettings())
            char.chars = json.dumps(charList)
            return charList
        except:
            return None

    def apiFetch(self, charID, charName):
        char = eos.db.getCharacter(charID)
        char.defaultChar = charName
        char.apiFetch(charName, proxy = service.settings.ProxySettings.getInstance().getProxySettings())
        eos.db.commit()

    def apiUpdateCharSheet(self, charID, sheet):
        char = eos.db.getCharacter(charID)
        char.apiUpdateCharSheet(sheet)
        eos.db.commit()

    def changeLevel(self, charID, skillID, level):
        char = eos.db.getCharacter(charID)
        skill = char.getSkill(skillID)
        if isinstance(level, basestring):
            skill.learned = False
            skill.level = None
        else:
            skill.level = level

        eos.db.commit()

    def addImplant(self, charID, itemID):
        char = eos.db.getCharacter(charID)
        implant = eos.types.Implant(eos.db.getItem(itemID))
        char.implants.freeSlot(implant.slot)
        char.implants.append(implant)

    def removeImplant(self, charID, slot):
        char = eos.db.getCharacter(charID)
        char.implants.freeSlot(slot)

    def getImplants(self, charID):
        char = eos.db.getCharacter(charID)
        return char.implants

    def checkRequirements(self, fit):
        toCheck = []
        reqs = {}
        for thing in itertools.chain(fit.modules, fit.drones, (fit.ship,)):
            for attr in ("item", "charge"):
                subThing = getattr(thing, attr, None)
                subReqs = {}
                if subThing is not None:
                    self._checkRequirements(fit, fit.character, subThing, subReqs)
                    if subReqs:
                        reqs[subThing] = subReqs

        return reqs

    def _checkRequirements(self, fit, char, subThing, reqs):
        for req, level in subThing.requiredSkills.iteritems():
            name = req.name
            ID = req.ID
            info = reqs.get(name)
            currLevel, subs = info if info is not None else 0, {}
            if level > currLevel and (char is None or char.getSkill(req).level < level):
                reqs[name] = (level, ID, subs)
                self._checkRequirements(fit, char, req, subs)

        return reqs

########NEW FILE########
__FILENAME__ = damagePattern
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import eos.db
import eos.types
import copy

class DamagePattern():
    instance = None
    @classmethod
    def getInstance(cls):
        if cls.instance is None:
            cls.instance = DamagePattern()

        return cls.instance

    def __init__(self):
        uniform = eos.db.getDamagePattern("Uniform")
        if uniform is None:
            uniform = eos.types.DamagePattern(25, 25, 25, 25)
            uniform.name = "Uniform"
            eos.db.save(uniform)

    def getDamagePatternList(self):
        return eos.db.getDamagePatternList()

    def getDamagePattern(self, name):
        return eos.db.getDamagePattern(name)

    def newPattern(self):
        p = eos.types.DamagePattern(0, 0, 0, 0)
        p.name = ""
        return p

    def renamePattern(self, p, newName):
        p.name = newName
        eos.db.save(p)

    def deletePattern(self, p):
        eos.db.remove(p)

    def copyPattern(self, p):
        newP = copy.deepcopy(p)
        eos.db.save(newP)
        return newP

    def saveChanges(self, p):
        eos.db.save(p)

    def importPatterns(self, text):
        lookup = {}
        current = self.getDamagePatternList()
        for pattern in current:
            lookup[pattern.name] = pattern
        try:
            imports = eos.types.DamagePattern.importPatterns(text)
            for pattern in imports:
                if pattern.name in lookup:
                    match = lookup[pattern.name]
                    match.__dict__.update(pattern.__dict__)
                else:
                    eos.db.save(pattern)
            eos.db.commit()
        except:
            pass

    def exportPatterns(self):
        patterns = self.getDamagePatternList()
        for i in xrange(len(patterns) - 1, -1, -1):
            if patterns[i].name in ("Uniform", "Selected Ammo"):
                del patterns[i]

        patterns.sort(key=lambda p: p.name)
        return eos.types.DamagePattern.exportPatterns(*patterns)


########NEW FILE########
__FILENAME__ = fit
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import os.path
import locale
import copy
import threading
import wx
from codecs import open

import eos.db
import eos.types

from eos.types import State, Slot, Module, Cargo

from service.market import Market
from service.damagePattern import DamagePattern
from service.character import Character
from service.fleet import Fleet
from service.settings import SettingsProvider

class FitBackupThread(threading.Thread):
    def __init__(self, path, callback):
        threading.Thread.__init__(self)
        self.path = path
        self.callback = callback

    def run(self):
        path = self.path
        sFit = Fit.getInstance()
        allFits = map(lambda x: x[0], sFit.getAllFits())
        backedUpFits = sFit.exportXml(*allFits)
        backupFile = open(path, "w", encoding="utf-8")
        backupFile.write(backedUpFits)
        backupFile.close()
        wx.CallAfter(self.callback)

class FitImportThread(threading.Thread):
    def __init__(self, paths, callback):
        threading.Thread.__init__(self)
        self.paths = paths
        self.callback = callback

    def run(self):
        importedFits = []
        paths = self.paths
        sFit = Fit.getInstance()
        for path in paths:
            pathImported = sFit.importFit(path)
            if pathImported is not None:
                importedFits += pathImported
        wx.CallAfter(self.callback, importedFits)

class Fit(object):
    instance = None
    @classmethod
    def getInstance(cls):
        if cls.instance is None:
            cls.instance = Fit()

        return cls.instance

    def __init__(self):
        self.pattern = DamagePattern.getInstance().getDamagePattern("Uniform")
        self.character = Character.getInstance().all5()
        self.booster = False
        self.dirtyFitIDs = set()

        serviceFittingDefaultOptions = {
            "useGlobalCharacter": False,
            "useGlobalDamagePattern": False,
            "defaultCharacter": self.character.ID,
            "useGlobalForceReload": False,
            "colorFitBySlot": False,
            "rackSlots": False,
            "rackLabels": False,
            "compactSkills": False}

        self.serviceFittingOptions = SettingsProvider.getInstance().getSettings("pyfaServiceFittingOptions", serviceFittingDefaultOptions)


    def getAllFits(self):
        fits = eos.db.getFitList()
        names = []
        for fit in fits:
            names.append((fit.ID, fit.name))

        return names

    def getFitsWithShip(self, id):
        ''' Lists fits of shipID, used with shipBrowser '''
        fits = eos.db.getFitsWithShip(id)
        names = []
        for fit in fits:
            names.append((fit.ID, fit.name, fit.booster, fit.timestamp))

        return names

    def getBoosterFits(self):
        ''' Lists fits flagged as booster '''
        fits = eos.db.getBoosterFits()
        names = []
        for fit in fits:
            names.append((fit.ID, fit.name, fit.shipID))

        return names

    def countFitsWithShip(self, id):
        count = eos.db.countFitsWithShip(id)
        return count

    def groupHasFits(self, id):
        sMkt = Market.getInstance()
        grp = sMkt.getGroup(id, eager=("items", "group"))
        items = sMkt.getItemsByGroup(grp)
        for item in items:
            if self.countFitsWithShip(item.ID) > 0:
                return True
        return False

    def getModule(self, fitID, pos):
        fit = eos.db.getFit(fitID)
        return fit.modules[pos]

    def newFit(self, shipID, name=None):
        fit = eos.types.Fit()
        fit.ship = eos.types.Ship(eos.db.getItem(shipID))
        fit.name = name if name is not None else "New %s" % fit.ship.item.name
        fit.damagePattern = self.pattern
        fit.character = self.character
        fit.booster = self.booster
        eos.db.save(fit)
        self.recalc(fit)
        return fit.ID

    def toggleBoostFit(self, fitID):
        fit = eos.db.getFit(fitID)
        fit.booster = not fit.booster
        eos.db.commit()

    def renameFit(self, fitID, newName):
        fit = eos.db.getFit(fitID)
        fit.name = newName
        eos.db.commit()

    def deleteFit(self, fitID):
        fit = eos.db.getFit(fitID)
        sFlt = Fleet.getInstance()
        sFlt.removeAssociatedFleetData(fit)
        self.removeProjectedData(fitID)

        eos.db.remove(fit)

    def copyFit(self, fitID):
        fit = eos.db.getFit(fitID)
        newFit = copy.deepcopy(fit)
        eos.db.save(newFit)
        return newFit.ID

    def clearFit(self, fitID):
        if fitID is None:
            return None

        fit = eos.db.getFit(fitID)
        fit.clear()
        return fit

    def removeProjectedData(self, fitID):
        '''Removes projection relation from ships that have fitID as projection. See GitHub issue #90'''
        fit = eos.db.getFit(fitID)
        fits = eos.db.getProjectedFits(fitID)

        for projectee in fits:
            projectee.projectedFits.remove(fit)

    def toggleFactorReload(self, fitID):
        if fitID is None:
            return None

        fit = eos.db.getFit(fitID)
        fit.factorReload = not fit.factorReload
        eos.db.commit()
        self.recalc(fit)

    def switchFit(self, fitID):
        if fitID is None:
            return None

        fit = eos.db.getFit(fitID)

        if self.serviceFittingOptions["useGlobalCharacter"]:
            if fit.character != self.character:
                fit.character = self.character

        if self.serviceFittingOptions["useGlobalDamagePattern"]:
            if fit.damagePattern != self.pattern:
                fit.damagePattern = self.pattern

        eos.db.commit()
        self.recalc(fit, withBoosters=True)

    def getFit(self, fitID):
        if fitID is None:
            return None
        fit = eos.db.getFit(fitID)
        inited = getattr(fit, "inited", None)
        if inited is None or inited is False:
            sFlt = Fleet.getInstance()
            f = sFlt.getLinearFleet(fit)
            if f is None:
                sFlt.removeAssociatedFleetData(fit)
                fit.fleet = None
            else:
                fit.fleet = f
            self.recalc(fit, withBoosters=True)
            fit.fill()
            eos.db.commit()
            fit.inited = True
        return fit

    def searchFits(self, name):
        results = eos.db.searchFits(name)
        fits = []
        for fit in results:
            fits.append((fit.ID, fit.name, fit.ship.item.ID, fit.ship.item.name, fit.booster, fit.timestamp))
        return fits

    def addImplant(self, fitID, itemID):
        if fitID is None:
            return False

        fit = eos.db.getFit(fitID)
        item = eos.db.getItem(itemID, eager="attributes")
        try:
            implant = eos.types.Implant(item)
        except ValueError:
            return False

        fit.implants.freeSlot(implant)
        fit.implants.append(implant)
        self.recalc(fit)
        return True

    def removeImplant(self, fitID, position):
        if fitID is None:
            return False

        fit = eos.db.getFit(fitID)
        implant = fit.implants[position]
        fit.implants.remove(implant)
        self.recalc(fit)
        return True

    def addBooster(self, fitID, itemID):
        if fitID is None:
            return False

        fit = eos.db.getFit(fitID)
        item = eos.db.getItem(itemID, eager="attributes")
        try:
            booster = eos.types.Booster(item)
        except ValueError:
            return False

        fit.boosters.freeSlot(booster)
        fit.boosters.append(booster)
        self.recalc(fit)
        return True

    def removeBooster(self, fitID, position):
        if fitID is None:
            return False

        fit = eos.db.getFit(fitID)
        booster = fit.boosters[position]
        fit.boosters.remove(booster)
        self.recalc(fit)
        return True

    def project(self, fitID, thing):
        fit = eos.db.getFit(fitID)

        if isinstance(thing, int):
            thing = eos.db.getItem(thing, eager=("attributes", "group.category"))

        if isinstance(thing, eos.types.Fit):
            if thing.ID == fitID:
                return
            fit.projectedFits.append(thing)
        elif thing.category.name == "Drone":
            drone = None
            for d in fit.projectedDrones.find(thing):
                if d is None or d.amountActive == d.amount or d.amount >= 5:
                    drone = d
                    break

            if drone is None:
                drone = eos.types.Drone(thing)
                fit.projectedDrones.append(drone)

            drone.amount += 1
        elif thing.group.name == "Effect Beacon":
            module = eos.types.Module(thing)
            module.state = State.ONLINE
            fit.projectedModules.append(module)
        else:
            module = eos.types.Module(thing)
            module.state = State.ACTIVE
            if not module.canHaveState(module.state, fit):
                module.state = State.OFFLINE
            fit.projectedModules.append(module)

        eos.db.commit()
        self.recalc(fit)
        return True

    def toggleProjected(self, fitID, thing, click):
        fit = eos.db.getFit(fitID)
        if isinstance(thing, eos.types.Drone):
            if thing.amountActive == 0 and thing.canBeApplied(fit):
                thing.amountActive = thing.amount
            else:
                thing.amountActive = 0
        elif isinstance(thing, eos.types.Module):
            thing.state = self.__getProposedState(thing, click)
            if not thing.canHaveState(thing.state, fit):
                thing.state = State.OFFLINE

        eos.db.commit()
        self.recalc(fit)

    def removeProjected(self, fitID, thing):
        fit = eos.db.getFit(fitID)
        if isinstance(thing, eos.types.Drone):
            fit.projectedDrones.remove(thing)
        elif isinstance(thing, eos.types.Module):
            fit.projectedModules.remove(thing)
        else:
            fit.projectedFits.remove(thing)

        eos.db.commit()
        self.recalc(fit)

    def appendModule(self, fitID, itemID):
        fit = eos.db.getFit(fitID)
        item = eos.db.getItem(itemID, eager=("attributes", "group.category"))
        try:
            m = eos.types.Module(item)
        except ValueError:
            return False

        if m.item.category.name == "Subsystem":
            fit.modules.freeSlot(m.getModifiedItemAttr("subSystemSlot"))

        if m.fits(fit):
            m.owner = fit
            numSlots = len(fit.modules)
            fit.modules.append(m)
            if m.isValidState(State.ACTIVE):
                m.state = State.ACTIVE

            self.recalc(fit)
            self.checkStates(fit, m)
            fit.fill()
            eos.db.commit()

            return numSlots != len(fit.modules)
        else:
            return None

    def removeModule(self, fitID, position):
        fit = eos.db.getFit(fitID)
        if fit.modules[position].isEmpty:
            return None

        numSlots = len(fit.modules)
        fit.modules.toDummy(position)
        self.recalc(fit)
        self.checkStates(fit, None)
        fit.fill()
        eos.db.commit()
        return numSlots != len(fit.modules)

    def moveCargoToModule(self, fitID, moduleIdx, cargoIdx, copy = False):
        '''
        Moves cargo to fitting window. Can either do a copy, move, or swap with current module
        If we try to copy/move into a spot with a non-empty module, we swap instead.

        To avoid redundancy in converting Cargo item, this function does the
        sanity checks as opposed to the GUI View. This is different than how the
        normal .swapModules() does things, which is mostly a blind swap.
        '''
        fit = eos.db.getFit(fitID)

        module = fit.modules[moduleIdx]

        # Gather modules and convert Cargo item to Module, silently return if not a module
        try:
            cargoP = Module(fit.cargo[cargoIdx].item)
            cargoP.owner = fit
            if cargoP.isValidState(State.ACTIVE):
                cargoP.state = State.ACTIVE
        except:
            return

        if cargoP.slot != module.slot: # can't swap modules to different racks
            return

        # remove module that we are trying to move cargo to
        fit.modules.remove(module)

        if not cargoP.fits(fit): #if cargo doesn't fit, rollback and return
            fit.modules.insert(moduleIdx, module)
            return

        fit.modules.insert(moduleIdx, cargoP)

        if not copy: # remove existing cargo if not cloning
             fit.cargo.remove(fit.cargo[cargoIdx])

        if not module.isEmpty: # if module is placeholder, we don't want to convert/add it
            moduleP = Cargo(module.item)
            moduleP.amount = 1
            fit.cargo.insert(cargoIdx, moduleP)

        eos.db.commit()
        self.recalc(fit)


    def swapModules(self, fitID, src, dst):
        fit = eos.db.getFit(fitID)
        # Gather modules
        srcMod = fit.modules[src]
        dstMod = fit.modules[dst]

        # To swap, we simply remove mod and insert at destination.
        fit.modules.remove(srcMod)
        fit.modules.insert(dst, srcMod)
        fit.modules.remove(dstMod)
        fit.modules.insert(src, dstMod)

        eos.db.commit()

    def cloneModule(self, fitID, src, dst):
        '''
        Clone a module from src to dst

        This will overwrite dst! Checking for empty module must be
        done at a higher level
        '''
        fit = eos.db.getFit(fitID)
        # Gather modules
        srcMod = fit.modules[src]
        dstMod = fit.modules[dst] # should be a placeholder module

        new = copy.deepcopy(srcMod)
        new.owner = fit
        if new.fits(fit):
            # insert copy if module meets hardpoint restrictions
            fit.modules.remove(dstMod)
            fit.modules.insert(dst, new)

            eos.db.commit()
            self.recalc(fit)

    def addCargo(self, fitID, itemID, amount=1, replace = False):
        '''Adds cargo via typeID of item. If replace = True, we replace amount with
        given parameter, otherwise we increment
        '''

        if fitID == None:
            return False

        fit = eos.db.getFit(fitID)
        item = eos.db.getItem(itemID)
        cargo = None

        # adding from market
        for x in fit.cargo.find(item):
            if x is not None:
                # found item already in cargo, use previous value and remove old
                cargo = x
                fit.cargo.remove(x)
                break

        if cargo is None:
            # if we don't have the item already in cargo, use default values
            cargo = eos.types.Cargo(item)

        fit.cargo.append(cargo)
        if replace:
            cargo.amount = amount
        else:
            cargo.amount += amount

        self.recalc(fit)
        eos.db.commit()

        return True

    def removeCargo(self, fitID, position):
        if fitID is None:
            return False

        fit = eos.db.getFit(fitID)
        charge = fit.cargo[position]
        fit.cargo.remove(charge)
        self.recalc(fit)
        return True

    def addDrone(self, fitID, itemID):
        if fitID == None:
            return False

        fit = eos.db.getFit(fitID)
        item = eos.db.getItem(itemID, eager=("attributes", "group.category"))
        if item.category.name == "Drone":
            drone = None
            for d in fit.drones.find(item):
                if d is not None and d.amountActive == 0 and d.amount < max(5, fit.extraAttributes["maxActiveDrones"]):
                    drone = d
                    break

            if drone is None:
                drone = eos.types.Drone(item)
                if drone.fits(fit) is True:
                    fit.drones.append(drone)
                else:
                    return False
            drone.amount += 1
            eos.db.commit()
            self.recalc(fit)
            return True
        else:
            return False

    def mergeDrones(self, fitID, d1, d2, projected=False):
        if fitID == None:
            return False

        fit = eos.db.getFit(fitID)
        if d1.item != d2.item:
            return False

        if projected:
            fit.projectedDrones.remove(d1)
        else:
            fit.drones.remove(d1)

        d2.amount += d1.amount
        d2.amountActive += d1.amountActive if d1.amountActive > 0 else -d2.amountActive
        eos.db.commit()
        self.recalc(fit)
        return True

    def splitDrones(self, fit, d, amount, l):
        total = d.amount
        active = d.amountActive > 0
        d.amount = amount
        d.amountActive = amount if active else 0

        newD = eos.types.Drone(d.item)
        newD.amount = total - amount
        newD.amountActive = newD.amount if active else 0
        l.append(newD)
        eos.db.commit()

    def splitProjectedDroneStack(self, fitID, d, amount):
        if fitID == None:
            return False

        fit = eos.db.getFit(fitID)
        self.splitDrones(fit, d, amount, fit.projectedDrones)

    def splitDroneStack(self, fitID, d, amount):
        if fitID == None:
            return False

        fit = eos.db.getFit(fitID)
        self.splitDrones(fit, d, amount, fit.drones)

    def removeDrone(self, fitID, i, numDronesToRemove=1):
        fit = eos.db.getFit(fitID)
        d = fit.drones[i]
        d.amount -= numDronesToRemove
        if d.amountActive > 0:
            d.amountActive -= numDronesToRemove

        if d.amount == 0:
            del fit.drones[i]

        eos.db.commit()
        self.recalc(fit)
        return True

    def toggleDrone(self, fitID, i):
        fit = eos.db.getFit(fitID)
        d = fit.drones[i]
        if d.amount == d.amountActive:
            d.amountActive = 0
        else:
            d.amountActive = d.amount

        eos.db.commit()
        self.recalc(fit)
        return True

    def toggleImplant(self, fitID, i):
        fit = eos.db.getFit(fitID)
        implant = fit.implants[i]
        implant.active = not implant.active

        eos.db.commit()
        self.recalc(fit)
        return True

    def toggleBooster(self, fitID, i):
        fit = eos.db.getFit(fitID)
        booster = fit.boosters[i]
        booster.active = not booster.active

        eos.db.commit()
        self.recalc(fit)
        return True

    def changeChar(self, fitID, charID):
        if fitID is None or charID is None:
            if charID is not None:
                self.character = Character.getInstance().all5()

            return

        fit = eos.db.getFit(fitID)
        fit.character = self.character = eos.db.getCharacter(charID)
        self.recalc(fit)

    def isAmmo(self, itemID):
        return eos.db.getItem(itemID).category.name == "Charge"

    def setAmmo(self, fitID, ammoID, modules):
        if fitID is None:
            return

        fit = eos.db.getFit(fitID)
        ammo = eos.db.getItem(ammoID) if ammoID else None

        for mod in modules:
            if mod.isValidCharge(ammo):
                mod.charge = ammo

        self.recalc(fit)

    def getDamagePattern(self, fitID):
        if fitID is None:
            return

        fit = eos.db.getFit(fitID)
        return fit.damagePattern

    def setDamagePattern(self, fitID, pattern):
        if fitID is None:
            return

        fit = eos.db.getFit(fitID)
        fit.damagePattern = self.pattern = pattern
        eos.db.commit()

        self.recalc(fit)

    def setAsPattern(self, fitID, ammo):
        if fitID is None:
            return

        sDP = DamagePattern.getInstance()
        dp = sDP.getDamagePattern("Selected Ammo")
        if dp is None:
            dp = eos.types.DamagePattern()
            dp.name = "Selected Ammo"

        fit = eos.db.getFit(fitID)
        for attr in ("em", "thermal", "kinetic", "explosive"):
            setattr(dp, "%sAmount" % attr, ammo.getAttribute("%sDamage" % attr))

        fit.damagePattern = dp
        self.recalc(fit)

    def exportFit(self, fitID):
        fit = eos.db.getFit(fitID)
        return fit.exportEft()

    def exportEftImps(self, fitID):
        fit = eos.db.getFit(fitID)
        return fit.exportEftImps()

    def exportDna(self, fitID):
        fit = eos.db.getFit(fitID)
        return fit.exportDna()

    def exportXml(self, *fitIDs):
        fits = map(lambda id: eos.db.getFit(id), fitIDs)
        return eos.types.Fit.exportXml(*fits)

    def backupFits(self, path, callback):
        thread = FitBackupThread(path, callback)
        thread.start()

    def importFitsThreaded(self, paths, callback):
        thread = FitImportThread(paths, callback)
        thread.start()

    def importFit(self, path):
        filename = os.path.split(path)[1]

        defcodepage = locale.getpreferredencoding()

        file = open(path, "r")
        srcString = file.read()
        # If file had ANSI encoding, convert it to unicode using system
        # default codepage, or use fallback cp1252 on any encoding errors
        if isinstance(srcString, str):
            try:
                srcString = unicode(srcString, defcodepage)
            except UnicodeDecodeError:
                srcString = unicode(srcString, "cp1252")

        type, fits = eos.types.Fit.importAuto(srcString, filename)
        for fit in fits:
            fit.character = self.character
            fit.damagePattern = self.pattern
        return fits

    def importFitFromBuffer(self, buffer, activeFit=None):
        type,fits = eos.types.Fit.importAuto(buffer, activeFit=activeFit)
        for fit in fits:
            fit.character = self.character
            fit.damagePattern = self.pattern
        return fits

    def saveImportedFits(self, fits):
        IDs = []
        for fit in fits:
            eos.db.save(fit)
            IDs.append(fit.ID)

        return IDs

    def checkStates(self, fit, base):
        changed = False
        for mod in fit.modules:
            if mod != base:
                if not mod.canHaveState(mod.state):
                    mod.state = State.ONLINE
                    changed = True
        for mod in fit.projectedModules:
            if not mod.canHaveState(mod.state, fit):
                mod.state = State.OFFLINE
                changed = True
        for drone in fit.projectedDrones:
            if drone.amountActive > 0 and not drone.canBeApplied(fit):
                drone.amountActive = 0
                changed = True
        return changed

    def toggleModulesState(self, fitID, base, modules, click):
        proposedState = self.__getProposedState(base, click)
        if proposedState != base.state:
            base.state = proposedState
            for mod in modules:
                if mod != base:
                    mod.state = self.__getProposedState(mod, click, proposedState)

        eos.db.commit()
        fit = eos.db.getFit(fitID)

        # As some items may affect state-limiting attributes of the ship, calculate new attributes first
        self.recalc(fit)
        # Then, check states of all modules and change where needed
        changed = self.checkStates(fit, base)
        # If any state was changed, recalulate attributes again
        if changed is True:
            self.recalc(fit)

    # Old state : New State
    localMap = {State.OVERHEATED: State.ACTIVE,
                State.ACTIVE: State.ONLINE,
                State.OFFLINE: State.ONLINE,
                State.ONLINE: State.ACTIVE}
    projectedMap = {State.OVERHEATED: State.ACTIVE,
                    State.ACTIVE: State.OFFLINE,
                    State.OFFLINE: State.ACTIVE,
                    State.ONLINE: State.ACTIVE} # Just in case

    def __getProposedState(self, mod, click, proposedState=None):
        if mod.slot in (Slot.RIG, Slot.SUBSYSTEM) or mod.isEmpty:
            return State.ONLINE

        currState = state = mod.state
        transitionMap = self.projectedMap if mod.projected else self.localMap
        if proposedState is not None:
            state = proposedState
        elif click == "right":
            state = State.OVERHEATED
        elif click == "ctrl":
            state = State.OFFLINE
        else:
            state = transitionMap[currState]
            if not mod.isValidState(state):
                state =- 1

        if mod.isValidState(state):
            return state
        else:
            return currState

    def refreshFit(self, fitID):
        if fitID is None:
            return None

        fit = eos.db.getFit(fitID)
        eos.db.commit()
        self.recalc(fit)

    def recalc(self, fit, withBoosters=False):
        if fit.factorReload is not self.serviceFittingOptions["useGlobalForceReload"]:
            fit.factorReload = self.serviceFittingOptions["useGlobalForceReload"]
        fit.clear()
        fit.calculateModifiedAttributes(withBoosters=withBoosters, dirtyStorage=self.dirtyFitIDs)

########NEW FILE########
__FILENAME__ = fleet
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import eos.db
from eos.types import Fleet as Fleet_, Wing, Squad
import copy

class Fleet(object):
    instance = None
    @classmethod
    def getInstance(cls):
        if cls.instance is None:
            cls.instance = Fleet()

        return cls.instance

    def __init__(self):
        pass

    def getFleetList(self):
        fleetList = []
        fleets = eos.db.getFleetList()
        for fleet in fleets:
            fleetList.append((fleet.ID, fleet.name, fleet.count()))

        return fleetList

    def getFleetByID(self, ID):
        f = eos.db.getFleet(ID)
        return f

    def addFleet(self):
        f = Fleet_()
        eos.db.save(f)
        return f

    def renameFleet(self, fleet, newName):
        fleet.name = newName
        eos.db.commit()

    def copyFleet(self, fleet):
        newFleet = copy.deepcopy(fleet)
        eos.db.save(newFleet)
        return newFleet

    def copyFleetByID(self, ID):
        fleet = self.getFleetByID(ID)
        return self.copyFleet(fleet)

    def deleteFleet(self, fleet):
        eos.db.remove(fleet)

    def deleteFleetByID(self, ID):
        fleet = self.getFleetByID(ID)
        self.deleteFleet(fleet)

    def makeLinearFleet(self, fit):
        f = Fleet_()
        w = Wing()
        f.wings.append(w)
        s = Squad()
        w.squads.append(s)
        s.members.append(fit)
        fit.fleet = f
        eos.db.save(f)

    def setLinearFleetCom(self, boostee, booster):
        #if boostee == booster:
        #    return
        if self.getLinearFleet(boostee) is None:
            self.removeAssociatedFleetData(boostee)
            self.makeLinearFleet(boostee)
        squadIDs = set(eos.db.getSquadsIDsWithFitID(boostee.ID))
        squad = eos.db.getSquad(squadIDs.pop())
        if squad.wing.gang.leader is not None and booster is None:
            try:
                squad.wing.gang.leader.boostsFits.remove(boostee.ID)
            except KeyError:
                pass
        squad.wing.gang.leader = booster
        if self.anyBoosters(squad) is False:
            self.removeAssociatedFleetData(boostee)
        from service.fit import Fit
        sFit = Fit.getInstance()
        sFit.recalc(boostee, withBoosters=True)

    def setLinearWingCom(self, boostee, booster):
        #if boostee == booster:
        #    return
        if self.getLinearFleet(boostee) is None:
            self.removeAssociatedFleetData(boostee)
            self.makeLinearFleet(boostee)
        squadIDs = set(eos.db.getSquadsIDsWithFitID(boostee.ID))
        squad = eos.db.getSquad(squadIDs.pop())
        if squad.wing.leader is not None and booster is None:
            try:
                squad.wing.leader.boostsFits.remove(boostee.ID)
            except KeyError:
                pass
        squad.wing.leader = booster
        if self.anyBoosters(squad) is False:
            self.removeAssociatedFleetData(boostee)
        from service.fit import Fit
        sFit = Fit.getInstance()
        sFit.recalc(boostee, withBoosters=True)

    def setLinearSquadCom(self, boostee, booster):
        #if boostee == booster:
        #    return
        if self.getLinearFleet(boostee) is None:
            self.removeAssociatedFleetData(boostee)
            self.makeLinearFleet(boostee)
        squadIDs = set(eos.db.getSquadsIDsWithFitID(boostee.ID))
        squad = eos.db.getSquad(squadIDs.pop())
        if squad.leader is not None and booster is None:
            try:
                squad.leader.boostsFits.remove(boostee.ID)
            except KeyError:
                pass
        squad.leader = booster
        if self.anyBoosters(squad) is False:
            self.removeAssociatedFleetData(boostee)
        from service.fit import Fit
        sFit = Fit.getInstance()
        sFit.recalc(boostee, withBoosters=True)


    def getLinearFleet(self, fit):
        sqIDs = eos.db.getSquadsIDsWithFitID(fit.ID)
        if len(sqIDs) != 1:
            return None
        s = eos.db.getSquad(sqIDs[0])
        if len(s.members) != 1:
            return None
        w = s.wing
        if len(w.squads) != 1:
            return None
        f = w.gang
        if len(f.wings) != 1:
            return None
        return f

    def removeAssociatedFleetData(self, fit):
        squadIDs = set(eos.db.getSquadsIDsWithFitID(fit.ID))
        if len(squadIDs) == 0:
            return
        squads = list(eos.db.getSquad(sqID) for sqID in squadIDs)
        wingIDs = set(squad.wing.ID for squad in squads)
        fleetIDs = set(squad.wing.gang.ID for squad in squads)
        for fleetID in fleetIDs:
            fleet = eos.db.getFleet(fleetID)
            for wing in fleet.wings:
                wingIDs.add(wing.ID)
        for wingID in wingIDs:
            wing = eos.db.getWing(wingID)
            for squad in wing.squads:
                squadIDs.add(squad.ID)
        for squadID in squadIDs:
            squad = eos.db.getSquad(squadID)
            if squad.leader is not None:
                try:
                    squad.leader.boostsFits.remove(fit.ID)
                except KeyError:
                    pass
            eos.db.remove(squad)
        for wingID in wingIDs:
            wing = eos.db.getWing(wingID)
            if wing.leader is not None:
                try:
                    wing.leader.boostsFits.remove(fit.ID)
                except KeyError:
                    pass
            eos.db.remove(wing)
        for fleetID in fleetIDs:
            fleet = eos.db.getFleet(fleetID)
            if fleet.leader is not None:
                try:
                    fleet.leader.boostsFits.remove(fit.ID)
                except KeyError:
                    pass
            eos.db.remove(fleet)
        fit.fleet = None
        return

    def anyBoosters(self, squad):
        wing = squad.wing
        fleet = wing.gang
        if squad.leader is None and wing.leader is None and fleet.leader is None:
            return False
        return True

    def loadLinearFleet(self, fit):
        if self.getLinearFleet(fit) is None:
            return None
        squadID = eos.db.getSquadsIDsWithFitID(fit.ID)[0]
        s = eos.db.getSquad(squadID)
        w = s.wing
        f = w.gang
        return (f.leader, w.leader, s.leader)

########NEW FILE########
__FILENAME__ = market
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import re
import threading
import wx

import Queue

import eos.db
import eos.types

from service.settings import SettingsProvider, ProxySettings

try:
    from collections import OrderedDict
except ImportError:
    from gui.utils.compat import OrderedDict

# Event which tells threads dependent on Market that it's initialized
mktRdy = threading.Event()

class ShipBrowserWorkerThread(threading.Thread):
    def run(self):
        self.queue = Queue.Queue()
        self.cache = {}
        # Wait for full market initialization (otherwise there's high risky
        # this thread will attempt to init Market which is already being inited)
        mktRdy.wait(5)
        self.processRequests()

    def processRequests(self):
        queue = self.queue
        cache = self.cache
        sMarket = Market.getInstance()
        while True:
            try:
                id, callback = queue.get()
                set = cache.get(id)
                if set is None:
                    set = sMarket.getShipList(id)
                    cache[id] = set

                wx.CallAfter(callback, (id, set))
            except:
                pass
            finally:
                try:
                    queue.task_done()
                except:
                    pass

class PriceWorkerThread(threading.Thread):
    def run(self):
        self.queue = Queue.Queue()
        self.processUpdates()

    def processUpdates(self):
        queue = self.queue
        while True:
            # Grab our data
            callback, requests = queue.get()

            # Grab prices, this is the time-consuming part
            if len(requests) > 0:
                proxy = ProxySettings.getInstance().getProxySettings()
                if proxy is not None:
                    proxy = "{0}:{1}".format(*proxy)
                eos.types.Price.fetchPrices(requests, proxy=proxy)

            wx.CallAfter(callback)
            queue.task_done()

    def trigger(self, prices, callbacks):
        self.queue.put((callbacks, prices))

class SearchWorkerThread(threading.Thread):
    def run(self):
        self.cv = threading.Condition()
        self.searchRequest = None
        self.processSearches()

    def processSearches(self):
        cv = self.cv

        while True:
            cv.acquire()
            while self.searchRequest is None:
                cv.wait()

            request, callback = self.searchRequest
            self.searchRequest = None
            cv.release()
            sMarket = Market.getInstance()
            # Rely on category data provided by eos as we don't hardcode them much in service
            filter = eos.types.Category.name.in_(sMarket.SEARCH_CATEGORIES)
            results = eos.db.searchItems(request, where=filter,
                                         join=(eos.types.Item.group, eos.types.Group.category),
                                         eager=("icon", "group.category", "metaGroup", "metaGroup.parent"))

            items = set()
            # Return only published items, consult with Market service this time
            for item in results:
                if sMarket.getPublicityByItem(item):
                    items.add(item)
            wx.CallAfter(callback, items)

    def scheduleSearch(self, text, callback):
        self.cv.acquire()
        self.searchRequest = (text, callback)
        self.cv.notify()
        self.cv.release()

class Market():
    instance = None
    def __init__(self):
        self.priceCache = {}

        #Init recently used module storage
        serviceMarketRecentlyUsedModules = {"pyfaMarketRecentlyUsedModules": []}

        self.serviceMarketRecentlyUsedModules = SettingsProvider.getInstance().getSettings("pyfaMarketRecentlyUsedModules", serviceMarketRecentlyUsedModules)

        # Start price fetcher
        self.priceWorkerThread = PriceWorkerThread()
        self.priceWorkerThread.daemon = True
        self.priceWorkerThread.start()

        # Thread which handles search
        self.searchWorkerThread = SearchWorkerThread()
        self.searchWorkerThread.daemon = True
        self.searchWorkerThread.start()

        # Ship browser helper thread
        self.shipBrowserWorkerThread = ShipBrowserWorkerThread()
        self.shipBrowserWorkerThread.daemon = True
        self.shipBrowserWorkerThread.start()

        # Items' group overrides
        self.customGroups = set()
        # Limited edition ships
        self.les_grp = eos.types.Group()
        self.les_grp.ID = -1
        self.les_grp.name = "Limited Issue Ships"
        self.les_grp.published = True
        ships = self.getCategory("Ship")
        self.les_grp.category = ships
        self.les_grp.categoryID = ships.ID
        self.les_grp.description = ""
        self.les_grp.icon = None
        self.ITEMS_FORCEGROUP = {
            "Opux Luxury Yacht": self.les_grp, # One of those is wedding present at CCP fanfest, another was hijacked from ISD guy during an event
            "Silver Magnate": self.les_grp,  # Amarr Championship prize
            "Gold Magnate": self.les_grp,  # Amarr Championship prize
            "Armageddon Imperial Issue": self.les_grp,  # Amarr Championship prize
            "Apocalypse Imperial Issue": self.les_grp, # Amarr Championship prize
            "Guardian-Vexor": self.les_grp, # Illegal rewards for the Gallente Frontier Tour Lines event arc
            "Megathron Federate Issue": self.les_grp, # Reward during Crielere event
            "Raven State Issue": self.les_grp,  # AT4 prize
            "Tempest Tribal Issue": self.les_grp, # AT4 prize
            "Apotheosis": self.les_grp, # 5th EVE anniversary present
            "Zephyr": self.les_grp, # 2010 new year gift
            "Primae": self.les_grp, # Promotion of planetary interaction
            "Freki": self.les_grp, # AT7 prize
            "Mimir": self.les_grp, # AT7 prize
            "Utu": self.les_grp, # AT8 prize
            "Adrestia": self.les_grp, # AT8 prize
            "Echelon": self.les_grp, # 2011 new year gift
            "Malice": self.les_grp, # AT9 prize
            "Vangel": self.les_grp, # AT9 prize
            "Cambion": self.les_grp, # AT10 prize
            "Etana": self.les_grp, # AT10 prize
            "Chremoas": self.les_grp, # AT11 prize :(
            "Moracha": self.les_grp, # AT11 prize
            "Interbus Shuttle": self.les_grp,
            "Leopard": self.les_grp,
            "Stratios Emergency Responder": self.les_grp }
        self.ITEMS_FORCEGROUP_R = self.__makeRevDict(self.ITEMS_FORCEGROUP)
        self.les_grp.addItems = list(self.getItem(itmn) for itmn in self.ITEMS_FORCEGROUP_R[self.les_grp])
        self.customGroups.add(self.les_grp)

        # List of items which are forcibly published or hidden
        self.ITEMS_FORCEPUBLISHED = {
            "Data Subverter I": False, # Not used in EVE, probably will appear with Dust link
            "Ghost Heavy Missile": False, # Missile used by Sansha
            "QA Cross Protocol Analyzer": False, # QA modules used by CCP internally
            "QA Damage Module": False,
            "QA ECCM": False,
            "QA Immunity Module": False,
            "QA Multiship Module - 10 Players": False,
            "QA Multiship Module - 20 Players": False,
            "QA Multiship Module - 40 Players": False,
            "QA Multiship Module - 5 Players": False,
            "QA Remote Armor Repair System - 5 Players": False,
            "QA Shield Transporter - 5 Players": False,
            "Aliastra Catalyst": False, # Vanity
            "Inner Zone Shipping Catalyst": False, # Vanity
            "Intaki Syndicate Catalyst": False, # Vanity
            "InterBus Catalyst": False, # Vanity
            "Quafe Catalyst": False, # Vanity
            "Nefantar Thrasher": False, # Vanity
            "Sarum Magnate": False, # Vanity
            "Sukuuvestaa Heron": False, # Vanity
            "Inner Zone Shipping Imicus": False, # Vanity
            "Vherokior Probe": False, # Vanity
            "Miasmos Quafe Ultra Edition": False, # Vanity
            "Miasmos Quafe Ultramarine Edition": False, # Vanity
            "Miasmos Amastris Edition": False, # Vanity
            "Goru's Shuttle": False, # Vanity
            "Guristas Shuttle": False, # Vanity
            "Tash-Murkon Magnate": False, # Vanity
            "Scorpion Ishukone Watch": False, # Vanity
            "Incursus Aliastra Edition": False, # Vanity
            "Merlin Nugoeihuvi Edition": False, # Vanity
            "Police Pursuit Comet": False, # Vanity
            "Punisher Kador Edition": False, # Vanity
            "Rifter Krusual Edition": False, # Vanity
            "Abaddon Kador Edition": False, # Vanity
            "Hyperion Aliastra Edition": False, # Vanity
            "Maelstrom Krusual Edition": False, # Vanity
            "Rokh Nugoeihuvi Edition": False, # Vanity
            "Mammoth Nefantar Edition": False } # Vanity

        # List of groups which are forcibly published
        self.GROUPS_FORCEPUBLISHED = {
            "Prototype Exploration Ship": False } # We moved the only ship from this group to other group anyway

        # Dictionary of items with forced meta groups, uses following format:
        # Item name: (metagroup name, parent type name)
        self.ITEMS_FORCEDMETAGROUP = {
            "'Habitat' Miner I": ("Storyline", "Miner I"),
            "'Wild' Miner I": ("Storyline", "Miner I"),
            "Medium Nano Armor Repair Unit I": ("Tech I", "Medium Armor Repairer I"),
            "Large 'Reprieve' Vestment Reconstructer I": ("Storyline", "Large Armor Repairer I"),
            "Khanid Navy Torpedo Launcher": ("Faction", "Torpedo Launcher I"),
            "Dark Blood Tracking Disruptor": ("Faction", "Tracking Disruptor I"),
            "True Sansha Tracking Disruptor": ("Faction", "Tracking Disruptor I"),
            "Shadow Serpentis Remote Sensor Dampener": ("Faction", "Remote Sensor Dampener I") }
        # Parent type name: set(item names)
        self.ITEMS_FORCEDMETAGROUP_R = {}
        for item, value in self.ITEMS_FORCEDMETAGROUP.items():
            parent = value[1]
            if not parent in self.ITEMS_FORCEDMETAGROUP_R:
                self.ITEMS_FORCEDMETAGROUP_R[parent] = set()
            self.ITEMS_FORCEDMETAGROUP_R[parent].add(item)
        # Dictionary of items with forced market group (service assumes they have no
        # market group assigned in db, otherwise they'll appear in both original and forced groups)
        self.ITEMS_FORCEDMARKETGROUP = {
            "'Alpha' Data Analyzer I": 714, # Ship Equipment > Electronics and Sensor Upgrades > Scanners > Data and Composition Scanners
            "'Codex' Data Analyzer I": 714, # Ship Equipment > Electronics and Sensor Upgrades > Scanners > Data and Composition Scanners
            "'Daemon' Data Analyzer I": 714, # Ship Equipment > Electronics and Sensor Upgrades > Scanners > Data and Composition Scanners
            "'Libram' Data Analyzer I": 714, # Ship Equipment > Electronics and Sensor Upgrades > Scanners > Data and Composition Scanners
            "Advanced Cerebral Accelerator": 977, # Implants & Boosters > Booster
            "Civilian Damage Control": 760, # Ship Equipment > Civilian Modules
            "Civilian EM Ward Field": 760, # Ship Equipment > Civilian Modules
            "Civilian Explosive Deflection Field": 760, # Ship Equipment > Civilian Modules
            "Civilian Hobgoblin": 837, # Drones > Combat Drones > Light Scout Drones
            "Civilian Kinetic Deflection Field": 760, # Ship Equipment > Civilian Modules
            "Civilian Light Missile Launcher": 760, # Ship Equipment > Civilian Modules
            "Civilian Scourge Light Missile": 920, # Ammunition & Charges > Missiles > Light Missiles > Standard Light Missiles
            "Civilian Small Remote Armor Repairer": 760, # Ship Equipment > Civilian Modules
            "Civilian Small Remote Shield Booster": 760, # Ship Equipment > Civilian Modules
            "Civilian Stasis Webifier": 760, # Ship Equipment > Civilian Modules
            "Civilian Thermic Dissipation Field": 760, # Ship Equipment > Civilian Modules
            "Civilian Warp Disruptor": 760, # Ship Equipment > Civilian Modules
            "Hardwiring - Zainou 'Sharpshooter' ZMX10": 1493, # Implants & Boosters > Implants > Skill Hardwiring > Missile Implants > Implant Slot 06
            "Hardwiring - Zainou 'Sharpshooter' ZMX100": 1493, # Implants & Boosters > Implants > Skill Hardwiring > Missile Implants > Implant Slot 06
            "Hardwiring - Zainou 'Sharpshooter' ZMX1000": 1493, # Implants & Boosters > Implants > Skill Hardwiring > Missile Implants > Implant Slot 06
            "Hardwiring - Zainou 'Sharpshooter' ZMX11": 1493, # Implants & Boosters > Implants > Skill Hardwiring > Missile Implants > Implant Slot 06
            "Hardwiring - Zainou 'Sharpshooter' ZMX110": 1493, # Implants & Boosters > Implants > Skill Hardwiring > Missile Implants > Implant Slot 06
            "Hardwiring - Zainou 'Sharpshooter' ZMX1100": 1493, # Implants & Boosters > Implants > Skill Hardwiring > Missile Implants > Implant Slot 06
            "Nugoehuvi Synth Blue Pill Booster": 977, # Implants & Boosters > Booster
            "Prototype Cerebral Accelerator": 977, # Implants & Boosters > Booster
            "Prototype Iris Probe Launcher": 712, # Ship Equipment > Turrets & Bays > Scan Probe Launchers
            "Shadow": 1310, # Drones > Combat Drones > Fighter Bombers
            "Sleeper Data Analyzer I": 714, # Ship Equipment > Electronics and Sensor Upgrades > Scanners > Data and Composition Scanners
            "Standard Cerebral Accelerator": 977, # Implants & Boosters > Booster
            "Talocan Data Analyzer I": 714, # Ship Equipment > Electronics and Sensor Upgrades > Scanners > Data and Composition Scanners
            "Terran Data Analyzer I": 714, # Ship Equipment > Electronics and Sensor Upgrades > Scanners > Data and Composition Scanners
            "Tetrimon Data Analyzer I": 714 } # Ship Equipment > Electronics and Sensor Upgrades > Scanners > Data and Composition Scanners

        self.ITEMS_FORCEDMARKETGROUP_R = self.__makeRevDict(self.ITEMS_FORCEDMARKETGROUP)

        # Misc definitions
        # 0 is for items w/o meta group
        self.META_MAP = OrderedDict([("normal",  frozenset((0, 1, 2, 14))),
                                     ("faction", frozenset((4, 3))),
                                     ("complex", frozenset((6,))),
                                     ("officer", frozenset((5,)))])
        self.SEARCH_CATEGORIES = ("Drone", "Module", "Subsystem", "Charge", "Implant")
        self.ROOT_MARKET_GROUPS = (9,     # Modules
                                   1111,  # Rigs
                                   157,   # Drones
                                   11,    # Ammo
                                   1112,  # Subsystems
                                   24)    # Implants & Boosters
        # Tell other threads that Market is at their service
        mktRdy.set()

    @classmethod
    def getInstance(cls):
        if cls.instance == None:
            cls.instance = Market()
        return cls.instance

    def __makeRevDict(self, orig):
        """Creates reverse dictionary"""
        rev = {}
        for item, value in orig.items():
            if not value in rev:
                rev[value] = set()
            rev[value].add(item)
        return rev

    def getItem(self, identity, *args, **kwargs):
        """Get item by its ID or name"""
        if isinstance(identity, eos.types.Item):
            item = identity
        elif isinstance(identity, (int, basestring)):
            item = eos.db.getItem(identity, *args, **kwargs)
        elif isinstance(identity, float):
            id = int(identity)
            item = eos.db.getItem(id, *args, **kwargs)
        else:
            raise TypeError("Need Item object, integer, float or string as argument")
        return item

    def getGroup(self, identity, *args, **kwargs):
        """Get group by its ID or name"""
        if isinstance(identity, eos.types.Group):
            return identity
        elif isinstance(identity, (int, float, basestring)):
            if isinstance(identity, float):
                identity = int(identity)
            # Check custom groups
            for cgrp in self.customGroups:
                # During first comparison we need exact int, not float for matching
                if cgrp.ID == identity or cgrp.name == identity:
                    # Return first match
                    return cgrp
            # Return eos group if everything else returned nothing
            return eos.db.getGroup(identity, *args, **kwargs)
        else:
            raise TypeError("Need Group object, integer, float or string as argument")

    def getCategory(self, identity, *args, **kwargs):
        """Get category by its ID or name"""
        if isinstance(identity, eos.types.Category):
            category = identity
        elif isinstance(identity, (int, basestring)):
            category = eos.db.getCategory(identity, *args, **kwargs)
        elif isinstance(identity, float):
            id = int(identity)
            category = eos.db.getCategory(id, *args, **kwargs)
        else:
            raise TypeError("Need Category object, integer, float or string as argument")
        return category

    def getMetaGroup(self, identity, *args, **kwargs):
        """Get meta group by its ID or name"""
        if isinstance(identity, eos.types.MetaGroup):
            metaGroup = identity
        elif isinstance(identity, (int, basestring)):
            metaGroup = eos.db.getMetaGroup(identity, *args, **kwargs)
        elif isinstance(identity, float):
            id = int(identity)
            metaGroup = eos.db.getMetaGroup(id, *args, **kwargs)
        else:
            raise TypeError("Need MetaGroup object, integer, float or string as argument")
        return metaGroup

    def getMarketGroup(self, identity, *args, **kwargs):
        """Get market group by its ID"""
        if isinstance(identity, eos.types.MarketGroup):
            marketGroup = identity
        elif isinstance(identity, (int, float)):
            id = int(identity)
            marketGroup = eos.db.getMarketGroup(id, *args, **kwargs)
        else:
            raise TypeError("Need MarketGroup object, integer or float as argument")
        return marketGroup

    def getGroupByItem(self, item):
        """Get group by item"""
        if item.name in self.ITEMS_FORCEGROUP:
            group = self.ITEMS_FORCEGROUP[item.name]
        else:
            group = item.group
        return group

    def getCategoryByItem(self, item):
        """Get category by item"""
        grp = self.getGroupByItem(item)
        cat = grp.category
        return cat

    def getMetaGroupByItem(self, item):
        """Get meta group by item"""
        # Check if item is in forced metagroup map
        if item.name in self.ITEMS_FORCEDMETAGROUP:
            # Create meta group from scratch
            metaGroup = eos.types.MetaType()
            # Get meta group info object based on meta group name
            metaGroupInfo = self.getMetaGroup(self.ITEMS_FORCEDMETAGROUP[item.name][0])
            # Get parent item based on its name
            parent = self.getItem(self.ITEMS_FORCEDMETAGROUP[item.name][1])
            # Assign all required for metaGroup variables
            metaGroup.info = metaGroupInfo
            metaGroup.items = item
            metaGroup.parent = parent
            metaGroup.metaGroupID = metaGroupInfo.ID
            metaGroup.parentTypeID = parent.ID
            metaGroup.typeID = item.ID
        # If no forced meta group is provided, try to use item's
        # meta group if any
        else:
            metaGroup = item.metaGroup
        return metaGroup

    def getMetaGroupIdByItem(self, item, fallback=0):
        """Get meta group ID by item"""
        id = getattr(self.getMetaGroupByItem(item), "ID", fallback)
        return id

    def getMarketGroupByItem(self, item, parentcheck=True):
        """Get market group by item, its ID or name"""
        # Check if we force market group for given item
        if item.name in self.ITEMS_FORCEDMARKETGROUP:
            mgid = self.ITEMS_FORCEDMARKETGROUP[item.name]
            return self.getMarketGroup(mgid)
        # Check if item itself has market group
        elif item.marketGroupID:
            return item.marketGroup
        elif parentcheck:
            # If item doesn't have marketgroup, check if it has parent
            # item and use its market group
            parent = self.getParentItemByItem(item, selfparent=False)
            if parent:
                return parent.marketGroup
            else:
                return None
        else:
            return None

    def getParentItemByItem(self, item, selfparent=True):
        """Get parent item by item"""
        mg = self.getMetaGroupByItem(item)
        if mg:
            parent = mg.parent
        # Consider self as parent if item has no parent in database
        elif selfparent is True:
            parent = item
        else:
            parent = None
        return parent

    def getVariationsByItems(self, items, alreadyparent=False):
        """Get item variations by item, its ID or name"""
        # Set for IDs of parent items
        parents = set()
        # Set-container for variables
        variations = set()
        for item in items:
            # Get parent item
            if alreadyparent is False:
                parent = self.getParentItemByItem(item)
            else:
                parent = item
            # Combine both in the same set
            parents.add(parent)
            # Check for overrides and add them if any
            if parent.name in self.ITEMS_FORCEDMETAGROUP_R:
                for itmn in self.ITEMS_FORCEDMETAGROUP_R[parent.name]:
                    variations.add(self.getItem(itmn))
        # Add all parents to variations set
        variations.update(parents)
        # Add all variations of parents to the set
        parentids = tuple(item.ID for item in parents)
        variations.update(eos.db.getVariations(parentids))
        return variations

    def getGroupsByCategory(self, cat):
        """Get groups from given category"""
        groups = set(filter(lambda grp: self.getPublicityByGroup(grp), cat.groups))
        return groups

    def getMarketGroupChildren(self, mg):
        """Get the children marketGroups of marketGroup."""
        children = set()
        for child in mg.children:
            children.add(child)
        return children

    def getItemsByGroup(self, group):
        """Get items assigned to group"""
        # Return only public items; also, filter out items
        # which were forcibly set to other groups
        groupItems = set(group.items)
        if hasattr(group, 'addItems'):
            groupItems.update(group.addItems)
        items = set(filter(lambda item: self.getPublicityByItem(item) and self.getGroupByItem(item) == group, groupItems))
        return items

    def getItemsByMarketGroup(self, mg, vars=True):
        """Get items in the given market group"""
        result = set()
        # Get items from eos market group
        baseitms = set(mg.items)
        # Add hardcoded items to set
        if mg.ID in self.ITEMS_FORCEDMARKETGROUP_R:
            forceditms = set(self.getItem(itmn) for itmn in self.ITEMS_FORCEDMARKETGROUP_R[mg.ID])
            baseitms.update(forceditms)
        if vars:
            parents = set()
            for item in baseitms:
                # Add one of the base market group items to result
                result.add(item)
                parent = self.getParentItemByItem(item, selfparent=False)
                # If item has no parent, it's base item (or at least should be)
                if parent is None:
                    parents.add(item)
            # Fetch variations only for parent items
            variations = self.getVariationsByItems(parents, alreadyparent=True)
            for variation in variations:
                # Exclude items with their own explicitly defined market groups
                if self.getMarketGroupByItem(variation, parentcheck=False) is None:
                    result.add(variation)
        else:
            result = baseitms
        # Get rid of unpublished items
        result = set(filter(lambda item: self.getPublicityByItem(item), result))
        return result

    def marketGroupHasTypesCheck(self, mg):
        """If market group has any items, return true"""
        if mg and mg.ID in self.ITEMS_FORCEDMARKETGROUP_R:
            return True
        elif len(mg.items) > 0:
            return True
        else:
            return False

    def marketGroupValidityCheck(self, mg):
        """Check market group validity"""
        # The only known case when group can be invalid is
        # when it's declared to have types, but it doesn't contain anything
        if mg.hasTypes and not self.marketGroupHasTypesCheck(mg):
            return False
        else:
            return True

    def getIconByMarketGroup(self, mg):
        """Return icon associated to marketgroup"""
        if mg.icon:
            return mg.icon.iconFile
        else:
            while mg and not mg.hasTypes:
                mg = mg.parent
            if not mg:
                return ""
            elif self.marketGroupHasTypesCheck(mg):
                # Do not request variations to make process faster
                # Pick random item and use its icon
                items = self.getItemsByMarketGroup(mg, vars=False)
                try:
                    item = items.pop()
                except KeyError:
                    return ""

                return item.icon.iconFile if item.icon else ""
            elif self.getMarketGroupChildren(mg) > 0:
                kids = self.getMarketGroupChildren(mg)
                mktGroups = self.getIconByMarketGroup(kids)
                size = len(mktGroups)
                return mktGroups.pop() if size > 0 else ""
            else:
                return ""

    def getPublicityByItem(self, item):
        """Return if an item is published"""
        if item.name in self.ITEMS_FORCEPUBLISHED:
            pub = self.ITEMS_FORCEPUBLISHED[item.name]
        else:
            pub = item.published
        return pub

    def getPublicityByGroup(self, group):
        """Return if an group is published"""
        if group.name in self.GROUPS_FORCEPUBLISHED:
            pub = self.GROUPS_FORCEPUBLISHED[group.name]
        else:
            pub = group.published
        return pub

    def getMarketRoot(self):
        """
        Get the root of the market tree.
        Returns a list, where each element is a tuple containing:
        the ID, the name and the icon of the group
        """
        root = set()
        for id in self.ROOT_MARKET_GROUPS:
            mg = self.getMarketGroup(id, eager="icon")
            root.add(mg)

        return root

    def getShipRoot(self):
        cat = self.getCategory("Ship")
        root = set(self.getGroupsByCategory(cat))
        return root

    def getShipList(self, grpid):
        """Get ships for given group id"""
        grp = self.getGroup(grpid, eager=("items", "items.group", "items.marketGroup"))
        ships = self.getItemsByGroup(grp)
        for ship in ships:
            ship.race
        return ships

    def getShipListDelayed(self, id, callback):
        """Background version of getShipList"""
        self.shipBrowserWorkerThread.queue.put((id, callback))

    def searchShips(self, name):
        """Find ships according to given text pattern"""
        filter = eos.types.Category.name.in_(["Ship"])
        results = eos.db.searchItems(name, where=filter,
                                     join=(eos.types.Item.group, eos.types.Group.category),
                                     eager=("icon", "group.category", "metaGroup", "metaGroup.parent"))
        ships = set()
        for item in results:
            if self.getPublicityByItem(item):
                ships.add(item)
        return ships

    def searchItems(self, name, callback):
        """Find items according to given text pattern"""
        self.searchWorkerThread.scheduleSearch(name, callback)

    def directAttrRequest(self, items, attribs):
        try:
            itemIDs = tuple(map(lambda i: i.ID, items))
        except TypeError:
            itemIDs = (items.ID,)
        try:
            attrIDs = tuple(map(lambda i: i.ID, attribs))
        except TypeError:
            attrIDs = (attribs.ID,)
        info = {}
        for itemID, typeID, val in eos.db.directAttributeRequest(itemIDs, attrIDs):
            info[itemID] = val

        return info

    def getImplantTree(self):
        """Return implant market group children"""
        img = self.getMarketGroup(27)
        return self.getMarketGroupChildren(img)

    def filterItemsByMeta(self, items, metas):
        """Filter items by meta lvl"""
        filtered = set(filter(lambda item: self.getMetaGroupIdByItem(item) in metas, items))
        return filtered

    def getPriceNow(self, typeID):
        """Get price for provided typeID"""
        price = self.priceCache.get(typeID)
        if price is None:
            price = eos.db.getPrice(typeID)
            if price is None:
                price = eos.types.Price(typeID)
                eos.db.add(price)

            self.priceCache[typeID] = price

        return price

    def getPricesNow(self, typeIDs):
        """Return map of calls to get price against list of typeIDs"""
        return map(self.getPrice, typeIDs)

    def getPrices(self, typeIDs, callback):
        """Get prices for multiple typeIDs"""
        requests = []
        for typeID in typeIDs:
            price = self.getPriceNow(typeID)
            requests.append(price)

        def cb():
            try:
                callback(requests)
            except:
                pass
            eos.db.commit()

        self.priceWorkerThread.trigger(requests, cb)

    def getSystemWideEffects(self):
        """
        Get dictionary with system-wide effects
        """
        # Container for system-wide effects
        effects = {}
        # Expressions for matching when detecting effects we're looking for
        validgroups = ("Black Hole Effect Beacon",
                       "Cataclysmic Variable Effect Beacon",
                       "Magnetar Effect Beacon",
                       "Pulsar Effect Beacon",
                       "Red Giant Beacon",
                       "Wolf Rayet Effect Beacon",
                       "Incursion ship attributes effects")
        # Stuff we don't want to see in names
        garbages = ("Effect", "Beacon", "ship attributes effects")
        # Get group with all the system-wide beacons
        grp = self.getGroup("Effect Beacon")
        beacons = self.getItemsByGroup(grp)
        # Cycle through them
        for beacon in beacons:
            # Check if it belongs to any valid group
            for group in validgroups:
                # Check beginning of the name only
                if re.match(group, beacon.name):
                    # Get full beacon name
                    beaconname = beacon.name
                    for garbage in garbages:
                        beaconname = re.sub(garbage, "", beaconname)
                    beaconname = re.sub(" {2,}", " ", beaconname).strip()
                    # Get short name
                    shortname = re.sub(group, "", beacon.name)
                    for garbage in garbages:
                        shortname = re.sub(garbage, "", shortname)
                    shortname = re.sub(" {2,}", " ", shortname).strip()
                    # Get group name
                    groupname = group
                    for garbage in garbages:
                        groupname = re.sub(garbage, "", groupname)
                    groupname = re.sub(" {2,}", " ", groupname).strip()
                    # Add stuff to dictionary
                    if not groupname in effects:
                        effects[groupname] = set()
                    effects[groupname].add((beacon, beaconname, shortname))
                    # Break loop on 1st result
                    break
        return effects

########NEW FILE########
__FILENAME__ = prefetch
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import threading
import eos.types
class PrefetchThread(threading.Thread):
    def run(self):
        # We're a daemon thread, as such, interpreter might get shut down while we do stuff
        # Make sure we don't throw tracebacks to console
        try:
            eos.types.Character.setSkillList(eos.db.getItemsByCategory("Skill", eager=("effects", "attributes", "attributes.info.icon", "attributes.info.unit", "icon")))
        except:
            pass

prefetch = PrefetchThread()
prefetch.daemon = True
prefetch.start()

########NEW FILE########
__FILENAME__ = settings
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import cPickle
import os.path
import config
import urllib2

class SettingsProvider():
    BASE_PATH = os.path.join(config.savePath, "settings")
    settings = {}
    _instance = None
    @classmethod
    def getInstance(cls):
        if cls._instance == None:
            cls._instance = SettingsProvider()

        return cls._instance

    def __init__(self):
        if not os.path.exists(self.BASE_PATH):
            os.mkdir(self.BASE_PATH);

    def getSettings(self, area, defaults=None):

        s = self.settings.get(area)
        if s is None:
            p = os.path.join(self.BASE_PATH, area)

            if not os.path.exists(p):
                info = {}
                if defaults:
                    for item in defaults:
                        info[item] = defaults[item]

            else:
                try:
                    f = open(p, "rb")
                    info = cPickle.load(f)
                    for item in defaults:
                        if item not in info:
                            info[item] = defaults[item]

                except:
                    info = {}
                    if defaults:
                        for item in defaults:
                            info[item] = defaults[item]

            self.settings[area] = s = Settings(p, info)

        return s

    def saveAll(self):
        for settings in self.settings.itervalues():
            settings.save()

class Settings():
    def __init__(self, location, info):
        self.location = location
        self.info = info

    def save(self):
        f = open(self.location, "wb")
        cPickle.dump(self.info, f, cPickle.HIGHEST_PROTOCOL)

    def __getitem__(self, k):
        try:
            return self.info[k]
        except KeyError:
            return None

    def __setitem__(self, k, v):
        self.info[k] = v

    def __iter__(self):
        return self.info.__iter__()

    def iterkeys(self):
        return self.info.iterkeys()

    def itervalues(self):
        return self.info.itervalues()

    def iteritems(self):
        return self.info.iteritems()

    def keys(self):
        return self.info.keys()

    def values(self):
        return self.info.values()

    def items(self):
        return self.info.items()



class ProxySettings():
    _instance = None
    @classmethod
    def getInstance(cls):
        if cls._instance == None:
            cls._instance = ProxySettings()

        return cls._instance

    def __init__(self):

        # mode
        # 0 - No proxy
        # 1 - Auto-detected proxy settings
        # 2 - Manual proxy settings
        serviceProxyDefaultSettings = {"mode": 1, "type": "https", "address": "", "port": ""}

        self.serviceProxySettings = SettingsProvider.getInstance().getSettings("pyfaServiceProxySettings", serviceProxyDefaultSettings)

    def getMode(self):
        return self.serviceProxySettings["mode"]

    def getAddress(self):
        return self.serviceProxySettings["address"]

    def getPort(self):
        return self.serviceProxySettings["port"]

    def getType(self):
        return self.serviceProxySettings["type"]

    def setMode(self, mode):
        self.serviceProxySettings["mode"] = mode

    def setAddress(self, addr):
        self.serviceProxySettings["address"] = addr

    def setPort(self, port):
        self.serviceProxySettings["port"] = port

    def setType(self, type):
        self.serviceProxySettings["type"] = type

    def autodetect(self):

        proxy = None
        proxAddr = proxPort = ""
        proxydict = urllib2.ProxyHandler().proxies
        txt = "Auto-detected: "

        validPrefixes = ("http", "https")

        for prefix in validPrefixes:
            if not prefix in proxydict:
                continue
            proxyline = proxydict[prefix]
            proto = "{0}://".format(prefix)
            if proxyline[:len(proto)] == proto:
                proxyline = proxyline[len(proto):]
            proxAddr, proxPort = proxyline.split(":")
            proxPort = int(proxPort.rstrip("/"))
            proxy = (proxAddr, proxPort)
            break

        return proxy

    def getProxySettings(self):

        if self.getMode() == 0:
            return None
        if self.getMode() == 1:
            return self.autodetect()
        if self.getMode() == 2:
            return (self.getAddress(), int(self.getPort()))



"""
Settings used by the HTML export feature.
"""
class HTMLExportSettings():
    _instance = None

    @classmethod
    def getInstance(cls):
        if cls._instance == None:
            cls._instance = HTMLExportSettings()

        return cls._instance

    def __init__(self):
        serviceHTMLExportDefaultSettings = {"enabled": False, "path": config.pyfaPath + os.sep + 'pyfaFits.html' }
        self.serviceHTMLExportSettings = SettingsProvider.getInstance().getSettings("pyfaServiceHTMLExportSettings", serviceHTMLExportDefaultSettings)

    def getEnabled(self):
        return self.serviceHTMLExportSettings["enabled"]

    def setEnabled(self, enabled):
        self.serviceHTMLExportSettings["enabled"] = enabled

    def getPath(self):
        return self.serviceHTMLExportSettings["path"]

    def setPath(self, path):
        self.serviceHTMLExportSettings["path"] = path

"""
Settings used by update notification
"""
class UpdateSettings():
    _instance = None

    @classmethod
    def getInstance(cls):
        if cls._instance == None:
            cls._instance = UpdateSettings()

        return cls._instance

    def __init__(self):
        # Settings
        # all        - If True, suppress all update notifications
        # prerelease - If True, suppress only prerelease notifications
        # version    - Set to release tag that user does not want notifications for
        serviceUpdateDefaultSettings = { "all": False, "prerelease": True, 'version': None }
        self.serviceUpdateSettings = SettingsProvider.getInstance().getSettings("pyfaServiceUpdateSettings", serviceUpdateDefaultSettings)

    def get(self, type):
        return self.serviceUpdateSettings[type]

    def set(self, type, value):
        self.serviceUpdateSettings[type] = value

# @todo: "reopen fits" setting class
# @todo: migrate fit settings (from fit service) here?

########NEW FILE########
__FILENAME__ = update
#===============================================================================
# Copyright (C) 2010 Diego Duclos
#
# This file is part of pyfa.
#
# pyfa is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyfa is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyfa.  If not, see <http://www.gnu.org/licenses/>.
#===============================================================================

import threading
import wx
import urllib2
import json
import config
import service

class CheckUpdateThread(threading.Thread):
    def __init__(self, callback):
        threading.Thread.__init__(self)
        self.callback = callback
        self.settings = service.settings.UpdateSettings.getInstance()

    def run(self):
        # Suppress all
        if (self.settings.get('all')):
            return

        try:
            # @todo: use proxy settings?
            response = urllib2.urlopen('https://api.github.com/repos/DarkFenX/Pyfa/releases')
            jsonResponse = json.loads(response.read());

            for release in jsonResponse:
                # Suppress pre releases
                if (release['prerelease'] and self.settings.get('prerelease')):
                    continue

                # Handle use-case of updating to suppressed version
                if self.settings.get('version') == 'v'+config.version:
                    self.settings.set('version', None)

                # Suppress version
                if (release['tag_name'] == self.settings.get('version')):
                    break

                # Set the release version that we will be comparing with.
                if release['prerelease']:
                    rVersion = release['tag_name'].replace('singularity-', '', 1)
                else:
                    rVersion = release['tag_name'].replace('v', '', 1)

                if config.tag is 'git' and not release['prerelease'] and self.versiontuple(rVersion) >= self.versiontuple(config.version):
                    wx.CallAfter(self.callback, release) # git (dev/Singularity) -> Stable
                elif config.expansionName is not "Singularity":
                    if release['prerelease']:
                        wx.CallAfter(self.callback, release) # Stable -> Singularity
                    elif self.versiontuple(rVersion) > self.versiontuple(config.version):
                        wx.CallAfter(self.callback, release) # Stable -> Stable
                else:
                    if release['prerelease'] and rVersion > config.expansionVersion:
                        wx.CallAfter(self.callback, release) # Singularity -> Singularity
                break;
        except: # for when there is no internet connection
            pass

    def versiontuple(self, v):
        return tuple(map(int, (v.split("."))))

class Update():
    instance = None
    def __init__(self):
       pass

    def CheckUpdate(self, callback):
        thread = CheckUpdateThread(callback)
        thread.start()

    @classmethod
    def getInstance(cls):
        if cls.instance == None:
            cls.instance = Update()
        return cls.instance



########NEW FILE########
