__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# subliminal documentation build configuration file, created by
# sphinx-quickstart on Wed Oct 23 23:24:28 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))
sys.path.append(os.path.abspath('_themes'))
import subliminal

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = subliminal.__title__
copyright = ' '.join(subliminal.__copyright__.split()[1:])

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = subliminal.__version__.split('-')[0]
# The full version, including alpha/beta/rc tags.
release = subliminal.__version__

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
#keep_warnings = False


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'diaoul'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
html_theme_options = {'github_user': 'Diaoul',
                      'github_repo': 'subliminal',
                      'github_branch': 'master',
                      'fork_me': 1,
                      'flattr': 0,
                      'gittip': 'Diaoul',
                      'pypi_downloads': 1,
                      'pypi_version': 0,
                      'travis': 0,
                      'coveralls': 0}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['_themes']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
html_sidebars = {
    'index': ['sidebar-intro.html', 'sidebar-star.html', 'sidebar-pypi.html', 'sidebar-donate.html',
              'sourcelink.html', 'searchbox.html'],
    '**': ['sidebar-intro.html', 'sidebar-star.html', 'sidebar-pypi.html', 'sidebar-donate.html',
           'localtoc.html', 'relations.html', 'sourcelink.html', 'searchbox.html']
}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'subliminaldoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'subliminal.tex', u'subliminal Documentation',
   u'Antoine Bertin', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'subliminal', u'subliminal Documentation',
     [u'Antoine Bertin'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'subliminal', u'subliminal Documentation',
   u'Antoine Bertin', 'subliminal', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
#texinfo_no_detailmenu = False


# -- Options for autodoc -------------------------------------------------------
autodoc_member_order = 'bysource'

########NEW FILE########
__FILENAME__ = api
# -*- coding: utf-8 -*-
from __future__ import unicode_literals
import collections
import io
import logging
import operator
import os.path
import babelfish
from .providers import ProviderPool
from .subtitle import get_subtitle_path


logger = logging.getLogger(__name__)


def list_subtitles(videos, languages, providers=None, provider_configs=None):
    """List subtitles for `videos` with the given `languages` using the specified `providers`

    :param videos: videos to list subtitles for
    :type videos: set of :class:`~subliminal.video.Video`
    :param languages: languages of subtitles to search for
    :type languages: set of :class:`babelfish.Language`
    :param providers: providers to use, if not all
    :type providers: list of string or None
    :param provider_configs: configuration for providers
    :type provider_configs: dict of provider name => provider constructor kwargs or None
    :return: found subtitles
    :rtype: dict of :class:`~subliminal.video.Video` => [:class:`~subliminal.subtitle.Subtitle`]

    """
    subtitles = collections.defaultdict(list)
    with ProviderPool(providers, provider_configs) as pp:
        for video in videos:
            logger.info('Listing subtitles for %r', video)
            video_subtitles = pp.list_subtitles(video, languages)
            logger.info('Found %d subtitles total', len(video_subtitles))
            subtitles[video].extend(video_subtitles)
    return subtitles


def download_subtitles(subtitles, provider_configs=None):
    """Download subtitles

    :param subtitles: subtitles to download
    :type subtitles: list of :class:`~subliminal.subtitle.Subtitle`
    :param provider_configs: configuration for providers
    :type provider_configs: dict of provider name => provider constructor kwargs or None

    """
    with ProviderPool(provider_configs=provider_configs) as pp:
        for subtitle in subtitles:
            logger.info('Downloading subtitle %r', subtitle)
            pp.download_subtitle(subtitle)


def download_best_subtitles(videos, languages, providers=None, provider_configs=None, min_score=0,
                            hearing_impaired=False, single=False):
    """Download the best subtitles for `videos` with the given `languages` using the specified `providers`

    :param videos: videos to download subtitles for
    :type videos: set of :class:`~subliminal.video.Video`
    :param languages: languages of subtitles to download
    :type languages: set of :class:`babelfish.Language`
    :param providers: providers to use for the search, if not all
    :type providers: list of string or None
    :param provider_configs: configuration for providers
    :type provider_configs: dict of provider name => provider constructor kwargs or None
    :param int min_score: minimum score for subtitles to download
    :param bool hearing_impaired: download hearing impaired subtitles
    :param bool single: do not download for videos with an undetermined subtitle language detected

    """
    downloaded_subtitles = collections.defaultdict(list)
    with ProviderPool(providers, provider_configs) as pp:
        for video in videos:
            # filter
            if single and babelfish.Language('und') in video.subtitle_languages:
                logger.debug('Skipping video %r: undetermined language found')
                continue

            # list
            logger.info('Listing subtitles for %r', video)
            video_subtitles = pp.list_subtitles(video, languages)
            logger.info('Found %d subtitles total', len(video_subtitles))

            # download
            downloaded_languages = set()
            for subtitle, score in sorted([(s, s.compute_score(video)) for s in video_subtitles],
                                          key=operator.itemgetter(1), reverse=True):
                if score < min_score:
                    logger.info('No subtitle with score >= %d', min_score)
                    break
                if subtitle.hearing_impaired != hearing_impaired:
                    logger.debug('Skipping subtitle: hearing impaired != %r', hearing_impaired)
                    continue
                if subtitle.language in downloaded_languages:
                    logger.debug('Skipping subtitle: %r already downloaded', subtitle.language)
                    continue
                logger.info('Downloading subtitle %r with score %d', subtitle, score)
                if pp.download_subtitle(subtitle):
                    downloaded_languages.add(subtitle.language)
                    downloaded_subtitles[video].append(subtitle)
                if single or downloaded_languages == languages:
                    logger.debug('All languages downloaded')
                    break
    return downloaded_subtitles


def save_subtitles(subtitles, single=False, directory=None, encoding=None):
    """Save subtitles on disk next to the video or in a specific folder if `folder_path` is specified

    :param bool single: download with .srt extension if ``True``, add language identifier otherwise
    :param directory: path to directory where to save the subtitles, if any
    :type directory: string or None
    :param encoding: encoding for the subtitles or ``None`` to use the original encoding
    :type encoding: string or None

    """
    for video, video_subtitles in subtitles.items():
        saved_languages = set()
        for video_subtitle in video_subtitles:
            if video_subtitle.content is None:
                logger.debug('Skipping subtitle %r: no content', video_subtitle)
                continue
            if video_subtitle.language in saved_languages:
                logger.debug('Skipping subtitle %r: language already saved', video_subtitle)
                continue
            subtitle_path = get_subtitle_path(video.name, None if single else video_subtitle.language)
            if directory is not None:
                subtitle_path = os.path.join(directory, os.path.split(subtitle_path)[1])
            logger.info('Saving %r to %r', video_subtitle, subtitle_path)
            if encoding is None:
                with io.open(subtitle_path, 'wb') as f:
                    f.write(video_subtitle.content)
            else:
                with io.open(subtitle_path, 'w', encoding=encoding) as f:
                    f.write(video_subtitle.text)
            saved_languages.add(video_subtitle.language)
            if single:
                break

########NEW FILE########
__FILENAME__ = cache
# -*- coding: utf-8 -*-
import datetime
import inspect
from dogpile.cache import make_region  # @UnresolvedImport
from dogpile.cache.backends.file import AbstractFileLock  # @UnresolvedImport
from dogpile.cache.compat import string_type  # @UnresolvedImport
from dogpile.core.readwrite_lock import ReadWriteMutex  # @UnresolvedImport


#: Subliminal's cache version
CACHE_VERSION = 1

#: Expiration time for show caching
SHOW_EXPIRATION_TIME = datetime.timedelta(weeks=3).total_seconds()

#: Expiration time for episode caching
EPISODE_EXPIRATION_TIME = datetime.timedelta(days=3).total_seconds()


def subliminal_key_generator(namespace, fn, to_str=string_type):
    """Add a :data:`CACHE_VERSION` to dogpile.cache's default function_key_generator"""
    if namespace is None:
        namespace = '%d:%s:%s' % (CACHE_VERSION, fn.__module__, fn.__name__)
    else:
        namespace = '%d:%s:%s|%s' % (CACHE_VERSION, fn.__module__, fn.__name__, namespace)

    args = inspect.getargspec(fn)
    has_self = args[0] and args[0][0] in ('self', 'cls')

    def generate_key(*args, **kw):
        if kw:
            raise ValueError('Keyword arguments not supported')
        if has_self:
            args = args[1:]
        return namespace + '|' + ' '.join(map(to_str, args))
    return generate_key


class MutexLock(AbstractFileLock):
    """:class:`MutexLock` is a thread-based rw lock based on :class:`dogpile.core.ReadWriteMutex`"""
    def __init__(self, filename):
        self.mutex = ReadWriteMutex()

    def acquire_read_lock(self, wait):
        ret = self.mutex.acquire_read_lock(wait)
        return wait or ret

    def acquire_write_lock(self, wait):
        ret = self.mutex.acquire_write_lock(wait)
        return wait or ret

    def release_read_lock(self):
        return self.mutex.release_read_lock()

    def release_write_lock(self):
        return self.mutex.release_write_lock()


#: The dogpile.cache region
region = make_region(function_key_generator=subliminal_key_generator)

########NEW FILE########
__FILENAME__ = cli
# -*- coding: utf-8 -*-
from __future__ import unicode_literals, print_function
import argparse
import datetime
import logging
import os
import re
import sys
import babelfish
import xdg.BaseDirectory
from subliminal import (__version__, cache_region, MutexLock, provider_manager, Video, Episode, Movie, scan_videos,
    download_best_subtitles, save_subtitles)
try:
    import colorlog
except ImportError:
    colorlog = None


DEFAULT_CACHE_FILE = os.path.join(xdg.BaseDirectory.save_cache_path('subliminal'), 'cli.dbm')


def subliminal():
    parser = argparse.ArgumentParser(prog='subliminal', description='Subtitles, faster than your thoughts',
                                     epilog='Suggestions and bug reports are greatly appreciated: '
                                     'https://github.com/Diaoul/subliminal/issues', add_help=False)

    # required arguments
    required_arguments_group = parser.add_argument_group('required arguments')
    required_arguments_group.add_argument('paths', nargs='+', metavar='PATH', help='path to video file or folder')
    required_arguments_group.add_argument('-l', '--languages', nargs='+', required=True, metavar='LANGUAGE',
                                          help='wanted languages as IETF codes e.g. fr, pt-BR, sr-Cyrl ')

    # configuration
    configuration_group = parser.add_argument_group('configuration')
    configuration_group.add_argument('-s', '--single', action='store_true',
                                     help='download without language code in subtitle\'s filename i.e. .srt only')
    configuration_group.add_argument('-c', '--cache-file', default=DEFAULT_CACHE_FILE,
                                     help='cache file (default: %(default)s)')

    # filtering
    filtering_group = parser.add_argument_group('filtering')
    filtering_group.add_argument('-p', '--providers', nargs='+', metavar='PROVIDER',
                                 help='providers to use (%s)' % ', '.join(provider_manager.available_providers))
    filtering_group.add_argument('-m', '--min-score', type=int, default=0,
                                 help='minimum score for subtitles (0-%d for episodes, 0-%d for movies)'
                                 % (Episode.scores['hash'], Movie.scores['hash']))
    filtering_group.add_argument('-a', '--age', help='download subtitles for videos newer than AGE e.g. 12h, 1w2d')
    filtering_group.add_argument('-h', '--hearing-impaired', action='store_true',
                                 help='download hearing impaired subtitles')
    filtering_group.add_argument('-f', '--force', action='store_true',
                                 help='force subtitle download for videos with existing subtitles')

    # addic7ed
    addic7ed_group = parser.add_argument_group('addic7ed')
    addic7ed_group.add_argument('--addic7ed-username', metavar='USERNAME', help='username for addic7ed provider')
    addic7ed_group.add_argument('--addic7ed-password', metavar='PASSWORD', help='password for addic7ed provider')

    # output
    output_group = parser.add_argument_group('output')
    output_group.add_argument('-d', '--directory',
                              help='save subtitles in the given directory rather than next to the video')
    output_group.add_argument('-e', '--encoding', default=None,
                              help='encoding to convert the subtitle to (default: no conversion)')
    output_exclusive_group = output_group.add_mutually_exclusive_group()
    output_exclusive_group.add_argument('-q', '--quiet', action='store_true', help='disable output')
    output_exclusive_group.add_argument('-v', '--verbose', action='store_true', help='verbose output')
    output_group.add_argument('--log-file', help='log into a file instead of stdout')
    output_group.add_argument('--color', action='store_true', help='add color to console output (requires colorlog)')

    # troubleshooting
    troubleshooting_group = parser.add_argument_group('troubleshooting')
    troubleshooting_group.add_argument('--debug', action='store_true', help='debug output')
    troubleshooting_group.add_argument('--version', action='version', version=__version__)
    troubleshooting_group.add_argument('--help', action='help', help='show this help message and exit')

    # parse args
    args = parser.parse_args()

    # parse paths
    try:
        args.paths = [os.path.abspath(os.path.expanduser(p.decode('utf-8') if isinstance(p, bytes) else p))
                      for p in args.paths]
    except UnicodeDecodeError:
        parser.error('argument paths: encodings is not utf-8: %r' % args.paths)

    # parse languages
    try:
        args.languages = {babelfish.Language.fromietf(l) for l in args.languages}
    except babelfish.Error:
        parser.error('argument -l/--languages: codes are not IETF: %r' % args.languages)

    # parse age
    if args.age is not None:
        match = re.match(r'^(?:(?P<weeks>\d+?)w)?(?:(?P<days>\d+?)d)?(?:(?P<hours>\d+?)h)?$', args.age)
        if not match:
            parser.error('argument -a/--age: invalid age: %r' % args.age)
        args.age = datetime.timedelta(**{k: int(v) for k, v in match.groupdict(0).items()})

    # parse cache-file
    args.cache_file = os.path.abspath(os.path.expanduser(args.cache_file))
    if not os.path.exists(os.path.split(args.cache_file)[0]):
        parser.error('argument -c/--cache-file: directory %r for cache file does not exist'
                     % os.path.split(args.cache_file)[0])

    # parse provider configs
    provider_configs = {}
    if (args.addic7ed_username is not None and args.addic7ed_password is None
        or args.addic7ed_username is None and args.addic7ed_password is not None):
        parser.error('argument --addic7ed-username/--addic7ed-password: both arguments are required or none')
    if args.addic7ed_username is not None and args.addic7ed_password is not None:
        provider_configs['addic7ed'] = {'username': args.addic7ed_username, 'password': args.addic7ed_password}

    # parse color
    if args.color and colorlog is None:
        parser.error('argument --color: colorlog required')

    # setup output
    if args.log_file is None:
        handler = logging.StreamHandler()
    else:
        handler = logging.FileHandler(args.log_file, encoding='utf-8')
    if args.debug:
        if args.color:
            if args.log_file is None:
                log_format = '%(log_color)s%(levelname)-8s%(reset)s [%(blue)s%(name)s-%(funcName)s:%(lineno)d%(reset)s] %(message)s'
            else:
                log_format = '%(purple)s%(asctime)s%(reset)s %(log_color)s%(levelname)-8s%(reset)s [%(blue)s%(name)s-%(funcName)s:%(lineno)d%(reset)s] %(message)s'
            handler.setFormatter(colorlog.ColoredFormatter(log_format,
                                                           log_colors=dict(colorlog.default_log_colors.items() + [('DEBUG', 'cyan')])))
        else:
            if args.log_file is None:
                log_format = '%(levelname)-8s [%(name)s-%(funcName)s:%(lineno)d] %(message)s'
            else:
                log_format = '%(asctime)s %(levelname)-8s [%(name)s-%(funcName)s:%(lineno)d] %(message)s'
            handler.setFormatter(logging.Formatter(log_format))
        logging.getLogger().addHandler(handler)
        logging.getLogger().setLevel(logging.DEBUG)
    elif args.verbose:
        if args.color:
            if args.log_file is None:
                log_format = '%(log_color)s%(levelname)-8s%(reset)s [%(blue)s%(name)s%(reset)s] %(message)s'
            else:
                log_format = '%(purple)s%(asctime)s%(reset)s %(log_color)s%(levelname)-8s%(reset)s [%(blue)s%(name)s%(reset)s] %(message)s'
            handler.setFormatter(colorlog.ColoredFormatter(log_format))
        else:
            log_format = '%(levelname)-8s [%(name)s] %(message)s'
            if args.log_file is not None:
                log_format = '%(asctime)s ' + log_format
            handler.setFormatter(logging.Formatter(log_format))
        logging.getLogger('subliminal').addHandler(handler)
        logging.getLogger('subliminal').setLevel(logging.INFO)
    elif not args.quiet:
        if args.color:
            if args.log_file is None:
                log_format = '[%(log_color)s%(levelname)s%(reset)s] %(message)s'
            else:
                log_format = '%(purple)s%(asctime)s%(reset)s [%(log_color)s%(levelname)s%(reset)s] %(message)s'
            handler.setFormatter(colorlog.ColoredFormatter(log_format))
        else:
            if args.log_file is None:
                log_format = '%(levelname)s: %(message)s'
            else:
                log_format = '%(asctime)s %(levelname)s: %(message)s'
            handler.setFormatter(logging.Formatter(log_format))
        logging.getLogger('subliminal.api').addHandler(handler)
        logging.getLogger('subliminal.api').setLevel(logging.INFO)

    # configure cache
    cache_region.configure('dogpile.cache.dbm', expiration_time=datetime.timedelta(days=30),  # @UndefinedVariable
                           arguments={'filename': args.cache_file, 'lock_factory': MutexLock})

    # scan videos
    videos = scan_videos([p for p in args.paths if os.path.exists(p)], subtitles=not args.force,
                         embedded_subtitles=not args.force, age=args.age)

    # guess videos
    videos.extend([Video.fromname(p) for p in args.paths if not os.path.exists(p)])

    # download best subtitles
    subtitles = download_best_subtitles(videos, args.languages, providers=args.providers,
                                        provider_configs=provider_configs, min_score=args.min_score,
                                        hearing_impaired=args.hearing_impaired, single=args.single)

    # save subtitles
    save_subtitles(subtitles, single=args.single, directory=args.directory, encoding=args.encoding)

    # result output
    if not subtitles:
        if not args.quiet:
            print('No subtitles downloaded', file=sys.stderr)
        exit(1)
    if not args.quiet:
        subtitles_count = sum([len(s) for s in subtitles.values()])
        if subtitles_count == 1:
            print('%d subtitle downloaded' % subtitles_count)
        else:
            print('%d subtitles downloaded' % subtitles_count)

########NEW FILE########
__FILENAME__ = compat
# -*- coding: utf-8 -*-
import sys
import socket


if sys.version_info[0] == 2:
    from xmlrpclib import ServerProxy, Transport
    from httplib import HTTPConnection
elif sys.version_info[0] == 3:
    from xmlrpc.client import ServerProxy, Transport
    from http.client import HTTPConnection


class TimeoutTransport(Transport, object):
    def __init__(self, timeout=socket._GLOBAL_DEFAULT_TIMEOUT, *args, **kwargs):
        super(TimeoutTransport, self).__init__(*args, **kwargs)
        self.timeout = timeout

    def make_connection(self, host):
        h = HTTPConnection(host, timeout=self.timeout)
        return h

########NEW FILE########
__FILENAME__ = addic7ed
# -*- coding: utf-8 -*-
from __future__ import unicode_literals
from babelfish import LanguageReverseConverter, language_converters


class Addic7edConverter(LanguageReverseConverter):
    def __init__(self):
        self.name_converter = language_converters['name']
        self.from_addic7ed = {'Català': ('cat',), 'Chinese (Simplified)': ('zho',), 'Chinese (Traditional)': ('zho',),
                              'Euskera': ('eus',), 'Galego': ('glg',), 'Greek': ('ell',), 'Malay': ('msa',),
                              'Portuguese (Brazilian)': ('por', 'BR'), 'Serbian (Cyrillic)': ('srp', None, 'Cyrl'),
                              'Serbian (Latin)': ('srp',), 'Spanish (Latin America)': ('spa',),
                              'Spanish (Spain)': ('spa',)}
        self.to_addic7ed = {('cat',): 'Català', ('zho',): 'Chinese (Simplified)', ('eus',): 'Euskera',
                            ('glg',): 'Galego', ('ell',): 'Greek', ('msa',): 'Malay',
                            ('por', 'BR'): 'Portuguese (Brazilian)', ('srp', None, 'Cyrl'): 'Serbian (Cyrillic)'}
        self.codes = self.name_converter.codes | set(self.from_addic7ed.keys())

    def convert(self, alpha3, country=None, script=None):
        if (alpha3, country, script) in self.to_addic7ed:
            return self.to_addic7ed[(alpha3, country, script)]
        if (alpha3, country) in self.to_addic7ed:
            return self.to_addic7ed[(alpha3, country)]
        if (alpha3,) in self.to_addic7ed:
            return self.to_addic7ed[(alpha3,)]
        return self.name_converter.convert(alpha3, country, script)

    def reverse(self, addic7ed):
        if addic7ed in self.from_addic7ed:
            return self.from_addic7ed[addic7ed]
        return self.name_converter.reverse(addic7ed)

########NEW FILE########
__FILENAME__ = podnapisi
# -*- coding: utf-8 -*-
from __future__ import unicode_literals
from babelfish import LanguageReverseConverter, LanguageConvertError, LanguageReverseError


class PodnapisiConverter(LanguageReverseConverter):
    def __init__(self):
        self.from_podnapisi = {2: ('eng',), 28: ('spa',), 26: ('pol',), 36: ('srp',), 1: ('slv',), 38: ('hrv',),
                               9: ('ita',), 8: ('fra',), 48: ('por', 'BR'), 23: ('nld',), 12: ('ara',), 13: ('ron',),
                               33: ('bul',), 32: ('por',), 16: ('ell',), 15: ('hun',), 31: ('fin',), 30: ('tur',),
                               7: ('ces',), 25: ('swe',), 27: ('rus',), 24: ('dan',), 22: ('heb',), 51: ('vie',),
                               52: ('fas',), 5: ('deu',), 14: ('spa', 'AR'), 54: ('ind',), 47: ('srp', None, 'Cyrl'),
                               3: ('nor',), 20: ('est',), 10: ('bos',), 17: ('zho',), 37: ('slk',), 35: ('mkd',),
                               11: ('jpn',), 4: ('kor',), 29: ('sqi',), 6: ('isl',), 19: ('lit',), 46: ('ukr',),
                               44: ('tha',), 53: ('cat',), 56: ('sin',), 21: ('lav',), 40: ('cmn',), 55: ('msa',),
                               42: ('hin',), 50: ('bel',)}
        self.to_podnapisi = {v: k for k, v in self.from_podnapisi.items()}
        self.codes = set(self.from_podnapisi.keys())

    def convert(self, alpha3, country=None, script=None):
        if (alpha3,) in self.to_podnapisi:
            return self.to_podnapisi[(alpha3,)]
        if (alpha3, country) in self.to_podnapisi:
            return self.to_podnapisi[(alpha3, country)]
        if (alpha3, country, script) in self.to_podnapisi:
            return self.to_podnapisi[(alpha3, country, script)]
        raise LanguageConvertError(alpha3, country, script)

    def reverse(self, podnapisi):
        if podnapisi not in self.from_podnapisi:
            raise LanguageReverseError(podnapisi)
        return self.from_podnapisi[podnapisi]

########NEW FILE########
__FILENAME__ = tvsubtitles
# -*- coding: utf-8 -*-
from __future__ import unicode_literals
from babelfish import LanguageReverseConverter, language_converters


class TVsubtitlesConverter(LanguageReverseConverter):
    def __init__(self):
        self.alpha2_converter = language_converters['alpha2']
        self.from_tvsubtitles = {'br': ('por', 'BR'), 'ua': ('ukr',), 'gr': ('ell',), 'cn': ('zho',), 'jp': ('jpn',),
                                 'cz': ('ces',)}
        self.to_tvsubtitles = {v: k for k, v in self.from_tvsubtitles}
        self.codes = self.alpha2_converter.codes | set(self.from_tvsubtitles.keys())

    def convert(self, alpha3, country=None, script=None):
        if (alpha3, country) in self.to_tvsubtitles:
            return self.to_tvsubtitles[(alpha3, country)]
        if (alpha3,) in self.to_tvsubtitles:
            return self.to_tvsubtitles[(alpha3,)]
        return self.alpha2_converter.convert(alpha3, country, script)

    def reverse(self, tvsubtitles):
        if tvsubtitles in self.from_tvsubtitles:
            return self.from_tvsubtitles[tvsubtitles]
        return self.alpha2_converter.reverse(tvsubtitles)

########NEW FILE########
__FILENAME__ = exceptions
# -*- coding: utf-8 -*-
from __future__ import unicode_literals


class Error(Exception):
    """Base class for exceptions in subliminal"""


class ProviderError(Error):
    """Exception raised by providers"""


class ConfigurationError(ProviderError):
    """Exception raised by providers when badly configured"""


class AuthenticationError(ProviderError):
    """Exception raised by providers when authentication failed"""


class DownloadLimitExceeded(ProviderError):
    """Exception raised by providers when download limit is exceeded"""

########NEW FILE########
__FILENAME__ = addic7ed
# -*- coding: utf-8 -*-
from __future__ import unicode_literals
import logging
import babelfish
import bs4
import requests
from . import Provider
from .. import __version__
from ..cache import region, SHOW_EXPIRATION_TIME
from ..exceptions import ConfigurationError, AuthenticationError, DownloadLimitExceeded, ProviderError
from ..subtitle import Subtitle, fix_line_endings, compute_guess_properties_matches
from ..video import Episode


logger = logging.getLogger(__name__)
babelfish.language_converters.register('addic7ed = subliminal.converters.addic7ed:Addic7edConverter')


class Addic7edSubtitle(Subtitle):
    provider_name = 'addic7ed'

    def __init__(self, language, series, season, episode, title, year, version, hearing_impaired, download_link,
                 page_link):
        super(Addic7edSubtitle, self).__init__(language, hearing_impaired, page_link)
        self.series = series
        self.season = season
        self.episode = episode
        self.title = title
        self.year = year
        self.version = version
        self.download_link = download_link

    def compute_matches(self, video):
        matches = set()
        # series
        if video.series and self.series == video.series:
            matches.add('series')
        # season
        if video.season and self.season == video.season:
            matches.add('season')
        # episode
        if video.episode and self.episode == video.episode:
            matches.add('episode')
        # title
        if video.title and self.title.lower() == video.title.lower():
            matches.add('title')
        # year
        if self.year == video.year:
            matches.add('year')
        # release_group
        if video.release_group and self.version and video.release_group.lower() in self.version.lower():
            matches.add('release_group')
        """
        # resolution
        if video.resolution and self.version and video.resolution in self.version.lower():
            matches.add('resolution')
        # format
        if video.format and self.version and video.format in self.version.lower:
            matches.add('format')
        """
        # we don't have the complete filename, so we need to guess the matches separately
        # guess resolution (screenSize in guessit)
        matches |= compute_guess_properties_matches(video, self.version, 'screenSize')
        # guess format
        matches |= compute_guess_properties_matches(video, self.version, 'format')
        return matches


class Addic7edProvider(Provider):
    languages = {babelfish.Language('por', 'BR')} | {babelfish.Language(l)
                 for l in ['ara', 'aze', 'ben', 'bos', 'bul', 'cat', 'ces', 'dan', 'deu', 'ell', 'eng', 'eus', 'fas',
                           'fin', 'fra', 'glg', 'heb', 'hrv', 'hun', 'hye', 'ind', 'ita', 'jpn', 'kor', 'mkd', 'msa',
                           'nld', 'nor', 'pol', 'por', 'ron', 'rus', 'slk', 'slv', 'spa', 'sqi', 'srp', 'swe', 'tha',
                           'tur', 'ukr', 'vie', 'zho']}
    video_types = (Episode,)
    server = 'http://www.addic7ed.com'

    def __init__(self, username=None, password=None):
        if username is not None and password is None or username is None and password is not None:
            raise ConfigurationError('Username and password must be specified')
        self.username = username
        self.password = password
        self.logged_in = False

    def initialize(self):
        self.session = requests.Session()
        self.session.headers = {'User-Agent': 'Subliminal/%s' % __version__.split('-')[0]}
        # login
        if self.username is not None and self.password is not None:
            logger.debug('Logging in')
            data = {'username': self.username, 'password': self.password, 'Submit': 'Log in'}
            r = self.session.post(self.server + '/dologin.php', data, timeout=10, allow_redirects=False)
            if r.status_code == 302:
                logger.info('Logged in')
                self.logged_in = True
            else:
                raise AuthenticationError(self.username)

    def terminate(self):
        # logout
        if self.logged_in:
            r = self.session.get(self.server + '/logout.php', timeout=10)
            logger.info('Logged out')
            if r.status_code != 200:
                raise ProviderError('Request failed with status code %d' % r.status_code)
        self.session.close()

    def get(self, url, params=None):
        """Make a GET request on `url` with the given parameters

        :param string url: part of the URL to reach with the leading slash
        :param params: params of the request
        :return: the response
        :rtype: :class:`bs4.BeautifulSoup`

        """
        r = self.session.get(self.server + url, params=params, timeout=10)
        if r.status_code != 200:
            raise ProviderError('Request failed with status code %d' % r.status_code)
        return bs4.BeautifulSoup(r.content, ['permissive'])

    @region.cache_on_arguments(expiration_time=SHOW_EXPIRATION_TIME)
    def get_show_ids(self):
        """Load the shows page with default series to show ids mapping

        :return: series to show ids
        :rtype: dict

        """
        soup = self.get('/shows.php')
        show_ids = {}
        for html_show in soup.select('td.version > h3 > a[href^="/show/"]'):
            show_ids[html_show.string.lower()] = int(html_show['href'][6:])
        return show_ids

    @region.cache_on_arguments(expiration_time=SHOW_EXPIRATION_TIME)
    def find_show_id(self, series, year=None):
        """Find the show id from the `series` with optional `year`

        Use this only if the show id cannot be found with :meth:`get_show_ids`

        :param string series: series of the episode in lowercase
        :param year: year of the series, if any
        :type year: int or None
        :return: the show id, if any
        :rtype: int or None

        """
        series_year = series
        if year is not None:
            series_year += ' (%d)' % year
        params = {'search': series_year, 'Submit': 'Search'}
        logger.debug('Searching series %r', params)
        suggested_shows = self.get('/search.php', params).select('span.titulo > a[href^="/show/"]')
        if not suggested_shows:
            logger.info('Series %r not found', series_year)
            return None
        return int(suggested_shows[0]['href'][6:])

    def query(self, series, season, year=None):
        show_ids = self.get_show_ids()
        show_id = None
        if year is not None:  # search with the year
            series_year = '%s (%d)' % (series.lower(), year)
            if series_year in show_ids:
                show_id = show_ids[series_year]
            else:
                show_id = self.find_show_id(series.lower(), year)
        if show_id is None:  # search without the year
            year = None
            if series.lower() in show_ids:
                show_id = show_ids[series.lower()]
            else:
                show_id = self.find_show_id(series.lower())
        if show_id is None:
            return []
        params = {'show_id': show_id, 'season': season}
        logger.debug('Searching subtitles %r', params)
        link = '/show/{show_id}&season={season}'.format(**params)
        soup = self.get(link)
        subtitles = []
        for row in soup('tr', class_='epeven completed'):
            cells = row('td')
            if cells[5].string != 'Completed':
                continue
            if not cells[3].string:
                continue
            subtitles.append(Addic7edSubtitle(babelfish.Language.fromaddic7ed(cells[3].string), series, season,
                                              int(cells[1].string), cells[2].string, year, cells[4].string,
                                              bool(cells[6].string), cells[9].a['href'],
                                              self.server + cells[2].a['href']))
        return subtitles

    def list_subtitles(self, video, languages):
        return [s for s in self.query(video.series, video.season, video.year)
                if s.language in languages and s.episode == video.episode]

    def download_subtitle(self, subtitle):
        r = self.session.get(self.server + subtitle.download_link, timeout=10, headers={'Referer': subtitle.page_link})
        if r.status_code != 200:
            raise ProviderError('Request failed with status code %d' % r.status_code)
        if r.headers['Content-Type'] == 'text/html':
            raise DownloadLimitExceeded
        subtitle.content = fix_line_endings(r.content)

########NEW FILE########
__FILENAME__ = opensubtitles
# -*- coding: utf-8 -*-
from __future__ import unicode_literals
import base64
import logging
import os
import re
import zlib
import babelfish
import guessit
from . import Provider
from .. import __version__
from ..compat import ServerProxy, TimeoutTransport
from ..exceptions import ProviderError, AuthenticationError, DownloadLimitExceeded
from ..subtitle import Subtitle, fix_line_endings, compute_guess_matches
from ..video import Episode, Movie


logger = logging.getLogger(__name__)


class OpenSubtitlesSubtitle(Subtitle):
    provider_name = 'opensubtitles'
    series_re = re.compile('^"(?P<series_name>.*)" (?P<series_title>.*)$')

    def __init__(self, language, hearing_impaired, id, matched_by, movie_kind, hash, movie_name, movie_release_name,  # @ReservedAssignment
                 movie_year, movie_imdb_id, series_season, series_episode, page_link):
        super(OpenSubtitlesSubtitle, self).__init__(language, hearing_impaired, page_link)
        self.id = id
        self.matched_by = matched_by
        self.movie_kind = movie_kind
        self.hash = hash
        self.movie_name = movie_name
        self.movie_release_name = movie_release_name
        self.movie_year = movie_year
        self.movie_imdb_id = movie_imdb_id
        self.series_season = series_season
        self.series_episode = series_episode

    @property
    def series_name(self):
        return self.series_re.match(self.movie_name).group('series_name')

    @property
    def series_title(self):
        return self.series_re.match(self.movie_name).group('series_title')

    def compute_matches(self, video):
        matches = set()
        # episode
        if isinstance(video, Episode) and self.movie_kind == 'episode':
            # series
            if video.series and self.series_name.lower() == video.series.lower():
                matches.add('series')
            # season
            if video.season and self.series_season == video.season:
                matches.add('season')
            # episode
            if video.episode and self.series_episode == video.episode:
                matches.add('episode')
            # guess
            matches |= compute_guess_matches(video, guessit.guess_episode_info(self.movie_release_name + '.mkv'))
        # movie
        elif isinstance(video, Movie) and self.movie_kind == 'movie':
            # year
            if video.year and self.movie_year == video.year:
                matches.add('year')
            # guess
            matches |= compute_guess_matches(video, guessit.guess_movie_info(self.movie_release_name + '.mkv'))
        else:
            logger.info('%r is not a valid movie_kind for %r', self.movie_kind, video)
            return matches
        # hash
        if 'opensubtitles' in video.hashes and self.hash == video.hashes['opensubtitles']:
            matches.add('hash')
        # imdb_id
        if video.imdb_id and self.movie_imdb_id == video.imdb_id:
            matches.add('imdb_id')
        # title
        if video.title and self.movie_name.lower() == video.title.lower():
            matches.add('title')
        return matches


class OpenSubtitlesProvider(Provider):
    languages = {babelfish.Language.fromopensubtitles(l) for l in babelfish.language_converters['opensubtitles'].codes}

    def __init__(self):
        self.server = ServerProxy('http://api.opensubtitles.org/xml-rpc', transport=TimeoutTransport(10))
        self.token = None

    def initialize(self):
        response = checked(self.server.LogIn('', '', 'eng', 'subliminal v%s' % __version__.split('-')[0]))
        self.token = response['token']

    def terminate(self):
        checked(self.server.LogOut(self.token))
        self.server.close()

    def no_operation(self):
        checked(self.server.NoOperation(self.token))

    def query(self, languages, hash=None, size=None, imdb_id=None, query=None):  # @ReservedAssignment
        searches = []
        if hash and size:
            searches.append({'moviehash': hash, 'moviebytesize': str(size)})
        if imdb_id:
            searches.append({'imdbid': imdb_id})
        if query:
            searches.append({'query': query})
        if not searches:
            raise ValueError('One or more parameter missing')
        for search in searches:
            search['sublanguageid'] = ','.join(l.opensubtitles for l in languages)
        logger.debug('Searching subtitles %r', searches)
        response = checked(self.server.SearchSubtitles(self.token, searches))
        if not response['data']:
            logger.debug('No subtitle found')
            return []
        return [OpenSubtitlesSubtitle(babelfish.Language.fromopensubtitles(r['SubLanguageID']),
                                      bool(int(r['SubHearingImpaired'])), r['IDSubtitleFile'], r['MatchedBy'],
                                      r['MovieKind'], r['MovieHash'], r['MovieName'], r['MovieReleaseName'],
                                      int(r['MovieYear']) if r['MovieYear'] else None, int(r['IDMovieImdb']),
                                      int(r['SeriesSeason']) if r['SeriesSeason'] else None,
                                      int(r['SeriesEpisode']) if r['SeriesEpisode'] else None, r['SubtitlesLink'])
                for r in response['data']]

    def list_subtitles(self, video, languages):
        query = None
        if ('opensubtitles' not in video.hashes or not video.size) and not video.imdb_id:
            query = video.name.split(os.sep)[-1]
        return self.query(languages, hash=video.hashes.get('opensubtitles'), size=video.size, imdb_id=video.imdb_id,
                          query=query)

    def download_subtitle(self, subtitle):
        response = checked(self.server.DownloadSubtitles(self.token, [subtitle.id]))
        if not response['data']:
            raise ProviderError('Nothing to download')
        subtitle.content = fix_line_endings(zlib.decompress(base64.b64decode(response['data'][0]['data']), 47))


class OpenSubtitlesError(ProviderError):
    """Base class for non-generic :class:`OpenSubtitlesProvider` exceptions"""


class Unauthorized(OpenSubtitlesError, AuthenticationError):
    """Exception raised when status is '401 Unauthorized'"""


class NoSession(OpenSubtitlesError, AuthenticationError):
    """Exception raised when status is '406 No session'"""


class DownloadLimitReached(OpenSubtitlesError, DownloadLimitExceeded):
    """Exception raised when status is '407 Download limit reached'"""


class InvalidImdbid(OpenSubtitlesError):
    """Exception raised when status is '413 Invalid ImdbID'"""


class UnknownUserAgent(OpenSubtitlesError, AuthenticationError):
    """Exception raised when status is '414 Unknown User Agent'"""


class DisabledUserAgent(OpenSubtitlesError, AuthenticationError):
    """Exception raised when status is '415 Disabled user agent'"""


class ServiceUnavailable(OpenSubtitlesError):
    """Exception raised when status is '503 Service Unavailable'"""


def checked(response):
    """Check a response status before returning it

    :param response: a response from a XMLRPC call to OpenSubtitles
    :return: the response
    :raise: :class:`OpenSubtitlesError`

    """
    status_code = int(response['status'][:3])
    if status_code == 401:
        raise Unauthorized
    if status_code == 406:
        raise NoSession
    if status_code == 407:
        raise DownloadLimitReached
    if status_code == 413:
        raise InvalidImdbid
    if status_code == 414:
        raise UnknownUserAgent
    if status_code == 415:
        raise DisabledUserAgent
    if status_code == 503:
        raise ServiceUnavailable
    if status_code != 200:
        raise OpenSubtitlesError(response['status'])
    return response

########NEW FILE########
__FILENAME__ = podnapisi
# -*- coding: utf-8 -*-
from __future__ import unicode_literals
import io
import logging
import re
import xml.etree.ElementTree
import zipfile
import babelfish
import bs4
import guessit
import requests
from . import Provider
from .. import __version__
from ..exceptions import ProviderError
from ..subtitle import Subtitle, fix_line_endings, compute_guess_matches
from ..video import Episode, Movie


logger = logging.getLogger(__name__)
babelfish.language_converters.register('podnapisi = subliminal.converters.podnapisi:PodnapisiConverter')


class PodnapisiSubtitle(Subtitle):
    provider_name = 'podnapisi'

    def __init__(self, language, id, releases, hearing_impaired, page_link, series=None, season=None, episode=None,  # @ReservedAssignment
                 title=None, year=None):
        super(PodnapisiSubtitle, self).__init__(language, hearing_impaired, page_link)
        self.id = id
        self.releases = releases
        self.hearing_impaired = hearing_impaired
        self.series = series
        self.season = season
        self.episode = episode
        self.title = title
        self.year = year

    def compute_matches(self, video):
        matches = set()
        # episode
        if isinstance(video, Episode):
            # series
            if video.series and self.series.lower() == video.series.lower():
                matches.add('series')
            # season
            if video.season and self.season == video.season:
                matches.add('season')
            # episode
            if video.episode and self.episode == video.episode:
                matches.add('episode')
            # guess
            for release in self.releases:
                matches |= compute_guess_matches(video, guessit.guess_episode_info(release + '.mkv'))
        # movie
        elif isinstance(video, Movie):
            # title
            if video.title and self.title.lower() == video.title.lower():
                matches.add('title')
            # guess
            for release in self.releases:
                matches |= compute_guess_matches(video, guessit.guess_movie_info(release + '.mkv'))
        # year
        if self.year == video.year:
            matches.add('year')
        return matches


class PodnapisiProvider(Provider):
    languages = {babelfish.Language.frompodnapisi(l) for l in babelfish.language_converters['podnapisi'].codes}
    video_types = (Episode, Movie)
    server = 'http://simple.podnapisi.net'
    link_re = re.compile('^.*(?P<link>/ppodnapisi/download/i/\d+/k/.*$)')

    def initialize(self):
        self.session = requests.Session()
        self.session.headers = {'User-Agent': 'Subliminal/%s' % __version__.split('-')[0]}

    def terminate(self):
        self.session.close()

    def get(self, url, params=None, is_xml=True):
        """Make a GET request on `url` with the given parameters

        :param string url: part of the URL to reach with the leading slash
        :param dict params: params of the request
        :param bool xml: whether the response content is XML or not
        :return: the response
        :rtype: :class:`xml.etree.ElementTree.Element` or :class:`bs4.BeautifulSoup`

        """
        r = self.session.get(self.server + '/ppodnapisi' + url, params=params, timeout=10)
        if r.status_code != 200:
            raise ProviderError('Request failed with status code %d' % r.status_code)
        if is_xml:
            return xml.etree.ElementTree.fromstring(r.content)
        else:
            return bs4.BeautifulSoup(r.content, ['permissive'])

    def query(self, language, series=None, season=None, episode=None, title=None, year=None):
        params = {'sXML': 1, 'sJ': language.podnapisi}
        if series and season and episode:
            params['sK'] = series
            params['sTS'] = season
            params['sTE'] = episode
        elif title:
            params['sK'] = title
        else:
            raise ValueError('Missing parameters series and season and episode or title')
        if year:
            params['sY'] = year
        logger.debug('Searching episode %r', params)
        subtitles = []
        while True:
            root = self.get('/search', params)
            if not int(root.find('pagination/results').text):
                logger.debug('No subtitle found')
                break
            if series and season and episode:
                subtitles.extend([PodnapisiSubtitle(language, int(s.find('id').text),
                                                    s.find('release').text.split() if s.find('release').text else [],
                                                    'n' in (s.find('flags').text or ''), s.find('url').text,
                                                    series=series, season=season, episode=episode,
                                                    year=s.find('year').text)
                                  for s in root.findall('subtitle')])
            elif title:
                subtitles.extend([PodnapisiSubtitle(language, int(s.find('id').text),
                                                    s.find('release').text.split() if s.find('release').text else [],
                                                    'n' in (s.find('flags').text or ''), s.find('url').text,
                                                    title=title, year=s.find('year').text)
                                  for s in root.findall('subtitle')])
            if int(root.find('pagination/current').text) >= int(root.find('pagination/count').text):
                break
            params['page'] = int(root.find('pagination/current').text) + 1
        return subtitles

    def list_subtitles(self, video, languages):
        if isinstance(video, Episode):
            return [s for l in languages for s in self.query(l, series=video.series, season=video.season,
                                                             episode=video.episode, year=video.year)]
        elif isinstance(video, Movie):
            return [s for l in languages for s in self.query(l, title=video.title, year=video.year)]

    def download_subtitle(self, subtitle):
        soup = self.get(subtitle.page_link[38:], is_xml=False)
        link = soup.find('a', href=self.link_re)
        if not link:
            raise ProviderError('Cannot find the download link')
        r = self.session.get(self.server + self.link_re.match(link['href']).group('link'), timeout=10)
        if r.status_code != 200:
            raise ProviderError('Request failed with status code %d' % r.status_code)
        with zipfile.ZipFile(io.BytesIO(r.content)) as zf:
            if len(zf.namelist()) > 1:
                raise ProviderError('More than one file to unzip')
            subtitle.content = fix_line_endings(zf.read(zf.namelist()[0]))

########NEW FILE########
__FILENAME__ = thesubdb
# -*- coding: utf-8 -*-
from __future__ import unicode_literals
import logging
import babelfish
import requests
from . import Provider
from .. import __version__
from ..exceptions import ProviderError
from ..subtitle import Subtitle, fix_line_endings


logger = logging.getLogger(__name__)


class TheSubDBSubtitle(Subtitle):
    provider_name = 'thesubdb'

    def __init__(self, language, hash):  # @ReservedAssignment
        super(TheSubDBSubtitle, self).__init__(language)
        self.hash = hash

    def compute_matches(self, video):
        matches = set()
        # hash
        if 'thesubdb' in video.hashes and video.hashes['thesubdb'] == self.hash:
            matches.add('hash')
        return matches


class TheSubDBProvider(Provider):
    languages = {babelfish.Language.fromalpha2(l) for l in ['en', 'es', 'fr', 'it', 'nl', 'pl', 'pt', 'ro', 'sv', 'tr']}
    required_hash = 'thesubdb'

    def initialize(self):
        self.session = requests.Session()
        self.session.headers = {'User-Agent': 'SubDB/1.0 (subliminal/%s; https://github.com/Diaoul/subliminal)' %
                                __version__.split('-')[0]}

    def terminate(self):
        self.session.close()

    def get(self, params):
        """Make a GET request on the server with the given parameters

        :param params: params of the request
        :return: the response
        :rtype: :class:`requests.Response`

        """
        return self.session.get('http://api.thesubdb.com', params=params, timeout=10)

    def query(self, hash):  # @ReservedAssignment
        params = {'action': 'search', 'hash': hash}
        logger.debug('Searching subtitles %r', params)
        r = self.get(params)
        if r.status_code == 404:
            logger.debug('No subtitle found')
            return []
        elif r.status_code != 200:
            raise ProviderError('Request failed with status code %d' % r.status_code)
        return [TheSubDBSubtitle(language, hash) for language in
                {babelfish.Language.fromalpha2(l) for l in r.content.decode('utf-8').split(',')}]

    def list_subtitles(self, video, languages):
        return [s for s in self.query(video.hashes['thesubdb']) if s.language in languages]

    def download_subtitle(self, subtitle):
        params = {'action': 'download', 'hash': subtitle.hash, 'language': subtitle.language.alpha2}
        r = self.get(params)
        if r.status_code != 200:
            raise ProviderError('Request failed with status code %d' % r.status_code)
        subtitle.content = fix_line_endings(r.content)

########NEW FILE########
__FILENAME__ = tvsubtitles
# -*- coding: utf-8 -*-
from __future__ import unicode_literals
import io
import logging
import re
import zipfile
import babelfish
import bs4
import requests
from . import Provider
from .. import __version__
from ..cache import region, SHOW_EXPIRATION_TIME, EPISODE_EXPIRATION_TIME
from ..exceptions import ProviderError
from ..subtitle import Subtitle, fix_line_endings, compute_guess_properties_matches
from ..video import Episode


logger = logging.getLogger(__name__)
babelfish.language_converters.register('tvsubtitles = subliminal.converters.tvsubtitles:TVsubtitlesConverter')


class TVsubtitlesSubtitle(Subtitle):
    provider_name = 'tvsubtitles'

    def __init__(self, language, series, season, episode, year, id, rip, release, page_link):  # @ReservedAssignment
        super(TVsubtitlesSubtitle, self).__init__(language, page_link=page_link)
        self.series = series
        self.season = season
        self.episode = episode
        self.year = year
        self.id = id
        self.rip = rip
        self.release = release

    def compute_matches(self, video):
        matches = set()
        # series
        if video.series and self.series == video.series:
            matches.add('series')
        # season
        if video.season and self.season == video.season:
            matches.add('season')
        # episode
        if video.episode and self.episode == video.episode:
            matches.add('episode')
        # year
        if self.year == video.year:
            matches.add('year')
        # release_group
        if video.release_group and self.release and video.release_group.lower() in self.release.lower():
            matches.add('release_group')
        """
        # video_codec
        if video.video_codec and self.release and (video.video_codec in self.release.lower()
                                                   or video.video_codec == 'h264' and 'x264' in self.release.lower()):
            matches.add('video_codec')
        # resolution
        if video.resolution and self.rip and video.resolution in self.rip.lower():
            matches.add('resolution')
        # format
        if video.format and self.rip and video.format in self.rip.lower():
            matches.add('format')
        """
        # we don't have the complete filename, so we need to guess the matches separately
        # guess video_codec (videoCodec in guessit)
        matches |= compute_guess_properties_matches(video, self.release, 'videoCodec')
        # guess resolution (screenSize in guessit)
        matches |= compute_guess_properties_matches(video, self.rip, 'screenSize')
        # guess format
        matches |= compute_guess_properties_matches(video, self.rip, 'format')
        return matches


class TVsubtitlesProvider(Provider):
    languages = {babelfish.Language('por', 'BR')} | {babelfish.Language(l)
                 for l in ['ara', 'bul', 'ces', 'dan', 'deu', 'ell', 'eng', 'fin', 'fra', 'hun', 'ita', 'jpn', 'kor',
                           'nld', 'pol', 'por', 'ron', 'rus', 'spa', 'swe', 'tur', 'ukr', 'zho']}
    video_types = (Episode,)
    server = 'http://www.tvsubtitles.net'
    episode_id_re = re.compile('^episode-\d+\.html$')
    subtitle_re = re.compile('^\/subtitle-\d+\.html$')
    link_re = re.compile('^(?P<series>[A-Za-z0-9 \'.]+).*\((?P<first_year>\d{4})-\d{4}\)$')

    def initialize(self):
        self.session = requests.Session()
        self.session.headers = {'User-Agent': 'Subliminal/%s' % __version__.split('-')[0]}

    def terminate(self):
        self.session.close()

    def request(self, url, params=None, data=None, method='GET'):
        """Make a `method` request on `url` with the given parameters

        :param string url: part of the URL to reach with the leading slash
        :param dict params: params of the request
        :param dict data: data of the request
        :param string method: method of the request
        :return: the response
        :rtype: :class:`bs4.BeautifulSoup`

        """
        r = self.session.request(method, self.server + url, params=params, data=data, timeout=10)
        if r.status_code != 200:
            raise ProviderError('Request failed with status code %d' % r.status_code)
        return bs4.BeautifulSoup(r.content, ['permissive'])

    @region.cache_on_arguments(expiration_time=SHOW_EXPIRATION_TIME)
    def find_show_id(self, series, year=None):
        """Find the show id from the `series` with optional `year`

        :param string series: series of the episode in lowercase
        :param year: year of the series, if any
        :type year: int or None
        :return: the show id, if any
        :rtype: int or None

        """
        data = {'q': series}
        logger.debug('Searching series %r', data)
        soup = self.request('/search.php', data=data, method='POST')
        links = soup.select('div.left li div a[href^="/tvshow-"]')
        if not links:
            logger.info('Series %r not found', series)
            return None
        matched_links = [link for link in links if self.link_re.match(link.string)]
        for link in matched_links:  # first pass with exact match on series
            match = self.link_re.match(link.string)
            if match.group('series').lower().replace('.', ' ').strip() == series:
                if year is not None and int(match.group('first_year')) != year:
                    continue
                return int(link['href'][8:-5])
        for link in matched_links:  # less selective second pass
            match = self.link_re.match(link.string)
            if match.group('series').lower().replace('.', ' ').strip().startswith(series):
                if year is not None and int(match.group('first_year')) != year:
                    continue
                return int(link['href'][8:-5])
        return None

    @region.cache_on_arguments(expiration_time=EPISODE_EXPIRATION_TIME)
    def find_episode_ids(self, show_id, season):
        """Find episode ids from the show id and the season

        :param int show_id: show id
        :param int season: season of the episode
        :return: episode ids per episode number
        :rtype: dict

        """
        params = {'show_id': show_id, 'season': season}
        logger.debug('Searching episodes %r', params)
        soup = self.request('/tvshow-{show_id}-{season}.html'.format(**params))
        episode_ids = {}
        for row in soup.select('table#table5 tr'):
            if not row('a', href=self.episode_id_re):
                continue
            cells = row('td')
            episode_ids[int(cells[0].string.split('x')[1])] = int(cells[1].a['href'][8:-5])
        return episode_ids

    def query(self, series, season, episode, year=None):
        show_id = self.find_show_id(series.lower(), year)
        if show_id is None:
            return []
        episode_ids = self.find_episode_ids(show_id, season)
        if episode not in episode_ids:
            logger.info('Episode %d not found', episode)
            return []
        params = {'episode_id': episode_ids[episode]}
        logger.debug('Searching episode %r', params)
        link = '/episode-{episode_id}.html'.format(**params)
        soup = self.request(link)
        return [TVsubtitlesSubtitle(babelfish.Language.fromtvsubtitles(row.h5.img['src'][13:-4]), series, season,
                                    episode, year if year and show_id != self.find_show_id(series.lower()) else None,
                                    int(row['href'][10:-5]), row.find('p', title='rip').text.strip() or None,
                                    row.find('p', title='release').text.strip() or None,
                                    self.server + '/subtitle-%d.html' % int(row['href'][10:-5]))
                for row in soup('a', href=self.subtitle_re)]

    def list_subtitles(self, video, languages):
        return [s for s in self.query(video.series, video.season, video.episode, video.year) if s.language in languages]

    def download_subtitle(self, subtitle):
        r = self.session.get(self.server + '/download-{subtitle_id}.html'.format(subtitle_id=subtitle.id),
                             timeout=10)
        if r.status_code != 200:
            raise ProviderError('Request failed with status code %d' % r.status_code)
        with zipfile.ZipFile(io.BytesIO(r.content)) as zf:
            if len(zf.namelist()) > 1:
                raise ProviderError('More than one file to unzip')
            subtitle.content = fix_line_endings(zf.read(zf.namelist()[0]))

########NEW FILE########
__FILENAME__ = score
#!/usr/bin/env python
# -*- coding: utf-8 -*-
from __future__ import print_function, unicode_literals
from sympy import Eq, symbols, solve


# Symbols
release_group, resolution, format, video_codec, audio_codec = symbols('release_group resolution format video_codec audio_codec')
imdb_id, hash, title, series, tvdb_id, season, episode = symbols('imdb_id hash title series tvdb_id season episode')  # @ReservedAssignment
year = symbols('year')


def get_episode_equations():
    """Get the score equations for a :class:`~subliminal.video.Episode`

    The equations are the following:

    1. hash = resolution + format + video_codec + audio_codec + series + season + episode + year + release_group
    2. series = resolution + video_codec + audio_codec + season + episode + release_group + 1
    3. year = series
    4. tvdb_id = series + year
    5. season = resolution + video_codec + audio_codec + 1
    6. imdb_id = series + season + episode + year
    7. format = video_codec + audio_codec
    8. resolution = video_codec
    9. video_codec = 2 * audio_codec
    10. title = season + episode
    11. season = episode
    12. release_group = season
    13. audio_codec = 1

    :return: the score equations for an episode
    :rtype: list of :class:`sympy.Eq`

    """
    equations = []
    equations.append(Eq(hash, resolution + format + video_codec + audio_codec + series + season + episode + year + release_group))
    equations.append(Eq(series, resolution + video_codec + audio_codec + season + episode + release_group + 1))
    equations.append(Eq(series, year))
    equations.append(Eq(tvdb_id, series + year))
    equations.append(Eq(season, resolution + video_codec + audio_codec + 1))
    equations.append(Eq(imdb_id, series + season + episode + year))
    equations.append(Eq(format, video_codec + audio_codec))
    equations.append(Eq(resolution, video_codec))
    equations.append(Eq(video_codec, 2 * audio_codec))
    equations.append(Eq(title, season + episode))
    equations.append(Eq(season, episode))
    equations.append(Eq(release_group, season))
    equations.append(Eq(audio_codec, 1))
    return equations


def get_movie_equations():
    """Get the score equations for a :class:`~subliminal.video.Movie`

    The equations are the following:

    1. hash = resolution + format + video_codec + audio_codec + title + year + release_group
    2. imdb_id = hash
    3. resolution = video_codec
    4. video_codec = 2 * audio_codec
    5. format = video_codec + audio_codec
    6. title = resolution + video_codec + audio_codec + year + 1
    7. release_group = resolution + video_codec + audio_codec + 1
    8. year = release_group + 1
    9. audio_codec = 1

    :return: the score equations for a movie
    :rtype: list of :class:`sympy.Eq`

    """
    equations = []
    equations.append(Eq(hash, resolution + format + video_codec + audio_codec + title + year + release_group))
    equations.append(Eq(imdb_id, hash))
    equations.append(Eq(resolution, video_codec))
    equations.append(Eq(video_codec, 2 * audio_codec))
    equations.append(Eq(format, video_codec + audio_codec))
    equations.append(Eq(title, resolution + video_codec + audio_codec + year + 1))
    equations.append(Eq(video_codec, 2 * audio_codec))
    equations.append(Eq(release_group, resolution + video_codec + audio_codec + 1))
    equations.append(Eq(year, release_group + 1))
    equations.append(Eq(audio_codec, 1))
    return equations


if __name__ == '__main__':
    print(solve(get_episode_equations(), [release_group, resolution, format, video_codec, audio_codec, imdb_id,
                                          hash, series, tvdb_id, season, episode, title, year]))
    print(solve(get_movie_equations(), [release_group, resolution, format, video_codec, audio_codec, imdb_id,
                                        hash, title, year]))

########NEW FILE########
__FILENAME__ = subtitle
# -*- coding: utf-8 -*-
from __future__ import unicode_literals
import logging
import os.path
import babelfish
import chardet
import guessit.matchtree
import guessit.transfo
import pysrt
from .video import Episode, Movie


logger = logging.getLogger(__name__)


class Subtitle(object):
    """Base class for subtitle

    :param language: language of the subtitle
    :type language: :class:`babelfish.Language`
    :param bool hearing_impaired: `True` if the subtitle is hearing impaired, `False` otherwise
    :param page_link: link to the web page from which the subtitle can be downloaded, if any
    :type page_link: string or None

    """
    def __init__(self, language, hearing_impaired=False, page_link=None):
        self.language = language
        self.hearing_impaired = hearing_impaired
        self.page_link = page_link

        #: Content as bytes
        self.content = None

        #: Encoding to decode with when accessing :attr:`text`
        self.encoding = None

    @property
    def guessed_encoding(self):
        """Guessed encoding using the language, falling back on chardet"""
        # always try utf-8 first
        encodings = ['utf-8']

        # add language-specific encodings
        if self.language.alpha3 == 'zho':
            encodings.extend(['gb18030', 'big5'])
        elif self.language.alpha3 == 'jpn':
            encodings.append('shift-jis')
        elif self.language.alpha3 == 'ara':
            encodings.append('windows-1256')
        elif self.language.alpha3 == 'heb':
            encodings.append('windows-1255')
        elif self.language.alpha3 == 'tur':
            encodings.extend(['iso-8859-9', 'windows-1254'])
        else:
            encodings.append('latin-1')

        # try to decode
        for encoding in encodings:
            try:
                self.content.decode(encoding)
                return encoding
            except UnicodeDecodeError:
                pass

        # fallback on chardet
        logger.warning('Could not decode content with encodings %r', encodings)
        return chardet.detect(self.content)['encoding']

    @property
    def text(self):
        """Content as string

        If :attr:`encoding` is None, the encoding is guessed with :attr:`guessed_encoding`

        """
        if not self.content:
            return ''
        return self.content.decode(self.encoding or self.guessed_encoding, errors='replace')

    @property
    def is_valid(self):
        """Check if a subtitle text is a valid SubRip format"""
        try:
            pysrt.from_string(self.text, error_handling=pysrt.ERROR_RAISE)
            return True
        except pysrt.Error as e:
            if e.args[0] > 80:
                return True
        except:
            logger.exception('Unexpected error when validating subtitle')
        return False

    def compute_matches(self, video):
        """Compute the matches of the subtitle against the `video`

        :param video: the video to compute the matches against
        :type video: :class:`~subliminal.video.Video`
        :return: matches of the subtitle
        :rtype: set

        """
        raise NotImplementedError

    def compute_score(self, video):
        """Compute the score of the subtitle against the `video`

        There are equivalent matches so that a provider can match one element or its equivalent. This is
        to give all provider a chance to have a score in the same range without hurting quality.

        * Matching :class:`~subliminal.video.Video`'s `hashes` is equivalent to matching everything else
        * Matching :class:`~subliminal.video.Episode`'s `season` and `episode`
          is equivalent to matching :class:`~subliminal.video.Episode`'s `title`
        * Matching :class:`~subliminal.video.Episode`'s `tvdb_id` is equivalent to matching
          :class:`~subliminal.video.Episode`'s `series`

        :param video: the video to compute the score against
        :type video: :class:`~subliminal.video.Video`
        :return: score of the subtitle
        :rtype: int

        """
        score = 0
        # compute matches
        initial_matches = self.compute_matches(video)
        matches = initial_matches.copy()
        # hash is the perfect match
        if 'hash' in matches:
            score = video.scores['hash']
        else:
            # remove equivalences
            if isinstance(video, Episode):
                if 'imdb_id' in matches:
                    matches -= {'series', 'tvdb_id', 'season', 'episode', 'title', 'year'}
                if 'tvdb_id' in matches:
                    matches -= {'series', 'year'}
                if 'title' in matches:
                    matches -= {'season', 'episode'}
            # add other scores
            score += sum((video.scores[match] for match in matches))
        logger.info('Computed score %d with matches %r', score, initial_matches)
        return score

    def __repr__(self):
        return '<%s [%s]>' % (self.__class__.__name__, self.language)


def get_subtitle_path(video_path, language=None):
    """Create the subtitle path from the given `video_path` and `language`

    :param string video_path: path to the video
    :param language: language of the subtitle to put in the path
    :type language: :class:`babelfish.Language` or None
    :return: path of the subtitle
    :rtype: string

    """
    subtitle_path = os.path.splitext(video_path)[0]
    if language is not None:
        try:
            return subtitle_path + '.%s.%s' % (language.alpha2, 'srt')
        except babelfish.LanguageConvertError:
            return subtitle_path + '.%s.%s' % (language.alpha3, 'srt')
    return subtitle_path + '.srt'


def compute_guess_matches(video, guess):
    """Compute matches between a `video` and a `guess`

    :param video: the video to compute the matches on
    :type video: :class:`~subliminal.video.Video`
    :param guess: the guess to compute the matches on
    :type guess: :class:`guessit.Guess`
    :return: matches of the `guess`
    :rtype: set

    """
    matches = set()
    if isinstance(video, Episode):
        # series
        if video.series and 'series' in guess and guess['series'].lower() == video.series.lower():
            matches.add('series')
        # season
        if video.season and 'seasonNumber' in guess and guess['seasonNumber'] == video.season:
            matches.add('season')
        # episode
        if video.episode and 'episodeNumber' in guess and guess['episodeNumber'] == video.episode:
            matches.add('episode')
        # year
        if video.year == guess.get('year'):  # count "no year" as an information
            matches.add('year')
    elif isinstance(video, Movie):
        # year
        if video.year and 'year' in guess and guess['year'] == video.year:
            matches.add('year')
    # title
    if video.title and 'title' in guess and guess['title'].lower() == video.title.lower():
        matches.add('title')
    # release group
    if video.release_group and 'releaseGroup' in guess and guess['releaseGroup'].lower() == video.release_group.lower():
        matches.add('release_group')
    # screen size
    if video.resolution and 'screenSize' in guess and guess['screenSize'] == video.resolution:
        matches.add('resolution')
    # format
    if video.format and 'format' in guess and guess['format'].lower() == video.format.lower():
        matches.add('format')
    # video codec
    if video.video_codec and 'videoCodec' in guess and guess['videoCodec'] == video.video_codec:
        matches.add('video_codec')
    # audio codec
    if video.audio_codec and 'audioCodec' in guess and guess['audioCodec'] == video.audio_codec:
        matches.add('audio_codec')
    return matches


def compute_guess_properties_matches(video, string, propertytype):
    """Compute matches between a `video` and properties of a certain property type

    :param video: the video to compute the matches on
    :type video: :class:`~subliminal.video.Video`
    :param string string: the string to check for a certain property type
    :param string propertytype: the type of property to check (as defined in guessit)
    :return: matches of a certain property type (but will only be 1 match because we are checking for 1 property type)
    :rtype: set

    Supported property types: result of guessit.transfo.guess_properties.GuessProperties().supported_properties()
    [u'audioProfile',
    u'videoCodec',
    u'container',
    u'format',
    u'episodeFormat',
    u'videoApi',
    u'screenSize',
    u'videoProfile',
    u'audioChannels',
    u'other',
    u'audioCodec']

    """
    matches = set()
    # We only check for the property types relevant for us
    if propertytype == 'screenSize' and video.resolution:
        for prop in guess_properties(string, propertytype):
            if prop.lower() == video.resolution.lower():
                matches.add('resolution')
    elif propertytype == 'format' and video.format:
        for prop in guess_properties(string, propertytype):
            if prop.lower() == video.format.lower():
                matches.add('format')
    elif propertytype == 'videoCodec' and video.video_codec:
        for prop in guess_properties(string, propertytype):
            if prop.lower() == video.video_codec.lower():
                matches.add('video_codec')
    elif propertytype == 'audioCodec' and video.audio_codec:
        for prop in guess_properties(string, propertytype):
            if prop.lower() == video.audio_codec.lower():
                matches.add('audio_codec')
    return matches


def guess_properties(string, propertytype):
    properties = set()
    if string:
        tree = guessit.matchtree.MatchTree(string)
        guessit.transfo.guess_properties.GuessProperties().process(tree)
        properties = set(n.guess[propertytype] for n in tree.nodes() if propertytype in n.guess)
    return properties


def fix_line_endings(content):
    """Fix line ending of `content` by changing it to \n

    :param bytes content: content of the subtitle
    :return: the content with fixed line endings
    :rtype: bytes

    """
    return content.replace(b'\r\n', b'\n').replace(b'\r', b'\n')

########NEW FILE########
__FILENAME__ = common
# -*- coding: utf-8 -*-
from __future__ import unicode_literals
from subliminal import Movie, Episode


MOVIES = [Movie('Man of Steel (2013)/man.of.steel.2013.720p.bluray.x264-felony.mkv', 'Man of Steel',
                format='BluRay', release_group='felony', resolution='720p', video_codec='h264', audio_codec='DTS',
                imdb_id=770828, size=7033732714, year=2013,
                hashes={'opensubtitles': '5b8f8f4e41ccb21e', 'thesubdb': 'ad32876133355929d814457537e12dc2'})]

EPISODES = [Episode('The Big Bang Theory/Season 07/The.Big.Bang.Theory.S07E05.720p.HDTV.X264-DIMENSION.mkv',
                    'The Big Bang Theory', 7, 5, format='HDTV', release_group='DIMENSION', resolution='720p',
                    video_codec='h264', audio_codec='AC3', imdb_id=3229392, size=501910737,
                    title='The Workplace Proximity', year=2007, tvdb_id=80379,
                    hashes={'opensubtitles': '6878b3ef7c1bd19e', 'thesubdb': '9dbbfb7ba81c9a6237237dae8589fccc'}),
            Episode('Game of Thrones/Season 03/Game.of.Thrones.S03E10.Mhysa.720p.WEB-DL.DD5.1.H.264-NTb.mkv',
                    'Game of Thrones', 3, 10, format='WEB-DL', release_group='NTb', resolution='720p',
                    video_codec='h264', audio_codec='AC3', imdb_id=2178796, size=2142810931, title='Mhysa',
                    tvdb_id=121361,
                    hashes={'opensubtitles': 'b850baa096976c22', 'thesubdb': 'b1f899c77f4c960b84b8dbf840d4e42d'}),
            Episode('Dallas.S01E03.mkv', 'Dallas', 1, 3),
            Episode('Dallas.2012.S01E03.mkv', 'Dallas', 1, 3, year=2012)]

########NEW FILE########
__FILENAME__ = test_providers
#!/usr/bin/env python
# -*- coding: utf-8 -*-
from __future__ import unicode_literals
import os
from unittest import TestCase, TestSuite, TestLoader, TextTestRunner
from babelfish import Language
from subliminal import provider_manager
from subliminal.tests.common import MOVIES, EPISODES


class ProviderTestCase(TestCase):
    provider_name = ''

    def setUp(self):
        self.Provider = provider_manager[self.provider_name]


class Addic7edProviderTestCase(ProviderTestCase):
    provider_name = 'addic7ed'

    def test_find_show_id(self):
        with self.Provider() as provider:
            show_id = provider.find_show_id('the big bang')
        self.assertEqual(show_id, 126)

    def test_find_show_id_no_year(self):
        with self.Provider() as provider:
            show_id = provider.find_show_id('dallas')
        self.assertEqual(show_id, 802)

    def test_find_show_id_year(self):
        with self.Provider() as provider:
            show_id = provider.find_show_id('dallas', 2012)
        self.assertEqual(show_id, 2559)

    def test_find_show_id_error(self):
        with self.Provider() as provider:
            show_id = provider.find_show_id('the big how i met your mother')
        self.assertIsNone(show_id)

    def test_get_show_ids(self):
        with self.Provider() as provider:
            show_ids = provider.get_show_ids()
        self.assertIn('the big bang theory', show_ids)
        self.assertEqual(show_ids['the big bang theory'], 126)

    def test_get_show_ids_no_year(self):
        with self.Provider() as provider:
            show_ids = provider.get_show_ids()
        self.assertIn('dallas', show_ids)
        self.assertEqual(show_ids['dallas'], 802)

    def test_get_show_ids_year(self):
        with self.Provider() as provider:
            show_ids = provider.get_show_ids()
        self.assertIn('dallas (2012)', show_ids)
        self.assertEqual(show_ids['dallas (2012)'], 2559)

    def test_query_episode_0(self):
        video = EPISODES[0]
        languages = {Language('tur'), Language('rus'), Language('heb'), Language('ita'), Language('fra'),
                     Language('ron'), Language('nld'), Language('eng'), Language('deu'), Language('ell'),
                     Language('por', 'BR'), Language('bul'), Language('por'), Language('msa')}
        matches = {frozenset(['series', 'resolution', 'season']),
                   frozenset(['series', 'episode', 'season', 'title']),
                   frozenset(['series', 'release_group', 'season']),
                   frozenset(['series', 'episode', 'season', 'release_group', 'title']),
                   frozenset(['series', 'season']),
                   frozenset(['series', 'season', 'format'])}
        with self.Provider() as provider:
            subtitles = provider.query(video.series, video.season, video.year)
        self.assertEqual({frozenset(subtitle.compute_matches(video)) for subtitle in subtitles}, matches)
        self.assertEqual({subtitle.language for subtitle in subtitles}, languages)

    def test_query_episode_1(self):
        video = EPISODES[1]
        languages = {Language('ind'), Language('spa'), Language('hrv'), Language('ita'), Language('fra'),
                     Language('cat'), Language('ell'), Language('nld'), Language('eng'), Language('fas'),
                     Language('por'), Language('nor'), Language('deu'), Language('ron'), Language('por', 'BR'),
                     Language('bul')}
        matches = {frozenset(['series', 'episode', 'resolution', 'season', 'title', 'year']),
                   frozenset(['series', 'resolution', 'season', 'year']),
                   frozenset(['series', 'resolution', 'season', 'year', 'format']),
                   frozenset(['series', 'episode', 'season', 'title', 'year']),
                   frozenset(['series', 'episode', 'season', 'title', 'year', 'format']),
                   frozenset(['series', 'release_group', 'season', 'year']),
                   frozenset(['series', 'release_group', 'season', 'year', 'format']),
                   frozenset(['series', 'resolution', 'release_group', 'season', 'year']),
                   frozenset(['series', 'resolution', 'release_group', 'season', 'year', 'format']),
                   frozenset(['series', 'episode', 'season', 'release_group', 'title', 'year', 'format']),
                   frozenset(['series', 'season', 'year']),
                   frozenset(['series', 'season', 'year', 'format'])}
        with self.Provider() as provider:
            subtitles = provider.query(video.series, video.season, video.year)
        self.assertEqual({frozenset(subtitle.compute_matches(video)) for subtitle in subtitles}, matches)
        self.assertEqual({subtitle.language for subtitle in subtitles}, languages)

    def test_query_episode_year(self):
        video_no_year = EPISODES[2]
        video_year = EPISODES[3]
        with self.Provider() as provider:
            subtitles_no_year = provider.query(video_no_year.series, video_no_year.season, video_no_year.year)
            subtitles_year = provider.query(video_year.series, video_year.season, video_year.year)
        self.assertNotEqual(subtitles_no_year, subtitles_year)

    def test_list_subtitles(self):
        video = EPISODES[0]
        languages = {Language('eng'), Language('fra')}
        matches = {frozenset(['series', 'episode', 'season', 'release_group', 'title']),
                   frozenset(['series', 'episode', 'season', 'title'])}
        with self.Provider() as provider:
            subtitles = provider.list_subtitles(video, languages)
        self.assertEqual({frozenset(subtitle.compute_matches(video)) for subtitle in subtitles}, matches)
        self.assertEqual({subtitle.language for subtitle in subtitles}, languages)

    def test_download_subtitle(self):
        video = EPISODES[0]
        languages = {Language('eng'), Language('fra')}
        with self.Provider() as provider:
            subtitles = provider.list_subtitles(video, languages)
            provider.download_subtitle(subtitles[0])
        self.assertIsNotNone(subtitles[0].content)
        self.assertTrue(subtitles[0].is_valid)


class OpenSubtitlesProviderTestCase(ProviderTestCase):
    provider_name = 'opensubtitles'

    def test_query_movie_0_query(self):
        video = MOVIES[0]
        languages = {Language('eng')}
        matches = {frozenset([]),
                   frozenset(['imdb_id', 'resolution', 'title', 'year']),
                   frozenset(['imdb_id', 'resolution', 'title', 'year', 'format']),
                   frozenset(['imdb_id', 'title', 'year']),
                   frozenset(['imdb_id', 'title', 'year', 'format']),
                   frozenset(['imdb_id', 'video_codec', 'title', 'year', 'format']),
                   frozenset(['imdb_id', 'resolution', 'title', 'video_codec', 'year', 'format']),
                   frozenset(['imdb_id', 'title', 'year', 'video_codec', 'resolution', 'release_group', 'format'])}
        with self.Provider() as provider:
            subtitles = provider.query(languages, query=video.title)
        self.assertEqual({frozenset(subtitle.compute_matches(video)) for subtitle in subtitles}, matches)
        self.assertEqual({subtitle.language for subtitle in subtitles}, languages)

    def test_query_episode_0_query(self):
        video = EPISODES[0]
        languages = {Language('eng')}
        matches = {frozenset(['series', 'episode', 'season', 'imdb_id', 'format']),
                   frozenset(['series', 'imdb_id', 'video_codec', 'episode', 'season', 'format']),
                   frozenset(['episode', 'title', 'series', 'imdb_id', 'video_codec', 'season'])}
        with self.Provider() as provider:
            subtitles = provider.query(languages, query=os.path.split(video.name)[1])
        self.assertEqual({frozenset(subtitle.compute_matches(video)) for subtitle in subtitles}, matches)
        self.assertEqual({subtitle.language for subtitle in subtitles}, languages)

    def test_query_episode_year(self):
        video_no_year = EPISODES[2]
        video_year = EPISODES[3]
        languages = {Language('eng')}
        with self.Provider() as provider:
            subtitles_no_year = provider.query(languages, query=os.path.split(video_no_year.name)[1])
            subtitles_year = provider.query(languages, query=os.path.split(video_year.name)[1])
        self.assertNotEqual(subtitles_no_year, subtitles_year)

    def test_query_episode_1_query(self):
        video = EPISODES[1]
        languages = {Language('eng'), Language('fra')}
        matches = {frozenset(['episode', 'title', 'series', 'imdb_id', 'video_codec', 'season', 'year', 'format']),
                   frozenset(['series', 'imdb_id', 'video_codec', 'episode', 'season', 'year']),
                   frozenset(['episode', 'video_codec', 'series', 'imdb_id', 'resolution', 'season', 'year']),
                   frozenset(['series', 'imdb_id', 'resolution', 'episode', 'season', 'year']),
                   frozenset(['series', 'episode', 'season', 'imdb_id', 'year']),
                   frozenset(['series', 'episode', 'season', 'imdb_id', 'year', 'format'])}
        with self.Provider() as provider:
            subtitles = provider.query(languages, query=os.path.split(video.name)[1])
        self.assertEqual({frozenset(subtitle.compute_matches(video)) for subtitle in subtitles}, matches)
        self.assertEqual({subtitle.language for subtitle in subtitles}, languages)

    def test_query_movie_0_imdb_id(self):
        video = MOVIES[0]
        languages = {Language('eng'), Language('fra')}
        matches = {frozenset(['imdb_id', 'video_codec', 'title', 'year', 'format']),
                   frozenset(['imdb_id', 'resolution', 'title', 'video_codec', 'year']),
                   frozenset(['imdb_id', 'resolution', 'title', 'video_codec', 'year', 'format']),
                   frozenset(['imdb_id', 'title', 'year', 'video_codec', 'resolution', 'release_group', 'format']),
                   frozenset(['imdb_id', 'title', 'year']),
                   frozenset(['imdb_id', 'title', 'year', 'format']),
                   frozenset(['imdb_id', 'resolution', 'title', 'year']),
                   frozenset(['imdb_id', 'resolution', 'title', 'year', 'format'])}
        with self.Provider() as provider:
            subtitles = provider.query(languages, imdb_id=video.imdb_id)
        self.assertEqual({frozenset(subtitle.compute_matches(video)) for subtitle in subtitles}, matches)
        self.assertEqual({subtitle.language for subtitle in subtitles}, languages)

    def test_query_episode_0_imdb_id(self):
        video = EPISODES[0]
        languages = {Language('eng'), Language('fra')}
        matches = {frozenset(['series', 'episode', 'season', 'imdb_id', 'format']),
                   frozenset(['episode', 'release_group', 'video_codec', 'series', 'imdb_id', 'resolution', 'season', 'format']),
                   frozenset(['series', 'imdb_id', 'video_codec', 'episode', 'season', 'format']),
                   frozenset(['episode', 'title', 'series', 'imdb_id', 'video_codec', 'season'])}
        with self.Provider() as provider:
            subtitles = provider.query(languages, imdb_id=video.imdb_id)
        self.assertEqual({frozenset(subtitle.compute_matches(video)) for subtitle in subtitles}, matches)
        self.assertEqual({subtitle.language for subtitle in subtitles}, languages)

    def test_query_movie_0_hash(self):
        video = MOVIES[0]
        languages = {Language('eng')}
        matches = {frozenset(['hash', 'title', 'video_codec', 'year', 'resolution', 'imdb_id', 'format']),
                   frozenset(['hash', 'title', 'video_codec', 'year', 'resolution', 'release_group', 'imdb_id', 'format']),
                   frozenset(['year', 'video_codec', 'imdb_id', 'hash', 'title', 'format']),
                   frozenset([]),
                   frozenset(['year', 'resolution', 'imdb_id', 'hash', 'title', 'format']),
                   frozenset(['year', 'imdb_id', 'hash', 'title']),
                   frozenset(['year', 'imdb_id', 'hash', 'title', 'format'])}
        with self.Provider() as provider:
            subtitles = provider.query(languages, hash=video.hashes['opensubtitles'], size=video.size)
        self.assertEqual({frozenset(subtitle.compute_matches(video)) for subtitle in subtitles}, matches)
        self.assertEqual({subtitle.language for subtitle in subtitles}, languages)

    def test_query_episode_0_hash(self):
        video = EPISODES[0]
        languages = {Language('eng')}
        matches = {frozenset(['series', 'hash', 'format']),
                   frozenset(['episode', 'season', 'series', 'imdb_id', 'video_codec', 'hash', 'format']),
                   frozenset(['series', 'episode', 'season', 'hash', 'imdb_id', 'format']),
                   frozenset(['series', 'resolution', 'hash', 'video_codec', 'format'])}
        with self.Provider() as provider:
            subtitles = provider.query(languages, hash=video.hashes['opensubtitles'], size=video.size)
        self.assertEqual({frozenset(subtitle.compute_matches(video)) for subtitle in subtitles}, matches)
        self.assertEqual({subtitle.language for subtitle in subtitles}, languages)

    def test_list_subtitles(self):
        video = MOVIES[0]
        languages = {Language('eng'), Language('fra')}
        matches = {frozenset(['title', 'video_codec', 'year', 'resolution', 'release_group', 'imdb_id', 'format']),
                   frozenset(['imdb_id', 'year', 'title']),
                   frozenset(['imdb_id', 'year', 'title', 'format']),
                   frozenset(['year', 'video_codec', 'imdb_id', 'resolution', 'title']),
                   frozenset(['year', 'video_codec', 'imdb_id', 'resolution', 'title', 'format']),
                   frozenset(['hash', 'title', 'video_codec', 'year', 'resolution', 'release_group', 'imdb_id', 'format']),
                   frozenset(['year', 'video_codec', 'imdb_id', 'hash', 'title', 'format']),
                   frozenset([]),
                   frozenset(['year', 'resolution', 'imdb_id', 'hash', 'title', 'format']),
                   frozenset(['hash', 'title', 'video_codec', 'year', 'resolution', 'imdb_id', 'format']),
                   frozenset(['year', 'imdb_id', 'hash', 'title']),
                   frozenset(['year', 'imdb_id', 'hash', 'title', 'format']),
                   frozenset(['video_codec', 'imdb_id', 'year', 'title', 'format']),
                   frozenset(['year', 'imdb_id', 'resolution', 'title']),
                   frozenset(['year', 'imdb_id', 'resolution', 'title', 'format'])}
        with self.Provider() as provider:
            subtitles = provider.list_subtitles(video, languages)
        self.assertEqual({frozenset(subtitle.compute_matches(video)) for subtitle in subtitles}, matches)
        self.assertEqual({subtitle.language for subtitle in subtitles}, languages)

    def test_download_subtitle(self):
        video = MOVIES[0]
        languages = {Language('eng'), Language('fra')}
        with self.Provider() as provider:
            subtitles = provider.list_subtitles(video, languages)
            provider.download_subtitle(subtitles[0])
        self.assertIsNotNone(subtitles[0].content)
        self.assertTrue(subtitles[0].is_valid)


class PodnapisiProviderTestCase(ProviderTestCase):
    provider_name = 'podnapisi'

    def test_query_movie_0(self):
        video = MOVIES[0]
        language = Language('eng')
        matches = {frozenset(['video_codec', 'title', 'resolution', 'year']),
                   frozenset(['title', 'resolution', 'year']),
                   frozenset(['video_codec', 'title', 'year']),
                   frozenset(['title', 'year']),
                   frozenset(['title']),
                   frozenset(['video_codec', 'title', 'resolution', 'release_group', 'year', 'format']),
                   frozenset(['video_codec', 'title', 'resolution', 'audio_codec', 'year', 'format'])}
        with self.Provider() as provider:
            subtitles = provider.query(language, title=video.title, year=video.year)
        self.assertEqual({frozenset(subtitle.compute_matches(video)) for subtitle in subtitles}, matches)
        self.assertEqual({subtitle.language for subtitle in subtitles}, {language})

    def test_query_episode_0(self):
        video = EPISODES[0]
        language = Language('eng')
        matches = {frozenset(['episode', 'series', 'season', 'video_codec', 'resolution', 'release_group', 'format']),
                   frozenset(['season', 'video_codec', 'episode', 'resolution', 'series'])}
        with self.Provider() as provider:
            subtitles = provider.query(language, series=video.series, season=video.season, episode=video.episode,
                                       year=video.year)
        self.assertEqual({frozenset(subtitle.compute_matches(video)) for subtitle in subtitles}, matches)
        self.assertEqual({subtitle.language for subtitle in subtitles}, {language})

    def test_query_episode_1(self):
        video = EPISODES[1]
        language = Language('eng')
        matches = {frozenset(['episode', 'release_group', 'series', 'video_codec', 'resolution', 'season', 'year', 'format']),
                   frozenset(['episode', 'series', 'video_codec', 'resolution', 'season', 'year']),
                   frozenset(['season', 'video_codec', 'episode', 'series', 'year'])}
        with self.Provider() as provider:
            subtitles = provider.query(language, series=video.series, season=video.season, episode=video.episode,
                                       year=video.year)
        self.assertEqual({frozenset(subtitle.compute_matches(video)) for subtitle in subtitles}, matches)
        self.assertEqual({subtitle.language for subtitle in subtitles}, {language})

    def test_list_subtitles(self):
        video = MOVIES[0]
        languages = {Language('eng'), Language('fra')}
        matches = {frozenset(['video_codec', 'title', 'resolution', 'year']),
                   frozenset(['title', 'resolution', 'year']),
                   frozenset(['video_codec', 'title', 'year']),
                   frozenset(['video_codec', 'title', 'year', 'format']),
                   frozenset(['title', 'year']),
                   frozenset(['title']),
                   frozenset(['video_codec', 'title', 'resolution', 'release_group', 'year', 'format']),
                   frozenset(['video_codec', 'title', 'resolution', 'audio_codec', 'year', 'format'])}
        with self.Provider() as provider:
            subtitles = provider.list_subtitles(video, languages)
        self.assertEqual({frozenset(subtitle.compute_matches(video)) for subtitle in subtitles}, matches)
        self.assertEqual({subtitle.language for subtitle in subtitles}, languages)

    def test_download_subtitle(self):
        video = MOVIES[0]
        languages = {Language('eng'), Language('fra')}
        with self.Provider() as provider:
            subtitles = provider.list_subtitles(video, languages)
            provider.download_subtitle(subtitles[0])
        self.assertIsNotNone(subtitles[0].content)
        self.assertTrue(subtitles[0].is_valid)


class TheSubDBProviderTestCase(ProviderTestCase):
    provider_name = 'thesubdb'

    def test_query_episode_0(self):
        video = EPISODES[0]
        languages = {Language('eng'), Language('spa'), Language('por')}
        matches = {frozenset(['hash'])}
        with self.Provider() as provider:
            subtitles = provider.query(video.hashes['thesubdb'])
        self.assertEqual({frozenset(subtitle.compute_matches(video)) for subtitle in subtitles}, matches)
        self.assertEqual({subtitle.language for subtitle in subtitles}, languages)

    def test_query_episode_1(self):
        video = EPISODES[1]
        languages = {Language('eng'), Language('por')}
        matches = {frozenset(['hash'])}
        with self.Provider() as provider:
            subtitles = provider.query(video.hashes['thesubdb'])
        self.assertEqual({frozenset(subtitle.compute_matches(video)) for subtitle in subtitles}, matches)
        self.assertEqual({subtitle.language for subtitle in subtitles}, languages)

    def test_list_subtitles(self):
        video = MOVIES[0]
        languages = {Language('eng'), Language('por')}
        matches = {frozenset(['hash'])}
        with self.Provider() as provider:
            subtitles = provider.list_subtitles(video, languages)
        self.assertEqual({frozenset(subtitle.compute_matches(video)) for subtitle in subtitles}, matches)
        self.assertEqual({subtitle.language for subtitle in subtitles}, languages)

    def test_download_subtitle(self):
        video = MOVIES[0]
        languages = {Language('eng'), Language('por')}
        with self.Provider() as provider:
            subtitles = provider.list_subtitles(video, languages)
            provider.download_subtitle(subtitles[0])
            provider.download_subtitle(subtitles[1])
        self.assertIsNotNone(subtitles[0].content)
        self.assertTrue(subtitles[0].is_valid)


class TVsubtitlesProviderTestCase(ProviderTestCase):
    provider_name = 'tvsubtitles'

    def test_find_show_id(self):
        with self.Provider() as provider:
            show_id = provider.find_show_id('the big bang')
        self.assertEqual(show_id, 154)

    def test_find_show_id_ambiguous(self):
        with self.Provider() as provider:
            show_id = provider.find_show_id('new girl')
        self.assertEqual(show_id, 977)

    def test_find_show_id_no_dots(self):
        with self.Provider() as provider:
            show_id = provider.find_show_id('marvel\'s agents of s h i e l d')
        self.assertEqual(show_id, 1340)

    def test_find_show_id_no_year_dallas(self):
        with self.Provider() as provider:
            show_id = provider.find_show_id('dallas')
        self.assertEqual(show_id, 646)

    def test_find_show_id_no_year_house_of_cards(self):
        with self.Provider() as provider:
            show_id = provider.find_show_id('house of cards')
        self.assertEqual(show_id, 352)

    def test_find_show_id_year_dallas(self):
        with self.Provider() as provider:
            show_id = provider.find_show_id('dallas', 2012)
        self.assertEqual(show_id, 1127)

    def test_find_show_id_year_house_of_cards(self):
        with self.Provider() as provider:
            show_id = provider.find_show_id('house of cards', 2013)
        self.assertEqual(show_id, 1246)

    def test_find_show_id_error(self):
        with self.Provider() as provider:
            show_id = provider.find_show_id('the big gaming')
        self.assertIsNone(show_id)

    def test_find_episode_ids(self):
        with self.Provider() as provider:
            episode_ids = provider.find_episode_ids(154, 5)
        self.assertEqual(set(episode_ids.keys()), set(range(1, 25)))

    def test_query_episode_0(self):
        video = EPISODES[0]
        languages = {Language('fra'), Language('por'), Language('hun'), Language('ron'), Language('eng')}
        matches = {frozenset(['series', 'episode', 'season', 'video_codec', 'format']),
                   frozenset(['series', 'episode', 'season', 'format'])}
        with self.Provider() as provider:
            subtitles = provider.query(video.series, video.season, video.episode, video.year)
        self.assertEqual({frozenset(subtitle.compute_matches(video)) for subtitle in subtitles}, matches)
        self.assertEqual({subtitle.language for subtitle in subtitles}, languages)

    def test_query_episode_1(self):
        video = EPISODES[1]
        languages = {Language('fra'), Language('ell'), Language('ron'), Language('eng'), Language('hun'),
                     Language('por'), Language('por', 'BR'), Language('jpn')}
        matches = {frozenset(['series', 'episode', 'resolution', 'season', 'year']),
                   frozenset(['series', 'episode', 'season', 'video_codec', 'year']),
                   frozenset(['series', 'episode', 'season', 'year'])}
        with self.Provider() as provider:
            subtitles = provider.query(video.series, video.season, video.episode, video.year)
        self.assertEqual({frozenset(subtitle.compute_matches(video)) for subtitle in subtitles}, matches)
        self.assertEqual({subtitle.language for subtitle in subtitles}, languages)

    def test_list_subtitles(self):
        video = EPISODES[0]
        languages = {Language('eng'), Language('fra')}
        matches = {frozenset(['series', 'episode', 'season', 'format'])}
        with self.Provider() as provider:
            subtitles = provider.list_subtitles(video, languages)
        self.assertEqual({frozenset(subtitle.compute_matches(video)) for subtitle in subtitles}, matches)
        self.assertEqual({subtitle.language for subtitle in subtitles}, languages)

    def test_download_subtitle(self):
        video = EPISODES[0]
        languages = {Language('hun')}
        with self.Provider() as provider:
            subtitles = provider.list_subtitles(video, languages)
            provider.download_subtitle(subtitles[0])
        self.assertIsNotNone(subtitles[0].content)
        self.assertTrue(subtitles[0].is_valid)


def suite():
    suite = TestSuite()
    suite.addTest(TestLoader().loadTestsFromTestCase(Addic7edProviderTestCase))
    suite.addTest(TestLoader().loadTestsFromTestCase(OpenSubtitlesProviderTestCase))
    suite.addTest(TestLoader().loadTestsFromTestCase(PodnapisiProviderTestCase))
    suite.addTest(TestLoader().loadTestsFromTestCase(TheSubDBProviderTestCase))
    suite.addTest(TestLoader().loadTestsFromTestCase(TVsubtitlesProviderTestCase))
    return suite


if __name__ == '__main__':
    TextTestRunner().run(suite())

########NEW FILE########
__FILENAME__ = test_subliminal
#!/usr/bin/env python
# -*- coding: utf-8 -*-
from __future__ import unicode_literals
import os
import shutil
from unittest import TestCase, TestSuite, TestLoader, TextTestRunner
from babelfish import Language
from subliminal import list_subtitles, download_subtitles, save_subtitles, download_best_subtitles, scan_video
from subliminal.tests.common import MOVIES, EPISODES


TEST_DIR = 'test_data'


class ApiTestCase(TestCase):
    def setUp(self):
        os.mkdir(TEST_DIR)

    def tearDown(self):
        shutil.rmtree(TEST_DIR)

    def test_list_subtitles_movie_0(self):
        videos = [MOVIES[0]]
        languages = {Language('eng')}
        subtitles = list_subtitles(videos, languages)
        self.assertEqual(len(subtitles), len(videos))
        self.assertGreater(len(subtitles[videos[0]]), 0)

    def test_list_subtitles_movie_0_por_br(self):
        videos = [MOVIES[0]]
        languages = {Language('por', 'BR')}
        subtitles = list_subtitles(videos, languages)
        self.assertEqual(len(subtitles), len(videos))
        self.assertGreater(len(subtitles[videos[0]]), 0)

    def test_list_subtitles_episodes(self):
        videos = [EPISODES[0], EPISODES[1]]
        languages = {Language('eng'), Language('fra')}
        subtitles = list_subtitles(videos, languages)
        self.assertEqual(len(subtitles), len(videos))
        self.assertGreater(len(subtitles[videos[0]]), 0)

    def test_download_subtitles(self):
        videos = [EPISODES[0]]
        for video in videos:
            video.name = os.path.join(TEST_DIR, os.path.split(video.name)[1])
        languages = {Language('eng')}
        subtitles = list_subtitles(videos, languages)
        download_subtitles(subtitles[videos[0]][:5])
        self.assertGreaterEqual(len([s for s in subtitles[videos[0]] if s.content is not None]), 4)

    def test_download_best_subtitles(self):
        videos = [EPISODES[0], EPISODES[1]]
        for video in videos:
            video.name = os.path.join(TEST_DIR, os.path.split(video.name)[1])
        languages = {Language('eng'), Language('fra')}
        subtitles = download_best_subtitles(videos, languages)
        for video in videos:
            self.assertIn(video, subtitles)
            self.assertEqual(len(subtitles[video]), 2)

    def test_save_subtitles(self):
        videos = [EPISODES[0], EPISODES[1]]
        for video in videos:
            video.name = os.path.join(TEST_DIR, os.path.split(video.name)[1])
        languages = {Language('eng'), Language('fra')}
        subtitles = list_subtitles(videos, languages)

        # make a list of subtitles to download (one per language per video)
        subtitles_to_download = []
        for video, video_subtitles in subtitles.items():
            video_subtitle_languages = set()
            for video_subtitle in video_subtitles:
                if video_subtitle.language in video_subtitle_languages:
                    continue
                subtitles_to_download.append(video_subtitle)
                video_subtitle_languages.add(video_subtitle.language)
                if video_subtitle_languages == languages:
                    break
        self.assertEqual(len(subtitles_to_download), 4)

        # download
        download_subtitles(subtitles_to_download)
        save_subtitles(subtitles)
        for video in videos:
            self.assertTrue(os.path.exists(os.path.splitext(video.name)[0] + '.en.srt'))
            self.assertTrue(os.path.exists(os.path.splitext(video.name)[0] + '.fr.srt'))

    def test_save_subtitles_single(self):
        videos = [EPISODES[0], EPISODES[1]]
        for video in videos:
            video.name = os.path.join(TEST_DIR, os.path.split(video.name)[1])
        languages = {Language('eng'), Language('fra')}
        subtitles = download_best_subtitles(videos, languages)
        save_subtitles(subtitles, single=True)
        for video in videos:
            self.assertIn(video, subtitles)
            self.assertEqual(len(subtitles[video]), 2)
            self.assertTrue(os.path.exists(os.path.splitext(video.name)[0] + '.srt'))

    def test_download_best_subtitles_min_score(self):
        videos = [MOVIES[0]]
        for video in videos:
            video.name = os.path.join(TEST_DIR, os.path.split(video.name)[1])
        languages = {Language('eng'), Language('fra')}
        subtitles = download_best_subtitles(videos, languages, min_score=1000)
        self.assertEqual(len(subtitles), 0)

    def test_download_best_subtitles_hearing_impaired(self):
        videos = [MOVIES[0]]
        for video in videos:
            video.name = os.path.join(TEST_DIR, os.path.split(video.name)[1])
        languages = {Language('eng')}
        subtitles = download_best_subtitles(videos, languages, hearing_impaired=True)
        self.assertTrue(subtitles[videos[0]][0].hearing_impaired)


class VideoTestCase(TestCase):
    def setUp(self):
        os.mkdir(TEST_DIR)
        for video in MOVIES + EPISODES:
            open(os.path.join(TEST_DIR, os.path.split(video.name)[1]), 'w').close()

    def tearDown(self):
        shutil.rmtree(TEST_DIR)

    def test_scan_video_movie(self):
        video = MOVIES[0]
        scanned_video = scan_video(os.path.join(TEST_DIR, os.path.split(video.name)[1]))
        self.assertEqual(scanned_video.name, os.path.join(TEST_DIR, os.path.split(video.name)[1]))
        self.assertEqual(scanned_video.title.lower(), video.title.lower())
        self.assertEqual(scanned_video.year, video.year)
        self.assertEqual(scanned_video.video_codec, video.video_codec)
        self.assertEqual(scanned_video.format, video.format)
        self.assertEqual(scanned_video.resolution, video.resolution)
        self.assertEqual(scanned_video.release_group, video.release_group)
        self.assertEqual(scanned_video.subtitle_languages, set())
        self.assertEqual(scanned_video.hashes, {})
        self.assertIsNone(scanned_video.audio_codec)
        self.assertIsNone(scanned_video.imdb_id)
        self.assertEqual(scanned_video.size, 0)

    def test_scan_video_episode(self):
        video = EPISODES[0]
        scanned_video = scan_video(os.path.join(TEST_DIR, os.path.split(video.name)[1]))
        self.assertEqual(scanned_video.name, os.path.join(TEST_DIR, os.path.split(video.name)[1]))
        self.assertEqual(scanned_video.series, video.series)
        self.assertEqual(scanned_video.season, video.season)
        self.assertEqual(scanned_video.episode, video.episode)
        self.assertEqual(scanned_video.video_codec, video.video_codec)
        self.assertEqual(scanned_video.format, video.format)
        self.assertEqual(scanned_video.resolution, video.resolution)
        self.assertEqual(scanned_video.release_group, video.release_group)
        self.assertEqual(scanned_video.subtitle_languages, set())
        self.assertEqual(scanned_video.hashes, {})
        self.assertIsNone(scanned_video.title)
        self.assertIsNone(scanned_video.tvdb_id)
        self.assertIsNone(scanned_video.imdb_id)
        self.assertIsNone(scanned_video.audio_codec)
        self.assertEqual(scanned_video.size, 0)

    def test_scan_video_subtitle_language_und(self):
        video = EPISODES[0]
        open(os.path.join(TEST_DIR, os.path.splitext(os.path.split(video.name)[1])[0]) + '.srt', 'w').close()
        scanned_video = scan_video(os.path.join(TEST_DIR, os.path.split(video.name)[1]))
        self.assertEqual(scanned_video.subtitle_languages, {Language('und')})

    def test_scan_video_subtitles_language_eng(self):
        video = EPISODES[0]
        open(os.path.join(TEST_DIR, os.path.splitext(os.path.split(video.name)[1])[0]) + '.en.srt', 'w').close()
        scanned_video = scan_video(os.path.join(TEST_DIR, os.path.split(video.name)[1]))
        self.assertEqual(scanned_video.subtitle_languages, {Language('eng')})

    def test_scan_video_subtitles_languages(self):
        video = EPISODES[0]
        open(os.path.join(TEST_DIR, os.path.splitext(os.path.split(video.name)[1])[0]) + '.en.srt', 'w').close()
        open(os.path.join(TEST_DIR, os.path.splitext(os.path.split(video.name)[1])[0]) + '.fr.srt', 'w').close()
        open(os.path.join(TEST_DIR, os.path.splitext(os.path.split(video.name)[1])[0]) + '.srt', 'w').close()
        scanned_video = scan_video(os.path.join(TEST_DIR, os.path.split(video.name)[1]))
        self.assertEqual(scanned_video.subtitle_languages, {Language('eng'), Language('fra'), Language('und')})


def suite():
    suite = TestSuite()
    suite.addTest(TestLoader().loadTestsFromTestCase(ApiTestCase))
    suite.addTest(TestLoader().loadTestsFromTestCase(VideoTestCase))
    return suite


if __name__ == '__main__':
    TextTestRunner().run(suite())

########NEW FILE########
__FILENAME__ = video
# -*- coding: utf-8 -*-
from __future__ import unicode_literals, division
import datetime
import hashlib
import logging
import os
import struct
import babelfish
import enzyme
import guessit


logger = logging.getLogger(__name__)

#: Video extensions
VIDEO_EXTENSIONS = ('.3g2', '.3gp', '.3gp2', '.3gpp', '.60d', '.ajp', '.asf', '.asx', '.avchd', '.avi', '.bik',
                    '.bix', '.box', '.cam', '.dat', '.divx', '.dmf', '.dv', '.dvr-ms', '.evo', '.flc', '.fli',
                    '.flic', '.flv', '.flx', '.gvi', '.gvp', '.h264', '.m1v', '.m2p', '.m2ts', '.m2v', '.m4e',
                    '.m4v', '.mjp', '.mjpeg', '.mjpg', '.mkv', '.moov', '.mov', '.movhd', '.movie', '.movx', '.mp4',
                    '.mpe', '.mpeg', '.mpg', '.mpv', '.mpv2', '.mxf', '.nsv', '.nut', '.ogg', '.ogm', '.omf', '.ps',
                    '.qt', '.ram', '.rm', '.rmvb', '.swf', '.ts', '.vfw', '.vid', '.video', '.viv', '.vivo', '.vob',
                    '.vro', '.wm', '.wmv', '.wmx', '.wrap', '.wvx', '.wx', '.x264', '.xvid')

#: Subtitle extensions
SUBTITLE_EXTENSIONS = ('.srt', '.sub', '.smi', '.txt', '.ssa', '.ass', '.mpl')


class Video(object):
    """Base class for videos

    Represent a video, existing or not, with various properties that defines it.
    Each property has an associated score based on equations that are described in
    subclasses.

    :param string name: name or path of the video
    :param string format: format of the video (HDTV, WEB-DL, ...)
    :param string release_group: release group of the video
    :param string resolution: screen size of the video stream (480p, 720p, 1080p or 1080i)
    :param string video_codec: codec of the video stream
    :param string audio_codec: codec of the main audio stream
    :param int imdb_id: IMDb id of the video
    :param dict hashes: hashes of the video file by provider names
    :param int size: byte size of the video file
    :param set subtitle_languages: existing subtitle languages

    """
    scores = {}

    def __init__(self, name, format=None, release_group=None, resolution=None, video_codec=None, audio_codec=None,
                 imdb_id=None, hashes=None, size=None, subtitle_languages=None):
        self.name = name
        self.format = format
        self.release_group = release_group
        self.resolution = resolution
        self.video_codec = video_codec
        self.audio_codec = audio_codec
        self.imdb_id = imdb_id
        self.hashes = hashes or {}
        self.size = size
        self.subtitle_languages = subtitle_languages or set()

    @classmethod
    def fromguess(cls, name, guess):
        if guess['type'] == 'episode':
            return Episode.fromguess(name, guess)
        if guess['type'] == 'movie':
            return Movie.fromguess(name, guess)
        raise ValueError('The guess must be an episode or a movie guess')

    @classmethod
    def fromname(cls, name):
        return cls.fromguess(os.path.split(name)[1], guessit.guess_file_info(name))

    def __repr__(self):
        return '<%s [%r]>' % (self.__class__.__name__, self.name)

    def __hash__(self):
        return hash(self.name)


class Episode(Video):
    """Episode :class:`Video`

    Scores are defined by a set of equations, see :func:`~subliminal.score.get_episode_equations`

    :param string series: series of the episode
    :param int season: season number of the episode
    :param int episode: episode number of the episode
    :param string title: title of the episode
    :param int year: year of series
    :param int tvdb_id: TheTVDB id of the episode

    """
    scores = {'format': 3, 'video_codec': 2, 'tvdb_id': 48, 'title': 12, 'imdb_id': 60, 'audio_codec': 1, 'year': 24,
              'resolution': 2, 'season': 6, 'release_group': 6, 'series': 24, 'episode': 6, 'hash': 74}

    def __init__(self, name, series, season, episode, format=None, release_group=None, resolution=None, video_codec=None,
                 audio_codec=None, imdb_id=None, hashes=None, size=None, subtitle_languages=None, title=None,
                 year=None, tvdb_id=None):
        super(Episode, self).__init__(name, format, release_group, resolution, video_codec, audio_codec, imdb_id, hashes,
                                      size, subtitle_languages)
        self.series = series
        self.season = season
        self.episode = episode
        self.title = title
        self.year = year
        self.tvdb_id = tvdb_id

    @classmethod
    def fromguess(cls, name, guess):
        if guess['type'] != 'episode':
            raise ValueError('The guess must be an episode guess')
        if 'series' not in guess or 'season' not in guess or 'episodeNumber' not in guess:
            raise ValueError('Insufficient data to process the guess')
        return cls(name, guess['series'], guess['season'], guess['episodeNumber'], format=guess.get('format'),
                   release_group=guess.get('releaseGroup'), resolution=guess.get('screenSize'),
                   video_codec=guess.get('videoCodec'), audio_codec=guess.get('audioCodec'),
                   title=guess.get('title'), year=guess.get('year'))

    @classmethod
    def fromname(cls, name):
        return cls.fromguess(os.path.split(name)[1], guessit.guess_episode_info(name))

    def __repr__(self):
        if self.year is None:
            return '<%s [%r, %dx%d]>' % (self.__class__.__name__, self.series, self.season, self.episode)
        return '<%s [%r, %d, %dx%d]>' % (self.__class__.__name__, self.series, self.year, self.season, self.episode)


class Movie(Video):
    """Movie :class:`Video`

    Scores are defined by a set of equations, see :func:`~subliminal.score.get_movie_equations`

    :param string title: title of the movie
    :param int year: year of the movie

    """
    scores = {'format': 3, 'video_codec': 2, 'title': 13, 'imdb_id': 34, 'audio_codec': 1, 'year': 7, 'resolution': 2,
              'release_group': 6, 'hash': 34}

    def __init__(self, name, title, format=None, release_group=None, resolution=None, video_codec=None, audio_codec=None,
                 imdb_id=None, hashes=None, size=None, subtitle_languages=None, year=None):
        super(Movie, self).__init__(name, format, release_group, resolution, video_codec, audio_codec, imdb_id, hashes,
                                    size, subtitle_languages)
        self.title = title
        self.year = year

    @classmethod
    def fromguess(cls, name, guess):
        if guess['type'] != 'movie':
            raise ValueError('The guess must be a movie guess')
        if 'title' not in guess:
            raise ValueError('Insufficient data to process the guess')
        return cls(name, guess['title'], format=guess.get('format'), release_group=guess.get('releaseGroup'),
                   resolution=guess.get('screenSize'), video_codec=guess.get('videoCodec'),
                   audio_codec=guess.get('audioCodec'),year=guess.get('year'))

    @classmethod
    def fromname(cls, name):
        return cls.fromguess(os.path.split(name)[1], guessit.guess_movie_info(name))

    def __repr__(self):
        if self.year is None:
            return '<%s [%r]>' % (self.__class__.__name__, self.title)
        return '<%s [%r, %d]>' % (self.__class__.__name__, self.title, self.year)


def scan_subtitle_languages(path):
    """Search for subtitles with alpha2 extension from a video `path` and return their language

    :param string path: path to the video
    :return: found subtitle languages
    :rtype: set

    """
    language_extensions = tuple('.' + c for c in babelfish.language_converters['alpha2'].codes)
    dirpath, filename = os.path.split(path)
    subtitles = set()
    for p in os.listdir(dirpath):
        if not isinstance(p, bytes) and p.startswith(os.path.splitext(filename)[0]) and p.endswith(SUBTITLE_EXTENSIONS):
            if os.path.splitext(p)[0].endswith(language_extensions):
                subtitles.add(babelfish.Language.fromalpha2(os.path.splitext(p)[0][-2:]))
            else:
                subtitles.add(babelfish.Language('und'))
    logger.debug('Found subtitles %r', subtitles)
    return subtitles


def scan_video(path, subtitles=True, embedded_subtitles=True):
    """Scan a video and its subtitle languages from a video `path`

    :param string path: absolute path to the video
    :param bool subtitles: scan for subtitles with the same name
    :param bool embedded_subtitles: scan for embedded subtitles
    :return: the scanned video
    :rtype: :class:`Video`
    :raise: ValueError if cannot guess enough information from the path

    """
    dirpath, filename = os.path.split(path)
    logger.info('Scanning video %r in %r', filename, dirpath)
    video = Video.fromguess(path, guessit.guess_file_info(path))
    video.size = os.path.getsize(path)
    if video.size > 10485760:
        logger.debug('Size is %d', video.size)
        video.hashes['opensubtitles'] = hash_opensubtitles(path)
        video.hashes['thesubdb'] = hash_thesubdb(path)
        logger.debug('Computed hashes %r', video.hashes)
    else:
        logger.warning('Size is lower than 10MB: hashes not computed')
    if subtitles:
        video.subtitle_languages |= scan_subtitle_languages(path)
    # enzyme
    try:
        if filename.endswith('.mkv'):
            with open(path, 'rb') as f:
                mkv = enzyme.MKV(f)
            if mkv.video_tracks:
                video_track = mkv.video_tracks[0]
                # resolution
                if video_track.height in (480, 720, 1080):
                    if video_track.interlaced:
                        video.resolution = '%di' % video_track.height
                        logger.debug('Found resolution %s with enzyme', video.resolution)
                    else:
                        video.resolution = '%dp' % video_track.height
                        logger.debug('Found resolution %s with enzyme', video.resolution)
                # video codec
                if video_track.codec_id == 'V_MPEG4/ISO/AVC':
                    video.video_codec = 'h264'
                    logger.debug('Found video_codec %s with enzyme', video.video_codec)
                elif video_track.codec_id == 'V_MPEG4/ISO/SP':
                    video.video_codec = 'DivX'
                    logger.debug('Found video_codec %s with enzyme', video.video_codec)
                elif video_track.codec_id == 'V_MPEG4/ISO/ASP':
                    video.video_codec = 'XviD'
                    logger.debug('Found video_codec %s with enzyme', video.video_codec)
            else:
                logger.warning('MKV has no video track')
            if mkv.audio_tracks:
                audio_track = mkv.audio_tracks[0]
                # audio codec
                if audio_track.codec_id == 'A_AC3':
                    video.audio_codec = 'AC3'
                    logger.debug('Found audio_codec %s with enzyme', video.audio_codec)
                elif audio_track.codec_id == 'A_DTS':
                    video.audio_codec = 'DTS'
                    logger.debug('Found audio_codec %s with enzyme', video.audio_codec)
                elif audio_track.codec_id == 'A_AAC':
                    video.audio_codec = 'AAC'
                    logger.debug('Found audio_codec %s with enzyme', video.audio_codec)
            else:
                logger.warning('MKV has no audio track')
            if mkv.subtitle_tracks:
                # embedded subtitles
                if embedded_subtitles:
                    embedded_subtitle_languages = set()
                    for st in mkv.subtitle_tracks:
                        if st.language:
                            try:
                                embedded_subtitle_languages.add(babelfish.Language.fromalpha3b(st.language))
                            except babelfish.Error:
                                logger.error('Embedded subtitle track language %r is not a valid language', st.language)
                                embedded_subtitle_languages.add(babelfish.Language('und'))
                        elif st.name:
                            try:
                                embedded_subtitle_languages.add(babelfish.Language.fromname(st.name))
                            except babelfish.Error:
                                logger.debug('Embedded subtitle track name %r is not a valid language', st.name)
                                embedded_subtitle_languages.add(babelfish.Language('und'))
                        else:
                            embedded_subtitle_languages.add(babelfish.Language('und'))
                    logger.debug('Found embedded subtitle %r with enzyme', embedded_subtitle_languages)
                    video.subtitle_languages |= embedded_subtitle_languages
            else:
                logger.debug('MKV has no subtitle track')
    except enzyme.Error:
        logger.exception('Parsing video metadata with enzyme failed')
    return video


def scan_videos(paths, subtitles=True, embedded_subtitles=True, age=None):
    """Scan `paths` for videos and their subtitle languages

    :params paths: absolute paths to scan for videos
    :type paths: list of string
    :param bool subtitles: scan for subtitles with the same name
    :param bool embedded_subtitles: scan for embedded subtitles
    :param age: age of the video, if any
    :type age: datetime.timedelta or None
    :return: the scanned videos
    :rtype: list of :class:`Video`

    """
    videos = []
    # scan files
    for filepath in [p for p in paths if os.path.isfile(p)]:
        if age is not None:
            try:
                video_age = datetime.datetime.now() - datetime.datetime.fromtimestamp(os.path.getmtime(filepath))
            except ValueError:
                logger.exception('Error while getting video age, skipping it')
                continue
            if video_age > age:
                logger.info('Skipping video %r: older than %r', filepath, age)
                continue
        try:
            videos.append(scan_video(filepath, subtitles, embedded_subtitles))
        except ValueError as e:
            logger.error('Skipping video: %s', e)
            continue
    # scan directories
    for path in [p for p in paths if os.path.isdir(p)]:
        logger.info('Scanning directory %r', path)
        for dirpath, dirnames, filenames in os.walk(path):
            # skip badly encoded directories
            if isinstance(dirpath, bytes):
                logger.error('Skipping badly encoded directory %r', dirpath.decode('utf-8', errors='replace'))
                continue
            # skip badly encoded and hidden sub directories
            for dirname in list(dirnames):
                if isinstance(dirname, bytes):
                    logger.error('Skipping badly encoded dirname %r in %r', dirname.decode('utf-8', errors='replace'),
                                 dirpath)
                    dirnames.remove(dirname)
                elif dirname.startswith('.'):
                    logger.debug('Skipping hidden dirname %r in %r', dirname, dirpath)
                    dirnames.remove(dirname)
            # scan for videos
            for filename in filenames:
                # skip badly encoded files
                if isinstance(filename, bytes):
                    logger.error('Skipping badly encoded filename %r in %r', filename.decode('utf-8', errors='replace'),
                                 dirpath)
                    continue
                # filter videos
                if not filename.endswith(VIDEO_EXTENSIONS):
                    continue
                # skip hidden files
                if filename.startswith('.'):
                    logger.debug('Skipping hidden filename %r in %r', filename, dirpath)
                    continue
                filepath = os.path.join(dirpath, filename)
                # skip links
                if os.path.islink(filepath):
                    logger.debug('Skipping link %r in %r', filename, dirpath)
                    continue
                if age is not None:
                    try:
                        video_age = datetime.datetime.now() - datetime.datetime.fromtimestamp(os.path.getmtime(filepath))
                    except ValueError:
                        logger.exception('Error while getting video age, skipping it')
                        continue
                    if video_age > age:
                        logger.info('Skipping video %r: older than %r', filepath, age)
                        continue
                try:
                    video = scan_video(filepath, subtitles, embedded_subtitles)
                except ValueError as e:
                    logger.error('Skipping video: %s', e)
                    continue
                videos.append(video)
    return videos


def hash_opensubtitles(video_path):
    """Compute a hash using OpenSubtitles' algorithm

    :param string video_path: path of the video
    :return: the hash
    :rtype: string

    """
    bytesize = struct.calcsize(b'<q')
    with open(video_path, 'rb') as f:
        filesize = os.path.getsize(video_path)
        filehash = filesize
        if filesize < 65536 * 2:
            return None
        for _ in range(65536 // bytesize):
            filebuffer = f.read(bytesize)
            (l_value,) = struct.unpack(b'<q', filebuffer)
            filehash += l_value
            filehash = filehash & 0xFFFFFFFFFFFFFFFF  # to remain as 64bit number
        f.seek(max(0, filesize - 65536), 0)
        for _ in range(65536 // bytesize):
            filebuffer = f.read(bytesize)
            (l_value,) = struct.unpack(b'<q', filebuffer)
            filehash += l_value
            filehash = filehash & 0xFFFFFFFFFFFFFFFF
    returnedhash = '%016x' % filehash
    return returnedhash


def hash_thesubdb(video_path):
    """Compute a hash using TheSubDB's algorithm

    :param string video_path: path of the video
    :return: the hash
    :rtype: string

    """
    readsize = 64 * 1024
    if os.path.getsize(video_path) < readsize:
        return None
    with open(video_path, 'rb') as f:
        data = f.read(readsize)
        f.seek(-readsize, os.SEEK_END)
        data += f.read(readsize)
    return hashlib.md5(data).hexdigest()

########NEW FILE########
