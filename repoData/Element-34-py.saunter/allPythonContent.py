__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Py.Saunter documentation build configuration file, created by
# sphinx-quickstart on Thu Sep  8 12:12:06 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import os
import sys

os.environ['DOCGENERATION'] = "true"

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('../../'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Py.Saunter'
copyright = u'2011, Element 34'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.47'
# The full version, including alpha/beta/rc tags.
release = '0.47'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'PySaunterdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [('index', 'PySaunter.tex', u'Py.Saunter Documentation', u'Element 34', 'manual')]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'pysaunter', u'Py.Saunter Documentation',
     [u'Element 34'], 1)
]

########NEW FILE########
__FILENAME__ = ConfigWrapper
# Copyright 2011 Element 34
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
=============
ConfigWrapper
=============
"""
import os
import os.path
import sys
import yaml


class ConfigWrapper(object):
    """
    Singleton reference to the config information
    """
    # singleton
    _instance = None

    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super(ConfigWrapper, cls).__new__(cls, *args, **kwargs)
            cls._instance._data = {}
        return cls._instance

    def __str__(self):
        return yaml.dump(self._data, default_flow_style=False)

    def __getitem__(self, key):
        return self._data[key]

    def __setitem__(self, key, value):
        self._data[key] = value

    def __contains__(self, item):
        if item in self._data:
            return True
        return False

    def configure(self, config="saunter.yaml"):
        if not os.path.exists(os.path.join("conf", config)):
            print("Could not find %s; are you sure you remembered to create one?" % os.path.join("conf", config))
            sys.exit(1)

        # this should exist since configure() is only called in main.py
        config_dir = os.path.join(self._data["saunter"]["base"], "conf")
        for root, dirs, files in os.walk(config_dir):
            for f in files:
                if f.endswith(".yaml"):
                    file_path = os.path.join(root, f)
                    relative_path = file_path[len(config_dir) + 1:]
                    head, tail = os.path.split(relative_path)
                    section_name = f[:-5]
                    o = open(file_path, "r")
                    if head:
                        if head not in self._data.keys():
                            self._data[head] = {}
                        if section_name in self._data[head]:
                            self._data[head][section_name] = dict(self._data[head][section_name].items() + yaml.load(o).items())
                        else:
                            self._data[head][section_name] = yaml.load(o)
                    else:
                        if section_name in self._data:
                            self._data[section_name] = dict(self._data[section_name].items() + yaml.load(o).items())
                        else:
                            self._data[section_name] = yaml.load(o)
                    o.close()

########NEW FILE########
__FILENAME__ = exceptions
# Copyright 2011 Element 34
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
==============
SyncExceptions
==============
"""


class SaunterExceptions(Exception):
    """Base class for exceptions in this module."""
    pass


class ElementNotFound(SaunterExceptions):
    def _get_message(self):
        return self._message

    def _set_message(self, message):
        self._message = message
    message = property(_get_message, _set_message)


class ElementVisiblityTimeout(SaunterExceptions):
    def _get_message(self):
        return self._message

    def _set_message(self, message):
        self._message = message
    message = property(_get_message, _set_message)


class ElementTextTimeout(SaunterExceptions):
    def _get_message(self):
        return self._message

    def _set_message(self, message):
        self._message = message
    message = property(_get_message, _set_message)


class InvalidLocatorString(SaunterExceptions):
    def _get_message(self):
        return self._message

    def _set_message(self, message):
        self._message = message
    message = property(_get_message, _set_message)


class WindowNotFound(SaunterExceptions):
    def _get_message(self):
        return self._message

    def _set_message(self, message):
        self._message = message
    message = property(_get_message, _set_message)


class ProfileNotFound(SaunterExceptions):
    def _get_message(self):
        return self._message

    def _set_message(self, message):
        self._message = message
    message = property(_get_message, _set_message)


class ProviderException(SaunterExceptions):
    def _get_message(self):
        return self._message

    def _set_message(self, message):
        self._message = message
    message = property(_get_message, _set_message)

########NEW FILE########
__FILENAME__ = string_data
# Copyright 2011 Element 34
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
===========
string_data
===========
"""
import random
import string


def random_string(random_length=None):
    """
    A generator for creating random string data of letters plus ' ' (whitespace)

    :params random_length: how many characters of random string data. if not provided, will be between 1 - 30
    :returns: String
    """
    choices = string.letters + ' '
    text = []
    if not random_length:
        random_length = random.randint(1, 30)
    for x in range(random_length):
        text.append(random.choice(choices))
    return "".join(text)

########NEW FILE########
__FILENAME__ = main
# Copyright 2011 Element 34
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import datetime
import pytest
import marks
import argparse
import os
import os.path
import re
import shutil
import sys
import time
import tempfile
import types
import saunter
saunter_installed_at = os.path.dirname(saunter.__file__)
cwd = os.getcwd()


def new():
    # conf
    if not os.path.isdir(os.path.join(cwd, "conf")):
        os.mkdir(os.path.join(cwd, "conf"))
    if not os.path.isfile(os.path.join(cwd, "conf", "saunter.yaml.default")):
        shutil.copy(os.path.join(saunter_installed_at, "_defaults", "conf", "saunter.yaml.default"),
                    os.path.join(cwd, "conf"))
    if not os.path.isfile(os.path.join(cwd, "conf", "selenium.yaml.default")):
        shutil.copy(os.path.join(saunter_installed_at, "_defaults", "conf", "selenium.yaml.default"),
                    os.path.join(cwd, "conf"))

    # browsers
    if not os.path.isdir(os.path.join(cwd, "conf", "browers")):
        os.mkdir(os.path.join(cwd, "conf", "browsers"))
    if not os.path.isfile(os.path.join(cwd, "conf", "browsers", "browser.yaml.default")):
        shutil.copy(os.path.join(saunter_installed_at, "_defaults", "conf", "browsers", "browser.yaml.default"),
                    os.path.join(cwd, "conf", "browsers"))

    # log
    if not os.path.isdir(os.path.join(cwd, "logs")):
        os.mkdir(os.path.join(cwd, "logs"))

    # modules
    if not os.path.isdir(os.path.join(cwd, "modules")):
        os.mkdir(os.path.join(cwd, "modules"))

    # modules/pages
    if not os.path.isdir(os.path.join(cwd, "modules", "pages")):
        os.mkdir(os.path.join(cwd, "modules", "pages"))

    # pages is a package
    if not os.path.isfile(os.path.join(cwd, "modules", "pages", "__init__.py")):
        f = open(os.path.join(cwd, "modules", "pages", "__init__.py"), "w")
        f.close()

    # modules/providers
    if not os.path.isdir(os.path.join(cwd, "modules", "providers")):
        os.mkdir(os.path.join(cwd, "modules", "providers"))

    # providers is a package
    if not os.path.isfile(os.path.join(cwd, "modules", "providers", "__init__.py")):
        f = open(os.path.join(cwd, "modules", "providers", "__init__.py"), "w")
        f.close()

    # modules/pages
    if not os.path.isdir(os.path.join(cwd, "modules", "tailored")):
        os.mkdir(os.path.join(cwd, "modules", "tailored"))

    # pages is a package
    if not os.path.isfile(os.path.join(cwd, "modules", "tailored", "__init__.py")):
        f = open(os.path.join(cwd, "modules", "tailored", "__init__.py"), "w")
        f.close()

    if not os.path.isfile(os.path.join(cwd, "modules", "tailored", "webdriver.py")):
        shutil.copy(os.path.join(saunter_installed_at, "_defaults", "tailored", "webdriver.py"), os.path.join(cwd, "modules", "tailored"))

    if not os.path.isfile(os.path.join(cwd, "modules", "tailored", "page.py")):
        shutil.copy(os.path.join(saunter_installed_at, "_defaults", "tailored", "page.py"), os.path.join(cwd, "modules", "tailored"))

    # scripts
    if not os.path.isdir(os.path.join(cwd, "scripts")):
        os.mkdir(os.path.join(cwd, "scripts"))

    # support
    if not os.path.isdir(os.path.join(cwd, "support")):
        os.mkdir(os.path.join(cwd, "support"))

    # support/csv
    if not os.path.isdir(os.path.join(cwd, "support", "csv")):
        os.mkdir(os.path.join(cwd, "support", "csv"))

    # support/db
    if not os.path.isdir(os.path.join(cwd, "support", "db")):
        os.mkdir(os.path.join(cwd, "support", "db"))

    # support/db
    if not os.path.isdir(os.path.join(cwd, "support", "files")):
        os.mkdir(os.path.join(cwd, "support", "files"))

    # misc.
    if not os.path.isfile(os.path.join(cwd, "conftest.py")):
        shutil.copy(os.path.join(saunter_installed_at, "_defaults", "conftest.py"), cwd)
    if not os.path.isfile(os.path.join(cwd, "pytest.ini")):
        shutil.copy(os.path.join(saunter_installed_at, "_defaults", "pytest.ini"), cwd)

    sys.exit()

p = argparse.ArgumentParser()
p.add_argument('--new', action='store_true', default=False, help="creates a new Saunter environment")
p.add_argument('-v', action='store_true', default=None, help="increase verbosity")
p.add_argument('-s', action='store_true', default=None, help="don't capture output")
p.add_argument('--tb', action='store', default="native", help='traceback print mode (long/short/line/native/no)')
p.add_argument('-p', action='append', default=[], help="early-load given plugin (multi-allowed)")
p.add_argument('-m', action='append', default=[], help="filter based on marks")
p.add_argument('-n', action='store', default=None, help="number of processes to fork")
p.add_argument('--traceconfig', action='store_true', default=None, help="trace considerations of conftest.py files")
p.add_argument('--pdb', action='store_true', default=None, help="start the interactive Python debugger on errors")
p.add_argument('--maxfail', action='store', default=None, help="exit after first num failures or errors.")
p.add_argument('--collectonly', action='store_true', default=None, help="only collect tests, don't execute them")
p.add_argument('--durations', action='store', default=None, help='show N slowest setup/test durations (N=0 for all)')
p.add_argument('--debug', action='store', default=None, help="store internal tracing debug information in 'pytestdebug.log'.")
p.add_argument('--version', action='version', version='Saunter %s' % saunter.__version__)

results = p.parse_args()

# argument handling; what a mess
if results.new:
    new()

arguments = []

# argparse will take all the -m arguments and compile them into a list
if len(results.m) == 1:
    arguments.append("-m")
    arguments.append(results.m[0])
elif len(results.m) > 1:
    for markers in results.m:
        arguments.append("-m")
        arguments.append(markers)
else:
    arguments.append("-m")
    arguments.append("shallow")

# this are either true or false
for noneable in ['v', 's']:
    if noneable in results.__dict__ and results.__dict__[noneable] is not None:
        arguments.append("-%s" % noneable)

for noneable in ['traceconfig', 'pdb', 'collectonly', "debug"]:
    if noneable in results.__dict__ and results.__dict__[noneable] is not None:
        arguments.append("--%s" % noneable)

for has_value in ['maxfail', 'durations']:
    if has_value in results.__dict__ and results.__dict__[has_value] is not None:
        arguments.append("--%s=%s" % (has_value, results.__dict__[has_value][0]))
        # arguments.append(results.__dict__[has_value][0])

if 'n' in results.__dict__ and results.__dict__['n'] is not None:
    arguments.append("--dist=load")
    arguments.append("--tx=%s*popen" % results.__dict__['n'])

# plugin control
if len(results.p) == 1:
    arguments.append("-p")
    arguments.append(results.p[0])
else:
    for p in results.p:
        arguments.append("-p")
        arguments.append(p)

import saunter.ConfigWrapper
config = saunter.ConfigWrapper.ConfigWrapper()
config["saunter"] = {}
config["saunter"]["base"] = cwd
config.configure()

# logging
timestamp = time.strftime("%Y-%m-%d-%H-%M-%S")
log_dir = os.path.join(cwd, 'logs', timestamp)
os.makedirs(log_dir)

log_name = os.path.join(log_dir, "%s.xml" % timestamp)
arguments.append('--junitxml=%s' % log_name)

config["saunter"]["log_dir"] = log_dir

arguments.append('--tb=%s' % results.__dict__["tb"])

# run
arguments.append("scripts")

run_status = pytest.main(args=arguments, plugins=[marks.MarksDecorator()])

shutil.copy(log_name, os.path.join(cwd, 'logs', 'latest.xml'))

sys.exit(run_status)

########NEW FILE########
__FILENAME__ = matchers
import sys


class Matchers(object):
    def __init__(self, driver, verification_errors):
        self.driver = driver
        self.verification_erorrs = verification_errors

    #
    # unittest.TestCase provided
    #
    def assert_equal(self, first, second, msg=""):
        """
        Hard assert for equality

        :params first: the value to compare against
        :params second: the value to compare with
        :params msg: (Optional) msg explaining the difference
        """
        assert first == second

    def verify_equal(self, first, second, msg=""):
        """
        Soft assert for equality

        :params want: the value to compare against
        :params second: the value to compare with
        :params msg: (Optional) msg explaining the difference
        """
        try:
            self.assert_equal(first, second, msg)
        except AssertionError, e:
            if msg:
                m = "%s:\n%s" % (msg, str(e))
            else:
                m = str(e)
            self.verification_erorrs.append(m)

    def assert_not_equal(self, first, second, msg=""):
        """
        Hard assert for inequality

        :params want: the value to compare against
        :params secondv: the value to compare with
        :params msg: (Optional) msg explaining the difference
        """
        assert first != second

    def verify_not_equal(self, first, second, msg=""):
        """
        Soft assert for inequality

        :params want: the value to compare against
        :params second: the value to compare with
        :params msg: (Optional) msg explaining the difference
        """
        try:
            self.assert_not_equal(first, second, msg)
        except AssertionError, e:
            if msg:
                m = "%s:\n%s" % (msg, str(e))
            else:
                m = str(e)
            self.verification_erorrs.append(m)

    def assert_true(self, expr, msg=None):
        """
        Soft assert for whether the condition is true

        :params expr: the statement to evaluate
        :params msg: (Optional) msg explaining the difference
        """
        assert bool(expr) is True

    def verify_true(self, expr, msg=None):
        """
        Soft assert for whether the condition is true

        :params expr: the statement to evaluate
        :params msg: (Optional) msg explaining the difference
        """
        try:
            self.assert_true(expr, msg)
        except AssertionError, e:
            if msg:
                m = "%s:\n%s" % (msg, str(e))
            else:
                m = str(e)
            self.verification_erorrs.append(m)

    def assert_false(self, expr, msg=None):
        """
        Soft assert for whether the condition is false

        :params expr: the statement to evaluate
        :params msg: (Optional) msg explaining the difference
        """
        assert bool(expr) is False

    def verify_false(self, expr, msg=None):
        """
        Soft assert for whether the condition is false

        :params expr: the statement to evaluate
        :params msg: (Optional) msg explaining the difference
        """
        try:
            self.assert_false(expr, msg)
        except AssertionError, e:
            if msg:
                m = "%s:\n%s" % (msg, str(e))
            else:
                m = str(e)
            self.verification_erorrs.append(m)

    def assert_is(self, first, second, msg=None):
        """
        Hard assert for whether the parameters evaluate to the same object

        :params want: the object to compare against
        :params second: the object to compare with
        :params msg: (Optional) msg explaining the difference
        """
        assert first is second

    def verify_is(self, first, second, msg=None):
        """
        Soft assert for whether the parameters evaluate to the same object

        :params want: the object to compare against
        :params second: the object to compare with
        :params msg: (Optional) msg explaining the difference
        """
        try:
            self.assert_is(first, second, msg)
        except AssertionError, e:
            if msg:
                m = "%s:\n%s" % (msg, str(e))
            else:
                m = str(e)
            self.verification_erorrs.append(m)

    def assert_is_not(self, first, second, msg=None):
        """
        Hard assert for whether the parameters do not evaluate to the same object

        :params want: the object to compare against
        :params second: the object to compare with
        :params msg: (Optional) msg explaining the difference
        """
        assert first is not second

    def verify_is_not(self, first, second, msg=None):
        """
        Soft assert for whether the parameters do not evaluate to the same object

        :params want: the object to compare against
        :params second: the object to compare with
        :params msg: (Optional) msg explaining the difference
        """
        try:
            self.assert_is_not(first, second, msg)
        except AssertionError, e:
            if msg:
                m = "%s:\n%s" % (msg, str(e))
            else:
                m = str(e)
            self.verification_erorrs.append(m)

    def assert_is_none(self, expr, msg=None):
        """
        Hard assert for whether the expr is None

        :params expr: the expression to execute
        :params msg: (Optional) msg explaining the difference
        """
        assert expr is None

    def verify_is_none(self, expr, msg=None):
        """
        Soft assert for whether the expr is None

        :params want: the object to compare against
        :params second: the object to compare with
        :params msg: (Optional) msg explaining the difference
        """
        try:
            self.assert_is_none(expr, msg)
        except AssertionError, e:
            if msg:
                m = "%s:\n%s" % (msg, str(e))
            else:
                m = str(e)
            self.verification_erorrs.append(m)

    def assert_is_not_none(self, expr, msg=None):
        """
        Hard assert for whether the expr is not None

        :params expr: the expression to execute
        :params msg: (Optional) msg explaining the difference
        """
        assert expr is not None

    def verify_is_not_none(self, expr, msg=None):
        """
        Soft assert for whether the expr is not None

        :params want: the object to compare against
        :params second: the object to compare with
        :params msg: (Optional) msg explaining the difference
        """
        try:
            self.assert_is_not_none(expr, msg)
        except AssertionError, e:
            if msg:
                m = "%s:\n%s" % (msg, str(e))
            else:
                m = str(e)
            self.verification_erorrs.append(m)

    def assert_in(self, first, second, msg=""):
        """
        Hard assert for whether the first is in second

        :params first: the value to check
        :params second: the container to check in
        :params msg: (Optional) msg explaining the difference
        """
        assert first in second

    def verify_in(self, first, second, msg=""):
        """
        Soft assert for whether the first is in second

        :params first: the value to check
        :params second: the container to check in
        :params msg: (Optional) msg explaining the difference
        """
        try:
            self.assert_in(first, second, msg)
        except AssertionError, e:
            if msg:
                m = "%s:\n%s" % (msg, str(e))
            else:
                m = str(e)
            self.verification_erorrs.append(m)

    def assert_not_in(self, first, second, msg=""):
        """
        Hard assert for whether the first is not in second

        :params first: the value to check
        :params second: the container to check in
        :params msg: (Optional) msg explaining the difference
        """
        assert first not in second

    def verify_not_in(self, first, second, msg=""):
        """
        Soft assert for whether the first is not in second

        :params first: the value to check
        :params second: the container to check in
        :params msg: (Optional) msg explaining the difference
        """
        try:
            self.assert_not_in(first, second, msg)
        except AssertionError, e:
            if msg:
                m = "%s:\n%s" % (msg, str(e))
            else:
                m = str(e)
            self.verification_erorrs.append(m)

    def assert_is_instance(self, obj, cls, msg=""):
        """
        Hard assert for whether the is an instance of cls

        :params obj: the object instance
        :params cls: the class to compare against
        :params msg: (Optional) msg explaining the difference
        """
        assert isinstance(obj, cls)

    def verify_is_instance(self, obj, cls, msg=""):
        """
        Soft assert for whether the is an instance of cls

        :params obj: the object instance
        :params cls: the class to compare against
        :params msg: (Optional) msg explaining the difference
        """
        try:
            self.assert_is_instance(obj, cls, msg)
        except AssertionError, e:
            if msg:
                m = "%s:\n%s" % (msg, str(e))
            else:
                m = str(e)
            self.verification_erorrs.append(m)

    def assert_is_not_instance(self, obj, cls, msg=""):
        """
        Hard assert for whether the is not an instance of cls

        :params obj: the object instance
        :params cls: the class to compare against
        :params msg: (Optional) msg explaining the difference
        """
        assert not isinstance(obj, cls)

    def verify_is_not_instance(self, obj, cls, msg=""):
        """
        Soft assert for whether the is not an instance of cls

        :params obj: the object instance
        :params cls: the class to compare against
        :params msg: (Optional) msg explaining the difference
        """
        try:
            self.assert_is_not_instance(obj, cls, msg)
        except AssertionError, e:
            if msg:
                m = "%s:\n%s" % (msg, str(e))
            else:
                m = str(e)
            self.verification_erorrs.append(m)

    #
    # selenium specific
    #
    def assert_text_present(self, text, msg=None):
        """
        Hard assert for whether the text if visible in the current window/frame

        :params text: the string to search for
        :params msg: (Optional) msg explaining the difference
        """
        e = driver.find_element_by_tag_name('body')
        assert text in e.text

    def verify_text_present(self, text, msg=None):
        """
        Soft assert for whether the text if visible in the current window/frame

        :params text: the string to search for
        :params msg: (Optional) msg explaining the difference
        """
        try:
            self.assert_text_present(text, msg)
        except AssertionError, e:
            if msg:
                m = "%s:\n%s" % (msg, str(e))
            else:
                m = str(e)
            self.verification_erorrs.append(m)

    def asset_element_present(self, locator, msg=None):
        """
        Hard assert for whether and element is present in the current window/frame

        :params locator: the locator of the element to search for
        :params msg: (Optional) msg explaining the difference
        """
        e = driver.find_elements_by_locator(locator)
        if len(e) == 0:
            raise AssertionError("Element at %s was not found" % locator)

    def verify_element_present(self, locator, msg=None):
        """
        Soft assert for whether and element is present in the current window/frame

        :params locator: the locator of the element to search for
        :params msg: (Optional) msg explaining the difference
        """
        try:
            self.asset_element_present(locator, msg)
        except AssertionError, e:
            if msg:
                m = "%s:\n%s" % (msg, str(e))
            else:
                m = str(e)
            self.verification_erorrs.append(m)

    def assert_visible(self, locator, msg=None):
        """
        Hard assert for whether and element is present and visible in the current window/frame

        :params locator: the locator of the element to search for
        :params msg: (Optional) msg explaining the difference
        """
        e = driver.find_elements_by_locator(locator)
        if len(e) == 0:
            raise AssertionError("Element at %s was not found" % locator)
        assert e.is_displayed()

    def verify_visible(self, locator, msg=None):
        """
        Soft assert for whether and element is present and visible in the current window/frame

        :params locator: the locator of the element to search for
        :params msg: (Optional) msg explaining the difference
        """
        try:
            self.assert_visible(locator, msg)
        except AssertionError, e:
            if msg:
                m = "%s:\n%s" % (msg, str(e))
            else:
                m = str(e)
            self.verification_erorrs.append(m)

########NEW FILE########
__FILENAME__ = attribute
# Copyright 2011 Element 34
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
=========
Attribute
=========
"""
from saunter.po.webdriver.element import Element
from saunter.exceptions import ElementNotFound


class Attribute(Element):
    """
    Base element class for Text fields
    """
    def __init__(self, element, attribute):
        self.locator = element
        self.attribute = attribute

    def __set__(self, obj, val):
        pass

    def __get__(self, obj, cls=None):
        try:
            e = obj.driver.find_element_by_locator(self.locator)
            return e.get_attribute(self.attribute)
        except AttributeError as e:
            if str(e) == "'SeleniumWrapper' object has no attribute 'connection'":
                pass
            else:
                raise e
        except ElementNotFound as e:
            msg = "Element %s was not found. It is used in the %s page object in the %s module." % (self.locator, obj.__class__.__name__, self.__module__)
            raise ElementNotFound(msg)

########NEW FILE########
__FILENAME__ = checkbox
# Copyright 2011 Element 34
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
========
Checkbox
========
"""
from saunter.po.webdriver.element import Element


class CheckBox(Element):
    def __set__(self, obj, val):
        e = obj.driver.find_element_by_locator(self.locator)
        current = e.is_selected()
        if current != val:
            e.click()

    def __get__(self, obj, cls=None):
        e = obj.driver.find_element_by_locator(self.locator)
        return e.is_selected()

########NEW FILE########
__FILENAME__ = element
# Copyright 2011 Element 34
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
=======
Element
=======
"""


class Element(object):
    """
    Top of the PO element tree
    """
    pass

########NEW FILE########
__FILENAME__ = multi_select
# Copyright 2011 Element 34
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
======
Select
======
"""
from saunter.po.webdriver.element import Element
from saunter.web_element import WebElement
from saunter.SeleniumWrapper import SeleniumWrapper as wrapper
from saunter.exceptions import ElementNotFound
from saunter.SaunterWebDriver import SaunterWebDriver
from selenium.webdriver.support.select import Select as WebDriverSelect


class MultiSelect(Element, WebDriverSelect):
    def __get__(self, obj, cls=None):
        s = WebDriverSelect(obj.driver.find_element_by_locator(self.locator))
        a = s.all_selected_options
        if len(a) == 0:
            return None
        return [x.text for x in a]

    def __getitem__(self, key):
        s = WebDriverSelect(self.driver.find_element_by_locator(self.locator))
        a = s.all_selected_options
        if len(a) == 0:
            return None
        selections = [x.text for x in a]
        return selections[key]

    def __delitem__(self, key):
        s = WebDriverSelect(self.driver.find_element_by_locator(self.locator))
        method = key[:key.find("=")]
        value = key[key.find("=") + 1:]
        if method == "value":
            s.deselect_by_value(value)
        elif method == "index":
            s.deselect_by_index(value)
        elif method == "text":
            s.deselect_by_visible_text(value)
        else:
            raise saunter.exceptions.InvalidLocatorString("%s is an invalid locator" % item)

    def __len__(self):
        s = WebDriverSelect(self.driver.find_element_by_locator(self.locator))
        return len(s.all_selected_options)

    def append(self, item):
        s = WebDriverSelect(self.driver.find_element_by_locator(self.locator))
        method = item[:item.find("=")]
        value = item[item.find("=") + 1:]
        if method == "value":
            s.select_by_value(value)
        elif method == "index":
            s.select_by_index(value)
        elif method == "text":
            s.select_by_visible_text(value)
        else:
            raise saunter.exceptions.InvalidLocatorString("%s is an invalid locator" % item)

########NEW FILE########
__FILENAME__ = number
# Copyright 2011 Element 34
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
======
Number
======
"""
from saunter.po.webdriver.element import Element
from saunter.SeleniumWrapper import SeleniumWrapper as wrapper
from saunter.exceptions import ElementNotFound
from saunter.SaunterWebDriver import SaunterWebDriver


class Number(Element):
    """
    Base element class for Number fields
    """
    def __set__(self, obj, val):
        e = SaunterWebDriver.find_element_by_locator(self.locator)
        e.send_keys(val)

    def __get__(self, obj, cls=None):
        try:
            e = SaunterWebDriver.find_element_by_locator(self.locator)
            return int(e.text)
        except AttributeError as e:
            if str(e) == "'SeleniumWrapper' object has no attribute 'connection'":
                pass
            else:
                raise e
        except ElementNotFound as e:
            msg = "Element %s was not found. It is used in the %s page object in the %s module." % (self.locator, obj.__class__.__name__, self.__module__)
            raise ElementNotFound(msg)

########NEW FILE########
__FILENAME__ = page
# Copyright 2011 Element 34
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
====
Page
====
"""
from saunter.po import timeout_seconds
from saunter.exceptions import ElementVisiblityTimeout, ElementTextTimeout
import time
from selenium.common.exceptions import StaleElementReferenceException
import saunter.ConfigWrapper
from selenium.webdriver.support.wait import WebDriverWait


class Page(object):
    """
    Top of the PO page tree
    """

    def __init__(self, driver):
        self.driver = driver
        if not hasattr(self, 'config'):
            self.cf = saunter.ConfigWrapper.ConfigWrapper()
            self.config = self.cf

        if not "short_wait" in self.cf["selenium"]:
            setattr(self, 'short_wait', WebDriverWait(self.driver, self.cf['selenium']['timeout'] / 2))
            setattr(self, 'wait', WebDriverWait(self.driver, self.cf['selenium']['timeout']))
            setattr(self, 'long_wait', WebDriverWait(self.driver, self.cf['selenium']['timeout'] * 2))

    def is_element_available(self, locator):
        """
        Synchronization method for making sure the element we're looking for is not only on the page,
        but also visible -- since Se will happily deal with things that aren't visible.

        Use this instead of is_element_present most of the time.
        """
        if self.driver.is_element_present(locator):
            if self.driver.is_visible(locator):
                return True
            else:
                return False
        else:
            return False

    def wait_for_available(self, locator):
        """
        Synchronization to deal with elements that are present, and are visible

        :raises: ElementVisiblityTimeout
        """
        for i in range(timeout_seconds):
            try:
                if self.is_element_available(locator):
                    break
            except:
                pass
            time.sleep(1)
        else:
            raise ElementVisiblityTimeout("%s availability timed out" % locator)
        return True

    def wait_for_visible(self, locator):
        """
        Synchronization to deal with elements that are present, but are disabled until some action
        triggers their visibility.

        :raises: ElementVisiblityTimeout
        """
        for i in range(timeout_seconds):
            try:
                if self.driver.is_visible(locator):
                    break
            except:
                pass
            time.sleep(1)
        else:
            raise ElementVisiblityTimeout("%s visibility timed out" % locator)
        return True

    def wait_for_hidden(self, locator):
        """
        Synchronization to deal with elements that are present, but are visibility until some action
        triggers their hidden-ness.

        :raises: ElementVisiblityTimeout=
        """
        for i in range(timeout_seconds):
            if self.driver.is_visible(locator):
                time.sleep(1)
            else:
                break
        else:
            raise ElementVisiblityTimeout("%s visibility timed out" % locator)
        return True

    def wait_for_text(self, locator, text):
        """
        Synchronization on some text being displayed in a particular element.

        :raises: ElementVisiblityTimeout
        """
        for i in range(timeout_seconds):
            try:
                e = self.driver.find_element_by_locator(locator)
                if e.text == text:
                    break
            except:
                pass
            time.sleep(1)
        else:
            raise ElementTextTimeout("%s value timed out" % locator)
        return True

    def wait_for_value(self, locator, text):
        """
        Synchronization on some value being set in a particular element.

        :raises: ElementVisiblityTimeout

        """
        for i in range(timeout_seconds):
            try:
                e = self.driver.find_element_by_locator(locator)
                if e.value == text:
                    break
            except:
                pass
            time.sleep(1)
        else:
            raise ElementTextTimeout("%s value timed out" % locator)
        return True

    def wait_for_value_changed(self, locator, text):
        e = self.driver.find_element_by_locator(locator)
        for i in range(timeout_seconds):
            try:
                if len(e.text.strip()) != 0 and e.text != text:
                    return True
            except StaleElementReferenceException, e:
                e = self.driver.find_element_by_locator(locator)
            finally:
                time.sleep(1)
        else:
            raise saunter.exceptions.ElementVisiblityTimeout("%s visibility timed out" % locator)

    def wait_for_element_not_present(self, locator):
        """
        Synchronization helper to wait until some element is removed from the page

        :raises: ElementVisiblityTimeout
        """
        for i in range(timeout_seconds):
            if self.driver.is_element_present(locator):
                time.sleep(1)
            else:
                break
        else:
            raise ElementVisiblityTimeout("%s presence timed out" % locator)
        return True

########NEW FILE########
__FILENAME__ = select
# Copyright 2011 Element 34
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
======
Select
======
"""
from saunter.po.webdriver.element import Element
from saunter.web_element import WebElement
from saunter.exceptions import ElementNotFound
from saunter.SaunterWebDriver import SaunterWebDriver
from selenium.webdriver.support.select import Select as WebDriverSelect
import saunter.exceptions


class Select(Element, WebDriverSelect):
    """
    Base element class for Select fields
    """
    def __set__(self, obj, val):
        s = WebDriverSelect(obj.driver.find_element_by_locator(self.locator))
        method = val[:val.find("=")]
        value = val[val.find("=") + 1:]
        if method == "value":
            s.select_by_value(value)
        elif method == "index":
            s.select_by_index(value)
        elif method == "text":
            s.select_by_visible_text(value)
        else:
            raise saunter.exceptions.InvalidLocatorString(val)

    def __get__(self, obj, cls=None):
        try:
            s = WebDriverSelect(obj.driver.find_element_by_locator(self.locator))
            e = s.first_selected_option
            return str(e.text)
        except AttributeError as e:
            if str(e) == "'SeleniumWrapper' object has no attribute 'connection'":
                pass
            else:
                raise e


class Select2(Element, WebDriverSelect):
    def __init__(self, driver, locator):
        self.driver = driver
        self.locator = locator

    @property
    def selected(self):
        s = WebDriverSelect(self.driver.find_element_by_locator(self.locator))
        e = s.first_selected_option
        return str(e.text)

    @selected.setter
    def selected(self, val):
        s = WebDriverSelect(self.driver.find_element_by_locator(self.locator))
        method = val[:val.find("=")]
        value = val[val.find("=") + 1:]
        if method == "value":
            s.select_by_value(value)
        elif method == "index":
            s.select_by_index(value)
        elif method == "text":
            s.select_by_visible_text(value)
        else:
            raise saunter.exceptions.InvalidLocatorString(val)

    @property
    def options(self):
        s = WebDriverSelect(self.driver.find_element_by_locator(self.locator))
        options = s.options
        text = [option.text.strip() for option in options]
        return text

########NEW FILE########
__FILENAME__ = text
# Copyright 2011 Element 34
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
====
Text
====
"""
from saunter.po.webdriver.unicode import Unicode
from saunter.SeleniumWrapper import SeleniumWrapper as wrapper
from saunter.exceptions import ElementNotFound


class Text(Unicode):
    def __get__(self, obj, cls=None):
        return str(super(Text, self).__get__(obj, cls))

########NEW FILE########
__FILENAME__ = unicode
# Copyright 2011 Element 34
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
=======
Unicode
=======
"""
from saunter.po.webdriver.element import Element
from saunter.SeleniumWrapper import SeleniumWrapper as wrapper
from saunter.exceptions import ElementNotFound
from saunter.SaunterWebDriver import SaunterWebDriver


class Unicode(Element):
    """
    Base element class for Unicode fields
    """
    def __set__(self, obj, val):
        e = obj.driver.find_element_by_locator(self.locator)
        e.send_keys(val)

    def __get__(self, obj, cls=None):
        e = obj.driver.find_element_by_locator(self.locator)
        if e.tag_name in ["input", "textarea"]:
            return e.get_attribute("value")
        return e.text

########NEW FILE########
__FILENAME__ = couch_provider
import ConfigParser
import couchdb.client
import random
import socket
import saunter.ConfigWrapper
from saunter.exceptions import ProviderException


# as will this
class CouchProvider(object):
    def __init__(self, database):
        cf = saunter.ConfigWrapper.ConfigWrapper()

        # read url from the config
        if "couchdb" in cf and "url" in cf["couch"]:
            url = cf["saunter"]["couchdb"]["url"]
        else:
            url = None

        # make sure we can connect to the server
        server = couchdb.client.Server(url=url)
        try:
            server.version()
        except socket.error:
            raise ProviderException('couch server not found at %s' % url)

        # check that the database is in the server
        if database not in server:
            raise ProviderException('database "%s" does not exist' % database)
        self.database = server[database]

# this will live per-project in $saunter_root/lib/providers
# class MySubclassedCouchProvider(CouchProvider):
#     def __init__(self, database):
#         super(MySubclassedCouchProvider, self).__init__(database)

#     def random_user(self):
#         map_fun = '''function(doc) {
#             emit(doc.username, null);
#         }'''
#         all_users = [user.id for user in self.database.query(map_fun=map_fun)]
#         random_user_id = random.choice(all_users)
#         return self.database.get(random_user_id)

#     def random_admin_user(self):
#         map_fun = '''function(doc) {
#             if (doc.role == 'admin')
#                 emit(doc.username, null);
#         }'''
#         all_users = [user.id for user in self.database.query(map_fun=map_fun)]
#         random_user_id = random.choice(all_users)
#         return self.database.get(random_user_id)

# for when I figure out how to test this stuff

# if __name__ == '__main__':
#     # in a saunter context, this is stored in the config
#     config = ConfigParser.ConfigParser()
#     config.add_section('couchdb')
#     config.set('couchdb', 'url', 'http://localhost:5984/')

#     c = MySubclassedCouchProvider('people')

#     # records from couchdb are 'just' dictionaries
#     random_user = c.random_user()
#     print(random_user['username'])

#     random_admin_user = c.random_admin_user()
#     print(random_admin_user['username'])

########NEW FILE########
__FILENAME__ = csv_provider
# Copyright 2011 Element 34
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
============
csv_provider
============
"""
import csv
import os.path
import random

import saunter.ConfigWrapper


class CSVProvider(object):
    """
    Provides data for either data driven scripting or as oracles from a csv file

    :params c: name of csv file located in support/csv directory
    """
    def __init__(self, c):
        cf = saunter.ConfigWrapper.ConfigWrapper()
        f = os.path.join(cf["saunter"]["base"], 'support', 'csv', c)
        self.data = csv.DictReader(open(f, 'rU'))

    def randomRow(self):
        """
        Gets a random row from the provider

        :returns: List
        """
        l = []
        for row in self.data:
            l.append(row)
        return random.choice(l)

########NEW FILE########
__FILENAME__ = django_provider
# Copyright 2011 Element 34
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
===============
django_provider
===============
"""
import os
import sys
import saunter.ConfigWrapper


class DjangoProvider(object):
    """
    Uses Django's Models to access the database
    """
    def __init__(self):
        cf = saunter.ConfigWrapper.ConfigWrapper()
        django_where = cf["django"]["installation"]
        if django_where not in sys.path:
            sys.path.append(django_where)

        django_name = cf.get("Django", "app")
        if not 'DJANGO_SETTINGS_MODULE' in os.environ:
            os.environ['DJANGO_SETTINGS_MODULE'] = "%s.settings" % django_name

    def get_random_user(self):
        """
        Gets a random user from the provider

        :returns: Dictionary
        """
        from provider.models import User
        u = User.objects.order_by('?')[0]
        return {"username": u.username, "password": u.password, "fullname": u.fullname}

########NEW FILE########
__FILENAME__ = mysql_provider
# Copyright 2013 Element 34
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
================
mysql_provider
================
"""
import mysql.connector

import saunter.ConfigWrapper


class DBProvider(object):
    """
    MySQL powered provider

    :params db: name of db file located in support/db directory
    """
    def __init__(self, db):
        try:
            cf = saunter.ConfigWrapper.ConfigWrapper()
        except:
            print('ooooo')

        self.mysql = mysql.connector.connect(
            user=cf["saunter"]["mysql"]["user"],
            password=cf["saunter"]["mysql"]["password"],
            host=cf["saunter"]["mysql"]["host"],
            database=cf["saunter"]["mysql"]["database"]
        )

    def __del__(self):
        self.mysql.close()

    # this would sit in the client side implementation

    # def get_random_user(self):
    #     """
    #     Gets a random user from the provider

    #     :returns: Dictionary
    #     """
    #     c = self.db.cursor()
    #     c.execute('''SELECT username, password, fullname FROM users
    #                  WHERE rowid >= (abs(random()) % (SELECT max(rowid) FROM users))
    #                  LIMIT 1''')
    #     r = c.fetchone()
    #     return {"username": r[0], "password": r[1], "fullname": r[2]}

########NEW FILE########
__FILENAME__ = sqlite3_provider
# Copyright 2011 Element 34
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
================
sqlite3_provider
================
"""
import os.path
import sqlite3

import saunter.ConfigWrapper


class DBProvider(object):
    """
    SQLite3 powered provider

    :params db: name of db file located in support/db directory
    """
    def __init__(self, db):
        try:
            cf = saunter.ConfigWrapper.ConfigWrapper()
        except:
            print('ooooo')
        self.db = sqlite3.connect(os.path.join(cf["saunter"]["base"], 'support', 'db', db))

    def __del__(self):
        self.db.close()

    def get_random_user(self):
        """
        Gets a random user from the provider

        :returns: Dictionary
        """
        c = self.db.cursor()
        c.execute('''SELECT username, password, fullname FROM users
                     WHERE rowid >= (abs(random()) % (SELECT max(rowid) FROM users))
                     LIMIT 1''')
        r = c.fetchone()
        return {"username": r[0], "password": r[1], "fullname": r[2]}

########NEW FILE########
__FILENAME__ = saucelabs
from _pytest.mark import MarkInfo
import json
import requests
import time
import os.path


class SauceLabs(object):
    def __init__(self, item):
        # session couldn't be established for some reason
        if not hasattr(item.parent._obj, "sauce_session"):
            return

        self.sauce_session = item.parent._obj.sauce_session
        self.username = item.parent._obj.config.get("SauceLabs", "username")
        self.key = item.parent._obj.config.get("SauceLabs", "key")
        self.log_dir = item.parent._obj.config.get("Saunter", "log_dir")

        j = {}

        # name
        j["name"] = item.name

        # result
        if item.outcome.lower() == 'passed':
            # print("pass")
            j["passed"] = True
        else:
            # print("fail")
            j["passed"] = False

        # tags
        j["tags"] = []
        j["custom-data"] = {}
        for keyword in item.keywords:
            if isinstance(item.keywords[keyword], MarkInfo):
                # per item custom data
                if keyword == "saucelabs_customdata":
                    for key, value in item.keywords[keyword].kwargs.iteritems():
                        j["custom-data"][key] = value
                # tags
                else:
                    j["tags"].append(keyword)

        # global custom data
        if item.parent._obj.config.has_section('SauceLabs CustomData'):
            for option in item.parent._obj.config.options('SauceLabs CustomData'):
                j["custom-data"][option] = item.parent._obj.config.get('SauceLabs CustomData', option)

        # print(json.dumps(j))

        # update
        which_url = "https://saucelabs.com/rest/v1/%s/jobs/%s" % (self.username, self.sauce_session)
        r = requests.put(which_url,
                         data=json.dumps(j),
                         headers={"Content-Type": "application/json"},
                         auth=(self.username, self.key))
        r.raise_for_status()

        if item.parent._obj.config.getboolean("SauceLabs", "get_video"):
            self._fetch_sauce_artifact("video.flv")

        if item.parent._obj.config.getboolean("SauceLabs", "get_log"):
            self._fetch_sauce_artifact("selenium-server.log")

    def _fetch_sauce_artifact(self, which):
        sauce_session = self.sauce_session
        which_url = "https://saucelabs.com/rest/%s/jobs/%s/results/%s" % (self.username, self.sauce_session, which)
        code = 404
        timeout = 0
        while code in [401, 404]:
            r = requests.get(which_url, auth=(self.username, self.key))
            try:
                code = r.status_code
                r.raise_for_status()
            except requests.exceptions.HTTPError, e:
                time.sleep(4)

        artifact = open(os.path.join(self.log_dir, which), "wb")
        artifact.write(r.content)
        artifact.close()

########NEW FILE########
__FILENAME__ = SaunterWebDriver
# Copyright 2011 Element 34
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import saunter.exceptions
from selenium import webdriver
from selenium.common.exceptions import NoSuchElementException
from saunter.web_element import WebElement


class SaunterWebDriver(webdriver.Remote):
    def __init__(self, **kwargs):
        super(SaunterWebDriver, self).__init__(**kwargs)

    def find_element_by_locator(self, locator):
        locator_type = locator[:locator.find("=")]
        if locator_type == "":
            raise saunter.exceptions.InvalidLocatorString(locator)
        locator_value = locator[locator.find("=") + 1:]
        if locator_type == 'class':
            return WebElement(self.find_element_by_class_name(locator_value))
        elif locator_type == 'css':
            return WebElement(self.find_element_by_css_selector(locator_value))
        elif locator_type == 'id':
            return WebElement(self.find_element_by_id(locator_value))
        elif locator_type == 'link':
            return WebElement(self.find_element_by_link_text(locator_value))
        elif locator_type == 'name':
            return WebElement(self.find_element_by_name(locator_value))
        elif locator_type == 'plink':
            return WebElement(self.find_element_by_partial_link_text(locator_value))
        elif locator_type == 'tag':
            return WebElement(self.find_element_by_tag_name(locator_value))
        elif locator_type == 'xpath':
            return WebElement(self.find_element_by_xpath(locator_value))
        else:
            raise saunter.exceptions.InvalidLocatorString(locator)

    def find_elements_by_locator(self, locator):
        locator_type = locator[:locator.find("=")]
        if locator_type == "":
            raise saunter.exceptions.InvalidLocatorString(locator)
        locator_value = locator[locator.find("=") + 1:]
        if locator_type == 'class':
            elements = self.find_elements_by_class_name(locator_value)
        elif locator_type == 'css':
            elements = self.find_elements_by_css_selector(locator_value)
        elif locator_type == 'id':
            elements = self.find_elements_by_id(locator_value)
        elif locator_type == 'link':
            elements = self.find_elements_by_link_text(locator_value)
        elif locator_type == 'name':
            elements = self.find_elements_by_name(locator_value)
        elif locator_type == 'plink':
            elements = self.find_elements_by_partial_link_text(locator_value)
        elif locator_type == 'tag':
            elements = self.find_elements_by_tag_name(locator_value)
        elif locator_type == 'xpath':
            elements = self.find_elements_by_xpath(locator_value)
        else:
            raise saunter.exceptions.InvalidLocatorString(locator)

        return [WebElement(e) for e in elements]

    # @deprecated
    @classmethod
    def click(cls, locator):
        driver = se_wrapper().connection

        e = cls.find_element_by_locator(locator)
        e.click()

    def is_element_present(self, locator):
        try:
            self.find_element_by_locator(locator)
            return True
        except NoSuchElementException:
            return False

    def is_visible(self, locator):
        return self.find_element_by_locator(locator).is_displayed()

########NEW FILE########
__FILENAME__ = base
# Copyright 2011 Element 34
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import time
import urllib2
import os
import os.path
import saunter.matchers as matchers


class BaseTestCase(object):
    def assertEqual(self, first, second, msg=None):
        self.matchers.assert_equal(first, second, msg)

    def assertNotEqual(self, first, second, msg=None):
        self.matchers.assert_not_equal(first, second, msg)

    def assertTrue(self, expr, msg=None):
        self.matchers.assert_true(expr, msg)

    def assertFalse(self, expr, msg=None):
        self.matchers.assert_false(expr, msg)

    def assertIs(self, first, second, msg=None):
        self.matchers.assert_is(first, second, msg)

    def assertIsNot(self, first, second, msg=None):
        self.matchers.assert_is_not(first, second, msg)

    def assertIsNone(self, expr, msg=None):
        self.matchers.assert_is_none(expr, msg)

    def assertIsNotNone(self, expr, msg=None):
        self.matchers.assert_is_not_none(expr, msg)

    def assertIn(self, first, second, msg=None):
        self.matchers.assert_in(first, second, msg)

    def assertNotIn(self, first, second, msg=None):
        self.matchers.assert_not_in(first, second, msg)

    def assertIsInstance(self, obj, cls, msg=None):
        self.matchers.assert_is_instance(obj, cls, msg)

    def assertIsNotInstance(self, obj, cls, msg=None):
        self.matchers.assert_is_not_instance(obj, cls, msg)

    def _screenshot_prep_dirs(self):
        class_dir = os.path.join(os.path.join(self.config['saunter']['log_dir'], self.__class__.__name__))
        if not os.path.exists(class_dir):
            os.makedirs(class_dir)

        method_dir = os.path.join(class_dir, self.current_method_name)
        if not os.path.exists(method_dir):
            os.makedirs(method_dir)

        return method_dir

########NEW FILE########
__FILENAME__ = webdriver
# Copyright 2011 Element 34
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
===============
SaunterTestCase
===============
"""
import logging
import os
import os.path
import requests
import sys

import saunter.ConfigWrapper

config = saunter.ConfigWrapper.ConfigWrapper()
if "SauceLabs" in config and config["SauceLabs"]["ondemand"]:
    import json

try:
    from tailored.webdriver import WebDriver
except ImportError as e:
    if "DOCGENERATION" not in os.environ:
        raise

from selenium.webdriver.common.by import By
from selenium.common.exceptions import WebDriverException
from selenium.common.exceptions import TimeoutException
from saunter.exceptions import ProfileNotFound
from selenium.webdriver.remote.webelement import WebElement
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
from saunter.testcase.base import BaseTestCase
from saunter.SaunterWebDriver import SaunterWebDriver
from selenium.webdriver import FirefoxProfile
import py.test
from _pytest.mark import MarkInfo

from saunter.matchers import Matchers

capabilities_map = {
    "firefox": DesiredCapabilities.FIREFOX,
    "internet explorer": DesiredCapabilities.INTERNETEXPLORER,
    "internetexplorer": DesiredCapabilities.INTERNETEXPLORER,
    "iexplore": DesiredCapabilities.INTERNETEXPLORER,
    "ie": DesiredCapabilities.INTERNETEXPLORER,
    "chrome": DesiredCapabilities.CHROME,
    "opera": DesiredCapabilities.OPERA,
    "chrome": DesiredCapabilities.CHROME,
    "htmlunitjs": DesiredCapabilities.HTMLUNITWITHJS,
    "htmlunit": DesiredCapabilities.HTMLUNIT,
    "iphone": DesiredCapabilities.IPHONE,
    "ipad": DesiredCapabilities.IPAD,
    "android": DesiredCapabilities.ANDROID,
    "phantomjs": DesiredCapabilities.PHANTOMJS,
}

os_map = {
    "XP": "XP",
    "Windows 2003": "XP",
    "VISTA": "VISTA",
    "Windows 2008": "VISTA",
    "Linux": "LINUX",
    "LINUX": "LINUX",
    "MAC": "MAC"
}


class SaunterTestCase(BaseTestCase):
    """
    Parent class of all script classes used for custom asserts (usually 'soft' asserts) and shared fixture setup
    and teardown
    """
    def setup_method(self, method):
        """
        Parent class of all script classes used for custom asserts (usually 'soft' asserts) and shared fixture setup
        and teardown
        """
        self.cf = self.config = saunter.ConfigWrapper.ConfigWrapper()

        self.current_method_name = method.__name__

        browser = self.cf["browsers"][self.cf["saunter"]["default_browser"]]
        if browser["type"][0] == "*":
            browser = browser["type"] = browser["type"][1:]

        profile = None
        if browser["type"] == 'firefox':
            if browser["profiles"][sys.platform]:
                profile_path = os.path.join(self.cf["saunter"]["base"], 'support', 'profiles', browser["profiles"][sys.platform])
            elif browser["profiles"]["profile"]:
                profile_path = os.path.join(self.cf["saunter"]["base"], 'support', 'profiles', browser["profiles"]["profile"])
            else:
                profile_path = None

            if profile_path:
                if os.path.isdir(profile_path):
                    profile = FirefoxProfile(profile_path)
                else:
                    raise ProfileNotFound("Profile not found at %s" % profile_path)

        if "saucelabs" in browser and browser["saucelabs"]["ondemand"]:
            desired_capabilities = {
                "platform": self.cf["sauceLabs"]["os"],
                "browserName": self.cf["sauceLabs"]["browser"],
                "version": self.cf.get("SauceLabs", "browser_version"),
                "name": method.__name__
            }
            if desired_capabilities["browserName"][0] == "*":
                desired_capabilities["browserName"] = desired_capabilities["browserName"][1:]
            if desired_capabilities["platform"] in os_map:
                desired_capabilities["platform"] = os_map[desired_capabilities["platform"]]

            if self.cf.has_option("SauceLabs", "selenium_version"):
                desired_capabilities['selenium-version'] = self.cf.get('SauceLabs', 'selenium_version')

            command_executor = "http://%s:%s@ondemand.saucelabs.com:80/wd/hub" % (self.cf.get("SauceLabs", "username"), self.cf.get("SauceLabs", "key"))
        else:
            desired_capabilities = capabilities_map[browser["type"]]

            if browser["proxy"]["type"] and browser["proxy"]["type"].lower() == "browsermob":
                from browsermobproxy import Client
                self.client = Client(self.cf.get("Proxy", "proxy_url"))
                self.client.add_to_webdriver_capabilities(desired_capabilities)

            if "is grid" in self.cf["selenium"] and self.cf["selenium"]["executor"]["is grid"]:
                    if browser["grid filters"]["platform"]:
                        desired_capabilities["platform"] = browser["grid filters"]["platform"].upper()
                    if browser["grid filters"]["version"]:
                        desired_capabilities["platform"] = str(browser["grid filters"]["version"])

            command_executor = "http://%s:%s/wd/hub" % (self.cf["selenium"]["executor"]["host"], self.cf["selenium"]["executor"]["port"])

        self.driver = WebDriver(desired_capabilities=desired_capabilities, command_executor=command_executor, browser_profile=profile)

        self.verificationErrors = []
        self.matchers = Matchers(self.driver, self.verificationErrors)

        if "saucelabs" in self.cf["browsers"][self.cf["saunter"]["default_browser"]] and self.cf["browsers"][self.cf["saunter"]["default_browser"]]["saucelabs"]["ondemand"]:
            self.sauce_session = self.driver.session_id

        self._screenshot_number = 1

    def teardown_method(self, method):
        """
        Default teardown method for all scripts. If run through Sauce Labs OnDemand, the job name, status and tags
        are updated. Also the video and server log are downloaded if so configured.
        """
        if hasattr(self, "config"):
            if "saucelabs" in self.cf["browsers"][self.cf["saunter"]["default_browser"]] and not self.cf["browsers"][self.cf["saunter"]["default_browser"]]["saucelabs"]["ondemand"]:
                self.take_named_screenshot("final")

        if hasattr(self, "driver"):
            self.driver.quit()

    def take_numbered_screenshot(self):
        if self.config.has_option("Saunter", "take_screenshots"):
            if self.cf.getboolean("Saunter", "take_screenshots"):
                method_dir = self._screenshot_prep_dirs()

                self.driver.get_screenshot_as_file(os.path.join(method_dir, str(self._screenshot_number).zfill(3) + ".png"))
                self._screenshot_number = self._screenshot_number + 1

                if self.config.has_option("Saunter", "jenkins"):
                    if self.cf.getboolean("Saunter", "jenkins"):
                        sys.stdout.write(os.linesep + "[[ATTACHMENT|%s]]" % image_path + os.linesep)

    def take_named_screenshot(self, name):
        method_dir = self._screenshot_prep_dirs()

        image_path = os.path.join(method_dir, str(name) + ".png")
        self.driver.get_screenshot_as_file(image_path)

        if "ci_type" in self.cf and self.cf["ci_type"].lower() == "jenkins":
            sys.stdout.write(os.linesep + "[[ATTACHMENT|%s]]" % image_path + os.linesep)

########NEW FILE########
__FILENAME__ = web_element
from selenium.webdriver.remote.webelement import WebElement
import saunter.exceptions


class WebElement(WebElement):
    def __init__(self, element):
        self.__dict__.update(element.__dict__)

    def find_element_by_locator(self, locator):
        locator_type = locator[:locator.find("=")]
        if locator_type == "":
            raise saunter.exceptions.InvalidLocatorString(locator)
        locator_value = locator[locator.find("=") + 1:]
        if locator_type == 'class':
            return WebElement(self.find_element_by_class_name(locator_value))
        elif locator_type == 'css':
            return WebElement(self.find_element_by_css_selector(locator_value))
        elif locator_type == 'id':
            return WebElement(self.find_element_by_id(locator_value))
        elif locator_type == 'link':
            return WebElement(self.find_element_by_link_text(locator_value))
        elif locator_type == 'name':
            return WebElement(self.find_element_by_name(locator_value))
        elif locator_type == 'plink':
            return WebElement(self.find_element_by_partial_link_text(locator_value))
        elif locator_type == 'tag':
            return WebElement(self.find_element_by_tag_name(locator_value))
        elif locator_type == 'xpath':
            return WebElement(self.find_element_by_xpath(locator_value))
        else:
            raise saunter.exceptions.InvalidLocatorString(locator)

    def find_elements_by_locator(self, locator):
        locator_type = locator[:locator.find("=")]
        if locator_type == "":
            raise saunter.exceptions.InvalidLocatorString(locator)
        locator_value = locator[locator.find("=") + 1:]
        if locator_type == 'class':
            elements = self.find_elements_by_class_name(locator_value)
        elif locator_type == 'css':
            elements = self.find_elements_by_css_selector(locator_value)
        elif locator_type == 'id':
            elements = self.find_elements_by_id(locator_value)
        elif locator_type == 'link':
            elements = self.find_elements_by_link_text(locator_value)
        elif locator_type == 'name':
            elements = self.find_elements_by_name(locator_value)
        elif locator_type == 'plink':
            elements = self.find_elements_by_partial_link_text(locator_value)
        elif locator_type == 'tag':
            elements = self.find_elements_by_tag_name(locator_value)
        elif locator_type == 'xpath':
            elements = self.find_elements_by_xpath(locator_value)
        else:
            raise saunter.exceptions.InvalidLocatorString(locator)

        return [WebElement(e) for e in elements]

########NEW FILE########
__FILENAME__ = conftest
# Copyright 2011 Element 34
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
import os.path
import py
import sys
import random
import saunter.saucelabs


def pytest_configure(config):
    sys.path.append(os.path.join(os.getcwd(), "modules"))


# Comment or remove to disable auto screenshotting on error
def pytest_runtest_call(item, __multicall__):
    try:
        __multicall__.execute()
    except Exception as e:
        if hasattr(item.parent.obj, 'driver') or hasattr(item.parent.obj, 'selenium'):
            item.parent.obj.take_named_screenshot('exception')
        raise(e)


def pytest_runtest_makereport(__multicall__, item, call):
    if call.when == "call":
        try:
            assert([] == item.parent.obj.verificationErrors)
        except AssertionError:
            call.excinfo = py.code.ExceptionInfo()

    report = __multicall__.execute()

    item.outcome = report.outcome

    if call.when == "call":
        if hasattr(item.parent.obj, 'config') and item.parent.obj.config.getboolean('SauceLabs', 'ondemand'):
            s = saunter.saucelabs.SauceLabs(item)

    return report


def pytest_runtest_teardown(__multicall__, item):
    __multicall__.execute()

    # if hasattr(item.parent.obj, 'config') and item.parent.obj.config.getboolean('SauceLabs', 'ondemand'):
    #     s = saunter.saucelabs.SauceLabs(item)


def pytest_collection_modifyitems(items):
    random.shuffle(items)

########NEW FILE########
__FILENAME__ = page
from saunter.po.webdriver.page import Page as SaunterPage

from saunter.po import timeout_seconds
from selenium.webdriver.support.ui import WebDriverWait
from selenium.common.exceptions import TimeoutException
from selenium.common.exceptions import NoSuchElementException
import time


class Page(SaunterPage):
    pass

########NEW FILE########
__FILENAME__ = webdriver
"""
=============
WebDriver
=============
"""
from saunter.SaunterWebDriver import SaunterWebDriver


class WebDriver(SaunterWebDriver):
    """
    Modifications to the core WebDriver API are done in this class
    """
    def __init__(self, **kwargs):
        super(WebDriver, self).__init__(**kwargs)

########NEW FILE########
