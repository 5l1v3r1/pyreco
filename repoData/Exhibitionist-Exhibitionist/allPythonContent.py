__FILENAME__ = print_versions
#!/usr/bin/env python
import sys

print("\nINSTALLED VERSIONS")
print("------------------")
print("Python: %d.%d.%d.%s.%s" % sys.version_info[:])

try:
    import tornado
    print("tornado: %s" % tornado.version)
except:
    print("Tornado: Not installed")

try:
    import ws4py
    print("ws4py: %s" % ws4py.__version__)
except:
    print("ws4py: Not installed")

try:
    import requests
    print("Requests: %s" % requests.__version__)
except:
    print("Requests: Not installed")

print("\n")

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Exhibitionist documentation build configuration file, created by
# sphinx-quickstart on Thu Feb 28 13:27:27 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.intersphinx', 'sphinx.ext.todo', 'sphinx.ext.coverage', 'sphinx.ext.ifconfig', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Exhibitionist'
copyright = u'2013, y-p'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.1.0'
# The full version, including alpha/beta/rc tags.
release = '0.1.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Exhibitionistdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Exhibitionist.tex', u'Exhibitionist Documentation',
   u'y-p', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'exhibitionist', u'Exhibitionist Documentation',
     [u'y-p'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'Exhibitionist', u'Exhibitionist Documentation',
   u'y-p', 'Exhibitionist', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/': None}

########NEW FILE########
__FILENAME__ = app
#!/usr/bin/python
# -*- coding: utf-8 -*-
from __future__ import print_function

import os

from exhibitionist import get_server
from exhibitionist.util.common import UrlDisplay

import handlers

pjoin = os.path.join
dirname = lambda x: os.path.abspath(os.path.dirname(x))

# tell the server where the templates and static files
# are served from.
# This enables get_template_path() in request handlers
# and {{static_url(filename)}} in templates, if you're using
# the tornado template engine.
STATIC_DIR = pjoin(dirname(__file__), "static")
TEMPLATE_DIR = pjoin(dirname(__file__), "templates")

# Instantiate aserver, register handlers ("views"), and start the server listening
# websockets_enabled=True is the default, You can omit it for brevity
server = get_server(template_path=TEMPLATE_DIR,
                    static_path=STATIC_DIR,
                    websockets_enabled=True).add_handler(handlers).start()

obj = ["foo", "bar", "baz", 1, 2, 3] # the object to be viewed

# get the url of the MainViewHandler view defined in handlers
url = server.get_view_url("MainViewHandler", obj)

# UrlDisplay adapts to the environment in which it is run
# in ipnb you'll get inline html, in ipython-qtconsole it provides a hot link
# and in other environments, a text message with the url
#
# Alternatively, IPNB allows you to install a display hook based on object type
# google "ipython formatters for_type"
# or see:
# http://ipython.org/ipython-doc/stable/api/generated/IPython.core.formatters.html
UrlDisplay(url)

# If websockets are enabled, `server.websocket` becomes available and
# The server.notify_object(channel,payload) can be used push events to all
# clients subscribed to a channel. by convention the objid should be used as the
# channel name.
# See templates/index.html for the javascript that does the subscribing by
# send a "SUB" message over a websocket.
# server.notify_channel(channel,payload) is a closely related methods, that
# allows you to specify an arbitrary channel name. using notify_channel(objid,"foo")
# is the same as notify_object(obj,"foo") if objid corresponds to obj.
# You could for example have all clients register
# on the "all" channel, which would allow you to push a message to all active
# client regardless of the object view they requested.

# server.notify_object(obj,dict(msg_type="GREETING",payload="Hello World!"))


# when you're done, shutdown the server to release the socket
# server.stop()


if __name__ == "__main__":
    print("""
    You should be running this in an interactive session. If
    you are, to actually see a view you need to display it as
    the repr() of some object. The url for the view is in
    a variable called "url", which you can open in a browser:

    >>> url

    or try:

    >>> UrlDisplay(url,obj)

    to get a url/HTML view for a dict object created for you. The
    view will display as text/HTML depending on whether you're in
    the terminal, or in IPython-Notebook.

    Please look at the heavily-commented source for 'app.py' for
    help understanding how everything works.
""");
########NEW FILE########
__FILENAME__ = handlers
# -*- coding: utf-8 -*-
from __future__ import print_function

import os
import codecs
import logging

from exhibitionist.toolbox import (getLogger, http_handler, JSONRequestHandler,
                                   CORSMixin, StaticFileHandler,
                                   utf8, HTTPError, xhtml_escape)

context = None # get rid of "symbol missing" squiggles in rope

logger = getLogger(__name__)

# you can use your favorite template engine instead
# tornado engine uses "{{context}}" style placeholders,
# tmpl=Template(str) to construct templates,
# and tmpl.generate(**kwds), to render.
from tornado.template import Template

PROJECT_NAME = "myAwesomeProject"

# This endpoint will be  at http://{server_addr}/myAwesomeProject/{objid}
# JSONRequestHandler is a subclass of tornado's RequestHandler
# with the addition of JSONMixin, providing the write_json()
# method.
@http_handler(r'/%s/{{objid}}' % PROJECT_NAME,foo='bar')
class MainViewHandler(JSONRequestHandler):

    # any custom kwds argument specified via @http_handler
    # will be available in kwds
    def initialize(self,**kwds):
        kwds.get('foo') == 'bar'

    # prepare is called after __init__ is run
    def prepare(self):
        pass

    # get is invoked when the user issues an HTTP GET request, the
    # common case. You can also implement put, post, delete and others
    # similarly. see http://www.tornadoweb.org/documentation/web.html
    # whenever the special marker {{objid}} is included in the route
    # objid is passed as an argument to get, and the associated object
    # itself is available at 'context.object'. if an unrecognized
    # objid is provided, a 404 will be raised automatically.
    def get(self, objid):

        # Instantiate a template object using Template engine
        # This can be moved to prepare() when index.html is stabilized
        # Done like this, changes to the template are reflected
        # on (no-cache) refresh

        tmpl_file = os.path.join(self.get_template_path(),"index.html")
        if not(os.path.isdir(self.get_template_path())):
            self.set_status(500)
            return self.finish("Template path does not exist")

        with codecs.open(tmpl_file) as f:
            self.tmpl = Template(f.read())

        # validate the object's type to avoid mysterious errors later on
        if not isinstance(context.object, (list,tuple)):
            self.set_status(500)
            return self.finish("Bad object type, expected list or tuple")

        # Tornado makes query parameters available via `get_argument`.
        # Here we handle requests for "/myAwesomeProject/{objid}?format=json".
        # These are usually the AJAX requests issued by the client *after*
        # grabbing the HTML page, below.
        if self.get_argument("format", "").lower() == "json":
            # For this example, the payload for the json data returned
            # is just the string representation of the object.
            payload = unicode(context.object).encode('utf-8', 'replace')

            # write_json will encode the payload as json, and send it
            # to the client.
            #
            # IMPORTANT: the payload must be JSON-Encodable.
            #
            # JSONP is automatically used if a query parameter called "callback"
            # was given, jQuery's default name for jsnop.
            # See CORSMixin if you prefer avoiding JSONP.
            self.write_json(dict(payload=payload))

        # if the client requested "/myAwesomeProject/{objid}"
        # we render the HTMl and send it back to the client
        # this is usually the first request.
        else:
            # The object associated with {objid} is available here
            obj = context.object

            # Get back the url of this view. We embed this in the HTML returned
            # to the client, which uses it to issue AJAX requests back to us.
            # e.g '$.getJSON(api_url + "?format=json")' (javascript)
            # See templates/index.html for the javascript side of things
            api_url = context.get_view_url("MainViewHandler", obj)
            api_url += "?format=json"  # add query parameter to url

            # get the websocket connection url ("ws://server_addr/ws")
            # Also embedded int he client HTML, the client opens a websocket
            # on load, and subscribes to notification on the "channel= {objid}"
            ws_url = context.get_ws_url()
            # render the template , see /templates/index.html

            body = self.tmpl.generate(
                                      objid=objid,
                                      api_url=api_url,
                                      ws_url=ws_url,
                                      static_url=self.static_url)

            self.write(body) # send the HTML to client


# This handler demonstrates a different style of doing things
# with unique paths, rather then query parameters as seen above.
# CORSMixin can be used to allow cross-origin requests from FriendlyDomain.com

# Uncomment the decorator to activate this endpoint
#@http_handler(r'/%s/{{objid}}/(?P<parity>odd|even)'% PROJECT_NAME)
class AlternativeHandler(CORSMixin('FriendlyDomain.com'), JSONRequestHandler):
    def __init__(self, *args, **kwds):
        super(AlternativeHandler, self).__init__(*args, **kwds)

    # note the 'parity' arg, corresponding to route regex named capture group
    def get(self, objid, parity):

        # validate the object's type to avoid mysterious errors later on
        if not isinstance(context.object, list):
            raise HTTPError(500, # Server Error status code
                            log_message="bad object type") # to the client

        parity = parity.lower()
        base = 0
        if parity == 'odd':
            base = 1 # just the odd elements
        elif parity == 'even':
            base = 0 # just the even elements
        else:
            raise HTTPError(500, # Server Error status code
                            log_message="bad parity")

        # For this example, the payload for the json data returned
        # is just the string representation of the object.
        payload = context.object[base::2]

        # ensure payload is JSON-Encodable by converting everything to it's utf8 repr
        payload = map(utf8, payload)

        # always escape data which might end up as HTML.
        payload = map(xhtml_escape,
                      map(utf8, payload)) # ensure JSON-Encodable
        self.write_json(dict(payload=payload))



########NEW FILE########
__FILENAME__ = app
#!/usr/bin/python
# -*- coding: utf-8 -*-
import os
from math import sin,cos
import numpy as np

from exhibitionist.toolbox import WSMsg,UrlDisplay,get_server
import handlers

SPRITE_SIZE=60 # dimension of single image as rendered in HTML
FRAME_SIZE=600-SPRITE_SIZE-5 # calculare a reasonable framesize

pjoin = os.path.join
dirname = lambda x: os.path.abspath(os.path.dirname(x))
STATIC_DIR = pjoin(dirname(__file__), "static")
TEMPLATE_DIR = pjoin(dirname(__file__), "templates")

server = get_server(template_path=TEMPLATE_DIR,static_path=STATIC_DIR). \
    add_handler(handlers).start()


# generate xy coordinates of a spiral
def spiral(x=FRAME_SIZE/2,y=FRAME_SIZE/2,
           radius=FRAME_SIZE/2, npoints= 100,
           N_ARMS=3):
    def easing(i):
        return i #2-2*(1.0/(1+i**2))

    radius =float(radius)
    x =float(x)
    y =float(y)
    a=N_ARMS*1.0/radius * (2*3.14)

    t=0
    for i in xrange(npoints):
        yield(x+t*cos(a*t),y+t*sin(a*t))
        t = radius*easing(i*1.0/npoints)

obj=list(spiral())
UrlDisplay(server.get_view_url("KittenGram",obj,'cat'))
url=server.get_view_url("KittenGram",obj,'cat')
UrlDisplay(url,width=str(FRAME_SIZE)+"px")

# open view in browser

# server.notify_object(obj,WSMsg("CMD","play")) # meow
# server.notify_object(obj,WSMsg('CMD','dog')) # I'm a dog person
# server.notify_object(obj,WSMsg("CMD","play")) # woof
# server.notify_object(obj,WSMsg('CMD','cat')) # No, I'm a cat person


# Try opening multiple views of either type in several tabs,
# and conduct a pet orchestra with a "play" message.


# when you're done, shutdown the server to release the socket
# server.stop()


if __name__ == "__main__":
    print("""
    You should be running this in an interactive session. If
    you are, to actually see a view you need to display it as
    the repr() of some object. The url for the view is in
    a variable called "url", which you can open in a browser:

    >>> url

    or try:

    >>> UrlDisplay(url,"600px")

    to get the url/HTML view, depending on whether you're in the
    terminal, or in IPython-Notebook.

    Please look at the source for 'app.py' for more things to try out
    in the interactive prompt.

    This example has some javascript just waiting for you to push
    an event at it.

    Once you have a view loaded, Try these:

    >>> server.notify_object(obj,WSMsg("CMD","play"))
    *meow*
    >>> server.notify_object(obj,WSMsg('CMD','dog'))
    'I'm a dog person'
    >>> server.notify_object(obj,WSMsg("CMD","play"))
    *woof*
    >>> server.notify_object(obj,WSMsg('CMD','cat'))
    'No, I'm a cat person'
""");


########NEW FILE########
__FILENAME__ = handlers
# from exhibitionist.toolbox import  http_handler,JSONRequestHandler,Template
import os
import codecs
import threading
from exhibitionist.toolbox import *

from tornado.template import Template

context = None # lose the warnings

@http_handler(r'/numpy/{{objid}}/(?P<animal>cat|dog)')
class KittenGram(JSONRequestHandler):
# prepare is called after __init__ is run
    def prepare(self):
        tmpl_file = os.path.join(self.get_template_path(),"index.html")
        if not(os.path.isdir(self.get_template_path())):
            self.set_status(500)
            return self.finish("Template path does not exist")
        with codecs.open(tmpl_file) as f:
            self.tmpl = Template(f.read())

    def get(self, objid, animal):
        if self.get_argument("format", "").lower() == "json":
            self.write_json(context.object)
        else:
            api_url = context.get_view_url("KittenGram", context.object, animal)
            ws_url = context.get_ws_url()
            self.write(self.tmpl.generate(objid=objid,
                                          api_url=api_url + '?format=json',
                                          ws_url=ws_url,
                                          animal=animal,
                                          static_url=self.static_url))

########NEW FILE########
__FILENAME__ = app
#!/usr/bin/python
# -*- coding: utf-8 -*-
from __future__ import print_function

import os

import pandas as pd
from pandas.util.testing import makeCustomDataframe as mkdf

from exhibitionist.toolbox import UrlDisplay, get_server

import handlers

# make sure the handlers module is on your python path
# you could just use os.chdir to set the working directory
# to the example root directory.


pjoin = os.path.join
dirname = lambda x: os.path.abspath(os.path.dirname(x))
STATIC_DIR = pjoin(dirname(__file__), "static")
TEMPLATE_DIR = pjoin(dirname(__file__), "templates")

server = get_server(template_path=TEMPLATE_DIR,static_path=STATIC_DIR). \
    add_handler(handlers).start()


def my_repr(df):
    return UrlDisplay(server.get_view_url("dfView", df), width="800px",
                      height="350px",fs_btn=True)._repr_html_()

# monkey patch pandas to override it's default HTML repr. This could also
# be done # upstream as part of pandas itself.
# a cleaner way would be to use IPNB type-based display hooking
# google "ipython formatters for_type"
# or see
# http://ipython.org/ipython-doc/stable/api/generated/IPython.core.formatters.html

# print fancy link/embedded HTML in qtconsole/ipnb
pd.DataFrame._repr_html_ = my_repr
# now, displaying dataframes in IPython-notebook will open up
# an IFRAME with the grid view

df=mkdf(5000,10)

# now we can display the dataframe from our python prompt
# and view the url or rendered HTML
# >>> df

# try to modify the datdrame inplace, and refresh the grid
# with the bottom left-hand button
# df.ix[0,0]="pooh"


# when you're done, shutdown the server to release the socket
# server.stop()



if __name__ == "__main__":
    print("""
    You should be running this in an interactive session. If
    you are, to actually see a view you need to display an object,
    so it's repr() will be displayed. So try:

    >>> df

    to get the url/HTML view, depending on whether you're in the
    terminal, or in IPython-Notebook.

    Please look at the source for 'app.py' for more things to try out
    in the interactive prompt.

    In particular, try modifying the df object:

    >>> df.ix[0,0] = "Pooh"

    and refreshing the grid (refresh button at bottom left corner).

""");

########NEW FILE########
__FILENAME__ = handlers
# -*- coding: utf-8 -*-
from __future__ import print_function

import codecs
import os
import logging

from exhibitionist.toolbox import ( getLogger, http_handler,
                                    JSONRequestHandler, StaticFileHandler,
                                    HTTPError)
context = None # eliminate tooling "symbol not found"
logger = getLogger(__name__)

from tornado.template import Template


@http_handler(r'/pandas/df/{{objid}}$', view_name="dfView")
class GetDataFrameView(JSONRequestHandler):
    def prepare(self):
        tmpl_file = os.path.join(self.get_template_path(),"jqgrid_view.html")
        if not(os.path.isdir(self.get_template_path())):
            self.set_status(500)
            self.finish("Template path does not exist")
            return
        with codecs.open(tmpl_file) as f:
            self.tmpl = Template(f.read())


    def get(self, objid):
        import pandas as pd
        # by default the object is placed in self.object
        if not isinstance(context.object, pd.DataFrame):
            self.set_status(500)
            self.finish("Object exists, but is not a dataframe")
            return

        base = "http://{host}/pandas".format(host=self.request.host)
        body = self.tmpl.generate(api_url=base,
                                  objid=objid,
                                  static_url=self.static_url)

        self.write(body)


@http_handler(r'/pandas/(?P<noun>columns|rows|edit)/{{objid}}$')
class jqGridPandasAjax(JSONRequestHandler):
    def get(self, objid, noun):
        import math
        import pandas as pd
        # logger.info(self.request.arguments)
        def listify(o):
            if not isinstance(o, (list, tuple)):
                o = [o, ]
            return list(o)

        df = context.object # we set @http_handler(obj_attr='the_object')

        if not isinstance(df, pd.DataFrame):
            raise (HTTPError(500, "Object exists, but is not a dataframe"))

        if len(df.columns) == 0:
            cidx_nlevels = 0
        else:
            cidx_nlevels = 1 if not hasattr(df.columns, "levels") else len(df.columns[0])

        if len(df.index) == 0:
            ridx_nlevels = 0
        else:
            ridx_nlevels = 1 if not hasattr(df.index, "levels") else len(df.index[0])

        if noun == "columns":
            def mk_col(index, headings, width=80, cssClass="", formatter=None, **kwds):
                d = dict(index=index, headings=headings,
                         width=width, cssClass=cssClass, formatter=formatter)
                d.update(kwds)
                return d

            if (cidx_nlevels == 0):
                raise (HTTPError(500, "no columns"))

            # fake multirow header for pandas Column MultiIndex as multiple lines of text

            # the name field contains a list of string (possibly singleton)
            # one per level of column index
            if cidx_nlevels == 1:
                cols = [[""] * cidx_nlevels] * ridx_nlevels + map(lambda x: [unicode(x)], list(df.columns))
            else:
                cols = [[""] * cidx_nlevels] * ridx_nlevels + map(lambda x: map(unicode, x), list(df.columns))

            columns = [mk_col(i, headings=headings, cssClass="", is_index=i < ridx_nlevels)
                       for i, headings in enumerate(cols)]
            payload = dict(columns=columns)
            self.write_json(payload)

        elif noun == "rows":
            # the returned json schema is forced by jqGrid
            rows = int(self.get_argument("rows")) # rows per page
            page = int(self.get_argument("page")) # #page requesed

            offset = ((page - 1) * rows)
            count = rows
            logger.info(offset)
            payload = dict(total=int(math.ceil(len(df) // rows)), # total number of pages
                           page=page, # current page number
                           records=len(df)) # total rows in dataframe

            if offset < 0 or count < 0 or offset >= len(df):
                # empty response, probably shouldn't happen, try to recover
                payload.update(dict(rows=[]))
                logger.warn("Bad request: offset:%s count:%s" % (offset, count))
            else:
                count = min(count, len(df) - offset) # num rows to return
                # all data gets converted to string, circumvent
                # the dtypes trap. json can't serialize int64, NaNs, etc
                rows = []
                payload['rows'] = rows
                for i in range(offset, offset + count):
                    vals = listify(df.index[i]) + list(df.irow(i).tolist())
                    # rows.append(dict(id=i,cell=map(unicode,vals)))
                    a = {j:unicode(val) for j,val in enumerate(vals)}
                    a.update(dict(id=i))
                    rows.append(a)

                # logger.info(payload)
            self.write_json(payload)

    def post(self, objid,noun):
        import pandas as pd

        if not noun == 'edit' and\
            isinstance(context.object, pd.DataFrame):
            self.set_status(500)
            self.finish("That's an error.")
            return

        # lost of cruddy error checking here

        # the POST bears these keys
        # {'oper': ['edit'], '2': ['R4C1'], 'id': ['5']}
        # id is 1-based row number,
        # int-string key is 1-based (que'lle horrible API!)
        # it's value (in list) is the new value

        args = self.request.arguments

        #validate
        if not all(k in args for k in ['id','oper']) and len(args) == 3:
            self.set_status(500)
            return self.finish("Couldn't parse request.")

        rid = args.pop('id')
        oper = args.pop('oper')
        col,val = None,None
        if args.items():
            col,val = args.items()[0]

        if not( len(args) == 1
                and isinstance(oper,list) and len(oper) ==1 and oper[0] == 'edit'
                and isinstance(rid,list) and len(rid) ==1
                and isinstance(val,list) and len(val) ==1
        ):
            logger.info((len(args) == 1 , oper == 'edit'
                        , isinstance(rid,list) , len(rid) ==1
                        , isinstance(val,list) , len(val) ==1))
            self.set_status(500)
            return self.finish("Couldn't parse request.")

        row = int(rid[0])

        try:
            col = int(col)-1
        except:
            self.set_status(500)
            return self.finish("Couldn't parse col.")

        val  = val[0]

        # primitive dtype coercion
        df= context.object
        old_val = df.irow(row)[col]
        try:
            val = type(old_val)(val)
        except:
            self.set_status(500)
            return self.finish("Couldn't coerce new value to proper type.")
        else:
            df.ix[row,col] = val
            logger.info("Replacing old value %s with %s at (%s, %s)" %
                        (old_val,val,row,col))



########NEW FILE########
__FILENAME__ = app
#!/usr/bin/python
# -*- coding: utf-8 -*-
from __future__ import print_function


"""
This exampls has nothing to with objects. It just demonstrates the use
of PubSub using websockets. Each side can subscribe to any channel, and publish
events to a channel. We demonstrate this by having both sides subscribe to a channel
using a callback, and then exchanging PING/PONG messages forever , alternating roles
on each iteration. YOu might want to open your browser's debug console, to see
what's going on.

"""
import codecs

import time
import os

from exhibitionist.isubscriber import ISubscriber
from exhibitionist.toolbox import *

from tornado.template import Template

context = None # eliminate tooling "symbol not found"

logger = getLogger(__name__)


class PingPonger(ISubscriber):
    """
    this class is a callback for incoming websocket messages
    messages going our are send through the notify_channel
    command which queues an event with tornado IOLoop in
    a thread-safe manner
    """
    def __init__(self, pubsub):
        self.pubsub = pubsub
        self.pubsub.subscribe(self, "THE_CHANNEL")

    def notify(self, channel, payload):
        # this gets called in the context of the Exhebition server thread
        logger.info(payload)
        if payload == "PING":
            logger.info("caught ping")
            self.pubsub.publish("THE_CHANNEL", dict(msg_type="PUB",payload="PONG",channel="THE_CHANNEL"),self)

            time.sleep(1.0)
            # if there was an Exhibition server going we could add a callback to
            # the Tornado event loop or run this in a thread. pubsub is thread-safe.
            self.pubsub.publish("THE_CHANNEL",dict(msg_type="PUB",payload="PING",channel="THE_CHANNEL"),self)


pjoin = os.path.join
dirname = lambda x: os.path.abspath(os.path.dirname(x))
STATIC_DIR = pjoin(dirname(__file__), "static")
TEMPLATE_DIR = pjoin(dirname(__file__), "templates")

import handlers
server = get_server(template_path=TEMPLATE_DIR,static_path=STATIC_DIR).\
        add_handler(handlers).start()

pp = PingPonger(server.pubsub) # meow

print("Please open the following url in your browser: " +
      server.get_view_url("PingPongView"))

print("""
Open up the javascript console (for *That* tab), and your log should show be
printing notices periodically, indicating messages being exchanged between
python and the client over websockets.
If You're using chrome, developer tools let's you see websockets frames
as they are passed on the wire, from the network tab.
""")


# when you're done, shutdown the server to release the socket
# server.stop()

########NEW FILE########
__FILENAME__ = handlers
# -*- coding: utf-8 -*-
from __future__ import print_function

import codecs
import os
import logging

from exhibitionist.toolbox import ( getLogger, http_handler,
                                    JSONRequestHandler, StaticFileHandler,
                                    HTTPError)
context = None # eliminate "symbol not found" warning
logger = getLogger(__name__, logging.INFO)

from tornado.template import Template

@http_handler("/game")
class PingPongView(JSONRequestHandler):
    """ This view provides the HTML to the client
    """
    def get(self):
        #note no leading slash, common cause of errors
        tmpl_file = os.path.join(self.get_template_path(),"index.html")
        if not(os.path.isdir(self.get_template_path())):
            self.set_status(500)
            return self.finish("Template path does not exist")

        with codecs.open(tmpl_file) as f:
            self.tmpl = Template(f.read())

        static_base=self.static_url("")[:-1] # strip trailing slash
        result= self.tmpl.generate(static_base=static_base,
                              ws_url=context.get_ws_url(),
                              static_url=self.static_url)
        self.write(result)

########NEW FILE########
__FILENAME__ = decorators
# -*- coding: utf-8 -*-
from __future__ import print_function

import logging
from functools import wraps
import threading

from exhibitionist.log import getLogger

logger = getLogger("decorator")

# These are the attribute name used to store
# the decorator supplied values on the class
VIEW_NAME_ATTR = "view_name" # key in dict under self.STORE_UNDER_ATTR
ROUTE_ATTR = "view_route" # key in dict under self.STORE_UNDER_ATTR
OBJECT_ATTR = 'object'
AUTO_OBJ_ATTR = 'auto_obj'
KWDS_ATTR = 'kwds'

# the name of the group/argument used to capture the objid
OBJID_REGEX_GROUP_NAME = 'objid'
# the pat placeholder to be replaced by objid regx
OBJID_PLACEHOLDER = '{{%s}}' % OBJID_REGEX_GROUP_NAME
MIN_OBJID_LEN = 8
OBJID_REGEX = '(?P<{obj_group_name}>[a-z\d]{{{min_len},40}})'.format(
    min_len=MIN_OBJID_LEN,
    obj_group_name=OBJID_REGEX_GROUP_NAME)

GET_REG_OBJ_ATTR = "get_obj_from_registry"
GET_VIEW_ATTR = "get_view_url"
PUBSUB_ATTR = "pubsub"

SUPER_CANARY="canary87969875987895"

class http_handler(object):
    """decorator gor http request handlers

    handlers decoarted with the decrorator can be passed
    into , or auto-discovered by, server.add_handler()
    """

    _handlers = dict()
    _context = threading.local()
    add_context = set(('on_message','prepare', 'get', 'post', 'put',
                       'delete', 'head', 'options'))

    add_prefetch = set(('get', 'post', 'put', 'delete', 'head', 'options'))

    @classmethod
    def get_context(cls):
        return cls._context

    @classmethod
    def get_specs(cls):
        return cls._handlers

    def __init__(self, route, view_name=None, **kwds):
        from exhibitionist.shared import registry

        self.registry = kwds.pop('__registry', registry) # for testing
        self.in_test = kwds.pop("__test",False)
        self.auto_obj = OBJID_PLACEHOLDER in route
        self.route = route.replace(OBJID_PLACEHOLDER, OBJID_REGEX)
        self.view_name = view_name
        self.kwds = kwds

    def prefetch_object(self, this, f, objid, *args, **kwds):
        import tornado.web

        # validate objid format
        # objid = kwds.get(OBJID_REGEX_GROUP_NAME)
        objid = str(objid)[:40]

        o = self.registry.get(objid)
        if o is None:
            raise tornado.web.HTTPError(404, 'No such Object')
        else:
            setattr(self.get_context(), OBJECT_ATTR, o)

        val = f(this, objid, *args, **kwds)

        # release ref to object, to allow weakrefs
        # to be reaped
        setattr(self.get_context(), OBJECT_ATTR, None)
        # should have been put there by ExhibitionitRequestHandler
        # if Init was called

        from exhibitionist.log import getLogger
        if not hasattr(this,SUPER_CANARY):
            if not self.in_test:

                getLogger(__name__).error("RequestHandler did not call super().__init__ ")
        else:
            delattr(this,SUPER_CANARY)

        return val

    def inject_context(self, this, f, *args, **kwargs):
        """inject context into method closure"""
        import six

        if six.PY3:
            f.__globals__['context'] = self.get_context()
        else:
            f.func_globals['context'] = self.get_context()

        return f(this, *args, **kwargs)

    def __call__(self, o):
        from exhibitionist.toolbox import ExhibitionistRequestHandler

        # insist, for future-proofing sake
        if not self.in_test:
            assert issubclass(o, ExhibitionistRequestHandler)

        d = {VIEW_NAME_ATTR: self.view_name or o.__name__,
             ROUTE_ATTR: self.route,
             KWDS_ATTR: self.kwds,
             AUTO_OBJ_ATTR: self.auto_obj}

        self._handlers[o] = d

        # inject context into method's globals()
        # http://www.tornadoweb.org/documentation/web.html


        for method_name in self.add_context:
            import types

            if hasattr(o, method_name) and \
                    isinstance(getattr(o, method_name),
                               (types.MethodType, types.FunctionType)):

                @wraps(getattr(o, method_name))
                def wrap_inject_context(f):
                    return lambda x, *args, **kwds: \
                        self.inject_context(x, f, *args, **kwds)

                setattr(o, method_name, wrap_inject_context(f=getattr(o,
                                                       method_name)))
                # if the {{objid}} marker was included
                #wrap the method in object fetching magical goodness
                if self.auto_obj and method_name in self.add_prefetch:
                    @wraps(getattr(o, method_name))
                    def wrap_prefetch_object(f):
                        return lambda x, *args, **kwds: \
                            self.prefetch_object(x, f, *args, **kwds)

                    setattr(o, method_name, wrap_prefetch_object(f=getattr(o,
                                                           method_name)))

        return o

    @classmethod
    def get_view_name(self, h):
        return self._handlers[h].get(VIEW_NAME_ATTR)

    @classmethod
    def get_auto_obj(self, h):
        return self._handlers[h].get(AUTO_OBJ_ATTR)

    @classmethod
    def get_route(self, h):
        return self._handlers[h].get(ROUTE_ATTR)

    @classmethod
    def get_kwds(self, h):
        return self._handlers[h].get(KWDS_ATTR)

    @classmethod
    def is_decorated_as_http(self, h):
        try:
            return h in self._handlers
        except:
            return False


def mlock(f):
    @wraps(f)
    def inner(self, *args, **kwargs):
        with self.lock:
            return f(self, *args, **kwargs)

    return inner

########NEW FILE########
__FILENAME__ = exceptions
# -*- coding: utf-8 -*-
from __future__ import print_function

class ExhibitionistError(Exception):
    def __init__(self, value,errno=None):
        self.value = value
        self.errno=errno

    def __str__(self):
        return repr(self.value)


########NEW FILE########
__FILENAME__ = isubscriber
# -*- coding: utf-8 -*-
from __future__ import print_function

class ISubscriber(object):
    def notify(self,channel, payload): # pragma: no cover
        raise NotImplemented

########NEW FILE########
__FILENAME__ = log
# -*- coding: utf-8 -*-
from __future__ import print_function

import logging
import exhibitionist.settings as settings

def getLogger(name, level=settings.DEFAULT_LOG_LEVEL):
    logger = logging.getLogger(name.replace("exhibitionist.", ""))

    sh = logging.FileHandler(settings.LOG_FILE)
    sh.setFormatter(settings.LOG_FORMAT)
    logger.setLevel(level)


    logger.addHandler(sh)

    return logger
########NEW FILE########
__FILENAME__ = cors
# -*- coding: utf-8 -*-
from __future__ import print_function

CORS_DOMAIN_ATTR = '_cors_domain'


class _CORSMixin(object):
    """
    Internal, don't use this directly.
    """

    def set_default_headers(self):
        self.set_header('Access-Control-Allow-Origin', getattr(self,
                                                               CORS_DOMAIN_ATTR))


def CORSMixin(allowed_domain='localhost'):
    """
    a function returning a class, to be used as a mixin for setting appropriate
    CORS (http://www.w3.org/TR/cors/) to enable cross-domain requests.
    the CORS header needs to present on your AJAX endpoints if they are
    on a different domain to that which served the page issuing the AJAX request.

    Usage (allowing access from any domain):

    class MyHandler(CORSMixin(domain="*"), tornado.web.RequestHandler):
        pass

    Note that CORSMixin must appear before tornado.web.RequestHandler
    in the superclass list.

    This is a slight abuse of nomenclature, since a mixin should be a class and
    not a function, but it's nicer then getCORSMixin().

    Provided for convenience , you can set the appropriate headers yourself
    in your handler, implementing some logic based on requests headers (for supporting
    multiple specific domains for example).
    """

    #  returns a class object parametrized by the specified domain
    return type('CORSMixin', (_CORSMixin, ),
                {CORS_DOMAIN_ATTR: allowed_domain})

########NEW FILE########
__FILENAME__ = json
# -*- coding: utf-8 -*-
from __future__ import print_function

from tornado.escape import json_encode

JSON_CB_ATTR = '_callback_name'


class _JSONMixin(object):
    """
    Internal. Don't use this directly
    """

    def write_json(self, d):
        self.set_header('Content-Type', 'application/json')

        body = json_encode(d)

        # supported, but the view should set the CORS header, so straight json works
        canary = object()
        callback = self.get_argument(getattr(self, JSON_CB_ATTR),
                                     default=canary, strip=True)

        if callback != canary:
            self.set_header('Content-Type', 'text/javascript')
            body = str(callback) + '(' + body + ')'

        self.write(body)


def JSONMixin(callback_arg='callback'):
    """
    a function returning a class, to be used as a mixin for supporting JSON responses.
    Defines a self.write_json(payload)  method, where payload is the object to be serialized
    as  json and returned to the client.

    If a callback query parameter is present in the request, write_json() will return a JSONP reply.
    The default name of the callback argument is "callback"  (used by jQuery),
    but you can define it's value yourself:

    class MyHandler(JSONMixin(callback_arg="cb"), tornado.web.RequestHandler):
       def get(self):
           ...
           self.write_json(payload)

    Note that JSONMixin must appear before tornado.web.RequestHandler
    in the superclass list.

    This is a slight abuse of nomenclature, since a mixin should be a class and
    not a function, but it's nicer then getJSONMixin().

    """

    return type('JSONMixin', (_JSONMixin, ), {JSON_CB_ATTR: callback_arg})

########NEW FILE########
__FILENAME__ = pubsub
# -*- coding: utf-8 -*-
from __future__ import print_function

import threading
from collections import namedtuple

from exhibitionist.decorators import mlock

import exhibitionist.log

logger = exhibitionist.log.getLogger(__name__)

Entry = namedtuple("Entry", "priority sub")

class PubSubMixin(object):
    def __init__(self):
        super(PubSubMixin, self).__init__()
        self.table = dict() # (channel,list((sub,priority))
        self.lock = threading.RLock()

    @mlock
    def subscribe(self, sub, channel, priority=0):
        """
        re-registering a sub with the same key will overwrite the priority value
        parameters:

          channel - must be hashable
          sub - the object associated with the channel
          priority - higher priority means higher priority
        """
        from exhibitionist.isubscriber import ISubscriber
        # There are more efficient ways to do all this
        logger.debug("PubSub Subscribing %s to %s" % (sub, channel))

        assert isinstance(sub, ISubscriber)

        subs = self.table.get(channel, [])
        # logger.debug("PubSub.subscribe: %s" % str(subs))

        for i, h in enumerate(subs):
            if id(h.sub) == id(sub):
                subs.remove(h) # will be reinserted with new priority

        self.table[channel] = self.table.get(channel, []) + [Entry(priority=priority, sub=sub)]

        # sort by descending priority
        self.table[channel].sort(key=lambda x: x.priority, reverse=True)
        # logger.debug("PubSub.subscribe: %s" % self.table.get(channel,[]))

        assert channel in self.table

    @mlock
    def unsubscribe(self, sub, channel=None):
        """
        Unregister a previously registered sub.

        params:
        channel - string or None. if None, sub will be unregistered for all channels
                         if channel is specified, the sub will be removed from the given
                         channel.
        sub - the callable previously registered.

        if the given channel/sub is not current registered, the function Ignores it.
        """
        from six import string_types

        assert isinstance(channel, string_types) or channel is None
        assert (not isinstance(sub, string_types)), "Sub can't be a string, did you get arg order wrong?"

        channels = []
        if channel is None:
            channels = self.table.keys()
        elif channel in self.table:
            channels = [channel]

        for k in list(channels): # loop mutates dict, can't be lazy on py3
            l = [x for x in self.table[k] if x.sub != sub]
            if l:
                self.table[k] = l
            else: # gc empty channels
                logger.debug("removing entry")
                del self.table[k]

    @mlock
    def list_subs(self, channel):
        """
        returns a lists of subs for the specified channel

        """
        # logger.fatal(">list_subs: " + str(self.table.get(channel,[])))
        # logger.fatal(">all: " + str(self.table))
        return [x.sub for x in self.table.get(channel, [])]

    @mlock
    def list_channels(self):
        return self.table.keys()

########NEW FILE########
__FILENAME__ = objectRegistry
# -*- coding: utf-8 -*-
from __future__ import print_function

from collections import namedtuple
import logging
import threading
from hashlib import sha1
import random
import weakref
import six

from exhibitionist.decorators import mlock, MIN_OBJID_LEN
import exhibitionist.log

logger = exhibitionist.log.getLogger(__name__)

RegObj = namedtuple("RegObj", "ref objid")


class ObjectRegistry(object):
    def __init__(self,min_objid_len=MIN_OBJID_LEN,use_short_keys=True):
        from exhibitionist.util.compat import OrderedDict

        self.min_objid_len = min_objid_len
        self.use_short_keys = use_short_keys

        self.lock = threading.RLock()
        # by using an Ordered dict, we can disambiguate
        # shortened oids.
        self._registry = OrderedDict()
        self.nonce = str(random.random()) # unique seed for each run
        self._canary = object() # used internally to signal missing object

        self.HASH_LEN = len(self.hash_obj(object()))

    def hash_obj(self, obj):
        """Taks a hashable object and returns a key as string"""
        s = (str(id(obj)) + self.nonce)

        if six.PY3:
            s = s.encode('utf-8')

        return sha1(s).hexdigest()

    @mlock
    def register(self, obj, weak=False):
        """
        Stores a weakref to an object, and returns a unique key for future retrieval

        weak - [bool:False] if true will use a weakref to the object
        """
        assert obj is not None

        class Ref(object):
            def __init__(self, obj):
                self.obj = obj

            def __call__(self):
                return self.obj

        objid = self.hash_obj(obj)

        # TODO: Better Data Structure
        # find the minimum length unique prefix of this objid

        collided=True
        for i in range(self.min_objid_len,len(objid)+1):
            dupes = [x for x in self._registry if x.startswith(objid[:i])]
            # if we found a unique prefix, or this object is already registered
            # and the only dupe with the prefix len is the same object
            # we're good.
            if not dupes or (len(dupes) == 1 and objid == dupes[0]):
                collided=False
                break

        if collided:
            msg = "Hash collision detected when trying to register object."
            logger.fatal(msg)
            raise ValueError(msg)


        # we're good
        if weak:
            logger.debug("Registering Object (weak) {0}".format(objid))
            ref = weakref.ref(obj)
        else:
            logger.debug("Registering Object {0}".format(objid))
            ref = Ref(obj)
        self._registry[objid] = RegObj(ref=ref, objid=objid)

        if not self.use_short_keys:
            i=len(objid)

        return objid[:i]


    @mlock
    def get(self, objid):
        """Takes a key and returns an object

        The key should be the retval of  a previous call to register(),
        or a prefix of one at least min_obj_id(=8) characters long.
        """

        # TODO: Future refactor
        # Do we need current fixed length objids?
        # we return the minimal-len unique prefix, that means,
        # if there was a collision (somewhat unlikely) we'd have
        # two objects whose extent (published) objid differs
        # by one suffix character (e.g ABC and ABCD).
        # good enough for now.

        # TODO: Better Data Structure
        # get via hash prefix is supported with linear scan, we can do better
        #
        # Room for improvement if performance ever becomes an
        # issue. tested very reasonably with up to 100000 objects
        # "64k should be enough for everybody"

        assert isinstance(objid, six.string_types)

        if (self.min_objid_len and len(objid) < self.min_objid_len) or\
                (not self.use_short_keys and len(objid) < self.HASH_LEN) :
            return None

        if objid not in self._registry:
            for k in self._registry:
                if k.startswith(objid):
                    objid = k
                    break

        objnd =  self._registry.get(objid, self._canary)

        if objnd != self._canary:
            obj = objnd.ref()
            if isinstance(objnd.ref, weakref.ref) and obj is None:
                logger.debug("Removing GC'd object from registry")

                del self._registry[objid]  # delete ref to garbage-collected object
            else: # weakref expired
                return obj

########NEW FILE########
__FILENAME__ = IProvider
# -*- coding: utf-8 -*-
from __future__ import print_function

class IProvider(object): # pragma: no cover

    name = None # a unique name for the provider

    def register_with_server(self,server):
        """
        will be called by server when the provider is registered
        enables the provider to get a reference to a the server instance
        and register http handlers with it.
        """
        self.server = server # save the server for later
        raise NotImplementedError

    def subscribe(self,h):
        """register handlers with the provider/server

        h is guaranteed to gave self.is_handler(h) True
        The provider can do some private initialization,
        or it can register the handlers with the server.

        This is suitable when the handlers are provided by the
        user rather then bundled with the provider, so
        the handlers are not known beforehand, but are
        provided via a call to add_handler.

        """
        raise NotImplementedError

    def is_handler(self,h):
        """predicate for handlers handled by this provider

        when server.add_handler is called with a namespace, all symbols
        are filteres through provider predicates to isolate the handlers.
        any handler for which the predicate returns True, will result in
        a call to subscribe, with the object as an argument
        """
        raise NotImplementedError

    def populate_context(self,context):
        """context is available to all request handlers in thread

        invoked when the server starts up, and attribute you put on context
        will be available to request handlers.
        """
        raise NotImplementedError

    def stop(self):
        """invoked right before the server thread stops"""
        raise NotImplementedError
########NEW FILE########
__FILENAME__ = handlers
# -*- coding: utf-8 -*-
from __future__ import print_function

import logging
import json
import six
from exhibitionist.isubscriber import ISubscriber

from tornado import websocket

from exhibitionist.decorators import http_handler,GET_REG_OBJ_ATTR

import exhibitionist.log
from exhibitionist.toolbox import WSMsg, ExhibitionistRequestHandler

logger = exhibitionist.log.getLogger(__name__)
context = None # dummy symbol

@http_handler(r'/ws$')
class WebSocketEvents(ISubscriber,ExhibitionistRequestHandler, websocket.WebSocketHandler,):
    """Websockets events handler

    Messages going over the websocket from/to the client must be a dict with mandatory
    fields "msg_type" and "payload" fields.

    Defines msg_type(s): "PUB","SUB","ACK","NAK"

    Examples Messages

    dict(msg_type="SUB",channel="ch") - client subscribe request for channel "ch"
    dict(msg_type="PUB",payload="p",channel="ch") -
           clients publish payload "p" to channel "ch"
    dict(msg_type="ACK",payload={message}) - reply from server indicating
        that previous request (PUB or SUB) was successful
    dict(msg_type="ACK",payload={message}) - reply from server indicating
        that previous request (PUB or SUB) failed

    """
    def __init__(self,*args,**kwds):
        super(WebSocketEvents, self).__init__(*args,**kwds)
        self.canary=object()

    # ISubscriber interface
    def notify(self,channel, payload):
        logger.debug('sending to websocket ' + str(payload))
        self.write_message(payload) # WebSocketHandler method

    def open(self, objid=None):
        logger.debug('WebSocket opened')

    def on_message(self, message):
        logger.debug('WSMsg Received: ' + str(message))

        try:
            message = json.loads(message)
        except Exception as  e: # pragma: no cover
            self.write_message(WSMsg(msg_type="NAK",payload="Malformed payload"))
            logger.error(str(e))
            return
        try:
            message['msg_type']
        except Exception as  e: # pragma: no cover
            self.write_message(WSMsg(msg_type="NAK",payload="Message must have 'msg_type' field"))
            # logger.error(str(e))
            return

        try:
            if message.get("msg_type") == "SUB":
                channel = message.get("channel")
                if not channel:
                    self.write_message(WSMsg(msg_type="NAK",payload="missing/invalid channel field"))
                else:
                    context.pubsub.subscribe(self,channel)
                    self.write_message(WSMsg(msg_type="ACK",payload=message))

            elif message.get("msg_type") == "PUB":
                channel = message.get("channel")
                payload = message.get("payload")
                if channel is None:
                    self.write_message(WSMsg(msg_type="NAK",payload="missing channel field"))
                if payload is None:
                    self.write_message(WSMsg(msg_type="NAK",payload="missing payload"))
                else:
                    self.write_message(WSMsg(msg_type="ACK",payload=message))
                    context.pubsub.publish(six.text_type(channel), payload,self)

        except Exception as  e: # pragma: no cover
            self.write_message(WSMsg(msg_type="NAK",payload="An error has occured"))
            logger.error(str(e))
            return

    def on_close(self):
        # unregister client from pubsub
        context.pubsub.unsubscribe(self)
        logger.debug('WebSocket closed')

########NEW FILE########
__FILENAME__ = test_pubsubdispatch
###########
# testing #
###########
from exhibitionist.isubscriber import ISubscriber

from exhibitionist.pubsubdispatch import PubSubDispatch
import unittest
import time
import threading


class IOLoopMock(object):
    def add_callback(self, callback):
        # import random
        # time.sleep(random.random()*0.05)
        callback()
        pass

    def running(self):
        return True

class Testpubsubdispatch(unittest.TestCase):
    def setUp(self):
        self.pubsubdispatch = PubSubDispatch(IOLoopMock())


    def tearDown(self):
        pass

    @staticmethod
    def wait_for_predicate(pred, timeout, interval=None):
        interval = interval or timeout
        waited = 0
        while waited <= timeout:
            if pred():
                return True
            time.sleep(interval)
            waited += interval
        return False

    def test_message_rx_tx(self):
        l = []

        class A(ISubscriber):
            def notify(self,channel, payload):
                l.append(payload)

        self.pubsubdispatch.subscribe(A(), "ch1")
        self.assertEqual(len(l), 0)
        self.pubsubdispatch.publish(channel="ch1", payload="the payload")

        self.wait_for_predicate(lambda: len(l), 1, 0.001)
        self.assertEqual(len(l), 1)
        self.assertEqual(l.pop(), "the payload")

        # and again
        self.pubsubdispatch.publish(channel="ch1", payload="the payload2")
        self.wait_for_predicate(lambda: len(l), 1, 0.001)
        self.assertEqual(len(l), 1)
        self.assertEqual(l.pop(), "the payload2")

        # two receivers
        self.assertEqual(len(l), 0)
        self.pubsubdispatch.subscribe(A(), "ch1")
        self.pubsubdispatch.publish(channel="ch1", payload="the payload3")
        self.wait_for_predicate(lambda: len(l) >= 2, 1, 0.001)
        self.assertEqual(len(l), 2)
        self.assertEqual(l.pop(), "the payload3")
        self.assertEqual(l.pop(), "the payload3")

        # just the registered channels get the messages for a channel
        self.assertEqual(len(l), 0)
        self.pubsubdispatch.subscribe(A(), "ch2")
        self.pubsubdispatch.publish(channel="ch1", payload="the payload4")
        self.wait_for_predicate(lambda: len(l) >= 2, 1, 0.001)
        self.assertEqual(len(l), 2)
        self.assertEqual(l.pop(), "the payload4")
        self.assertEqual(l.pop(), "the payload4")

        self.assertEqual(len(l), 0)
        self.pubsubdispatch.publish(channel="ch2", payload="the payload5")
        self.wait_for_predicate(lambda: len(l) >= 1, 1, 0.001)
        self.assertEqual(len(l), 1)
        self.assertEqual(l.pop(), "the payload5")

    def test_make_sure_we_dont_receive_our_own_message(self):

        l = []

        class A(ISubscriber):
            def notify(self,channel, payload):
                l.append(payload)

        a=A()
        #do
        self.pubsubdispatch.subscribe(a, "ch1")
        self.assertEqual(len(l), 0)
        self.pubsubdispatch.publish(channel="ch1", payload="the payload")

        self.wait_for_predicate(lambda: len(l), 0.2, 0.001)
        self.assertEqual(len(l), 1)
        self.assertEqual(l.pop(), "the payload")

        #don't
        self.pubsubdispatch.publish(channel="ch1", payload="the payload",exclude=a)
        self.wait_for_predicate(lambda: len(l), 0.2, 0.001)
        self.assertEqual(len(l), 0)


    def test_make_sure_we_dont_receive_our_own_message_multiple_subs(self):
        # make sure the other subscriber does get it, no matter the subscribe order

        l = []

        class A(ISubscriber):
            def notify(self,channel, payload):
                l.append(self)

        a=A()
        b=A()

        #do
        self.pubsubdispatch.subscribe(a, "ch1")
        self.pubsubdispatch.subscribe(b, "ch1")
        self.assertEqual(len(l), 0)

        self.pubsubdispatch.publish(channel="ch1", payload="the payload",exclude=a)
        self.wait_for_predicate(lambda: len(l), 0.2, 0.001)
        self.assertEqual(len(l), 1)
        self.assertEqual(l.pop(), b)

        self.pubsubdispatch.publish(channel="ch1", payload="the payload",exclude=b)
        self.wait_for_predicate(lambda: len(l), 0.2, 0.001)
        self.assertEqual(len(l), 1)
        self.assertEqual(l.pop(), a)
########NEW FILE########
__FILENAME__ = test_websocket
###########
# testing #
###########
# from websocket import create_connection
import nose
from exhibitionist.isubscriber import ISubscriber

from exhibitionist import get_server
from exhibitionist.providers.websocket import WebSocketProvider
from exhibitionist.toolbox import WSMsg


import unittest
import json

from ws4py.client.threadedclient import WebSocketClient


class WSClient(WebSocketClient):
    """utility for testing"""

    def __init__(self, objid, basket, *args, **kwds):
        super(WSClient, self).__init__(*args, **kwds)
        self.basket = basket
        self.objid = objid

    def send(self, payload, binary=False):
        """Transperant json stringify"""
        from six import string_types

        if not isinstance(payload, (string_types, bytearray)):
            payload = json.dumps(payload)
        super(WSClient, self).send(payload, binary)

    def opened(self):
        self.send(WSMsg("SUB", channel=self.objid))

    def closed(self, code, reason=""):
        pass

    def received_message(self, m):
        # print(m.data)
        data = json.loads(m.data.decode('utf-8'))
        self.basket.append(data)


class TestWebsocketBasic(unittest.TestCase):
    def test_creation_and_reg_with_server(self):
        from exhibitionist import get_server

        self.server = get_server(websockets_enabled=True).start()
        assert self.server._ensure_up() == 0
        self.ws_url = self.server.get_view_url('WebSocketEvents')


# noinspection PyUnusedLocal
class TestWebsocket(unittest.TestCase):
    def setUp(self):
        self.server = get_server().start()
        assert self.server._ensure_up() == 0
        self.ws_url = self.server.get_view_url('WebSocketEvents')
        self.o = object()
        self.objid = self.server.registry.register(self.o)

    def tearDown(self):
        self.server.stop()
        self.server.join(5)
        pass

    @staticmethod
    def wait_for_predicate(pred, timeout, interval=None):
        import time

        interval = interval or timeout
        waited = 0
        while waited <= timeout:
            if pred():
                return True
            time.sleep(interval)
            waited += interval
        return False


    def test_pubsub(self):
        raise nose.SkipTest()
        # import threading
        # print threading.enumerate()
        # 1/0
        basket = []
        for i in range(3):
            data = None

            self.o = object()
            objid = self.server.registry.register(self.o)
            ws = WSClient(objid, basket, self.ws_url, protocols=['http-only'])
            ws.connect()
            self.wait_for_predicate(lambda: basket, 1, 0.005)

            data = basket.pop()
            self.assertEqual(  data['msg_type'], 'ACK')
            self.assertEqual(basket, [])
            self.server.notify_object(self.o, WSMsg("foo", payload=i))

            self.wait_for_predicate(lambda: basket, 1, 0.005)
            data = basket.pop()
            self.assertEqual(data['msg_type'], 'foo')
            self.assertEqual(data['payload'], i)
            data = None

            self.o2 = object()
            objid2 = self.server.registry.register(self.o2)
            ws2 = WSClient(objid2, basket, self.ws_url, protocols=['http-only', 'chat'])
            ws2.connect()

            self.wait_for_predicate(lambda: basket, 1, 0.005)
            data = basket.pop()
            self.assertEqual(data['msg_type'], 'ACK', data['payload'])

            data = None
            self.server.notify_object(self.o2, WSMsg("o2", payload=0))
            self.wait_for_predicate(lambda: basket, 1, 0.005)
            data = basket.pop()
            self.assertEqual(data['msg_type'], 'o2')
            self.assertEqual(data['payload'], 0)

            data = None
            self.server.notify_object(self.o, WSMsg("foo", payload=i))
            self.wait_for_predicate(lambda: basket, 1, 0.005)
            data = basket.pop()

            self.assertEqual(data['msg_type'], 'foo')
            self.assertEqual(data['payload'], i)

            self.assertEqual(basket, [])
            ws2.close()
            ws.close()

    def test_2way_pubsub(self):
        raise nose.SkipTest()
        basket = []
        basket2 = []

        data = None

        # have a client connect, and subscribe to a channel
        self.o = object()
        objid = self.server.registry.register(self.o)
        ws = WSClient(objid, basket, self.ws_url, protocols=['http-only'])
        ws.connect()
        self.wait_for_predicate(lambda: basket, 1, 0.005)

        # make sure the client SUB request was ACKnowledged
        data = basket.pop()
        self.assertEqual(data['msg_type'], 'ACK', data['payload'])
        self.assertEqual(basket, [])

        # connected, notify object, and make sure tyhe client receives it
        self.server.notify_object(self.o, WSMsg('foo', payload=33))
        self.wait_for_predicate(lambda: basket, 1, 0.005)
        data = basket.pop()
        self.assertEqual(data['msg_type'], 'foo')
        self.assertEqual(data['payload'], 33)
        self.assertEqual(basket, [])

        data = None

        class A(ISubscriber):
            def notify(self, channel, payload):
                basket2.append( payload)

        # register another subscriber, this time a python, rather then
        # a websocket callback.
        # and publish a message to the channel from the web socket client
        a = A()

        self.server.pubsub.subscribe(a, 'chan')
        ws.send(WSMsg('PUB', payload='m_data', channel='chan'))

        self.wait_for_predicate(lambda: len(basket2)>=1, 1, 0.005)
        self.assertEqual(len(basket2),1)

        self.assertEqual(basket2.pop(), 'm_data')

        ws.close()


    def test_clear_sub_on_close(self):
        raise nose.SkipTest()
        import time

        basket = []

        self.o = object()
        objid = self.server.registry.register(self.o)
        ws = WSClient(objid, basket, self.ws_url, protocols=['http-only', 'chat'])
        ws.connect()

        ws2 = WSClient(objid, basket, self.ws_url, protocols=['http-only', 'chat'])
        ws2.connect()
        self.wait_for_predicate(lambda: len(basket) >= 2, 1, 0.01)

        self.assertTrue(len(basket) == 2)
        data = basket.pop()
        self.assertEqual(data['msg_type'], 'ACK', data['payload'])
        data = basket.pop()
        self.assertEqual(data['msg_type'], 'ACK', data['payload'])

        #
        self.assertTrue(len(basket) == 0)
        self.server.notify_object(self.o, WSMsg("foo", payload=0))
        self.wait_for_predicate(lambda: len(basket) >= 2, 1, 0.01)
        self.assertTrue(len(basket) == 2)

        data = basket.pop()
        self.assertEqual(data['msg_type'], 'foo', data)
        data = basket.pop()
        self.assertEqual(data['msg_type'], 'foo', data)

        lsub = self.server.pubsub.list_subs
        self.assertEqual(len(lsub(objid)), 2)

        ws.close()

        self.wait_for_predicate(lambda: len(lsub(objid)) == 1, 1, 0.01)
        self.assertEqual(len(lsub(objid)), 1)

        ws2.close()

        self.wait_for_predicate(lambda: len(lsub(objid)) == 0, 1, 0.01)
        self.assertEqual(len(lsub(objid)), 0)

        # reap empty channels
        self.assertEqual(len(self.server.pubsub.list_channels()), 0)


########NEW FILE########
__FILENAME__ = pubsubdispatch
# -*- coding: utf-8 -*-
from __future__ import print_function

from collections import namedtuple
import logging
from six import string_types

from exhibitionist.mixins.pubsub import PubSubMixin

import exhibitionist.log

logger = exhibitionist.log.getLogger(__name__, )

class PubSubDispatch(PubSubMixin):
    """Manages a list of subscriptions, and provides methods for publishing message to channels"""
    def __init__(self, ioloop):
        super(PubSubDispatch, self).__init__()
        self.ioloop = ioloop
        logger.debug("PubSubDispatch initialized")

    def publish(self,channel,payload,exclude=None):
        """publish a payload to a channel
        if `exclude` is provided, the subscriber(s) given won't be notified,
        Primarily used to prevent a publisher that is also a subscriber to receive messages.

        Websocket clients that publish messages are always excluded from recieving their own messages.

        :param channel:
        :rtype channel: string
        :param payload:
        :rtype payload: JSON-able object
        :param exclude: callback or sequence of calllbacks to be excluded from notification
        :rtype exclude: ISubscriber or sequence of ISubscribers

        :return: None
        """
        exclude = exclude or tuple()
        if not hasattr(exclude,'__iter__'):
            exclude = [exclude]

        logger.debug("Q-msg: [%s] %s" %(channel,payload))
        try:
            cs = self.list_subs(channel)
            # logger.debug("channels: %s" % cs)
            for c in cs:
                if c in exclude:
                    continue

                try:
                    def callback(c,payload):
                        def cb():
                            # c is ISubscriber
                            c.notify(channel, payload)
                        return cb
                    # logger.debug("Queueing ws send in ioloop")
                    self.ioloop.add_callback(callback(c,payload))
                except IOError as  e: # pragma: no cover
                    logger.debug("ioloop stopped: %s " + str(e)) # pragma: no cover
                    break #TODO, make sure client write can't throw IOError, possibly overloading it
                except Exception as  e: # pragma: no cover
                    logger.debug("Error writing to client: %s: " % str(e)) # pragma: no cover

        except Exception as e: # pragma: no cover
            logger.fatal(str(e)) # pragma: no cover

########NEW FILE########
__FILENAME__ = server
# -*- coding: utf-8 -*-
from __future__ import print_function
import os

import threading
import logging
from six.moves import queue
import errno
from tornado.httpserver import HTTPServer
from exhibitionist.pubsubdispatch import PubSubDispatch

import exhibitionist.settings as settings
from exhibitionist.decorators import (http_handler, GET_REG_OBJ_ATTR,
                                      GET_VIEW_ATTR, PUBSUB_ATTR)
from exhibitionist.providers.IProvider import IProvider
from exhibitionist.exceptions import ExhibitionistError
import exhibitionist.log

logger = exhibitionist.log.getLogger(__name__)


class ExhibitionistServer(IProvider, threading.Thread):
    """
    The tornado server thread, and also provides handler
    registration , both HTTP RequestHandlers with tornado
    and other types provided by providers

    all **kwds not consumed by the Server contructor,
    will be passed on as keyword arguments to tornado's
    application constructor. Particular examples are
    "static_path" and "template_path"
    """

    def __init__(self, port=None, address='127.0.0.1',
                 **kwds):
        """
        If port== None, will pick one automatically
        """
        import tornado.web
        import tornado.ioloop

        super(ExhibitionistServer, self).__init__()

        self.name = "ExhibitionistServer Thread"
        self.daemon = True
        self.synq = queue.Queue()
        self.started_ok = False

        # One IOLoop per thread
        # this was a nightmare to debug.
        self.ioloop = tornado.ioloop.IOLoop()

        if kwds.get('static_path') :
            assert os.path.isdir(kwds.get('static_path'))

        if kwds.get('template_path') :
            assert os.path.isdir(kwds.get('template_path'))

        kwds['template_path'] = kwds.get('template_path',
                                         "You_did_not_set_the_template_path")

        # logger.info(kwds)
        self.application = None

        # extra kwds are passed to application as settings
        # self.application.settings.update(kwds)

        self._server = None

        self.tornado_app_settings=kwds

        self.pubsub = PubSubDispatch(self.ioloop)

        self.http_handlers = set()

        self._port_requested = port
        self._address_requested = address
        self._port_used = None
        self._address_used = None

        self.providers = set()

        if kwds.get("__registry"): # for testing
            self.registry = kwds.get("__registry")
        else:
            import exhibitionist.shared

            self.registry = exhibitionist.shared.registry

        # register the provider part of self,
        # with the server part of self.
        self.register_provider(self)


    @staticmethod
    def _discover(pred, or_or_ns):
        """Internal: Takes a predicate + object/namespace, and finds xs for which pred(x)

        :param pred: lambda x: bool
        :param or_or_ns: a python object, including packages/modules
        :rtype : list
        """
        import inspect

        candidates = []

        if inspect.ismodule(or_or_ns):
            # modules and submodules of package
            modules = [or_or_ns]
            modules += [getattr(or_or_ns, x) for x in dir(or_or_ns)
                        if inspect.ismodule(getattr(or_or_ns, x))]
            for m in modules:
                candidates.extend([getattr(m, x) for x in dir(m)])

        candidates.append(or_or_ns)

        return [x for x in candidates if pred(x)]

    #######################
    # The IProvider  interface
    def register_with_server(self, server):
        pass

    def populate_context(self, context):
        setattr(context, GET_VIEW_ATTR, self.get_view_url)
        setattr(context, GET_REG_OBJ_ATTR, self.registry.get)
        setattr(context, PUBSUB_ATTR, self.pubsub)

        pass

    def subscribe(self, h):
        if self.isAlive():
            raise RuntimeError(
                "Registering http handlers after server start is not allowed")

        # exst_names=[x for x in self.http_handlers
        #             if  get_view_name(x) == get_view_name(h)]
        # if exst_names and exst_names[0] != h:
        if h in self.http_handlers:
            raise RuntimeError("view_name collision, "
                               "there's already a handler called %s" %
                               http_handler.get_view_name(h))

        if h not in self.http_handlers:
            tmpl = "Discovered {type} handler '{name}'  tagged with {route}"
            logger.debug(tmpl.format(type='http',
                                     name=http_handler.get_view_name(h),
                                     route=http_handler.get_route(h)))
            self.http_handlers.add(h)

            # update the application http_handlers
            # this allows dynamic addition of http_handlers


    def is_http_handler(self, o):
        from exhibitionist.decorators import http_handler
        import inspect
        import tornado.web

        return (http_handler.is_decorated_as_http(o) and
                (inspect.isclass(o) and issubclass(o,
                                                   tornado.web.RequestHandler)))

    is_handler = is_http_handler

    #######################
    # The server interface
    def register_provider(self, provider):
        import inspect

        if self.started_ok:
            raise ExhibitionistError(
                "can only add providers before server start")

        # todo, refactor in to verify_provider()
        if inspect.isclass(provider):
            raise AssertionError(
                "Provider must be instance, not class. did you forget to add ()?")
        assert isinstance(provider,
                          IProvider), "Provider must be inherit from IProvider"
        assert hasattr(provider, "is_handler")
        assert hasattr(provider, "subscribe")
        self.providers.add(provider)

        provider.register_with_server(self)
        if provider != self: # attach the provider instance as an attribute
            setattr(self, provider.name, provider)

        return self  # fluent

    def add_handler(self, ns_or_h):
        """
        called by user with http_handlers,or modules containing them,
        of whatever type (http, ws). They will be auto-detected
        and registered with the appropriate backend machinery

        may throw RuntimeError if provider refuses to accept new handlers
        (for example, new HTTP handlers after server start)
        """
        if self.started_ok:
            raise ExhibitionistError(
                "can only add handlers before server start")

        for prvdr in self.providers:
            handlers = self._discover(prvdr.is_handler, ns_or_h)
            [prvdr.subscribe(x) for x in
             handlers] # py3 has lazy map, side-effects.

        return self # fluent

    def _register_handlers(self):
        """ register http_handlers with tornado application"""
        from tornado.web import URLSpec,Application

        urlconf = [URLSpec(http_handler.get_route(h), h,
                           name=http_handler.get_view_name(h),
                           kwargs=http_handler.get_kwds(h))
                   for h in self.http_handlers]

        self.application = Application(urlconf,
                                       **self.tornado_app_settings)
        #
        # self.application.add_handlers("", urlconf) # re-register everything


    def get_view_url(self, handler_name, *args, **kwds):
        """Returns a full url for the given view, with given argument

        a wrapper around tornado's reverse_url with some bells and whistles.

        if the handler included the {{objid}} special marker, 'objid'
        must be provide to reverse_url to be inserted into the returned
        url, and args[0] will be interpreted as the object to be viewed.
        If you pass in an object it will automatically be registered
        and the objid substituted into the url, but you can also
        provide an objid for an object previously registered.

        if you want a weakref to be used (to prevent memory leaks) to store
        the object in the object registry ,pass in a kwd argument
        `_weakref=True` when first viewing the argument.
        Note that not all types are supported by weakref.

        :param handler_name: Handler class name, or value of view_name used
            in @http_handler.
        :param obj_or_objid: objid is the return value of a previous call to
            registry.register
        :param args: values to use in unnamed capture groups in route regexp,
            if any.  must match the number and order of groups.
        :param kwds: values to use in named capture groups in route regexp,
            if any   must match the number and and names of groups.

        Throws: IOError if the server thread failed to initialize

        Examples:

        @http_handler("/blah/{{objid}}")
        class A():
           ...

        get_view_url('A',my_object)

        -----------

        @http_handler("/blah/{{objid}}/(\d+)/(?P<an_arg>\w+)")
        class A():
           ...

        get_view_url('A',my_object,12,an_arg="baz")

        -----------

        @http_handler("/blah/(\d+)/(?P<an_arg>\w+)")
        class A():
           ...

        get_view_url('A',12,an_arg="baz")

        -----------
        """
        import exhibitionist.shared as shared
        from tornado import websocket
        from six import string_types

        weak = kwds.pop("_weakref",False)

        if self._ensure_up() != 0:  # make sure the server thread has finished starting up
            raise ExhibitionistError("The server thread failed to start.")

        registry = kwds.pop('__registry', shared.registry)  # for testing
        handler = self.application.named_handlers[handler_name].handler_class

        if args and  http_handler.get_auto_obj(handler):
            obj_or_objid=args[0]
            objid=None

            # let the user provide an objid of registered object
            if  isinstance(obj_or_objid, string_types) and registry.get(obj_or_objid):
                objid = obj_or_objid

            if objid is None:
                objid = registry.register(obj_or_objid,weak=weak)

            if objid is not None:
                args = (objid,) + args[1:]

        path = self.application.reverse_url(handler_name, *args, **kwds)


        # TODO: we special-case WSH here, need to be more general?
        if issubclass(handler, websocket.WebSocketHandler):
            prot = "ws"
        else:
            prot = "http"

        return "{prot}://{addr}:{port}{path}".format(prot=prot,
                                                     addr=self.address,
                                                     port=self.port, path=path)

    def stop(self, block=True, waitfor=0):
        """Initiates a full shutdown of event loop and server.
        if successful, will release the server'socket an the thread will stop,
        Note, that unless stop() is called, the socket used will not be released
        until shutdown, this can act as a leak for sockets.

        :param waitfor: in seconds, time between stopping the server (and providers)
         and calling stop on the event loop.
        """
        import datetime

        def stopCallback2():
            self.ioloop.stop()

        def stopCallback1():
            self.ioloop.add_timeout(datetime.timedelta(seconds=waitfor),
                                    stopCallback2)
        def close_cb(s):
            return lambda : s.stop()

        for p in self.providers:
            if p != self:
                self.ioloop.add_callback(close_cb(p))

        self.ioloop.add_callback(close_cb(self._server))
        self.ioloop.add_callback(stopCallback1)
        if block:
            self.join()
        return self

    def _create_http_server(self,port_start,port_end,ioloop):
        import socket

        server = HTTPServer(self.application, io_loop=ioloop)

        for portnum in range(port_start, port_end):
            try:

                server.listen(portnum,
                                    address=self._address_requested)
                logger.info('Server listening on port {0}'.format(portnum))
                self._port_used = portnum
                self._address_used = self._address_requested

                return server, portnum

            except socket.error as  e:
                # try remaining ports if port used, raise otherwise
                if e.errno != errno.EADDRINUSE or portnum == port_end-1:
                    logger.error(str(e)) # pragma: no cover
                    try:
                        server.stop()
                    except:
                        pass
                    raise


    def run(self):
        import socket

        try:
            logger.info('Starting Up')

            for p in self.providers:
                p.populate_context(http_handler.get_context())

            # register all discovered http_handler with Tornado application
            self._register_handlers()

            # extra kwds are passed to application as settings
            # self.application.settings.update(kwds)

            port_start = self._port_requested or settings.SERVER_PORT_BASE
            if self._port_requested:
                port_end = self._port_requested + 1
            else:
                port_end = min(65535, port_start + settings.MAX_N_SOCKETS)

            try:
                (self._server,portnum) = self._create_http_server(port_start,
                                                                  port_end,
                                                                  self.ioloop)

            except (OSError,socket.error) as  e:
                self.synq.put(e.errno)# pragma: no cover
                errmsg="Couldn't listen on ports: [{0},{1})"
                logger.error(errmsg.format(port_start, port_end))
                raise
            except Exception as e:
                logger.error(str(e))
                raise

            # we're fine, start the loop
            self.synq.put(0) # signal successful startup
            self.ioloop.start()

            # blocked here, until someone stops the loop, safely.

            # self.ioloop.close() # despite everything, still throwing fd errors
            logger.info('Stopped server at {0}:{1}'.format(self.address,
                                                           self.port))
            logger.info('Stopped IOLoop')

            # not Thread Safe
            self._port_used = None
            self._server = None
            self.application = None


        except Exception as e: # capture exceptions from daemonic thread to log file
            import traceback as tb

            logger.error(
                "Exception in server thread:\n" + str(e) + str(tb.format_exc()))


    def start(self, block=True, timeout=5):
        """ Start the server socket, bind to a socket and start listening

        Note, that the socket is held until stop() is called, or the main thread exists.
        This can act as a leak, unless stop() is called when the server is no longer needed.

        returns self

        :param timeout: in seconds
        :rtype : ExhibitionistServer
        """
        super(ExhibitionistServer, self).start()
        if block:
            err = self._ensure_up(timeout)
            if err != 0:
                msg = "Server failed to start: %s" % errno.errorcode[err]
                raise ExhibitionistError(msg,errno=err)

        return self # fluent

    def _ensure_up(self, timeout=1):
        """
        we must be sure that the server successfully bound

        :returns : 0 if success, errno <0 if an error occurred
        :rtype : int
        :param timeout: in seconds
        on a addr:port, before returning a url.
        Waits on a signal from the server thread that it is
        ready.

        :rtype : bool
        """

        if self.started_ok:
            return 0
        else:
            try:
                result = errno.EIO # will be returned if error in Queue get
                result = self.synq.get(timeout=timeout)
            except queue.Empty:
                return errno.ETIMEDOUT
            else:
                if result == 0:
                    self.started_ok = True
                    return 0
                else:
                    return result

    def notify_object(self, obj, payload, exclude=None):
        """
        :param obj: any python object
        :param payload: a JSON encodable object to be send to the client
        :param exclude: callback or sequence of calllbacks to be ecluded from notification
        :rtype exclude: ISubscriber or sequence of ISubscribers
        :return:
        """
        objid = self.registry.register(obj)
        return self.notify_channel(channel=objid, payload=payload,
                                   exclude=exclude)

    def notify_channel(self, channel, payload, exclude=None):
        """

        :param channel: the name of a channel to publish a message on, usually an objid
        :param payload:
        :param exclude: callback or sequence of calllbacks to be ecluded from notification
        :rtype exclude: ISubscriber or sequence of ISubscribers
        :return:
        """
        from six import string_types

        if not isinstance(channel, string_types):
            raise ValueError("Channel must be a string")

        # put message in q to notify the pubsubdispatch Thread of message
        # it will then queue on a send on the ioloop
        self.pubsub.publish(channel=channel, payload=payload,
                            exclude=exclude)

    @property
    def port(self):
        """ None if server not active, listening port otherwise"""
        return self._port_used


    @property
    def address(self):
        """ None if server not active, bound address otherwise"""
        return self._address_used

########NEW FILE########
__FILENAME__ = settings
# -*- coding: utf-8 -*-
from __future__ import print_function

import os
import logging

LOG_FORMAT = logging.Formatter(fmt='%(asctime)s {%(name)-4s: %(lineno)d} %(levelname)-8s  %(message)s', datefmt='%m-%d %H:%M:%S')

make_path = lambda base, suffix: os.path.abspath(os.path.join(base, suffix))

# detect null device on this box
try:
    # *nix
    NULLDEV = "/dev/null"
    with open(NULLDEV, "wb"):
        pass
except:
    # windows: http://stackoverflow.com/questions/313111
    NULLDEV = "NUL"

BASE_DIR = make_path(os.path.dirname(__file__), "..")
# unless a port is specified, the server loops through
# [SERVER_PORT_BASE,SERVER_PORT_BASE+MAX_N_SOCKETS)
# and binds to the first available socket.
SERVER_PORT_BASE = 9080
MAX_N_SOCKETS = 100

# For Exhibitionist only.If None, the package loggers will be NullLogger
DEFAULT_LOG_LEVEL = logging.CRITICAL+1
LOG_FILE = NULLDEV # by default, log to /dev/null

# tornado <=2.4.1 uses the root logger so we can't silence it
# without potentially affecting user code. It's also chatty by default
# which can flood the console with crappy favicon 404 reports.
# So, pipe everything to the platform /dev/null.
# hope this works off-linux.
TORNADO_LOG_FILE = NULLDEV # send the tornado logging to /dev/null

# put these in your local_settings.py to enable
# logging for development
# LOG_FILE=make_path(BASE_DIR,"xb.log")
# TORNADO_LOG_FILE=make_path(BASE_DIR,"tornado.log")
# DEFAULT_LOG_LEVEL=logging.DEBUG


try:
    from local_settings import *
except:# pragma: no cover
    pass

########NEW FILE########
__FILENAME__ = shared
# -*- coding: utf-8 -*-
from __future__ import print_function

# Package-wide data structure instances live here.

# The objid: object  registry
# this is used by the @route decorator
from exhibitionist.objectRegistry import ObjectRegistry
from exhibitionist.decorators import MIN_OBJID_LEN

__all__=['registry']

# Single Thread-Safe registry, used by all servers.
registry = ObjectRegistry(min_objid_len=MIN_OBJID_LEN,
                          use_short_keys=True)


########NEW FILE########
__FILENAME__ = bogus_handlers
# -*- coding: utf-8 -*-
from __future__ import print_function
from exhibitionist.toolbox import ExhibitionistRequestHandler

import tornado.web
from exhibitionist.decorators import http_handler
from exhibitionist.mixins.json import JSONMixin
from exhibitionist.mixins.cors import CORSMixin

# this is used to test auto-discovery of http_handlers
# via modules, as well as the JSON and CORS mixins

# expose static files to client
@http_handler(r'/blahldkfj')
class MyJSONView(CORSMixin("CORS"), JSONMixin(callback_arg="cb"),ExhibitionistRequestHandler):
    def get(self, *args, **kwds):
        print(self.request.uri)
        self.write_json(dict(foo="bar"))

########NEW FILE########
__FILENAME__ = test_decorators
# -*- coding: utf-8 -*-
from __future__ import print_function

###########
# testing #
###########

from exhibitionist.decorators import (http_handler,OBJID_PLACEHOLDER, OBJID_REGEX_GROUP_NAME)

import unittest
from exhibitionist.objectRegistry import ObjectRegistry
from exhibitionist.toolbox import ExhibitionistRequestHandler

context = None # elimiate missing symbol warnings

class TestDecorators(unittest.TestCase):
    def setUp(self):
        pass

    def tearDown(self):
        pass

    def test_marker_substitution(self):
        import re

        @http_handler("#{0}#".format(OBJID_PLACEHOLDER))
        class A(ExhibitionistRequestHandler):
            pass

        self.assertTrue(OBJID_REGEX_GROUP_NAME in re.compile(http_handler.get_route(A)).groupindex)
        self.assertTrue(http_handler.is_decorated_as_http(A))


    def test_view_name(self):
        @http_handler(r"", view_name="blah")
        class A(ExhibitionistRequestHandler):
            pass

        self.assertEqual(http_handler.get_view_name(A), "blah")
        pass

    def test_all_verbs_auto_obj_and_context_injection(self):
        import tornado.web

        registry = ObjectRegistry()

        @http_handler(OBJID_PLACEHOLDER, __registry=registry,__test=True)
        class A(object):
            def get(self, objid, *args, **kwds):
                assert context.object == o
                pass

            def post(self, objid, *args, **kwds):
                assert context.object == o
                pass

            def put(self, objid, *args, **kwds):
                assert context.object == o
                pass

            def delete(self, objid, *args, **kwds):
                assert context.object == o
                pass

            def head(self, objid, *args, **kwds):
                assert context.object == o
                pass

            def options(self, objid, *args, **kwds):
                assert context.object == o
                pass

        for method_name in ['get', 'post', 'put', 'delete', 'head', 'options']:
            o = object()
            objid = registry.register(o)
            handler = A()
            getattr(handler, method_name)(objid=objid)

            try:
                getattr(handler, method_name)(objid="NoSuchObject")
            except tornado.web.HTTPError:
                pass
            else:
                self.fail(method_name)


########NEW FILE########
__FILENAME__ = test_multiple_servers
# -*- coding: utf-8 -*-
from __future__ import print_function

###########
# testing #
###########
import errno
from exhibitionist.toolbox import ExhibitionistRequestHandler
import nose

from exhibitionist import get_server
import unittest

context = None # eliminate missing symbol warnings

class TestMultiServers(unittest.TestCase):
    def setUp(self):
        pass

    def tearDown(self):
        pass

    def test_stop_server(self):
        import time
        from random import random

        for i in range(10):
            server = get_server().start()
            self.assertTrue(server.isAlive())
            server.stop()
            server.join(1)
            self.assertFalse(server.isAlive())

    def test_stop_server_releases_port(self):
        import time
        from random import random
        import socket


        for i in range(100):
            server = get_server(port=4000).start()
            self.assertTrue(server.isAlive())

            # make sure port is taken
            s = socket.socket()
            addr, port = server.address, server.port
            # print(addr,port)
            try:
                s.bind((addr, port))
            except socket.error as e:
                if e.errno != errno.EADDRINUSE:
                    self.fail("excpected EADDRINUSE, got some other error")
            else:
                s.close()
                self.fail("socket was supposed to be taken")

            # stop server and wait
            server.stop()
            server.join(1)
            self.assertFalse(server.isAlive())

            error=False
            # make sure port is available
            try:
                s.bind((addr, port))
            except (OSError, socket.error) as e:
                error = True
                if e.errno == errno.EADDRINUSE:
                    msg = "socket not released after server stop()"
                else:
                    msg = "couldn't bind to available socket, unknown error"
            else:
                s.close()

            if error:
                self.fail(msg)


    def test_multiple(self):
        """
        Torture test of mutliple server,
        mutliple object, multile client hitting
        servers concurrently,

        """
        try:
            import grequests
        except ImportError:
            raise nose.SkipTest("grequests not available")

        import grequests
        from exhibitionist.objectRegistry import ObjectRegistry
        from exhibitionist.decorators import http_handler
        import random

        registry = ObjectRegistry()
        @http_handler(r'/{{objid}}', __registry=registry)
        class Handler(ExhibitionistRequestHandler):
            def get(self, *args, **kwds):
                self.write(str(id(context.object)))

        N_SERVERS = 3
        N_CONC_CONNS = 20

        for i in range(10):

            try:
                servers = []
                for i in range(N_SERVERS):
                    servers.append(get_server().add_handler(Handler).start())
                assert len(servers) == N_SERVERS

                urls=[]
                objs=[object() for i in range(N_CONC_CONNS)] # use integers
                for i in range(N_CONC_CONNS): # 50 connections at once
                    o = objs[i]
                    r = random.randint(0, N_SERVERS-1)
                    assert r < N_SERVERS
                    s = servers[r]
                    urls.append(s.get_view_url("Handler", o, __registry=registry))
                assert len(urls) == len(objs)

                jobs = [grequests.get(url) for url in urls]
                results = grequests.map(jobs)

                for i,r in enumerate(results):
                    self.assertTrue(str(id(objs[i])) == r.content)

            finally:
                for s in servers:
                    try:
                        s.stop()
                    except:
                        pass




########NEW FILE########
__FILENAME__ = test_pubsub
# -*- coding: utf-8 -*-
from __future__ import print_function

from exhibitionist.isubscriber import ISubscriber

from exhibitionist.mixins.pubsub import PubSubMixin
import unittest


class TestPubSub(unittest.TestCase):
    def setUp(self):
        self.pubsub = PubSubMixin()

    def tearDown(self):
        pass

    @staticmethod
    def pick_attr(l, attr):
        return [getattr(x, attr) for x in l]

    def test_sub(self):
        # basic sub
        h = ISubscriber()

        self.pubsub.subscribe(h, "ch1")
        self.assertTrue(h in self.pubsub.list_subs("ch1"))

    def test_resub_no_dupe(self):
        # basic sub
        h = ISubscriber()

        self.pubsub.subscribe(h, "ch1")
        self.pubsub.subscribe(h, "ch1")
        self.assertTrue(h in self.pubsub.list_subs("ch1"))
        self.assertTrue(len(self.pubsub.list_subs("ch1")) == 1)

    def test_sub_multi_channels(self):
        # basic sub
        h = ISubscriber()
        h2 = ISubscriber()
        self.pubsub.subscribe(h, "ch1")
        self.pubsub.subscribe(h, "ch2")
        self.assertTrue(h in self.pubsub.list_subs("ch1"))
        self.assertTrue(h in self.pubsub.list_subs("ch2"))

        self.pubsub.subscribe(h2, "ch1")
        self.pubsub.subscribe(h2, "ch2")
        self.assertTrue(h in self.pubsub.list_subs("ch1"))
        self.assertTrue(h2 in self.pubsub.list_subs("ch1"))
        self.assertTrue(h2 in self.pubsub.list_subs("ch2"))


    def test_unsub(self):
        h = ISubscriber()
        h2 = ISubscriber()

        self.pubsub.subscribe(h, "ch1")
        self.pubsub.subscribe(h2, "ch1")
        self.pubsub.subscribe(h, "ch2")
        self.pubsub.subscribe(h, "ch3")
        self.assertTrue(h in self.pubsub.list_subs("ch1"))
        self.assertTrue(h in self.pubsub.list_subs("ch2"))
        self.assertTrue(h in self.pubsub.list_subs("ch3"))

        # specific ch
        self.pubsub.unsubscribe(h, "ch1")
        self.assertFalse(h in self.pubsub.list_subs("ch1"))
        self.assertTrue(h in self.pubsub.list_subs("ch2"))
        self.assertTrue(h2 in self.pubsub.list_subs("ch1"))


        # specific ch
        self.pubsub.unsubscribe(h)
        self.assertFalse(h in self.pubsub.list_subs("ch1"))
        self.assertFalse(h in self.pubsub.list_subs("ch2"))
        self.assertFalse(h in self.pubsub.list_subs("ch3"))
        self.assertTrue(h2 in self.pubsub.list_subs("ch1"))


    def test_list_channels(self):
        h = ISubscriber()
        h2 = ISubscriber()

        self.pubsub.subscribe(h, "ch1")
        self.assertTrue("ch1" in self.pubsub.list_channels())
        self.assertFalse("ch2" in self.pubsub.list_channels())

        self.pubsub.subscribe(h, "ch2")
        self.assertTrue("ch1" in self.pubsub.list_channels())
        self.assertTrue("ch2" in self.pubsub.list_channels())




########NEW FILE########
__FILENAME__ = test_registry
# -*- coding: utf-8 -*-
from __future__ import print_function

import unittest
from exhibitionist.decorators import MIN_OBJID_LEN
from exhibitionist.objectRegistry import ObjectRegistry


class TestRegistry(unittest.TestCase):
    def setUp(self):
        self.registry = ObjectRegistry()

    def tearDown(self):
        pass

    def test_repeated_register_same_key(self):
        r = self.registry
        a = (0, 0)
        key = r.register(a)
        self.assertEqual(r.register(a),
                         key) # repeated registration returns same key

    def test_can_register_non_hashable(self):
        r = self.registry
        a = dict()
        key = r.register(a)
        self.assertTrue(key is not None)

    def test_repeated_register_modified_same_key(self):
        r = self.registry
        a = [0, 0]
        key = r.register(a)
        a[1] = 2
        self.assertEqual(r.register(a),
                         key) # repeated registration returns same key

    def test_repeated_register_modified_same_object(self):
        r = self.registry
        a = [0, 0]
        key1 = r.register(a)
        a[1] = 2
        key2 = r.register(a)
        self.assertEqual(id(r.get(key1)), id(r.get(key2))) #

    def test_diff_objects_diff_keys(self):
        r = self.registry
        a = dict()
        b = dict()
        self.assertNotEqual(r.register(a),
                            r.register(b)) # different object get diff hashes

    def test_can_use_weakref(self):
        class A(object):
            pass

        r = self.registry
        a = A()
        key = r.register(a, weak=True)
        self.assertEqual(id(r.get(key)),
                         id(a)) # mutating an object does not alter it's key
        del a
        # import gc
        #
        # gc.collect()
        self.assertEqual(r.get(key), None) # weakrefs are weak

    def test_can_use_hash_prefix(self):
        from exhibitionist.decorators import MIN_OBJID_LEN
        class A(object):
            pass

        # keys shorter then MIN_OBJID_LEN are ignored
        r = ObjectRegistry(MIN_OBJID_LEN)
        a = A()
        key = r.register(a)
        for i in range(1, MIN_OBJID_LEN):
            self.assertEqual(r.get(key[:i]), None)

        for i in range(MIN_OBJID_LEN, len(key)):
            self.assertEqual(id(r.get(key[:i])), id(a))


    def test_return_min_len_key(self):
        def full_id(partial):
            return [x for x in d if x.startswith(partial)][0]
        # start returning keys with len >=1
        # force collisions by registering lots of objects
        r=ObjectRegistry(min_objid_len=1)
        d=r._registry

        objs = [object()]
        oids = [r.register(objs[-1])]



        for i in range(512): # 16**3
            objs.append(object())
            oids.append(r.register(objs[-1]))
            self.assertEqual(r.get(full_id(oids[-1])),objs[-1])

            # make sure we get back the same key, if we reregister
            l = len(d)
            self.assertEqual(oids[-1],r.register(objs[-1]))
            # no change in number of keys
            self.assertEqual(len(d), l)

    def test_return_min_len_key_more(self):
        def full_id(partial):
            return [x for x in d if x.startswith(partial)][0]
        # start returning keys with len >=8 (MIN_OBJID_LEN)
        # force collisions by building keys and shoving them
        # into the registry
        # then reregister same object and make sure
        # we get back an objid which is longer then
        # previous iteration, and that we can get back the object
        # # with it.

        r=ObjectRegistry(min_objid_len=8)
        d=r._registry

        HASH_LEN =len(r.hash_obj(object())) # should be 40 for sha1

        objs = [object()]
        partial = r.register(objs[-1])
        oid = full_id(partial)
        for i in range(8,HASH_LEN):
        # now we've yanked a reference out, let's inject
        # back in with the same (i+1)-prefix
            print(d.keys())
            partial += '_'
            new_oid = partial + oid[i+1:]

            # use the registry to store a reference,
            # then yank it out and reinsert with new_oid
            objs.append(object())
            oid = full_id(r.register(objs[-1]))
            d[new_oid] = d.pop(oid)

        # check that the prefix gets us the original object
        # and that the prefix+_ gets us the new object
        # and that registering the same object, gets us the
        # new id
        #     self.assertEqual(r.get(partial[:-1]), objs[-2])

            self.assertEqual(r.get(partial[:-1]), objs[-2])
            self.assertEqual(r.get(partial), objs[-1])

        # Done

    def test_return_min_len_key_more2(self):
        def full_id(partial):
            return [x for x in d if x.startswith(partial)][0]
            # start returning keys with len >=8 (MIN_OBJID_LEN)
            # force collisions by building keys and shoving them
            # into the registry
            # then reregister same object and make sure
            # we get back an objid which is longer then
            # previous iteration, and that we can get back the object
            # # with it.

        MIN_OBJID_LEN=8

        r=ObjectRegistry(min_objid_len=MIN_OBJID_LEN)
        d=r._registry

        HASH_LEN =len(r.hash_obj(object())) # should be 40 for sha1

        ##### new test
        for i in range(MIN_OBJID_LEN,HASH_LEN-1):
            o = object()
            oid = r.register(o)
            foid = full_id(oid)
            new_oid = foid[i:] + '_' * (HASH_LEN-i)
            d[new_oid] = d.pop(foid)
            self.assertTrue(len(r.register(o)) >= len(oid))

        for j in range(100):
            import random
            o = object()
            oid = r.register(o)
            foid = full_id(oid)
            i=random.randint(MIN_OBJID_LEN,HASH_LEN-1)
            new_oid = foid[i:] + '_' * (HASH_LEN-i)
            d[new_oid] = d.pop(foid)
            self.assertTrue(len(r.register(o)) >= len(oid))



    def test_use_short_keys(self):

        r=ObjectRegistry(min_objid_len=8,use_short_keys=True)
        HASH_LEN =len(r.hash_obj(object())) # should be 40 for sha1
        self.assertEqual(len(r.register(object())), 8)

        r=ObjectRegistry(min_objid_len=7,use_short_keys=True)
        self.assertEqual(len(r.register(object())), 7)

        r=ObjectRegistry(min_objid_len=7,use_short_keys=False)
        self.assertEqual(len(r.register(object())), HASH_LEN)

        # must use full key when short_keys=False
        self.assertEqual(r.get(r.register(object())[:-1]), None)
########NEW FILE########
__FILENAME__ = test_server
# -*- coding: utf-8 -*-
from __future__ import print_function
import errno

from exhibitionist import get_server
from exhibitionist.exceptions import ExhibitionistError
import unittest

from exhibitionist.objectRegistry import ObjectRegistry
from exhibitionist.toolbox import ExhibitionistRequestHandler

context = None # mute missing symbol warning


class TestServer(unittest.TestCase):
    def setUp(self):
        self.server = get_server()


    def tearDown(self):
        if self.server.started_ok:
            self.server.stop()
            self.server.join(5)

    def test_add_handler(self):

        from exhibitionist.decorators import http_handler
        import requests

        # expose static files to client
        @http_handler(r'/')
        class Handler(ExhibitionistRequestHandler):
            def get(self, *args, **kwds):
                self.write("a")

        self.server.add_handler(Handler)
        self.server.start()

        result = requests.get(self.server.get_view_url("Handler")).content
        self.assertEqual(result, b"a")

    def test_websocket_enable_disable(self):
        server = get_server()
        self.assertTrue(hasattr(server.start(), "websocket"))
        server.stop()
        server.join(5)
        server = get_server(websockets_enabled=False)
        self.assertFalse(hasattr(server.start(), "websocket"))
        server.stop()
        server.join(5)

    def test_respect_requested_port(self):
        server = get_server(port=64003).start()
        self.assertEqual(server.port, 64003)

        # dies request port taken
        # logging.info("the next test should fail to bind to 64003")
        try:
            server = get_server(port=64003).start(timeout=0.1)
        except ExhibitionistError as e:
            # self.assertEqual(e.errno, errno.EADDRNOTAVAIL)
            pass
        else:
            self.fail("exception was not raised")

    def test_missing_obj_404(self):
        from exhibitionist.decorators import http_handler
        import requests

        registry = ObjectRegistry()
        basket = []

        @http_handler(r'/{{objid}}', __registry=registry)
        class Handler(ExhibitionistRequestHandler):
            def get(self, *args, **kwds):
                basket.append(context.object)
                self.write("")

        o = object()
        self.server.add_handler(Handler)
        self.server.start()
        self.assertEqual(len(basket), 0)
        url = self.server.get_view_url("Handler", o, __registry=registry)
        url = url[:-1] + "_" # make objid invalid
        r = requests.get(url)
        self.assertEqual(r.status_code, 404)

    def test_can_get_as_objid(self):
        from exhibitionist.decorators import http_handler
        import tornado.web
        import requests

        registry = ObjectRegistry()
        basket = []

        @http_handler(r'/{{objid}}', __registry=registry)
        class Handler(ExhibitionistRequestHandler):
            def get(self, *args, **kwds):
                basket.append(context.object)
                self.write("")

        o = object()
        k = registry.register(o)
        self.server.add_handler(Handler)
        self.server.start()
        self.assertEqual(len(basket), 0)

        url = self.server.get_view_url("Handler", k, __registry=registry)
        r = requests.get(url)
        self.assertEqual(r.status_code, 200)

        self.assertTrue(registry.register(o) in url)
        self.assertTrue(k in url)


    def test_can_pass_handler_kwds(self):
        from exhibitionist.decorators import http_handler
        import requests

        registry = ObjectRegistry()
        basket = []

        @http_handler(r'/', __registry=registry,foo='bar')
        class Handler(ExhibitionistRequestHandler):
            def initialize(self,**kwds):
                basket.append(kwds.get('foo',''))

            def get(self, *args, **kwds):
                pass

        self.server.add_handler(Handler)
        self.server.start()
        self.assertEqual(len(basket), 0)

        url = self.server.get_view_url("Handler", __registry=registry)
        r = requests.get(url)
        self.assertEqual(r.status_code, 200)

        self.assertEqual(len(basket), 1)
        self.assertEqual(basket.pop(), 'bar')


    def test_add_obj_handler(self):
        from exhibitionist.decorators import http_handler
        import requests

        registry = ObjectRegistry()
        basket = []

        @http_handler(r'/{{objid}}', __registry=registry)
        class Handler(ExhibitionistRequestHandler):
            def get(self, *args, **kwds):
                basket.append(context.object)
                self.write("")


        class A(object):
            pass

        o = object()
        self.server.add_handler(Handler)
        self.server.start()
        self.assertEqual(len(basket), 0)
        requests.get(
            self.server.get_view_url("Handler", o, __registry=registry))
        self.assertEqual(len(basket), 1)
        self.assertEqual(basket.pop(), o)

        # test weakref reaped
        o = A()
        self.assertEqual(len(basket), 0)
        url = self.server.get_view_url("Handler", o, __registry=registry,
                                       _weakref=True)
        requests.get(url)
        self.assertEqual(len(basket), 1)
        self.assertEqual(basket.pop(), o)
        del o

        r = requests.get(url)
        self.assertEqual(r.status_code, 404)


    def test_add_obj_handler_from_module(self):
        import requests

        import bogus_handlers as handlers

        registry = ObjectRegistry()

        self.server.add_handler(handlers)
        self.server.start()

        url = self.server.get_view_url("MyJSONView", __registry=registry)
        result = requests.get(url)
        body = result.content
        self.assertTrue(b"bar" in body)

        headers = result.headers
        # test JSONMixin
        self.assertEqual(headers["Content-Type"], "application/json")
        # test CORSMixin
        self.assertEqual(headers["Access-Control-Allow-Origin"], "CORS")

        #test JSONP, with custom callback param name
        url = self.server.get_view_url("MyJSONView",
                                       __registry=registry) + "?cb=?"

        result = requests.get(url)
        headers = result.headers
        self.assertEqual(headers["Content-Type"], 'text/javascript')


    def test_can_only_add_providers_before_server_start(self):
        self.server.start()._ensure_up()
        try:
            self.server.register_provider(object())
        except ExhibitionistError:
            pass
        else:
            self.fail("Didn't catch attempt to register provider after start")

    def test_can_only_add_handlers_before_server_start(self):
        self.server.start()._ensure_up()
        try:
            self.server.add_handler(object())
        except Exception:
            pass
        else:
            self.fail("Didn't catch attempt to add handlers after server start")

    def test_pure_evil_at_bay(self):

        # make sure requests to a given port are always handled
        # by the server thread that is listening to that port,
        # even having identical routes on different servers.
        # Tornado 2.4.1 doesn't do that if server threads share the IOLoop

        from tornado.web import RequestHandler
        import threading
        import requests
        from exhibitionist.decorators import http_handler

        bucket = set()

        @http_handler("/a",__test=True)
        class H(RequestHandler):
            def __init__(self, *args, **kwds):
                super(H, self).__init__(*args, **kwds)
                self.bucket = bucket

            def get(self):
                self.bucket.add(threading.current_thread().ident)

        servers = []
        try:

            for i in range(10):
                servers.append(get_server().add_handler(H).start())

            for i in range(100):
                requests.get(servers[0].get_view_url("H"))

            self.assertEqual(len(bucket), 1)
        finally:
            for s in servers:
                try:
                    s.stop()
                except:
                    pass


    def test_notify_channel_takes_strings_only(self):
        try:
            self.server.notify_channel(object(), "")
        except ValueError:
            pass
        else:
            self.fail("failed to raise exception")

    def test_kwds_in_decorator(self):
        from exhibitionist.decorators import http_handler
        import tornado.web
        import requests

        registry = ObjectRegistry()
        basket = []

        @http_handler(r'/{{objid}}', __registry=registry, myArg='abc')
        class Handler(ExhibitionistRequestHandler):
            def initialize(self, myArg):
                basket.append(myArg)

            def get(self, *args, **kwds):
                self.write("")

        o = object()
        self.server.add_handler(Handler)
        self.server.start()
        self.assertEqual(len(basket), 0)
        requests.get(
            self.server.get_view_url('Handler', o, __registry=registry))
        self.assertEqual(len(basket), 1)
        self.assertEqual(basket.pop(), 'abc')




########NEW FILE########
__FILENAME__ = toolbox
# -*- coding: utf-8 -*-
from __future__ import print_function

# This Module collects bits and pieces from all over the place in one namespace
# to reduce import boilerplate.
# Purists may shake their fist and mutter angrily about the evils of 'from x import *'

__all__ = ['HTTPError', 'JSONRequestHandler', 'CORSAllRequestHandler', 'StaticFileHandler',
           'RequestHandler', 'http_handler', 'WSMsg', 'JSONMixin', 'CORSMixin', 'getLogger',
           'UrlDisplay', 'xhtml_escape', 'utf8', 'get_server','ExhibitionistRequestHandler']


# just a messy collection of everything you need
from tornado.web import StaticFileHandler, RequestHandler, HTTPError
from tornado.escape import xhtml_escape, utf8

from exhibitionist.decorators import http_handler, SUPER_CANARY
from exhibitionist.mixins.json import JSONMixin
from exhibitionist.mixins.cors import CORSMixin
from exhibitionist.providers.websocket import WSMsg

from exhibitionist.log import getLogger
from exhibitionist.util.common import UrlDisplay
from exhibitionist import get_server


class ExhibitionistRequestHandler(RequestHandler):
    """
    All views should use a RequestHandler derived from this class.
    This should enable us to introduce new behaviour in the future
    to be availabe with a package upgrade rather then rewriting views.
    Let's hope they remember to call super()

    """
    def __init__(self,*args,**kwds):
        super(ExhibitionistRequestHandler,self).__init__(*args,**kwds)
        # @http_handler checks for this and removes it before calling
        # the method. So we can issue a warning if the user
        # fails to call super().__init__
        setattr(self,SUPER_CANARY,True)


class JSONRequestHandler(JSONMixin(callback_arg="callback"), ExhibitionistRequestHandler):
    pass

class CORSAllRequestHandler(CORSMixin(allowed_domain="*"), JSONRequestHandler):
    pass


########NEW FILE########
__FILENAME__ = common
# -*- coding: utf-8 -*-
from __future__ import print_function

class UrlDisplay(object):# pragma: no cover
    """Displays urls as text, hotlinks, or inline HTML if in IPython

    height [default "400px"] - iframe height.
    width [default  "100%"] - iframe width.
    fs_btn [default False]- add a 'full-screen' button to the view.
    """

    def __init__(self, url, height="400px",width="100%", **kwds):

        self.url = url
        self.width = width
        self.height = height
        self.fs_btn = kwds.get('fs_btn', False)

    # noinspection PyBroadException
    @staticmethod
    def check_ipython():
        env = None
        try:
            ip = get_ipython()
            env = "ipython"

            # 0.13, 0.14/1.0dev keep the type of frontend in different places
            front_end = (ip.config.get('KernelApp') or
                         ip.config.get('IPKernelApp'))['parent_appname']
            if "qtconsole" in front_end:
                env = "qtconsole"
            elif "notebook" in front_end:
                env = "notebook"
        except:
            pass
        return env

    def notebook_repr(self):
        """ override this method"""
        from hashlib import sha1
        import random
        import os.path as osp
        rand_hash=sha1(str(random.random())).hexdigest()
        frags_dir  = osp.abspath(osp.join(osp.dirname(__file__),"../static"))
        # This will have to become a template engine dependency
        # resistance is futile.
        markup = open(osp.join(frags_dir,"ipython_iframe.html")).read()\
            .format(url=self.url,
                    width=self.width,
                    height=self.height,
                    rand_hash=rand_hash)

        markup += open(osp.join(frags_dir,"ipython_freezing.html")).read() % (rand_hash,)
        if self.fs_btn:
            markup += open(osp.join(frags_dir,"ipython_fs_btn.html")).read()

        return markup

    def qtconsole_repr(self):
        """ override this method"""
        return 'Open this <a href="%s">link</a>  to View the object' % (self.url)

    def __repr__(self):
        return self.url

    def _repr_html_(self):

        if self.check_ipython() == 'notebook':
            return self.notebook_repr()
        elif self.check_ipython() == 'qtconsole':
            return self.qtconsole_repr()
        else:
            raise NotImplementedError()

########NEW FILE########
__FILENAME__ = compat
# -*- coding: utf-8 -*-
from __future__ import print_function

from collections import MutableMapping
import six


class _OrderedDict(dict, MutableMapping): # pragma: no cover
    # Methods with direct access to underlying attributes

    # noinspection PyMissingConstructor
    def __init__(self, *args, **kwds):
        if len(args) > 1:
            raise TypeError('expected at 1 argument, got %d', len(args))
        if not hasattr(self, '_keys'):
            self._keys = []
        self.update(*args, **kwds)

    def clear(self):
        del self._keys[:]
        dict.clear(self)

    def __setitem__(self, key, value):
        if key not in self:
            self._keys.append(key)
        dict.__setitem__(self, key, value)

    def __delitem__(self, key):
        dict.__delitem__(self, key)
        self._keys.remove(key)

    def __iter__(self):
        return iter(self._keys)

    def __reversed__(self):
        return reversed(self._keys)

    def popitem(self):
        if not self:
            raise KeyError
        key = self._keys.pop()
        value = dict.pop(self, key)
        return key, value

    def __reduce__(self):
        items = [[k, self[k]] for k in self]
        inst_dict = vars(self).copy()
        inst_dict.pop('_keys', None)
        return (self.__class__, (items,), inst_dict)

    # Methods with indirect access via the above methods

    setdefault = MutableMapping.setdefault
    update = MutableMapping.update
    pop = MutableMapping.pop
    keys = MutableMapping.keys
    values = MutableMapping.values
    items = MutableMapping.items

    def __repr__(self):
        pairs = ', '.join(map('%r: %r'.__mod__, self.items()))
        return '%s({%s})' % (self.__class__.__name__, pairs)

    def copy(self):
        return self.__class__(self)

    # noinspection PyMethodOverriding
    @classmethod
    def fromkeys(cls, iterable, value=None):
        d = cls()
        for key in iterable:
            d[key] = value
        return d


import sys

if sys.version_info[:2] < (2, 7):
    OrderedDict = _OrderedDict
else:
    from collections import OrderedDict


########NEW FILE########
