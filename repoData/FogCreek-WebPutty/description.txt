# Google App Engine Mini Profiler

gae_mini_profiler is a quick drop-in WSGI app that provides ubiquitous profiling of your existing GAE projects. It exposes both RPC statistics and standard profiling output for users of your choosing on your production site. Only requests coming from users of your choosing will be profiled, and others will not suffer any performance degradation. See screenshots and features below.

This project is heavily inspired by the impressive [mvc-mini-profiler](http://code.google.com/p/mvc-mini-profiler/).

gae_mini_profiler is [MIT licensed](http://en.wikipedia.org/wiki/MIT_License).

* <a href="#demo">Demo</a>
* <a href="#screens">Screenshots</a>
* <a href="#start">Getting Started</a>
* <a href="#features">Features</a>
* <a href="#dependencies">Dependencies</a>
* <a href="#bonus">Bonus</a>
* <a href="#faq">FAQ</a>

## <a name="demo">Demo</a>

You can play around with one of GAE's sample applications with gae_mini_profiler enabled for all users via [http://gae-mini-profiler.appspot.com](http://gae-mini-profiler.appspot.com/).

## <a name="screens">Screenshots</a>

<img src="http://gae-mini-profiler.appspot.com/images/gae-mini-profiler/corner.png"/><br/><em>All profiled pages have total milliseconds in corner, which can be expanded...</em><br/><br/>
<img src="http://gae-mini-profiler.appspot.com/images/gae-mini-profiler/expanded.png"/><br/><em>...to show more details...</em><br/><br/>
<img src="http://gae-mini-profiler.appspot.com/images/gae-mini-profiler/rpc.png"/><br/><em>...about remote procedure call performance...</em><br/><br/>
<img src="http://gae-mini-profiler.appspot.com/images/gae-mini-profiler/profile.png"/><br/><em>...or standard profiler output.</em><br/><br/>
<img src="http://gae-mini-profiler.appspot.com/images/gae-mini-profiler/ajax-corner.png?test"/><br/><em>Ajax requests are also profiled and details made available as they are received.</em><br/><br/>
<img src="http://i.imgur.com/SG0dp.png"/><br/><em>Any Python logging module output is also available for easy access.</em>

## <a name="start">Getting Started</a>

1. Download this repository's source and copy the `gae_mini_profiler/` folder into your App Engine project's root directory.

2. Add the following two handler definitions to `app.yaml`:

        handlers:
        - url: /gae_mini_profiler/static
          static_dir: gae_mini_profiler/static
        - url: /gae_mini_profiler/.*
          script: gae_mini_profiler/main.py

3. Modify the WSGI application you want to profile by wrapping it with the gae_mini_profiler WSGI application. This is usually done in `appengine_config.py`:

        import gae_mini_profiler.profiler
        gae_mini_profiler_ENABLED_PROFILER_EMAILS = ['m.dornseif@hudora.de']

        def webapp_add_wsgi_middleware(app):
            """Called with each WSGI handler initialisation"""
            app = gae_mini_profiler.profiler.ProfilerWSGIMiddleware(app)
            return app

4. If you use Django Templates insert the `profiler_includes` template tag below jQuery somewhere (preferably at the end of your template):

                ...your html...
                {% profiler_includes %}
            </body>
        </html>

    Alternatively on any other template system you can hardcode the call.
    
    For example in jinja2 first add a function to template globals that can retrieve the request_id, something like:
    
        from gae_mini_profiler import profiler
        def get_request_id():
            return profiler.request_id
        jinja_env.globals['get_request_id'] = get_request_id

    Than add this to your template:

        <link rel="stylesheet" type="text/css" href="/gae_mini_profiler/static/css/profiler.css" />
        <script type="text/javascript" src="/gae_mini_profiler/static/js/profiler.js"></script>
        <script type="text/javascript">GaeMiniProfiler.init("{{get_request_id()}}", false)</script>

    If you use the static inclusion you probably should use your template engine to include the code only
for admins or other profiling-prone users.

5. You're all set! Just choose the users for whom you'd like to enable profiling by putting the respective E-Mail addresses in `gae_mini_profiler/config.py`:

            enabled_profiler_emails = ['user1@example.com',
                                       'user2@example.com']

For more sophisticated choice of what to profile check `gae_mini_profiler/config.py`.


## <a name="features">Features</a>

* Production profiling without impacting normal users
* Easily profile all requests, including ajax calls
* Summaries of RPC call types and their performance so you can quickly figure out whether datastore, memcache, or urlfetch is your bottleneck
* Redirect chains are tracked -- quickly examine the profile of not just the currently rendered request, but any preceding request that issued a 302 redirect leading to the current page.
* Share individual profile results with others by sending link
* Duplicate RPC calls are flagged for easy spotting in case you're repeating memcache or datastore queries.
* Quickly sort and examine profiler stats and call stacks

## <a name="dependencies">Dependencies</a>

* jQuery must be included somewhere on your page.
* (Optional) If you want the fancy slider selector for the Logs output, jQuery UI must also be included with its Slider plugin.

## <a name="bonus">Bonus</a>

gae_mini_profiler is currently in production use at [Khan Academy](http://khanacademy.org) as well as [WebPutty](http://www.webputty.net). If you make good use of it elsewhere, be sure to let me know.

## <a name="faq">FAQ</a>

1. I had my appstats_RECORD_FRACTION variable set to 0.1, which means only 10% of my queries were getting profiles generated.  This meant that most of the time gae_mini_profiler was failing with a javascript error, because the appstats variable was null.

    If you are using appengine_config.py to customize Appstats behavior you should add this to the top of your "appstats_should_record" method.
<pre>def appstats_should_record(env):
        from gae_mini_profiler.config import should_profile
        if should_profile(env):
            return True
</pre>

# WebPutty: The Open Source Transmogrifier

<img src="http://blog.fogcreek.com/wp-content/uploads/2011/07/transmogrifier_small.png" width="300" height="300" alt="WebPutty Transmogrifier" title="WebPutty Transmogrifier" style="float: right;" />

## What the what?

WebPutty is a simple CSS editing and hosting service that you can run on [Google App Engine](https://developers.google.com/appengine/).

WebPutty gives you a syntax-highlighting CSS editor you can use from anywhere, the power of [SCSS](http://sass-lang.com/) and [Compass](http://compass-style.org/), a side-by-side preview pane, and instant publishing with minification, compression, and automatic cache control.

You can get started with just a pair of tags in your website's template and WebPutty will host and serve your published CSS minified and gzipped for super speed.

Intrigued? Read more about [the motivation behind WebPutty](http://blog.fogcreek.com/webputty-css-editing-goes-boink/?fccmp=webputty), [how it came to be](http://tghw.com/blog/lean-development-zero-to-launch-in-six-weeks/), and [how it ended up being open-source](http://blog.fogcreek.com/whats-up-with-webputty/?fccmp=webputty).

## How to get WebPutty up and running on your very own sparkly Google App Engine account:

1. Download and install [Python 2.7](http://www.python.org/getit/releases/2.7.4/) and the [Google App Engine SDK for Python](https://developers.google.com/appengine/downloads)
- Clone this repo
- [Log into Google App Engine](https://appengine.google.com/) and create a new application
- Open up app.yaml in the root of this repo and update `application` to match the name of your newly created Google App Engine application
- Open up settings.py (also in the root of this repo) and update the following variables:
	* `invite_sender_email`
	* `incoming_sender_email`
	* `forward_mail_to`
	* `secret_key`

- Install [pip](http://pypi.python.org/pypi/pip)
- `pip install fabric`
- `fab deploy`
- `sip lemonade`

# Advanced Setup:
### For page preview images:
- Go to http://url2png.com and sign up for an account
	- Add these settings to the `url2png` section in settings.py

### To store WebPutty stylesheets using Google Cloud Storage (faster and cheaper than GAE):
- Sign up for [Google Cloud Storage](https://developers.google.com/storage/) via [Google's API console](https://code.google.com/apis/console/)
	- Update `google_bucket` and `use_google_cloud_storage` in settings.py

# Copyright

Copyright (c) 2011-2013 Fog Creek Software Inc.

Some of the icons, images, and sample HTML &amp; CSS used by WebPutty are licensed under the following terms:

- [Creative Commons Attribution License](http://creativecommons.org/licenses/by/3.0/)
  * FatCow Web Hosting, [Farm-Fresh Web Icon Pack](http://www.fatcow.com/free-icons)
  * design deck, [IC Minimal Icon Set](http://www.designdeck.co.uk/article_details.php?id=246)
  * Yusuke Kamiyamane, [Fugue Icon Pack](http://p.yusukekamiyamane.com/)
  * Mark Pilgrim, [Dive into HTML5](http://diveintohtml5.org)

- [Creative Commons Attribution-NoDerivs License](http://creativecommons.org/licenses/by-nd/3.0/)
  * Double-J Design, [Siena Icon Pack](http://www.doublejdesign.co.uk/products-page/icons/siena/)

- [Creative Commons Attribution-Noncommercial-Share Alike License](http://creativecommons.org/licenses/by-nc-sa/3.0/) (with explicit permission for use in WebPutty)
  * Hayes Roberts, [www.bluebison.net](http://www.bluebison.net/content/?p=786)

# License

WebPutty is licensed under the [MIT](http://www.opensource.org/licenses/mit-license.php "Read more about the MIT license form") license.

