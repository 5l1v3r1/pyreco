__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# django-zebra documentation build configuration file, created by
# sphinx-quickstart on Thu Feb 16 22:57:53 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.todo', 'sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'django-zebra'
copyright = u'2012, Steven Skoczen & Lee Trout'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '1.0'
# The full version, including alpha/beta/rc tags.
release = '1.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'django-zebradoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'django-zebra.tex', u'django-zebra Documentation',
   u'Steven Skoczen \\& Lee Trout', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'django-zebra', u'django-zebra Documentation',
     [u'Steven Skoczen & Lee Trout'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'django-zebra', u'django-zebra Documentation',
   u'Steven Skoczen & Lee Trout', 'django-zebra', 'Stripe library for Django',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

from zebra.conf import options

if options.ZEBRA_ENABLE_APP:
    from zebra.models import Customer, Plan, Subscription
    
    admin.site.register(Customer)
    admin.site.register(Plan)
    admin.site.register(Subscription)

########NEW FILE########
__FILENAME__ = options
"""
Default settings for zebra
"""
import datetime
import os

from django.conf import settings as _settings


if hasattr(_settings, 'STRIPE_PUBLISHABLE'):
    STRIPE_PUBLISHABLE = getattr(_settings, 'STRIPE_PUBLISHABLE')
else:
    try:
        STRIPE_PUBLISHABLE = os.environ['STRIPE_PUBLISHABLE']
    except KeyError:
        STRIPE_PUBLISHABLE = ''

if hasattr(_settings, 'STRIPE_SECRET'):
    STRIPE_SECRET = getattr(_settings, 'STRIPE_SECRET')
else:
    try:
        STRIPE_SECRET = os.environ['STRIPE_SECRET']
    except KeyError:
        STRIPE_SECRET = ''

ZEBRA_ENABLE_APP = getattr(_settings, 'ZEBRA_ENABLE_APP', False)
ZEBRA_AUTO_CREATE_STRIPE_CUSTOMERS = getattr(_settings,
    'ZEBRA_AUTO_CREATE_STRIPE_CUSTOMERS', True)

_today = datetime.date.today()
ZEBRA_CARD_YEARS = getattr(_settings, 'ZEBRA_CARD_YEARS',
    range(_today.year, _today.year+12))
ZEBRA_CARD_YEARS_CHOICES = getattr(_settings, 'ZEBRA_CARD_YEARS_CHOICES',
    [(i,i) for i in ZEBRA_CARD_YEARS])

ZEBRA_MAXIMUM_STRIPE_CUSTOMER_LIST_SIZE = getattr(_settings,
    'ZEBRA_MAXIMUM_STRIPE_CUSTOMER_LIST_SIZE', 100)

_audit_defaults = {
    'active': 'active',
    'no_subscription': 'no_subscription',
    'past_due': 'past_due',
    'suspended': 'suspended',
    'trialing': 'trialing',
    'unpaid': 'unpaid',
    'cancelled': 'cancelled'
}

ZEBRA_AUDIT_RESULTS = getattr(_settings, 'ZEBRA_AUDIT_RESULTS', _audit_defaults)

ZEBRA_ACTIVE_STATUSES = getattr(_settings, 'ZEBRA_ACTIVE_STATUSES',
    ('active', 'past_due', 'trialing'))
ZEBRA_INACTIVE_STATUSES = getattr(_settings, 'ZEBRA_INACTIVE_STATUSES',
    ('cancelled', 'suspended', 'unpaid', 'no_subscription'))

if ZEBRA_ENABLE_APP:
    ZEBRA_CUSTOMER_MODEL = getattr(_settings, 'ZEBRA_CUSTOMER_MODEL', 'zebra.Customer')
else:
    ZEBRA_CUSTOMER_MODEL = getattr(_settings, 'ZEBRA_CUSTOMER_MODEL', None)

########NEW FILE########
__FILENAME__ = forms
from django import forms
from django.core.exceptions import NON_FIELD_ERRORS
from django.utils.dates import MONTHS

from zebra.conf import options
from zebra.widgets import NoNameSelect, NoNameTextInput


class MonospaceForm(forms.Form):
    def addError(self, message):
        self._errors[NON_FIELD_ERRORS] = self.error_class([message])


class CardForm(MonospaceForm):
    last_4_digits = forms.CharField(required=True, min_length=4, max_length=4,
        widget=forms.HiddenInput())
    stripe_token = forms.CharField(required=True, widget=forms.HiddenInput())


class StripePaymentForm(CardForm):
    def __init__(self, *args, **kwargs):
        super(StripePaymentForm, self).__init__(*args, **kwargs)
        self.fields['card_cvv'].label = "Card CVC"
        self.fields['card_cvv'].help_text = "Card Verification Code; see rear of card."
        months = [ (m[0], u'%02d - %s' % (m[0], unicode(m[1])))
                    for m in sorted(MONTHS.iteritems()) ]
        self.fields['card_expiry_month'].choices = months

    card_number = forms.CharField(required=False, max_length=20,
        widget=NoNameTextInput())
    card_cvv = forms.CharField(required=False, max_length=4,
        widget=NoNameTextInput())
    card_expiry_month = forms.ChoiceField(required=False, widget=NoNameSelect(),
        choices=MONTHS.iteritems())
    card_expiry_year = forms.ChoiceField(required=False, widget=NoNameSelect(),
        choices=options.ZEBRA_CARD_YEARS_CHOICES)

########NEW FILE########
__FILENAME__ = clear_stripe_test_customers
from django.core.management.base import BaseCommand

import stripe

from zebra.conf import options as zoptions


CLEAR_CHUNK_SIZE = zoptions.ZEBRA_MAXIMUM_STRIPE_CUSTOMER_LIST_SIZE

class Command(BaseCommand):
    help = "Clear all test mode customers from your stripe account."
    __test__ = False

    def handle(self, *args, **options):
        verbosity = int(options.get('verbosity', 1))
        stripe.api_key = zoptions.STRIPE_SECRET
        customer_chunk = [0]

        if verbosity > 0:
            print "Clearing stripe test customers:"
        
        num_checked = 0
        while len(customer_chunk) is not 0:
            customer_chunk = stripe.Customer.all(count=CLEAR_CHUNK_SIZE, offset=num_checked).data

            if verbosity > 1:     
                print "Processing records %s-%s" % (num_checked, num_checked+len(customer_chunk))

            for c in customer_chunk:
                if verbosity > 2:
                    print "Deleting %s..." % (c.description),

                if not c.livemode:
                    c.delete()

                    if verbosity > 2:
                        print "done"
            
            num_checked = num_checked + len(customer_chunk)
        
        if verbosity > 0:
            print "Finished clearing stripe test customers."

########NEW FILE########
__FILENAME__ = mixins
import stripe

from zebra.conf import options


def _get_attr_value(instance, attr, default=None):
    """
    Simple helper to get the value of an instance's attribute if it exists.

    If the instance attribute is callable it will be called and the result will
    be returned.

    Optionally accepts a default value to return if the attribute is missing.
    Defaults to `None`

    >>> class Foo(object):
    ...     bar = 'baz'
    ...     def hi(self):
    ...         return 'hi'
    >>> f = Foo()
    >>> _get_attr_value(f, 'bar')
    'baz'
    >>> _get_attr_value(f, 'xyz')

    >>> _get_attr_value(f, 'xyz', False)
    False
    >>> _get_attr_value(f, 'hi')
    'hi'
    """
    value = default
    if hasattr(instance, attr):
        value = getattr(instance, attr)
        if callable(value):
            value = value()
    return value


class StripeMixin(object):
    """
    Provides a property `stripe` that returns an instance of the Stripe module.

    It optionally supports the ability to set `stripe.api_key` if your class
    has a `stripe_api_key` attribute (method or property), or if
    settings has a `STRIPE_SECRET` attribute (method or property).
    """
    def _get_stripe(self):
        if hasattr(self, 'stripe_api_key'):
            stripe.api_key = _get_attr_value(self, 'stripe_api_key')
        elif hasattr(options, 'STRIPE_SECRET'):
            stripe.api_key = _get_attr_value(options, 'STRIPE_SECRET')
        return stripe
    stripe = property(_get_stripe)


class StripeCustomerMixin(object):
    """
    Provides a property property `stripe_customer` that returns a stripe
    customer instance.

    Your class must provide:
    
    - an attribute `stripe_customer_id` (method or property)
      to provide the customer id for the returned instance, and
    - an attribute `stripe` (method or property) that returns an instance
      of the Stripe module. StripeMixin is an easy way to get this.
    
    """
    def _get_stripe_customer(self):
        c = None
        if _get_attr_value(self, 'stripe_customer_id'):
            c = self.stripe.Customer.retrieve(_get_attr_value(self,
                                        'stripe_customer_id'))
        if not c and options.ZEBRA_AUTO_CREATE_STRIPE_CUSTOMERS:
            c = self.stripe.Customer.create()
            self.stripe_customer_id = c.id
            self.save()

        return c
    stripe_customer = property(_get_stripe_customer)


class StripeSubscriptionMixin(object):
    """
    Provides a property `stripe_subscription` that returns a stripe
    subscription instance.

    Your class must have an attribute `stripe_customer` (method or property)
    to provide a customer instance with which to lookup the subscription.
    """
    def _get_stripe_subscription(self):
        subscription = None
        customer = _get_attr_value(self, 'stripe_customer')
        if hasattr(customer, 'subscription'):
            subscription = customer.subscription
        return subscription
    stripe_subscription = property(_get_stripe_subscription)


class StripePlanMixin(object):
    """
    Provides a property `stripe_plan` that returns a stripe plan instance.

    Your class must have an attribute `stripe_plan_id` (method or property)
    to provide the plan id for the returned instance.
    """
    def _get_stripe_plan(self):
        return stripe.Plan.retrieve(_get_attr_value(self, 'stripe_plan_id'))
    stripe_plan = property(_get_stripe_plan)


class StripeInvoiceMixin(object):
    """
    Provides a property `stripe_invoice` that returns a stripe invoice instance.

    Your class must have an attribute `stripe_invoice_id` (method or property)
    to provide the invoice id for the returned instance.
    """
    def _get_stripe_invoice(self):
        return stripe.Invoice.retrieve(_get_attr_value(self,
                                                        'stripe_invoice_id'))
    stripe_invoice = property(_get_stripe_invoice)


class StripeInvoiceItemMixin(object):
    """
    Provides a property `stripe_invoice_item` that returns a stripe
    invoice item instance.

    Your class must have an attribute `stripe_invoice_item_id` (method or
    property) to provide the invoice id for the returned instance.
    """
    def _get_stripe_invoice_item(self):
        return stripe.InvoiceItem.retrieve(_get_attr_value(self,
                                                    'stripe_invoice_item_id'))
    stripe_invoice_item = property(_get_stripe_invoice_item)


class StripeChargeMixin(object):
    """
    Provides a property `stripe_charge` that returns a stripe charge instance.

    Your class must have an attribute `stripe_charge_id` (method or
    property) to provide the invoice id for the returned instance.
    """
    def _get_stripe_charge(self):
        return stripe.Charge.retrieve(_get_attr_value(self, 'stripe_charge_id'))
    stripe_charge = property(_get_stripe_charge)


class ZebraMixin(StripeMixin, StripeCustomerMixin, StripeSubscriptionMixin,
                StripePlanMixin, StripeInvoiceMixin, StripeInvoiceItemMixin,
                StripeChargeMixin):
    """
    Provides all available Stripe mixins in one class.

    `self.stripe`
    `self.stripe_customer`
    `self.stripe_subscription`
    `self.stripe_plan`
    """
    pass

########NEW FILE########
__FILENAME__ = models
from django.db import models

from zebra import mixins
from zebra.conf import options


class StripeCustomer(models.Model, mixins.StripeMixin, mixins.StripeCustomerMixin):
    stripe_customer_id = models.CharField(max_length=50, blank=True, null=True)

    class Meta:
        abstract = True

    def __unicode__(self):
        return u"%s" % self.stripe_customer_id


class StripePlan(models.Model, mixins.StripeMixin, mixins.StripePlanMixin):
    stripe_plan_id = models.CharField(max_length=50, blank=True, null=True)

    class Meta:
        abstract = True

    def __unicode__(self):
        return u"%s" % self.stripe_plan_id


class StripeSubscription(models.Model, mixins.StripeMixin, mixins.StripeSubscriptionMixin):
    """
    You need to provide a stripe_customer attribute. See zebra.models for an
    example implimentation.
    """
    class Meta:
        abstract = True


# Non-abstract classes must be enabled in your project's settings.py
if options.ZEBRA_ENABLE_APP:
    class DatesModelBase(models.Model):
        date_created = models.DateTimeField(auto_now_add=True)
        date_modified = models.DateTimeField(auto_now=True)

        class Meta:
            abstract = True

    class Customer(DatesModelBase, StripeCustomer):
        pass

    class Plan(DatesModelBase, StripePlan):
        pass

    class Subscription(DatesModelBase, StripeSubscription):
        customer = models.ForeignKey(Customer)
        plan = models.ForeignKey(Plan)

        def __unicode__(self):
            return u"%s: %s" % (self.customer, self.plan)

        @property
        def stripe_customer(self):
            return self.customer.stripe_customer
########NEW FILE########
__FILENAME__ = signals
"""
Provides the following signals:

V1

- zebra_webhook_recurring_payment_failed
- zebra_webhook_invoice_ready
- zebra_webhook_recurring_payment_succeeded
- zebra_webhook_subscription_trial_ending
- zebra_webhook_subscription_final_payment_attempt_failed
- zebra_webhook_subscription_ping_sent

v2

- zebra_webhook_charge_succeeded
- zebra_webhook_charge_failed
- zebra_webhook_charge_refunded
- zebra_webhook_charge_disputed
- zebra_webhook_customer_created
- zebra_webhook_customer_updated
- zebra_webhook_customer_deleted
- zebra_webhook_customer_subscription_created
- zebra_webhook_customer_subscription_updated
- zebra_webhook_customer_subscription_deleted
- zebra_webhook_customer_subscription_trial_will_end
- zebra_webhook_customer_discount_created
- zebra_webhook_customer_discount_updated
- zebra_webhook_customer_discount_deleted
- zebra_webhook_invoice_created
- zebra_webhook_invoice_updated
- zebra_webhook_invoice_payment_succeeded
- zebra_webhook_invoice_payment_failed
- zebra_webhook_invoiceitem_created
- zebra_webhook_invoiceitem_updated
- zebra_webhook_invoiceitem_deleted
- zebra_webhook_plan_created
- zebra_webhook_plan_updated
- zebra_webhook_plan_deleted
- zebra_webhook_coupon_created
- zebra_webhook_coupon_updated
- zebra_webhook_coupon_deleted
- zebra_webhook_transfer_created
- zebra_webhook_transfer_failed
- zebra_webhook_ping
"""
import django.dispatch

WEBHOOK_ARGS = ["customer", "full_json"]

zebra_webhook_recurring_payment_failed = django.dispatch.Signal(providing_args=WEBHOOK_ARGS)
zebra_webhook_invoice_ready = django.dispatch.Signal(providing_args=WEBHOOK_ARGS)
zebra_webhook_recurring_payment_succeeded = django.dispatch.Signal(providing_args=WEBHOOK_ARGS)
zebra_webhook_subscription_trial_ending = django.dispatch.Signal(providing_args=WEBHOOK_ARGS)
zebra_webhook_subscription_final_payment_attempt_failed = django.dispatch.Signal(providing_args=WEBHOOK_ARGS)
zebra_webhook_subscription_ping_sent = django.dispatch.Signal(providing_args=[])

# v2 webhooks
WEBHOOK2_ARGS = ["full_json"]

zebra_webhook_charge_succeeded = django.dispatch.Signal(providing_args=WEBHOOK2_ARGS)
zebra_webhook_charge_failed = django.dispatch.Signal(providing_args=WEBHOOK2_ARGS)
zebra_webhook_charge_refunded = django.dispatch.Signal(providing_args=WEBHOOK2_ARGS)
zebra_webhook_charge_disputed = django.dispatch.Signal(providing_args=WEBHOOK2_ARGS)
zebra_webhook_customer_created = django.dispatch.Signal(providing_args=WEBHOOK2_ARGS)
zebra_webhook_customer_updated = django.dispatch.Signal(providing_args=WEBHOOK2_ARGS)
zebra_webhook_customer_deleted = django.dispatch.Signal(providing_args=WEBHOOK2_ARGS)
zebra_webhook_customer_subscription_created = django.dispatch.Signal(providing_args=WEBHOOK2_ARGS)
zebra_webhook_customer_subscription_updated = django.dispatch.Signal(providing_args=WEBHOOK2_ARGS)
zebra_webhook_customer_subscription_deleted = django.dispatch.Signal(providing_args=WEBHOOK2_ARGS)
zebra_webhook_customer_subscription_trial_will_end = django.dispatch.Signal(providing_args=WEBHOOK2_ARGS)
zebra_webhook_customer_discount_created = django.dispatch.Signal(providing_args=WEBHOOK2_ARGS)
zebra_webhook_customer_discount_updated = django.dispatch.Signal(providing_args=WEBHOOK2_ARGS)
zebra_webhook_customer_discount_deleted = django.dispatch.Signal(providing_args=WEBHOOK2_ARGS)
zebra_webhook_invoice_created = django.dispatch.Signal(providing_args=WEBHOOK2_ARGS)
zebra_webhook_invoice_updated = django.dispatch.Signal(providing_args=WEBHOOK2_ARGS)
zebra_webhook_invoice_payment_succeeded = django.dispatch.Signal(providing_args=WEBHOOK2_ARGS)
zebra_webhook_invoice_payment_failed = django.dispatch.Signal(providing_args=WEBHOOK2_ARGS)
zebra_webhook_invoiceitem_created = django.dispatch.Signal(providing_args=WEBHOOK2_ARGS)
zebra_webhook_invoiceitem_updated = django.dispatch.Signal(providing_args=WEBHOOK2_ARGS)
zebra_webhook_invoiceitem_deleted = django.dispatch.Signal(providing_args=WEBHOOK2_ARGS)
zebra_webhook_plan_created = django.dispatch.Signal(providing_args=WEBHOOK2_ARGS)
zebra_webhook_plan_updated = django.dispatch.Signal(providing_args=WEBHOOK2_ARGS)
zebra_webhook_plan_deleted = django.dispatch.Signal(providing_args=WEBHOOK2_ARGS)
zebra_webhook_coupon_created = django.dispatch.Signal(providing_args=WEBHOOK2_ARGS)
zebra_webhook_coupon_updated = django.dispatch.Signal(providing_args=WEBHOOK2_ARGS)
zebra_webhook_coupon_deleted = django.dispatch.Signal(providing_args=WEBHOOK2_ARGS)
zebra_webhook_transfer_created = django.dispatch.Signal(providing_args=WEBHOOK2_ARGS)
zebra_webhook_transfer_failed = django.dispatch.Signal(providing_args=WEBHOOK2_ARGS)
zebra_webhook_ping = django.dispatch.Signal(providing_args=WEBHOOK2_ARGS)

WEBHOOK_MAP = {
    'charge_succeeded': zebra_webhook_charge_succeeded,
    'charge_failed': zebra_webhook_charge_failed,
    'charge_refunded': zebra_webhook_charge_refunded,
    'charge_disputed': zebra_webhook_charge_disputed,
    'customer_created': zebra_webhook_customer_created,
    'customer_updated': zebra_webhook_customer_updated,
    'customer_deleted': zebra_webhook_customer_deleted,
    'customer_subscription_created': zebra_webhook_customer_subscription_created,
    'customer_subscription_updated': zebra_webhook_customer_subscription_updated,
    'customer_subscription_deleted': zebra_webhook_customer_subscription_deleted,
    'customer_subscription_trial_will_end': zebra_webhook_customer_subscription_trial_will_end,
    'customer_discount_created': zebra_webhook_customer_discount_created,
    'customer_discount_updated': zebra_webhook_customer_discount_updated,
    'customer_discount_deleted': zebra_webhook_customer_discount_deleted,
    'invoice_created': zebra_webhook_invoice_created,
    'invoice_updated': zebra_webhook_invoice_updated,
    'invoice_payment_succeeded': zebra_webhook_invoice_payment_succeeded,
    'invoice_payment_failed': zebra_webhook_invoice_payment_failed,
    'invoiceitem_created': zebra_webhook_invoiceitem_created,
    'invoiceitem_updated': zebra_webhook_invoiceitem_updated,
    'invoiceitem_deleted': zebra_webhook_invoiceitem_deleted,
    'plan_created': zebra_webhook_plan_created,
    'plan_updated': zebra_webhook_plan_updated,
    'plan_deleted': zebra_webhook_plan_deleted,
    'coupon_created': zebra_webhook_coupon_created,
    'coupon_updated': zebra_webhook_coupon_updated,
    'coupon_deleted': zebra_webhook_coupon_deleted,
    'transfer_created': zebra_webhook_transfer_created,
    'transfer_failed': zebra_webhook_transfer_failed,
    'ping': zebra_webhook_ping,
}

########NEW FILE########
__FILENAME__ = zebra_tags
from django.core.urlresolvers import reverse
from django import template
from django.template.loader import render_to_string
from django.utils.encoding import force_unicode
from django.utils.safestring import mark_safe
from django.utils.translation import ugettext as _

from zebra.conf import options


register = template.Library()

def _set_up_zebra_form(context):
    if not "zebra_form" in context:
        if "form" in context:
            context["zebra_form"] = context["form"]
        else:
            raise Exception, "Missing stripe form."
    context["STRIPE_PUBLISHABLE"] = options.STRIPE_PUBLISHABLE
    return context


@register.inclusion_tag('zebra/_stripe_js_and_set_stripe_key.html', takes_context=True)
def zebra_head_and_stripe_key(context):
    return _set_up_zebra_form(context)


@register.inclusion_tag('zebra/_basic_card_form.html', takes_context=True)
def zebra_card_form(context):
    return _set_up_zebra_form(context)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url

from zebra import views

urlpatterns = patterns('',
    url(r'webhooks/$',     views.webhooks,          name='webhooks'),
    url(r'webhooks/v2/$',     views.webhooks_v2,          name='webhooks_v2'),
)

########NEW FILE########
__FILENAME__ = utils
from zebra.conf import options

AUDIT_RESULTS = options.ZEBRA_AUDIT_RESULTS


def audit_customer_subscription(customer, unknown=True):
    """
    Audits the provided customer's subscription against stripe and returns a pair
    that contains a boolean and a result type.

    Default result types can be found in zebra.conf.defaults and can be
    overridden in your project's settings.
    """
    if (hasattr(customer, 'suspended') and customer.suspended):
        result = AUDIT_RESULTS['suspended']
    else:
        if hasattr(customer, 'subscription'):
            try:
                result = AUDIT_RESULTS[customer.subscription.status]
            except KeyError, err:
                # TODO should this be a more specific exception class?
                raise Exception("Unable to locate a result set for \
subscription status %s in ZEBRA_AUDIT_RESULTS") % str(err)
        else:
            result = AUDIT_RESULTS['no_subscription']
    return result
########NEW FILE########
__FILENAME__ = views
from django.http import HttpResponse
try:
    import json as simplejson
except:
    from django.utils import simplejson
    
from django.db.models import get_model
import stripe
from zebra.conf import options
from zebra.signals import *
from django.views.decorators.csrf import csrf_exempt

import logging
log = logging.getLogger("zebra.%s" % __name__)

stripe.api_key = options.STRIPE_SECRET

def _try_to_get_customer_from_customer_id(stripe_customer_id):
    if options.ZEBRA_CUSTOMER_MODEL:
        m = get_model(*options.ZEBRA_CUSTOMER_MODEL.split('.'))
        try:
            return m.objects.get(stripe_customer_id=stripe_customer_id)
        except:
            pass
    return None

@csrf_exempt
def webhooks(request):
    """
    Handles all known webhooks from stripe, and calls signals.
    Plug in as you need.
    """

    if request.method != "POST":
        return HttpResponse("Invalid Request.", status=400)

    json = simplejson.loads(request.POST["json"])

    if json["event"] == "recurring_payment_failed":
        zebra_webhook_recurring_payment_failed.send(sender=None, customer=_try_to_get_customer_from_customer_id(json["customer"]), full_json=json)

    elif json["event"] == "invoice_ready":
        zebra_webhook_invoice_ready.send(sender=None, customer=_try_to_get_customer_from_customer_id(json["customer"]), full_json=json)

    elif json["event"] == "recurring_payment_succeeded":
        zebra_webhook_recurring_payment_succeeded.send(sender=None, customer=_try_to_get_customer_from_customer_id(json["customer"]), full_json=json)

    elif json["event"] == "subscription_trial_ending":
        zebra_webhook_subscription_trial_ending.send(sender=None, customer=_try_to_get_customer_from_customer_id(json["customer"]), full_json=json)

    elif json["event"] == "subscription_final_payment_attempt_failed":
        zebra_webhook_subscription_final_payment_attempt_failed.send(sender=None, customer=_try_to_get_customer_from_customer_id(json["customer"]), full_json=json)

    elif json["event"] == "ping":
        zebra_webhook_subscription_ping_sent.send(sender=None)

    else:
        return HttpResponse(status=400)

    return HttpResponse(status=200)

@csrf_exempt
def webhooks_v2(request):
    """
    Handles all known webhooks from stripe, and calls signals.
    Plug in as you need.
    """
    if request.method != "POST":
        return HttpResponse("Invalid Request.", status=400)

    try:
        event_json = simplejson.loads(request.body)
    except AttributeError:
        # Backwords compatibility
        # Prior to Django 1.4, request.body was named request.raw_post_data
        event_json = simplejson.loads(request.raw_post_data)
    event_key = event_json['type'].replace('.', '_')

    if event_key in WEBHOOK_MAP:
        WEBHOOK_MAP[event_key].send(sender=None, full_json=event_json)

    return HttpResponse(status=200)

########NEW FILE########
__FILENAME__ = widgets
from django.forms.widgets import Select, TextInput
from django.utils.safestring import mark_safe


class NoNameWidget(object):

    def _update_to_noname_class_name(self, name, kwargs_dict):
        if "attrs" in kwargs_dict:
            if "class" in kwargs_dict["attrs"]:
                kwargs_dict["attrs"]["class"] += " %s" % (name.replace("_", "-"), )
            else:
                kwargs_dict["attrs"].update({'class': name.replace("_", "-")})
        else:
            kwargs_dict["attrs"] = {'class': name.replace("_", "-")}

        return kwargs_dict

    def _strip_name_attr(self, widget_string, name):
        return widget_string.replace("name=\"%s\"" % (name,), "")

    class Media:
        css = {
            'all': ('zebra/card-form.css',)
        }
        js = ('zebra/card-form.js', 'https://js.stripe.com/v1/')



class NoNameTextInput(TextInput, NoNameWidget):

    def render(self, name, *args, **kwargs):
        kwargs = self._update_to_noname_class_name(name, kwargs)
        return mark_safe(self._strip_name_attr(super(NoNameTextInput, self).render(name, *args, **kwargs), name))


class NoNameSelect(Select, NoNameWidget):

    def render(self, name, *args, **kwargs):
        kwargs = self._update_to_noname_class_name(name, kwargs)
        return mark_safe(self._strip_name_attr(super(NoNameSelect, self).render(name, *args, **kwargs), name))

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
from django.core.management import execute_manager
import imp
try:
    imp.find_module('settings') # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n" % __file__)
    sys.exit(1)

import settings

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = models
from django.db import models

# Create your models here.

########NEW FILE########
__FILENAME__ = tests
import unittest
from django.conf import settings
from django.test.client import Client
from zebra.signals import *
from django.utils import simplejson


from django.core.urlresolvers import reverse

class TestWebhooks(unittest.TestCase):

    def setUp(self):
        self.signal_kwargs = None

    def _signal_reciever(self, **kwargs):
        self.signal_kwargs = kwargs

    def _customized_signal_reciever(self, **kwargs):
        self.customer = kwargs["customer"]
        self.full_json = kwargs["full_json"]

    def test_recurring_payment_failed_signal_fired(self):
        zebra_webhook_recurring_payment_failed.connect(self._signal_reciever)

        self.assertEqual(self.signal_kwargs, None)

        # Pulled directly from the stripe docs
        test_post_data = {'json': simplejson.dumps({
          "customer":1083,
          "livemode": True,
          "event": "recurring_payment_failed",
          "attempt": 2,
          "invoice": {
            "attempted": True,
            "charge": "ch_sUmNHkMiag",
            "closed": False,
            "customer": "1083",
            "date": 1305525584,
            "id": "in_jN6A1g8N76",
            "object": "invoice",
            "paid": True,
            "period_end": 1305525584,
            "period_start": 1305525584,
            "subtotal": 2000,
            "total": 2000,
            "lines": {
              "subscriptions": [
                {
                  "period": {
                    "start": 1305525584,
                    "end": 1308203984
                  },
                  "plan": {
                    "object": "plan",
                    "name": "Premium plan",
                    "id": "premium",
                    "interval": "month",
                    "amount": 2000
                  },
                  "amount": 2000
                }
              ]
            }
          },
          "payment": {
            "time": 1297887533,
            "card": {
              "type": "Visa",
              "last4": "4242"
            },
            "success": False
          }
        }) }

        c = Client()
        response = c.post(reverse("zebra:webhooks"), test_post_data)

        self.assertEqual(response.status_code, 200)
        self.assertEqual(self.signal_kwargs["full_json"]["customer"], 1083)



    def test_invoice_ready_signal_fired(self):
        zebra_webhook_invoice_ready.connect(self._signal_reciever)

        self.assertEqual(self.signal_kwargs, None)

        # Pulled directly from the stripe docs
        test_post_data = {'json': simplejson.dumps(
        {
          "customer":1083,
          "event":"invoice_ready",
          "invoice": {
            "total": 1500,
            "subtotal": 3000,
            "lines": {
              "invoiceitems": [
                {
                  "id": "ii_N17xcRJUtn",
                  "amount": 1000,
                  "date": 1303586118,
                  "currency": "usd",
                  "description": "One-time setup fee"
                }
              ],
              "subscriptions": [
                {
                  "amount": 2000,
                  "period": {
                    "start": 1304588585,
                    "end": 1307266985
                  },
                  "plan": {
                    "amount": 2000,
                    "interval": "month",
                    "object": "plan",
                    "id": "p_Mr2NgWECmJ",
                    "id": "premium"
                  }
                }
              ]
            },
            "object": "invoice",
            "discount": {
              "code": "50OFF",
              "percent_off": 50
            },
            "date": 1304588585,
            "period_start": 1304588585,
            "id": "in_jN6A1g8N76",
            "period_end": 1304588585
          }
        }
        ) }

        c = Client()
        response = c.post(reverse("zebra:webhooks"), test_post_data)

        self.assertEqual(response.status_code, 200)
        self.assertEqual(self.signal_kwargs["full_json"]["invoice"]["date"], 1304588585)

      
 

    def test_recurring_payment_succeeded_signal_fired(self):
        zebra_webhook_recurring_payment_succeeded.connect(self._signal_reciever)

        self.assertEqual(self.signal_kwargs, None)

        # Pulled directly from the stripe docs
        test_post_data = {'json': simplejson.dumps(
            {
              "customer":"1083",
              "livemode": True,
              "event":"recurring_payment_succeeded",
              "invoice": {
                "total": 2000,
                "subtotal": 2000,
                "lines": {
                  "subscriptions": [
                  {
                    "amount": 2000,
                    "period": {
                      "start": 1304588585,
                      "end": 1307266985
                    },
                    "plan": {
                      "amount": 2000,
                      "interval": "month",
                      "object": "plan",
                      "id": "premium",
                      "name": "Premium plan"
                    }
                  }
                  ]
                },
                "object": "invoice",
                "date": 1304588585,
                "period_start": 1304588585,
                "id": "in_jN6A1g8N76",
                "period_end": 1304588585
              },
              "payment": {
                "time": 1297887533,
                "card":
                {
                  "type": "Visa",
                  "last4": "4242"
                },
                "success": True
              }
            }        
        ) }

        c = Client()
        response = c.post(reverse("zebra:webhooks"), test_post_data)

        self.assertEqual(response.status_code, 200)
        self.assertEqual(self.signal_kwargs["full_json"]["payment"]["time"], 1297887533)

             

    def test_subscription_trial_ending_signal_fired(self):
        zebra_webhook_subscription_trial_ending.connect(self._signal_reciever)

        self.assertEqual(self.signal_kwargs, None)

        # Pulled directly from the stripe docs
        test_post_data = {'json': simplejson.dumps(
            {
              "customer":1083,
              "event":"subscription_trial_ending",
              "subscription":
              {
                "trial_start": 1304627445,
                "trial_end": 1307305845,
                "plan": {
                  "trial_period_days": 31,
                  "amount": 2999,
                  "interval": "month",
                  "id": "silver",
                  "name": "Silver"
                },
              }
            }      
        ) }

        c = Client()
        response = c.post(reverse("zebra:webhooks"), test_post_data)

        self.assertEqual(response.status_code, 200)
        self.assertEqual(self.signal_kwargs["full_json"]["subscription"]["trial_end"], 1307305845)



    def test_subscription_final_payment_attempt_failed_signal_fired(self):
        zebra_webhook_subscription_final_payment_attempt_failed.connect(self._signal_reciever)

        self.assertEqual(self.signal_kwargs, None)

        # Pulled directly from the stripe docs
        test_post_data = {'json': simplejson.dumps(
            {
              "customer":1083,
              "event":"subscription_final_payment_attempt_failed",
              "subscription": {
                "status": "canceled",
                "start": 1304585542,
                "plan": {
                  "amount": 2000,
                  "interval": "month",
                  "object": "plan",
                  "id": "p_ag2NgWECmJ",
                  "id": "silver"
                },
                "canceled_at": 1304585552,
                "ended_at": 1304585552,
                "object": "subscription",
                "current_period_end": 1307263942,
                "id": "sub_kP4M63kFrb",
                "current_period_start": 1304585542
              }
            } 
        ) }

        c = Client()
        response = c.post(reverse("zebra:webhooks"), test_post_data)

        self.assertEqual(response.status_code, 200)
        self.assertEqual(self.signal_kwargs["full_json"]["subscription"]["start"], 1304585542)


    def test_webhooks_return_valid_customer_obj(self):
        zebra_webhook_subscription_trial_ending.connect(self._signal_reciever)

        from zebra.models import Customer
        cust = Customer.objects.create()
        
        # since ZEBRA_AUTO_CREATE_STRIPE_CUSTOMERS is on (default), this creates a customer
        cust.stripe_customer

        self.assertEqual(self.signal_kwargs, None)

        # Pulled directly from the stripe docs
        test_post_data = {'json': simplejson.dumps(
            {
              "customer":cust.stripe_customer_id,
              "event":"subscription_trial_ending",
              "subscription":
              {
                "trial_start": 1304627445,
                "trial_end": 1307305845,
                "plan": {
                  "trial_period_days": 31,
                  "amount": 2999,
                  "interval": "month",
                  "id": "silver",
                  "name": "Silver"
                },
              }
            }      
        ) }

        c = Client()
        response = c.post(reverse("zebra:webhooks"), test_post_data)

        self.assertEqual(response.status_code, 200)
        self.assertEqual(self.signal_kwargs["customer"], cust)

    def test_webhooks_return_valid_customer_obj_as_an_arg(self):
        zebra_webhook_subscription_trial_ending.connect(self._customized_signal_reciever)

        from zebra.models import Customer
        cust = Customer.objects.create()
        
        # since ZEBRA_AUTO_CREATE_STRIPE_CUSTOMERS is on (default), this creates a customer
        cust.stripe_customer

        self.assertEqual(self.signal_kwargs, None)

        # Pulled directly from the stripe docs
        test_post_data = {'json': simplejson.dumps(
            {
              "customer":cust.stripe_customer_id,
              "event":"subscription_trial_ending",
              "subscription":
              {
                "trial_start": 1304627445,
                "trial_end": 1307305845,
                "plan": {
                  "trial_period_days": 31,
                  "amount": 2999,
                  "interval": "month",
                  "id": "silver",
                  "name": "Silver"
                },
              }
            }      
        ) }

        c = Client()
        response = c.post(reverse("zebra:webhooks"), test_post_data)

        self.assertEqual(response.status_code, 200)
        self.assertEqual(self.customer, cust)

      
 

    def test_ping_webhook_signal_fired(self):
        zebra_webhook_subscription_ping_sent.connect(self._signal_reciever)

        self.assertEqual(self.signal_kwargs, None)

        # Pulled directly from the stripe docs
        test_post_data = {'json': simplejson.dumps(
            {
              "event":"ping",
            }        
        ) }

        c = Client()
        response = c.post(reverse("zebra:webhooks"), test_post_data)

        self.assertEqual(response.status_code, 200)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *
from marty import views

urlpatterns = patterns('',          
    url(r'update$',     views.update,          name='update'),
)

########NEW FILE########
__FILENAME__ = views

from django.http import HttpResponseRedirect
from django.shortcuts import render_to_response, redirect
from django.template import RequestContext
from django.http import HttpResponse
from django.utils import simplejson
from zebra.conf import options

import stripe
stripe.api_key = options.STRIPE_SECRET

from zebra.forms import StripePaymentForm


# In a real implementation, do login required, etc.
def update(request):
    user = request.user
    success_updating = False

    if request.method == 'POST':
        zebra_form = StripePaymentForm(request.POST)
        if zebra_form.is_valid():

            customer = stripe.Customer.retrieve(user.stripe_id)
            customer.card = zebra_form.cleaned_data['stripe_token']
            customer.save()

            profile = user.get_profile()
            profile.last_4_digits = zebra_form.cleaned_data['last_4_digits']
            profile.stripe_customer_id = customer.id
            profile.save()

            success_updating = True

    else:
        zebra_form = StripePaymentForm()

    return render_to_response('marty/basic_update.html',
        {
          'zebra_form': zebra_form,
          'publishable': options.STRIPE_PUBLISHABLE,
          'success_updating': success_updating,
        },
        context_instance=RequestContext(request)
    )

########NEW FILE########
__FILENAME__ = settings
# Django settings for zebra_sample_project project.

# Custom path to include zebra from this repo, intstead of pip installing itself.
import sys
from os.path import abspath, dirname, join
sys.path.insert(0, join(abspath(dirname(__file__)), "../"))


DEBUG = True
TEMPLATE_DEBUG = DEBUG

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3', # Add 'postgresql_psycopg2', 'postgresql', 'mysql', 'sqlite3' or 'oracle'.
        'NAME': 'zebra_sample.db',                      # Or path to database file if using sqlite3.
    }
}

TIME_ZONE = None
LANGUAGE_CODE = 'en-us'
SITE_ID = 1
USE_I18N = True
USE_L10N = True
MEDIA_ROOT = ''
MEDIA_URL = ''
STATIC_ROOT = ''
STATIC_URL = '/static/'
ADMIN_MEDIA_PREFIX = '/static/admin/'

STATICFILES_DIRS = (
    # Put strings here, like "/home/html/static" or "C:/www/django/static".
)
STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
)

# Make this unique, and don't share it with anybody.
SECRET_KEY = '1fdl=4jdiaa=x*=x%=%k&y*b@pcw6ir-vw-(&2^y766v1+6=6o'

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
)

ROOT_URLCONF = 'zebra_sample_project.urls'

TEMPLATE_DIRS = (
    # Put strings here, like "/home/html/django_templates" or "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # 'django.contrib.admin',
    # 'django.contrib.admindocs',
    'django_extensions',
    'zebra',
    'marty',
    

)

# A sample logging configuration. The only tangible logging
# performed by this configuration is to send an email to
# the site admins on every HTTP 500 error.
# See http://docs.djangoproject.com/en/dev/topics/logging for
# more details on how to customize your logging configuration.
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'mail_admins': {
            'level': 'ERROR',
            'class': 'django.utils.log.AdminEmailHandler'
        }
    },
    'loggers': {
        'django.request': {
            'handlers': ['mail_admins'],
            'level': 'ERROR',
            'propagate': True,
        },
    }
}



# Zebra Config
ZEBRA_ENABLE_APP = True

# Set these, or include them in an untracked locals.py
STRIPE_PUBLISHABLE = None
STRIPE_SECRET = None

try:
    from locals import *
except:
    pass

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import patterns, include, url

urlpatterns = patterns('',
    url(r'zebra/',   include('zebra.urls',  namespace="zebra",  app_name='zebra') ),
    url(r'',         include('marty.urls',  namespace="marty",  app_name='marty') ),
)

########NEW FILE########
