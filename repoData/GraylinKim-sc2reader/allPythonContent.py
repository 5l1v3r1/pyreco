__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# sc2reader documentation build configuration file, created by
# sphinx-quickstart on Sun May 01 12:39:48 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os
import sc2reader

autodoc_member_order = "bysource"

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.pngmath', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'sc2reader'
copyright = u'2011-2013'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = sc2reader.__version__

# The full version, including alpha/beta/rc tags.
release = sc2reader.__version__

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'nature'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'sc2readerdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'sc2reader.tex', u'sc2reader Documentation',
   u'Graylin Kim', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'sc2reader', u'sc2reader Documentation',
     [u'Graylin Kim'], 1)
]

########NEW FILE########
__FILENAME__ = sc2autosave
#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''sc2autosave is a utility for reorganizing and renaming Starcraft II files.

Overview
==============

sc2autosave provides a simple mechanism for renaming replay files as they are
copied or moved from a source directory to a destination directory. In between
runs the state is stored in the sc2autosave.dat file saved to the destination
folder. In this way, multiple destination folders with different organizations
and formats can be maintained independently.

General Operation
-------------------

When first run for a given destination directory, sc2autosave scans for all
files since the epoch. Each subsequent run scans only for files new files
since the previous scan time. This behavior can be modified on a run by run
basis by with the --since DATETIME option. By default the source directory
is scanned recursively. The --depth DEPTH option can limit and/or eliminate
this is recursion.

Files identified as new are then copied to the destination directory. The
--move option can override this behavior. The default behavior is a good idea
because it ensures that there is a backup copy and allows for several different
file structures to be constructed with different sc2autosave configurations for
easy replay navigation. You might keep your replay files redundantly stored
sorted by format, by map, and by matchup for easy lookup later on.

While normally run as a batch process, the --period SECONDS option can be used
to run sc2autosave as a background process, scanning the directory for changes
every SECONDS seconds. This is useful for creating background processes on
operating system start up.

Renaming Replays
--------------------

The --rename option allows you to specify a renaming format string. The string
is constructed the pythonic (3.0) way with {:field} indicating the substition
of a field. The forward slash (/) is a special character here which terminates
a folder name and allows for organization into subdirectories. All other string
characters form the template into which the fields are inserted.

Fields related to dates and times (:date, :datetime, :length fields) can be
formatted through their respective directives (--date, --datetime, --length)
according to python date formatting conventions. Additionally, the player
display format can be refined with the --player-format FORMAT directive which
is interpreted similarly to the --rename FORMAT directive detailed above.

Once content has been defined to your tastes you may wish to get specific about
the ordering of the teams and players on those teams in the replay name. The
--team-order-by and --player-order-by directives can be used for this purpose.
A common preference is to favor specific players (like yourself and friends)
and their teams in the ordering by placing them first in the listing. The
--favor PLAYER1 [PLAYER2] directive supports this preference.

Filtering Replays
---------------------

Once a replay has been scanned and parsed you have an opportunity to filter it
for inclusion in the destination directory. This is useful when constructing
various different types of replay packs for distribution and review. Replays
are small and Battle.net has a terrible filesystem based replay locator; why
not make your life easier with a little duplication.

--filter-players PLAYER [PLAYER ...]
--filter-matchup MATCHUP [MATCHUP ...]
--filter-map NAME [NAME ...]
--filter-length LOW HIGH
--filter-date START END

Example Configurations
------------------------

This first basic configuration sets up a background process to copy new replays
without renaming to a 'Saved' subdirectory every 10 seconds. The depth 0 option
keeps the script from looking into the 'Saved' subdirectory.

    sc2autosave                                                             \
        --source ~/My\ Documents/Starcraft\ II/Accounts/.../Mutliplayer     \
        --dest ~/My\ Documents/Starcraft\ II/Accounts/.../Multiplater/Saved \
        --period 10                                                         \
        --depth 0

This next configuration runs in batch mode using the default renaming format.

    sc2autosave                                                             \
        --source ~/My\ Documents/Starcraft\ II/Accounts/.../Mutliplayer     \
        --dest ~/My\ Documents/Starcraft\ II/Accounts/.../Multiplater/Saved \
        --rename

    (ZvP) Lost Temple: ShadesofGray(Z) vs Trisfall(P).SC2Replay
    (ZZvPP) Shattered Temple: ShadesofGray(Z), Remedy(Z) vs ProfProbe(P), Trisfall(P).SC2Replay

Here is a heavily customized format that organizes replays into subdirectories
by replay format and favors ShadesofGray in the player and team orderings.

    sc2autosave                                                             \
        --source ~/My\ Documents/Starcraft\ II/Accounts/.../Mutliplayer     \
        --dest ~/My\ Documents/Starcraft\ II/Accounts/.../Multiplater/Saved \
        --rename "{:format}/{:matchup} on {:map}: {:teams}"                 \
        --player-format "{:name}({:play_race})"                             \
        --team-order-by number                                              \
        --player-order-by name                                              \
        --favored ShadesofGray

    1v1/ZvP on Lost Temple: ShadesofGray(Z) vs Trisfall(P).SC2Replay
    2v2/ZZvPP on Shattered Temple: ShadesofGray(Z), Remedy(Z) vs ProfProbe(P), Trisfall(P).SC2Replay

Next is another customized format which organizes replays by matchup. It uses
strict player and team ordering by number with no exceptions and formats game
length to show both minutes and seconds.

    sc2autosave                                                             \
        --source ~/My\ Documents/Starcraft\ II/Accounts/.../Mutliplayer     \
        --dest ~/My\ Documents/Starcraft\ II/Accounts/.../Multiplater/Saved \
        --rename "{:matchup}/({:length}) {:map}: {:teams}"                  \
        --player-format "{:name}({:play_race})"                             \
        --team-order-by number                                              \
        --player-order-by number                                            \
        --length "%M:%S"

    PvZ/(20:14) Lost Temple: Trisfall(P) vs ShadesofGray(Z).SC2Replay
    ZZvPP/(35:40) Shattered Temple: Remedy(Z), ShadesofGray(Z) vs Trisfall(P), ProfProbe(P).SC2Replay

Complete Reference Guide
---------------------------

    --source SOURCE_FOLDER
        The source folder to scan for replays. Uses recursive scan by default.
    --dest DESTINATION_FOLDER
        The destination folder to place replays into.
    --depth DEPTH
        Allows recursion to be limited and/or disabled (with DEPTH=0).
    --period SECONDS
        Puts sc2autosave into continuous mode, scanning the directory for new
        files every SECONDS seconds.
    --rename FORMAT
        :map - Inserts the map name.
        :date - Inserts a string formated datetime object using --date-format.
        :length - Inserts a string formatted time object using --length-format.
        :teams - Inserts a comma separated player list. Teams are separated
            with a ' vs ' string. Format the player with --player-format.
        :format - Inserts the map format (1v1, 2v2, 3v3, etc)
        :matchup - Inserts the matchup (ZvZ, PTvTZ, etc). The matchup is
            in team order with races ordered alphabetically; not by player!
            This makes matchups more consistent and useful for sorting.

    --length-format FORMAT
    --player-format FORMAT
    --date-format   FORMAT

    --team-order-by   FIELD
    --player-order-by FIELD
    --favored NAME [NAME,...]


POST-Parse filtering vs preparse filtering?
POST-Parse, how to do it?!?!?!?!
'''
import argparse
import cPickle
import os
import shutil
import sys
import time

import sc2reader


def run(args):
    #Reset wipes the destination clean so we can start over.
    if args.reset:
        reset(args)

    #Set up validates the destination and source directories.
    #It also loads the previous state or creates one as necessary.
    state = setup(args)

    #We break out of this loop in batch mode and on KeyboardInterrupt
    while True:

        #The file scan uses the arguments and the state to filter down to
        #only new (since the last sync time) files.
        for path in scan(args, state):
            try:
                #Read the file and expose useful aspects for renaming/filtering
                replay = sc2reader.load_replay(path, load_level=2)
            except KeyboardInterrupt:
                raise
            except:
                #Failure to parse
                file_name = os.path.basename(path)
                directory = make_directory(args, ('parse_error',))
                new_path = os.path.join(directory, file_name)
                source_path = path[len(args.source):]
                args.log.write("Error parsing replay: {0}".format(source_path))
                if not args.dryrun:
                    args.action.run(path, new_path)

                #Skip to the next replay
                continue

            aspects = generate_aspects(args, replay)

            #Use the filter args to select files based on replay attributes
            if filter_out_replay(args, replay):
                continue

            #Apply the aspects to the rename formatting.
            #'/' is a special character for creation of subdirectories.
            #TODO: Handle duplicate replay names, its possible..
            path_parts = args.rename.format(**aspects).split('/')
            filename = path_parts.pop()+'.SC2Replay'

            #Construct the directory and file paths; create needed directories
            directory = make_directory(args, path_parts)
            new_path = os.path.join(directory, filename)

            #Find the source relative to the source directory for reporting
            dest_path = new_path[len(args.dest):]
            source_path = path[len(args.source):]

            #Log the action and run it if we are live
            msg = "{0}:\n\tSource: {1}\n\tDest: {2}\n"
            args.log.write(msg.format(args.action.type, source_path, dest_path))
            if not args.dryrun:
                args.action.run(path, new_path)

        #After every batch completes, save the state and flush the log
        #TODO: modify the state to include a list of remaining files
        args.log.flush()
        save_state(state, args)

        #We only run once in batch mode!
        if args.mode == 'BATCH':
            break

        #Since new replays come in fairly infrequently, reduce system load
        #by sleeping for an acceptable response time before the next scan.
        time.sleep(args.period)

    args.log.write('Batch Completed')


def filter_out_replay(args, replay):
    player_names = set([player.name for player in replay.players])
    filter_out_player = not set(args.filter_player) & player_names

    if args.filter_rule == 'ALLOW':
        return filter_out_player
    else:
        return not filter_out_player


# We need to create these compare functions at runtime because the ordering
# hinges on the --favored PLAYER options passed in from the command line.
def create_compare_funcs(args):
    favored_set = set(name.lower() for name in args.favored)

    def player_compare(player1, player2):
        # Normalize the player names and generate our key metrics
        player1_name = player1.name.lower()
        player2_name = player2.name.lower()
        player1_favored = (player1_name in favored_set)
        player2_favored = (player2_name in favored_set)

        # The favored player always comes first in the ordering
        if player1_favored and not player2_favored:
            return -1
        elif player2_favored and not player1_favored:
            return 1

        # The most favored person will always be listed first
        elif player1_favored and player2_favored:
            player1_index = args.favored.index(player1_name)
            player2_index = args.favored.index(player2_name)
            return player1_index - player2_index

        # If neither is favored, we'll order by number for now
        # TODO: Allow command line specification of other orderings (maybe?)
        else:
            return player1.pid-player2.pid

    def team_compare(team1, team2):
        # Normalize the team name lists and generate our key metrics
        team1_names = set(p.name.lower() for p in team1.players)
        team2_names = set(p.name.lower() for p in team2.players)
        team1_favored = team1_names & favored_set
        team2_favored = team2_names & favored_set

        # The team with the favored players will always be listed first
        if team1_favored and not team2_favored:
            return -1
        elif team2_favored and not team1_favored:
            return 1

        # The team with the most favored person will always come first
        elif team1_favored and team2_favored:
            team1_best = sorted(args.favored.index(n) for n in team1_favored)
            team2_best = sorted(args.favored.index(n) for n in team2_favored)
            return team1_best[-1] - team2_best[-1]

        # If neither is favored, we'll order by number for now
        # TODO: Allow command line specification of other orderings (maybe?)
        else:
            return team1.number-team2.number

    return team_compare, player_compare


def generate_aspects(args, replay):
    teams = sorted(replay.teams, args.team_compare)
    matchups, team_strings = list(), list()
    for team in teams:
        team.players = sorted(team.players, args.player_compare)
        composition = sorted(p.play_race[0].upper() for p in team.players)
        matchups.append(''.join(composition))
        string = ', '.join(p.format(args.player_format) for p in team.players)
        team_strings.append(string)

    return sc2reader.utils.AttributeDict(
        result=teams[0].result,
        length=replay.length,
        map=replay.map,
        type=replay.type,
        date=replay.date.strftime(args.date_format),
        matchup='v'.join(matchups),
        teams=' vs '.join(team_strings)
    )


def make_directory(args, path_parts):
    directory = args.dest
    for part in path_parts:
        directory = os.path.join(directory, part)
        if not os.path.exists(directory):
            args.log.write('Creating subfolder: {0}\n'.format(directory))
            if not args.dryrun:
                os.mkdir(directory)
        elif not os.path.isdir(directory):
            exit('Cannot create subfolder. Path is occupied: {0}', directory)

    return directory


def scan(args, state):
    args.log.write("SCANNING: {0}\n".format(args.source))
    files = sc2reader.utils.get_files(
        path=args.source,
        regex=args.exclude_files,
        allow=False,
        exclude=args.exclude_dirs,
        depth=args.depth,
        followlinks=args.follow_links)
    return filter(lambda f: os.path.getctime(f) > state.last_sync, files)


def exit(msg, *args, **kwargs):
    sys.exit(msg.format(*args, **kwargs)+"\n\nScript Aborted.")


def reset(args):
    if not os.path.exists(args.dest):
        exit("Cannot reset, destination does not exist: {0}", args.dest)
    elif not os.path.isdir(args.dest):
        exit("Cannot reset, destination must be directory: {0}", args.dest)

    print 'About to reset directory: {0}\nAll files and subdirectories will be removed.'.format(args.dest)
    choice = raw_input('Proceed anyway? (y/n) ')
    if choice.lower() == 'y':
        args.log.write('Removing old directory: {0}\n'.format(args.dest))
        if not args.dryrun:
            print args.dest
            shutil.rmtree(args.dest)
    else:
        sys.exit("Script Aborted")


def setup(args):
    args.team_compare, args.player_compare = create_compare_funcs(args)
    args.action = sc2reader.utils.AttributeDict(type=args.action, run=shutil.copy if args.action == 'COPY' else shutil.move)
    if not os.path.exists(args.source):
        msg = 'Source does not exist: {0}.\n\nScript Aborted.'
        sys.exit(msg.format(args.source))
    elif not os.path.isdir(args.source):
        msg = 'Source is not a directory: {0}.\n\nScript Aborted.'
        sys.exit(msg.format(args.source))

    if not os.path.exists(args.dest):
        if not args.dryrun:
            os.mkdir(args.dest)
        else:
            args.log.write('Creating destination: {0}\n'.format(args.dest))
    elif not os.path.isdir(args.dest):
        sys.exit('Destination must be a directory.\n\nScript Aborted')

    data_file = os.path.join(args.dest, 'sc2autosave.dat')

    args.log.write('Loading state from file: {0}\n'.format(data_file))
    if os.path.isfile(data_file) and not args.reset:
        with open(data_file) as file:
            return cPickle.load(file)
    else:
        return sc2reader.utils.AttributeDict(last_sync=0)


def save_state(state, args):
    state.last_sync = time.time()
    data_file = os.path.join(args.dest, 'sc2autosave.dat')
    if not args.dryrun:
        with open(data_file, 'w') as file:
            cPickle.dump(state, file)
    else:
        args.log.write('Writing state to file: {0}\n'.format(data_file))


def main():
    parser = argparse.ArgumentParser(
        description='Automatically copy new replays to directory',
        fromfile_prefix_chars='@',
        formatter_class=sc2reader.scripts.utils.Formatter.new(max_help_position=35),
        epilog="And that's all folks")

    required = parser.add_argument_group('Required Arguments')
    required.add_argument('source', type=str,
        help='The source directory to poll')
    required.add_argument('dest', type=str,
        help='The destination directory to copy to')

    general = parser.add_argument_group('General Options')
    general.add_argument('--mode', dest='mode',
        type=str, choices=['BATCH', 'CYCLE'], default='BATCH',
        help='The operating mode for the organizer')

    general.add_argument('--action', dest='action',
        choices=['COPY', 'MOVE'], default="COPY", type=str,
        help='Have the organizer move your files instead of copying')
    general.add_argument('--period',
        dest='period', type=int, default=0,
        help='The period of time to wait between scans.')
    general.add_argument('--log', dest='log', metavar='LOGFILE',
        type=argparse.FileType('w'), default=sys.stdout,
        help='Destination file for log information')
    general.add_argument('--dryrun',
        dest='dryrun', action="store_true",
        help="Don't do anything. Only simulate the output")
    general.add_argument('--reset',
        dest='reset', action='store_true', default=False,
        help='Wipe the destination directory clean and start over.')

    fileargs = parser.add_argument_group('File Options')
    fileargs.add_argument('--depth',
        dest='depth', type=int, default=-1,
        help='Maximum recussion depth. -1 (default) is unlimited.')
    fileargs.add_argument('--exclude-dirs', dest='exclude_dirs',
        type=str, metavar='NAME', nargs='+', default=[],
        help='A list of directory names to exclude during recursion')
    fileargs.add_argument('--exclude-files', dest='exclude_files',
        type=str, metavar='REGEX', default="",
        help='An expression to match excluded files')
    fileargs.add_argument('--follow-links',
        dest='follow_links', action="store_true", default=False,
        help="Enable following of symbolic links while scanning")

    renaming = parser.add_argument_group('Renaming Options')
    renaming.add_argument('--rename',
        dest='rename', type=str, metavar='FORMAT', nargs='?',
        default="{length} {type} on {map}",
        help='''\
            The renaming format string. can have the following values:

                * {length} - The length of the replay ([H:]MM:SS)
                * {type} - The type of the replay (1v1,2v2,4v4,etc)
                * {map} - The map that was played on.
                * {match} - Race matchup in team order, alphabetically by race.
                * {date} - The date the replay was played on
                * {teams} - The player line up
        ''')

    renaming.add_argument('--length-format',
        dest='length_format', type=str, metavar='FORMAT', default='%M.%S',
        help='The length format string. See the python time module for details')
    renaming.add_argument('--player-format',
        dest='player_format', type=str, metavar='FORMAT', default='{name} ({play_race})',
        help='The player format string used to render the :teams content item.')
    renaming.add_argument('--date-format',
        dest='date_format', type=str, metavar='FORMAT', default='%m-%d-%Y',
        help='The date format string used to render the :date content item.')
    '''
    renaming.add_argument('--team-order-by',
        dest='team_order', type=str, metavar='FIELD', default='NUMBER',
        help='The field by which teams are ordered.')
    renaming.add_argument('--player-order-by',
        dest='player_order', type=str, metavar='FIELD', default='NAME',
        help='The field by which players are ordered on teams.')
    '''
    renaming.add_argument('--favored', dest='favored',
        type=str, default=[], metavar='NAME', nargs='+',
        help='A list of the players to favor in ordering teams and players')

    filterargs = parser.add_argument_group('Filtering Options')
    filterargs.add_argument('--filter-rule', dest='filter_rule',
        choices=["ALLOW","DENY"],
        help="The filters can either be used as a white list or a black list")
    filterargs.add_argument('--filter-player', metavar='NAME',
        dest='filter_player', nargs='+', type=str, default=[],
        help="A list of players to filter on")

    try:
        run(parser.parse_args())
    except KeyboardInterrupt:
        print "\n\nScript Interupted. Process Aborting"

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = sc2store
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import cPickle
import os
import shutil
import sys
import sqlite3
import time

import sc2reader

from pprint import PrettyPrinter
pprint = PrettyPrinter(indent=2).pprint

from sqlalchemy import create_engine
from sqlalchemy import Column, ForeignKey, distinct, Table
from sqlalchemy import Integer, String, Sequence, DateTime
from sqlalchemy.orm import relationship, sessionmaker

from sqlalchemy.orm.exc import NoResultFound

from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.ext.associationproxy import association_proxy
Base = declarative_base()

party_member = Table('party_member', Base.metadata,
    Column('person_id', Integer, ForeignKey('person.id')),
    Column('party_id', Integer, ForeignKey('party.id')),
)

class Person(Base):
    __tablename__ = 'person'
    id = Column(Integer, Sequence('person_id_seq'), primary_key=True)

    name = Column(String(50))
    url = Column(String(50))
    parties = relationship('Party', secondary=party_member)
    players = relationship('Player')


class Party(Base):
    __tablename__ = 'party'
    id = Column(Integer, Sequence('party_id_seq'), primary_key=True)

    player_names = Column(String(255))

    members = relationship('Person', secondary=party_member)
    teams = relationship('Team')

    def __init__(self, *players):
        self.player_names = ''
        self.members = list()
        self.add_players(*players)

    def add_players(self, *players):
        for player in players:
            self.player_names += '['+player.name+']'
            self.members.append(player.person)

    @classmethod
    def make_player_names(self, players):
        return ''.join(sorted('['+player.name+']' for player in players))


class Game(Base):
    __tablename__ = 'game'
    id = Column(Integer, Sequence('game_id_seq'), primary_key=True)

    map = Column(String(255))
    file_name = Column(String(255))
    datetime = Column(DateTime)
    category = Column(String(50))
    type = Column(String(20))
    matchup = Column(String(100))
    length = Column(Integer)
    build = Column(String(25))
    release_string = Column(String(50))

    teams = relationship('Team')
    players = relationship('Player')

    def __init__(self, replay, db):
        self.map = replay.map
        self.file_name = replay.filename
        self.type = replay.type
        self.datetime = replay.date
        self.category = replay.category
        self.length = replay.length.seconds
        self.winner_known = replay.winner_known
        self.build = replay.build
        self.release_string = replay.release_string
        self.teams = [Team(team,db) for team in replay.teams]
        self.matchup = 'v'.join(sorted(team.lineup for team in self.teams))
        self.players = sum((team.players for team in self.teams), [])


class Team(Base):
    __tablename__ = 'team'
    id = Column(Integer, Sequence('team_id_seq'), primary_key=True)
    game_id = Column(Integer, ForeignKey('game.id'))
    party_id = Column(Integer, ForeignKey('party.id'))

    result = Column(String(50))
    number = Column(Integer)
    lineup = Column(String(10))

    players = relationship('Player')
    party = relationship('Party')
    game = relationship('Game')

    def __init__(self, team, db):
        self.number = team.number
        self.result = team.result
        self.players = [Player(player,db) for player in team.players]
        self.lineup = ''.join(sorted(player.play_race[0].upper() for player in self.players))

        try:
            player_names = Party.make_player_names(self.players)
            self.party = db.query(Party).filter(Party.player_names == player_names).one()
        except NoResultFound as e:
            self.party = Party(*self.players)


class Player(Base):
    __tablename__ = 'player'
    id = Column(Integer, Sequence('player_id_seq'), primary_key=True)
    game_id = Column(Integer, ForeignKey('game.id'))
    team_id = Column(Integer, ForeignKey('team.id'))
    person_id = Column(Integer, ForeignKey('person.id'))

    play_race = Column(String(20))
    pick_race = Column(String(20))
    color_str = Column(String(20))
    color_hex = Column(String(20))

    name = association_proxy('person','name')
    person = relationship('Person')
    team = relationship('Team')
    game = relationship('Game')

    def __init__(self, player, db):
        try:
            self.person = db.query(Person).filter(Person.name == player.name).one()
        except NoResultFound as e:
            self.person = Person()
            self.person.name = player.name
            self.person.url = player.url

        self.play_race = player.play_race
        self.pick_race = player.pick_race
        self.color_str = str(player.color)
        self.color_hex = player.color.hex


class Message(Base):
    __tablename__ = 'message'
    id = Column(Integer, Sequence('message_id_seq'), primary_key=True)
    player_id = Column(Integer, ForeignKey('player.id'))


def parse_args():
    import argparse
    parser = argparse.ArgumentParser(description='Stores replay meta data into an SQL database')
    parser.add_argument('--storage', default='sqlite:///:memory:', type=str, help='Path to the sql storage file of choice')
    parser.add_argument('paths', metavar='PATH', type=str, nargs='+', help='Path to a replay file or a folder of replays')
    return parser.parse_args()

def main():
    args = parse_args()
    db = load_session(args)

    for path in args.paths:
        for file_name in sc2reader.utils.get_files(path, depth=0):
            print "CREATING: {0}".format(file_name)
            db.add(Game(sc2reader.read_file(file_name), db))

    db.commit()

    print list(db.query(distinct(Person.name)).all())

    #for row in db.query(distinct(Person.name)).all():
    #    print row


def load_session(args):
    engine = create_engine(args.storage, echo=True)
    Base.metadata.create_all(engine)
    Session = sessionmaker(bind=engine)
    return Session()


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = new_units
# Shows new data entries from the requested build files:
#
# Usage: python new_data.py sc2reader/data/HotS/24764_units.csv sc2reader/data/HotS/24764_abilites.csv
#
# The output from this can be used to update the unit_lookup.csv and ability_lookup.csv files. Maybe the
# script can be fixed to append these lines automatically...
#
import pkgutil
import sys

UNIT_LOOKUP = dict()
for entry in pkgutil.get_data('sc2reader.data', 'unit_lookup.csv').split('\n'):
    if not entry: continue
    str_id, title = entry.strip().split(',')
    UNIT_LOOKUP[str_id] = title

with open(sys.argv[1],'r') as new_units:
	for line in new_units:
		new_unit_name = line.strip().split(',')[1]
		if new_unit_name not in UNIT_LOOKUP:
			print "{0},{1}".format(new_unit_name,new_unit_name)

print
print

ABIL_LOOKUP = dict()
for entry in pkgutil.get_data('sc2reader.data', 'ability_lookup.csv').split('\n'):
    if not entry: continue
    str_id, abilities = entry.split(',',1)
    ABIL_LOOKUP[str_id] = abilities.split(',')

with open(sys.argv[2], 'r') as new_abilities:
	for line in new_abilities:
		new_ability_name = line.strip().split(',')[1]
		if new_ability_name not in ABIL_LOOKUP:
			print "{0},{1}".format(new_ability_name,new_ability_name)

########NEW FILE########
__FILENAME__ = constants
# -*- coding: utf-8 -*-
from __future__ import absolute_import, print_function, unicode_literals, division

# These are found in Repack-MPQ/fileset.{locale}#Mods#Core.SC2Mod#{locale}.SC2Data/LocalizedData/Editor/EditorCategoryStrings.txt
# EDSTR_CATEGORY_Race
# EDSTR_PLAYERPROPS_RACE
# The ??? means that I don't know what language it is.
# If multiple languages use the same set they should be comma separated
LOCALIZED_RACES = {

    # enUS
    'Terran': 'Terran',
    'Protoss': 'Protoss',
    'Zerg': 'Zerg',

    # ruRU
    'Терран': 'Terran',
    'Протосс': 'Protoss',
    'Зерг': 'Zerg',

    # koKR
    '테란': 'Terran',
    '프로토스': 'Protoss',
    '저그': 'Zerg',

    # ??eu
    'Terranie': 'Terran',
    'Protosi': 'Protoss',
    'Zergi': 'Zerg',

    # zhCH
    '人类': 'Terran',
    '星灵': 'Protoss',
    '异虫': 'Zerg',

    # zhTW
    '人類': 'Terran',
    '神族': 'Protoss',
    '蟲族': 'Zerg',

    # ???
    'Terrano': 'Terran',

    # deDE
    'Terraner': 'Terran',

    # esES - Spanish
    # esMX - Latin American
    # frFR - French - France
    # plPL - Polish Polish
    # ptBR - Brazilian Portuguese
}

MESSAGE_CODES = {
    '0': 'All',
    '2': 'Allies',
    '128': 'Header',
    '125': 'Ping',
}


GAME_SPEED_FACTOR = {
    'Slower':   0.6,
    'Slow':     0.8,
    'Normal':   1.0,
    'Fast':     1.2,
    'Faster':   1.4
}

GATEWAY_CODES = {
    'US': 'Americas',
    'KR': 'Asia',
    'EU': 'Europe',
    'SG': 'South East Asia',
    'XX': 'Public Test',
}


GATEWAY_LOOKUP = {
    0: '',
    1: 'us',
    2: 'eu',
    3: 'kr',
    5: 'cn',
    6: 'sea',
    98: 'xx',
}

COLOR_CODES = {
    'B4141E': 'Red',
    '0042FF': 'Blue',
    '1CA7EA': 'Teal',
    'EBE129': 'Yellow',
    '540081': 'Purple',
    'FE8A0E': 'Orange',
    '168000': 'Green',
    'CCA6FC': 'Light Pink',
    '1F01C9': 'Violet',
    '525494': 'Light Grey',
    '106246': 'Dark Green',
    '4E2A04': 'Brown',
    '96FF91': 'Light Green',
    '232323': 'Dark Grey',
    'E55BB0': 'Pink',
    'FFFFFF': 'White',
    '000000': 'Black',
}

COLOR_CODES_INV = dict(zip(COLOR_CODES.values(), COLOR_CODES.keys()))

SUBREGIONS = {
    # United States
    'us': {
        1: 'us',
        2: 'la',
    },

    # Europe
    'eu': {
        1: 'eu',
        2: 'ru',
    },

    # Korea - appear to both map to same place
    'kr': {
        1: 'kr',
        2: 'tw',
    },
    # Taiwan - appear to both map to same place
    'tw': {
        1: 'kr',
        2: 'tw',
    },

    # China - different url scheme (www.battlenet.com.cn)?
    'cn': {
        1: 'cn',
    },

    # South East Asia
    'sea': {
        1: 'sea',
    },

    # Singapore
    'sg': {
        1: 'sg',
    },

    # Public Test
    'xx': {
        1: 'xx',
    },
}


import json
import pkgutil

attributes_json = pkgutil.get_data('sc2reader.data', 'attributes.json').decode('utf8')
attributes_dict = json.loads(attributes_json)
LOBBY_PROPERTIES = dict()
for key, value in attributes_dict.get('attributes', dict()).items():
    LOBBY_PROPERTIES[int(key)] = value

########NEW FILE########
__FILENAME__ = create_lookup
abilities = dict()
with open('hots_abilities.csv', 'r') as f:
    for line in f:
        num, ability = line.strip('\r\n ').split(',')
        abilities[ability] = [""]*32

with open('command_lookup.csv', 'r') as f:
    for line in f:
        ability, commands = line.strip('\r\n ').split('|', 1)
        abilities[ability] = commands.split('|')

with open('new_lookup.csv', 'w') as out:
    for ability, commands in sorted(abilities.items()):
        out.write(','.join([ability]+commands)+'\n')

########NEW FILE########
__FILENAME__ = decoders
# -*- coding: utf-8 -*-
from __future__ import absolute_import, print_function, unicode_literals, division

from io import BytesIO

import struct
import functools

try:
    from collections import OrderedDict
except ImportError as e:
    from ordereddict import OrderedDict


class ByteDecoder(object):
    """
    :param contents: The string or file-like object to decode
    :param endian: Either > or <. Indicates the endian the bytes are stored in.

    Used to unpack parse byte aligned files.
    """

    #: The Bytes object used internaly for reading from the
    #: decoder contents. cStringIO is faster than managing our
    #: own string access in python. For PyPy installations a
    #: managed string implementation might be faster.
    _buffer = None

    #: The string buffer being decoded. A direct reference
    #: is kept around to make read_range and peek faster.
    _contents = ""

    def __init__(self, contents, endian):
        """ Accepts both strings and files implementing ``read()`` and
        decodes them in the specified endian format.
        """
        if hasattr(contents, 'read'):
            self._contents = contents.read()
        else:
            self._contents = contents

        self._buffer = BytesIO(self._contents)
        self.length = len(self._contents)

        # Expose the basic BytesIO interface
        self.read = self._buffer.read
        self.seek = self._buffer.seek
        self.tell = self._buffer.tell

        # decode the endian value if necessary
        self.endian = endian.lower()
        if self.endian.lower() == 'little':
            self.endian = "<"
        elif self.endian.lower() == 'big':
            self.endian = ">"
        elif self.endian not in ('<', '>'):
            raise ValueError("Endian must be one of 'little', '<', 'big', or '>' but was: "+self.endian)

        # Pre-compiling
        self._unpack_int = struct.Struct(str(self.endian+'I')).unpack
        self._unpack_short = struct.Struct(str(self.endian+'H')).unpack
        self._unpack_longlong = struct.Struct(str(self.endian+'Q')).unpack
        self._unpack_bytes = lambda bytes: bytes if self.endian == '>' else bytes[::-1]

    def done(self):
        """ Returns true when all bytes have been decoded """
        return self.tell() == self.length

    def read_range(self, start, end):
        """ Returns the raw byte string from the indicated address range """
        return self._contents[start:end]

    def peek(self, count):
        """ Returns the raw byte string for the next ``count`` bytes """
        start = self.tell()
        return self._contents[start:start+count]

    def read_uint8(self):
        """ Returns the next byte as an unsigned integer """
        return ord(self.read(1))

    def read_uint16(self):
        """ Returns the next two bytes as an unsigned integer """
        return self._unpack_short(self.read(2))[0]

    def read_uint32(self):
        """ Returns the next four bytes as an unsigned integer """
        return self._unpack_int(self.read(4))[0]

    def read_uint64(self):
        """ Returns the next eight bytes as an unsigned integer """
        return self._unpack_longlong(self.read(8))[0]

    def read_bytes(self, count):
        """ Returns the next ``count`` bytes as a byte string """
        return self._unpack_bytes(self.read(count))

    def read_uint(self, count):
        """ Returns the next ``count`` bytes as an unsigned integer """
        unpack = struct.Struct(str(self.endian+'B'*count)).unpack
        uint = 0
        for byte in unpack(self.read(count)):
            uint = uint << 8 | byte
        return uint

    def read_string(self, count, encoding='utf8'):
        """ Read a string in given encoding (default utf8) that is ``count`` bytes long """
        return self.read_bytes(count).decode(encoding)

    def read_cstring(self, encoding='utf8'):
        """ Read a NULL byte terminated character string decoded with given encoding (default utf8). Ignores endian. """
        cstring = BytesIO()
        while True:
            c = self.read(1)
            if ord(c) == 0:
                return cstring.getvalue().decode(encoding)
            else:
                cstring.write(c)


class BitPackedDecoder(object):
    """
    :param contents: The string of file-like object to decode

    Extends :class:`ByteDecoder`. Always packed BIG_ENDIAN

    Adds capabilities for parsing files that Blizzard has packed in
    bits and not in bytes.

    """
    #: The ByteDecoder used internally to read byte
    #: aligned values.
    _buffer = None

    #: Tracks the how many bits have already been used
    #: from the current byte.
    _bit_shift = 0

    #: Holds the byte, if any, that hasn't had its bits
    #: fully used yet.
    _next_byte = None

    #: Maps bit shifts to low bit masks used for grabbing
    #: the first bits off of the next byte.
    _lo_masks = [0x00, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF]

    #: Maps bit shifts to high bit masks used for grabbing
    #: the remaining bits off of the previous byte.
    _hi_masks = [0xFF ^ mask for mask in _lo_masks]

    #: Maps bit shifts to high and low bit masks. Used for
    #: joining bytes when we are not byte aligned.
    _bit_masks = list(zip(_lo_masks, _hi_masks))

    def __init__(self, contents):
        self._buffer = ByteDecoder(contents, endian='BIG')

        # Partially expose the ByteBuffer interface
        self.length = self._buffer.length
        self.tell = self._buffer.tell
        self.peek = self._buffer.peek
        self.read_range = self._buffer.read_range

        # Reduce the number of lookups required to read
        self._read = self._buffer.read
        self.read_bool = functools.partial(self.read_bits, 1)

    def done(self):
        """ Returns true when all bytes in the buffer have been used"""
        return self.tell() == self.length

    def byte_align(self):
        """ Moves cursor to the beginning of the next byte """
        self._next_byte = None
        self._bit_shift = 0

    def read_uint8(self):
        """ Returns the next 8 bits as an unsigned integer """
        data = ord(self._buffer.read(1))

        if self._bit_shift != 0:
            lo_mask, hi_mask = self._bit_masks[self._bit_shift]
            hi_bits = self._next_byte & hi_mask
            lo_bits = data & lo_mask
            self._next_byte = data
            data = hi_bits | lo_bits

        return data

    def read_uint16(self):
        """ Returns the next 16 bits as an unsigned integer """
        data = self._buffer.read_uint16()

        if self._bit_shift != 0:
            lo_mask, hi_mask = self._bit_masks[self._bit_shift]
            hi_bits = (self._next_byte & hi_mask) << 8
            mi_bits = (data & 0xFF00) >> (8-self._bit_shift)
            lo_bits = (data & lo_mask)
            self._next_byte = data & 0xFF
            data = hi_bits | mi_bits | lo_bits

        return data

    def read_uint32(self):
        """ Returns the next 32 bits as an unsigned integer """
        data = self._buffer.read_uint32()

        if self._bit_shift != 0:
            lo_mask, hi_mask = self._bit_masks[self._bit_shift]
            hi_bits = (self._next_byte & hi_mask) << 24
            mi_bits = (data & 0xFFFFFF00) >> (8-self._bit_shift)
            lo_bits = (data & lo_mask)
            self._next_byte = data & 0xFF
            data = hi_bits | mi_bits | lo_bits

        return data

    def read_uint64(self):
        """ Returns the next 64 bits as an unsigned integer """
        data = self._buffer.read_uint64()

        if self._bit_shift != 0:
            lo_mask, hi_mask = self._bit_masks[self._bit_shift]
            hi_bits = (self._next_byte & hi_mask) << 56
            mi_bits = (data & 0xFFFFFFFFFFFFFF00) >> (8-self._bit_shift)
            lo_bits = (data & lo_mask)
            self._next_byte = data & 0xFF
            data = hi_bits | mi_bits | lo_bits

        return data

    def read_vint(self):
        """ Reads a signed integer of variable length """
        byte = ord(self._buffer.read(1))
        negative = byte & 0x01
        result = (byte & 0x7F) >> 1
        bits = 6
        while byte & 0x80:
            byte = self.read_uint8()
            result |= (byte & 0x7F) << bits
            bits += 7
        return -result if negative else result

    def read_aligned_bytes(self, count):
        """ Skips to the beginning of the next byte and returns the next ``count`` bytes as a byte string """
        self.byte_align()
        return self._buffer.read_bytes(count)

    def read_aligned_string(self, count, encoding='utf8'):
        """ Skips to the beginning of the next byte and returns the next ``count`` bytes decoded with encoding (default utf8) """
        self.byte_align()
        return self._buffer.read_string(count, encoding)

    def read_bytes(self, count):
        """ Returns the next ``count*8`` bits as a byte string """
        data = self._buffer.read_bytes(count)

        if self._bit_shift != 0:
            temp_buffer = BytesIO()
            prev_byte = self._next_byte
            lo_mask, hi_mask = self._bit_masks[self._bit_shift]
            for next_byte in struct.unpack(str("B")*count, data):
                temp_buffer.write(struct.pack(str("B"), prev_byte & hi_mask | next_byte & lo_mask))
                prev_byte = next_byte

            self._next_byte = prev_byte
            data = temp_buffer.getvalue()
            temp_buffer.truncate(0)

        return data

    def read_bits(self, count):
        """ Returns the next ``count`` bits as an unsigned integer """
        result = 0
        bits = count
        bit_shift = self._bit_shift

        # If we've got a byte in progress use it first
        if bit_shift != 0:
            bits_left = 8-bit_shift

            if bits_left < bits:
                bits -= bits_left
                result = (self._next_byte >> bit_shift) << bits
            elif bits_left > bits:
                self._bit_shift += bits
                return (self._next_byte >> bit_shift) & self._lo_masks[bits]
            else:
                self._bit_shift = 0
                return self._next_byte >> bit_shift

        # Then grab any additional whole bytes as needed
        if bits >= 8:
            bytes = int(bits/8)

            if bytes == 1:
                bits -= 8
                result |= self._buffer.read_uint8() << bits

            elif bytes == 2:
                bits -= 16
                result |= self._buffer.read_uint16() << bits

            elif bytes == 4:
                bits -= 32
                result |= self._buffer.read_uint32() << bits

            else:
                for byte in struct.unpack(str("B")*bytes, self._read(bytes)):
                    bits -= 8
                    result |= byte << bits

        # Grab any trailing bits from the next byte
        if bits != 0:
            self._next_byte = ord(self._read(1))
            result |= self._next_byte & self._lo_masks[bits]

        self._bit_shift = bits
        return result

    def read_frames(self):
        """ Reads a frame count as an unsigned integer """
        byte = self.read_uint8()
        time, additional_bytes = byte >> 2, byte & 0x03
        if additional_bytes == 0:
            return time
        elif additional_bytes == 1:
            return time << 8 | self.read_uint8()
        elif additional_bytes == 2:
            return time << 16 | self.read_uint16()
        elif additional_bytes == 3:
            return time << 24 | self.read_uint16() << 8 | self.read_uint8()

    def read_struct(self, datatype=None):
        """ Reads a nested data structure. If the type is not specified the
        first byte is used as the type identifier.
        """
        self.byte_align()
        datatype = ord(self._buffer.read(1)) if datatype is None else datatype

        if datatype == 0x00:  # array
            data = [self.read_struct() for i in range(self.read_vint())]

        elif datatype == 0x01:  # bitarray, weird alignment requirements
            bits = self.read_vint()
            data = self.read_bits(bits)

        elif datatype == 0x02:  # blob
            length = self.read_vint()
            data = self._buffer.read_bytes(length)

        elif datatype == 0x03:  # choice
            flag = self.read_vint()
            data = self.read_struct()

        elif datatype == 0x04:  # optional
            exists = self._buffer.read_uint8() != 0
            data = self.read_struct() if exists else None

        elif datatype == 0x05:  # Struct
            entries = self.read_vint()
            data = dict([(self.read_vint(), self.read_struct()) for i in range(entries)])

        elif datatype == 0x06:  # u8
            data = ord(self._buffer.read(1))

        elif datatype == 0x07:  # u32
            data = self._buffer.read_bytes(4)  # self.read_uint32()

        elif datatype == 0x08:  # u64
            data = self._buffer.read_unit64()

        elif datatype == 0x09:  # vint
            data = self.read_vint()

        else:
            raise TypeError("Unknown Data Structure: '{0}'".format(datatype))

        return data

########NEW FILE########
__FILENAME__ = engine
# -*- coding: utf-8 -*-
from __future__ import absolute_import, print_function, unicode_literals, division

import collections
from sc2reader.events import *
from sc2reader.engine.events import InitGameEvent, EndGameEvent, PluginExit


class GameEngine(object):
    """ GameEngine Specification
        --------------------------

        The game engine runs through all the events for a given replay in
        chronological order. For each event, event handlers from registered
        plugins are executed in order of plugin registration from most general
        to most specific.

        Example Usage::

            class Plugin1():
                def handleCommandEvent(self, event, replay):
                    pass

            class Plugin2():
                def handleEvent(self, event, replay):
                    pass

                def handleTargetUnitCommandEvent(self, event, replay):
                    pass

            ...

            engine = GameEngine(plugins=[Plugin1(), Plugin2()], **options)
            engine.register_plugins(Plugin3(), Plugin(4))
            engine.reigster_plugin(Plugin(5))
            engine.run(replay)

        Calls functions in the following order for a ``TargetUnitCommandEvent``::

            Plugin1.handleCommandEvent(event, replay)
            Plugin2.handleEvent(event, replay)
            Plugin2.handleTargetUnitCommandEvent(event, replay)


        Plugin Specification
        -------------------------

        Plugins can opt in to handle events with methods in the format:

            def handleEventName(self, event, replay)

        In addition to handling specific event types, plugins can also
        handle events more generally by handling built-in parent classes
        from the list below::

            * handleEvent - called for every single event of all types
            * handleMessageEvent - called for events in replay.message.events
            * handleGameEvent - called for events in replay.game.events
            * handleTrackerEvent - called for events in replay.tracker.events
            * handleCommandEvent - called for all types of command events
            * handleControlGroupEvent - called for all player control group events

        Plugins may also handle optional ``InitGame`` and ``EndGame`` events generated
        by the GameEngine before and after processing all the events:

          * handleInitGame - is called prior to processing a new replay to provide
            an opportunity for the plugin to clear internal state and set up any
            replay state necessary.

          * handleEndGame - is called after all events have been processed and
            can be used to perform post processing on aggrated data or clean up
            intermediate data caches.

        Event handlers can choose to ``yield`` additional events which will be injected
        into the event stream directly after the event currently being processed. This
        feature allows for message passing between plugins. An ExpansionTracker plugin
        could notify all other plugins of a new ExpansionEvent that they could opt to
        process::

            def handleUnitDoneEvent(self, event, replay):
                if event.unit.name == 'Nexus':
                    yield ExpansionEvent(event.frame, event.unit)
                ....

        If a plugin wishes to stop processing a replay it can yield a PluginExit event before returning::

            def handleEvent(self, event, replay):
                if len(replay.tracker_events) == 0:
                    yield PluginExit(self, code=0, details=dict(msg="tracker events required"))
                    return
                ...

            def handleCommandEvent(self, event, replay):
                try:
                    possibly_throwing_error()
                catch Error as e:
                    logger.error(e)
                    yield PluginExit(self, code=0, details=dict(msg="Unexpected exception"))

        The GameEngine will intercept this event and remove the plugin from the list of
        active plugins for this replay. The exit code and details will be available from the
        replay::

            code, details = replay.plugins['MyPlugin']

        If your plugin depends on another plugin, it is a good idea to implement handlePluginExit
        and be alerted if the plugin that you require fails. This way you can exit gracefully. You
        can also check to see if the plugin name is in ``replay.plugin_failures``::

            if 'RequiredPlugin' in replay.plugin_failures:
                code, details = replay.plugins['RequiredPlugin']
                message = "RequiredPlugin failed with code: {0}. Cannot continue.".format(code)
                yield PluginExit(self, code=1, details=dict(msg=message))
    """
    def __init__(self, plugins=[]):
        self._plugins = list()
        self.register_plugins(*plugins)

    def register_plugin(self, plugin):
        self._plugins.append(plugin)

    def register_plugins(self, *plugins):
        for plugin in plugins:
            self.register_plugin(plugin)

    def run(self, replay):
        # A map of [event.name] => event handlers in plugin registration order
        # ranked from most generic to most specific
        handlers = dict()

        # Create a local copy of the plugins list. As plugins exit we can
        # remove them from this list and regenerate event handlers.
        plugins = list(self._plugins)

        # Create a dict for storing plugin exit codes and details.
        replay.plugin_result = replay.plugins = dict()

        # Create a list storing replay.plugins keys for failures.
        replay.plugin_failures = list()

        # Fill event event queue with the replay events, bookmarked by Init and End events.
        event_queue = collections.deque()
        event_queue.append(InitGameEvent())
        event_queue.extend(replay.events)
        event_queue.append(EndGameEvent())

        # Work through the events in the queue, pushing newly emitted events to
        # the front of the line for immediate processing.
        while len(event_queue) > 0:
            event = event_queue.popleft()

            if event.name == 'PluginExit':
                # Remove the plugin and reset the handlers.
                plugins.remove(event.plugin)
                handlers.clear()
                replay.plugin_result[event.plugin.name] = (event.code, event.details)
                if event.code != 0:
                    replay.plugin_failures.append(event.plugin.name)

            # If we haven't compiled a list of handlers for this event yet, do so!
            if event.name not in handlers:
                event_handlers = self._get_event_handlers(event, plugins)
                handlers[event.name] = event_handlers
            else:
                event_handlers = handlers[event.name]

            # Events have the option of yielding one or more additional events
            # which get processed after the current event finishes. The new_events
            # batch is constructed in reverse order because extendleft reverses
            # the order again with a series of appendlefts.
            new_events = collections.deque()
            for event_handler in event_handlers:
                try:
                    for new_event in (event_handler(event, replay) or []):
                        if new_event.name == 'PluginExit':
                            new_events.append(new_event)
                            break
                        else:
                            new_events.appendleft(new_event)
                except Exception as e:
                    if event_handler.__self__.name in ['ContextLoader']:
                        # Certain built in plugins should probably still cause total failure
                        raise  # Maybe??
                    else:
                        new_event = PluginExit(event_handler.__self__, code=1, details=dict(error=e))
                        new_events.append(new_event)
            event_queue.extendleft(new_events)

        # For any plugins that didn't yield a PluginExit event or throw unexpected exceptions,
        # record a successful completion.
        for plugin in plugins:
            replay.plugin_result[plugin.name] = (0, dict())

    def _get_event_handlers(self, event, plugins):
        return sum([self._get_plugin_event_handlers(plugin, event) for plugin in plugins], [])

    def _get_plugin_event_handlers(self, plugin, event):
        handlers = list()
        if isinstance(event, Event) and hasattr(plugin, 'handleEvent'):
            handlers.append(getattr(plugin, 'handleEvent', None))
        if isinstance(event, MessageEvent) and hasattr(plugin, 'handleMessageEvent'):
            handlers.append(getattr(plugin, 'handleMessageEvent', None))
        if isinstance(event, GameEvent) and hasattr(plugin, 'handleGameEvent'):
            handlers.append(getattr(plugin, 'handleGameEvent', None))
        if isinstance(event, TrackerEvent) and hasattr(plugin, 'handleTrackerEvent'):
            handlers.append(getattr(plugin, 'handleTrackerEvent', None))
        if isinstance(event, CommandEvent) and hasattr(plugin, 'handleCommandEvent'):
            handlers.append(getattr(plugin, 'handleCommandEvent', None))
        if isinstance(event, ControlGroupEvent) and hasattr(plugin, 'handleControlGroupEvent'):
            handlers.append(getattr(plugin, 'handleControlGroupEvent', None))
        if hasattr(plugin, 'handle'+event.name):
            handlers.append(getattr(plugin, 'handle'+event.name, None))
        return handlers

########NEW FILE########
__FILENAME__ = events
# -*- coding: utf-8 -*-
from __future__ import absolute_import, print_function, unicode_literals, division


class InitGameEvent(object):
    name = 'InitGame'


class EndGameEvent(object):
    name = 'EndGame'


class PluginExit(object):
    name = 'PluginExit'

    def __init__(self, plugin, code=0, details=None):
        self.plugin = plugin
        self.code = code
        self.details = details or {}

########NEW FILE########
__FILENAME__ = apm
# -*- coding: utf-8 -*-
from __future__ import absolute_import, print_function, unicode_literals, division

from collections import defaultdict


class APMTracker(object):
    """
    Builds ``player.aps`` and ``player.apm`` dictionaries where an action is
    any Selection, ControlGroup, or Command event.

    Also provides ``player.avg_apm`` which is defined as the sum of all the
    above actions divided by the number of seconds played by the player (not
    necessarily the whole game) multiplied by 60.

    APM is 0 for games under 1 minute in length.
    """
    name = 'APMTracker'

    def handleInitGame(self, event, replay):
        for human in replay.humans:
            human.apm = defaultdict(int)
            human.aps = defaultdict(int)
            human.seconds_played = replay.length.seconds

    def handleControlGroupEvent(self, event, replay):
        event.player.aps[event.second] += 1
        event.player.apm[int(event.second/60)] += 1

    def handleSelectionEvent(self, event, replay):
        event.player.aps[event.second] += 1
        event.player.apm[int(event.second/60)] += 1

    def handleCommandEvent(self, event, replay):
        event.player.aps[event.second] += 1
        event.player.apm[int(event.second/60)] += 1

    def handlePlayerLeaveEvent(self, event, replay):
        event.player.seconds_played = event.second

    def handleEndGame(self, event, replay):
        for human in replay.humans:
            if len(human.apm.keys()) > 0:
                human.avg_apm = sum(human.aps.values())/float(human.seconds_played)*60
            else:
                human.avg_apm = 0

########NEW FILE########
__FILENAME__ = context
# -*- coding: utf-8 -*-
# TODO: Dry this up a bit!
from __future__ import absolute_import, print_function, unicode_literals, division

from sc2reader.log_utils import loggable
from sc2reader.utils import Length


@loggable
class ContextLoader(object):
    name = 'ContextLoader'

    def handleInitGame(self, event, replay):
        replay.units = set()
        replay.unit = dict()

    def handleGameEvent(self, event, replay):
        self.load_message_game_player(event, replay)

    def handleMessageEvent(self, event, replay):
        self.load_message_game_player(event, replay)

    def handleCommandEvent(self, event, replay):
        if not replay.datapack:
            return

        if event.ability_id not in replay.datapack.abilities:
            if not getattr(replay, 'marked_error', None):
                replay.marked_error = True
                event.logger.error(replay.filename)
                event.logger.error("Release String: "+replay.release_string)
                for player in replay.players:
                    event.logger.error("\t{0}".format(player))

            self.logger.error("{0}\t{1}\tMissing ability {2:X} from {3}".format(event.frame, event.player.name, event.ability_id, replay.datapack.__class__.__name__))

        else:
            event.ability = replay.datapack.abilities[event.ability_id]
            event.ability_name = event.ability.name

        if event.other_unit_id in replay.objects:
            event.other_unit = replay.objects[event.other_unit_id]
        elif event.other_unit_id is not None:
            self.logger.error("Other unit {0} not found".format(event.other_unit_id))

    def handleTargetUnitCommandEvent(self, event, replay):
        if not replay.datapack:
            return

        if event.target_unit_id in replay.objects:
            event.target = replay.objects[event.target_unit_id]
            if not replay.tracker_events and not event.target.is_type(event.target_unit_type):
                replay.datapack.change_type(event.target, event.target_unit_type, event.frame)
        else:
            # Often when the target_unit_id is not in replay.objects it is 0 because it
            # is a target building/destructable hidden by fog of war. Perhaps we can match
            # it through the fog using location?
            unit = replay.datapack.create_unit(event.target_unit_id, event.target_unit_type, event.frame)
            event.target = unit
            replay.objects[event.target_unit_id] = unit

    def handleSelectionEvent(self, event, replay):
        if not replay.datapack:
            return

        units = list()
        # TODO: Blizzard calls these subgroup flags but that doesn't make sense right now
        for (unit_id, unit_type, subgroup_flags, intra_subgroup_flags) in event.new_unit_info:
            # If we don't have access to tracker events, use selection events to create
            # new units and track unit type changes. It won't be perfect, but it is better
            # than nothing.
            if not replay.tracker_events:
                # Starting at 23925 the default viking mode is assault. Most people expect
                # the default viking mode to be figher so fudge it a bit here.
                if replay.versions[1] == 2 and replay.build >= 23925 and unit_type == 71:
                    unit_type = 72

                if unit_id in replay.objects:
                    unit = replay.objects[unit_id]
                    if not unit.is_type(unit_type):
                        replay.datapack.change_type(unit, unit_type, event.frame)
                else:
                    unit = replay.datapack.create_unit(unit_id, unit_type, event.frame)
                    replay.objects[unit_id] = unit

            # If we have tracker events, the unit must already exist and must already
            # have the correct unit type.
            else:
                unit = replay.objects[unit_id]

            # Selection events hold flags on units (like hallucination)
            unit.apply_flags(intra_subgroup_flags)

            units.append(unit)

        event.new_units = event.objects = units

    def handleResourceTradeEvent(self, event, replay):
        event.sender = event.player
        event.recipient = replay.players[event.recipient_id]

    def handleHijackReplayGameEvent(self, event, replay):
        replay.resume_from_replay = True
        replay.resume_method = event.method
        replay.resume_user_info = event.user_infos

    def handlePlayerStatsEvent(self, event, replay):
        self.load_tracker_player(event, replay)

    def handleUnitBornEvent(self, event, replay):
        self.load_tracker_upkeeper(event, replay)
        self.load_tracker_controller(event, replay)

        if not replay.datapack:
            return

        if event.unit_id in replay.objects:
            # This can happen because game events are done first
            event.unit = replay.objects[event.unit_id]
        else:
            # TODO: How to tell if something is hallucination?
            event.unit = replay.datapack.create_unit(event.unit_id, event.unit_type_name, event.frame)
            replay.objects[event.unit_id] = event.unit

        replay.active_units[event.unit_id_index] = event.unit
        event.unit.location = event.location
        event.unit.started_at = event.frame
        event.unit.finished_at = event.frame

        if event.unit_upkeeper:
            event.unit.owner = event.unit_upkeeper
            event.unit.owner.units.append(event.unit)

    def handleUnitDiedEvent(self, event, replay):
        if not replay.datapack:
            return

        if event.unit_id in replay.objects:
            event.unit = replay.objects[event.unit_id]
            event.unit.died_at = event.frame
            event.unit.location = event.location
            if event.unit_id_index in replay.active_units:
                del replay.active_units[event.unit_id_index]
            else:
                self.logger.error("Unable to delete unit index {0} at {1} [{2}], index not active.".format(event.killer_pid, Length(seconds=event.second), event.frame))
        else:
            self.logger.error("Unit {0} died at {1} [{2}] before it was born!".format(event.unit_id, Length(seconds=event.second), event.frame))

        if event.killing_player_id in replay.player:
            event.killing_player = event.killer = replay.player[event.killing_player_id]
            if event.unit:
                event.unit.killing_player = event.unit.killed_by = event.killing_player
                event.killing_player.killed_units.append(event.unit)
        elif event.killing_player_id:
            self.logger.error("Unknown killing player id {0} at {1} [{2}]".format(event.killing_player_id, Length(seconds=event.second), event.frame))

        if event.killing_unit_id in replay.objects:
            event.killing_unit = replay.objects[event.killing_unit_id]
            if event.unit:
                event.unit.killing_unit = event.killing_unit
                event.killing_unit.killed_units.append(event.unit)
        elif event.killing_unit_id:
            self.logger.error("Unknown killing unit id {0} at {1} [{2}]".format(event.killing_unit_id, Length(seconds=event.second), event.frame))

    def handleUnitOwnerChangeEvent(self, event, replay):
        self.load_tracker_controller(event, replay)
        self.load_tracker_upkeeper(event, replay)

        if not replay.datapack:
            return

        if event.unit_id in replay.objects:
            event.unit = replay.objects[event.unit_id]
        else:
            self.logger.error("Unit {0} owner changed at {1} [{2}] before it was born!".format(event.unit_id, Length(seconds=event.second), event.frame))

        if event.unit_upkeeper:
            if event.unit.owner:
                event.unit.owner.units.remove(event.unit)
            event.unit.owner = event.unit_upkeeper
            event.unit_upkeeper.units.append(event.unit)

    def handleUnitTypeChangeEvent(self, event, replay):
        if not replay.datapack:
            return

        if event.unit_id in replay.objects:
            event.unit = replay.objects[event.unit_id]
            replay.datapack.change_type(event.unit, event.unit_type_name, event.frame)
        else:
            self.logger.error("Unit {0} type changed at {1} [{2}] before it was born!".format(event.unit_id, Length(seconds=event.second)))

    def handleUpgradeCompleteEvent(self, event, replay):
        self.load_tracker_player(event, replay)
        # TODO: We don't have upgrade -> ability maps
        # TODO: we can probably do the same thing we did for units

    def handleUnitInitEvent(self, event, replay):
        self.load_tracker_upkeeper(event, replay)
        self.load_tracker_controller(event, replay)

        if not replay.datapack:
            return

        if event.unit_id in replay.objects:
            event.unit = replay.objects[event.unit_id]
        else:
            # TODO: How to tell if something is hallucination?
            event.unit = replay.datapack.create_unit(event.unit_id, event.unit_type_name, event.frame)
            replay.objects[event.unit_id] = event.unit

        replay.active_units[event.unit_id_index] = event.unit
        event.unit.location = event.location
        event.unit.started_at = event.frame

        if event.unit_upkeeper:
            event.unit.owner = event.unit_upkeeper
            event.unit.owner.units.append(event.unit)

    def handleUnitDoneEvent(self, event, replay):
        if not replay.datapack:
            return

        if event.unit_id in replay.objects:
            event.unit = replay.objects[event.unit_id]
            event.unit.finished_at = event.frame
        else:
            self.logger.error("Unit {0} done at {1} [{2}] before it was started!".format(event.killer_pid, Length(seconds=event.second), event.frame))

    def handleUnitPositionsEvent(self, event, replay):
        if not replay.datapack:
            return

        for unit_index, (x, y) in event.positions:
            if unit_index in replay.active_units:
                unit = replay.active_units[unit_index]
                unit.location = (x, y)
                event.units[unit] = unit.location
            else:
                self.logger.error("Unit at active_unit index {0} moved at {1} [{2}] but it doesn't exist!".format(event.killer_pid, Length(seconds=event.second), event.frame))

    def load_message_game_player(self, event, replay):
        if replay.versions[1] == 1 or (replay.versions[1] == 2 and replay.build < 24247):
            if event.pid in replay.entity:
                event.player = replay.entity[event.pid]
                event.player.events.append(event)
            elif event.pid != 16:
                self.logger.error("Bad pid ({0}) for event {1} at {2} [{3}].".format(event.pid, event.__class__, Length(seconds=event.second), event.frame))
            else:
                pass  # This is a global event

        else:  # Now event.pid is actually a user id for human entities
            if event.pid < len(replay.humans):
                event.player = replay.human[event.pid]
                event.player.events.append(event)
            elif event.pid != 16:
                self.logger.error("Bad pid ({0}) for event {1} at {2} [{3}].".format(event.pid, event.__class__, Length(seconds=event.second), event.frames))
            else:
                pass  # This is a global event

    def load_tracker_player(self, event, replay):
        if event.pid in replay.entity:
            event.player = replay.entity[event.pid]
        else:
            self.logger.error("Bad pid ({0}) for event {1} at {2} [{3}].".format(event.pid, event.__class__, Length(seconds=event.second), event.frame))

    def load_tracker_upkeeper(self, event, replay):
        if event.upkeep_pid in replay.entity:
            event.unit_upkeeper = replay.entity[event.upkeep_pid]
        elif event.upkeep_pid != 0:
            self.logger.error("Bad upkeep_pid ({0}) for event {1} at {2} [{3}].".format(event.upkeep_pid, event.__class__, Length(seconds=event.second), event.frame))

    def load_tracker_controller(self, event, replay):
        if event.control_pid in replay.entity:
            event.unit_controller = replay.entity[event.control_pid]
        elif event.control_pid != 0:
            self.logger.error("Bad control_pid ({0}) for event {1} at {2} [{3}].".format(event.control_pid, event.__class__, Length(seconds=event.second), event.frame))

########NEW FILE########
__FILENAME__ = gameheart
# -*- coding: utf-8 -*-
from __future__ import absolute_import, print_function, unicode_literals, division

from datetime import datetime
from sc2reader.utils import Length, get_real_type
from sc2reader.objects import Observer, Team
from sc2reader.engine.events import PluginExit
from sc2reader.constants import GAME_SPEED_FACTOR


class GameHeartNormalizer(object):
    """
    normalize a GameHeart replay to:
    1) reset frames to the game start
    2) remove observing players
    3) fix race selection
    4) fix team selection
    If a replay is not a GameHeart replay, it should be left untouched
    Hopefully, the changes here will also extend to other replays that use
    in-game lobbies

    GameHeart games have some constraints we can use here:
    * They are all 1v1's.
    * You can't random in GameHeart
    """
    name = 'GameHeartNormalizer'

    PRIMARY_BUILDINGS = dict(Hatchery="Zerg", Nexus="Protoss", CommandCenter="Terran")

    def handleInitGame(self, event, replay):
        # without tracker events game heart games can't be fixed
        if len(replay.tracker_events) == 0:
            yield PluginExit(self, code=0, details=dict())
            return

        start_frame = -1
        actual_players = {}
        for event in replay.tracker_events:
            if start_frame != -1 and event.frame > start_frame + 5:  # fuzz it a little
                break
            if event.name == 'UnitBornEvent' and event.control_pid and event.unit_type_name in self.PRIMARY_BUILDINGS:
                # In normal replays, starting units are born on frame zero.
                if event.frame == 0:
                    yield PluginExit(self, code=0, details=dict())
                    return
                else:
                    start_frame = event.frame
                    actual_players[event.control_pid] = self.PRIMARY_BUILDINGS[event.unit_type_name]

        self.fix_entities(replay, actual_players)
        self.fix_events(replay, start_frame)

        replay.frames -= start_frame
        replay.game_length = Length(seconds=replay.frames / 16)
        replay.real_type = get_real_type(replay.teams)
        replay.real_length = Length(seconds=int(replay.game_length.seconds/GAME_SPEED_FACTOR[replay.speed]))
        replay.start_time = datetime.utcfromtimestamp(replay.unix_timestamp-replay.real_length.seconds)

    def fix_events(self, replay, start_frame):
        # Set back the game clock for all events
        for event in replay.events:
            if event.frame < start_frame:
                event.frame = 0
                event.second = 0
            else:
                event.frame -= start_frame
                event.second = event.frame >> 4

    def fix_entities(self, replay, actual_players):
        # Change the players that aren't playing into observers
        for p in [p for p in replay.players if p.pid not in actual_players]:
            obs = Observer(p.sid, p.slot_data, p.uid, p.init_data, p.pid)

            # Because these obs start the game as players the client
            # creates various Beacon units for them.
            obs.units = p.units

            # Remove all references to the old player
            del replay.player[p.pid]
            del replay.entity[p.pid]
            del replay.human[p.uid]
            replay.players.remove(p)
            replay.entities.remove(p)
            replay.humans.remove(p)

            # Create all the necessary references for the new observer
            replay.observer[obs.uid] = obs
            replay.entity[obs.pid] = obs
            replay.human[obs.uid] = obs
            replay.observers.append(obs)
            replay.entities.append(obs)
            replay.humans.append(obs)

        # Maintain order, just in case someone is depending on it
        replay.observers = sorted(replay.observers, key=lambda o: o.sid)
        replay.entities = sorted(replay.entities, key=lambda o: o.sid)
        replay.humans = sorted(replay.humans, key=lambda o: o.sid)

        # Assume one player per team, should be valid for GameHeart games
        replay.team = dict()
        replay.teams = list()
        for index, player in enumerate(replay.players):
            team_id = index+1
            team = Team(team_id)
            replay.team[team_id] = team
            replay.teams.append(team)
            player.team = team
            team.result = player.result
            player.pick_race = actual_players[player.pid]
            player.play_race = player.pick_race
            team.players = [player]
            team.result = player.result
            if team.result == 'Win':
                replay.winner = team

########NEW FILE########
__FILENAME__ = selection
# -*- coding: utf-8 -*-
from __future__ import absolute_import, print_function, unicode_literals, division


class SelectionTracker(object):
    """ Tracks a player's active selection as an input into other plugins.

        In some situations selection tracking isn't perfect. The plugin will
        detect these situations and report errors. For a player will a high
        level of selection errors, it may be best to ignore the selection
        results as they could have been severely compromised.

        Exposes the following interface, directly integrated into the player:

            for person in replay.entities:
                total_errors = person.selection_errors

                selection = person.selection
                control_group_0 = selection[0]
                ...
                control_group_9 = selection[9]
                active_selection = selection[10]

        # TODO: list a few error inducing sitations
    """
    name = 'SelectionTracker'

    def handleInitGame(self, event, replay):
        for person in replay.entities:
            person.selection = dict()
            for i in range(11):
                person.selection[i] = list()
            person.selection_errors = 0

    def handleSelectionEvent(self, event, replay):
        selection = event.player.selection[event.control_group]
        new_selection, error = self._deselect(selection, event.mask_type, event.mask_data)
        new_selection = self._select(new_selection, event.objects)
        event.player.selection[event.control_group] = new_selection
        if error:
            event.player.selection_errors += 1

    def handleGetControlGroupEvent(self, event, replay):
        selection = event.player.selection[event.control_group]
        new_selection, error = self._deselect(selection, event.mask_type, event.mask_data)
        event.player.selection[10] = new_selection
        if error:
            event.player.selection_errors += 1

    def handleSetControlGroupEvent(self, event, replay):
        event.player.selection[event.control_group] = event.player.selection[10]

    def handleAddToControlGroupEvent(self, event, replay):
        selection = event.player.selection[event.control_group]
        new_selection, error = self._deselect(selection, event.mask_type, event.mask_data)
        new_selection = self._select(new_selection, event.player.selection[10])
        event.player.selection[event.control_group] = new_selection
        if error:
            event.player.selection_errors += 1

    def _select(self, selection, units):
        return sorted(set(selection+units))

    def _deselect(self, selection, mode, data):
        """Returns false if there was a data error when deselecting"""
        if mode == 'None':
            return selection, False

        selection_size, data_size = len(selection), len(data)

        if mode == 'Mask':
            # Deselect objects according to deselect mask
            sfilter = lambda bit_u: not bit_u[0]
            mask = data+[False]*(selection_size-data_size)
            new_selection = [u for (bit, u) in filter(sfilter, zip(mask, selection))]
            error = data_size > selection_size

        elif mode == 'OneIndices':
            # Deselect objects according to indexes
            clean_data = list(filter(lambda i: i < selection_size, data))
            new_selection = [u for i, u in enumerate(selection) if i < selection_size]
            error = len(list(filter(lambda i: i >= selection_size, data))) != 0

        elif mode == 'ZeroIndices':
            # Select objects according to indexes
            clean_data = list(filter(lambda i: i < selection_size, data))
            new_selection = [selection[i] for i in clean_data]
            error = len(clean_data) != data_size

        return new_selection, error

########NEW FILE########
__FILENAME__ = utils
# -*- coding: utf-8 -*-
from __future__ import absolute_import, print_function, unicode_literals, division

from bisect import bisect_left


class GameState(dict):
    def __init__(self, initial_state):
        self._frames = list()
        self._frameset = set()
        self[0] = initial_state
        self.locked = False

    def __getitem__(self, frame):
        if frame in self:
            return super(GameState, self).__getitem__(frame)

        # Get the previous frame from our sorted frame list
        # bisect_left returns the left most key where an item is
        # less than or equal to the value in that key. If it is
        # less than we need to subtract 1
        key = bisect_left(self._frames, frame)
        if key == len(self._frames) or self._frames[key] > frame:
            prev_frame = self._frames[key - 1]
        else:
            prev_frame = self._frames[key]

        # If we've locked the game state we don't need deep copies anymore
        if self.locked:
            state = self[prev_frame]
        else:
            # Copy the previous state and use it as our basis here
            state = self[prev_frame]
            if hasattr(state, 'copy'):
                state = state.copy()

        self[frame] = state
        return state

    def __setitem__(self, frame, value):
        if frame not in self._frameset:
            self._frames.insert(bisect_left(self._frames, frame), frame)
            self._frameset.add(frame)

        super(GameState, self).__setitem__(frame, value)

########NEW FILE########
__FILENAME__ = base
# -*- coding: utf-8 -*-
from __future__ import absolute_import, print_function, unicode_literals, division


class Event(object):
    name = 'Event'

########NEW FILE########
__FILENAME__ = game
# -*- coding: utf-8 -*-
from __future__ import absolute_import, print_function, unicode_literals, division

from sc2reader.utils import Length
from sc2reader.events.base import Event
from sc2reader.log_utils import loggable

from itertools import chain


@loggable
class GameEvent(Event):
    """
    This is the base class for all game events. The attributes below are universally available.
    """
    def __init__(self, frame, pid):
        #: The id of the player generating the event. This is 16 for global non-player events.
        #: Prior to Heart of the Swarm this was the player id. Since HotS it is
        #: now the user id (uid), we still call it pid for backwards compatibility. You shouldn't
        #: ever need to use this; use :attr:`player` instead.
        self.pid = pid

        #: A reference to the :class:`~sc2reader.objects.Player` object representing
        #: this player in the replay. Not available for global events (:attr:`is_local` = False)
        self.player = None

        #: The frame of the game that this event was recorded at. 16 frames per game second.
        self.frame = frame

        #: The second of the game that this event was recorded at. 16 frames per game second.
        self.second = frame >> 4

        #: A flag indicating if it is a local or global event.
        self.is_local = (pid != 16)

        #: Short cut string for event class name
        self.name = self.__class__.__name__

    def _str_prefix(self):
        player_name = self.player.name if getattr(self, 'pid', 16) != 16 else "Global"
        return "{0}\t{1:<15} ".format(Length(seconds=int(self.frame / 16)), player_name)

    def __str__(self):
        return self._str_prefix() + self.name


class GameStartEvent(GameEvent):
    """
    Recorded when the game starts and the frames start to roll. This is a global non-player
    event.
    """
    def __init__(self, frame, pid, data):
        super(GameStartEvent, self).__init__(frame, pid)

        #: ???
        self.data = data


class PlayerLeaveEvent(GameEvent):
    """
    Recorded when a player leaves the game.
    """
    def __init__(self, frame, pid, data):
        super(PlayerLeaveEvent, self).__init__(frame, pid)

        #: ???
        self.data = data


class UserOptionsEvent(GameEvent):
    """
    This event is recorded for each player at the very beginning of the game before the
    :class:`GameStartEvent`.
    """
    def __init__(self, frame, pid, data):
        super(UserOptionsEvent, self).__init__(frame, pid)
        #:
        self.game_fully_downloaded = data['game_fully_downloaded']

        #:
        self.development_cheats_enabled = data['development_cheats_enabled']

        #:
        self.multiplayer_cheats_enabled = data['multiplayer_cheats_enabled']

        #:
        self.sync_checksumming_enabled = data['sync_checksumming_enabled']

        #:
        self.is_map_to_map_transition = data['is_map_to_map_transition']

        #:
        self.use_ai_beacons = data['use_ai_beacons']

        #: Are workers sent to auto-mine on game start
        self.starting_rally = data['starting_rally']

        #:
        self.debug_pause_enabled = data['debug_pause_enabled']

        #:
        self.base_build_num = data['base_build_num']


def create_command_event(frame, pid, data):
    ability_type = data['data'][0]
    if ability_type == 'None':
        return BasicCommandEvent(frame, pid, data)

    elif ability_type == 'TargetUnit':
        return TargetUnitCommandEvent(frame, pid, data)

    elif ability_type == 'TargetPoint':
        return TargetPointCommandEvent(frame, pid, data)

    elif ability_type == 'Data':
        return DataCommandEvent(frame, pid, data)


@loggable
class CommandEvent(GameEvent):
    """
    Ability events are generated when ever a player in the game issues a command
    to a unit or group of units. They are split into three subclasses of ability,
    each with their own set of associated data. The attributes listed below are
    shared across all ability event types.

    See :class:`TargetPointCommandEvent`, :class:`TargetUnitCommandEvent`, and
    :class:`DataCommandEvent` for individual details.
    """
    def __init__(self, frame, pid, data):
        super(CommandEvent, self).__init__(frame, pid)

        #: Flags on the command???
        self.flags = data['flags']

        #: A dictionary of possible ability flags. Flags are:
        #:
        #: * alternate
        #: * queued
        #: * preempt
        #: * smart_click
        #: * smart_rally
        #: * subgroup
        #: * set_autocast,
        #: * set_autocast_on
        #: * user
        #: * data_a
        #: * data_b
        #: * data_passenger
        #: * data_abil_queue_order_id,
        #: * ai
        #: * ai_ignore_on_finish
        #: * is_order
        #: * script
        #: * homogenous_interruption,
        #: * minimap
        #: * repeat
        #: * dispatch_to_other_unit
        #: * target_self
        #:
        self.flag = dict(
            alternate=0x1 & self.flags != 0,
            queued=0x2 & self.flags != 0,
            preempt=0x4 & self.flags != 0,
            smart_click=0x8 & self.flags != 0,
            smart_rally=0x10 & self.flags != 0,
            subgroup=0x20 & self.flags != 0,
            set_autocast=0x40 & self.flags != 0,
            set_autocast_on=0x80 & self.flags != 0,
            user=0x100 & self.flags != 0,
            data_a=0x200 & self.flags != 0,
            data_passenger=0x200 & self.flags != 0,  # alt-name
            data_b=0x400 & self.flags != 0,
            data_abil_queue_order_id=0x400 & self.flags != 0,  # alt-name
            ai=0x800 & self.flags != 0,
            ai_ignore_on_finish=0x1000 & self.flags != 0,
            is_order=0x2000 & self.flags != 0,
            script=0x4000 & self.flags != 0,
            homogenous_interruption=0x8000 & self.flags != 0,
            minimap=0x10000 & self.flags != 0,
            repeat=0x20000 & self.flags != 0,
            dispatch_to_other_unit=0x40000 & self.flags != 0,
            target_self=0x80000 & self.flags != 0,
        )

        #: Flag marking that the command had ability information
        self.has_ability = data['ability'] is not None

        #: Link the the ability group
        self.ability_link = data['ability']['ability_link'] if self.has_ability else 0

        #: The index of the ability in the ability group
        self.command_index = data['ability']['ability_command_index'] if self.has_ability else 0

        #: Additional ability data.
        self.ability_data = data['ability']['ability_command_data'] if self.has_ability else 0

        #: Unique identifier for the ability
        self.ability_id = self.ability_link << 5 | self.command_index

        #: A reference to the ability being used
        self.ability = None

        #: A shortcut to the name of the ability being used
        self.ability_name = ''

        #: The type of ability, one of: None (no target), TargetPoint, TargetUnit, or Data
        self.ability_type = data['data'][0]

        #: The raw data associated with this ability type
        self.ability_type_data = data['data'][1]

        #: Other unit id??
        self.other_unit_id = data['other_unit_tag']

        #: A reference to the other unit
        self.other_unit = None

    def __str__(self):
        string = self._str_prefix()
        if self.has_ability:
            string += "Ability ({0:X})".format(self.ability_id)
            if self.ability:
                string += " - {0}".format(self.ability.name)
        else:
            string += "Right Click"

        if self.ability_type == 'TargetUnit':
            string += "; Target: {0} [{1:0>8X}]".format(self.target.name, self.target_unit_id)

        if self.ability_type in ('TargetPoint', 'TargetUnit'):
            string += "; Location: {0}".format(str(self.location))

        return string


class BasicCommandEvent(CommandEvent):
    """
    Extends :class:`CommandEvent`

    This event is recorded for events that have no extra information recorded.

    Note that like all CommandEvents, the event will be recorded regardless
    of whether or not the command was successful.
    """
    def __init__(self, frame, pid, data):
        super(BasicCommandEvent, self).__init__(frame, pid, data)


class TargetPointCommandEvent(CommandEvent):
    """
    Extends :class:`CommandEvent`

    This event is recorded when ever a player issues a command that targets a location
    and NOT a unit. Commands like Psistorm, Attack Move, Fungal Growth, and EMP fall
    under this category.

    Note that like all CommandEvents, the event will be recorded regardless
    of whether or not the command was successful.
    """
    def __init__(self, frame, pid, data):
        super(TargetPointCommandEvent, self).__init__(frame, pid, data)

        #: The x coordinate of the target. Available for TargetPoint and TargetUnit type events.
        self.x = self.ability_type_data['point'].get('x', 0) / 4096.0

        #: The y coordinate of the target. Available for TargetPoint and TargetUnit type events.
        self.y = self.ability_type_data['point'].get('y', 0) / 4096.0

        #: The z coordinate of the target. Available for TargetPoint and TargetUnit type events.
        self.z = self.ability_type_data['point'].get('z', 0)

        #: The location of the target. Available for TargetPoint and TargetUnit type events
        self.location = (self.x, self.y, self.z)


class TargetUnitCommandEvent(CommandEvent):
    """
    Extends :class:`CommandEvent`

    This event is recorded when ever a player issues a command that targets a unit.
    The location of the target unit at the time of the command is also recorded. Commands like
    Chronoboost, Transfuse, and Snipe fall under this category.

    Note that like all CommandEvents, the event will be recorded regardless
    of whether or not the command was successful.
    """
    def __init__(self, frame, pid, data):
        super(TargetUnitCommandEvent, self).__init__(frame, pid, data)

        #: Flags set on the target unit. Available for TargetUnit type events
        self.target_flags = self.ability_type_data.get('flags', None)

        #: Timer??  Available for TargetUnit type events.
        self.target_timer = self.ability_type_data.get('timer', None)

        #: Unique id of the target unit. Available for TargetUnit type events.
        #: This id can be 0 when the target unit is shrouded by fog of war.
        self.target_unit_id = self.ability_type_data.get('unit_tag', None)

        #: A reference to the targetted unit. When the :attr:`target_unit_id` is
        #: 0 this target unit is a generic, reused fog of war unit of the :attr:`target_unit_type`
        #: with an id of zero. It should not be confused with a real unit.
        self.target_unit = None

        #: Current integer type id of the target unit. Available for TargetUnit type events.
        self.target_unit_type = self.ability_type_data.get('unit_link', None)

        #: Integer player id of the controlling player. Available for TargetUnit type events starting in 19595.
        #: When the targetted unit is under fog of war this id is zero.
        self.control_player_id = self.ability_type_data.get('control_player_id', None)

        #: Integer player id of the player paying upkeep. Available for TargetUnit type events.
        self.upkeep_player_id = self.ability_type_data.get('upkeep_player_id', None)

        #: The x coordinate of the target. Available for TargetPoint and TargetUnit type events.
        self.x = self.ability_type_data['point'].get('x', 0) / 4096.0

        #: The y coordinate of the target. Available for TargetPoint and TargetUnit type events.
        self.y = self.ability_type_data['point'].get('y', 0) / 4096.0

        #: The z coordinate of the target. Available for TargetPoint and TargetUnit type events.
        self.z = self.ability_type_data['point'].get('z', 0)

        #: The location of the target. Available for TargetPoint and TargetUnit type events
        self.location = (self.x, self.y, self.z)


class DataCommandEvent(CommandEvent):
    """
    Extends :class:`CommandEvent`

    DataCommandEvent are recorded when ever a player issues a command that has no target. Commands
    like Burrow, SeigeMode, Train XYZ, and Stop fall under this category.

    Note that like all CommandEvents, the event will be recorded regardless
    of whether or not the command was successful.
    """
    def __init__(self, frame, pid, data):
        super(DataCommandEvent, self).__init__(frame, pid, data)

        #: Other target data. Available for Data type events.
        self.target_data = self.ability_type_data.get('data', None)


@loggable
class SelectionEvent(GameEvent):
    """
    Selection events are generated when ever the active selection of the
    player is updated. Unlike other game events, these events can also be
    generated by non-player actions like unit deaths or transformations.

    Starting in Starcraft 2.0.0, selection events targetting control group
    buffers are also generated when control group selections are modified
    by non-player actions. When a player action updates a control group
    a :class:`ControlGroupEvent` is generated.
    """
    def __init__(self, frame, pid, data):
        super(SelectionEvent, self).__init__(frame, pid)

        #: The control group being modified. 10 for active selection
        self.control_group = data['control_group_index']

        #: Deprecated, use control_group
        self.bank = self.control_group

        #: ???
        self.subgroup_index = data['subgroup_index']

        #: The type of mask to apply. One of None, Mask, OneIndices, ZeroIndices
        self.mask_type = data['remove_mask'][0]

        #: The data for the mask
        self.mask_data = data['remove_mask'][1]

        #: The unit type data for the new units
        self.new_unit_types = [(d['unit_link'], d['subgroup_priority'], d['intra_subgroup_priority'], d['count']) for d in data['add_subgroups']]

        #: The unit id data for the new units
        self.new_unit_ids = data['add_unit_tags']

        # This stretches out the unit types and priorities to be zipped with ids.
        unit_types = chain(*[[utype]*count for (utype, subgroup_priority, intra_subgroup_priority, count) in self.new_unit_types])
        unit_subgroup_priorities = chain(*[[subgroup_priority]*count for (utype, subgroup_priority, intra_subgroup_priority, count) in self.new_unit_types])
        unit_intra_subgroup_priorities = chain(*[[intra_subgroup_priority]*count for (utype, subgroup_priority, intra_subgroup_priority, count) in self.new_unit_types])

        #: The combined type and id information for new units
        self.new_unit_info = list(zip(self.new_unit_ids, unit_types, unit_subgroup_priorities, unit_intra_subgroup_priorities))

        #: A list of references to units added by this selection
        self.new_units = None

        #: Deprecated, see new_units
        self.objects = None

    def __str__(self):
        if self.new_units:
            return GameEvent.__str__(self)+str([str(u) for u in self.new_units])
        else:
            return GameEvent.__str__(self)+str([str(u) for u in self.new_unit_info])


def create_control_group_event(frame, pid, data):
    update_type = data['control_group_update']
    if update_type == 0:
        return SetControlGroupEvent(frame, pid, data)
    elif update_type == 1:
        return AddToControlGroupEvent(frame, pid, data)
    elif update_type == 2:
        return GetControlGroupEvent(frame, pid, data)
    elif update_type == 3:
        # TODO: What could this be?!?
        return ControlGroupEvent(frame, pid, data)


@loggable
class ControlGroupEvent(GameEvent):
    """
    ControlGroup events are recorded when ever a player action modifies or accesses a control
    group. There are three kinds of events, generated by each of the possible
    player actions:

    * :class:`SetControlGroup` - Recorded when a user sets a control group (ctrl+#).
    * :class:`GetControlGroup` - Recorded when a user retrieves a control group (#).
    * :class:`AddToControlGroup` - Recorded when a user adds to a control group (shift+ctrl+#)

    All three events have the same set of data (shown below) but are interpretted differently.
    See the class entry for details.
    """
    def __init__(self, frame, pid, data):
        super(ControlGroupEvent, self).__init__(frame, pid)

        #: Index to the control group being modified
        self.control_group = data['control_group_index']

        #: Deprecated, use control_group
        self.bank = self.control_group

        #: Deprecated, use control_group
        self.hotkey = self.control_group

        #: The type of update being performed, 0 (set),1 (add),2 (get)
        self.update_type = data['control_group_update']

        #: The type of mask to apply. One of None, Mask, OneIndices, ZeroIndices
        self.mask_type = data['remove_mask'][0]

        #: The data for the mask
        self.mask_data = data['remove_mask'][1]


class SetControlGroupEvent(ControlGroupEvent):
    """
    Extends :class:`ControlGroupEvent`

    This event does a straight forward replace of the current control group contents
    with the player's current selection. This event doesn't have masks set.
    """


class AddToControlGroupEvent(SetControlGroupEvent):
    """
    Extends :class:`ControlGroupEvent`

    This event adds the current selection to the control group.
    """


class GetControlGroupEvent(ControlGroupEvent):
    """
    Extends :class:`ControlGroupEvent`

    This event replaces the current selection with the contents of the control group.
    The mask data is used to limit that selection to units that are currently selectable.
    You might have 1 medivac and 8 marines on the control group but if the 8 marines are
    inside the medivac they cannot be part of your selection.
    """


@loggable
class CameraEvent(GameEvent):
    """
    Camera events are generated when ever the player camera moves, zooms, or rotates.
    It does not matter why the camera changed, this event simply records the current
    state of the camera after changing.
    """
    def __init__(self, frame, pid, data):
        super(CameraEvent, self).__init__(frame, pid)

        #: The x coordinate of the center of the camera
        self.x = (data['target']['x'] if data['target'] is not None else 0)/256.0

        #: The y coordinate of the center of the camera
        self.y = (data['target']['y'] if data['target'] is not None else 0)/256.0

        #: The location of the center of the camera
        self.location = (self.x, self.y)

        #: The distance to the camera target ??
        self.distance = data['distance']

        #: The current pitch of the camera
        self.pitch = data['pitch']

        #: The current yaw of the camera
        self.yaw = data['yaw']

    def __str__(self):
        return self._str_prefix() + "{0} at ({1}, {2})".format(self.name, self.x, self.y)


@loggable
class ResourceTradeEvent(GameEvent):
    """
    Generated when a player trades resources with another player. But not when fullfulling
    resource requests.
    """
    def __init__(self, frame, pid, data):
        super(ResourceTradeEvent, self).__init__(frame, pid)

        #: The id of the player sending the resources
        self.sender_id = pid

        #: A reference to the player sending the resources
        self.sender = None

        #: The id of the player receiving the resources
        self.recipient_id = data['recipient_id']

        #: A reference to the player receiving the resources
        self.recipient = None

        #: An array of resources sent
        self.resources = data['resources']

        #: Amount minerals sent
        self.minerals = self.resources[0] if len(self.resources) >= 1 else None

        #: Amount vespene sent
        self.vespene = self.resources[1] if len(self.resources) >= 2 else None

        #: Amount terrazine sent
        self.terrazon = self.resources[2] if len(self.resources) >= 3 else None

        #: Amount custom resource sent
        self.custom_resource = self.resources[3] if len(self.resources) >= 4 else None

    def __str__(self):
        return self._str_prefix() + " transfer {0} minerals, {1} gas, {2} terrazine, and {3} custom to {4}".format(self.minerals, self.vespene, self.terrazine, self.custom, self.recipient)


class ResourceRequestEvent(GameEvent):
    """
    Generated when a player creates a resource request.
    """
    def __init__(self, frame, pid, data):
        super(ResourceRequestEvent, self).__init__(frame, pid)

        #: An array of resources sent
        self.resources = data['resources']

        #: Amount minerals sent
        self.minerals = self.resources[0] if len(self.resources) >= 1 else None

        #: Amount vespene sent
        self.vespene = self.resources[1] if len(self.resources) >= 2 else None

        #: Amount terrazine sent
        self.terrazon = self.resources[2] if len(self.resources) >= 3 else None

        #: Amount custom resource sent
        self.custom_resource = self.resources[3] if len(self.resources) >= 4 else None

    def __str__(self):
        return self._str_prefix() + " requests {0} minerals, {1} gas, {2} terrazine, and {3} custom".format(self.minerals, self.vespene, self.terrazine, self.custom)


class ResourceRequestFulfillEvent(GameEvent):
    """
    Generated when a player accepts a resource request.
    """
    def __init__(self, frame, pid, data):
        super(ResourceRequestFulfillEvent, self).__init__(frame, pid)

        #: The id of the request being fulfilled
        self.request_id = data['request_id']


class ResourceRequestCancelEvent(GameEvent):
    """
    Generated when a player cancels their resource request.
    """
    def __init__(self, frame, pid, data):
        super(ResourceRequestCancelEvent, self).__init__(frame, pid)

        #: The id of the request being cancelled
        self.request_id = data['request_id']


class HijackReplayGameEvent(GameEvent):
    """
    Generated when players take over from a replay.
    """
    def __init__(self, frame, pid, data):
        super(HijackReplayGameEvent, self).__init__(frame, pid)

        #: The method used. Not sure what 0/1 represent
        self.method = data['method']

        #: Information on the users hijacking the game
        self.user_infos = data['user_infos']

########NEW FILE########
__FILENAME__ = message
# -*- coding: utf-8 -*-
from __future__ import absolute_import, print_function, unicode_literals, division

from sc2reader.events.base import Event
from sc2reader.utils import Length
from sc2reader.log_utils import loggable


@loggable
class MessageEvent(Event):
    """
        Parent class for all message events.
    """
    def __init__(self, frame, pid):
        #: The user id (or player id for older replays) of the person that generated the event.
        self.pid = pid

        #: The frame of the game this event was applied
        self.frame = frame

        #: The second of the game (game time not real time) this event was applied
        self.second = frame >> 4

        #: Short cut string for event class name
        self.name = self.__class__.__name__

    def _str_prefix(self):
        player_name = self.player.name if getattr(self, 'pid', 16) != 16 else "Global"
        return "{0}\t{1:<15} ".format(Length(seconds=int(self.frame / 16)), player_name)

    def __str__(self):
        return self._str_prefix() + self.name


@loggable
class ChatEvent(MessageEvent):
    """
        Records in-game chat events.
    """
    def __init__(self, frame, pid, target, text):
        super(ChatEvent, self).__init__(frame, pid)
        #: The numerical target type. 0 = to all; 2 = to allies; 4 = to observers.
        self.target = target

        #: The text of the message.
        self.text = text

        #: Flag marked true of message was to all.
        self.to_all = (self.target == 0)

        #: Flag marked true of message was to allies.
        self.to_allies = (self.target == 2)

        #: Flag marked true of message was to observers.
        self.to_observers = (self.target == 4)


@loggable
class ProgressEvent(MessageEvent):
    """
        Sent during the load screen to update load process for other clients.
    """
    def __init__(self, frame, pid, progress):
        super(ProgressEvent, self).__init__(frame, pid)

        #: Marks the load progress for the player. Scaled 0-100.
        self.progress = progress


@loggable
class PingEvent(MessageEvent):
    """
        Records pings made by players in game.
    """
    def __init__(self, frame, pid, target, x, y):
        super(PingEvent, self).__init__(frame, pid)

        #: The numerical target type. 0 = to all; 2 = to allies; 4 = to observers.
        self.target = target

        #: Flag marked true of message was to all.
        self.to_all = (self.target == 0)

        #: Flag marked true of message was to allies.
        self.to_allies = (self.target == 2)

        #: Flag marked true of message was to observers.
        self.to_observers = (self.target == 4)

        #: The x coordinate of the target location
        self.x = x

        #: The y coordinate of the target location
        self.y = y

        #: The (x,y) coordinate of the target location
        self.location = (self.x, self.y)

########NEW FILE########
__FILENAME__ = tracker
# -*- coding: utf-8 -*-
from __future__ import absolute_import, print_function, unicode_literals, division

import functools

from sc2reader.events.base import Event
from sc2reader.utils import Length

clamp = functools.partial(max, 0)


class TrackerEvent(Event):
    """
    Parent class for all tracker events.
    """
    def __init__(self, frames):
        #: The frame of the game this event was applied
        self.frame = frames

        #: The second of the game (game time not real time) this event was applied
        self.second = frames >> 4

        #: Short cut string for event class name
        self.name = self.__class__.__name__

    def load_context(self, replay):
        pass

    def _str_prefix(self):
        return "{0}\t ".format(Length(seconds=int(self.frame / 16)))

    def __str__(self):
        return self._str_prefix() + self.name


class PlayerSetupEvent(TrackerEvent):
    """ Sent during game setup to help us organize players better """
    def __init__(self, frames, data, build):
        super(PlayerSetupEvent, self).__init__(frames)

        #: The player id of the player we are setting up
        self.pid = data[0]

        #: The type of this player. One of 1=human, 2=cpu, 3=neutral, 4=hostile
        self.type = data[1]

        #: The user id of the player we are setting up. None of not human
        self.uid = data[2]

        #: The slot id of the player we are setting up. None if not playing
        self.sid = data[3]


class PlayerStatsEvent(TrackerEvent):
    """
    Player Stats events are generated for all players that were in the game even if they've since
    left every 10 seconds. An additional set of stats events are generated at the end of the game.

    When a player leaves the game, a single PlayerStatsEvent is generated for that player and no
    one else. That player continues to generate PlayerStatsEvents at 10 second intervals until the
    end of the game.

    In 1v1 games, the above behavior can cause the losing player to have 2 events generated at the
    end of the game. One for leaving and one for the  end of the game.
    """
    def __init__(self, frames, data, build):
        super(PlayerStatsEvent, self).__init__(frames)

        #: Id of the player the stats are for
        self.pid = data[0]

        #: The Player object that these stats apply to
        self.player = None

        #: An ordered list of all the available stats
        self.stats = data[1]

        #: Minerals currently available to the player
        self.minerals_current = clamp(self.stats[0])

        #: Vespene currently available to the player
        self.vespene_current = clamp(self.stats[1])

        #: The rate the player is collecting minerals
        self.minerals_collection_rate = clamp(self.stats[2])

        #: The rate the player is collecting vespene
        self.vespene_collection_rate = clamp(self.stats[3])

        #: The number of active workers the player has
        self.workers_active_count = clamp(self.stats[4])

        #: The total mineral cost of army units (buildings?) currently being built/queued
        self.minerals_used_in_progress_army = clamp(self.stats[5])

        #: The total mineral cost of economy units (buildings?) currently being built/queued
        self.minerals_used_in_progress_economy = clamp(self.stats[6])

        #: The total mineral cost of technology research (buildings?) currently being built/queued
        self.minerals_used_in_progress_technology = clamp(self.stats[7])

        #: The total mineral cost of all things in progress
        self.minerals_used_in_progress = self.minerals_used_in_progress_army + self.minerals_used_in_progress_economy + self.minerals_used_in_progress_technology

        #: The total vespene cost of army units (buildings?) currently being built/queued
        self.vespene_used_in_progress_army = clamp(self.stats[8])

        #: The total vespene cost of economy units (buildings?) currently being built/queued.
        self.vespene_used_in_progress_economy = clamp(self.stats[9])

        #: The total vespene cost of technology research (buildings?) currently being built/queued.
        self.vespene_used_in_progress_technology = clamp(self.stats[10])

        #: The total vespene cost of all things in progress
        self.vespene_used_in_progress = self.vespene_used_in_progress_army + self.vespene_used_in_progress_economy + self.vespene_used_in_progress_technology

        #: The total cost of all things in progress
        self.resources_used_in_progress = self.minerals_used_in_progress + self.vespene_used_in_progress

        #: The total mineral cost of current army units (buildings?)
        self.minerals_used_current_army = clamp(self.stats[11])

        #: The total mineral cost of current economy units (buildings?)
        self.minerals_used_current_economy = clamp(self.stats[12])

        #: The total mineral cost of current technology research (buildings?)
        self.minerals_used_current_technology = clamp(self.stats[13])

        #: The total mineral cost of all current things
        self.minerals_used_current = self.minerals_used_current_army + self.minerals_used_current_economy + self.minerals_used_current_technology

        #: The total vespene cost of current army units (buildings?)
        self.vespene_used_current_army = clamp(self.stats[14])

        #: The total vespene cost of current economy units (buildings?)
        self.vespene_used_current_economy = clamp(self.stats[15])

        #: The total vespene cost of current technology research (buildings?)
        self.vespene_used_current_technology = clamp(self.stats[16])

        #: The total vepsene cost of all current things
        self.vespene_used_current = self.vespene_used_current_army + self.vespene_used_current_economy + self.vespene_used_current_technology

        #: The total cost of all things current
        self.resources_used_current = self.minerals_used_current + self.vespene_used_current

        #: The total mineral cost of all army units (buildings?) lost
        self.minerals_lost_army = clamp(self.stats[17])

        #: The total mineral cost of all economy units (buildings?) lost
        self.minerals_lost_economy = clamp(self.stats[18])

        #: The total mineral cost of all technology research (buildings?) lost
        self.minerals_lost_technology = clamp(self.stats[19])

        #: The total mineral cost of all lost things
        self.minerals_lost = self.minerals_lost_army + self.minerals_lost_economy + self.minerals_lost_technology

        #: The total vespene cost of all army units (buildings?) lost
        self.vespene_lost_army = clamp(self.stats[20])

        #: The total vespene cost of all economy units (buildings?) lost
        self.vespene_lost_economy = clamp(self.stats[21])

        #: The total vespene cost of all technology research (buildings?) lost
        self.vespene_lost_technology = clamp(self.stats[22])

        #: The total vepsene cost of all lost things
        self.vespene_lost = self.vespene_lost_army + self.vespene_lost_economy + self.vespene_lost_technology

        #: The total resource cost of all lost things
        self.resources_lost = self.minerals_lost + self.vespene_lost

        #: The total mineral value of enemy army units (buildings?) killed
        self.minerals_killed_army = clamp(self.stats[23])

        #: The total mineral value of enemy economy units (buildings?) killed
        self.minerals_killed_economy = clamp(self.stats[24])

        #: The total mineral value of enemy technology research (buildings?) killed
        self.minerals_killed_technology = clamp(self.stats[25])

        #: The total mineral value of all killed things
        self.minerals_killed = self.minerals_killed_army + self.minerals_killed_economy + self.minerals_killed_technology

        #: The total vespene value of enemy army units (buildings?) killed
        self.vespene_killed_army = clamp(self.stats[26])

        #: The total vespene value of enemy economy units (buildings?) killed
        self.vespene_killed_economy = clamp(self.stats[27])

        #: The total vespene value of enemy technology research (buildings?) killed
        self.vespene_killed_technology = clamp(self.stats[28])

        #: The total vespene cost of all killed things
        self.vespene_killed = self.vespene_killed_army + self.vespene_killed_economy + self.vespene_killed_technology

        #: The total resource cost of all killed things
        self.resources_killed = self.minerals_killed + self.vespene_killed

        #: The food supply currently used
        self.food_used = clamp(self.stats[29]) / 4096.0

        #: The food supply currently available
        self.food_made = clamp(self.stats[30]) / 4096.0

        #: The total mineral value of all active forces
        self.minerals_used_active_forces = clamp(self.stats[31])

        #: The total vespene value of all active forces
        self.vespene_used_active_forces = clamp(self.stats[32])

        #: Minerals of army value lost to friendly fire
        self.ff_minerals_lost_army = clamp(self.stats[33]) if build >= 26490 else None

        #: Minerals of economy value lost to friendly fire
        self.ff_minerals_lost_economy = clamp(self.stats[34]) if build >= 26490 else None

        #: Minerals of technology value lost to friendly fire
        self.ff_minerals_lost_technology = clamp(self.stats[35]) if build >= 26490 else None

        #: Vespene of army value lost to friendly fire
        self.ff_vespene_lost_army = clamp(self.stats[36]) if build >= 26490 else None

        #: Vespene of economy value lost to friendly fire
        self.ff_vespene_lost_economy = clamp(self.stats[37]) if build >= 26490 else None

        #: Vespene of technology value lost to friendly fire
        self.ff_vespene_lost_technology = clamp(self.stats[38]) if build >= 26490 else None

    def __str__(self):
        return self._str_prefix() + "{0: >15} - Stats Update".format(self.player)


class UnitBornEvent(TrackerEvent):
    """
    Generated when a unit is created in a finished state in the game. Examples include the Marine,
    Zergling, and Zealot (when trained from a gateway). Units that enter the game unfinished (all
    buildings, warped in units) generate a :class:`UnitInitEvent` instead.

    Unfortunately, units that are born do not have events marking their beginnings like
    :class:`UnitInitEvent` and :class:`UnitDoneEvent` do. The closest thing to it are the
    :class:`~sc2reader.event.game.CommandEvent` game events where the command is a train unit
    command.
    """
    def __init__(self, frames, data, build):
        super(UnitBornEvent, self).__init__(frames)

        #: The index portion of the unit id
        self.unit_id_index = data[0]

        #: The recycle portion of the unit id
        self.unit_id_recycle = data[1]

        #: The unique id of the unit being born
        self.unit_id = self.unit_id_index << 18 | self.unit_id_recycle

        #: The unit object that was born
        self.unit = None

        #: The unit type name of the unit being born
        self.unit_type_name = data[2].decode('utf8')

        #: The id of the player that controls this unit.
        self.control_pid = data[3]

        #: The id of the player that pays upkeep for this unit.
        self.upkeep_pid = data[4]

        #: The player object that pays upkeep for this one. 0 means neutral unit
        self.unit_upkeeper = None

        #: The player object that controls this unit. 0 means neutral unit
        self.unit_controller = None

        #: The x coordinate of the center of the born unit's footprint. Only 4 point resolution
        #: prior to Starcraft Patch 2.1.
        self.x = data[5]

        #: The y coordinate of the center of the born unit's footprint. Only 4 point resolution
        #: prior to Starcraft Patch 2.1.
        self.y = data[6]

        #: The map location of the unit birth
        self.location = (self.x, self.y)

        if build < 27950:
            self.x = self.x * 4
            self.y = self.y * 4
            self.location = (self.x, self.y)

    def __str__(self):
        return self._str_prefix() + "{0: >15} - Unit born {1}".format(self.unit_upkeeper, self.unit)


class UnitDiedEvent(TrackerEvent):
    """
    Generated when a unit dies or is removed from the game for any reason. Reasons include
    morphing, merging, and getting killed.
    """
    def __init__(self, frames, data, build):
        super(UnitDiedEvent, self).__init__(frames)

        #: The index portion of the unit id
        self.unit_id_index = data[0]

        #: The recycle portion of the unit id
        self.unit_id_recycle = data[1]

        #: The unique id of the unit being killed
        self.unit_id = self.unit_id_index << 18 | self.unit_id_recycle

        #: The unit object that died
        self.unit = None

        #: Deprecated, see :attr:`killing_player_id`
        self.killer_pid = data[2]

        #: Deprecated, see :attr:`killing_player`
        self.killer = None

        #: The id of the player that killed this unit. None when not available.
        self.killing_player_id = data[2]

        #: The player object of the that killed the unit. Not always available.
        self.killing_player = None

        #: The x coordinate of the center of the dying unit's footprint. Only 4 point resolution
        #: prior to Starcraft Patch 2.1.
        self.x = data[3]

        #: The y coordinate of the center of the dying unit's footprint. Only 4 point resolution
        #: prior to Starcraft Patch 2.1.
        self.y = data[4]

        #: The map location the unit was killed at.
        self.location = (self.x, self.y)

        #: The index portion of the killing unit's id. Available for build 27950+
        self.killing_unit_index = None

        #: The recycle portion of the killing unit's id. Available for build 27950+
        self.killing_unit_recycle = None

        #: The unique id of the unit doing the killing. Available for build 27950+
        self.killing_unit_id = None

        #: A reference to the :class:`Unit` that killed this :class:`Unit`
        self.killing_unit = None

        if build < 27950:
            self.x = self.x * 4
            self.y = self.y * 4
            self.location = (self.x, self.y)
        else:
            # Starcraft patch 2.1 introduced killer unit indexes
            self.killing_unit_index = data[5]
            self.killing_unit_recycle = data[6]
            if self.killing_unit_index:
                self.killing_unit_id = self.killing_unit_index << 18 | self.killing_unit_recycle

    def __str__(self):
        return self._str_prefix() + "{0: >15} - Unit died {1}.".format(self.unit.owner, self.unit)


class UnitOwnerChangeEvent(TrackerEvent):
    """
    Generated when either ownership or control of a unit is changed. Neural Parasite is an example
    of an action that would generate this event.
    """
    def __init__(self, frames, data, build):
        super(UnitOwnerChangeEvent, self).__init__(frames)

        #: The index portion of the unit id
        self.unit_id_index = data[0]

        #: The recycle portion of the unit id
        self.unit_id_recycle = data[1]

        #: The unique id of the unit changing ownership
        self.unit_id = self.unit_id_index << 18 | self.unit_id_recycle

        #: The unit object that is affected by this event
        self.unit = None

        #: The new id of the player that controls this unit.
        self.control_pid = data[2]

        #: The new id of the player that pays upkeep for this unit.
        self.upkeep_pid = data[3]

        #: The player object that pays upkeep for this one. 0 means neutral unit
        self.unit_upkeeper = None

        #: The player object that controls this unit. 0 means neutral unit
        self.unit_controller = None

    def __str__(self):
        return self._str_prefix() + "{0: >15} took {1}".format(self.unit_upkeeper, self.unit)


class UnitTypeChangeEvent(TrackerEvent):
    """
    Generated when the unit's type changes. This generally tracks upgrades to buildings (Hatch,
    Lair, Hive) and mode switches (Sieging Tanks, Phasing prisms, Burrowing roaches). There may
    be some other situations where a unit transformation is a type change and not a new unit.
    """
    def __init__(self, frames, data, build):
        super(UnitTypeChangeEvent, self).__init__(frames)

        #: The index portion of the unit id
        self.unit_id_index = data[0]

        #: The recycle portion of the unit id
        self.unit_id_recycle = data[1]

        #: The unique id of the unit changing type
        self.unit_id = self.unit_id_index << 18 | self.unit_id_recycle

        #: The unit object that was changed
        self.unit = None

        #: The the new unit type name
        self.unit_type_name = data[2].decode('utf8')

    def __str__(self):
        return self._str_prefix() + "{0: >15} - Unit {0} type changed to {1}".format(self.unit.owner, self.unit, self.unit_type_name)


class UpgradeCompleteEvent(TrackerEvent):
    """
    Generated when a player completes an upgrade.
    """
    def __init__(self, frames, data, build):
        super(UpgradeCompleteEvent, self).__init__(frames)

        #: The player that completed the upgrade
        self.pid = data[0]

        #: The Player object that completed the upgrade
        self.player = None

        #: The name of the upgrade
        self.upgrade_type_name = data[1]

        #: The number of times this upgrade as been researched
        self.count = data[2]

    def __str__(self):
        return self._str_prefix() + "{0: >15} - {1}upgrade completed".format(self.player, self.upgrade_type_name)


class UnitInitEvent(TrackerEvent):
    """
    The counter part to :class:`UnitDoneEvent`, generated by the game engine when a unit is
    initiated. This applies only to units which are started in game before they are finished.
    Primary examples being buildings and warp-in units.
    """
    def __init__(self, frames, data, build):
        super(UnitInitEvent, self).__init__(frames)

        #: The index portion of the unit id
        self.unit_id_index = data[0]

        #: The recycle portion of the unit id
        self.unit_id_recycle = data[1]

        #: The unique id of the stated unit
        self.unit_id = self.unit_id_index << 18 | self.unit_id_recycle

        #: The unit object that was started (e.g. started to warp in)
        self.unit = None

        #: The the new unit type name
        self.unit_type_name = data[2].decode('utf8')

        #: The id of the player that controls this unit.
        self.control_pid = data[3]

        #: The id of the player that pays upkeep for this unit.
        self.upkeep_pid = data[4]

        #: The player object that pays upkeep for this one. 0 means neutral unit
        self.unit_upkeeper = None

        #: The player object that controls this unit. 0 means neutral unit
        self.unit_controller = None

        #: The x coordinate of the center of the init unit's footprint. Only 4 point resolution
        #: prior to Starcraft Patch 2.1.
        self.x = data[5]

        #: The y coordinate of the center of the init unit's footprint. Only 4 point resolution
        #: prior to Starcraft Patch 2.1.
        self.y = data[6]

        #: The map location the unit was started at
        self.location = (self.x, self.y)

        if build < 27950:
            self.x = self.x * 4
            self.y = self.y * 4
            self.location = (self.x, self.y)

    def __str__(self):
        return self._str_prefix() + "{0: >15} - Unit initiated {1}".format(self.unit_upkeeper, self.unit)


class UnitDoneEvent(TrackerEvent):
    """
    The counter part to the :class:`UnitInitEvent`, generated by the game engine when an initiated
    unit is completed. E.g. warp-in finished, building finished, morph complete.
    """
    def __init__(self, frames, data, build):
        super(UnitDoneEvent, self).__init__(frames)

        #: The index portion of the unit id
        self.unit_id_index = data[0]

        #: The recycle portion of the unit id
        self.unit_id_recycle = data[1]

        #: The unique id of the finished unit
        self.unit_id = self.unit_id_index << 18 | self.unit_id_recycle

        #: The unit object that was finished
        self.unit = None

    def __str__(self):
        return self._str_prefix() + "{0: >15} - Unit {1} done".format(self.unit.owner, self.unit)


class UnitPositionsEvent(TrackerEvent):
    """
    Generated every 15 seconds. Marks the positions of the first 255 units that were damaged in
    the last interval. If more than 255 units were damaged, then the first 255 are reported and
    the remaining units are carried into the next interval.
    """
    def __init__(self, frames, data, build):
        super(UnitPositionsEvent, self).__init__(frames)

        #: The starting unit index point.
        self.first_unit_index = data[0]

        #: An ordered list of unit/point data interpreted as below.
        self.items = data[1]

        #: A dict mapping of units that had their position updated to their positions
        self.units = dict()

        #: A list of (unit_index, (x,y)) derived from the first_unit_index and items. Prior to
        #: Starcraft Patch 2.1 the coordinates have 4 point resolution. (15,25) recorded as (12,24).
        #: Location prior to any rounding marks the center of the unit footprint.
        self.positions = list()

        unit_index = self.first_unit_index
        for i in range(0, len(self.items), 3):
            unit_index += self.items[i]
            x = self.items[i + 1]
            y = self.items[i + 2]
            if build < 27950:
                x = x * 4
                y = y * 4
            self.positions.append((unit_index, (x, y)))

    def __str__(self):
        return self._str_prefix() + "Unit positions update"

########NEW FILE########
__FILENAME__ = exceptions
# -*- coding: utf-8 -*-
from __future__ import absolute_import, print_function, unicode_literals, division


class SC2ReaderError(Exception):
    pass


class SC2ReaderLocalizationError(SC2ReaderError):
    pass


class CorruptTrackerFileError(SC2ReaderError):
    pass


class MPQError(SC2ReaderError):
    pass


class NoMatchingFilesError(SC2ReaderError):
    pass


class MultipleMatchingFilesError(SC2ReaderError):
    pass


class ReadError(SC2ReaderError):
    def __init__(self, msg, type, location, replay=None,  game_events=[], buffer=None):
        self.__dict__.update(locals())
        super(ReadError, self).__init__(msg)

    def __str__(self):
        return "{0}, Type: {1}".format(self.msg, self.type)


class ParseError(SC2ReaderError):
    pass


class ProcessError(SC2ReaderError):
    pass


class FileError(SC2ReaderError):
    pass

########NEW FILE########
__FILENAME__ = replay
# -*- coding: utf-8 -*-
from __future__ import absolute_import, print_function, unicode_literals, division

import json
from collections import defaultdict

from sc2reader import log_utils
from sc2reader.utils import Length
from sc2reader.factories.plugins.utils import PlayerSelection, GameState, JSONDateEncoder, plugin


@plugin
def toJSON(replay, **user_options):
    options = dict(cls=JSONDateEncoder)
    options.update(user_options)
    obj = toDict()(replay)
    return json.dumps(obj, **options)


@plugin
def toDict(replay):
    # Build observers into dictionary
    observers = list()
    for observer in replay.observers:
        messages = list()
        for message in getattr(observer, 'messages', list()):
            messages.append({
                'time': message.time.seconds,
                'text': message.text,
                'is_public': message.to_all
            })
        observers.append({
            'name': getattr(observer, 'name', None),
            'pid': getattr(observer, 'pid', None),
            'messages': messages,
        })

    # Build players into dictionary
    players = list()
    for player in replay.players:
        messages = list()
        for message in player.messages:
            messages.append({
                'time': message.time.seconds,
                'text': message.text,
                'is_public': message.to_all
            })
        players.append({
            'avg_apm': getattr(player, 'avg_apm', None),
            'color': player.color.__dict__ if hasattr(player, 'color') else None,
            'handicap': getattr(player, 'handicap', None),
            'name': getattr(player, 'name', None),
            'pick_race': getattr(player, 'pick_race', None),
            'pid': getattr(player, 'pid', None),
            'play_race': getattr(player, 'play_race', None),
            'result': getattr(player, 'result', None),
            'type': getattr(player, 'type', None),
            'uid': getattr(player, 'uid', None),
            'url': getattr(player, 'url', None),
            'messages': messages,
        })

    # Consolidate replay metadata into dictionary
    return {
        'region': getattr(replay, 'region', None),
        'map_name': getattr(replay, 'map_name', None),
        'file_time': getattr(replay, 'file_time', None),
        'filehash': getattr(replay, 'filehash', None),
        'unix_timestamp': getattr(replay, 'unix_timestamp', None),
        'date': getattr(replay, 'date', None),
        'utc_date': getattr(replay, 'utc_date', None),
        'speed': getattr(replay, 'speed', None),
        'category': getattr(replay, 'category', None),
        'type': getattr(replay, 'type', None),
        'is_ladder': getattr(replay, 'is_ladder', False),
        'is_private': getattr(replay, 'is_private', False),
        'filename': getattr(replay, 'filename', None),
        'file_time': getattr(replay, 'file_time', None),
        'frames': getattr(replay, 'frames', None),
        'build': getattr(replay, 'build', None),
        'release': getattr(replay, 'release_string', None),
        'game_fps': getattr(replay, 'game_fps', None),
        'game_length': getattr(getattr(replay, 'game_length', None), 'seconds', None),
        'players': players,
        'observers': observers,
        'real_length': getattr(getattr(replay, 'real_length', None), 'seconds', None),
        'real_type': getattr(replay, 'real_type', None),
        'time_zone': getattr(replay, 'time_zone', None),
        'versions': getattr(replay, 'versions', None)
    }


@plugin
def APMTracker(replay):
    """
    Builds ``player.aps`` and ``player.apm`` dictionaries where an action is
    any Selection, Hotkey, or Command event.

    Also provides ``player.avg_apm`` which is defined as the sum of all the
    above actions divided by the number of seconds played by the player (not
    necessarily the whole game) multiplied by 60.
    """
    for player in replay.players:
        player.aps = defaultdict(int)
        player.apm = defaultdict(int)
        player.seconds_played = replay.length.seconds

        for event in player.events:
            if event.name == 'SelectionEvent' or 'CommandEvent' in event.name or 'ControlGroup' in event.name:
                player.aps[event.second] += 1
                player.apm[int(event.second/60)] += 1

            elif event.name == 'PlayerLeaveEvent':
                player.seconds_played = event.second

        if len(player.apm) > 0:
            player.avg_apm = sum(player.aps.values())/float(player.seconds_played)*60
        else:
            player.avg_apm = 0

    return replay


@plugin
def SelectionTracker(replay):
    debug = replay.opt.debug
    logger = log_utils.get_logger(SelectionTracker)

    for person in replay.entities:
        # TODO: A more robust person interface might be nice
        person.selection_errors = 0
        player_selections = GameState(PlayerSelection())
        for event in person.events:
            error = False
            if event.name == 'SelectionEvent':
                selections = player_selections[event.frame]
                control_group = selections[event.control_group].copy()
                error = not control_group.deselect(event.mask_type, event.mask_data)
                control_group.select(event.new_units)
                selections[event.control_group] = control_group
                if debug:
                    logger.info("[{0}] {1} selected {2} units: {3}".format(Length(seconds=event.second), person.name, len(selections[0x0A].objects), selections[0x0A]))

            elif event.name == 'SetToHotkeyEvent':
                selections = player_selections[event.frame]
                selections[event.control_group] = selections[0x0A].copy()
                if debug:
                    logger.info("[{0}] {1} set hotkey {2} to current selection".format(Length(seconds=event.second), person.name, event.hotkey))

            elif event.name == 'AddToHotkeyEvent':
                selections = player_selections[event.frame]
                control_group = selections[event.control_group].copy()
                error = not control_group.deselect(event.mask_type, event.mask_data)
                control_group.select(selections[0x0A].objects)
                selections[event.control_group] = control_group
                if debug:
                    logger.info("[{0}] {1} added current selection to hotkey {2}".format(Length(seconds=event.second), person.name, event.hotkey))

            elif event.name == 'GetFromHotkeyEvent':
                selections = player_selections[event.frame]
                control_group = selections[event.control_group].copy()
                error = not control_group.deselect(event.mask_type, event.mask_data)
                selections[0xA] = control_group
                if debug:
                    logger.info("[{0}] {1} retrieved hotkey {2}, {3} units: {4}".format(Length(seconds=event.second), person.name, event.control_group, len(selections[0x0A].objects), selections[0x0A]))

            else:
                continue

            # TODO: The event level interface here should be improved
            #       Possibly use 'added' and 'removed' unit lists as well
            event.selected = selections[0x0A].objects
            if error:
                person.selection_errors += 1
                if debug:
                    logger.warn("Error detected in deselection mode {0}.".format(event.mask_type))

        person.selection = player_selections
        # Not a real lock, so don't change it!
        person.selection.locked = True

    return replay

########NEW FILE########
__FILENAME__ = utils
# -*- coding: utf-8 -*-
from __future__ import absolute_import, print_function, unicode_literals, division

from bisect import bisect_left
from collections import defaultdict
from datetime import datetime
from functools import wraps
import json

from sc2reader.log_utils import loggable


def plugin(func):
    @wraps(func)
    def wrapper(**options):
        @wraps(func)
        def call(*args, **kwargs):
            opt = kwargs.copy()
            opt.update(options)
            return func(*args, **opt)
        return call
    return wrapper


class JSONDateEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, datetime):
            return obj.strftime("%Y-%m-%d %H:%M:%S")
        return json.JSONEncoder.default(self, obj)


class GameState(dict):
    def __init__(self, initial_state):
        self._frames = list()
        self._frameset = set()
        self[0] = initial_state
        self.locked = False

    def __getitem__(self, frame):
        if frame in self:
            return super(GameState, self).__getitem__(frame)

        # Get the previous frame from our sorted frame list
        # bisect_left returns the left most key where an item is
        # less than or equal to the value in that key. If it is
        # less than we need to subtract 1
        key = bisect_left(self._frames, frame)
        if key == len(self._frames) or self._frames[key] > frame:
            prev_frame = self._frames[key - 1]
        else:
            prev_frame = self._frames[key]

        # If we've locked the game state we don't need deep copies anymore
        if self.locked:
            state = self[prev_frame]
        else:
            # Copy the previous state and use it as our basis here
            state = self[prev_frame]
            if hasattr(state, 'copy'):
                state = state.copy()

        self[frame] = state
        return state

    def __setitem__(self, frame, value):
        if frame not in self._frameset:
            self._frames.insert(bisect_left(self._frames, frame), frame)
            self._frameset.add(frame)

        super(GameState, self).__setitem__(frame, value)


@loggable
class UnitSelection(object):
    def __init__(self, objects=None):
        self.objects = objects or list()

    def select(self, new_objects):
        new_set = set(self.objects+list(new_objects))
        self.objects = sorted(new_set, key=lambda obj: obj.id)

    def deselect(self, mode, data):
        """Returns false if there was a data error when deselecting"""
        size = len(self.objects)

        if mode == 'None':
            return True

        elif mode == 'Mask':
            """ Deselect objects according to deselect mask """
            mask = data
            if len(mask) < size:
                # pad to the right
                mask = mask+[False]*(len(self.objects)-len(mask))

            self.logger.debug("Deselection Mask: {0}".format(mask))
            self.objects = [obj for (slct, obj) in filter(lambda slct_obj: not slct_obj[0], zip(mask, self.objects))]
            return len(mask) <= size

        elif mode == 'OneIndices':
            """ Deselect objects according to indexes """
            clean_data = list(filter(lambda i: i < size, data))
            self.objects = [self.objects[i] for i in range(len(self.objects)) if i not in clean_data]
            return len(clean_data) == len(data)

        elif mode == 'ZeroIndices':
            """ Deselect objects according to indexes """
            clean_data = list(filter(lambda i: i < size, data))
            self.objects = [self.objects[i] for i in clean_data]
            return len(clean_data) == len(data)

        else:
            return False

    def __str__(self):
        return ', '.join(str(obj) for obj in self.objects)

    def copy(self):
        return UnitSelection(self.objects[:])


class PlayerSelection(defaultdict):
    def __init__(self):
        super(PlayerSelection, self).__init__(UnitSelection)

    def copy(self):
        new = PlayerSelection()
        for bank, selection in self.items():
            new[bank] = selection  # UnitSelection(selection.objects[:])
        return new

########NEW FILE########
__FILENAME__ = sc2factory
# -*- coding: utf-8 -*-
from __future__ import absolute_import, print_function, unicode_literals, division

from collections import defaultdict
from io import BytesIO
import os
import sys

try:
    unicode
except NameError:
    basestring = unicode = str

if sys.version_info[0] < 3:
    from urllib2 import urlopen
    from urlparse import urlparse
else:
    from urllib.request import urlopen
    from urllib.parse import urlparse

import re
import time

from sc2reader import utils
from sc2reader import log_utils
from sc2reader.resources import Resource, Replay, Map, GameSummary, Localization


@log_utils.loggable
class SC2Factory(object):
    """The SC2Factory class acts as a generic loader interface for all
    available to sc2reader resources. At current time this includes
    :class:`~sc2reader.resources.Replay` and :class:`~sc2reader.resources.Map` resources. These resources can be
    loaded in both singular and plural contexts with:

        * :meth:`load_replay` - :class:`Replay`
        * :meth:`load_replays` - generator<:class:`Replay`>
        * :meth:`load_map` - :class:`Map`
        * :meth:`load_maps` - : generator<:class:`Map`>

    The load behavior can be configured in three ways:

        * Passing options to the factory constructor
        * Using the :meth:`configure` method of a factory instance
        * Passing overried options into the load method

    See the :meth:`configure` method for more details on configuration
    options.

    Resources can be loaded in the singular context from the following inputs:

    * URLs - Uses the built-in package ``urllib``
    * File path - Uses the built-in method ``open``
    * File-like object - Must implement ``.read()``
    * DepotFiles - Describes remote Battle.net depot resources

    In the plural context the following inputs are acceptable:

    * An iterable of the above inputs
    * Directory path - Uses :meth:`~sc2reader.utils.get_files` with the appropriate extension to fine files.

    """

    _resource_name_map = dict(replay=Replay, map=Map)

    default_options = {
        Resource: {'debug': False},
        Replay: {'load_level': 4, 'load_map': False},
    }

    def __init__(self, **options):
        self.plugins = list()

        # Bootstrap with the default options
        self.options = defaultdict(dict)
        for cls, options in self.default_options.items():
            self.options[cls] = options.copy()

        # Then configure with the options passed in
        self.configure(**options)

    # Primary Interface
    def load_replay(self, source, options=None, **new_options):
        """Loads a single sc2replay file. Accepts file path, url, or file object."""
        return self.load(Replay, source, options, **new_options)

    def load_replays(self, sources, options=None, **new_options):
        """Loads a collection of sc2replay files, returns a generator."""
        return self.load_all(Replay, sources, options, extension='SC2Replay', **new_options)

    def load_localization(self, source, options=None, **new_options):
        """Loads a single s2ml file. Accepts file path, url, or file object."""
        return self.load(Localization, source, options, **new_options)

    def load_localizations(self, sources, options=None, **new_options):
        """Loads a collection of s2ml files, returns a generator."""
        return self.load_all(Localization, sources, options, extension='s2ml', **new_options)

    def load_map(self, source, options=None, **new_options):
        """Loads a single s2ma file. Accepts file path, url, or file object."""
        return self.load(Map, source, options, **new_options)

    def load_maps(self, sources, options=None, **new_options):
        """Loads a collection of s2ma files, returns a generator."""
        return self.load_all(Map, sources, options, extension='s2ma', **new_options)

    def load_game_summary(self, source, options=None, **new_options):
        """Loads a single s2gs file. Accepts file path, url, or file object."""
        return self.load(GameSummary, source, options, **new_options)

    def load_game_summaries(self, sources, options=None, **new_options):
        """Loads a collection of s2gs files, returns a generator."""
        return self.load_all(GameSummary, sources, options, extension='s2gs', **new_options)

    def configure(self, cls=None, **options):
        """ Configures the factory to use the supplied options. If cls is specified
            the options will only be applied when loading that class"""
        if isinstance(cls, basestring):
            cls = self._resource_name_map.get[cls.lower()]
        cls = cls or Resource
        self.options[cls].update(options)

    def reset(self):
        "Resets the options to factory defaults"
        self.options = defaultdict(dict)

    def register_plugin(self, cls, plugin):
        "Registers the given Plugin to be run on classes of the supplied name."
        if isinstance(cls, basestring):
            cls = self._resource_name_map.get(cls.lower(), Resource)
        self.plugins.append((cls, plugin))

    # Support Functions
    def load(self, cls, source, options=None, **new_options):
        options = options or self._get_options(cls, **new_options)
        resource, filename = self._load_resource(source, options=options)
        return self._load(cls, resource, filename=filename, options=options)

    def load_all(self, cls, sources, options=None, **new_options):
        options = options or self._get_options(cls, **new_options)
        for resource, filename in self._load_resources(sources, options=options):
            yield self._load(cls, resource, filename=filename, options=options)

    # Internal Functions
    def _load(self, cls, resource, filename, options):
        obj = cls(resource, filename=filename, factory=self, **options)
        for plugin in options.get('plugins', self._get_plugins(cls)):
            obj = plugin(obj)
        return obj

    def _get_plugins(self, cls):
        plugins = list()
        for ext_cls, plugin in self.plugins:
            if issubclass(cls, ext_cls):
                plugins.append(plugin)
        return plugins

    def _get_options(self, cls, **new_options):
        options = utils.AttributeDict()
        for opt_cls, cls_options in self.options.items():
            if issubclass(cls, opt_cls):
                options.update(cls_options)
        options.update(new_options)
        return options

    def _load_resources(self, resources, options=None, **new_options):
        """Collections of resources or a path to a directory"""
        options = options or self._get_options(Resource, **new_options)

        # Path to a folder, retrieve all relevant files as the collection
        if isinstance(resources, basestring):
            resources = utils.get_files(resources, **options)

        for resource in resources:
            yield self._load_resource(resource, options=options)

    def load_remote_resource_contents(self, resource, **options):
        self.logger.info("Fetching remote resource: "+resource)
        return urlopen(resource).read()

    def load_local_resource_contents(self, location, **options):
        # Extract the contents so we can close the file
        with open(location, 'rb') as resource_file:
            return resource_file.read()

    def _load_resource(self, resource, options=None, **new_options):
        """http links, filesystem locations, and file-like objects"""
        options = options or self._get_options(Resource, **new_options)

        if isinstance(resource, utils.DepotFile):
            resource = resource.url

        if isinstance(resource, basestring):
            if re.match(r'https?://', resource):
                contents = self.load_remote_resource_contents(resource, **options)

            else:
                directory = options.get('directory', '')
                location = os.path.join(directory, resource)
                contents = self.load_local_resource_contents(location, **options)

            # BytesIO implements a fuller file-like object
            resource_name = resource
            resource = BytesIO(contents)

        else:
            # Totally not designed for large files!!
            # We need a multiread resource, so wrap it in BytesIO
            if not hasattr(resource, 'seek'):
                resource = BytesIO(resource.read())

            resource_name = getattr(resource, 'name', 'Unknown')

        if options.get('verbose', None):
            print(resource_name)

        return (resource, resource_name)


class CachedSC2Factory(SC2Factory):

    def get_remote_cache_key(self, remote_resource):
        # Strip the port and use the domain as the bucket
        # and use the full path as the key
        parseresult = urlparse(remote_resource)
        bucket = re.sub(r':.*', '', parseresult.netloc)
        key = parseresult.path.strip('/')
        return (bucket, key)

    def load_remote_resource_contents(self, remote_resource, **options):
        cache_key = self.get_remote_cache_key(remote_resource)
        if not self.cache_has(cache_key):
            resource = super(CachedSC2Factory, self).load_remote_resource_contents(remote_resource, **options)
            self.cache_set(cache_key, resource)
        else:
            resource = self.cache_get(cache_key)
        return resource

    def cache_has(self, cache_key):
        raise NotImplemented()

    def cache_get(self, cache_key):
        raise NotImplemented()

    def cache_set(self, cache_key, value):
        raise NotImplemented()


class FileCachedSC2Factory(CachedSC2Factory):
    """
    :param cache_dir: Local directory to cache files in.

    Extends :class:`SC2Factory`.

    Caches remote depot resources on the file system in the ``cache_dir``.
    """
    def __init__(self, cache_dir, **options):
        super(FileCachedSC2Factory, self).__init__(**options)
        self.cache_dir = os.path.abspath(cache_dir)
        if not os.path.isdir(self.cache_dir):
            raise ValueError("cache_dir ({0}) must be an existing directory.".format(self.cache_dir))
        elif not os.access(self.cache_dir, os.F_OK | os.W_OK | os.R_OK):
            raise ValueError("Must have read/write access to {0} for local file caching.".format(self.cache_dir))

    def cache_has(self, cache_key):
        return os.path.exists(self.cache_path(cache_key))

    def cache_get(self, cache_key, **options):
        return self.load_local_resource_contents(self.cache_path(cache_key), **options)

    def cache_set(self, cache_key, value):
        cache_path = self.cache_path(cache_key)
        bucket_dir = os.path.dirname(cache_path)
        if not os.path.exists(bucket_dir):
            os.makedirs(bucket_dir)

        with open(cache_path, 'wb') as out:
            out.write(value)

    def cache_path(self, cache_key):
        return os.path.join(self.cache_dir, *(cache_key))


class DictCachedSC2Factory(CachedSC2Factory):
    """
    :param cache_max_size: The max number of cache entries to hold in memory.

    Extends :class:`SC2Factory`.

    Caches remote depot resources in memory. Does not write to the file system.
    The cache is effectively cleared when the process exits.
    """
    def __init__(self, cache_max_size=0, **options):
        super(DictCachedSC2Factory, self).__init__(**options)
        self.cache_dict = dict()
        self.cache_used = dict()
        self.cache_max_size = cache_max_size

    def cache_set(self, cache_key, value):
        if self.cache_max_size and len(self.cache_dict) >= self.cache_max_size:
            oldest_cache_key = min(self.cache_used.items(), key=lambda e: e[1])[0]
            del self.cache_used[oldest_cache_key]
            del self.cache_dict[oldest_cache_key]
        self.cache_dict[cache_key] = value
        self.cache_used[cache_key] = time.time()

    def cache_get(self, cache_key):
        self.cache_used[cache_key] = time.time()
        return self.cache_dict[cache_key]

    def cache_has(self, cache_key):
        return cache_key in self.cache_dict


class DoubleCachedSC2Factory(DictCachedSC2Factory, FileCachedSC2Factory):
    """
    :param cache_dir: Local directory to cache files in.
    :param cache_max_size: The max number of cache entries to hold in memory.

    Extends :class:`SC2Factory`.

    Caches remote depot resources to the file system AND holds a subset of them
    in memory for more efficient access.
    """
    def __init__(self, cache_dir, cache_max_size=0, **options):
        super(DoubleCachedSC2Factory, self).__init__(cache_max_size, cache_dir=cache_dir, **options)

    def load_remote_resource_contents(self, remote_resource, **options):
        cache_key = self.get_remote_cache_key(remote_resource)

        if DictCachedSC2Factory.cache_has(self, cache_key):
            return DictCachedSC2Factory.cache_get(self, cache_key)

        if not FileCachedSC2Factory.cache_has(self, cache_key):
            resource = SC2Factory.load_remote_resource_contents(self, remote_resource, **options)
            FileCachedSC2Factory.cache_set(self, cache_key, resource)
        else:
            resource = FileCachedSC2Factory.cache_get(self, cache_key)

        DictCachedSC2Factory.cache_set(self, cache_key, resource)
        return resource

########NEW FILE########
__FILENAME__ = log_utils
# -*- coding: utf-8 -*-
from __future__ import absolute_import, print_function, unicode_literals, division

import logging

try:
    unicode
except NameError:
    basestring = unicode = str

try:
    from logging import NullHandler
except ImportError:
    # Copied from the Python 2.7 source code.
    class NullHandler(logging.Handler):
        """
        This handler does nothing. It's intended to be used to avoid the
        "No handlers could be found for logger XXX" one-off warning. This is
        important for library code, which may contain code to log events. If a user
        of the library does not configure logging, the one-off warning might be
        produced; to avoid this, the library developer simply needs to instantiate
        a NullHandler and add it to the top-level logger of the library module or
        package.
        """
        def handle(self, record):
            pass

        def emit(self, record):
            pass

        def createLock(self):
            self.lock = None

LEVEL_MAP = dict(
    DEBUG=logging.DEBUG,
    INFO=logging.INFO,
    WARN=logging.WARN,
    ERROR=logging.ERROR,
    CRITICAL=logging.CRITICAL
)


def setup():
    logging.getLogger('sc2reader').addHandler(NullHandler())


def log_to_file(filename, level='WARN', format=None, datefmt=None, **options):
    add_log_handler(logging.FileHandler(filename, **options), level, format, datefmt)


def log_to_console(level='WARN', format=None, datefmt=None, **options):
    add_log_handler(logging.StreamHandler(**options), level, format, datefmt)


def add_log_handler(handler, level='WARN', format=None, datefmt=None):
    handler.setFormatter(logging.Formatter(format, datefmt))

    if isinstance(level, basestring):
        level = LEVEL_MAP[level]

    logger = logging.getLogger('sc2reader')
    logger.setLevel(level)
    logger.addHandler(handler)


def get_logger(entity):
    """
        Retrieves loggers from the enties fully scoped name.

            get_logger(Replay)     -> sc2reader.replay.Replay
            get_logger(get_logger) -> sc2reader.utils.get_logger

        :param entity: The entity for which we want a logger.
    """
    try:
        return logging.getLogger(entity.__module__+'.'+entity.__name__)

    except AttributeError:
        raise TypeError("Cannot retrieve logger for {0}.".format(entity))


def loggable(cls):
    cls.logger = get_logger(cls)
    return cls

########NEW FILE########
__FILENAME__ = objects
# -*- coding: utf-8 -*-
from __future__ import absolute_import, print_function, unicode_literals, division

import hashlib
import math
from collections import namedtuple

from sc2reader import utils, log_utils
from sc2reader.decoders import ByteDecoder
from sc2reader.constants import *

Location = namedtuple('Location', ['x', 'y'])


class Team(object):
    """
    The team object primarily a container object for organizing :class:`Player`
    objects with some metadata. As such, it implements iterable and can be
    looped over like a list.

    :param interger number: The team number as recorded in the replay
    """

    #: A unique hash identifying the team of players
    hash = str()

    #: The team number as recorded in the replay
    number = int()

    #: A list of the :class:`Player` objects on the team
    players = list()

    #: The result of the game for this team.
    #: One of "Win", "Loss", or "Unknown"
    result = str()

    def __init__(self, number):
        self.number = number
        self.players = list()
        self.result = "Unknown"

    def __iter__(self):
        return self.players.__iter__()

    @property
    def lineup(self):
        """
        A string representation of the team play races like PP or TPZZ. Random
        pick races are not reflected in this string
        """
        return ''.join(sorted(p.play_race[0].upper() for p in self.players))

    @property
    def hash(self):
        raw_hash = ','.join(sorted(p.url for p in self.players))
        return hashlib.sha256(raw_hash).hexdigest()

    def __str__(self):
        return "Team {0}: {1}".format(self.number, ", ".join([str(p) for p in self.players]))

    def __repr__(self):
        return str(self)


@log_utils.loggable
class Attribute(object):

    def __init__(self, header, attr_id, player, value):
        self.header = header
        self.id = attr_id
        self.player = player

        if self.id not in LOBBY_PROPERTIES:
            self.logger.info("Unknown attribute id: {0}".format(self.id))
            self.name = "Unknown"
            self.value = None
        else:
            self.name, lookup = LOBBY_PROPERTIES[self.id]
            self.value = lookup[value.strip("\x00 ")[::-1]]

    def __repr__(self):
        return str(self)

    def __str__(self):
        return "[{0}] {1}: {2}".format(self.player, self.name, self.value)


class Entity(object):
    """
    :param integer sid: The entity's unique slot id.
    :param dict slot_data: The slot data associated with this entity
    """
    def __init__(self, sid, slot_data):
        #: The entity's unique in-game slot id
        self.sid = int(sid)

        #: The entity's replay.initData slot data
        self.slot_data = slot_data

        #: The player's handicap as set prior to game start, ranges from 50-100
        self.handicap = slot_data['handicap']

        #: The entity's team number. None for observers
        self.team_id = slot_data['team_id']+1

        #: A flag indicating if the person is a human or computer
        #: Really just a shortcut for isinstance(entity, User)
        self.is_human = slot_data['control'] == 2

        #: A flag indicating the entity's observer status.
        #: Really just a shortcut for isinstance(entity, Observer).
        self.is_observer = slot_data['observe'] != 0

        #: A flag marking this entity as a referee (can talk to players)
        self.is_referee = slot_data['observe'] == 2

        #: The unique Battle.net account identifier in the form of
        #: <region_id>-S2-<subregion>-<toon_id>
        self.toon_handle = slot_data['toon_handle']

        toon_handle = self.toon_handle or "0-S2-0-0"
        parts = toon_handle.split("-")

        #: The Battle.net region the entity is registered to
        self.region = GATEWAY_LOOKUP[int(parts[0])]

        #: The Battle.net subregion the entity is registered to
        self.subregion = int(parts[2])

        #: The Battle.net acount identifier. Used to construct the
        #: bnet profile url. This value can be zero for games
        #: played offline when a user was not logged in to battle.net.
        self.toon_id = int(parts[3])

        #: A list of :class:`Event` objects representing all the game events
        #: generated by the person over the course of the game
        self.events = list()

        #: A list of :class:`~sc2reader.events.message.ChatEvent` objects representing all of the chat
        #: messages the person sent during the game
        self.messages = list()

    def format(self, format_string):
        return format_string.format(**self.__dict__)


class Player(object):
    """
    :param integer pid: The player's unique player id.
    :param dict detail_data: The detail data associated with this player
    :param dict attribute_data: The attribute data associated with this player
    """
    def __init__(self, pid, detail_data, attribute_data):
        #: The player's unique in-game player id
        self.pid = int(pid)

        #: The replay.details data on this player
        self.detail_data = detail_data

        #: The replay.attributes.events data on this player
        self.attribute_data = attribute_data

        #: The player result, one of "Win", "Loss", or None
        self.result = None
        if detail_data['result'] == 1:
            self.result = "Win"
        elif detail_data['result'] == 2:
            self.result = "Loss"

        #: A reference to the player's :class:`Team` object
        self.team = None

        #: The race the player picked prior to the game starting.
        #: One of Protoss, Terran, Zerg, Random
        self.pick_race = attribute_data.get('Race', 'Unknown')

        #: The difficulty setting for the player. Always Medium for human players.
        #: Very Easy, Easy, Medium, Hard, Harder, Very hard, Elite, Insane,
        #: Cheater 2 (Resources), Cheater 1 (Vision)
        self.difficulty = attribute_data.get('Difficulty', 'Unknown')

        #: The race the player played the game with.
        #: One of Protoss, Terran, Zerg
        self.play_race = LOCALIZED_RACES.get(detail_data['race'], detail_data['race'])

        #: A reference to a :class:`~sc2reader.utils.Color` object representing the player's color
        self.color = utils.Color(**detail_data['color'])

        #: A list of references to the :class:`~sc2reader.data.Unit` objects the player had this game
        self.units = list()

        #: A list of references to the :class:`~sc2reader.data.Unit` objects that the player killed this game
        self.killed_units = list()

        #: The Battle.net region the entity is registered to
        self.region = GATEWAY_LOOKUP[detail_data['bnet']['region']]

        #: The Battle.net subregion the entity is registered to
        self.subregion = detail_data['bnet']['subregion']

        #: The Battle.net acount identifier. Used to construct the
        #: bnet profile url. This value can be zero for games
        #: played offline when a user was not logged in to battle.net.
        self.toon_id = detail_data['bnet']['uid']


class User(object):
    """
    :param integer uid: The user's unique user id
    :param dict init_data: The init data associated with this user
    """
    #: The Battle.net profile url template
    URL_TEMPLATE = "http://{region}.battle.net/sc2/en/profile/{toon_id}/{subregion}/{name}/"

    def __init__(self, uid, init_data):
        #: The user's unique in-game user id
        self.uid = int(uid)

        #: The replay.initData data on this user
        self.init_data = init_data

        #: The user's Battle.net clan tag at the time of the game
        self.clan_tag = init_data['clan_tag']

        #: The user's Battle.net name at the time of the game
        self.name = init_data['name']

        #: The user's combined Battle.net race levels
        self.combined_race_levels = init_data['combined_race_levels']

        #: The highest 1v1 league achieved by the user in the current season with 1 as Bronze and
        #: 7 as Grandmaster. 8 seems to indicate that there is no current season 1v1 ranking.
        self.highest_league = init_data['highest_league']

        #: A flag indicating if this person was the one who recorded the game.
        #: This is deprecated because it doesn't actually work.
        self.recorder = None

    @property
    def url(self):
        """The player's formatted Battle.net profile url"""
        return self.URL_TEMPLATE.format(**self.__dict__)  # region=self.region, toon_id=self.toon_id, subregion=self.subregion, name=self.name.('utf8'))


class Observer(Entity, User):
    """ Extends :class:`Entity` and :class:`User`.

    :param integer sid: The entity's unique slot id.
    :param dict slot_data: The slot data associated with this entity
    :param integer uid: The user's unique user id
    :param dict init_data: The init data associated with this user
    :param integer pid: The player's unique player id.
    """
    def __init__(self, sid, slot_data, uid, init_data, pid):
        Entity.__init__(self, sid, slot_data)
        User.__init__(self, uid, init_data)

        #: The player id of the observer. Only meaningful in pre 2.0.4 replays
        self.pid = pid

    def __str__(self):
        return "Observer {0} - {1}".format(self.uid, self.name)

    def __repr__(self):
        return str(self)


class Computer(Entity, Player):
    """ Extends :class:`Entity` and :class:`Player`

    :param integer sid: The entity's unique slot id.
    :param dict slot_data: The slot data associated with this entity
    :param integer pid: The player's unique player id.
    :param dict detail_data: The detail data associated with this player
    :param dict attribute_data: The attribute data associated with this player
    """
    def __init__(self, sid, slot_data, pid, detail_data, attribute_data):
        Entity.__init__(self, sid, slot_data)
        Player.__init__(self, pid, detail_data, attribute_data)

        #: The auto-generated in-game name for this computer player
        self.name = detail_data['name']

    def __str__(self):
        return "Player {0} - {1} ({2})".format(self.pid, self.name, self.play_race)

    def __repr__(self):
        return str(self)


class Participant(Entity, User, Player):
    """ Extends :class:`Entity`, :class:`User`, and :class:`Player`

    :param integer sid: The entity's unique slot id.
    :param dict slot_data: The slot data associated with this entity
    :param integer uid: The user's unique user id
    :param dict init_data: The init data associated with this user
    :param integer pid: The player's unique player id.
    :param dict detail_data: The detail data associated with this player
    :param dict attribute_data: The attribute data associated with this player
    """
    def __init__(self, sid, slot_data, uid, init_data, pid, detail_data, attribute_data):
        Entity.__init__(self, sid, slot_data)
        User.__init__(self, uid, init_data)
        Player.__init__(self, pid, detail_data, attribute_data)

    def __str__(self):
        return "Player {0} - {1} ({2})".format(self.pid, self.name, self.play_race)

    def __repr__(self):
        return str(self)


class PlayerSummary():
    """
    Resents a player as loaded from a :class:`~sc2reader.resources.GameSummary`
    file.
    """

    #: The index of the player in the game
    pid = int()

    #: The index of the players team in the game
    teamid = int()

    #: The race the player played in the game.
    play_race = str()

    #: The race the player picked in the lobby.
    pick_race = str()

    #: If the player is a computer
    is_ai = False

    #: If the player won the game
    is_winner = False

    #: Battle.Net id of the player
    bnetid = int()

    #: Subregion id of player
    subregion = int()

    #: The player's region, such as us, eu, sea
    region = str()

    #: unknown1
    unknown1 = int()

    #: unknown2
    unknown2 = dict()

    #: :class:`Graph` of player army values over time (seconds)
    army_graph = None

    #: :class:`Graph` of player income over time (seconds)
    income_graph = None

    #: Stats from the game in a dictionary
    stats = dict()

    def __init__(self, pid):
        self.unknown2 = dict()
        self.pid = pid

    def __str__(self):
        if not self.is_ai:
            return 'User {0}-S2-{1}-{2}'.format(self.region.upper(), self.subregion, self.bnetid)
        else:
            return 'AI ({0})'.format(self.play_race)

    def __repr__(self):
        return str(self)

    def get_stats(self):
        s = ''
        for k in self.stats:
            s += '{0}: {1}\n'.format(self.stats_pretty_names[k], self.stats[k])
        return s.strip()


BuildEntry = namedtuple('BuildEntry', ['supply', 'total_supply', 'time', 'order', 'build_index'])


# TODO: Are there libraries with classes like this in them
class Graph():
    """
    A class to represent a graph on the score screen. Derived from data in the
    :class:`~sc2reader.resources.GameSummary` file.
    """

    #: Times in seconds on the x-axis of the graph
    times = list()

    #: Values on the y-axis of the graph
    values = list()

    def __init__(self, x, y, xy_list=None):
        self.times = list()
        self.values = list()

        if xy_list:
            for x, y in xy_list:
                self.times.append(x)
                self.values.append(y)
        else:
            self.times = x
            self.values = y

    def as_points(self):
        """ Get the graph as a list of (x, y) tuples """
        return list(zip(self.times, self.values))

    def __str__(self):
        return "Graph with {0} values".format(len(self.times))


class MapInfoPlayer(object):
    """
    Describes the player data as found in the MapInfo document of SC2Map archives.
    """
    def __init__(self, pid, control, color, race, unknown, start_point, ai, decal):
        #: The pid of the player
        self.pid = pid

        #: The controller of the player, one of:
        #:
        #: * 0 = Default?
        #: * 1 = User
        #: * 2 = Computer
        #: * 3 = Neutral
        #: * 4 = Hostile
        #: * More?
        #:
        self.control = control

        #: The color of the player, one of:
        #:
        #: * 0xffffffff = (Any)
        #: * 0 = White
        #: * 1 = Red
        #: * 2 = Blue
        #: * 3 = Teal
        #: * 4 = Purple
        #: * 5 = Yellow
        #: * 6 = Orange
        #: * 7 = Green
        #: * 8 = Pink
        #: * 9 = Violet
        #: * 10 = Light Grey
        #: * 11 = Dark Green
        #: * 12 = Brown
        #: * 13 = Light Green
        #: * 14 = Dark Grey
        #: * 15 = Lavender
        #:
        self.color = color

        #: The player race, "" for unset
        self.race = race

        #: Unknown player setting
        self.unknown = unknown

        #: The point index of the player start location; 0 = random
        self.start_point = start_point

        #: The AI to use
        self.ai = ai

        #: The player decal
        self.decal = decal


@log_utils.loggable
class MapInfo(object):
    """
    Represents the data encoded into the MapInfo file inside every SC2Map archive
    """
    def __init__(self, contents):
        # According to http://www.galaxywiki.net/MapInfo_(File_Format)
        # With a couple small changes for version 0x20+
        data = ByteDecoder(contents, endian='LITTLE')
        magic = data.read_string(4)
        if magic != 'MapI':
            self.logger.warn("Invalid MapInfo file: {0}".format(magic))
            return

        #: The map info file format version
        self.version = data.read_uint32()
        if self.version >= 0x18:
            self.unknown1 = data.read_uint32()
            self.unknown2 = data.read_uint32()

        #: The full map width
        self.width = data.read_uint32()

        #: The full map height
        self.height = data.read_uint32()

        #: Small map preview type: 0 = None, 1 = Minimap, 2 = Custom
        self.small_preview_type = data.read_uint32()

        #: (Optional) Small map preview path; relative to root of map archive
        self.small_preview_path = str()
        if self.small_preview_type == 2:
            self.small_preview_path = data.read_cstring()

        #: Large map preview type: 0 = None, 1 = Minimap, 2 = Custom
        self.large_preview_type = data.read_uint32()

        #: (Optional) Large map preview path; relative to root of map archive
        self.large_preview_path = str()
        if self.large_preview_type == 2:
            self.large_preview_path = data.read_cstring()

        if self.version >= 0x1f:
            self.unknown3 = data.read_cstring()
            self.unknown4 = data.read_uint32()

        self.unknown5 = data.read_uint32()

        #: The type of fog of war used on the map
        self.fog_type = data.read_cstring()

        #: The tile set used on the map
        self.tile_set = data.read_cstring()

        #: The left bounds for the camera. This value is 7 less than the value shown in the editor.
        self.camera_left = data.read_uint32()

        #: The bottom bounds for the camera. This value is 4 less than the value shown in the editor.
        self.camera_bottom = data.read_uint32()

        #: The right bounds for the camera. This value is 7 more than the value shown in the editor.
        self.camera_right = data.read_uint32()

        #: The top bounds for the camera. This value is 4 more than the value shown in the editor.
        self.camera_top = data.read_uint32()

        #: The map base height (what is that?). This value is 4096*Base Height in the editor (giving a decimal value).
        self.base_height = data.read_uint32()/4096

        #: Load screen type: 0 = default, 1 = custom
        self.load_screen_type = data.read_uint32()

        #: (Optional) Load screen image path; relative to root of map archive
        self.load_screen_path = data.read_cstring()

        #: Unknown string, usually empty
        self.unknown6 = data.read_bytes(data.read_uint16()).decode('utf8')

        #: Load screen image scaling strategy: 0 = normal, 1 = aspect scaling, 2 = stretch the image.
        self.load_screen_scaling = data.read_uint32()

        #: The text position on the loading screen. One of:
        #:
        #: * 0xffffffff = (Default)
        #: * 0 = Top Left
        #: * 1 = Top
        #: * 2 = Top Right
        #: * 3 = Left
        #: * 4 = Center
        #: * 5 = Right
        #: * 6 = Bottom Left
        #: * 7 = Bottom
        #: * 8 = Bottom Right
        #:
        self.text_position = data.read_uint32()

        #: Loading screen text position offset x
        self.text_position_offset_x = data.read_uint32()

        #: Loading screen text position offset y
        self.text_position_offset_y = data.read_uint32()

        #: Loading screen text size x
        self.text_position_size_x = data.read_uint32()

        #: Loading screen text size y
        self.text_position_size_y = data.read_uint32()

        #: A bit array of flags with the following options (possibly incomplete)
        #:
        #: * 0x00000001 = Disable Replay Recording
        #: * 0x00000002 = Wait for Key (Loading Screen)
        #: * 0x00000004 = Disable Trigger Preloading
        #: * 0x00000008 = Enable Story Mode Preloading
        #: * 0x00000010 = Use Horizontal Field of View
        #:
        self.data_flags = data.read_uint32()

        self.unknown7 = data.read_uint32()

        if self.version >= 0x19:
            self.unknown8 = data.read_bytes(8)

        if self.version >= 0x1f:
            self.unknown9 = data.read_bytes(9)

        if self.version >= 0x20:
            self.unknown10 = data.read_bytes(4)

        #: The number of players enabled via the data editor
        self.player_count = data.read_uint32()

        #: A list of references to :class:`MapInfoPlayer` objects
        self.players = list()
        for i in range(self.player_count):
            self.players.append(MapInfoPlayer(
                pid=data.read_uint8(),
                control=data.read_uint32(),
                color=data.read_uint32(),
                race=data.read_cstring(),
                unknown=data.read_uint32(),
                start_point=data.read_uint32(),
                ai=data.read_uint32(),
                decal=data.read_cstring(),
            ))

        #: A list of the start location point indexes used in Basic Team Settings.
        #: The editor limits these to only Start Locations and not regular points.
        self.start_locations = list()
        for i in range(data.read_uint32()):
            self.start_locations.append(data.read_uint32())

        #: The number of start locations used
        self.start_location_used = data.read_uint32()

        #: The number of alliance flags encoded in :attr:`alliance_flags`.
        self.alliance_flags_length = data.read_uint32()
        # A set bit (1) indicates that the pair of Start Locations are to be allied.
        # bit = 1; // Set up a bitmask
        # // i will be the first Start Location in the Point Indexes array
        # // j will the the Start Location after i
        # for(i=0;i< Start Location Count;i++){
        #    for(j=i+1;j < Start Location Count;j++){ // set j, and then iterate through the rest
        #       bit <<= 1; // Shift left to move the mask to the next bit.
        #       if((Team Enemy Flags & bit) != 0) { // These start locations are allies
        #          // Add more to compensate for byte boundaries. This array can get big.
        #       }
        #    }
        # }
        #: A bit array of flags mapping out the player alliances
        self.alliance_flags = data.read_uint(int(math.ceil(self.alliance_flags_length/8.0)))

        #: A list of the advanced start location point indexes used in Advanced Team Settings.
        #: The editor limits these to only Start Locations and not regular points.
        self.advanced_start_locations = list()
        for i in range(data.read_uint32()):
            # point index for each start location used
            self.advanced_start_locations.append(data.read_uint32())

        #: A list of bit arrays marking which start locations below to which team.
        self.advanced_teams_flags = list()
        for i in range(data.read_uint32()):
            # TODO:
            # One set for each team. Each bit corresponds with the Point Indexes
            # array index (i.e., bit 0 is PointIndexes[0], bit1 is PointIndex[1],
            # etc.). If the bit is set, that start location is a part of that team.
            self.advanced_teams_flags.append(data.read_uint32())

        #: Possibly "number of teams used"? Similar to "start locations used"
        self.advanced_teams_count2 = data.read_uint32()

        #: The number of enemy flags encoded in :attr:`enemy_flags`.
        self.enemy_flags_length = data.read_uint32()
        # A set bit (1) indicates that the pair of teams are to be enemies.
        # bit = 1; // Set up a bitmask
        # // i will be the first Team in the Team Members array.
        # // j will be the Team that comes after i
        # for(i=0;i< Team Count;i++){
        #    for(j=i+1;j < Team Count;j++){ // set j, and then iterate through the rest
        #       bit <<= 1; // Shift left to move the mask to the next bit.
        #       if((Team Enemy Flags & bit) != 0) { // These teams are enemies
        #          // Add more code to compensate for byte boundaries.
        #       }
        #    }
        # }
        #: A bit array of flags mapping out the player enemies.
        self.enemy_flags = data.read_uint(int(math.ceil(self.enemy_flags_length/8.0)))

        if data.length != data.tell():
            self.logger.warn("Not all of the MapInfo file was read!")

    def __str__(self):
        return self.map_name

########NEW FILE########
__FILENAME__ = readers
# -*- coding: utf-8 -*-
from __future__ import absolute_import, print_function, unicode_literals, division

import struct

from sc2reader.exceptions import ParseError, ReadError
from sc2reader.objects import *
from sc2reader.events.game import *
from sc2reader.events.message import *
from sc2reader.events.tracker import *
from sc2reader.utils import DepotFile
from sc2reader.decoders import BitPackedDecoder, ByteDecoder


class InitDataReader(object):
    def __call__(self, data, replay):
        data = BitPackedDecoder(data)
        result = dict(
            user_initial_data=[dict(
                name=data.read_aligned_string(data.read_uint8()),
                clan_tag=data.read_aligned_string(data.read_uint8()) if replay.base_build >= 24764 and data.read_bool() else None,
                clan_logo=DepotFile(data.read_aligned_bytes(40)) if replay.base_build >= 27950 and data.read_bool() else None,
                highest_league=data.read_uint8() if replay.base_build >= 24764 and data.read_bool() else None,
                combined_race_levels=data.read_uint32() if replay.base_build >= 24764 and data.read_bool() else None,
                random_seed=data.read_uint32(),
                race_preference=data.read_uint8() if data.read_bool() else None,
                team_preference=data.read_uint8() if replay.base_build >= 16561 and data.read_bool() else None,
                test_map=data.read_bool(),
                test_auto=data.read_bool(),
                examine=data.read_bool() if replay.base_build >= 21955 else None,
                custom_interface=data.read_bool() if replay.base_build >= 24764 else None,
                observe=data.read_bits(2),
            ) for i in range(data.read_bits(5))],

            game_description=dict(
                random_value=data.read_uint32(),
                game_cache_name=data.read_aligned_string(data.read_bits(10)),
                game_options=dict(
                    lock_teams=data.read_bool(),
                    teams_together=data.read_bool(),
                    advanced_shared_control=data.read_bool(),
                    random_races=data.read_bool(),
                    battle_net=data.read_bool(),
                    amm=data.read_bool(),
                    competitive=data.read_bool(),
                    no_victory_or_defeat=data.read_bool(),
                    fog=data.read_bits(2),
                    observers=data.read_bits(2),
                    user_difficulty=data.read_bits(2),
                    client_debug_flags=data.read_uint64() if replay.base_build >= 22612 else None,
                ),
                game_speed=data.read_bits(3),
                game_type=data.read_bits(3),
                max_users=data.read_bits(5),
                max_observers=data.read_bits(5),
                max_players=data.read_bits(5),
                max_teams=data.read_bits(4)+1,
                max_colors=data.read_bits(6) if replay.base_build >= 17266 else data.read_bits(5)+1,
                max_races=data.read_uint8()+1,
                max_controls=data.read_uint8()+(0 if replay.base_build >= 26490 else 1),
                map_size_x=data.read_uint8(),
                map_size_y=data.read_uint8(),
                map_file_sync_checksum=data.read_uint32(),
                map_file_name=data.read_aligned_string(data.read_bits(11)),
                map_author_name=data.read_aligned_string(data.read_uint8()),
                mod_file_sync_checksum=data.read_uint32(),
                slot_descriptions=[dict(
                    allowed_colors=data.read_bits(data.read_bits(6)),
                    allowed_races=data.read_bits(data.read_uint8()),
                    allowedDifficulty=data.read_bits(data.read_bits(6)),
                    allowedControls=data.read_bits(data.read_uint8()),
                    allowed_observe_types=data.read_bits(data.read_bits(2)),
                    allowed_ai_builds=data.read_bits(data.read_bits(7)) if replay.base_build >= 23925 else None,
                ) for i in range(data.read_bits(5))],
                default_difficulty=data.read_bits(6),
                default_ai_build=data.read_bits(7) if replay.base_build >= 23925 else None,
                cache_handles=[DepotFile(data.read_aligned_bytes(40)) for i in range(data.read_bits(6 if replay.base_build >= 21955 else 4))],
                has_extension_mod=data.read_bool() if replay.base_build >= 27950 else None,
                is_blizzardMap=data.read_bool(),
                is_premade_ffa=data.read_bool(),
                is_coop_mode=data.read_bool() if replay.base_build >= 23925 else None,
            ),

            lobby_state=dict(
                phase=data.read_bits(3),
                max_users=data.read_bits(5),
                max_observers=data.read_bits(5),
                slots=[dict(
                    control=data.read_uint8(),
                    user_id=data.read_bits(4) if data.read_bool() else None,
                    team_id=data.read_bits(4),
                    colorPref=data.read_bits(5) if data.read_bool() else None,
                    race_pref=data.read_uint8() if data.read_bool() else None,
                    difficulty=data.read_bits(6),
                    ai_build=data.read_bits(7) if replay.base_build >= 23925 else None,
                    handicap=data.read_bits(7),
                    observe=data.read_bits(2),
                    working_set_slot_id=data.read_uint8() if replay.base_build >= 24764 and data.read_bool() else None,
                    rewards=[data.read_uint32() for i in range(data.read_bits(6 if replay.base_build >= 24764 else 5))],
                    toon_handle=data.read_aligned_string(data.read_bits(7)) if replay.base_build >= 17266 else None,
                    licenses=[data.read_uint32() for i in range(data.read_bits(9))] if replay.base_build >= 19132 else [],
                ) for i in range(data.read_bits(5))],
                random_seed=data.read_uint32(),
                host_user_id=data.read_bits(4) if data.read_bool() else None,
                is_single_player=data.read_bool(),
                game_duration=data.read_uint32(),
                default_difficulty=data.read_bits(6),
                default_ai_build=data.read_bits(7) if replay.base_build >= 24764 else None,
            ),
        )
        if not data.done():
            raise ValueError("{0} bytes left!".format(data.length-data.tell()))
        return result


class AttributesEventsReader(object):
    def __call__(self, data, replay):
        data = ByteDecoder(data, endian='LITTLE')
        data.read_bytes(5 if replay.base_build >= 17326 else 4)
        result = [Attribute(
            data.read_uint32(),
            data.read_uint32(),
            data.read_uint8(),
            ''.join(reversed(data.read_string(4))),
        ) for i in range(data.read_uint32())]
        if not data.done():
            raise ValueError("Not all bytes used up!")
        return result


class DetailsReader(object):
    def __call__(self, data, replay):
        details = BitPackedDecoder(data).read_struct()
        return dict(
            players=[dict(
                name=p[0].decode('utf8'),
                bnet=dict(
                    region=p[1][0],
                    program_id=p[1][1],
                    subregion=p[1][2],
                    # name=p[1][3].decode('utf8'),  # This is documented but never available
                    uid=p[1][4],
                ),
                race=p[2].decode('utf8'),
                color=dict(
                    a=p[3][0],
                    r=p[3][1],
                    g=p[3][2],
                    b=p[3][3],
                ),
                control=p[4],
                team=p[5],
                handicap=p[6],
                observe=p[7],
                result=p[8],
                working_set_slot=p[9] if replay.build >= 24764 else None,
            ) for p in details[0]],
            map_name=details[1].decode('utf8'),
            difficulty=details[2],
            thumbnail=details[3][0],
            blizzard_map=details[4],
            file_time=details[5],
            utc_adjustment=details[6],
            description=details[7],
            image_file_path=details[8].decode('utf8'),
            map_file_name=details[9].decode('utf8'),
            cache_handles=[DepotFile(bytes) for bytes in details[10]],
            mini_save=details[11],
            game_speed=details[12],
            default_difficulty=details[13],
            mod_paths=details[14] if (replay.build >= 22612 and replay.versions[1] == 1) else None,
            campaign_index=details[15] if replay.versions[1] == 2 else None,
            restartAsTransitionMap=details[16] if replay.build > 26490 else None,
        )


class MessageEventsReader(object):
    def __call__(self, data, replay):
        data = BitPackedDecoder(data)
        pings = list()
        messages = list()
        packets = list()

        frame = 0
        while not data.done():
            frame += data.read_frames()
            pid = data.read_bits(5)
            flag = data.read_bits(4)
            if flag == 0:  # Client chat message
                recipient = data.read_bits(3 if replay.base_build >= 21955 else 2)
                text = data.read_aligned_string(data.read_bits(11))
                messages.append(ChatEvent(frame, pid, recipient, text))

            elif flag == 1:  # Client ping message
                recipient = data.read_bits(3 if replay.base_build >= 21955 else 2)
                x = data.read_uint32()-2147483648
                y = data.read_uint32()-2147483648
                pings.append(PingEvent(frame, pid, recipient, x, y))

            elif flag == 2:  # Loading progress message
                progress = data.read_uint32()-2147483648
                packets.append(ProgressEvent(frame, pid, progress))

            elif flag == 3:  # Server ping message
                pass

            data.byte_align()

        return dict(pings=pings, messages=messages, packets=packets)


class GameEventsReader_Base(object):

    def __init__(self):
        self.EVENT_DISPATCH = {
            0: (None, self.unknown_event),
            5: (None, self.finished_loading_sync_event),
            7: (None, self.bank_file_event),
            8: (None, self.bank_section_event),
            9: (None, self.bank_key_event),
            10: (None, self.bank_value_event),
            11: (None, self.bank_signature_event),
            12: (UserOptionsEvent, self.user_options_event),
            22: (None, self.save_game_event),
            23: (None, self.save_game_done_event),
            25: (PlayerLeaveEvent, self.player_leave_event),
            26: (None, self.game_cheat_event),
            27: (create_command_event, self.command_event),
            28: (SelectionEvent, self.selection_delta_event),
            29: (create_control_group_event, self.control_group_update_event),
            30: (None, self.selection_sync_check_event),
            31: (None, self.resource_trade_event),
            32: (None, self.trigger_chat_message_event),
            33: (None, self.ai_communicate_event),
            34: (None, self.set_absolute_game_speed_event),
            35: (None, self.add_absolute_game_speed_event),
            37: (None, self.broadcast_cheat_event),
            38: (None, self.alliance_event),
            39: (None, self.unit_click_event),
            40: (None, self.unit_highlight_event),
            41: (None, self.trigger_reply_selected_event),
            44: (None, self.trigger_skipped_event),
            45: (None, self.trigger_sound_length_query_event),
            46: (None, self.trigger_sound_offset_event),
            47: (None, self.trigger_transmission_offset_event),
            48: (None, self.trigger_transmission_complete_event),
            49: (CameraEvent, self.camera_update_event),
            50: (None, self.trigger_abort_mission_event),
            51: (None, self.trigger_purchase_made_event),
            52: (None, self.trigger_purchase_exit_event),
            53: (None, self.trigger_planet_mission_launched_event),
            54: (None, self.trigger_planet_panel_canceled_event),
            55: (None, self.trigger_dialog_control_event),
            56: (None, self.trigger_sound_length_sync_event),
            57: (None, self.trigger_conversation_skipped_event),
            58: (None, self.trigger_mouse_clicked_event),
            63: (None, self.trigger_planet_panel_replay_event),
            64: (None, self.trigger_soundtrack_done_event),
            65: (None, self.trigger_planet_mission_selected_event),
            66: (None, self.trigger_key_pressed_event),
            67: (None, self.trigger_movie_function_event),
            68: (None, self.trigger_planet_panel_birth_complete_event),
            69: (None, self.trigger_planet_panel_death_complete_event),
            70: (None, self.resource_request_event),
            71: (None, self.resource_request_fulfill_event),
            72: (None, self.resource_request_cancel_event),
            73: (None, self.trigger_research_panel_exit_event),
            74: (None, self.trigger_research_panel_purchase_event),
            75: (None, self.trigger_research_panel_selection_changed_event),
            76: (None, self.lag_message_event),
            77: (None, self.trigger_mercenary_panel_exit_event),
            78: (None, self.trigger_mercenary_panel_purchase_event),
            79: (None, self.trigger_mercenary_panel_selection_changed_event),
            80: (None, self.trigger_victory_panel_exit_event),
            81: (None, self.trigger_battle_report_panel_exit_event),
            82: (None, self.trigger_battle_report_panel_play_mission_event),
            83: (None, self.trigger_battle_report_panel_play_scene_event),
            84: (None, self.trigger_battle_report_panel_selection_changed_event),
            85: (None, self.trigger_victory_panel_play_mission_again_event),
            86: (None, self.trigger_movie_started_event),
            87: (None, self.trigger_movie_finished_event),
            88: (None, self.decrement_game_time_remaining_event),
            89: (None, self.trigger_portrait_loaded_event),
            90: (None, self.trigger_custom_dialog_dismissed_event),
            91: (None, self.trigger_game_menu_item_selected_event),
            92: (None, self.trigger_camera_move_event),
            93: (None, self.trigger_purchase_panel_selected_purchase_item_changed_event),
            94: (None, self.trigger_purchase_panel_selected_purchase_category_changed_event),
            95: (None, self.trigger_button_pressed_event),
            96: (None, self.trigger_game_credits_finished_event),
        }

    def __call__(self, data, replay):
        data = BitPackedDecoder(data)
        game_events = list()

        # method short cuts, avoid dict lookups
        EVENT_DISPATCH = self.EVENT_DISPATCH
        debug = replay.opt.debug
        tell = data.tell
        read_frames = data.read_frames
        read_bits = data.read_bits
        byte_align = data.byte_align
        append = game_events.append

        try:
            fstamp = 0
            event_start = 0
            data_length = data.length
            while event_start != data_length:
                fstamp += read_frames()
                pid = read_bits(5)
                event_type = read_bits(7)
                event_class, event_parser = EVENT_DISPATCH.get(event_type, (None, None))
                if event_parser is not None:
                    event_data = event_parser(data)
                    if event_class is not None:
                        event = event_class(fstamp, pid, event_data)
                        append(event)
                        if debug:
                            event.bytes = data.read_range(event_start, tell())
                    else:
                        pass  # Skipping unused events

                # Otherwise throw a read error
                else:
                    raise ReadError("Event type {0} unknown at position {1}.".format(hex(event_type), hex(event_start)), event_type, event_start, replay, game_events, data)

                byte_align()
                event_start = tell()

            return game_events
        except ParseError as e:
            raise ReadError("Parse error '{0}' unknown at position {1}.".format(e.msg, hex(event_start)), event_type, event_start, replay, game_events, data)
        except EOFError as e:
            raise ReadError("EOFError error '{0}' unknown at position {1}.".format(e.msg, hex(event_start)), event_type, event_start, replay, game_events, data)

    # Don't want to do this more than once
    SINGLE_BIT_MASKS = [0x1 << i for i in range(2**9)]

    def read_selection_bitmask(self, data, mask_length):
        bits_left = mask_length
        bits = data.read_bits(mask_length)
        mask = list()
        shift_diff = (mask_length+data._bit_shift) % 8 - data._bit_shift
        if shift_diff > 0:
            mask = [bits & data._lo_masks[shift_diff]]
            bits = bits >> shift_diff
            bits_left -= shift_diff
        elif shift_diff < 0:
            mask = [bits & data._lo_masks[8+shift_diff]]
            bits = bits >> (8+shift_diff)
            bits_left -= 8+shift_diff

        # Now shift the rest of the bits off into the mask in byte-sized
        # chunks in reverse order. No idea why it'd be stored like this.
        while bits_left != 0:
            mask.insert(0, bits & 0xFF)
            bits = bits >> 8
            bits_left -= 8

        # Compile the finished mask into a large integer for bit checks
        bit_mask = sum([c << (i*8) for i, c in enumerate(mask)])

        # Change mask representation from an int to a bit array with
        # True => Deselect, False => Keep
        return [(bit_mask & bit != 0) for bit in self.SINGLE_BIT_MASKS[:mask_length]]


class GameEventsReader_15405(GameEventsReader_Base):

    def unknown_event(self, data):
        return dict(
            unknown=data.read_bytes(2)
        )

    def finished_loading_sync_event(self, data):
        return None

    def bank_file_event(self, data):
        return dict(
            name=data.read_aligned_string(data.read_bits(7)),
        )

    def bank_section_event(self, data):
        return dict(
            name=data.read_aligned_string(data.read_bits(6)),
        )

    def bank_key_event(self, data):
        return dict(
            name=data.read_aligned_string(data.read_bits(6)),
            type=data.read_uint32(),
            data=data.read_aligned_bytes(data.read_bits(7)),
        )

    def bank_value_event(self, data):
        return dict(
            type=data.read_uint32(),
            name=data.read_aligned_string(data.read_bits(6)),
            data=data.read_aligned_bytes(data.read_bits(12)),
        )

    def bank_signature_event(self, data):
        return dict(
            signature=[data.read_uint8() for i in range(data.read_bits(4))],
            toon_handle=None,
        )

    def user_options_event(self, data):
        return dict(
            # I'm just guessing which flags are available here
            game_fully_downloaded=None,
            development_cheats_enabled=data.read_bool(),
            multiplayer_cheats_enabled=data.read_bool(),
            sync_checksumming_enabled=data.read_bool(),
            is_map_to_map_transition=data.read_bool(),
            use_ai_beacons=None,
            debug_pause_enabled=None,
            base_build_num=None,
            starting_rally=None,
        )

    def save_game_event(self, data):
        return dict(
            file_name=data.read_aligned_string(data.read_bits(11)),
            automatic=data.read_bool(),
            overwrite=data.read_bool(),
            name=data.read_aligned_string(data.read_uint8()),
            description=data.read_aligned_string(data.read_bits(10)),
        )

    def save_game_done_event(self, data):
        return None

    def player_leave_event(self, data):
        return None

    def game_cheat_event(self, data):
        return dict(
            point=dict(
                x=data.read_uint32()-2147483648,
                y=data.read_uint32()-2147483648,
            ),
            time=data.read_uint32()-2147483648,
            verb=data.read_aligned_string(data.read_bits(10)),
            arguments=data.read_aligned_string(data.read_bits(10)),
        )

    def command_event(self, data):
        flags = data.read_uint32()
        ability = dict(
            ability_link=data.read_uint16(),
            ability_command_index=data.read_uint8(),
            ability_command_data=data.read_uint8(),
        )
        target_data = ('TargetUnit', dict(
            flags=data.read_uint8(),
            timer=data.read_uint8(),
        ))
        other_unit_tag = data.read_uint32()

        target_data[1].update(dict(
            unit_tag=data.read_uint32(),
            unit_link=data.read_uint16(),
            control_player_id=None,
            upkeep_player_id=data.read_bits(4) if data.read_bool() else None,
            point=dict(
                x=data.read_uint32()-2147483648,
                y=data.read_uint32()-2147483648,
                z=data.read_uint32()-2147483648,
            ),
        ))
        return dict(
            flags=flags,
            ability=ability,
            data=target_data,
            other_unit_tag=other_unit_tag,
        )

    def selection_delta_event(self, data):
        return dict(
            control_group_index=data.read_bits(4),
            subgroup_index=data.read_uint8(),
            remove_mask=('Mask', self.read_selection_bitmask(data, data.read_uint8())),
            add_subgroups=[dict(
                unit_link=data.read_uint16(),
                subgroup_priority=None,
                intra_subgroup_priority=data.read_uint8(),
                count=data.read_uint8(),
            ) for i in range(data.read_uint8())],
            add_unit_tags=[data.read_uint32() for i in range(data.read_uint8())],
        )

    def control_group_update_event(self, data):
        return dict(
            control_group_index=data.read_bits(4),
            control_group_update=data.read_bits(2),
            remove_mask=('Mask', self.read_selection_bitmask(data, data.read_uint8())) if data.read_bool() else ('None', None),
        )

    def selection_sync_check_event(self, data):
        return dict(
            control_group_index=data.read_bits(4),
            selection_sync_data=dict(
                count=data.read_uint8(),
                subgroup_count=data.read_uint8(),
                active_subgroup_index=data.read_uint8(),
                unit_tags_checksum=data.read_uint32(),
                subgroup_indices_checksum=data.read_uint32(),
                subgroups_checksum=data.read_uint32(),
            )
        )

    def resource_trade_event(self, data):
        return dict(
            recipient_id=data.read_bits(4),
            resources=[data.read_uint32()-2147483648 for i in range(data.read_bits(3))],
        )

    def trigger_chat_message_event(self, data):
        return dict(
            message=data.read_aligned_string(data.read_bits(10)),
        )

    def ai_communicate_event(self, data):
        return dict(
            beacon=data.read_uint8()-128,
            ally=data.read_uint8()-128,
            flags=data.read_uint8()-128,
            build=None,
            target_unit_tag=data.read_uint32(),
            target_unit_link=data.read_uint16(),
            target_upkeep_player_id=data.read_bits(4) if data.read_bool() else None,
            target_control_player_id=None,
            target_point=dict(
                x=data.read_uint32()-2147483648,
                y=data.read_uint32()-2147483648,
                z=data.read_uint32()-2147483648,
            ),
        )

    def set_absolute_game_speed_event(self, data):
        return dict(
            speed=data.read_bits(3),
        )

    def add_absolute_game_speed_event(self, data):
        return dict(
            delta=data.read_uint8()-128,
        )

    def broadcast_cheat_event(self, data):
        return dict(
            verb=data.read_aligned_string(data.read_bits(10)),
            arguments=data.read_aligned_string(data.read_bits(10)),
        )

    def alliance_event(self, data):
        return dict(
            alliance=data.read_uint32(),
            control=data.read_uint32(),
        )

    def unit_click_event(self, data):
        return dict(
            unit_tag=data.read_uint32(),
        )

    def unit_highlight_event(self, data):
        return dict(
            unit_tag=data.read_uint32(),
            flags=data.read_uint8(),
        )

    def trigger_reply_selected_event(self, data):
        return dict(
            conversation_id=data.read_uint32()-2147483648,
            reply_id=data.read_uint32()-2147483648,
        )

    def trigger_skipped_event(self, data):
        return None

    def trigger_sound_length_query_event(self, data):
        return dict(
            sound_hash=data.read_uint32(),
            length=data.read_uint32(),
        )

    def trigger_sound_offset_event(self, data):
        return dict(
            sound=data.read_uint32(),
        )

    def trigger_transmission_offset_event(self, data):
        return dict(
            transmission_id=data.read_uint32()-2147483648,
        )

    def trigger_transmission_complete_event(self, data):
        return dict(
            transmission_id=data.read_uint32()-2147483648,
        )

    def camera_update_event(self, data):
        return dict(
            target=dict(
                x=data.read_uint16(),
                y=data.read_uint16(),
            ),
            distance=data.read_uint16() if data.read_bool() else None,
            pitch=data.read_uint16() if data.read_bool() else None,
            yaw=data.read_uint16() if data.read_bool() else None,
            reason=None,
        )

    def trigger_abort_mission_event(self, data):
        return None

    def trigger_purchase_made_event(self, data):
        return dict(
            purchase_item_id=data.read_uint32()-2147483648,
        )

    def trigger_purchase_exit_event(self, data):
        return None

    def trigger_planet_mission_launched_event(self, data):
        return dict(
            difficulty_level=data.read_uint32()-2147483648,
        )

    def trigger_planet_panel_canceled_event(self, data):
        return None

    def trigger_dialog_control_event(self, data):
        return dict(
            control_id=data.read_uint32()-2147483648,
            event_type=data.read_uint32()-2147483648,
            event_data={  # Choice
                0: lambda: ('None', None),
                1: lambda: ('Checked', data.read_bool()),
                2: lambda: ('ValueChanged', data.read_uint32()),
                3: lambda: ('SelectionChanged', data.read_uint32()-2147483648),
                4: lambda: ('TextChanged', data.read_aligned_string(data.read_bits(11))),
            }[data.read_bits(3)](),
        )

    def trigger_sound_length_sync_event(self, data):
        return dict(
            sync_info=dict(
                sound_hash=[data.read_uint32() for i in range(data.read_uint8())],
                length=[data.read_uint32() for i in range(data.read_uint8())],
            )
        )

    def trigger_conversation_skipped_event(self, data):
        return dict(
            skip_type=data.read_int(1),
        )

    def trigger_mouse_clicked_event(self, data):
        return dict(
            button=data.read_uint32(),
            down=data.read_bool(),
            position_ui=dict(
                x=data.read_uint32(),
                y=data.read_uint32(),
            ),
            position_world=dict(
                x=data.read_uint32()-2147483648,
                y=data.read_uint32()-2147483648,
                z=data.read_uint32()-2147483648,
            ),
        )

    def trigger_planet_panel_replay_event(self, data):
        return None

    def trigger_soundtrack_done_event(self, data):
        return dict(
            soundtrack=data.read_uint32(),
        )

    def trigger_planet_mission_selected_event(self, data):
        return dict(
            planet_id=data.read_uint32()-2147483648,
        )

    def trigger_key_pressed_event(self, data):
        return dict(
            key=data.read_uint8()-128,
            flags=data.read_uint8()-128,
        )

    def trigger_movie_function_event(self, data):
        return dict(
            function_name=data.read_aligned_string(data.read_bits(7)),
        )

    def trigger_planet_panel_birth_complete_event(self, data):
        return None

    def trigger_planet_panel_death_complete_event(self, data):
        return None

    def resource_request_event(self, data):
        return dict(
            resources=[data.read_uint32()-2147483648 for i in range(data.read_bits(3))],
        )

    def resource_request_fulfill_event(self, data):
        return dict(
            request_id=data.read_uint32()-2147483648,
        )

    def resource_request_cancel_event(self, data):
        return dict(
            request_id=data.read_uint32()-2147483648,
        )

    def trigger_research_panel_exit_event(self, data):
        return None

    def trigger_research_panel_purchase_event(self, data):
        return None

    def trigger_research_panel_selection_changed_event(self, data):
        return dict(
            item_id=data.read_uint32()-2147483648,
        )

    def lag_message_event(self, data):
        return dict(
            player_id=data.read_bits(4),
        )

    def trigger_mercenary_panel_exit_event(self, data):
        return None

    def trigger_mercenary_panel_purchase_event(self, data):
        return None

    def trigger_mercenary_panel_selection_changed_event(self, data):
        return dict(
            item_id=data.read_uint32()-2147483648,
        )

    def trigger_victory_panel_exit_event(self, data):
        return None

    def trigger_battle_report_panel_exit_event(self, data):
        return None

    def trigger_battle_report_panel_play_mission_event(self, data):
        return dict(
            battle_report_id=data.read_uint32()-2147483648,
            difficulty_level=data.read_uint32()-2147483648,
        )

    def trigger_battle_report_panel_play_scene_event(self, data):
        return dict(
            battle_report_id=data.read_uint32()-2147483648,
        )

    def trigger_battle_report_panel_selection_changed_event(self, data):
        return dict(
            battle_report_id=data.read_uint32()-2147483648,
        )

    def trigger_victory_panel_play_mission_again_event(self, data):
        return dict(
            difficulty_level=data.read_uint32()-2147483648,
        )

    def trigger_movie_started_event(self, data):
        return None

    def trigger_movie_finished_event(self, data):
        return None

    def decrement_game_time_remaining_event(self, data):
        return dict(
            decrement_ms=data.read_uint32(),
        )

    def trigger_portrait_loaded_event(self, data):
        return dict(
            portrait_id=data.read_uint32()-2147483648,
        )

    def trigger_custom_dialog_dismissed_event(self, data):
        return dict(
            result=data.read_uint32()-2147483648,
        )

    def trigger_game_menu_item_selected_event(self, data):
        return dict(
            game_menu_item_index=data.read_uint32()-2147483648,
        )

    def trigger_camera_move_event(self, data):
        return dict(
            reason=data.read_uint8()-128,
        )

    def trigger_purchase_panel_selected_purchase_item_changed_event(self, data):
        return dict(
            item_id=data.read_uint32()-2147483648,
        )

    def trigger_purchase_panel_selected_purchase_category_changed_event(self, data):
        return dict(
            category_id=data.read_uint32()-2147483648,
        )

    def trigger_button_pressed_event(self, data):
        return dict(
            button=data.read_uint16(),
        )

    def trigger_game_credits_finished_event(self, data):
        return None


class GameEventsReader_16561(GameEventsReader_15405):

    def command_event(self, data):
        return dict(
            flags=data.read_bits(17),
            ability=dict(
                ability_link=data.read_uint16(),
                ability_command_index=data.read_bits(5),
                ability_command_data=data.read_uint8() if data.read_bool() else None,
            ) if data.read_bool() else None,
            data={  # Choice
                0: lambda: ('None', None),
                1: lambda: ('TargetPoint', dict(
                    point=dict(
                        x=data.read_bits(20),
                        y=data.read_bits(20),
                        z=data.read_uint32()-2147483648,
                    )
                )),
                2: lambda: ('TargetUnit', dict(
                    flags=data.read_uint8(),
                    timer=data.read_uint8(),
                    unit_tag=data.read_uint32(),
                    unit_link=data.read_uint16(),
                    control_player_id=None,
                    upkeep_player_id=data.read_bits(4) if data.read_bool() else None,
                    point=dict(
                        x=data.read_bits(20),
                        y=data.read_bits(20),
                        z=data.read_uint32()-2147483648,
                    ),
                )),
                3: lambda: ('Data', dict(data=data.read_uint32())),
            }[data.read_bits(2)](),
            other_unit_tag=data.read_uint32() if data.read_bool() else None
        )

    def selection_delta_event(self, data):
        return dict(
            control_group_index=data.read_bits(4),
            subgroup_index=data.read_uint8(),
            remove_mask={  # Choice
                0: lambda: ('None', None),
                1: lambda: ('Mask', self.read_selection_bitmask(data, data.read_uint8())),
                2: lambda: ('OneIndices', [data.read_uint8() for i in range(data.read_uint8())]),
                3: lambda: ('ZeroIndices', [data.read_uint8() for i in range(data.read_uint8())]),
            }[data.read_bits(2)](),
            add_subgroups=[dict(
                unit_link=data.read_uint16(),
                subgroup_priority=None,
                intra_subgroup_priority=data.read_uint8(),
                count=data.read_uint8(),
            ) for i in range(data.read_uint8())],
            add_unit_tags=[data.read_uint32() for i in range(data.read_uint8())],
        )

    def control_group_update_event(self, data):
        return dict(
            control_group_index=data.read_bits(4),
            control_group_update=data.read_bits(2),
            remove_mask={  # Choice
                0: lambda: ('None', None),
                1: lambda: ('Mask', self.read_selection_bitmask(data, data.read_uint8())),
                2: lambda: ('OneIndices', [data.read_uint8() for i in range(data.read_uint8())]),
                3: lambda: ('ZeroIndices', [data.read_uint8() for i in range(data.read_uint8())]),
            }[data.read_bits(2)](),
        )

    def decrement_game_time_remaining_event(self, data):
        return dict(
            decrement_ms=data.read_bits(19)
        )


class GameEventsReader_16605(GameEventsReader_16561):
    pass


class GameEventsReader_16755(GameEventsReader_16605):
    pass


class GameEventsReader_16939(GameEventsReader_16755):
    pass


class GameEventsReader_17326(GameEventsReader_16939):

    def __init__(self):
        super(GameEventsReader_17326, self).__init__()

        self.EVENT_DISPATCH.update({
            59: (None, self.trigger_mouse_moved_event),
        })

    def bank_signature_event(self, data):
        return dict(
            signature=[data.read_uint8() for i in range(data.read_bits(5))],
            toon_handle=None,
        )

    def trigger_mouse_clicked_event(self, data):
        return dict(
            button=data.read_uint32(),
            down=data.read_bool(),
            position_ui=dict(
                x=data.read_bits(11),
                y=data.read_bits(11),
            ),
            position_world=dict(
                x=data.read_bits(20),
                y=data.read_bits(20),
                z=data.read_uint32() - 2147483648,
            ),
        )

    def trigger_mouse_moved_event(self, data):
        return dict(
            position_ui=dict(
                x=data.read_bits(11),
                y=data.read_bits(11),
            ),
            position_world=dict(
                x=data.read_bits(20),
                y=data.read_bits(20),
                z=data.read_uint32()-2147483648,
            ),
        )


class GameEventsReader_18092(GameEventsReader_17326):
    pass


class GameEventsReader_18574(GameEventsReader_18092):

    def command_event(self, data):
        return dict(
            flags=data.read_bits(18),
            ability=dict(
                ability_link=data.read_uint16(),
                ability_command_index=data.read_bits(5),
                ability_command_data=data.read_uint8() if data.read_bool() else None,
            ) if data.read_bool() else None,
            data={  # Choice
                0: lambda: ('None', None),
                1: lambda: ('TargetPoint', dict(
                    point=dict(
                        x=data.read_bits(20),
                        y=data.read_bits(20),
                        z=data.read_uint32()-2147483648,
                    )
                )),
                2: lambda: ('TargetUnit', dict(
                    flags=data.read_uint8(),
                    timer=data.read_uint8(),
                    unit_tag=data.read_uint32(),
                    unit_link=data.read_uint16(),
                    control_player_id=None,
                    upkeep_player_id=data.read_bits(4) if data.read_bool() else None,
                    point=dict(
                        x=data.read_bits(20),
                        y=data.read_bits(20),
                        z=data.read_uint32()-2147483648,
                    ),
                )),
                3: lambda: ('Data', dict(data=data.read_uint32())),
            }[data.read_bits(2)](),
            other_unit_tag=data.read_uint32() if data.read_bool() else None
        )


class GameEventsReader_19132(GameEventsReader_18574):
    pass


class GameEventsReader_19595(GameEventsReader_19132):

    def command_event(self, data):
        return dict(
            flags=data.read_bits(18),
            ability=dict(
                ability_link=data.read_uint16(),
                ability_command_index=data.read_bits(5),
                ability_command_data=data.read_uint8() if data.read_bool() else None,
            ) if data.read_bool() else None,
            data={  # Choice
                0: lambda: ('None', None),
                1: lambda: ('TargetPoint', dict(
                    point=dict(
                        x=data.read_bits(20),
                        y=data.read_bits(20),
                        z=data.read_uint32()-2147483648,
                    )
                )),
                2: lambda: ('TargetUnit', dict(
                    flags=data.read_uint8(),
                    timer=data.read_uint8(),
                    unit_tag=data.read_uint32(),
                    unit_link=data.read_uint16(),
                    control_player_id=data.read_bits(4) if data.read_bool() else None,
                    upkeep_player_id=data.read_bits(4) if data.read_bool() else None,
                    point=dict(
                        x=data.read_bits(20),
                        y=data.read_bits(20),
                        z=data.read_uint32()-2147483648,
                    ),
                )),
                3: lambda: ('Data', dict(data=data.read_uint32())),
            }[data.read_bits(2)](),
            other_unit_tag=data.read_uint32() if data.read_bool() else None
        )

    def ai_communicate_event(self, data):
        return dict(
            beacon=data.read_uint8()-128,
            ally=data.read_uint8()-128,
            flags=data.read_uint8()-128,  # autocast??
            build=None,
            target_unit_tag=data.read_uint32(),
            target_unit_link=data.read_uint16(),
            target_upkeep_player_id=data.read_bits(4) if data.read_bool() else None,
            target_control_player_id=data.read_bits(4) if data.read_bool() else None,
            target_point=dict(
                x=data.read_uint32()-2147483648,
                y=data.read_uint32()-2147483648,
                z=data.read_uint32()-2147483648,
            ),
        )


class GameEventsReader_21029(GameEventsReader_19595):
    pass


class GameEventsReader_22612(GameEventsReader_21029):

    def __init__(self):
        super(GameEventsReader_22612, self).__init__()

        self.EVENT_DISPATCH.update({
            36: (None, self.trigger_ping_event),
            60: (None, self.achievement_awarded_event),
            97: (None, self.trigger_cutscene_bookmark_fired_event),
            98: (None, self.trigger_cutscene_end_scene_fired_event),
            99: (None, self.trigger_cutscene_conversation_line_event),
            100: (None, self.trigger_cutscene_conversation_line_missing_event),
        })

    def user_options_event(self, data):
        return dict(
            game_fully_downloaded=data.read_bool(),
            development_cheats_enabled=data.read_bool(),
            multiplayer_cheats_enabled=data.read_bool(),
            sync_checksumming_enabled=data.read_bool(),
            is_map_to_map_transition=data.read_bool(),
            use_ai_beacons=data.read_bool(),
            debug_pause_enabled=None,
            base_build_num=None,
            starting_rally=None,
        )

    def command_event(self, data):
        return dict(
            flags=data.read_bits(20),
            ability=dict(
                ability_link=data.read_uint16(),
                ability_command_index=data.read_bits(5),
                ability_command_data=data.read_uint8() if data.read_bool() else None,
            ) if data.read_bool() else None,
            data={  # Choice
                0: lambda: ('None', None),
                1: lambda: ('TargetPoint', dict(
                    point=dict(
                        x=data.read_bits(20),
                        y=data.read_bits(20),
                        z=data.read_uint32()-2147483648,
                    )
                )),
                2: lambda: ('TargetUnit', dict(
                    flags=data.read_uint8(),
                    timer=data.read_uint8(),
                    unit_tag=data.read_uint32(),
                    unit_link=data.read_uint16(),
                    control_player_id=data.read_bits(4) if data.read_bool() else None,
                    upkeep_player_id=data.read_bits(4) if data.read_bool() else None,
                    point=dict(
                        x=data.read_bits(20),
                        y=data.read_bits(20),
                        z=data.read_uint32()-2147483648,
                    ),
                )),
                3: lambda: ('Data', dict(data=data.read_uint32())),
            }[data.read_bits(2)](),
            other_unit_tag=data.read_uint32() if data.read_bool() else None
        )

    def selection_delta_event(self, data):
        return dict(
            control_group_index=data.read_bits(4),
            subgroup_index=data.read_bits(9),
            remove_mask={  # Choice
                0: lambda: ('None', None),
                1: lambda: ('Mask', self.read_selection_bitmask(data, data.read_bits(9))),
                2: lambda: ('OneIndices', [data.read_bits(9) for i in range(data.read_bits(9))]),
                3: lambda: ('ZeroIndices', [data.read_bits(9) for i in range(data.read_bits(9))]),
            }[data.read_bits(2)](),
            add_subgroups=[dict(
                unit_link=data.read_uint16(),
                subgroup_priority=None,
                intra_subgroup_priority=data.read_uint8(),
                count=data.read_bits(9),
            ) for i in range(data.read_bits(9))],
            add_unit_tags=[data.read_uint32() for i in range(data.read_bits(9))],
        )

    def control_group_update_event(self, data):
        return dict(
            control_group_index=data.read_bits(4),
            control_group_update=data.read_bits(2),
            remove_mask={  # Choice
                0: lambda: ('None', None),
                1: lambda: ('Mask', self.read_selection_bitmask(data, data.read_bits(9))),
                2: lambda: ('OneIndices', [data.read_bits(9) for i in range(data.read_bits(9))]),
                3: lambda: ('ZeroIndices', [data.read_bits(9) for i in range(data.read_bits(9))]),
            }[data.read_bits(2)](),
        )

    def selection_sync_check_event(self, data):
        return dict(
            control_group_index=data.read_bits(4),
            selection_sync_data=dict(
                count=data.read_bits(9),
                subgroup_count=data.read_bits(9),
                active_subgroup_index=data.read_bits(9),
                unit_tags_checksum=data.read_uint32(),
                subgroup_indices_checksum=data.read_uint32(),
                subgroups_checksum=data.read_uint32(),
            )
        )

    def ai_communicate_event(self, data):
        return dict(
            beacon=data.read_uint8()-128,
            ally=data.read_uint8()-128,
            flags=data.read_uint8()-128,
            build=data.read_uint8()-128,
            target_unit_tag=data.read_uint32(),
            target_unit_link=data.read_uint16(),
            target_upkeep_player_id=data.read_uint8(),
            target_control_player_id=data.read_uint8(),
            target_point=dict(
                x=data.read_uint32()-2147483648,
                y=data.read_uint32()-2147483648,
                z=data.read_uint32()-2147483648,
            ),
        )

    def trigger_ping_event(self, data):
        return dict(
            point=dict(
                x=data.read_uint32()-2147483648,
                y=data.read_uint32()-2147483648,
            ),
            unit_tag=data.read_uint32(),
            pinged_minimap=data.read_bool(),
        )

    def trigger_transmission_offset_event(self, data):
        # I'm not actually sure when this second int is introduced..
        return dict(
            transmission_id=data.read_uint32()-2147483648,
            thread=data.read_uint32(),
        )

    def achievement_awarded_event(self, data):
        return dict(
            achievement_link=data.read_uint16(),
        )

    def trigger_cutscene_bookmark_fired_event(self, data):
        return dict(
            cutscene_id=data.read_uint32()-2147483648,
            bookmark_name=data.read_aligned_string(data.read_bits(7)),
        )

    def trigger_cutscene_end_scene_fired_event(self, data):
        return dict(
            cutscene_id=data.read_uint32()-2147483648,
        )

    def trigger_cutscene_conversation_line_event(self, data):
        return dict(
            cutscene_id=data.read_uint32()-2147483648,
            conversation_line=data.read_aligned_string(data.read_bits(7)),
            alt_conversation_line=data.read_aligned_string(data.read_bits(7)),
        )

    def trigger_cutscene_conversation_line_missing_event(self, data):
        return dict(
            cutscene_id=data.read_uint32()-2147483648,
            conversation_line=data.read_aligned_string(data.read_bits(7)),
        )


class GameEventsReader_23260(GameEventsReader_22612):

    def trigger_sound_length_sync_event(self, data):
        return dict(
            sync_info=dict(
                sound_hash=[data.read_uint32() for i in range(data.read_bits(7))],
                length=[data.read_uint32() for i in range(data.read_bits(7))],
            )
        )

    def user_options_event(self, data):
        return dict(
            game_fully_downloaded=data.read_bool(),
            development_cheats_enabled=data.read_bool(),
            multiplayer_cheats_enabled=data.read_bool(),
            sync_checksumming_enabled=data.read_bool(),
            is_map_to_map_transition=data.read_bool(),
            starting_rally=data.read_bool(),
            use_ai_beacons=data.read_bool(),
            debug_pause_enabled=None,
            base_build_num=None,
        )


class GameEventsReader_HotSBeta(GameEventsReader_23260):

    def user_options_event(self, data):
        return dict(
            game_fully_downloaded=data.read_bool(),
            development_cheats_enabled=data.read_bool(),
            multiplayer_cheats_enabled=data.read_bool(),
            sync_checksumming_enabled=data.read_bool(),
            is_map_to_map_transition=data.read_bool(),
            starting_rally=data.read_bool(),
            debug_pause_enabled=None,
            base_build_num=data.read_uint32(),
            use_ai_beacons=None,
        )

    def selection_delta_event(self, data):
        return dict(
            control_group_index=data.read_bits(4),
            subgroup_index=data.read_bits(9),
            remove_mask={  # Choice
                0: lambda: ('None', None),
                1: lambda: ('Mask', self.read_selection_bitmask(data, data.read_bits(9))),
                2: lambda: ('OneIndices', [data.read_bits(9) for i in range(data.read_bits(9))]),
                3: lambda: ('ZeroIndices', [data.read_bits(9) for i in range(data.read_bits(9))]),
            }[data.read_bits(2)](),
            add_subgroups=[dict(
                unit_link=data.read_uint16(),
                subgroup_priority=data.read_uint8(),
                intra_subgroup_priority=data.read_uint8(),
                count=data.read_bits(9),
            ) for i in range(data.read_bits(9))],
            add_unit_tags=[data.read_uint32() for i in range(data.read_bits(9))],
        )

    def camera_update_event(self, data):
        return dict(
            target=dict(
                x=data.read_uint16(),
                y=data.read_uint16(),
            ) if data.read_bool() else None,
            distance=data.read_uint16() if data.read_bool() else None,
            pitch=data.read_uint16() if data.read_bool() else None,
            yaw=data.read_uint16() if data.read_bool() else None,
        )

    def trigger_dialog_control_event(self, data):
        return dict(
            control_id=data.read_uint32()-2147483648,
            event_type=data.read_uint32()-2147483648,
            event_data={  # Choice
                0: lambda: ('None', None),
                1: lambda: ('Checked', data.read_bool()),
                2: lambda: ('ValueChanged', data.read_uint32()),
                3: lambda: ('SelectionChanged', data.read_uint32()-2147483648),
                4: lambda: ('TextChanged', data.read_aligned_string(data.read_bits(11))),
                5: lambda: ('MouseButton', data.read_uint32())
            }[data.read_bits(3)](),
        )


class GameEventsReader_24247(GameEventsReader_HotSBeta):

    def __init__(self):
        super(GameEventsReader_24247, self).__init__()

        self.EVENT_DISPATCH.update({
            7: (UserOptionsEvent, self.user_options_event),       # Override
            9: (None, self.bank_file_event),                      # Override
            10: (None, self.bank_section_event),                  # Override
            11: (None, self.bank_key_event),                      # Override
            12: (None, self.bank_value_event),                    # Override
            13: (None, self.bank_signature_event),                # New
            14: (None, self.camera_save_event),                   # New
            21: (None, self.save_game_event),                     # New
            22: (None, self.save_game_done_event),                # Override
            23: (None, self.load_game_done_event),                # Override
            43: (HijackReplayGameEvent, self.hijack_replay_game_event),  # New
            62: (None, self.trigger_target_mode_update_event),    # New
            101: (PlayerLeaveEvent, self.game_user_leave_event),  # New
            102: (None, self.game_user_join_event),               # New
        })
        del self.EVENT_DISPATCH[8]
        del self.EVENT_DISPATCH[25]
        del self.EVENT_DISPATCH[76]

    def bank_signature_event(self, data):
        return dict(
            signature=[data.read_uint8() for i in range(data.read_bits(5))],
            toon_handle=data.read_aligned_string(data.read_bits(7))
        )

    def camera_save_event(self, data):
        return dict(
            which=data.read_bits(3),
            target=dict(
                x=data.read_uint16(),
                y=data.read_uint16(),
            )
        )

    def load_game_done_event(self, data):
        return None

    def hijack_replay_game_event(self, data):
        return dict(
            user_infos=[dict(
                game_user_id=data.read_bits(4),
                observe=data.read_bits(2),
                name=data.read_aligned_string(data.read_uint8()),
                toon_handle=data.read_aligned_string(data.read_bits(7)) if data.read_bool() else None,
                clan_tag=data.read_aligned_string(data.read_uint8()) if data.read_bool() else None,
                clan_logo=None,
            ) for i in range(data.read_bits(5))],
            method=data.read_bits(1),
        )

    def camera_update_event(self, data):
        return dict(
            target=dict(
                x=data.read_uint16(),
                y=data.read_uint16(),
            ) if data.read_bool() else None,
            distance=data.read_uint16() if data.read_bool() else None,
            pitch=data.read_uint16() if data.read_bool() else None,
            yaw=data.read_uint16() if data.read_bool() else None,
            reason=None,
        )

    def trigger_target_mode_update_event(self, data):
        return dict(
            ability_link=data.read_uint16(),
            ability_command_index=data.read_bits(5),
            state=data.read_uint8()-128,
        )

    def game_user_leave_event(self, data):
        return None

    def game_user_join_event(self, data):
        return dict(
            observe=data.read_bits(2),
            name=data.read_aligned_string(data.read_bits(8)),
            toon_handle=data.read_aligned_string(data.read_bits(7)) if data.read_bool() else None,
            clan_tag=data.read_aligned_string(data.read_uint8()) if data.read_bool() else None,
            clan_log=None,
        )


class GameEventsReader_26490(GameEventsReader_24247):

    def user_options_event(self, data):
        return dict(
            game_fully_downloaded=data.read_bool(),
            development_cheats_enabled=data.read_bool(),
            multiplayer_cheats_enabled=data.read_bool(),
            sync_checksumming_enabled=data.read_bool(),
            is_map_to_map_transition=data.read_bool(),
            starting_rally=data.read_bool(),
            debug_pause_enabled=data.read_bool(),
            base_build_num=data.read_uint32(),
            use_ai_beacons=None,
        )

    def trigger_mouse_clicked_event(self, data):
        return dict(
            button=data.read_uint32(),
            down=data.read_bool(),
            position_ui=dict(
                x=data.read_bits(11),
                y=data.read_bits(11),
            ),
            position_world=dict(
                x=data.read_bits(20) - 2147483648,
                y=data.read_bits(20) - 2147483648,
                z=data.read_uint32() - 2147483648,
            ),
            flags=data.read_uint8() - 128,
        )

    def trigger_mouse_moved_event(self, data):
        return dict(
            position_ui=dict(
                x=data.read_bits(11),
                y=data.read_bits(11),
            ),
            position_world=dict(
                x=data.read_bits(20),
                y=data.read_bits(20),
                z=data.read_uint32() - 2147483648,
            ),
            flags=data.read_uint8() - 128,
        )


class GameEventsReader_27950(GameEventsReader_26490):

    def hijack_replay_game_event(self, data):
        return dict(
            user_infos=[dict(
                game_user_id=data.read_bits(4),
                observe=data.read_bits(2),
                name=data.read_aligned_string(data.read_uint8()),
                toon_handle=data.read_aligned_string(data.read_bits(7)) if data.read_bool() else None,
                clan_tag=data.read_aligned_string(data.read_uint8()) if data.read_bool() else None,
                clan_logo=DepotFile(data.read_aligned_bytes(40)) if data.read_bool() else None,
            ) for i in range(data.read_bits(5))],
            method=data.read_bits(1),
        )

    def camera_update_event(self, data):
        return dict(
            target=dict(
                x=data.read_uint16(),
                y=data.read_uint16(),
            ) if data.read_bool() else None,
            distance=data.read_uint16() if data.read_bool() else None,
            pitch=data.read_uint16() if data.read_bool() else None,
            yaw=data.read_uint16() if data.read_bool() else None,
            reason=data.read_uint8() - 128 if data.read_bool() else None,
        )

    def game_user_join_event(self, data):
        return dict(
            observe=data.read_bits(2),
            name=data.read_aligned_string(data.read_bits(8)),
            toon_handle=data.read_aligned_string(data.read_bits(7)) if data.read_bool() else None,
            clan_tag=data.read_aligned_string(data.read_uint8()) if data.read_bool() else None,
            clan_logo=DepotFile(data.read_aligned_bytes(40)) if data.read_bool() else None,
        )


class TrackerEventsReader(object):

    def __init__(self):
        self.EVENT_DISPATCH = {
            0: PlayerStatsEvent,
            1: UnitBornEvent,
            2: UnitDiedEvent,
            3: UnitOwnerChangeEvent,
            4: UnitTypeChangeEvent,
            5: UpgradeCompleteEvent,
            6: UnitInitEvent,
            7: UnitDoneEvent,
            8: UnitPositionsEvent,
            9: PlayerSetupEvent,
        }

    def __call__(self, data, replay):
        decoder = BitPackedDecoder(data)

        frames = 0
        events = list()
        while not decoder.done():
            decoder._buffer.read(3)  # 03 00 09
            frames += decoder.read_vint()
            decoder._buffer.read(1)  # 09
            etype = decoder.read_vint()
            event_data = decoder.read_struct()
            event = self.EVENT_DISPATCH[etype](frames, event_data, replay.build)
            events.append(event)

        return events

########NEW FILE########
__FILENAME__ = resources
# -*- coding: utf-8 -*-
from __future__ import absolute_import, print_function, unicode_literals, division

from collections import defaultdict, namedtuple
from datetime import datetime
import hashlib
from xml.etree import ElementTree
import zlib

import mpyq
import sc2reader
from sc2reader import utils
from sc2reader.decoders import BitPackedDecoder
from sc2reader import log_utils
from sc2reader import readers
from sc2reader import exceptions
from sc2reader.data import datapacks
from sc2reader.exceptions import SC2ReaderLocalizationError, CorruptTrackerFileError
from sc2reader.objects import Participant, Observer, Computer, Team, PlayerSummary, Graph, BuildEntry, MapInfo
from sc2reader.constants import GAME_SPEED_FACTOR, LOBBY_PROPERTIES


class Resource(object):
    def __init__(self, file_object, filename=None, factory=None, **options):
        self.factory = factory
        self.opt = utils.AttributeDict(options)
        self.logger = log_utils.get_logger(self.__class__)
        self.filename = filename or getattr(file_object, 'name', 'Unavailable')

        if hasattr(file_object, 'seek'):
            file_object.seek(0)
            self.filehash = hashlib.sha256(file_object.read()).hexdigest()
            file_object.seek(0)


class Replay(Resource):

    #: A nested dictionary of player => { attr_name : attr_value } for
    #: known attributes. Player 16 represents the global context and
    #: contains attributes like game speed.
    attributes = defaultdict(dict)

    #: Fully qualified filename of the replay file represented.
    filename = str()

    #: Total number of frames in this game at 16 frames per second.
    frames = int()

    #: The SCII client build number
    build = int()

    #: The SCII game engine build number
    base_build = int()

    #: The full version release string as seen on Battle.net
    release_string = str()

    #: A tuple of the individual pieces of the release string
    versions = tuple()

    #: The game speed: Slower, Slow, Normal, Fast, Faster
    speed = str()

    #: Deprecated, use :attr:`game_type` or :attr:`real_type` instead
    type = str()

    #: The game type choosen at game creation: 1v1, 2v2, 3v3, 4v4, FFA
    game_type = str()

    #: The real type of the replay as observed by counting players on teams.
    #: For outmatched games, the smaller team numbers come first.
    #: Example Values: 1v1, 2v2, 3v3, FFA, 2v4, etc.
    real_type = str()

    #: The category of the game, Ladder and Private
    category = str()

    #: A flag for public ladder games
    is_ladder = bool()

    #: A flag for private non-ladder games
    is_private = bool()

    #: The raw hash name of the s2ma resource as hosted on bnet depots
    map_hash = str()

    #: The name of the map the game was played on
    map_name = str()

    #: A reference to the loaded :class:`Map` resource.
    map = None

    #: The UTC time (according to the client NOT the server) that the game
    #: was ended as represented by the Windows OS
    windows_timestamp = int()

    #: The UTC time (according to the client NOT the server) that the game
    #: was ended as represented by the Unix OS
    unix_timestamp = int()

    #: The time zone adjustment for the time zone registered on the local
    #: computer that recorded this replay.
    time_zone = int()

    #: Deprecated: See `end_time` below.
    date = None

    #: A datetime object representing the utc time at the end of the game.
    end_time = None

    #: A datetime object representing the utc time at the start of the game
    start_time = None

    #: Deprecated: See `game_length` below.
    length = None

    #: The :class:`Length` of the replay as an alternative to :attr:`frames`
    game_length = None

    #: The :class:`Length` of the replay in real time adjusted for the game speed
    real_length = None

    #: The region the game was played on: us, eu, sea, etc
    region = str()

    #: An integrated list of all the game events
    events = list()

    #: A list of :class:`Team` objects from the game
    teams = list()

    #: A dict mapping team number to :class:`Team` object
    team = dict()

    #: A list of :class:`Player` objects from the game
    players = list()

    #: A dual key dict mapping player names and numbers to
    #: :class:`Player` objects
    player = utils.PersonDict()

    #: A list of :class:`Observer` objects from the game
    observers = list()

    #: A list of :class:`Person` objects from the game representing
    #: both the player and observer lists
    people = list()

    #: A dual key dict mapping :class:`Person` object to their
    #: person id's and names
    person = utils.PersonDict()

    #: A list of :class:`Person` objects from the game representing
    #: only the human players from the :attr:`people` list
    humans = list()

    #: A list of :class:`Computer` objects from the game.
    computers = list()

    #: A list of all the chat message events from the game
    messages = list()

    #: A list of pings sent by all the different people in the game
    pings = list()

    #: A list of packets sent between the various game clients
    packets = list()

    #: A reference to the :class:`Person` that recorded the game
    recorder = None

    #: If there is a valid winning team this will contain a :class:`Team` otherwise it will be :class:`None`
    winner = None

    #: A dictionary mapping unit unique ids to their corresponding classes
    objects = dict()

    #: A sha256 hash uniquely representing the combination of people in the game.
    #: Can be used in conjunction with date times to match different replays
    #: of the game game.
    people_hash = str()

    #: SC2 Expansion. One of 'WoL', 'HotS'
    expasion = str()

    #: True of the game was resumed from a replay
    resume_from_replay = False

    #: A flag marking which method was used to resume from replay. Unknown interpretation.
    resume_method = None

    #: Lists info for each user that is resuming from replay.
    resume_user_info = None

    def __init__(self, replay_file, filename=None, load_level=4, engine=sc2reader.engine, do_tracker_events=True, **options):
        super(Replay, self).__init__(replay_file, filename, **options)
        self.datapack = None
        self.raw_data = dict()

        # The current load level of the replay
        self.load_level = None

        # default values, filled in during file read
        self.speed = ""
        self.type = ""
        self.game_type = ""
        self.real_type = ""
        self.category = ""
        self.is_ladder = False
        self.is_private = False
        self.map = None
        self.map_hash = ""
        self.region = ""
        self.events = list()
        self.teams, self.team = list(), dict()

        self.player = utils.PersonDict()
        self.observer = utils.PersonDict()
        self.human = utils.PersonDict()
        self.computer = utils.PersonDict()
        self.entity = utils.PersonDict()

        self.players = list()
        self.observers = list()  # Unordered list of Observer
        self.humans = list()
        self.computers = list()
        self.entities = list()

        self.attributes = defaultdict(dict)
        self.messages = list()
        self.recorder = None  # Player object
        self.packets = list()
        self.objects = {}
        self.active_units = {}
        self.game_fps = 16.0

        self.tracker_events = list()
        self.game_events = list()

        # Bootstrap the readers.
        self.registered_readers = defaultdict(list)
        self.register_default_readers()

        # Bootstrap the datapacks.
        self.registered_datapacks = list()
        self.register_default_datapacks()

        # Unpack the MPQ and read header data if requested
        # Since the underlying traceback isn't important to most people, don't expose it in python2 anymore
        if load_level >= 0:
            self.load_level = 0
            try:
                self.archive = mpyq.MPQArchive(replay_file, listfile=False)
            except Exception as e:
                raise exceptions.MPQError("Unable to construct the MPQArchive", e)

            header_content = self.archive.header['user_data_header']['content']
            header_data = BitPackedDecoder(header_content).read_struct()
            self.versions = list(header_data[1].values())
            self.frames = header_data[3]
            self.build = self.versions[4]
            self.base_build = self.versions[5]
            self.release_string = "{0}.{1}.{2}.{3}".format(*self.versions[1:5])
            self.game_length = utils.Length(seconds=self.frames/16)
            self.length = self.real_length = utils.Length(seconds=int(self.frames/self.game_fps))

        # Load basic details if requested
        if load_level >= 1:
            self.load_level = 1
            for data_file in ['replay.initData', 'replay.details', 'replay.attributes.events']:
                self._read_data(data_file, self._get_reader(data_file))
            self.load_details()
            self.datapack = self._get_datapack()

            # Can only be effective if map data has been loaded
            if options.get('load_map', False):
                self.load_map()

        # Load players if requested
        if load_level >= 2:
            self.load_level = 2
            for data_file in ['replay.message.events']:
                self._read_data(data_file, self._get_reader(data_file))
            self.load_message_events()
            self.load_players()

        # Load tracker events if requested
        if load_level >= 3 and do_tracker_events:
            self.load_level = 3
            for data_file in ['replay.tracker.events']:
                self._read_data(data_file, self._get_reader(data_file))
            self.load_tracker_events()

        # Load events if requested
        if load_level >= 4:
            self.load_level = 4
            for data_file in ['replay.game.events']:
                self._read_data(data_file, self._get_reader(data_file))
            self.load_game_events()

        # Run this replay through the engine as indicated
        if engine:
            resume_events = [ev for ev in self.game_events if ev.name == 'HijackReplayGameEvent']
            if self.base_build <= 26490 and self.tracker_events and len(resume_events) > 0:
                raise CorruptTrackerFileError(
                    "Cannot run engine on resumed games with tracker events. Run again with the " +
                    "do_tracker_events=False option to generate context without tracker events.")

            engine.run(self)

    def load_details(self):
        if 'replay.attributes.events' in self.raw_data:
            # Organize the attribute data to be useful
            self.attributes = defaultdict(dict)
            attributesEvents = self.raw_data['replay.attributes.events']
            for attr in attributesEvents:
                self.attributes[attr.player][attr.name] = attr.value

            # Populate replay with attributes
            self.speed = self.attributes[16]['Game Speed']
            self.category = self.attributes[16]['Game Mode']
            self.type = self.game_type = self.attributes[16]['Teams']
            self.is_ladder = (self.category == "Ladder")
            self.is_private = (self.category == "Private")

        if 'replay.details' in self.raw_data:
            details = self.raw_data['replay.details']

            self.map_name = details['map_name']

            self.region = details['cache_handles'][0].server.lower()
            self.map_hash = details['cache_handles'][-1].hash
            self.map_file = details['cache_handles'][-1]

            # Expand this special case mapping
            if self.region == 'sg':
                self.region = 'sea'

            dependency_hashes = [d.hash for d in details['cache_handles']]
            if hashlib.sha256('Standard Data: Swarm.SC2Mod'.encode('utf8')).hexdigest() in dependency_hashes:
                self.expansion = 'HotS'
            elif hashlib.sha256('Standard Data: Liberty.SC2Mod'.encode('utf8')).hexdigest() in dependency_hashes:
                self.expansion = 'WoL'
            else:
                self.expansion = ''

            self.windows_timestamp = details['file_time']
            self.unix_timestamp = utils.windows_to_unix(self.windows_timestamp)
            self.end_time = datetime.utcfromtimestamp(self.unix_timestamp)

            # The utc_adjustment is either the adjusted windows timestamp OR
            # the value required to get the adjusted timestamp. We know the upper
            # limit for any adjustment number so use that to distinguish between
            # the two cases.
            if details['utc_adjustment'] < 10**7*60*60*24:
                self.time_zone = details['utc_adjustment']/(10**7*60*60)
            else:
                self.time_zone = (details['utc_adjustment']-details['file_time'])/(10**7*60*60)

            self.game_length = self.length
            self.real_length = utils.Length(seconds=int(self.length.seconds/GAME_SPEED_FACTOR[self.speed]))
            self.start_time = datetime.utcfromtimestamp(self.unix_timestamp-self.real_length.seconds)
            self.date = self.end_time  # backwards compatibility

    def load_map(self):
        self.map = self.factory.load_map(self.map_file, **self.opt)

    def load_players(self):
        # If we don't at least have details and attributes_events we can go no further
        if 'replay.details' not in self.raw_data:
            return
        if 'replay.attributes.events' not in self.raw_data:
            return
        if 'replay.initData' not in self.raw_data:
            return

        self.clients = list()
        self.client = dict()

        # For players, we can use the details file to look up additional
        # information. detail_id marks the current index into this data.
        detail_id = 0
        player_id = 1
        details = self.raw_data['replay.details']
        initData = self.raw_data['replay.initData']

        # Assume that the first X map slots starting at 1 are player slots
        # so that we can assign player ids without the map
        self.entities = list()
        for slot_id, slot_data in enumerate(initData['lobby_state']['slots']):
            user_id = slot_data['user_id']

            if slot_data['control'] == 2:
                if slot_data['observe'] == 0:
                    self.entities.append(Participant(slot_id, slot_data, user_id, initData['user_initial_data'][user_id], player_id, details['players'][detail_id], self.attributes.get(player_id, dict())))
                    detail_id += 1
                    player_id += 1

                else:
                    self.entities.append(Observer(slot_id, slot_data, user_id, initData['user_initial_data'][user_id], player_id))
                    player_id += 1

            elif slot_data['control'] == 3:
                self.entities.append(Computer(slot_id, slot_data, player_id, details['players'][detail_id], self.attributes.get(player_id, dict())))
                detail_id += 1
                player_id += 1

        def get_team(team_id):
            if team_id is not None and team_id not in self.team:
                    team = Team(team_id)
                    self.team[team_id] = team
                    self.teams.append(team)
            return self.team[team_id]

        # Set up all our cross reference data structures
        for entity in self.entities:
            if entity.is_observer is False:
                entity.team = get_team(entity.team_id)
                entity.team.players.append(entity)
                self.players.append(entity)
                self.player[entity.pid] = entity
            else:
                self.observers.append(entity)
                self.observer[entity.uid] = entity

            if entity.is_human:
                self.humans.append(entity)
                self.human[entity.uid] = entity
            else:
                self.computers.append(entity)
                self.computer[entity.pid] = entity

            # Index by pid so that we can match events to players in pre-HotS replays
            self.entity[entity.pid] = entity

        # Pull results up for teams
        for team in self.teams:
            results = set([p.result for p in team.players])
            if len(results) == 1:
                team.result = list(results)[0]
                if team.result == 'Win':
                    self.winner = team
            else:
                self.logger.warn("Conflicting results for Team {0}: {1}".format(team.number, results))
                team.result = 'Unknown'

        self.teams.sort(key=lambda t: t.number)

        # These are all deprecated
        self.clients = self.humans
        self.people = self.entities
        self.client = self.human
        self.person = self.entity

        self.real_type = utils.get_real_type(self.teams)

        # Assign the default region to computer players for consistency
        # We know there will be a default region because there must be
        # at least 1 human player or we wouldn't have a replay.
        default_region = self.humans[0].region
        for entity in self.entities:
            if not entity.region:
                entity.region = default_region

        # Pretty sure this just never worked, forget about it for now
        self.recorder = None

        entity_names = sorted(map(lambda p: p.name, self.entities))
        hash_input = self.region+":"+','.join(entity_names)
        self.people_hash = hashlib.sha256(hash_input.encode('utf8')).hexdigest()

        # The presence of observers and/or computer players makes this not actually ladder
        # This became an issue in HotS where Training, vs AI, Unranked, and Ranked
        # were all marked with "amm" => Ladder
        if len(self.observers) > 0 or len(self.humans) != len(self.players):
            self.is_ladder = False

    def load_message_events(self):
        if 'replay.message.events' not in self.raw_data:
            return

        self.messages = self.raw_data['replay.message.events']['messages']
        self.pings = self.raw_data['replay.message.events']['pings']
        self.packets = self.raw_data['replay.message.events']['packets']

        self.message_events = self.messages+self.pings+self.packets
        self.events = sorted(self.events + self.message_events, key=lambda e: e.frame)

    def load_game_events(self):
        # Copy the events over
        # TODO: the events need to be fixed both on the reader and processor side
        if 'replay.game.events' not in self.raw_data:
            return

        self.game_events = self.raw_data['replay.game.events']
        self.events = sorted(self.events+self.game_events, key=lambda e: e.frame)

        # hideous hack for HotS 2.0.0.23925, see https://github.com/GraylinKim/sc2reader/issues/87
        if self.events and self.events[-1].frame > self.frames:
            self.frames = self.events[-1].frame
            self.length = utils.Length(seconds=int(self.frames/self.game_fps))

    def load_tracker_events(self):
        if 'replay.tracker.events' not in self.raw_data:
            return

        self.tracker_events = self.raw_data['replay.tracker.events']
        self.events = sorted(self.tracker_events + self.events, key=lambda e: e.frame)

    def register_reader(self, data_file, reader, filterfunc=lambda r: True):
        """
        Allows you to specify your own reader for use when reading the data
        files packed into the .SC2Replay archives. Datapacks are checked for
        use with the supplied filterfunc in reverse registration order to give
        user registered datapacks preference over factory default datapacks.

        Don't use this unless you know what you are doing.

        :param data_file: The full file name that you would like this reader to
            parse.

        :param reader: The :class:`Reader` object you wish to use to read the
            data file.

        :param filterfunc: A function that accepts a partially loaded
            :class:`Replay` object as an argument and returns true if the
            reader should be used on this replay.
        """
        self.registered_readers[data_file].insert(0, (filterfunc, reader))

    def register_datapack(self, datapack, filterfunc=lambda r: True):
        """
        Allows you to specify your own datapacks for use when loading replays.
        Datapacks are checked for use with the supplied filterfunc in reverse
        registration order to give user registered datapacks preference over
        factory default datapacks.

        This is how you would add mappings for your favorite custom map.

        :param datapack: A :class:`BaseData` object to use for mapping unit
            types and ability codes to their corresponding classes.

        :param filterfunc: A function that accepts a partially loaded
            :class:`Replay` object as an argument and returns true if the
            datapack should be used on this replay.
        """
        self.registered_datapacks.insert(0, (filterfunc, datapack))

    # Override points
    def register_default_readers(self):
        """Registers factory default readers."""
        self.register_reader('replay.details', readers.DetailsReader(), lambda r: True)
        self.register_reader('replay.initData', readers.InitDataReader(), lambda r: True)
        self.register_reader('replay.tracker.events', readers.TrackerEventsReader(), lambda r: True)
        self.register_reader('replay.message.events', readers.MessageEventsReader(), lambda r: True)
        self.register_reader('replay.attributes.events', readers.AttributesEventsReader(), lambda r: True)

        self.register_reader('replay.game.events', readers.GameEventsReader_15405(), lambda r: 15405 <= r.base_build < 16561)
        self.register_reader('replay.game.events', readers.GameEventsReader_16561(), lambda r: 16561 <= r.base_build < 17326)
        self.register_reader('replay.game.events', readers.GameEventsReader_17326(), lambda r: 17326 <= r.base_build < 18574)
        self.register_reader('replay.game.events', readers.GameEventsReader_18574(), lambda r: 18574 <= r.base_build < 19595)
        self.register_reader('replay.game.events', readers.GameEventsReader_19595(), lambda r: 19595 <= r.base_build < 22612)
        self.register_reader('replay.game.events', readers.GameEventsReader_22612(), lambda r: 22612 <= r.base_build < 23260)
        self.register_reader('replay.game.events', readers.GameEventsReader_23260(), lambda r: 23260 <= r.base_build < 24247)
        self.register_reader('replay.game.events', readers.GameEventsReader_24247(), lambda r: 24247 <= r.base_build < 26490)
        self.register_reader('replay.game.events', readers.GameEventsReader_26490(), lambda r: 26490 <= r.base_build < 27950)
        self.register_reader('replay.game.events', readers.GameEventsReader_27950(), lambda r: 27950 <= r.base_build)
        self.register_reader('replay.game.events', readers.GameEventsReader_HotSBeta(), lambda r: r.versions[1] == 2 and r.build < 24247)

    def register_default_datapacks(self):
        """Registers factory default datapacks."""
        self.register_datapack(datapacks['WoL']['16117'], lambda r: r.expansion == 'WoL' and 16117 <= r.build < 17326)
        self.register_datapack(datapacks['WoL']['17326'], lambda r: r.expansion == 'WoL' and 17326 <= r.build < 18092)
        self.register_datapack(datapacks['WoL']['18092'], lambda r: r.expansion == 'WoL' and 18092 <= r.build < 19458)
        self.register_datapack(datapacks['WoL']['19458'], lambda r: r.expansion == 'WoL' and 19458 <= r.build < 22612)
        self.register_datapack(datapacks['WoL']['22612'], lambda r: r.expansion == 'WoL' and 22612 <= r.build < 24944)
        self.register_datapack(datapacks['WoL']['24944'], lambda r: r.expansion == 'WoL' and 24944 <= r.build)
        self.register_datapack(datapacks['HotS']['base'], lambda r: r.expansion == 'HotS' and r.build < 23925)
        self.register_datapack(datapacks['HotS']['23925'], lambda r: r.expansion == 'HotS' and 23925 <= r.build < 24247)
        self.register_datapack(datapacks['HotS']['24247'], lambda r: r.expansion == 'HotS' and 24247 <= r.build <= 24764)
        self.register_datapack(datapacks['HotS']['24764'], lambda r: r.expansion == 'HotS' and 24764 <= r.build)

    # Internal Methods
    def _get_reader(self, data_file):
        for callback, reader in self.registered_readers[data_file]:
            if callback(self):
                return reader
        else:
            raise ValueError("Valid {0} reader could not found for build {1}".format(data_file, self.build))

    def _get_datapack(self):
        for callback, datapack in self.registered_datapacks:
            if callback(self):
                return datapack
        else:
            return None

    def _read_data(self, data_file, reader):
        data = utils.extract_data_file(data_file, self.archive)
        if data:
            self.raw_data[data_file] = reader(data, self)
        elif self.opt.debug and data_file not in ['replay.message.events', 'replay.tracker.events']:
            raise ValueError("{0} not found in archive".format(data_file))

    def __getstate__(self):
        state = self.__dict__.copy()
        del state['registered_readers']
        del state['registered_datapacks']
        return state


class Map(Resource):
    url_template = 'http://{0}.depot.battle.net:1119/{1}.s2ma'

    #: The localized (only enUS supported right now) map name
    name = str()

    #: The map's author
    author = str()

    #: The map description as written by author
    description = str()

    def __init__(self, map_file, filename=None, region=None, map_hash=None, **options):
        super(Map, self).__init__(map_file, filename, **options)

        #: The unique hash used to identify this map on bnet's depots.
        self.hash = map_hash

        #: The region this map was posted to. Maps must be posted individually to each region.
        self.region = region

        #: A URL reference to the location of this map on bnet's depots.
        self.url = Map.get_url(self.region, map_hash)

        #: The opened MPQArchive for this map
        self.archive = mpyq.MPQArchive(map_file)

        #: A byte string representing the minimap in tga format.
        self.minimap = self.archive.read_file('Minimap.tga')

        # This will only populate the fields for maps with enUS localizations.
        # Clearly this isn't a great solution but we can't be throwing exceptions
        # just because US English wasn't a concern of the map author.
        # TODO: Make this work regardless of the localizations available.
        game_strings = self.archive.read_file('enUS.SC2Data\LocalizedData\GameStrings.txt').decode('utf8')
        if game_strings:
            for line in game_strings.split('\r\n'):
                if len(line) == 0:
                    continue

                key, value = line.split('=', 1)
                if key == 'DocInfo/Name':
                    self.name = value
                elif key == 'DocInfo/Author':
                    self.author = value
                elif key == 'DocInfo/DescLong':
                    self.description = value
                elif key == 'DocInfo/Website':
                    self.website = value

        #: A reference to the map's :class:`~sc2reader.objects.MapInfo` object
        self.map_info = MapInfo(self.archive.read_file('MapInfo'))

        doc_info = ElementTree.fromstring(self.archive.read_file('DocumentInfo').decode('utf8'))

        icon_path_node = doc_info.find('Icon/Value')
        #: (Optional) The path to the icon for the map, relative to the archive root
        self.icon_path = icon_path_node.text if icon_path_node is not None else None

        #: (Optional) The icon image for the map in tga format
        self.icon = self.archive.read_file(self.icon_path) if self.icon_path is not None else None

        #: A list of module names this map depends on
        self.dependencies = list()
        for dependency_node in doc_info.findall('Dependencies/Value'):
            self.dependencies.append(dependency_node.text)

    @classmethod
    def get_url(cls, region, map_hash):
        """Builds a download URL for the map from its components."""
        if region and map_hash:
            # it seems like sea maps are stored on us depots.
            region = 'us' if region == 'sea' else region
            return cls.url_template.format(region, map_hash)
        else:
            return None


class Localization(Resource, dict):

    def __init__(self, s2ml_file, **options):
        Resource.__init__(self, s2ml_file, **options)
        xml = ElementTree.parse(s2ml_file)
        for entry in xml.findall('e'):
            self[int(entry.attrib['id'])] = entry.text


class GameSummary(Resource):

    url_template = 'http://{0}.depot.battle.net:1119/{1}.s2gs'

    #: Game speed
    game_speed = str()

    #: Game length (real-time)
    real_length = int()

    #: Game length (in-game)
    game_length = int()

    #: A dictionary of Lobby properties
    lobby_properties = dict()

    #: A dictionary of Lobby player properties
    lobby_player_properties = dict()

    #: Winners, a list of the pids of the winning players
    winners = list()

    #: Build orders, a dict of build orders indexed by player id
    build_orders = dict()

    #: Map image urls
    image_urls = list()

    #: Map localization urls
    localization_urls = dict()

    def __init__(self, summary_file, filename=None, lang='enUS', **options):
        super(GameSummary, self).__init__(summary_file, filename, lang=lang, **options)

        #: A dict of team# -> teams
        self.team = dict()

        #: A list of teams
        self.teams = list()

        #: Players, a dict of :class`PlayerSummary` from the game
        self.players = list()

        self.observers = list()

        #: Game start and end times
        self.start_time = None
        self.end_time = None

        self.winners = list()
        self.player = dict()
        self.settings = dict()
        self.player_stats = dict()
        self.player_settings = defaultdict(dict)
        self.build_orders = defaultdict(list)
        self.image_urls = list()
        self.localization_urls = dict()
        self.lobby_properties = dict()
        self.lobby_player_properties = dict()
        self.game_type = str()
        self.real_type = str()

        # The first 16 bytes appear to be some sort of compression header
        buffer = BitPackedDecoder(zlib.decompress(summary_file.read()[16:]))

        # TODO: Is there a fixed number of entries?
        # TODO: Maybe the # of parts is recorded somewhere?
        self.parts = list()
        while not buffer.done():
            self.parts.append(buffer.read_struct())

        self.end_time = datetime.utcfromtimestamp(self.parts[0][8])
        self.game_speed = LOBBY_PROPERTIES[0xBB8][1][self.parts[0][0][1].decode('utf8')]
        self.game_length = utils.Length(seconds=self.parts[0][7])
        self.real_length = utils.Length(seconds=int(self.parts[0][7]/GAME_SPEED_FACTOR[self.game_speed]))
        self.start_time = datetime.utcfromtimestamp(self.parts[0][8] - self.real_length.seconds)

        self.load_translations()
        self.load_map_info()
        self.load_settings()
        self.load_player_stats()
        self.load_players()

        dependencies = [sheet[1] for sheet in self.lang_sheets['enUS']]
        if 'Swarm (Mod)' in dependencies:
            self.expansion = 'HotS'
        elif 'Liberty (Mod)' in dependencies:
            self.expansion = 'WoL'
        else:
            self.expansion = ''

        self.game_type = self.settings['Teams'].replace(" ", "")
        self.real_type = utils.get_real_type(self.teams)

        # The s2gs file also keeps reference to a series of s2mv files
        # Some of these appear to be encoded bytes and others appear to be
        # the preview images that authors may bundle with their maps.
        self.s2mv_urls = [str(utils.DepotFile(file_hash)) for file_hash in self.parts[0][6][7]]

    def load_translations(self):
        # This section of the file seems to map numerical ids to their
        # corresponding entries in the localization files (see below).
        # Each mapping has 3 parts:
        #   1: The id to be mapped
        #   2: The localization sheet and entry index to map to
        #   3: A list of ids for the summary tabs the value shows up in
        #
        # In some cases it seems that these ids don't map to an entry so
        # there must be some additional purpose to this section as well.
        #
        self.id_map = dict()
        for mapping in self.parts[1][0]:
            if isinstance(mapping[2][0], dict):
                self.id_map[mapping[1][1]] = (mapping[2][0][1], mapping[2][0][2])

        # The id mappings for lobby and player properties are stored
        # separately in the parts[0][5] entry.
        #
        # The values for each property are also mapped but the values
        # don't have their own unique ids so we use a compound key
        self.lobby_properties = dict()
        for item in self.parts[0][5]:
            uid = item[0][1]
            sheet = item[2][0][1]
            entry = item[2][0][2]
            self.id_map[uid] = (sheet, entry)

            for value in item[1]:
                sheet = value[1][0][1]
                entry = value[1][0][2]
                self.id_map[(uid, value[0])] = (sheet, entry)

        # Each localization is a pairing of a language id, e.g. enUS
        # and a list of byte strings that can be decoded into urls for
        # resources hosted on the battle.net depot servers.
        #
        # Sometimes these byte strings are all NULLed out and need to be ignored.
        for localization in self.parts[0][6][8]:
            language = localization[0].decode('utf8')

            files = list()
            for file_hash in localization[1]:
                if file_hash[:4].decode('utf8') != '\x00\x00\x00\x00':
                    files.append(utils.DepotFile(file_hash))
            self.localization_urls[language] = files

        # Grab the region from the one of the files
        self.region = list(self.localization_urls.values())[0][0].server.lower()

        # Each of the localization urls points to an XML file with a set of
        # localization strings and their unique ids. After reading these mappings
        # into a lang_sheets variable we can use these sheets to make a direct
        # map from internal id to localize string.
        #
        # For now we'll only do this for english localizations.
        self.lang_sheets = dict()
        self.translations = dict()
        for lang, files in self.localization_urls.items():
            if lang != self.opt.lang:
                continue

            sheets = list()
            for depot_file in files:
                sheets.append(self.factory.load_localization(depot_file, **self.opt))

            translation = dict()
            for uid, (sheet, item) in self.id_map.items():
                if sheet < len(sheets) and item in sheets[sheet]:
                    translation[uid] = sheets[sheet][item]
                elif self.opt.debug:
                    msg = "No {0} translation for sheet {1}, item {2}"
                    raise SC2ReaderLocalizationError(msg.format(self.opt.lang, sheet, item))
                else:
                    translation[uid] = "Unknown"

            self.lang_sheets[lang] = sheets
            self.translations[lang] = translation

    def load_map_info(self):
        map_strings = self.lang_sheets[self.opt.lang][-1]
        self.map_name = map_strings[1]
        self.map_description = map_strings[2]
        self.map_tileset = map_strings[3]

    def load_settings(self):
        Property = namedtuple('Property', ['id', 'values', 'requirements', 'defaults', 'is_lobby'])

        properties = dict()
        for p in self.parts[0][5]:
            properties[p[0][1]] = Property(p[0][1], p[1], p[3], p[8], isinstance(p[8], dict))

        settings = dict()
        for setting in self.parts[0][6][6]:
            prop = properties[setting[0][1]]
            if prop.is_lobby:
                settings[setting[0][1]] = setting[1][0]
            else:
                settings[setting[0][1]] = [p[0] for p in setting[1]]

        activated = dict()

        def use_property(prop, player=None):
            # Check the cache before recomputing
            if (prop.id, player) in activated:
                return activated[(prop.id, player)]

            # A property can only be used if it's requirements
            # are both active and have one if the required settings.
            # These settings can be player specific.
            use = False
            for req in prop.requirements:
                requirement = properties[req[0][1][1]]
                if not use_property(requirement, player):
                    break

                setting = settings[req[0][1][1]]

                # Lobby properties can require on player properties.
                # How does this work? I assume that one player satisfying the
                # property requirments is sufficient
                if requirement.is_lobby:
                    values = [setting]
                else:
                    values = [setting[player]] if player is not None else setting

                # Because of the above complication we resort to a set intersection of
                # the applicable values and the set of required values.
                if not set(requirement.values[val][0] for val in values) & set(req[1]):
                    break

            else:
                # Executes if we don't break out of the loop!
                use = True

            # Record the result for future reference and return
            activated[(prop.id, player)] = use
            return use

        translation = self.translations[self.opt.lang]
        for uid, prop in properties.items():
            name = translation.get(uid, "Unknown")
            if prop.is_lobby:
                if use_property(prop):
                    value = prop.values[settings[uid]][0]
                    self.settings[name] = translation[(uid, value)]
            else:
                for index, player_setting in enumerate(settings[uid]):
                    if use_property(prop, index):
                        value = prop.values[player_setting][0]
                        self.player_settings[index][name] = translation[(uid, value)]

    def load_player_stats(self):
        translation = self.translations[self.opt.lang]

        stat_items = sum([p[0] for p in self.parts[3:]], [])

        for item in stat_items:
            # Each stat item is laid out as follows
            #
            #   {
            #     0: {0:999, 1:translation_id},
            #     1: [ [{p1values},...], [{p2values},...], ...]
            #   }
            stat_id = item[0][1]
            if stat_id in translation:
                stat_name = translation[stat_id]
                # Assume anything under 1 million is a normal score screen item
                # Build order ids are generally 16 million+
                if stat_id < 1000000:
                    for pid, value in enumerate(item[1]):
                        if not value:
                            continue

                        if stat_name in ('Army Value', 'Resource Collection Rate', 'Upgrade Spending', 'Workers Active'):
                            # Each point entry for the graph is laid out as follows
                            #
                            #   {0:Value, 1:0, 2:Time}
                            #
                            # The 2nd part of the tuple appears to always be zero and
                            # the time is in seconds of game time.
                            xy = [(point[2], point[0]) for point in value]
                            value = Graph([], [], xy_list=xy)
                        else:
                            value = value[0][0]

                        self.player_stats.setdefault(pid, dict())[stat_name] = value
                else:
                    # Each build item represents one ability and contains
                    # a list of all the uses of that ability by each player
                    # up to the first 64 successful actions in the game.
                    for pindex, commands in enumerate(item[1]):
                        for command in commands:
                            self.build_orders[pindex].append(BuildEntry(
                                supply=command[0],
                                total_supply=command[1] & 0xff,
                                time=int((command[2] >> 8) / 16),
                                order=stat_name,
                                build_index=command[1] >> 16
                            ))
            elif stat_id != 83886080:  # We know this one is always bad.
                self.logger.warn("Untranslatable key = {0}".format(stat_id))

        # Once we've compiled all the build commands we need to make
        # sure they are properly sorted for presentation.
        for build_order in self.build_orders.values():
            build_order.sort(key=lambda x: x.build_index)

    def load_players(self):
        for index, struct in enumerate(self.parts[0][3]):
            if not struct[0] or not struct[0][1]:
                continue  # Slot is closed

            player = PlayerSummary(struct[0][0])
            stats = self.player_stats.get(index, dict())
            settings = self.player_settings[index]
            player.is_ai = not isinstance(struct[0][1], dict)
            if not player.is_ai:
                player.region = self.region
                player.subregion = struct[0][1][0][2]
                player.bnetid = struct[0][1][0][3]
                player.unknown1 = struct[0][1][0]
                player.unknown2 = struct[0][1][1]

            # Either a referee or a spectator, nothing else to do
            if settings.get('Participant Role', '') != 'Participant':
                self.observers.append(player)
                continue

            player.play_race = LOBBY_PROPERTIES[0xBB9][1].get(struct[2], None)

            player.is_winner = isinstance(struct[1], dict) and struct[1][0] == 0
            if player.is_winner:
                self.winners.append(player.pid)

            team_id = int(settings['Team'].split(' ')[1])
            if team_id not in self.team:
                self.team[team_id] = Team(team_id)
                self.teams.append(self.team[team_id])

            player.team = self.team[team_id]
            self.team[team_id].players.append(player)

            # We can just copy these settings right over
            player.color = utils.Color(name=settings.get('Color', None))
            player.pick_race = settings.get('Race', None)
            player.handicap = settings.get('Handicap', None)

            # Overview Tab
            player.resource_score = stats.get('Resources', None)
            player.structure_score = stats.get('Structures', None)
            player.unit_score = stats.get('Units', None)
            player.overview_score = stats.get('Overview', None)

            # Units Tab
            player.units_killed = stats.get('Killed Unit Count', None)
            player.structures_built = stats.get('Structures Built', None)
            player.units_trained = stats.get('Units Trained', None)
            player.structures_razed = stats.get('Structures Razed Count', None)

            # Graphs Tab
            # Keep income_graph for backwards compatibility
            player.army_graph = stats.get('Army Value')
            player.resource_collection_graph = stats.get('Resource Collection Rate', None)
            player.income_graph = player.resource_collection_graph

            # HotS Stats
            player.upgrade_spending_graph = stats.get('Upgrade Spending', None)
            player.workers_active_graph = stats.get('Workers Active', None)
            player.enemies_destroyed = stats.get('Enemies Destroyed:', None)
            player.time_supply_capped = stats.get('Time Supply Capped', None)
            player.idle_production_time = stats.get('Idle Production Time', None)
            player.resources_spent = stats.get('Resources Spent:', None)
            player.apm = stats.get('APM', None)

            # Economic Breakdown Tab
            if isinstance(player.income_graph, Graph):
                values = player.income_graph.values
                player.resource_collection_rate = int(sum(values)/len(values))
            else:
                # In old s2gs files the field with this name was actually a number not a graph
                player.resource_collection_rate = player.income_graph
                player.resource_collection_graph = None
                player.income_graph = None

            player.avg_unspent_resources = stats.get('Average Unspent Resources', None)
            player.workers_created = stats.get('Workers Created', None)

            # Build Orders Tab
            player.build_order = self.build_orders.get(index, None)

            self.players.append(player)
            self.player[player.pid] = player

    def __str__(self):
        return "{0} - {1} {2}".format(self.start_time, self.game_length, 'v'.join(''.join(p.play_race[0] for p in team.players) for team in self.teams))


class MapHeader(Resource):
    """**Experimental**"""

    base_url_template = 'http://{0}.depot.battle.net:1119/{1}.{2}'
    url_template = 'http://{0}.depot.battle.net:1119/{1}.s2mh'
    image_url_template = 'http://{0}.depot.battle.net:1119/{1}.s2mv'

    #: The name of the map
    name = str()

    #: Hash of map file
    map_hash = str()

    #: Link to the map file
    map_url = str()

    #: Hash of the map image
    image_hash = str()

    #: Link to the image of the map (.s2mv)
    image_url = str()

    #: Localization dictionary, {language, url}
    localization_urls = dict()

    #: Blizzard map
    blizzard = False

    def __init__(self, header_file, filename=None, **options):
        super(MapHeader, self).__init__(header_file, filename, **options)
        self.data = BitPackedDecoder(header_file).read_struct()

        # Name
        self.name = self.data[0][1]

        # Blizzard
        self.blizzard = (self.data[0][11] == 'BLIZ')

        # Parse image hash
        parsed_hash = utils.parse_hash(self.data[0][1])
        self.image_hash = parsed_hash['hash']
        self.image_url = self.image_url_template.format(parsed_hash['server'], parsed_hash['hash'])

        # Parse map hash
        parsed_hash = utils.parse_hash(self.data[0][2])
        self.map_hash = parsed_hash['hash']
        self.map_url = self.base_url_template.format(parsed_hash['server'], parsed_hash['hash'], parsed_hash['type'])

        # Parse localization hashes
        l18n_struct = self.data[0][4][8]
        for l in l18n_struct:
            parsed_hash = utils.parse_hash(l[1][0])
            self.localization_urls[l[0]] = self.base_url_template.format(parsed_hash['server'], parsed_hash['hash'], parsed_hash['type'])

########NEW FILE########
__FILENAME__ = sc2attributes
# -*- coding: utf-8 -*-
#
# Recursively searches for s2gs files in specified paths. Adds
# new attributes and values and allows the user to choose when
# conflicts are detected.
#
# Usage: sc2attributes PATH...
#
# Cannot be run from an egg installation because attributes.json
# must be writable. Install from source when you want to use this.
#
# ----------------------------------------------------------------
#
# The file has the following structure:
#
#   sc2reader/data/attributes.json - {
#       "attributes": { json object },
#       "decisions": "pickled python object",
#   }
#
# Why we need to track decisions:
#
# Sometimes the attribute names or values can change over time
# or have values we don't like. When the script detects conflicts
# between the s2gs names and the existing attribute names it
# notifies the user and asks for a decision. In order to save the
# user from making the same decisions over and over again we save
# those decisions. The decisions are pickled instead of in json
# because the data structure is too complex for the json format.
#
from __future__ import absolute_import, print_function, unicode_literals, division

import argparse
import json
import os
import pickle
import traceback

import sc2reader

decisions = dict()


def main():
    global decisions

    parser = argparse.ArgumentParser(description="Recursively parses replay files, inteded for debugging parse issues.")
    parser.add_argument('folders', metavar='folder', type=str, nargs='+', help="Path to a folder")
    args = parser.parse_args()

    scripts_dir = os.path.dirname(os.path.abspath(__file__))
    data_path = os.path.normpath(os.path.join(scripts_dir, '..', 'data', 'attributes.json'))

    attributes = dict()
    if os.path.exists(data_path):
        with open(data_path, 'r') as data_file:
            data = json.load(data_file)
            attributes = data.get('attributes', attributes)
            decisions = pickle.loads(data.get('decisions', '(dp0\n.'))

    for folder in args.folders:
        for path in sc2reader.utils.get_files(folder, extension='s2gs'):
            try:
                summary = sc2reader.load_game_summary(path)
                for prop in summary.parts[0][5]:
                    group_key = prop[0][1]
                    group_name = summary.translations['enUS'][group_key]
                    attribute_values = dict()
                    if str(group_key) in attributes:
                        attribute_name, attribute_values = attributes[str(group_key)]
                        if attribute_name != group_name:
                            group_name = get_choice(group_key, attribute_name, group_name)

                    for value in prop[1]:
                        value_key = value[0].strip("\x00 ").replace(' v ', 'v')
                        value_name = summary.lang_sheets['enUS'][value[1][0][1]][value[1][0][2]]
                        if str(value_key) in attribute_values:
                            attribute_value_name = attribute_values[str(value_key)]
                            if value_name != attribute_value_name:
                                value_name = get_choice((group_key, value_key), attribute_value_name, value_name)

                        attribute_values[str(value_key)] = value_name

                    attributes["{0:0>4}".format(group_key)] = (group_name, attribute_values)
            except Exception as e:
                if isinstance(e, KeyboardInterrupt):
                    raise
                else:
                    traceback.print_exc()

    with open(data_path, 'w') as data_file:
        data = dict(attributes=attributes, decisions=pickle.dumps(decisions))
        json.dump(data, data_file, indent=2, sort_keys=True)


def get_choice(s2gs_key, old_value, new_value):
    global decisions

    # This way old/new values can be swapped and decision is remembered
    key = frozenset([s2gs_key, old_value, new_value])
    if key not in decisions:
        print("Naming conflict on {0}: {1} != {2}".format(s2gs_key, old_value, new_value))
        print("Which do you want to use?")
        print("  (o) Old value '{0}'".format(old_value))
        print("  (n) New value '{0}'".format(new_value))
        while True:
            answer = raw_input("Choose 'o' or 'n' then press enter: ").lower()
            if answer not in ('o', 'n'):
                print('Invalid choice `{0}`'.format(answer))
            else:
                break
        decisions[key] = {'o': old_value, 'n': new_value}[answer]
        print("")
    return decisions[key]


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = sc2json
#!/usr/bin/env python
# -*- coding: utf-8 -*-
from __future__ import absolute_import, print_function, unicode_literals, division

import sc2reader
from sc2reader.factories.plugins.replay import toJSON


def main():
    import argparse
    parser = argparse.ArgumentParser(description="Prints replay data to a json string.")
    parser.add_argument('--indent', '-i', type=int, default=None, help="The per-line indent to use when printing a human readable json string")
    parser.add_argument('--encoding', '-e', type=str, default='UTF-8', help="The character encoding use..")
    parser.add_argument('path', metavar='path', type=str, nargs=1, help="Path to the replay to serialize.")
    args = parser.parse_args()

    factory = sc2reader.factories.SC2Factory()
    factory.register_plugin("Replay", toJSON(encoding=args.encoding, indent=args.indent))
    replay_json = factory.load_replay(args.path[0])
    print(replay_json)

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = sc2parse
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
This script is intended for use debugging parse issues on replays.

    sc2parse [FILES..]

Recursively parses all the files. When exceptions are thrown it catches them
and attempts to print(out any information that might be needed for debug. If
information you need isn't available feel free to add new handlers or add to
existing exception handlers.

Also sets logging to INFO so that missing unit type and ability type messages
are caught and reported. At some point these things should be moved to WARN.

If there are parse exceptions, this script should be run to generate an info
for the ticket filed.
"""
from __future__ import absolute_import, print_function, unicode_literals, division

import argparse
import sc2reader
import traceback

sc2reader.log_utils.log_to_console('INFO')


def main():
    parser = argparse.ArgumentParser(description="Recursively parses replay files, inteded for debugging parse issues.")
    parser.add_argument('--one_each', help="Attempt to parse only one Ladder replay for each release_string", action="store_true")
    parser.add_argument('--ladder_only', help="If a non-ladder game fails, ignore it", action="store_true")
    parser.add_argument('folders', metavar='folder', type=str, nargs='+', help="Path to a folder")
    args = parser.parse_args()

    releases_parsed = set()
    for folder in args.folders:
        print("dealing with {0}".format(folder))
        for path in sc2reader.utils.get_files(folder, extension='SC2Replay'):
            try:
                rs = sc2reader.load_replay(path, load_level=0).release_string
                already_did = rs in releases_parsed
                releases_parsed.add(rs)
                if not args.one_each or not already_did:
                    replay = sc2reader.load_replay(path, debug=True, load_level=1)
                    if not args.one_each or replay.is_ladder:
                        replay = sc2reader.load_replay(path, debug=True)

                        human.pids = set([human.pid for human in replay.humans])
                        event_pids = set([event.player.pid for event in replay.events if getattr(event, 'player', None)])
                        player_pids = set([player.pid for player in replay.players if player.is_human])
                        ability_pids = set([event.player.pid for event in replay.events if 'CommandEvent' in event.name])
                        if human.pids != event_pids:
                            print('Event Pid problem!  pids={pids} but event pids={event_pids}'.format(pids=human.pids, event_pids=event_pids))
                            print(' with {path}: {build} - {real_type} on {map_name} - Played {start_time}'.format(path=path, **replay.__dict__))
                        elif player_pids != ability_pids:
                            print('Ability Pid problem!  pids={pids} but event pids={event_pids}'.format(pids=player_pids, event_pids=ability_pids))
                            print(' with {path}: {build} - {real_type} on {map_name} - Played {start_time}'.format(path=path, **replay.__dict__))
                        else:
                            print('No problems with {path}: {build} - {real_type} on {map_name} - Played {start_time}'.format(path=path, **replay.__dict__))
                            print('Units were: {units}'.format(units=set([obj.name for obj in replay.objects.values()])))

            except sc2reader.exceptions.ReadError as e:
                if args.ladder_only and not e.replay.is_ladder:
                    continue

                print("")
                print(path)
                print('{build} - {real_type} on {map_name} - Played {start_time}'.format(**e.replay.__dict__))
                print('[ERROR]', e.message)
                for event in e.game_events[-5:]:
                    print('{0} - {1}'.format(hex(event.type), event.bytes.encode('hex')))
                print(e.buffer.read_range(e.location, e.location+50).encode('hex'))
                print
            except Exception as e:
                print("")
                print(path)
                try:
                    replay = sc2reader.load_replay(path, debug=True, load_level=2)
                    print('{build} - {real_type} on {map_name} - Played {start_time}'.format(**replay.__dict__))
                    print('[ERROR] {0}'.format(e.message))
                    for pid, attributes in replay.attributes.items():
                        print("{0} {1}".format(pid, attributes))
                    for pid, info in enumerate(replay.raw_data['replay.details'].players):
                        print("{0} {1}".format(pid, info))
                    for message in replay.raw_data['replay.message.events'].messages:
                        print("{0} {1}".format(message.pid, message.text))
                    traceback.print_exc()
                    print("")
                except Exception as e2:
                    replay = sc2reader.load_replay(path, debug=True, load_level=0)
                    print('Total failure parsing {release_string}'.format(**replay.__dict__))
                    print('[ERROR] {0}'.format(e.message))
                    print('[ERROR] {0}'.format(e2.message))
                    traceback.print_exc()
                    print


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = sc2printer
#!/usr/bin/env python
# -*- coding: utf-8 -*-
from __future__ import absolute_import, print_function, unicode_literals, division

import os
import argparse

import sc2reader
from sc2reader import utils
from sc2reader.exceptions import ReadError


def printReplay(filepath, arguments):
    """ Prints summary information about SC2 replay file """
    try:
        replay = sc2reader.load_replay(filepath, debug=True)

        if arguments.map:
            print("   Map:      {0}".format(replay.map_name))
        if arguments.length:
            print("   Length:   {0} minutes".format(replay.game_length))
        if arguments.date:
            print("   Date:     {0}".format(replay.start_time))
        if arguments.teams:
            lineups = [team.lineup for team in replay.teams]
            print("   Teams:    {0}".format("v".join(lineups)))
            for team in replay.teams:
                print("      Team {0}\t{1} ({2})".format(team.number, team.players[0].name, team.players[0].pick_race[0]))
                for player in team.players[1:]:
                    print("              \t{0} ({1})".format(player.name, player.pick_race[0]))
        if arguments.messages:
            print("   Messages:")
            for message in replay.messages:
                print("   {0}".format(message))
        if arguments.version:
            print("   Version:  {0}".format(replay.release_string))

        print
    except ReadError as e:
        raise
        return
        prev = e.game_events[-1]
        print("\nVersion {0} replay:\n\t{1}".format(e.replay.release_string, e.replay.filepath))
        print("\t{0}, Type={1:X}".format(e.msg, e.type))
        print("\tPrevious Event: {0}".format(prev.name))
        print("\t\t"+prev.bytes.encode('hex'))
        print("\tFollowing Bytes:")
        print("\t\t"+e.buffer.read_range(e.location, e.location+30).encode('hex'))
        print("Error with '{0}': ".format(filepath))
        print(e)
    except Exception as e:
        print("Error with '{0}': ".format(filepath))
        print(e)
        raise


def printGameSummary(filepath, arguments):
    summary = sc2reader.load_game_summary(filepath)

    if arguments.map:
        print("   Map:      {0}".format(summary.map_name))
    if arguments.length:
        print("   Length:   {0} minutes".format(summary.game_length))
    if arguments.date:
        print("   Date:     {0}".format(summary.start_time))
    if arguments.teams:
        lineups = [team.lineup for team in summary.teams]
        print("   Teams:    {0}".format("v".join(lineups)))
        for team in summary.teams:
            print("      Team {0}\t{1}".format(team.number, team.players[0]))
            for player in team.players[1:]:
                print("              \t{0}".format(player))
    if arguments.builds:
        for player in summary.players:
            print("\n== {0} ==\n".format(player))
            for order in summary.build_orders[player.pid]:
                msg = "  {0:0>2}:{1:0>2}  {2:<35} {3:0>2}/{4}"
                print(msg.format(order.time / 60, order.time % 60, order.order, order.supply, order.total_supply))
        print("")


def main():
    parser = argparse.ArgumentParser(
        description="""Prints basic information from Starcraft II replay and
        game summary files or directories.""")
    parser.add_argument('--recursive', action="store_true", default=True,
                        help="Recursively read through directories of Starcraft II files [default on]")

    required = parser.add_argument_group('Required Arguments')
    required.add_argument('paths', metavar='filename', type=str, nargs='+',
                          help="Paths to one or more Starcraft II files or directories")

    shared_args = parser.add_argument_group('Shared Arguments')
    shared_args.add_argument('--date', action="store_true", default=True,
                             help="print(game date [default on]")
    shared_args.add_argument('--length', action="store_true", default=False,
                             help="print(game duration mm:ss in game time (not real time) [default off]")
    shared_args.add_argument('--map', action="store_true", default=True,
                             help="print(map name [default on]")
    shared_args.add_argument('--teams', action="store_true", default=True,
                             help="print(teams, their players, and the race matchup [default on]")

    replay_args = parser.add_argument_group('Replay Options')
    replay_args.add_argument('--messages', action="store_true", default=False,
                             help="print(in-game player chat messages [default off]")
    replay_args.add_argument('--version', action="store_true", default=True,
                             help="print(the release string as seen in game [default on]")

    s2gs_args = parser.add_argument_group('Game Summary Options')
    s2gs_args.add_argument('--builds', action="store_true", default=False,
                           help="print(player build orders (first 64 items) [default off]")

    arguments = parser.parse_args()
    for path in arguments.paths:
        depth = -1 if arguments.recursive else 0
        for filepath in utils.get_files(path, depth=depth):
            name, ext = os.path.splitext(filepath)
            if ext.lower() == '.sc2replay':
                print("\n--------------------------------------\n{0}\n".format(filepath))
                printReplay(filepath, arguments)
            elif ext.lower() == '.s2gs':
                print("\n--------------------------------------\n{0}\n".format(filepath))
                printGameSummary(filepath, arguments)

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = sc2replayer
#!/usr/bin/env python
# -*- coding: utf-8 -*-
from __future__ import absolute_import, print_function, unicode_literals, division

try:
    # Assume that we are on *nix or Mac
    import termios
    import fcntl
    import os
    import sys

    def getch():
        fd = sys.stdin.fileno()
        oldterm = termios.tcgetattr(fd)
        newattr = termios.tcgetattr(fd)
        newattr[3] = newattr[3] & ~termios.ICANON & ~termios.ECHO
        termios.tcsetattr(fd, termios.TCSANOW, newattr)
        oldflags = fcntl.fcntl(fd, fcntl.F_GETFL)
        fcntl.fcntl(fd, fcntl.F_SETFL, oldflags | os.O_NONBLOCK)
        try:
            while 1:
                try:
                    sys.stdin.read(1)
                    break
                except IOError:
                    pass
        finally:
            termios.tcsetattr(fd, termios.TCSAFLUSH, oldterm)
            fcntl.fcntl(fd, fcntl.F_SETFL, oldflags)

except ImportError as e:
    try:
        # Opps, we might be on windows, try this one
        from msvcrt import getch
    except ImportError as e:
        # We can't make getch happen, just dump events to the screen
        getch = lambda: True


import argparse
import sc2reader
from sc2reader.events import *


def main():
    parser = argparse.ArgumentParser(
        description="""Step by step replay of game events; shows only the
        Initialization, Command, and Selection events by default. Press any
        key to advance through the events in sequential order."""
    )

    parser.add_argument('FILE', type=str, help="The file you would like to replay")
    parser.add_argument('--player', default=0, type=int, help="The number of the player you would like to watch. Defaults to 0 (All).")
    parser.add_argument('--bytes', default=False, action="store_true", help="Displays the byte code of the event in hex after each event.")
    parser.add_argument('--hotkeys', default=False, action="store_true", help="Shows the hotkey events in the event stream.")
    parser.add_argument('--cameras', default=False, action="store_true", help="Shows the camera events in the event stream.")
    args = parser.parse_args()

    for filename in sc2reader.utils.get_files(args.FILE):
        replay = sc2reader.load_replay(filename, debug=True)
        print("Release {0}".format(replay.release_string))
        print("{0} on {1} at {2}".format(replay.type, replay.map_name, replay.start_time))
        print("")
        for team in replay.teams:
            print(team)
            for player in team.players:
                print("  {0}".format(player))
        print("\n--------------------------\n\n")

        # Allow picking of the player to 'watch'
        if args.player:
            events = replay.player[args.player].events
        else:
            events = replay.events

        # Allow specification of events to `show`
        # Loop through the events
        for event in events:

            if isinstance(event, CommandEvent) or \
                    isinstance(event, SelectionEvent) or \
                    isinstance(event, PlayerLeaveEvent) or \
                    isinstance(event, GameStartEvent) or \
                    (args.hotkeys and isinstance(event, HotkeyEvent)) or \
                    (args.cameras and isinstance(event, CameraEvent)):
                print(event)
                getch()
                if args.bytes:
                    print("\t"+event.bytes.encode('hex'))


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = utils
# -*- coding: utf-8 -*-
from __future__ import absolute_import, print_function, unicode_literals, division

import argparse
import re
import textwrap


class Formatter(argparse.RawTextHelpFormatter):
    """FlexiFormatter which respects new line formatting and wraps the rest

    Example:
        >>> parser = argparse.ArgumentParser(formatter_class=FlexiFormatter)
        >>> parser.add_argument('a',help='''\
        ...     This argument's help text will have this first long line\
        ...     wrapped to fit the target window size so that your text\
        ...     remains flexible.
        ...
        ...         1. This option list
        ...         2. is still persisted
        ...         3. and the option strings get wrapped like this\
        ...            with an indent for readability.
        ...
        ...     You must use backslashes at the end of lines to indicate that\
        ...     you want the text to wrap instead of preserving the newline.
        ... ''')

    Only the name of this class is considered a public API. All the methods
    provided by the class are considered an implementation detail.
    """

    @classmethod
    def new(cls, **options):
        return lambda prog: Formatter(prog, **options)

    def _split_lines(self, text, width):
        lines = list()
        main_indent = len(re.match(r'( *)', text).group(1))
        # Wrap each line individually to allow for partial formatting
        for line in text.splitlines():

            # Get this line's indent and figure out what indent to use
            # if the line wraps. Account for lists of small variety.
            indent = len(re.match(r'( *)', line).group(1))
            list_match = re.match(r'( *)(([*-+>]+|\w+\)|\w+\.) +)', line)
            if(list_match):
                sub_indent = indent + len(list_match.group(2))
            else:
                sub_indent = indent

            # Textwrap will do all the hard work for us
            line = self._whitespace_matcher.sub(' ', line).strip()
            new_lines = textwrap.wrap(
                text=line,
                width=width,
                initial_indent=' '*(indent-main_indent),
                subsequent_indent=' '*(sub_indent-main_indent),
            )

            # Blank lines get eaten by textwrap, put it back with [' ']
            lines.extend(new_lines or [' '])

        return lines

########NEW FILE########
__FILENAME__ = utils
# -*- coding: utf-8 -*-
from __future__ import absolute_import, print_function, unicode_literals, division

import binascii
import os
import json
from datetime import timedelta, datetime

from sc2reader.log_utils import loggable
from sc2reader.exceptions import MPQError
from sc2reader.constants import COLOR_CODES, COLOR_CODES_INV


class DepotFile(object):
    """
    :param bytes: The raw bytes representing the depot file

    The DepotFile object parses bytes for a dependency into their components
    and assembles them into a URL so that the dependency can be fetched.
    """

    #: The url template for all DepotFiles
    url_template = 'http://{0}.depot.battle.net:1119/{1}.{2}'

    def __init__(self, bytes):
        #: The server the file is hosted on
        self.server = bytes[4:8].decode('utf-8').strip('\x00 ')

        # There is no SEA depot, use US instead
        if self.server == 'SEA':
            self.server = 'US'

        #: The unique content based hash of the file
        self.hash = binascii.b2a_hex(bytes[8:]).decode('utf8')

        #: The extension of the file on the server
        self.type = bytes[0:4].decode('utf8')

    @property
    def url(self):
        """ Returns url of the depot file. """
        return self.url_template.format(self.server, self.hash, self.type)

    def __hash__(self):
        return hash(self.url)

    def __str__(self):
        return self.url


class PersonDict(dict):
    """
    Deprecated!

    Supports lookup on both the player name and player id

    ::

        person = PersonDict()
        person[1] = Player(1,"ShadesofGray")
        me = person.name("ShadesofGray")
        del person[me.pid]

    Delete is supported on the player id only
    """
    def __init__(self):
        super(PersonDict, self).__init__()
        self._key_map = dict()

    def name(self, player_name):
        """ deprecated because it is possible for multiple players to have the same name. """
        return self[self._key_map[player_name]]

    def __setitem__(self, key, value):
        self._key_map[value.name] = key
        super(PersonDict, self).__setitem__(key, value)


def windows_to_unix(windows_time):
    # This windows timestamp measures the number of 100 nanosecond periods since
    # January 1st, 1601. First we subtract the number of nanosecond periods from
    # 1601-1970, then we divide by 10^7 to bring it back to seconds.
    return int((windows_time-116444735995904000)/10**7)


class AttributeDict(dict):
    """
    Support access to dictionary items via the dot syntax as though they
    were class attributes. Also support setting new keys via dot syntax.
    """
    def __getattr__(self, name):
        try:
            return self[name]
        except KeyError:
            raise AttributeError('No such attribute {0}'.format(name))

    def __setattr__(self, name, value):
        self[name] = value

    def copy(self):
        return AttributeDict(self.items())


@loggable
class Color(object):
    """
    Stores a color name and rgba representation of a color. Individual
    color components can be retrieved with the dot operator::

        color = Color(r=255, g=0, b=0, a=75)
        tuple(color.r,color.g, color.b, color.a) == color.rgba

    You can also create a color by name.

        color = Color('Red')

    Only standard Starcraft colors are supported. ValueErrors will be thrown
    on invalid names or hex values.
    """
    def __init__(self, name=None, r=0, g=0, b=0, a=255):
        if name:
            if name not in COLOR_CODES_INV:
                self.logger.warn("Invalid color name: " + name)
            hexstr = COLOR_CODES_INV.get(name, '000000')
            self.r = int(hexstr[0:2], 16)
            self.g = int(hexstr[2:4], 16)
            self.b = int(hexstr[4:6], 16)
            self.a = 255
            self.name = name
        else:
            self.r = r
            self.g = g
            self.b = b
            self.a = a
            if self.hex not in COLOR_CODES:
                self.logger.warn("Invalid color hex value: " + self.hex)
            self.name = COLOR_CODES.get(self.hex, self.hex)

    @property
    def rgba(self):
        """ Returns a tuple containing the color's (r,g,b,a) """
        return (self.r, self.g, self.b, self.a)

    @property
    def hex(self):
        """The hexadecimal representation of the color"""
        return "{0.r:02X}{0.g:02X}{0.b:02X}".format(self)

    def __str__(self):
        return self.name


def get_real_type(teams):
    # Special case FFA games and sort outmatched games in ascending order
    team_sizes = [len(team.players) for team in teams]
    if len(team_sizes) > 2 and sum(team_sizes) == len(team_sizes):
        return "FFA"
    else:
        return "v".join(str(size) for size in sorted(team_sizes))


def extract_data_file(data_file, archive):

    def recovery_attempt():
        try:
            return archive.read_file(data_file)
        except Exception:
            return None

    # Wrap all mpyq related exceptions so they can be distinguished
    # from other sc2reader issues later on.
    try:
        # Some replays tampered with by 3rd party software report
        # block sizes wrong. They can either over report or under
        # report. If they over report a non-compressed file might
        # attempt decompression. If they under report a compressed
        # file might bypass decompression. So do this:
        #
        # * Force a decompression to catch under reporting
        # * If that fails, try to process normally
        # * mpyq doesn't allow you to skip decompression, so fail
        #
        # Refs: arkx/mpyq#12, GraylinKim/sc2reader#102
        try:
            file_data = archive.read_file(data_file, force_decompress=True)
        except Exception as e:
            file_data = recovery_attempt()
            if file_data is None:
                raise

        return file_data

    except Exception as e:
        # Python2 and Python3 handle wrapped exceptions with old tracebacks in incompatible ways
        # Python3 handles it by default and Python2's method won't compile in python3
        # Since the underlying traceback isn't important to most people, don't expose it anymore
        raise MPQError("Unable to extract file: {0}".format(data_file), e)


def merged_dict(a, b):
    c = a.copy()
    c.update(b)
    return c


def get_files(path, exclude=list(), depth=-1, followlinks=False, extension=None, **extras):
    """
    Retrieves files from the given path with configurable behavior.

    :param path: Path to search for files
    :param depth: Limits the depth of the search. -1 = Unlimited
    :param followLinks: Enables the search to follow links.
    :param exclude: Excludes subdirectories with names in this list.
    :param extension: Restricts results to files matching the given extension."
    """
    # os.walk and os.path.isfile fail silently. We want to be loud!
    if not os.path.exists(path):
        raise ValueError("Location `{0}` does not exist".format(path))

    # If an extension is supplied, use it to do a type check
    if extension:
        type_check = lambda path: os.path.splitext(path)[1][1:].lower() == extension.lower()
    else:
        type_check = lambda n: True

    # os.walk can't handle file paths, only directories
    if os.path.isfile(path):
        if type_check(path):
            yield path
        else:
            pass  # return and halt the generator

    else:
        for root, directories, filenames in os.walk(path, followlinks=followlinks):
            # Exclude the indicated directories by removing them from `directories`
            for directory in list(directories):
                if directory in exclude or depth == 0:
                    directories.remove(directory)

            # Extend our return value only with the allowed file type and regex
            for filename in filter(type_check, filenames):
                yield os.path.join(root, filename)

            depth -= 1


class Length(timedelta):
    """ Extends the builtin timedelta class. See python docs for more info on
        what capabilities this gives you.
    """

    @property
    def hours(self):
        """ The number of hours in represented. """
        return self.seconds//3600

    @property
    def mins(self):
        """ The number of minutes in excess of the hours. """
        return self.seconds//60 % 60

    @property
    def secs(self):
        """ The number of seconds in excess of the minutes. """
        return self.seconds % 60

    def __str__(self):
        if self.hours:
            return "{0:0>2}.{1:0>2}.{2:0>2}".format(self.hours, self.mins, self.secs)
        else:
            return "{0:0>2}.{1:0>2}".format(self.mins, self.secs)


class JSONDateEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, datetime):
            return obj.strftime("%Y-%m-%d %H:%M:%S")
        return json.JSONEncoder.default(self, obj)


def toJSON(replay, **user_options):
    options = dict(cls=JSONDateEncoder)
    options.update(user_options)
    return json.dumps(toDict(replay), **options)


def toDict(replay):
    # Build observers into dictionary
    observers = list()
    for observer in replay.observers:
        messages = list()
        for message in getattr(observer, 'messages', list()):
            messages.append({
                'time': message.time.seconds,
                'text': message.text,
                'is_public': message.to_all
            })
        observers.append({
            'name': getattr(observer, 'name', None),
            'pid': getattr(observer, 'pid', None),
            'messages': messages,
        })

    # Build players into dictionary
    players = list()
    for player in replay.players:
        messages = list()
        for message in player.messages:
            messages.append({
                'time': message.time.seconds,
                'text': message.text,
                'is_public': message.to_all
            })
        players.append({
            'avg_apm': getattr(player, 'avg_apm', None),
            'color': player.color.__dict__ if hasattr(player, 'color') else None,
            'handicap': getattr(player, 'handicap', None),
            'name': getattr(player, 'name', None),
            'pick_race': getattr(player, 'pick_race', None),
            'pid': getattr(player, 'pid', None),
            'play_race': getattr(player, 'play_race', None),
            'result': getattr(player, 'result', None),
            'type': getattr(player, 'type', None),
            'uid': getattr(player, 'uid', None),
            'url': getattr(player, 'url', None),
            'messages': messages,
        })

    # Consolidate replay metadata into dictionary
    return {
        'region': getattr(replay, 'region', None),
        'map_name': getattr(replay, 'map_name', None),
        'file_time': getattr(replay, 'file_time', None),
        'filehash': getattr(replay, 'filehash', None),
        'unix_timestamp': getattr(replay, 'unix_timestamp', None),
        'date': getattr(replay, 'date', None),
        'utc_date': getattr(replay, 'utc_date', None),
        'speed': getattr(replay, 'speed', None),
        'category': getattr(replay, 'category', None),
        'type': getattr(replay, 'type', None),
        'is_ladder': getattr(replay, 'is_ladder', False),
        'is_private': getattr(replay, 'is_private', False),
        'filename': getattr(replay, 'filename', None),
        'file_time': getattr(replay, 'file_time', None),
        'frames': getattr(replay, 'frames', None),
        'build': getattr(replay, 'build', None),
        'release': getattr(replay, 'release_string', None),
        'game_fps': getattr(replay, 'game_fps', None),
        'game_length': getattr(getattr(replay, 'game_length', None), 'seconds', None),
        'players': players,
        'observers': observers,
        'real_length': getattr(getattr(replay, 'real_length', None), 'seconds', None),
        'real_type': getattr(replay, 'real_type', None),
        'time_zone': getattr(replay, 'time_zone', None),
        'versions': getattr(replay, 'versions', None)
    }

########NEW FILE########
__FILENAME__ = test_all
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals

import datetime
import json

# Newer unittest features aren't built in for python 2.6
import sys
if sys.version_info[:2] < (2, 7):
    import unittest2 as unittest
else:
    import unittest

import sc2reader

sc2reader.log_utils.log_to_console("INFO")


class TestReplays(unittest.TestCase):

    def test_teams(self):
        replay = sc2reader.load_replay("test_replays/1.2.2.17811/13.SC2Replay")
        self.assertNotEqual(replay.player[1].team.number, replay.player[2].team.number)

        replay = sc2reader.load_replay("test_replays/2.0.8.25604/mlg1.SC2Replay")
        self.assertNotEqual(replay.player[1].team.number, replay.player[2].team.number)

    def test_private_category(self):
        replay = sc2reader.load_replay("test_replays/1.2.2.17811/2.SC2Replay")
        self.assertEqual(replay.expansion, "WoL")
        self.assertTrue(replay.is_private, True)
        self.assertFalse(replay.is_ladder, False)

    def test_standard_1v1(self):
        replay = sc2reader.load_replay("test_replays/1.2.2.17811/1.SC2Replay")

        self.assertEqual(replay.expansion, "WoL")
        self.assertEqual(str(replay.length), "32.47")
        self.assertEqual(str(replay.game_length), "32.47")
        self.assertEqual(str(replay.real_length), "23.25")
        self.assertEqual(replay.map_name, "Lost Temple")
        self.assertEqual(replay.build, 17811)
        self.assertEqual(replay.release_string, "1.2.2.17811")
        self.assertEqual(replay.speed, "Faster")
        self.assertEqual(replay.type, "1v1")

        self.assertTrue(replay.is_ladder)
        self.assertFalse(replay.is_private)

        self.assertEqual(len(replay.players), 2)
        self.assertEqual(replay.person[1].name, "Emperor")
        self.assertEqual(replay.person[2].name, "Boom")

        emperor = replay.person[1]
        self.assertEqual(emperor.team.number, 1)
        self.assertEqual(emperor.pick_race, "Protoss")
        self.assertEqual(emperor.play_race, "Protoss")
        # self.assertFalse(emperor.recorder)

        boom = replay.person[2]
        self.assertEqual(boom.team.number, 2)
        self.assertEqual(boom.pick_race, "Terran")
        self.assertEqual(boom.play_race, "Terran")
        # self.assertTrue(boom.recorder)

        for player in replay.players:
            self.assertTrue(player.is_human)

        # Because it is a 1v1 and the recording player quit, we should know the winner.
        self.assertEqual(emperor.result, "Win")
        self.assertEqual(boom.result, "Loss")

        self.assertEqual(emperor.url, "http://eu.battle.net/sc2/en/profile/520049/1/Emperor/")
        self.assertEqual(boom.url, "http://eu.battle.net/sc2/en/profile/1694745/1/Boom/")

        self.assertEqual(len(replay.messages), 12)
        self.assertEqual(replay.messages[0].text, "hf")
        self.assertEqual(replay.messages[0].player.name, "Emperor")
        self.assertEqual(replay.messages[1].text, "HEYA")
        self.assertEqual(replay.messages[1].player.name, "Boom")
        self.assertEqual(replay.messages[2].text, "gl hf")
        self.assertEqual(replay.messages[2].player.name, "Boom")
        self.assertEqual(replay.messages[3].text, "sry for caps")
        self.assertEqual(replay.messages[3].player.name, "Boom")
        self.assertEqual(replay.messages[4].text, "^^")
        self.assertEqual(replay.messages[4].player.name, "Emperor")
        self.assertEqual(replay.messages[5].text, "noppe")
        self.assertEqual(replay.messages[5].player.name, "Emperor")
        self.assertEqual(replay.messages[6].text, "you greedy bastard")
        self.assertEqual(replay.messages[6].player.name, "Boom")
        self.assertEqual(replay.messages[7].text, "ggg")
        self.assertEqual(replay.messages[7].player.name, "Boom")
        self.assertEqual(replay.messages[8].text, "WG")
        self.assertEqual(replay.messages[8].player.name, "Emperor")
        self.assertEqual(replay.messages[9].text, "wg? :)")
        self.assertEqual(replay.messages[9].player.name, "Boom")
        self.assertEqual(replay.messages[10].text, "wipe")
        self.assertEqual(replay.messages[10].player.name, "Emperor")
        self.assertEqual(replay.messages[11].text, "huh?")
        self.assertEqual(replay.messages[11].player.name, "Boom")

        for msg in replay.messages:
            self.assertTrue(msg.to_all)

    def test_2v2(self):
        replay = sc2reader.load_replay("test_replays/1.2.2.17811/7.SC2Replay")
        self.assertEqual(replay.type, "2v2")

    def test_3v3(self):
        replay = sc2reader.load_replay("test_replays/1.2.2.17811/3.SC2Replay")
        self.assertEqual(replay.type, "3v3")

        # Because it"s a 3v3 and all of the members of Team 2 quit, we should know the winner.
        self.assertEqual(replay.team[1].result, "Win")
        self.assertEqual(replay.team[2].result, "Loss")

    def test_4v4(self):
        replay = sc2reader.load_replay("test_replays/1.2.0.17326/9.SC2Replay")
        self.assertEqual(replay.type, "4v4")

    def test_ffa(self):
        replay = sc2reader.load_replay("test_replays/1.2.2.17811/8.SC2Replay")
        self.assertEqual(replay.type, "FFA")
        self.assertEqual(replay.winner.players[0].name, "Boom")

    def test_unknown_winner(self):
        replay = sc2reader.load_replay("test_replays/1.2.2.17811/10.SC2Replay")

        # Recording player (Boom) left second in a 4v4, so the winner shouldn"t be known
        self.assertEqual(replay.winner, None)

    def test_random_player(self):
        replay = sc2reader.load_replay("test_replays/1.2.2.17811/3.SC2Replay")
        gogeta = next(player for player in replay.players if player.name == "Gogeta")
        self.assertEqual(gogeta.pick_race, "Random")
        self.assertEqual(gogeta.play_race, "Terran")

        replay = sc2reader.load_replay("test_replays/1.2.2.17811/6.SC2Replay")
        permafrost = next(player for player in replay.players if player.name == "Permafrost")
        self.assertEqual(permafrost.pick_race, "Random")
        self.assertEqual(permafrost.play_race, "Protoss")

    def test_us_realm(self):
        replay = sc2reader.load_replay("test_replays/1.2.2.17811/5.SC2Replay")
        shadesofgray = [player for player in replay.players if player.name == "ShadesofGray"][0]
        reddawn = [player for player in replay.players if player.name == "reddawn"][0]
        self.assertEqual(shadesofgray.url, "http://us.battle.net/sc2/en/profile/2358439/1/ShadesofGray/")
        self.assertEqual(reddawn.url, "http://us.battle.net/sc2/en/profile/2198663/1/reddawn/")

    def test_kr_realm_and_tampered_messages(self):
        """
        # TODO: Current problem.. both players are set as the recording players
        # Waiting for response https://github.com/arkx/mpyq/issues/closed#issue/7
        """
        replay = sc2reader.load_replay("test_replays/1.1.3.16939/11.SC2Replay")
        self.assertEqual(replay.expansion, "WoL")
        first = [player for player in replay.players if player.name == "명지대학교"][0]
        second = [player for player in replay.players if player.name == "티에스엘사기수"][0]
        self.assertEqual(first.url, "http://kr.battle.net/sc2/en/profile/258945/1/명지대학교/")
        self.assertEqual(second.url, "http://kr.battle.net/sc2/en/profile/102472/1/티에스엘사기수/")
        self.assertEqual(replay.messages[0].text, "sc2.replays.net")
        self.assertEqual(replay.messages[5].text, "sc2.replays.net")

    def test_referee(self):
        replay = sc2reader.load_replay("test_replays/1.2.2.17811/14.SC2Replay")

    def test_encrypted(self):
        replay = sc2reader.load_replay("test_replays/1.2.2.17811/4.SC2Replay")

    def test_observers(self):
        replay = sc2reader.load_replay("test_replays/1.2.2.17811/13.SC2Replay")

    def test_datetimes(self):
        # Ignore seconds in comparisons, because they are off by one what is reported by Windows.
        # This might be a little nuance worth investigating at some point.

        # Played at 20 Feb 2011 22:44:48 UTC+2
        replay = sc2reader.load_replay("test_replays/1.2.2.17811/1.SC2Replay")
        self.assertEqual(replay.end_time, datetime.datetime(2011, 2, 20, 20, 44, 47))

        # Played at 21 Feb 2011 00:42:13 UTC+2
        replay = sc2reader.load_replay("test_replays/1.2.2.17811/2.SC2Replay")
        self.assertEqual(replay.end_time, datetime.datetime(2011, 2, 20, 22, 42, 12))

        # Played at 25 Feb 2011 16:36:28 UTC+2
        replay = sc2reader.load_replay("test_replays/1.2.2.17811/3.SC2Replay")
        self.assertEqual(replay.end_time, datetime.datetime(2011, 2, 25, 14, 36, 26))

    def test_hots_pids(self):
        for replayfilename in [
            "test_replays/2.0.3.24764/Akilon Wastes (10).SC2Replay",
            "test_replays/2.0.3.24764/Antiga Shipyard (3).SC2Replay",
            "test_replays/2.0.0.24247/molten.SC2Replay",
            "test_replays/2.0.0.23925/Akilon Wastes.SC2Replay",
            ]:

            replay = sc2reader.load_replay(replayfilename)
            self.assertEqual(replay.expansion, "HotS")
            player_pids = set([player.pid for player in replay.players if player.is_human])
            ability_pids = set([event.player.pid for event in replay.events if "CommandEvent" in event.name])
            self.assertEqual(ability_pids, player_pids)

    def test_wol_pids(self):
        replay = sc2reader.load_replay("test_replays/1.5.4.24540/ggtracker_1471849.SC2Replay")
        self.assertEqual(replay.expansion, "WoL")
        ability_pids = set([event.player.pid for event in replay.events if "CommandEvent" in event.name])
        player_pids = set([player.pid for player in replay.players])
        self.assertEqual(ability_pids, player_pids)

    def test_hots_hatchfun(self):
        replay = sc2reader.load_replay("test_replays/2.0.0.24247/molten.SC2Replay")
        player_pids = set([ player.pid for player in replay.players])
        spawner_pids = set([ event.player.pid for event in replay.events if "TargetUnitCommandEvent" in event.name and event.ability.name == "SpawnLarva"])
        self.assertTrue(spawner_pids.issubset(player_pids))

    def test_hots_vs_ai(self):
        replay = sc2reader.load_replay("test_replays/2.0.0.24247/Cloud Kingdom LE (13).SC2Replay")
        self.assertEqual(replay.expansion, "HotS")
        replay = sc2reader.load_replay("test_replays/2.0.0.24247/Korhal City (19).SC2Replay")
        self.assertEqual(replay.expansion, "HotS")

    def test_oracle_parsing(self):
        replay = sc2reader.load_replay("test_replays/2.0.3.24764/ggtracker_1571740.SC2Replay")
        self.assertEqual(replay.expansion, "HotS")
        oracles = [unit for unit in replay.objects.values() if unit.name == "Oracle"]
        self.assertEqual(len(oracles), 2)

    def test_resume_from_replay(self):
        replay = sc2reader.load_replay("test_replays/2.0.3.24764/resume_from_replay.SC2Replay")
        self.assertTrue(replay.resume_from_replay)
        self.assertEqual(replay.resume_method, 0)

    def test_clan_players(self):
        replay = sc2reader.load_replay("test_replays/2.0.4.24944/Lunar Colony V.SC2Replay")
        self.assertEqual(replay.expansion, "WoL")
        self.assertEqual(len(replay.people), 4)

    def test_WoL_204(self):
        replay = sc2reader.load_replay("test_replays/2.0.4.24944/ggtracker_1789768.SC2Replay")
        self.assertEqual(replay.expansion, "WoL")
        self.assertEqual(len(replay.people), 2)

    def test_send_resources(self):
        replay = sc2reader.load_replay("test_replays/2.0.4.24944/Backwater Complex (15).SC2Replay")

    def test_cn_replays(self):
        replay = sc2reader.load_replay("test_replays/2.0.5.25092/cn1.SC2Replay")
        self.assertEqual(replay.region, "cn")
        self.assertEqual(replay.expansion, "WoL")

    def test_unit_types(self):
        """ sc2reader#136 regression test """
        replay = sc2reader.load_replay('test_replays/2.0.8.25604/issue136.SC2Replay')
        hellion_times = [u.started_at for u in replay.players[0].units if u.name == 'Hellion']
        hellbat_times = [u.started_at for u in replay.players[0].units if u.name == 'BattleHellion']
        self.assertEqual(hellion_times, [5180, 5183])
        self.assertEqual(hellbat_times, [6736, 6741, 7215, 7220, 12004, 12038])

    @unittest.expectedFailure
    def test_outmatched_pids(self):
        replay = sc2reader.load_replay('test_replays/2.0.8.25604/issue131_arid_wastes.SC2Replay')
        self.assertEqual(replay.players[0].pid, 1)
        self.assertEqual(replay.players[1].pid, 3)
        self.assertEqual(replay.players[2].pid, 4)

        replay = sc2reader.load_replay('test_replays/2.0.8.25604/issue135.SC2Replay')
        self.assertEqual(replay.players[0].pid, 1)
        self.assertEqual(replay.players[1].pid, 2)
        self.assertEqual(replay.players[2].pid, 4)

        replay = sc2reader.load_replay("test_replays/2.0.8.25604/mlg1.SC2Replay")
        self.assertEqual(replay.players[0].pid, 1)
        self.assertEqual(replay.players[1].pid, 2)
        self.assertEqual(len(replay.players), 2)
        self.assertEqual(len(replay.people), 3)

    def test_map_info(self):
        replay = sc2reader.load_replay("test_replays/1.5.3.23260/ggtracker_109233.SC2Replay", load_map=True)
        self.assertEqual(replay.map.map_info.tile_set, 'Avernus')
        self.assertEqual(replay.map.map_info.fog_type, 'Dark')
        self.assertEqual(replay.map.map_info.width, 176)
        self.assertEqual(replay.map.map_info.height, 160)
        self.assertEqual(replay.map.map_info.camera_top, 134)
        self.assertEqual(replay.map.map_info.camera_left, 14)
        self.assertEqual(replay.map.map_info.camera_right, 162)
        self.assertEqual(replay.map.map_info.camera_bottom, 14)
        controllers = [(p.pid, p.control) for p in replay.map.map_info.players]
        self.assertEqual(controllers, [(0, 3), (1, 1), (2, 1), (15, 4)])

    def test_engine_plugins(self):
        from sc2reader.engine.plugins import ContextLoader, APMTracker, SelectionTracker

        replay = sc2reader.load_replay(
            "test_replays/2.0.5.25092/cn1.SC2Replay",
            engine=sc2reader.engine.GameEngine(plugins=[
                ContextLoader(),
                APMTracker(),
                SelectionTracker(),
            ])
        )

        code, details = replay.plugins['ContextLoader']
        self.assertEqual(code, 0)
        self.assertEqual(details, dict())

    def test_factory_plugins(self):
        from sc2reader.factories.plugins.replay import APMTracker, SelectionTracker, toJSON

        factory = sc2reader.factories.SC2Factory()
        factory.register_plugin("Replay", APMTracker())
        factory.register_plugin("Replay", SelectionTracker())
        factory.register_plugin("Replay", toJSON())
        replay = factory.load_replay("test_replays/2.0.5.25092/cn1.SC2Replay")

        # Load and quickly check the JSON output consistency
        result = json.loads(replay)
        self.assertEqual(result["map_name"], "生化实验区")
        self.assertEqual(result["players"][2]["name"], "ImYoonA")
        self.assertEqual(result["players"][2]["avg_apm"], 84.52332657200812)
        self.assertEqual(result["release"], "2.0.5.25092")
        self.assertEqual(result["game_length"], 986)
        self.assertEqual(result["real_length"], 704)
        self.assertEqual(result["region"], "cn")
        self.assertEqual(result["game_fps"], 16.0)
        self.assertTrue(result["is_ladder"])

    def test_gameheartnormalizer_plugin(self):
        from sc2reader.engine.plugins import GameHeartNormalizer
        sc2reader.engine.register_plugin(GameHeartNormalizer())

        # Not a GameHeart game!
        replay = sc2reader.load_replay("test_replays/2.0.0.24247/molten.SC2Replay")
        player_pids = set([ player.pid for player in replay.players])
        spawner_pids = set([ event.player.pid for event in replay.events if "TargetUnitCommandEvent" in event.name and event.ability.name == "SpawnLarva"])
        self.assertTrue(spawner_pids.issubset(player_pids))

        replay = sc2reader.load_replay("test_replays/gameheart/gameheart.SC2Replay")
        self.assertEqual(replay.events[0].frame, 0)
        self.assertEqual(replay.game_length.seconds, 636)
        self.assertEqual(len(replay.observers), 5)
        self.assertEqual(replay.players[0].name, 'SjoWBBII')
        self.assertEqual(replay.players[0].play_race, 'Terran')
        self.assertEqual(replay.players[1].name, 'Stardust')
        self.assertEqual(replay.players[1].play_race, 'Protoss')
        self.assertEqual(len(replay.teams), 2)
        self.assertEqual(replay.teams[0].players[0].name, 'SjoWBBII')
        self.assertEqual(replay.teams[1].players[0].name, 'Stardust')
        self.assertEqual(replay.winner, replay.teams[1])

        replay = sc2reader.load_replay("test_replays/gameheart/gh_sameteam.SC2Replay")
        self.assertEqual(replay.events[0].frame, 0)
        self.assertEqual(replay.game_length.seconds, 424)
        self.assertEqual(len(replay.observers), 5)
        self.assertEqual(replay.players[0].name, 'EGJDRC')
        self.assertEqual(replay.players[0].play_race, 'Zerg')
        self.assertEqual(replay.players[1].name, 'LiquidTaeJa')
        self.assertEqual(replay.players[1].play_race, 'Terran')
        self.assertEqual(len(replay.teams), 2)
        self.assertEqual(replay.teams[0].players[0].name, 'EGJDRC')
        self.assertEqual(replay.teams[1].players[0].name, 'LiquidTaeJa')
        self.assertEqual(replay.winner, replay.teams[0])

    def test_replay_event_order(self):
        replay = sc2reader.load_replay("test_replays/event_order.SC2Replay")

    def test_daedalus_point(self):
        replay = sc2reader.load_replay("test_replays/2.0.11.26825/DaedalusPoint.SC2Replay")


class TestGameEngine(unittest.TestCase):
    class TestEvent(object):
        name='TestEvent'
        def __init__(self, value):
            self.value = value
        def __str__(self):
            return self.value

    class TestPlugin1(object):
        name = 'TestPlugin1'

        def handleInitGame(self, event, replay):
            yield TestGameEngine.TestEvent('b')
            yield TestGameEngine.TestEvent('c')

        def handleTestEvent(self, event, replay):
            print("morestuff")
            if event.value == 'd':
                yield sc2reader.engine.PluginExit(self, code=1, details=dict(msg="Fail!"))
            else:
                yield TestGameEngine.TestEvent('d')

        def handleEndGame(self, event, replay):
            yield TestGameEngine.TestEvent('g')

    class TestPlugin2(object):
        name = 'TestPlugin2'
        def handleInitGame(self, event, replay):
            replay.engine_events = list()

        def handleTestEvent(self, event, replay):
            replay.engine_events.append(event)

        def handlePluginExit(self, event, replay):
            yield TestGameEngine.TestEvent('e')

        def handleEndGame(self, event, replay):
            yield TestGameEngine.TestEvent('f')

    class MockReplay(object):
        def __init__(self, events):
            self.events = events

    def test_plugin1(self):
        engine = sc2reader.engine.GameEngine()
        engine.register_plugin(self.TestPlugin1())
        engine.register_plugin(self.TestPlugin2())
        replay = self.MockReplay([self.TestEvent('a')])
        engine.run(replay)
        self.assertEqual(''.join(str(e) for e in replay.engine_events), 'bdecaf')
        self.assertEqual(replay.plugin_failures, ['TestPlugin1'])
        self.assertEqual(replay.plugin_result['TestPlugin1'], (1, dict(msg="Fail!")))
        self.assertEqual(replay.plugin_result['TestPlugin2'], (0, dict()))



if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_all
# -*- coding: UTF-8 -*-

# Newer unittest features aren't built in for python 2.6
import sys
if sys.version_info[:2] < (2, 7):
    import unittest2 as unittest
else:
    import unittest

import sc2reader
sc2reader.log_utils.log_to_console("INFO")


class TestSummaries(unittest.TestCase):

    def test_a_WoL_s2gs(self):
        summary = sc2reader.load_game_summary("test_s2gs/s2gs1.s2gs")
        self.assertEqual(summary.players[0].resource_collection_rate, 1276)
        self.assertEqual(summary.players[0].build_order[0].order, 'Probe')
        self.assertEqual(summary.expansion, 'WoL')

    def test_a_HotS_s2gs(self):
        summary = sc2reader.load_game_summary("test_s2gs/hots1.s2gs")
        self.assertEqual(summary.players[0].resource_collection_rate, 1599)
        self.assertEqual(summary.players[0].build_order[0].order, 'SCV')
        self.assertEqual(summary.expansion, 'HotS')

    def test_another_HotS_s2gs(self):
        summary = sc2reader.load_game_summary("test_s2gs/hots2.s2gs")
        self.assertEqual(summary.players[0].enemies_destroyed, 14575)
        self.assertEqual(summary.players[0].time_supply_capped, 50)
        self.assertEqual(summary.players[0].idle_production_time, 4438)
        self.assertEqual(summary.players[0].resources_spent, 25450)
        self.assertEqual(summary.players[0].apm, 204)
        self.assertEqual(summary.players[0].workers_active_graph.as_points()[8][1], 25)
        self.assertEqual(summary.players[0].upgrade_spending_graph.as_points()[8][1], 300)
        self.assertEqual(summary.expansion, 'HotS')

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
