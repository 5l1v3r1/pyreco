__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Guake Terminal documentation build configuration file, created by
# sphinx-quickstart on Fri Nov 15 15:48:46 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import os
import sys

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Guake Terminal'
copyright = u'2013, Gaetan Semet'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.5'
# The full version, including alpha/beta/rc tags.
release = '0.5.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
on_rtd = os.environ.get('READTHEDOCS', None) == 'True'
if on_rtd:
    html_theme = 'default'
else:
    html_theme = 'nature'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'guakeonlinedoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'guakeonlinehelp.tex', u'Guake Terminal Documentation',
   u'Gaetan Semet', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'guakeonlinehelp', u'Guake Terminal Documentation',
     [u'Gaetan Semet'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'guakeonlinehelp', u'Guake Terminal Documentation',
   u'Gaetan Semet', 'guakeonlinehelp', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = fiximports
#!/usr/bin/env python
'''Check and sort import statement from a python file '''

import re
import sys


class FixImports(object):

    '''
    I can be used to check and sort import statement of a python file
    Please use sortImportGroups() method
    '''

    _regexImport = re.compile(r"^import\s+(.*)")
    _regexFromImport = re.compile(r"^from\s+([a-zA-Z0-9\._]+)\s+import\s+(.*)$")
    _regexFromFutureImport = re.compile(r"^from\s+__future__\s+import\s+(.*)$")

    def printErrorMsg(self, filename, lineNb, errorMessage):
        ''' I print the error message following pylint convention'''
        print ("%(filename)s:%(line_nb)s: %(error_msg)s" %
               dict(filename=filename,
                    line_nb=lineNb,
                    error_msg=errorMessage))

    def isImportLine(self, line):
        '''I return True is the given line is an import statement, False otherwize'''
        return self._regexImport.match(line) or self._regexFromImport.match(line)

    def isBadLineFixable(self, line):
        '''I return True is the given line is an import line than I know how to split'''
        if self.isImportLine(line) and '(' not in line:
            return True
        return False

    def analyzeLine(self, filename, line, lineNb):
        '''I look at the line and print all error I find'''
        res = True
        if self.isImportLine(line):
            if ',' in line:
                self.printErrorMsg(filename, lineNb,
                                   "multiple modules imported on one line - will fix")
                res = False
            if '\\' in line:
                self.printErrorMsg(filename, lineNb,
                                   "line-continuation character found - will fix.")
                res = False
            # these two don't occur in the Buildbot codebase, so we don't try to
            # fix them
            if ';' in line:
                self.printErrorMsg(filename, lineNb,
                                   "multiple import statement on one line. "
                                   "Put each import on its own line.")
                res = False
            if '(' in line:
                self.printErrorMsg(filename, lineNb,
                                   "parenthesis character found. "
                                   "Please import each module on a single line")
                res = False
        return res

    def importOrder(self, line):
        '''
        I define how import lines should be sorted
        return a tuple of order criterias sorted be importance
        '''
        ret = ("__future__" not in line,  # always put __future__ import first
               self._regexFromImport.match(line) is not None,  # import before from import
               line,  # then lexicographic order
               )
        return ret

    def sortImportGroups(self, filename, data=None):
        '''
        I perform the analysis of the given file, print the error I find and try to split and
        sort the import statement
        '''
        lines = data.split("\n")
        res = True
        for cur_line_nb, line in enumerate(lines):
            if not self.analyzeLine(filename, line, cur_line_nb):
                if not self.isBadLineFixable(line):
                    res = False
        if not res:
            return False, data

        # First split the import we can split
        newlines = []
        self.groups = []
        self.group_start = None

        def maybeEndGroup():
            if self.group_start is not None:
                self.groups.append((self.group_start, len(newlines)))
                self.group_start = None

        iter = lines.__iter__()
        while True:
            try:
                line = iter.next()
            except StopIteration:
                break
            if self.isImportLine(line):
                # join any continuation lines (\\)
                while line[-1] == '\\':
                    line = line[:-1] + iter.next()
                if self.group_start is None:
                    self.group_start = len(newlines)

                if self.isBadLineFixable(line):
                    match = self._regexFromImport.match(line)
                    if match:
                        module = match.group(1)
                        imports = [s.strip() for s in match.group(2).split(",")]
                        for imp in imports:
                            newlines.append("from %s import %s" % (module, imp))
                        continue
            else:
                maybeEndGroup()
            newlines.append(line)

        maybeEndGroup()

        lines = newlines
        for start, end in self.groups:
            lines[start:end] = sorted(lines[start:end], key=self.importOrder)

        # reiterate line by line to split mixed groups
        splitted_groups_lines = []
        prev_import_line_type = ""
        for line in lines:
            if not line.strip() or not self.isImportLine(line):
                splitted_groups_lines.append(line)
                prev_import_line_type = ""
            else:
                import_match = self._regexImport.match(line)
                from_match = self._regexFromImport.match(line)
                current_line_type = None
                if import_match is not None:
                    module = import_match
                    current_line_type = "import"
                elif from_match is not None:
                    module = from_match
                    current_line_type = "from"
                assert(current_line_type)
                if prev_import_line_type and current_line_type != prev_import_line_type:
                    splitted_groups_lines.append("")
                prev_import_line_type = current_line_type
                splitted_groups_lines.append(line)

        return True, "\n".join(splitted_groups_lines)


def main():
    '''I am the main method'''
    if len(sys.argv) != 2:
        print "usage: %s <python file>" % (sys.argv[0])
        sys.exit(1)

    filename = sys.argv[1]

    with open(filename, 'r') as filedesc:
        data = filedesc.read()
    res, content = FixImports().sortImportGroups(filename, data)
    if not res:
        sys.exit(1)

    with open(filename, 'w') as filedesc:
        filedesc.write(content)
    if data != content:
        print "import successfully reordered for file: %s" % (filename)
    sys.exit(0)

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = common
# -*- coding: utf-8; -*-
"""
Copyright (C) 2007-2013 Guake authors

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License as
published by the Free Software Foundation; either version 2 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public
License along with this program; if not, write to the
Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301 USA
"""
from __future__ import absolute_import

import gtk
import gconf
import sys
import os
import locale
import gettext
import time
import subprocess
import re
import guake.globals

# Internationalization purposes.
_ = gettext.gettext

__all__ = ['_', 'ShowableError', 'test_gconf',
           'pixmapfile', 'gladefile', 'hexify_color',
           'get_binaries_from_path']

class ShowableError(Exception):
    def __init__(self, title, msg, exit_code=1):
        d = gtk.MessageDialog(type=gtk.MESSAGE_ERROR,
                buttons=gtk.BUTTONS_CLOSE)
        d.set_markup('<b><big>%s</big></b>' % title)
        d.format_secondary_markup(msg)
        d.run()
        d.destroy()
        if exit_code != -1:
            sys.exit(exit_code)

def test_gconf():
    c = gconf.client_get_default()
    return c.dir_exists('/apps/guake')

def pixmapfile(x):
    f = os.path.join(guake.globals.IMAGE_DIR, x)
    if not os.path.exists(f):
        raise IOError('No such file or directory: %s' % f)
    return os.path.abspath(f)

def gladefile(x):
    f = os.path.join(guake.globals.GLADE_DIR, x)
    if not os.path.exists(f):
        raise IOError('No such file or directory: %s' % f)
    return os.path.abspath(f)

def hexify_color(c):
    h = lambda x: hex(x).replace('0x', '').zfill(4)
    return '#%s%s%s' % (h(c.red), h(c.green), h(c.blue))

def get_binaries_from_path(compiled_re):
    ret = []
    for i in os.environ.get('PATH', '').split(os.pathsep):
        if os.path.isdir(i):
            for j in os.listdir(i):
                if compiled_re.match(j):
                    ret.append(os.path.join(i, j))
    return ret

def shell_quote(text):
    """ quote text (filename) for inserting into a shell """
    return r"\'".join("'%s'" % p for p in text.split("'"))

def clamp(value, lower, upper):
    return max(min(value, upper), lower)

########NEW FILE########
__FILENAME__ = dbusiface
# -*- coding: utf-8; -*-
"""
Copyright (C) 2007-2013 Guake authors

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License as
published by the Free Software Foundation; either version 2 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public
License along with this program; if not, write to the
Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301 USA
"""
import dbus
import dbus.service
import dbus.glib
import gtk
import guake.common
dbus.glib.threads_init()

DBUS_PATH = '/org/guake/RemoteControl'
DBUS_NAME = 'org.guake.RemoteControl'

class DbusManager(dbus.service.Object):
    def __init__(self, guakeinstance):
        self.guake = guakeinstance
        self.bus = dbus.SessionBus()
        bus_name = dbus.service.BusName(DBUS_NAME, bus=self.bus)
        super(DbusManager, self).__init__(bus_name, DBUS_PATH)

    @dbus.service.method(DBUS_NAME)
    def show_hide(self):
        self.guake.show_hide()

    @dbus.service.method(DBUS_NAME)
    def show(self):
        self.guake.show()
        self.guake.set_terminal_focus()

    @dbus.service.method(DBUS_NAME)
    def hide(self):
        self.guake.hide()

    @dbus.service.method(DBUS_NAME, in_signature='s')
    def add_tab(self, directory=''):
        self.guake.add_tab(directory)

    @dbus.service.method(DBUS_NAME, in_signature='i')
    def select_tab(self, tab_index=0):
        self.guake.select_tab(int(tab_index))

    @dbus.service.method(DBUS_NAME, out_signature='i')
    def get_selected_tab(self):
        return self.guake.get_selected_tab()

    @dbus.service.method(DBUS_NAME, out_signature='i')
    def get_tab_count(self):
        return len(self.guake.term_list)

    @dbus.service.method(DBUS_NAME, in_signature='s')
    def set_bgcolor(self, bgcolor):
        self.guake.set_bgcolor(bgcolor)

    @dbus.service.method(DBUS_NAME, in_signature='s')
    def set_fgcolor(self, fgcolor):
        self.guake.set_fgcolor(fgcolor)

    @dbus.service.method(DBUS_NAME, in_signature='s')
    def execute_command(self, command):
        self.guake.execute_command(command)

    @dbus.service.method(DBUS_NAME, in_signature='i', out_signature='s')
    def get_tab_name(self, tab_index=0):
        return self.guake.term_list[int(tab_index)].get_window_title() or ''

    @dbus.service.method(DBUS_NAME, in_signature='is')
    def rename_tab(self, tab_index, new_text):
        self.guake.rename_tab(tab_index, new_text)

    @dbus.service.method(DBUS_NAME, in_signature='s')
    def rename_current_tab(self, new_text):
        self.guake.rename_current_tab(new_text)

    @dbus.service.method(DBUS_NAME)
    def show_about(self):
        self.guake.show_about()

    @dbus.service.method(DBUS_NAME)
    def show_prefs(self):
        self.guake.show_prefs()

    @dbus.service.method(DBUS_NAME)
    def quit(self):
        self.guake.quit()

########NEW FILE########
__FILENAME__ = example
"""
Copyright (C) 2007 Lincoln de Sousa <lincoln@archlinux-br.org>

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License as
published by the Free Software Foundation; either version 2 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public
License along with this program; if not, write to the
Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301 USA
"""

"""
Globahotkeys test file
======================

Intro
~~~~~
This is a really simple test of globalhotkeys module.

To use this you must compile globalhotkeys module, and run this file with
python. Please only remember to copy your globalhotkeys.so file to a path
contained in sys.path (maybe you can use PYTHONPATH).

The module contains only 3 functions, init/bind/unbind and they are very simple
to use.

What you can not forget?
~~~~~~~~~~~~~~~~~~~~~~~~
 - Compile your module with debug flag, it will help you find a possible
   problem.

 - Run every test from a terminal, all messages will be displayed there.

 - Globalhotkeys module depends on gtk, so if you don't import gtk before call
   any funcion in that module, you will see some warnings on your terminal =D

 - globalhotkeys.init MUST be called before binding/unbinding keys.


What shoud happen here?
~~~~~~~~~~~~~~~~~~~~~~~
This script is a simple test that initializes globalhotkeys machinery and
bindings a key to a simple function. So after running this program, you shoud
se a message 'great =D' or 'bad =('. If every thing goes right, when you press
the F12 key, you should see ('F12',) on your terminal otherwise, you will see a
warning saying that binding has failed.

A really important thing is that globalhotkeys.bind returns boolean values, so
if you want to know if binding works properly, only test this with a simple if.

A cool test
~~~~~~~~~~~
if you want to test your program when it shoud say to the user that the binding
failed, you can simply use this program to bind the key that you're running.
Because you can bind a key once.
"""
import gtk
import globalhotkeys

def hammer(*args):
    print args

globalhotkeys.init()
binded = globalhotkeys.bind('F12', hammer)
if binded:
    print 'great =D'
else:
    print 'bad =('

gtk.main()

########NEW FILE########
__FILENAME__ = gtk-theme-swatch
#!/usr/bin/env python
# gtk-theme-swatch: A PyGtk widget that displays the color swatches of all
# gtk.Styles, in all states. Useful for designing themes
# author: John Stowers <john.stowers@gmail.com>

import gtk
import pygtk

pygtk.require('2.0')

class ThemeSwatch(gtk.DrawingArea):

    SWATCH_SIZE = 50        #swatch size
    SWATCH_GAP = 5          #gap
    SWATCH_LABEL_SIZE = 10  #text size

    STYLES = (
        "fg",
        "bg",
        "light",
        "dark",
        "mid",
        "text",
        "base",
        "text_aa"
        )
    STYLE_STATES = {
        gtk.STATE_NORMAL:"normal",
        gtk.STATE_ACTIVE:"active",
        gtk.STATE_PRELIGHT:"prelight",
        gtk.STATE_SELECTED:"selected",
        gtk.STATE_INSENSITIVE:"insensitive"
        }

    def __init__(self):
        gtk.DrawingArea.__init__(self)
        self.connect("expose_event", self.expose)

    @classmethod
    def get_min_size(cls):
        w = (1+len(cls.STYLE_STATES))*(cls.SWATCH_SIZE + cls.SWATCH_GAP)
        h = (1+len(cls.STYLES))*(cls.SWATCH_SIZE + cls.SWATCH_GAP)
        return w,h

    def color_to_cairo_rgba(self, c, a=1):
      return c.red/65535.0, c.green/65535.0, c.blue/65535.0, a

    def draw_rect(self, x, y, w, h, color):
        cr = self.context
        cr.rectangle(x, y, w, h)
        cr.set_source_rgba(
                    *self.color_to_cairo_rgba(color)
                    )
        cr.fill()

    def draw_round_rect(self, x, y, w, h, color, r=15):
        cr = self.context
        cr.set_source_rgba(
                    *self.color_to_cairo_rgba(color)
                    )

        cr.move_to(x+r,y)
        cr.line_to(x+w-r,y);   cr.curve_to(x+w,y,x+w,y,x+w,y+r)
        cr.line_to(x+w,y+h-r); cr.curve_to(x+w,y+h,x+w,y+h,x+w-r,y+h)
        cr.line_to(x+r,y+h);   cr.curve_to(x,y+h,x,y+h,x,y+h-r)
        cr.line_to(x,y+r);     cr.curve_to(x,y,x,y,x+r,y)
        cr.close_path()

        cr.fill()

    def expose(self, widget, event):
        self.context = widget.window.cairo_create()

        # set a clip region for the expose event
        self.context.rectangle(event.area.x, event.area.y,
                               event.area.width, event.area.height)
        self.context.clip()

        self.draw()

        return False

    def draw(self):
        cr = self.context
        rect = self.get_allocation()

        s = self.SWATCH_SIZE        #swatch size
        g = self.SWATCH_GAP         #gap
        t = self.SWATCH_LABEL_SIZE  #text size

        x = rect.x+g
        y = rect.y

        #draw style state labels, x axis
        #cr.rotate(-30)
        cr.set_font_size(t)
        for state,name in self.STYLE_STATES.items():
            cr.set_source_rgb(0, 0, 0)
            cr.move_to(x+0.5, y+s/2+t/2)
            cr.show_text(name)
            x += g+s
        #cr.rotate(30)

        y += s
        x = rect.x+g
        for name in self.STYLES:
            colors = getattr(self.style, name, None)
            if colors:
                for state in self.STYLE_STATES:
                    color = colors[state]

                    #self.draw_rect(x, y, s, s, color)
                    self.draw_round_rect(x, y, s, s, color)
                    print "[%7s,%11s]" % (name, self.STYLE_STATES[state]) ,

                    x += g+s

            #draw style labels, y axis
            cr.set_source_rgb(0, 0, 0)
            cr.move_to(x+g, y+s/2+t/2)
            cr.show_text(name)

            x = rect.x+g
            y += g+s
            print ""

def main():
    window = gtk.Window()
    theme = ThemeSwatch()

    window.set_size_request(
                *theme.get_min_size()
                )
    window.add(theme)

    window.connect("destroy", gtk.main_quit)
    window.show_all()

    gtk.main()

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = notifier
#!/usr/bin/env python
"""
Copyright (C) 2013 Maxim Ivanov <ulidtko@gmail.com>

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License as
published by the Free Software Foundation; either version 2 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public
License along with this program; if not, write to the
Free Software Foundation, Inc., 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.
"""

import glib
import pynotify

pynotify.init("Guake")

__all__ = ['show_message']

RETRY_INTERVAL = 3 # seconds

retry_limit = 5 # tries


def show_message(brief, body=None, icon=None):
    try:
        notification = pynotify.Notification(brief, body, icon)
        notification.show()
    except glib.GError:
        print_warning()
        glib.timeout_add_seconds(RETRY_INTERVAL, lambda: retry(brief, body, icon))


def retry(*args):
    global retry_limit

    if retry_limit <= 0:
        return False

    retry_limit -= 1
    show_message(*args)


def print_warning():
    if not hasattr(print_warning, 'already_printed'):
        print """
Notification service is not running (yet). Guake can't display notifications!
  We'll retry a few times more a bit later, but you can use
  the following command to disable the startup notification:
$ gconftool-2 --type bool --set /apps/guake/general/use_popup false
        """.strip()
        print_warning.already_printed = True

########NEW FILE########
__FILENAME__ = prefs
#!/usr/bin/env python
# -*- coding: utf-8; -*-
#
# Copyright (C) 2007-2013 Guake authors
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 2 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public
# License along with this program; if not, write to the
# Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
# Boston, MA 02110-1301 USA
from __future__ import absolute_import

import os
import re
import warnings

import gconf
import gobject
import gtk

from guake.common import ShowableError
from guake.common import _
from guake.common import get_binaries_from_path
from guake.common import gladefile
from guake.common import hexify_color
from guake.common import pixmapfile
from guake.globals import GCONF_PATH
from guake.globals import KEY
from guake.globals import LOCALE_DIR
from guake.globals import NAME
from guake.globals import QUICK_OPEN_MATCHERS
from guake.simplegladeapp import SimpleGladeApp
from guake.simplegladeapp import bindtextdomain

# A regular expression to match possible python interpreters when
# filling interpreters combo in preferences (including bpython and ipython)
PYTHONS = re.compile(r'^[a-z]python$|^python\d\.\d$')

# Path to the shells file, it will be used to start to populate
# interpreters combo, see the next variable, its important to fill the
# rest of the combo too.
SHELLS_FILE = '/etc/shells'

# string to show in prefereces dialog for user shell option
USER_SHELL_VALUE = _('<user shell>')

# translating our types to vte types
ERASE_BINDINGS = {'ASCII DEL': 'ascii-delete',
                  'Escape sequence': 'delete-sequence',
                  'Control-H': 'ascii-backspace'}

# Stuff used to build the treeview that will allow the user to change
# keybindings in the preferences window.
LKEY = lambda x: GCONF_PATH + '/keybindings/local/' + x
GKEY = lambda x: GCONF_PATH + '/keybindings/global/' + x

HOTKEYS = [
    {'label': 'General',
     'keys': [{'key': GKEY('show_hide'),
               'label': 'Toggle Guake visibility'},
              {'key': LKEY('toggle_fullscreen'),
               'label': 'Toggle Fullscreen'},
              {'key': LKEY('quit'),
               'label': 'Quit'},
              ]},

    {'label': 'Tab management',
     'keys': [{'key': LKEY('new_tab'),
               'label': 'New tab'},
              {'key': LKEY('close_tab'),
               'label': 'Close tab'},
              {'key': LKEY('rename_current_tab'),
               'label': 'Rename current tab'},
              ]},

    {'label': 'Navigation',
     'keys': [{'key': LKEY('previous_tab'),
               'label': 'Go to previous tab'},
              {'key': LKEY('next_tab'),
               'label': 'Go to next tab'},
              {'key': LKEY('switch_tab1'),
               'label': 'Go to first tab'},
              {'key': LKEY('switch_tab2'),
               'label': 'Go to second tab'},
              {'key': LKEY('switch_tab3'),
               'label': 'Go to third tab'},
              {'key': LKEY('switch_tab4'),
               'label': 'Go to fourth tab'},
              {'key': LKEY('switch_tab5'),
               'label': 'Go to fifth tab'},
              {'key': LKEY('switch_tab6'),
               'label': 'Go to sixth tab'},
              {'key': LKEY('switch_tab7'),
               'label': 'Go to seventh tab'},
              {'key': LKEY('switch_tab8'),
               'label': 'Go to eighth tab'},
              {'key': LKEY('switch_tab9'),
               'label': 'Go to ninth tab'},
              {'key': LKEY('switch_tab10'),
               'label': 'Go to tenth tab'},
              ]},

    {'label': 'Appearance',
     'keys': [{'key': LKEY('zoom_out'),
               'label': 'Zoom out'},
              {'key': LKEY('zoom_in'),
               'label': 'Zoom in'},
              {'key': LKEY('zoom_in_alt'),
               'label': 'Zoom in (alternative)'},
              ]},

    {'label': 'Clipboard',
     'keys': [{'key': LKEY('clipboard_copy'),
               'label': 'Copy text to clipboard'},
              {'key': LKEY('clipboard_paste'),
               'label': 'Paste text from clipboard'},
              ]},

    {'label': 'Extra features',
     'keys': [
              {'key': LKEY('search_on_web'),
               'label': 'Search select text on web'},
     ]},
]

PALETTES = [
    # tango
    '#000000000000:#cccc00000000:#4e4e9a9a0606:#c4c4a0a00000:#34346565a4a4:'
    '#757550507b7b:#060698209a9a:#d3d3d7d7cfcf:#555557575353:#efef29292929:'
    '#8a8ae2e23434:#fcfce9e94f4f:#72729f9fcfcf:#adad7f7fa8a8:#3434e2e2e2e2:'
    '#eeeeeeeeecec',

    # linux console
    '#000000000000:#aaaa00000000:#0000aaaa0000:#aaaa55550000:#00000000aaaa:'
    '#aaaa0000aaaa:#0000aaaaaaaa:#aaaaaaaaaaaa:#555555555555:#ffff55555555:'
    '#5555ffff5555:#ffffffff5555:#55555555ffff:#ffff5555ffff:#5555ffffffff:'
    '#ffffffffffff',

    # xterm
    '#000000000000:#cdcb00000000:#0000cdcb0000:#cdcbcdcb0000:#1e1a908fffff:'
    '#cdcb0000cdcb:#0000cdcbcdcb:#e5e2e5e2e5e2:#4ccc4ccc4ccc:#ffff00000000:'
    '#0000ffff0000:#ffffffff0000:#46458281b4ae:#ffff0000ffff:#0000ffffffff:'
    '#ffffffffffff',

    # rxvt
    '#000000000000:#cdcd00000000:#0000cdcd0000:#cdcdcdcd0000:#00000000cdcd:'
    '#cdcd0000cdcd:#0000cdcdcdcd:#fafaebebd7d7:#404040404040:#ffff00000000:'
    '#0000ffff0000:#ffffffff0000:#00000000ffff:#ffff0000ffff:#0000ffffffff:'
    '#ffffffffffff'
]


class PrefsCallbacks(object):
    """Holds callbacks that will be used in the PrefsDialg class.
    """

    def __init__(self):
        self.client = gconf.client_get_default()

    # general tab

    def on_default_shell_changed(self, combo):
        """Changes the activity of default_shell in gconf
        """
        citer = combo.get_active_iter()
        if not citer:
            return
        shell = combo.get_model().get_value(citer, 0)
        # we unset the value (restore to default) when user chooses to use
        # user shell as guake shell interpreter.
        if shell == USER_SHELL_VALUE:
            self.client.unset(KEY('/general/default_shell'))
        else:
            self.client.set_string(KEY('/general/default_shell'), shell)

    def on_use_login_shell_toggled(self, chk):
        """Changes the activity of use_login_shell in gconf
        """
        self.client.set_bool(KEY('/general/use_login_shell'), chk.get_active())

    def on_open_tab_cwd_toggled(self, chk):
        """Changes the activity of open_tab_cwd in gconf
        """
        self.client.set_bool(KEY('/general/open_tab_cwd'), chk.get_active())

    def on_use_trayicon_toggled(self, chk):
        """Changes the activity of use_trayicon in gconf
        """
        self.client.set_bool(KEY('/general/use_trayicon'), chk.get_active())

    def on_use_popup_toggled(self, chk):
        """Changes the activity of use_popup in gconf
        """
        self.client.set_bool(KEY('/general/use_popup'), chk.get_active())

    def on_prompt_on_quit_toggled(self, chk):
        """Set the `prompt on quit' property in gconf
        """
        self.client.set_bool(KEY('/general/prompt_on_quit'), chk.get_active())

    def on_window_ontop_toggled(self, chk):
        """Changes the activity of window_ontop in gconf
        """
        self.client.set_bool(KEY('/general/window_ontop'), chk.get_active())

    def on_quick_open_enable_toggled(self, chk):
        """Changes the activity of window_ontop in gconf
        """
        self.client.set_bool(KEY('/general/quick_open_enable'), chk.get_active())

    def on_window_losefocus_toggled(self, chk):
        """Changes the activity of window_losefocus in gconf
        """
        self.client.set_bool(KEY('/general/window_losefocus'), chk.get_active())

    def on_window_losefocus_toggled(self, chk):
        """Changes the activity of window_losefocus in gconf
        """
        self.client.set_bool(KEY('/general/window_losefocus'), chk.get_active())

    def on_quick_open_command_line_changed(self, edt):
        self.client.set_string(KEY('/general/quick_open_command_line'), edt.get_text())

    def on_window_tabbar_toggled(self, chk):
        """Changes the activity of window_tabbar in gconf
        """
        self.client.set_bool(KEY('/general/window_tabbar'), chk.get_active())

    def on_start_fullscreen_toggled(self, chk):
        """Changes the activity of start_fullscreen in gconf
        """
        self.client.set_bool(KEY('/general/start_fullscreen'), chk.get_active())

    def on_primary_display_toggled(self, chk):
        """Set the 'appear on primary display' preference in gconf. This
        property supercedes any value stored in display_n.
        """
        self.client.set_bool(KEY('/general/primary_display'), chk.get_active())

    def on_mouse_display_toggled(self, chk):
        """Set the 'appear on mouse display' preference in gconf. This
        property supercedes any value stored in display_n.
        """
        self.client.set_bool(KEY('/general/mouse_display'), chk.get_active())

    def on_display_n_changed(self, combo):
        """Set the destination display in gconf. This is superceded by a 'true'
        value in primary_display or mouse_display.
        """
        i = combo.get_active_iter()
        if not i:
            return
        val = combo.get_model().get_value(i, 0)
        val_int = int(val.split()[0])  # extracts 1 from '1' or from '1 (primary)'
        self.client.set_int(KEY('/general/display_n'), val_int)

    def on_window_height_value_changed(self, hscale):
        """Changes the value of window_height in gconf
        """
        val = hscale.get_value()
        self.client.set_int(KEY('/general/window_height'), int(val))

    # scrolling tab

    def on_use_scrollbar_toggled(self, chk):
        """Changes the activity of use_scrollbar in gconf
        """
        self.client.set_bool(KEY('/general/use_scrollbar'), chk.get_active())

    def on_history_size_value_changed(self, spin):
        """Changes the value of history_size in gconf
        """
        val = int(spin.get_value())
        self.client.set_int(KEY('/general/history_size'), val)

    def on_scroll_output_toggled(self, chk):
        """Changes the activity of scroll_output in gconf
        """
        self.client.set_bool(KEY('/general/scroll_output'), chk.get_active())

    def on_scroll_keystroke_toggled(self, chk):
        """Changes the activity of scroll_keystroke in gconf
        """
        self.client.set_bool(KEY('/general/scroll_keystroke'), chk.get_active())

    # appearance tab

    def on_use_default_font_toggled(self, chk):
        """Changes the activity of use_default_font in gconf
        """
        self.client.set_bool(KEY('/general/use_default_font'), chk.get_active())

    def on_font_style_font_set(self, fbtn):
        """Changes the value of font_style in gconf
        """
        self.client.set_string(KEY('/style/font/style'), fbtn.get_font_name())

    def on_font_color_color_set(self, btn):
        """Changes the value of font_color in gconf
        """
        color = hexify_color(btn.get_color())
        self.client.set_string(KEY('/style/font/color'), color)

    def on_background_color_color_set(self, btn):
        """Changes the value of background_color in gconf
        """
        color = hexify_color(btn.get_color())
        self.client.set_string(KEY('/style/background/color'), color)

    def on_background_image_changed(self, btn):
        """Changes the value of background_image in gconf
        """
        filename = btn.get_filename()
        if os.path.isfile(filename or ''):
            self.client.set_string(KEY('/style/background/image'), filename)

    def on_transparency_value_changed(self, hscale):
        """Changes the value of background_transparency in gconf
        """
        value = hscale.get_value()
        self.client.set_int(KEY('/style/background/transparency'), int(value))

    # compatibility tab

    def on_backspace_binding_changed(self, combo):
        """Changes the value of compat_backspace in gconf
        """
        val = combo.get_active_text()
        self.client.set_string(KEY('/general/compat_backspace'),
                               ERASE_BINDINGS[val])

    def on_delete_binding_changed(self, combo):
        """Changes the value of compat_delete in gconf
        """
        val = combo.get_active_text()
        self.client.set_string(KEY('/general/compat_delete'),
                               ERASE_BINDINGS[val])


class PrefsDialog(SimpleGladeApp):
    """The Guake Preferences dialog.
    """
    def __init__(self):
        """Setup the preferences dialog interface, loading images,
        adding filters to file choosers and connecting some signals.
        """
        super(PrefsDialog, self).__init__(gladefile('prefs.glade'),
                                          root='config-window')
        self.add_callbacks(PrefsCallbacks())

        self.client = gconf.client_get_default()

        # setting evtbox title bg
        eventbox = self.get_widget('eventbox-title')
        eventbox.modify_bg(gtk.STATE_NORMAL,
                           eventbox.get_colormap().alloc_color("#ffffff"))

        # images
        ipath = pixmapfile('guake-notification.png')
        self.get_widget('image_logo').set_from_file(ipath)
        ipath = pixmapfile('quick-open.png')
        self.get_widget('image_quick_open').set_from_file(ipath)

        # the first position in tree will store the keybinding path in gconf,
        # and the user doesn't worry with this, let's hide that =D
        model = gtk.TreeStore(str, str, object, bool)
        treeview = self.get_widget('treeview-keys')
        treeview.set_model(model)
        treeview.set_rules_hint(True)
        treeview.connect('button-press-event', self.start_editing)

        renderer = gtk.CellRendererText()
        column = gtk.TreeViewColumn('keypath', renderer, text=0)
        column.set_visible(False)
        treeview.append_column(column)

        renderer = gtk.CellRendererText()
        column = gtk.TreeViewColumn(_('Action'), renderer, text=1)
        column.set_property('expand', True)
        treeview.append_column(column)

        renderer = gtk.CellRendererAccel()
        renderer.set_property('editable', True)

        renderer.connect('accel-edited', self.on_key_edited, model)
        renderer.connect('accel-cleared', self.on_key_cleared, model)

        column = gtk.TreeViewColumn(_('Shortcut'), renderer)
        column.set_cell_data_func(renderer, self.cell_data_func)
        column.set_property('expand', False)
        treeview.append_column(column)

        self.populate_shell_combo()
        self.populate_keys_tree()
        self.populate_display_n()
        self.load_configs()
        self.get_widget('config-window').hide()

        # Preview when selecting a bgimage
        self.selection_preview = gtk.Image()
        self.file_filter = gtk.FileFilter()
        self.file_filter.add_pattern("*.jpg")
        self.file_filter.add_pattern("*.png")
        self.file_filter.add_pattern("*.svg")
        self.file_filter.add_pattern("*.jpeg")
        self.bgfilechooser = self.get_widget('background_image')
        self.bgfilechooser.set_preview_widget(self.selection_preview)
        self.bgfilechooser.set_filter(self.file_filter)
        self.bgfilechooser.connect('update-preview', self.update_preview,
                                   self.selection_preview)

    def show(self):
        """Calls the main window show_all method and presents the
        window in the desktop.
        """
        self.get_widget('config-window').show_all()
        self.get_widget('config-window').present()

    def hide(self):
        """Calls the main window hide function.
        """
        self.get_widget('config-window').hide()

    def update_preview(self, file_chooser, preview):
        """Used by filechooser to preview image files
        """
        filename = file_chooser.get_preview_filename()
        if filename and os.path.isfile(filename or ''):
            try:
                mkpb = gtk.gdk.pixbuf_new_from_file_at_size
                pixbuf = mkpb(filename, 256, 256)
                preview.set_from_pixbuf(pixbuf)
                file_chooser.set_preview_widget_active(True)
            except gobject.GError:
                # this exception is raised when user chooses a
                # non-image file or a directory
                warnings.warn('File %s is not an image' % filename)
        else:
            file_chooser.set_preview_widget_active(False)

    def toggle_style_sensitivity(self, chk):
        """If the user chooses to use the gnome default font
        configuration it means that he will not be able to use the
        font selector.
        """
        self.get_widget('font_style').set_sensitive(not chk.get_active())

    def toggle_display_n_sensitivity(self, chk):
        """When the user unchecks 'primary display', the option to select an
        alternate display should be enabeld.
        """
        other = self.get_widget('primary_display' if 'mouse_display' == chk.get_name()\
                           else 'mouse_display')

        if chk.get_active():
          other.set_active(False)

        self.get_widget('display_n').set_sensitive(not chk.get_active())

    def toggle_quick_open_command_line_sensitivity(self, chk):
        """When the user unchecks 'enable quick open', the command line should be disabled
        """
        self.get_widget('quick_open_command_line').set_sensitive(chk.get_active())

    def clear_background_image(self, btn):
        """Unset the gconf variable that holds the name of the
        background image of all terminals.
        """
        self.client.unset(KEY('/style/background/image'))
        self.bgfilechooser.unselect_all()

    def on_reset_compat_defaults_clicked(self, bnt):
        """Reset default values to compat_{backspace,delete} gconf
        keys. The default values are retrivied from the guake.schemas
        file.
        """
        self.client.unset(KEY('/general/compat_backspace'))
        self.client.unset(KEY('/general/compat_delete'))
        self.reload_erase_combos()

    def on_palette_name_changed(self, combo):
        """Changes the value of palette in gconf
        """
        palette_index = combo.get_active()
        if palette_index == 4:
            return
        self.client.set_string(KEY('/style/font/palette'),
                               PALETTES[palette_index])
        self.set_palette_colors(PALETTES[palette_index])

    def on_palette_color_set(self, btn):
        """Changes the value of palette in gconf
        """
        palette = []
        for i in range(16):
            palette.append(hexify_color(
                self.get_widget('palette_%d' % i).get_color()))
        palette = ':'.join(palette)
        self.client.set_string(KEY('/style/font/palette'), palette)
        self.set_palette_name(palette)

    def set_palette_name(self, palette):
        """If the given palette matches an existing one, shows it in the
        combobox
        """
        self.get_widget('palette_name').set_active(4)
        for i in range(len(PALETTES)):
            if palette == PALETTES[i]:
                self.get_widget('palette_name').set_active(i)

    def set_palette_colors(self, palette):
        """Updates the color buttons with the given palette
        """
        palette = palette.split(':')
        for i in range(16):
            color = gtk.gdk.color_parse(palette[i])
            self.get_widget('palette_%d' % i).set_color(color)

    def reload_erase_combos(self, btn=None):
        """Read from gconf the value of compat_{backspace,delete} vars
        and select the right option in combos.
        """
        # backspace erase binding
        combo = self.get_widget('backspace-binding-combobox')
        binding = self.client.get_string(KEY('/general/compat_backspace'))
        for i in combo.get_model():
            if ERASE_BINDINGS.get(i[0]) == binding:
                combo.set_active_iter(i.iter)

        # delete erase binding
        combo = self.get_widget('delete-binding-combobox')
        binding = self.client.get_string(KEY('/general/compat_delete'))
        for i in combo.get_model():
            if ERASE_BINDINGS.get(i[0]) == binding:
                combo.set_active_iter(i.iter)

    def load_configs(self):
        """Load configurations for all widgets in General, Scrolling
        and Appearance tabs from gconf.
        """
        # default_shell

        combo = self.get_widget('default_shell')
        # get the value for defualt shell. If unset, set to USER_SHELL_VALUE.
        value = self.client.get_string(KEY('/general/default_shell')) or \
            USER_SHELL_VALUE
        for i in combo.get_model():
            if i[0] == value:
                combo.set_active_iter(i.iter)

        # login shell
        value = self.client.get_bool(KEY('/general/use_login_shell'))
        self.get_widget('use_login_shell').set_active(value)

        # tray icon
        value = self.client.get_bool(KEY('/general/use_trayicon'))
        self.get_widget('use_trayicon').set_active(value)

        # popup
        value = self.client.get_bool(KEY('/general/use_popup'))
        self.get_widget('use_popup').set_active(value)

        # prompt on quit
        value = self.client.get_bool(KEY('/general/prompt_on_quit'))
        self.get_widget('prompt_on_quit').set_active(value)

        # ontop
        value = self.client.get_bool(KEY('/general/window_ontop'))
        self.get_widget('window_ontop').set_active(value)

        # losefocus
        value = self.client.get_bool(KEY('/general/window_losefocus'))
        self.get_widget('window_losefocus').set_active(value)

        # use VTE titles
        value = self.client.get_bool(KEY('/general/use_vte_titles'))
        self.get_widget('use_vte_titles').set_active(value)

        value = self.client.get_int(KEY('/general/window_height'))
        self.get_widget('window_height').set_value(value)

        value = self.client.get_bool(KEY('/general/open_tab_cwd'))
        self.get_widget('open_tab_cwd').set_active(value)

        # tab bar
        value = self.client.get_bool(KEY('/general/window_tabbar'))
        self.get_widget('window_tabbar').set_active(value)

        # start fullscreen
        value = self.client.get_bool(KEY('/general/start_fullscreen'))
        self.get_widget('start_fullscreen').set_active(value)

        # display number / use primary display
        combo = self.get_widget('display_n')
        dest_screen = self.client.get_int(KEY('/general/display_n'))

        value = self.client.get_bool(KEY('/general/quick_open_enable'))
        self.get_widget('quick_open_enable').set_active(value)
        self.get_widget('quick_open_command_line').set_sensitive(value)
        text = gtk.TextBuffer()
        text = self.get_widget('quick_open_supported_patterns').get_buffer()
        for title, matcher, _ in QUICK_OPEN_MATCHERS:
            text.insert_at_cursor("%s: %s\n" % (title, matcher))
        self.get_widget('quick_open_supported_patterns').set_buffer(text)

        value = self.client.get_string(KEY('/general/quick_open_command_line'))
        if value is None:
            value = "subl %(file_path)s:%(line_number)s"
        self.get_widget('quick_open_command_line').set_text(value)

        # If Guake is configured to use a screen that is not currently attached,
        # default to 'primary display' option.
        screen = self.get_widget('config-window').get_screen()
        n_screens = screen.get_n_monitors()
        if dest_screen > n_screens - 1:
            self.client.set_bool(KEY('/general/primary_display'), True)
            self.client.set_bool(KEY('/general/mouse_display'), False)
            dest_screen = screen.get_primary_monitor()
            self.client.set_int(KEY('/general/display_n'), dest_screen)

        for i in combo.get_model():
            i_int = int(i[0].split()[0])  # extracts 1 from '1' or from '1 (primary)'
            if i_int == dest_screen:
                combo.set_active_iter(i.iter)

        value = self.client.get_bool(KEY('/general/primary_display'))
        self.get_widget('primary_display').set_active(value)

        # use display where the mouse is currently
        value = self.client.get_bool(KEY('/general/mouse_display'))
        self.get_widget('mouse_display').set_active(value)

        # scrollbar
        value = self.client.get_bool(KEY('/general/use_scrollbar'))
        self.get_widget('use_scrollbar').set_active(value)

        # history size
        value = self.client.get_int(KEY('/general/history_size'))
        self.get_widget('history_size').set_value(value)

        # scroll output
        value = self.client.get_bool(KEY('/general/scroll_output'))
        self.get_widget('scroll_output').set_active(value)

        # scroll keystroke
        value = self.client.get_bool(KEY('/general/scroll_keystroke'))
        self.get_widget('scroll_keystroke').set_active(value)

        # default font
        value = self.client.get_bool(KEY('/general/use_default_font'))
        self.get_widget('use_default_font').set_active(value)
        self.get_widget('font_style').set_sensitive(not value)

        # font
        value = self.client.get_string(KEY('/style/font/style'))
        self.get_widget('font_style').set_font_name(value)

        # font color
        val = self.client.get_string(KEY('/style/font/color'))
        try:
            color = gtk.gdk.color_parse(val)
            self.get_widget('font_color').set_color(color)
        except (ValueError, TypeError):
            warnings.warn('Unable to parse color %s' % val, Warning)

        # background color
        value = self.client.get_string(KEY('/style/background/color'))
        try:
            color = gtk.gdk.color_parse(value)
            self.get_widget('background_color').set_color(color)
        except (ValueError, TypeError):
            warnings.warn('Unable to parse color %s' % val, Warning)

        # palette
        value = self.client.get_string(KEY('/style/font/palette'))
        self.set_palette_name(value)
        self.set_palette_colors(value)

        # background image
        value = self.client.get_string(KEY('/style/background/image'))
        if os.path.isfile(value or ''):
            self.get_widget('background_image').set_filename(value)

        value = self.client.get_int(KEY('/style/background/transparency'))
        self.get_widget('background_transparency').set_value(value)

        # it's a separated method, to be reused.
        self.reload_erase_combos()

    # -- populate functions --

    def populate_shell_combo(self):
        """Read the /etc/shells and looks for installed shells to
        fill the default_shell combobox.
        """
        cb = self.get_widget('default_shell')
        # append user shell as first option
        cb.append_text(USER_SHELL_VALUE)
        if os.path.exists(SHELLS_FILE):
            lines = open(SHELLS_FILE).readlines()
            for i in lines:
                possible = i.strip()
                if possible and not possible.startswith('#') and \
                   os.path.exists(possible):
                    cb.append_text(possible)

        for i in get_binaries_from_path(PYTHONS):
            cb.append_text(i)

    def populate_keys_tree(self):
        """Reads the HOTKEYS global variable and insert all data in
        the TreeStore used by the preferences window treeview.
        """
        model = self.get_widget('treeview-keys').get_model()
        for group in HOTKEYS:
            giter = model.append(None)
            model.set(giter, 0, '', 1, _(group['label']))
            for item in group['keys']:
                child = model.append(giter)
                accel = self.client.get_string(item['key'])
                if accel:
                    params = gtk.accelerator_parse(accel)
                    hotkey = KeyEntry(*params)
                else:
                    hotkey = KeyEntry(0, 0)
                model.set(child,
                          0, item['key'],
                          1, _(item['label']),
                          2, hotkey,
                          3, True)
        self.get_widget('treeview-keys').expand_all()

    def populate_display_n(self):
        """Get the number of displays and populate this drop-down box
        with them all.
        """
        cb = self.get_widget('display_n')
        screen = self.get_widget('config-window').get_screen()

        for m in range(0, int(screen.get_n_monitors())):
            if m == int(screen.get_primary_monitor()):
                # TODO l10n
                cb.append_text(str(m) + ' ' + '(primary)')
            else:
                cb.append_text(str(m))

    # -- key handling --

    def on_key_edited(self, renderer, path, keycode, mask, keyval, model):
        """Callback that handles key edition in cellrenderer. It makes
        some tests to validate the key, like looking for already in
        use keys and look for [A-Z][a-z][0-9] to avoid problems with
        these common keys. If all tests are ok, the value will be
        stored in gconf.
        """
        giter = model.get_iter(path)
        gconf_path = model.get_value(giter, 0)

        oldkey = model.get_value(giter, 2)
        hotkey = KeyEntry(keycode, mask)
        key = gtk.accelerator_name(keycode, mask)
        keylabel = gtk.accelerator_get_label(keycode, mask)

        # we needn't to change anything, the user is trying to set the
        # same key that is already set.
        if oldkey == hotkey:
            return False

        # looking for already used keybindings
        def each_key(model, path, subiter):
            keyentry = model.get_value(subiter, 2)
            if keyentry and keyentry == hotkey:
                msg = _("The shortcut \"%s\" is already in use.") % keylabel
                raise ShowableError(_('Error setting keybinding.'), msg, -1)
        model.foreach(each_key)

        # avoiding problems with common keys
        if ((mask == 0 and keycode != 0) and (
            (keycode >= ord('a') and keycode <= ord('z')) or
            (keycode >= ord('A') and keycode <= ord('Z')) or
                (keycode >= ord('0') and keycode <= ord('9')))):
            dialog = gtk.MessageDialog(
                self.get_widget('config-window'),
                gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT,
                gtk.MESSAGE_WARNING, gtk.BUTTONS_OK,
                _("The shortcut \"%s\" cannot be used "
                  "because it will become impossible to "
                  "type using this key.\n\n"
                  "Please try with a key such as "
                  "Control, Alt or Shift at the same "
                  "time.\n") % key)
            dialog.run()
            dialog.destroy()
            return False

        # setting new value in ui
        giter = model.get_iter(path)
        model.set_value(giter, 2, hotkey)

        # setting the new value in gconf
        self.client.set_string(gconf_path, key)

    def on_key_cleared(self, renderer, path, model):
        """If the user tries to clear a keybinding with the backspace
        key this callback will be called and it just fill the model
        with an empty key and set the 'disabled' string in gconf path.
        """
        giter = model.get_iter(path)
        gconf_path = model.get_value(giter, 0)

        self.client.get_string(gconf_path)
        model.set_value(giter, 2, KeyEntry(0, 0))

        self.client.set_string(gconf_path, 'disabled')

    def cell_data_func(self, column, renderer, model, giter):
        """Defines the way that each renderer will handle the key
        object and the mask it sets the properties for a cellrenderer
        key.
        """
        obj = model.get_value(giter, 2)
        if obj:
            renderer.set_property('visible', True)
            renderer.set_property('accel-key', obj.keycode)
            renderer.set_property('accel-mods', obj.mask)
        else:
            renderer.set_property('visible', False)
            renderer.set_property('accel-key', 0)
            renderer.set_property('accel-mods', 0)

    def start_editing(self, treeview, event):
        """Make the treeview grab the focus and start editing the cell
        that the user has clicked to avoid confusion with two or three
        clicks before editing a keybinding.

        Thanks to gnome-keybinding-properties.c =)
        """
        if event.window != treeview.get_bin_window():
            return False

        x, y = int(event.x), int(event.y)
        ret = treeview.get_path_at_pos(x, y)
        if not ret:
            return False

        path, column, cellx, celly = ret
        if path and len(path) > 1:
            def real_cb():
                treeview.grab_focus()
                treeview.set_cursor(path, column, True)
            treeview.stop_emission('button-press-event')
            gobject.idle_add(real_cb)

        return True


class KeyEntry(object):
    def __init__(self, keycode, mask):
        self.keycode = keycode
        self.mask = mask

    def __repr__(self):
        return u'KeyEntry(%d, %d)' % (
            self.keycode, self.mask)

    def __eq__(self, rval):
        return self.keycode == rval.keycode and \
            self.mask == rval.mask


def setup_standalone_signals(instance):
    """Called when prefs dialog is running in standalone mode. It
    makes the delete event of dialog and click on close button finish
    the application.
    """
    window = instance.get_widget('config-window')
    window.connect('delete-event', gtk.main_quit)

    # We need to block the execution of the already associated
    # callback before connecting the new handler.
    button = instance.get_widget('button1')
    button.handler_block_by_func(instance.gtk_widget_destroy)
    button.connect('clicked', gtk.main_quit)

    return instance

if __name__ == '__main__':
    bindtextdomain(NAME, LOCALE_DIR)
    setup_standalone_signals(PrefsDialog()).show()
    gtk.main()

########NEW FILE########
__FILENAME__ = print_gtk_colors
#!/usr/bin/env python
import pygtk
import gtk


def format_color_string( Color ):
    return "%s %s %s" % (Color.red /256, Color.green/256,  Color.blue/256)

def print_hex_color( Color ):
    return "#" + hex(Color.red/256)[2:] + hex(Color.green/256)[2:] + hex(Color.blue/256)[2:]

def format_color_key( key, Color):
    return "\"%s\"=\"%s\" (%s)\n" % (key, format_color_string( Color ), print_hex_color( Color ))

invisible1 = gtk.Invisible()
style1 = invisible1.style

button1 = gtk.Button()
buttonstyle = button1.style

scroll1 =  gtk.VScrollbar()
scrollbarstyle = scroll1.style

menu1 = gtk.Menu()
menuitem1 = gtk.MenuItem()
menu1.add(menuitem1)
menustyle = menuitem1.style

format = ""
format += format_color_key('Scrollbar', scrollbarstyle.bg[gtk.STATE_NORMAL])
format += format_color_key('Background', style1.bg[gtk.STATE_NORMAL])
format += format_color_key('ActiveTitle', menustyle.bg[gtk.STATE_PRELIGHT])
format += format_color_key('InactiveTitle', menustyle.bg[gtk.STATE_PRELIGHT])
format += format_color_key('Menu', menustyle.bg[gtk.STATE_NORMAL])
format += format_color_key('Window', style1.bg[gtk.STATE_NORMAL])
format += format_color_key('WindowFrame', style1.fg[gtk.STATE_INSENSITIVE])
format += format_color_key('MenuText', style1.fg[gtk.STATE_NORMAL])
format += format_color_key('WindowText', style1.fg[gtk.STATE_NORMAL])
format += format_color_key('TitleText', style1.fg[gtk.STATE_NORMAL])
format += format_color_key('ActiveBorder', menustyle.bg[gtk.STATE_PRELIGHT])
format += format_color_key('InactiveBorder', menustyle.bg[gtk.STATE_NORMAL])
format += format_color_key('AppWorkSpace', style1.bg[gtk.STATE_NORMAL])
format += format_color_key('Hilight', menustyle.bg[gtk.STATE_PRELIGHT])
format += format_color_key('HilightText', style1.bg[gtk.STATE_PRELIGHT])
format += format_color_key('ButtonFace', style1.bg[gtk.STATE_NORMAL])
format += format_color_key('ButtonShadow', style1.bg[gtk.STATE_INSENSITIVE])
format += format_color_key('GrayText', style1.fg[gtk.STATE_INSENSITIVE])
format += format_color_key('ButtonText', style1.fg[gtk.STATE_NORMAL])
format += format_color_key('InactiveTitleText', style1.fg[gtk.STATE_INSENSITIVE])
format += format_color_key('ButtonHilight', style1.bg[gtk.STATE_NORMAL])
format += format_color_key('ButtonShadow', style1.fg[gtk.STATE_NORMAL])
format += format_color_key('ButtonLight', style1.fg[gtk.STATE_NORMAL])
format += format_color_key('InfoText', style1.fg[gtk.STATE_NORMAL])
format += format_color_key('InfoWindow', style1.fg[gtk.STATE_NORMAL])
format += format_color_key('ButtonAlternateFace', style1.bg[gtk.STATE_NORMAL])
format += format_color_key('ButtonHilight', style1.bg[gtk.STATE_NORMAL])
format += format_color_key('GradientActiveTitle', style1.bg[gtk.STATE_NORMAL])
format += format_color_key('GradientInactiveTitle', style1.bg[gtk.STATE_NORMAL])
format += format_color_key('MenuHilight', menustyle.bg[gtk.STATE_NORMAL])

print format

########NEW FILE########
__FILENAME__ = simplegladeapp
"""
Copyright (C) 2004 Sandino Flores Moreno

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
USA

simplegladeapp.py - Module that provides an object oriented abstraction
to pygtk and libglade.

    - Adding `object' as base class to SimpleGladeApp class.
    by Lincoln de Sousa <lincoln@archlinux-br.org>

    - Commenting `setlocale' call to avoid problems with languages with
      sufixes (as pt_BR.utf8) by Lincoln de Sousa <lincoln@archlinux-br.org>
"""


import pygtk
pygtk.require('2.0')

import os
import sys
import re

import tokenize
import gtk
import gtk.glade
import weakref
import inspect

__version__ = "1.0"
__author__ = 'Sandino "tigrux" Flores-Moreno'

def bindtextdomain(app_name, locale_dir=None):
    """    
    Bind the domain represented by app_name to the locale directory locale_dir.
    It has the effect of loading translations, enabling applications for different
    languages.

    app_name:
        a domain to look for translations, tipically the name of an application.

    locale_dir:
        a directory with locales like locale_dir/lang_isocode/LC_MESSAGES/app_name.mo
        If omitted or None, then the current binding for app_name is used.
    """    
    try:
        import locale
        import gettext
        # FIXME: Commented to avoid problems with a .utf8 LANG variable...
        # locale.setlocale(locale.LC_ALL, "")
        gettext.bindtextdomain(app_name, locale_dir)
        gettext.textdomain(app_name)
        gtk.glade.bindtextdomain(app_name, locale_dir)
        gtk.glade.textdomain(app_name)
        gettext.install(app_name, locale_dir, unicode = 1)
    except (IOError,locale.Error), e:
        print "Warning", app_name, e
        __builtins__.__dict__["_"] = lambda x : x


class SimpleGladeApp(object):

    def __init__(self, path, root=None, domain=None, **kwargs):
        """
        Load a glade file specified by glade_filename, using root as
        root widget and domain as the domain for translations.

        If it receives extra named arguments (argname=value), then they are used
        as attributes of the instance.

        path:
            path to a glade filename.
            If glade_filename cannot be found, then it will be searched in the
            same directory of the program (sys.argv[0])

        root:
            the name of the widget that is the root of the user interface,
            usually a window or dialog (a top level widget).
            If None or ommited, the full user interface is loaded.

        domain:
            A domain to use for loading translations.
            If None or ommited, no translation is loaded.

        **kwargs:
            a dictionary representing the named extra arguments.
            It is useful to set attributes of new instances, for example:
                glade_app = SimpleGladeApp("ui.glade", foo="some value", bar="another value")
            sets two attributes (foo and bar) to glade_app.
        """        
        if os.path.isfile(path):
            self.glade_path = path
        else:
            glade_dir = os.path.dirname( sys.argv[0] )
            self.glade_path = os.path.join(glade_dir, path)
        for key, value in kwargs.items():
            try:
                setattr(self, key, weakref.proxy(value) )
            except TypeError:
                setattr(self, key, value)
        self.glade = None
        self.install_custom_handler(self.custom_handler)
        self.glade = self.create_glade(self.glade_path, root, domain)
        if root:
            self.main_widget = self.get_widget(root)
        else:
            self.main_widget = None
        self.normalize_names()
        self.add_callbacks(self)
        self.new()

    def __repr__(self):
        class_name = self.__class__.__name__
        if self.main_widget:
            root = gtk.Widget.get_name(self.main_widget)
            repr = '%s(path="%s", root="%s")' % (class_name, self.glade_path, root)
        else:
            repr = '%s(path="%s")' % (class_name, self.glade_path)
        return repr

    def new(self):
        """
        Method called when the user interface is loaded and ready to be used.
        At this moment, the widgets are loaded and can be refered as self.widget_name
        """
        pass

    def add_callbacks(self, callbacks_proxy):
        """
        It uses the methods of callbacks_proxy as callbacks.
        The callbacks are specified by using:
            Properties window -> Signals tab
            in glade-2 (or any other gui designer like gazpacho).

        Methods of classes inheriting from SimpleGladeApp are used as
        callbacks automatically.

        callbacks_proxy:
            an instance with methods as code of callbacks.
            It means it has methods like on_button1_clicked, on_entry1_activate, etc.
        """        
        self.glade.signal_autoconnect(callbacks_proxy)

    def normalize_names(self):
        """
        It is internally used to normalize the name of the widgets.
        It means a widget named foo:vbox-dialog in glade
        is refered self.vbox_dialog in the code.

        It also sets a data "prefixes" with the list of
        prefixes a widget has for each widget.
        """
        for widget in self.get_widgets():
            widget_name = gtk.Widget.get_name(widget)
            prefixes_name_l = widget_name.split(":")
            prefixes = prefixes_name_l[ : -1]
            widget_api_name = prefixes_name_l[-1]
            widget_api_name = "_".join(re.findall(tokenize.Name, widget_api_name))
            gtk.Widget.set_name(widget, widget_api_name)
            if hasattr(self, widget_api_name):
                raise AttributeError("instance %s already has an attribute %s" % (self,widget_api_name))
            else:
                setattr(self, widget_api_name, widget)
                if prefixes:
                    gtk.Widget.set_data(widget, "prefixes", prefixes)

    def add_prefix_actions(self, prefix_actions_proxy):
        """
        By using a gui designer (glade-2, gazpacho, etc)
        widgets can have a prefix in theirs names
        like foo:entry1 or foo:label3
        It means entry1 and label3 has a prefix action named foo.

        Then, prefix_actions_proxy must have a method named prefix_foo which
        is called everytime a widget with prefix foo is found, using the found widget
        as argument.

        prefix_actions_proxy:
            An instance with methods as prefix actions.
            It means it has methods like prefix_foo, prefix_bar, etc.
        """        
        prefix_s = "prefix_"
        prefix_pos = len(prefix_s)

        is_method = lambda t : callable( t[1] )
        is_prefix_action = lambda t : t[0].startswith(prefix_s)
        drop_prefix = lambda (k,w): (k[prefix_pos:],w)

        members_t = inspect.getmembers(prefix_actions_proxy)
        methods_t = filter(is_method, members_t)
        prefix_actions_t = filter(is_prefix_action, methods_t)
        prefix_actions_d = dict( map(drop_prefix, prefix_actions_t) )

        for widget in self.get_widgets():
            prefixes = gtk.Widget.get_data(widget, "prefixes")
            if prefixes:
                for prefix in prefixes:
                    if prefix in prefix_actions_d:
                        prefix_action = prefix_actions_d[prefix]
                        prefix_action(widget)

    def custom_handler(self,
            glade, function_name, widget_name,
            str1, str2, int1, int2):
        """
        Generic handler for creating custom widgets, internally used to
        enable custom widgets (custom widgets of glade).

        The custom widgets have a creation function specified in design time.
        Those creation functions are always called with str1,str2,int1,int2 as
        arguments, that are values specified in design time.

        Methods of classes inheriting from SimpleGladeApp are used as
        creation functions automatically.

        If a custom widget has create_foo as creation function, then the
        method named create_foo is called with str1,str2,int1,int2 as arguments.
        """
        try:
            handler = getattr(self, function_name)
            return handler(str1, str2, int1, int2)
        except AttributeError:
            return None

    def gtk_widget_show(self, widget, *args):
        """
        Predefined callback.
        The widget is showed.
        Equivalent to widget.show()
        """
        widget.show()

    def gtk_widget_hide(self, widget, *args):
        """
        Predefined callback.
        The widget is hidden.
        Equivalent to widget.hide()
        """
        widget.hide()
        return True

    def gtk_widget_grab_focus(self, widget, *args):
        """
        Predefined callback.
        The widget grabs the focus.
        Equivalent to widget.grab_focus()
        """
        widget.grab_focus()

    def gtk_widget_destroy(self, widget, *args):
        """
        Predefined callback.
        The widget is destroyed.
        Equivalent to widget.destroy()
        """
        widget.destroy()

    def gtk_window_activate_default(self, window, *args):
        """
        Predefined callback.
        The default widget of the window is activated.
        Equivalent to window.activate_default()
        """
        widget.activate_default()

    def gtk_true(self, *args):
        """
        Predefined callback.
        Equivalent to return True in a callback.
        Useful for stopping propagation of signals.
        """
        return True

    def gtk_false(self, *args):
        """
        Predefined callback.
        Equivalent to return False in a callback.
        """
        return False

    def gtk_main_quit(self, *args):
        """
        Predefined callback.
        Equivalent to self.quit()
        """
        self.quit()

    def main(self):
        """
        Starts the main loop of processing events.
        The default implementation calls gtk.main()

        Useful for applications that needs a non gtk main loop.
        For example, applications based on gstreamer needs to override
        this method with gst.main()

        Do not directly call this method in your programs.
        Use the method run() instead.
        """
        gtk.main()

    def quit(self, *args):
        """
        Quit processing events.
        The default implementation calls gtk.main_quit()
        
        Useful for applications that needs a non gtk main loop.
        For example, applications based on gstreamer needs to override
        this method with gst.main_quit()
        """
        gtk.main_quit()

    def run(self):
        """
        Starts the main loop of processing events checking for Control-C.

        The default implementation checks wheter a Control-C is pressed,
        then calls on_keyboard_interrupt().

        Use this method for starting programs.
        """
        try:
            self.main()
        except KeyboardInterrupt:
            self.on_keyboard_interrupt()

    def on_keyboard_interrupt(self):
        """
        This method is called by the default implementation of run()
        after a program is finished by pressing Control-C.
        """
        pass

    def install_custom_handler(self, custom_handler):
        gtk.glade.set_custom_handler(custom_handler)

    def create_glade(self, glade_path, root, domain):
        return gtk.glade.XML(glade_path, root, domain)

    def get_widget(self, widget_name):
        return self.glade.get_widget(widget_name)

    def get_widgets(self):
        return self.glade.get_widget_prefix("")

########NEW FILE########
