Spearmint Frequently Asked Questions
------------------------------------

This document contains answers to some of the more frequent questions that spearmint users are asking.

**Question**: When I run spearmint my $PYTHONPATH variable appears to not be preserved. How do I fix this?  
**Answer**: If you invoke spearmint from the commandline using `bin/spearmint`, then spearmint is called from a bash script.  With bash scripts,
in order to preserve the environment you have to invoke them by "sourcing them" by putting a "." before the call `. bin/spearmint ...`
Another way to avoid this is running main.py directly (i.e. `python main.py ...`).  

**Question**: What exactly is passed into a Python wrapper by spearmint in the Params dictionary?  
**Answer**: For INT and FLOAT types spearmint passes in a numpy array of the size specified in config.pb in 'size' (even if it is size 1).  For ENUM types it is a list of strings of size 'size'.  

**Question**: Where can I see what my code outputs when it is being run by spearmint?  
**Answer**: In the experiment directory (i.e. the one that contains config.pb) spearmint adds an output directory that contains the output of each job that has been run.  The files are of the form <job_id>.out  

**Question**: Can I see a list of all the experiments run so far (i.e. a list of parameters) along with the corresponding function (cost or loss) values.  
**Answer**: The web status page (which you can invoke using the -w flag) now show this list in an easy to read table.  

**Question**: Quite often I would like to stop and restart spearmint. Sometimes I can Ctrl-C spearmint and restart it. Other times it seems to block and do nothing when restarted. Is there anything I can do except cleanup the directory and start from scratch again? Also Ctrl-C only seems to break me out of spearmint, a spearmint process is still running in the background (which I kill manually). Is this expected?  
**Answer**: Spearmint uses a file `expt_grid.pkl` to maintains state.  All the jobs spawned by spearmint write to this file as well as spearmint itself.  This enables spearmint to spawn jobs on multiple nodes in a cluster.  Of course, the writes to this file must be atomic.  When you kill spearmint, the jobs it has spawned will keep running (this is the intended behavior - the assumption is that jobs are expensive, so something that kills spearmint hopefully wouldn't stop the running jobs).  There is a caveat that spearmint may die when it is holding the lock to this `expt_grid.pkl`.  If you find that you restart spearmint and it is perpetually "waiting to lock grid..." you can safely remove the lock by typing `rm <expt_dir>/expt_grid.pkl.lock`.

**Question**: Spearmint locks up after performing the first sampling computation.  
**Answer**: Python's multiprocessing causes a deadlock on some platforms.  You can pass in a command line argument `--method-args=use_multiprocessing=0` to turn off multiprocessing and do computations serially (this is a bit slower but works just as well).

Spearmint
---------

Spearmint is a package to perform Bayesian optimization according to the
algorithms outlined in the paper:  

**Practical Bayesian Optimization of Machine Learning Algorithms**  
Jasper Snoek, Hugo Larochelle and Ryan P. Adams  
*Advances in Neural Information Processing Systems*, 2012  

This code is designed to automatically run experiments (thus the code
name 'spearmint') in a manner that iteratively adjusts a number of
parameters so as to minimize some objective in as few runs as
possible.

Spearmint is the result of a collaboration primarily between machine learning researchers at [Harvard University](https://hips.seas.harvard.edu/) and the [University of Toronto](http://learning.cs.toronto.edu/).

**Soon you'll be able to do your optimization in the cloud with a more powerful, accessible and scalable tool.  Sign up for the private beta at www.whetlab.com**

Dependencies
------------
This package requires:

* Python 2.7

* [Numpy](http://www.numpy.org/) version 1.6.1+
On Ubuntu linux you can install this package using the command:

		apt-get install python-numpy

* [Scipy](http://www.scipy.org/) version 0.9.0+
On Ubuntu linux you can install this package using the command:

		apt-get install python-scipy

* [Google Protocol Buffers](https://developers.google.com/protocol-buffers/) (for the fully automated code).
Note that you should be able to install protocol-buffers from source without requiring administrator privileges.  Otherwise, on Ubuntu linux you can install this package using the command:

		apt-get install python-protobuf
						
	and on Mac (if you use homebrew) with:

		brew install protobuf

	Then from within the spearmint sub-directory run the command:

		bin/make_protobufs

This package has been tested on Ubuntu linux (versions 11.0+) and
Mac-OSX.

The code consists of several parts.  It is designed to be modular to
allow swapping out various 'driver' and 'chooser' modules.  The
'chooser' modules are implementations of acquisition functions such as
expected improvement, UCB or random.  The drivers determine how
experiments are distributed and run on the system.  As the code is
designed to run experiments in parallel (spawning a new experiment as
soon a result comes in), this requires some engineering.  The current
implementations of these are in the 'spearmint' and 'spearmint-lite' subdirectories:

**Spearmint** is designed to automatically manage the launching and associated bookkeeping 
of experiments in either a single machine or cluster environment.  This requires that you provide
a 'wrapper' in a supported language (currently Python or Matlab) and a configuration file detailing parameters
to be tuned and their respective bounds. The wrapper must accept parameter values and then return simply a value which you wish to minimize with respect to the parameters. Spearmint will then iteratively call the wrapper with different 
parameter settings in an order that seeks to find the minimum value in as few evaluations (or cost) as possible.

**Spearmint-lite** is the 'bare-bones' stripped version of the code.
This version is simply driven by a flat-file and does not
automatically run experiments.  Instead, it proposes new experiments
(potentially multiple at a time) and requires that the user fill in
the result.  This is well suited to the case where writing a wrapper
around the code doesn't make sense (e.g. if the experiments don't
involve code at all) or if the user desires full control of the
process.  Also, the dependency on Google protocol buffers is replaced
with JSON.

Running the automated code: Spearmint
--------------------------------------------------------

The simplest way to get to know the code is probably to look at an
example.  In order to start a new experiment, you must create a directory 
that includes a wrapper script and config file.
We have created one simple example for you that optimizes the
'Braninhoo' benchmark in the subdirectory **examples/braninpy**.  Take a look at
**config.pb**.  It contains the specifications of the algorithm in
protocol buffer format.  In order to specify your optimization, you
have to fill in the variables 'language' (e.g. PYTHON or MATLAB) and
'name' (the name of the wrapper function you want to optimize).

Followed by these is a list of 'variables', which specifies the name,
type and size of the variables you wish to optimize over.  Each
variable must be either a FLOAT, INT or ENUM type, corresponding to
continuous real valued parameters, integer sequences and categorical
variables respectively.  MAX and MIN specify the bounds of the
variables over which to optimize and SIZE is the number of variables
of this type with these bounds.  Spearmint will call your wrapper
function with a dictionary type (in python) containing each of your
variables in a vector of size 'size', which you can access using the
name specified.  

Now take a look at branin.py (the wrapper which was
specified in the 'name' variable at the top of config.pb).  You will
see the file has a function 'main(job_id, params)'.  Your wrapper must
include this function, which spearmint will call passing in a job_id
(which is probably not interesting to you) and a dictionary, 'params',
containing the parameter vectors of the next experiment spearmint
wants to run.  The main function should take as input these parameters
and return a single real valued number representing the observed
function value (that is being optimized) at these inputs.

To install spearmint, go into the spearmint subdirectory and type (most likely preceded with 'sudo'):

	python setup.py install

You should add the spearmint subdirectory to your PYTHONPATH directory.  Note that you can often avoid the above step, but may have to add all the relevant modules to your PYTHONPATH and call spearmint directory from the directory using main.py.

To run spearmint, go into the **/bin** subdirectory and type:

	./spearmint ../examples/braninpy/config.pb --driver=local --method=GPEIOptChooser --method-args=noiseless=1

or alternatively in the **/spearmint** subdirectory:

	python main.py --driver=local --method=GPEIOptChooser --method-args=noiseless=1 ../examples/braninpy/config.pb

This will run spearmint according to the GP-EI MCMC strategy.  The code will sequentially spawn
processes that call the wrapper function and it will poll for results.
You will see that the code prints out the current best (i.e. lowest)
observation seen thus far and sequences of numbers corresponding to GP
hyperparameter samples and candidates it is optimizing over.  The
'method' argument specifies the chooser module (acquisition function)
to use and 'method-args' specifies chooser specific arguments.  In
this case, as braninhoo is an analytic function we tell the GP
hyperparameter sampling routine to not try to estimate noise.  This parameter is very important to specify correctly for the optimization to proceed properly.  If your algorithm is entirely deterministic (e.g. analytic) then specifying that it is noiseless will speed up the optimization considerably.  If your algorithm is not deterministic, as we expect for most machine learning algorithms and indeed most expensive experiments, then you should leave this out or set noiseless=0.

If you let it run for a while you will see that the current-best
decreases, eventually reaching the minimum at ~0.39. You can kill the
process (ctrl-c) at any time and you can restart from where it left off simply
by rerunning the spearmint command.

If you go back in to the braninpy directory you will see a number of
new files that spearmint uses to do bookkeeping.  Of particular
interest are **trace.csv** and the **output** directory.  **trace.csv**
contains a record of the experiments run so far and the best result
(and which experiment it came from) as a series over time.  Each line
of trace.csv contains the following in csv format: a timestamp, the
best value observed up to that timestamp, the job-id of the best value
observed, the number of potential candidates left, the number of
pending (currently running) experiments, the number of experiments
completed thus far.  The output directory contains a text file for
each job-id, containing the output of that job.  So if you want to
see, e.g. what the output (i.e. standard out and standard error) was
for the best job (as obtained from trace.csv) you can look up
job-id.txt in the output directory. 

 If you are debugging your code,
or the code is crashing for some reason, it's a good idea to look at
these files. Finally for ease of use, spearmint also prints out at
each iteration a file called 'best_job_and_result.txt' that contains the
best result observed so far, the job-id it came from and a dump of 
the names and values of all of the parameters corresponding to that result.

A script, bin/cleanup, is provided to completely restart an experiment
and delete all the results and intermediate files.  Simply run
`bin/cleanup <experiment_dir>`

Matlab code can also be optimized using this package. To do so, you
must specify in config.pb "type: Matlab" and use a matlab wrapper with
the "name" specified in config.pb.  The matlab wrapper must have a
function with the same name as the file name of the following form:
"function result = braninhoo(job_id, params)" Above we assume the file
name is "braninhoo.m".  Spearmint will pass in to this wrapper a
job_id and a matlab struct 'params' where the fields are given by the
variables specified in config.pb.  See the subdirectory "braninhoo"
for a matlab example matching that of python 'braninpy' described
above.

To run multiple jobs in parallel, pass to spearmint the argument:
`--max-concurrent=<#jobs>`

Spearmint is designed to be run in parallel either using multiple processors on a single machine or in a cluster environment.  These different environments, however, involve different queuing and fault-checking code and are thus coded as 'driver' modules.  Currently two drivers are available, but one can easily create a driver for a different environment by creating a new driver module (see the driver subdirectory for examples).

Using the `--driver=sge` flag, Spearmint can run on a system with Sun Grid Engine and it uses SGE to distribute experiments on a multi-node cluster in parallel using a queueing system in a fault-tolerant way.  It is particularly
well suited to the Amazon EC2 system.  Using [StarCluster](http://star.mit.edu/cluster/) will allow you to set up a large cluster and start distributing experiments within minutes.

Using the `--driver=local` flag will run Spearmint on a single machine with potentially many cores.  This driver simply spawns a new process on the current machine to run a new experiment.  This does not allow you to distribute across multiple machines, however.

### Web Status Page
Running spearmint with the flag `-w` will spawn a local web server that will display useful info and statistics about your optimization run in a much more interpretable and intuitive interface than the command line.  Spearmint will provide a link to the status page that you can simply paste into a browser window.


Running the basic code: Spearmint-lite 
---------------------------------------

Spearmint-lite is designed to be simple.  To run an experiment in
spearmint-lite, create a subdirectory as explained above.  Again, the
braninpy directory is provided as a demonstration.  In this case, the
experiment specification, which must be provided in config.json, is in
JSON format.  You must specify your problem as a sequence of JSON
objects.  As in the protocol buffer format above, each object must
have a name, a type (float, int or enum), a 'min', a 'max' and a
'size'. Nothing else needs to be specified.  

Go back to the top-level directory and run: 

	python spearmint-lite.py braninpy

Spearmint-lite will run one iteration of Bayesian
optimization and write out to a file named results.dat in the braninpy
subdirectory.  results.dat will contain a white-space delimited line
for each experiment, of the format: 
`<result> <time-taken> <list of parameters in the same order as config.json>`

Spearmint will propose new experiments and append them to results.dat each 
time it is run. Each proposed experiment will have a 'pending' result and 
time-taken, indicated by the letter P. The user must then run the experiment 
and fill in these values. Note that the time can safely be set to an arbitrary
value if the chooser module does not use it (only GPEIperSecChooser currently 
does). Spearmint will condition on the pending experiments when proposing new 
ones, so any number of experiments can be conducted in parallel.

A script, **cleanup.sh**, is provided to completely clean up all the intermediate
files and results in an experimental directory and restart the
experiment from scratch.

Chooser modules:
--------------- 

The chooser modules implement functions that tell spearmint which next
job to run.  Some correspond to 'acquisition functions' in the
Bayesian optimization literature.  Spearmint takes as an argument
`--method=ChooserModule` which allows one to easy swap out acquisition
functions. Choosers may optionally include parameters that can be
passed to spearmint using the argument
`--method-args=argument1,argument2,etc`.  These include, for example, the
number of GP hyperparameter samples to use. See the comments in
chooser files for chooser dependent arguments.  Below are described
the choosers provided in this package:

* **SequentialChooser:** Chooses the next experiment using a high
discrepancy Sobol sequence.  Experiments are taken sequentially from a
coarse-to-fine grid.

* **RandomChooser**: Experiments are sampled randomly from the unit hypercube.

* **GPEIOptChooser:** The GP EI MCMC algorithm from the paper. Jobs 
are first sampled densely from a dense grid on the unit hypercube
and then the best candidates are optimized 'fine-tuned' according
to EI.

* **GPEIperSecChooser:** The GP EI per Second algorithm from the paper.
Similar to GPEIOptChooser except points are optimized and evaluated
based on the EI per Second criterion, where each job is weighted
by the expected running time of the experiment.

* **GPEIChooser:** Points are densely sampled on the unit hypercube and the
best is returned according to the EI criterion.  This is considerably
faster than the GPEIOptChooser and works well in low-dimensional cases
where the grid covers the search space densely.

**IMPORTANT!**

When estimating noise, the Gaussian process prior over noise assumes
that the noise level is 'low' (e.g. between -1 to 1). If this is not
the case, make sure to rescale your function to make this true
(e.g. to approximately be between -1 and 1).  Otherwise, the algorithm
will find a bad high-noise mode that will result in bad performance.

## De Jong's function (2D)

A simple benchmark for optimization, De Jong's function is continuous, convex, and unimodal with a single parameter.

    f(x,y) = x^2 + y^2

### Global optimium

    X = 0
    Y = 0

## Rosenbrock's Valley

A slightly more difficult benchmark for optimization, Rosenbrock's valley (a.k.k the banana function) has a global
optimimum lying inside a long, narrow parabolic valley with a flat floor.

    f(x,y) = 100(y - x^2)^2 + (1 - x)^2

Global minimum:

    X = 0
    Y = 0


## The Six Hump Camel Back

A more difficult global optimization test function, this function has 6 local minima, two of which are global.

    f(x,y) = (4 - 2.1x^2 + x^4 / 3)x^2 + xy + (-4 + 4x^2)x^2

### Global optimium

    f(x,y) = −1.0316

    X = -0.898  (0.898)
    Y = 0.7126  (-0.7126)

Spearmint
---------

Spearmint is a package to perform Bayesian optimization according to the
algorithms outlined in the paper:  

**Practical Bayesian Optimization of Machine Learning Algorithms**  
Jasper Snoek, Hugo Larochelle and Ryan P. Adams  
*Advances in Neural Information Processing Systems*, 2012  

This code is designed to automatically run experiments (thus the code
name 'spearmint') in a manner that iteratively adjusts a number of
parameters so as to minimize some objective in as few runs as
possible.

Dependencies
------------
This package requires:

* Python 2.7

* [Numpy](http://www.numpy.org/) version 1.6.1+
On Ubuntu linux you can install this package using the command:

		apt-get install python-numpy

* [Scipy](http://www.scipy.org/) version 0.9.0+
On Ubuntu linux you can install this package using the command:

		apt-get install python-scipy

* [Google Protocol Buffers](https://developers.google.com/protocol-buffers/) (for the fully automated code).
Note that you should be able to install protocol-buffers from source without requiring administrator privileges.  Otherwise, on Ubuntu linux you can install this package using the command:

		apt-get install python-protobuf
						
	and on Mac with:

		pip install protobuf

	Then from within the spearmint sub-directory run the command:

		bin/make_protobufs

This package has been tested on Ubuntu linux (versions 11.0+) and
Mac-OSX.

The code consists of several parts.  It is designed to be modular to
allow swapping out various 'driver' and 'chooser' modules.  The
'chooser' modules are implementations of acquisition functions such as
expected improvement, UCB or random.  The drivers determine how
experiments are distributed and run on the system.  As the code is
designed to run experiments in parallel (spawning a new experiment as
soon a result comes in), this requires some engineering.  The current
implementations of these are in the 'spearmint' and 'spearmint-lite' subdirectories:

**Spearmint** is designed to automatically manage the launching and associated bookkeeping 
of experiments in either a single machine or cluster environment.  This requires that you provide
a 'wrapper' in a supported language (currently Python or Matlab) and a configuration file detailing parameters
to be tuned and their respective bounds. The wrapper must accept parameter values and then return simply a value which you wish to minimize with respect to the parameters. Spearmint will then iteratively call the wrapper with different 
parameter settings in an order that seeks to find the minimum value in as few evaluations (or cost) as possible.

**Spearmint-lite** is the 'bare-bones' stripped version of the code.
This version is simply driven by a flat-file and does not
automatically run experiments.  Instead, it proposes new experiments
(potentially multiple at a time) and requires that the user fill in
the result.  This is well suited to the case where writing a wrapper
around the code doesn't make sense (e.g. if the experiments don't
involve code at all) or if the user desires full control of the
process.  Also, the dependency on Google protocol buffers is replaced
with JSON.

Running the automated code: Spearmint
--------------------------------------------------------

The simplest way to get to know the code is probably to look at an
example.  In order to start a new experiment, you must create a directory 
that includes a wrapper script and config file.
We have created one simple example for you that optimizes the
'Braninhoo' benchmark in the subdirectory **examples/braninpy**.  Take a look at
**config.pb**.  It contains the specifications of the algorithm in
protocol buffer format.  In order to specify your optimization, you
have to fill in the variables 'language' (e.g. PYTHON or MATLAB) and
'name' (the name of the wrapper function you want to optimize).

Followed by these is a list of 'variables', which specifies the name,
type and size of the variables you wish to optimize over.  Each
variable must be either a FLOAT, INT or ENUM type, corresponding to
continuous real valued parameters, integer sequences and categorical
variables respectively.  MAX and MIN specify the bounds of the
variables over which to optimize and SIZE is the number of variables
of this type with these bounds.  Spearmint will call your wrapper
function with a dictionary type (in python) containing each of your
variables in a vector of size 'size', which you can access using the
name specified.  

Now take a look at branin.py (the wrapper which was
specified in the 'name' variable at the top of config.pb).  You will
see the file has a function 'main(job_id, params)'.  Your wrapper must
include this function, which spearmint will call passing in a job_id
(which is probably not interesting to you) and a dictionary, 'params',
containing the parameter vectors of the next experiment spearmint
wants to run.  The main function should take as input these parameters
and return a single real valued number representing the observed
function value (that is being optimized) at these inputs.

To install spearmint, go into the spearmint subdirectory and type (most likely preceded with 'sudo'):

	python setup.py install

You should add the spearmint subdirectory to your PYTHONPATH directory.  Note that you can often avoid the above step, but may have to add all the relevant modules to your PYTHONPATH and call spearmint directory from the directory using main.py.

To run spearmint, go into the **/bin** subdirectory and type:

	./spearmint ../examples/braninpy/config.pb --driver=local --method=GPEIOptChooser --method-args=noiseless=1

or alternatively in the **/spearmint** subdirectory:

	python main.py --driver=local --method=GPEIOptChooser --method-args=noiseless=1 ../examples/braninpy/config.pb

This will run spearmint according to the GP-EI MCMC strategy.  The code will sequentially spawn
processes that call the wrapper function and it will poll for results.
You will see that the code prints out the current best (i.e. lowest)
observation seen thus far and sequences of numbers corresponding to GP
hyperparameter samples and candidates it is optimizing over.  The
'method' argument specifies the chooser module (acquisition function)
to use and 'method-args' specifies chooser specific arguments.  In
this case, as braninhoo is an analytic function we tell the GP
hyperparameter sampling routine to not try to estimate noise.  This parameter is very important to specify correctly for the optimization to proceed properly.  If your algorithm is entirely deterministic (e.g. analytic) then specifying that it is noiseless will speed up the optimization considerably.  If your algorithm is not deterministic, as we expect for most machine learning algorithms and indeed most expensive experiments, then you should leave this out or set noiseless=0.

If you let it run for a while you will see that the current-best
decreases, eventually reaching the minimum at ~0.39. You can kill the
process (ctrl-c) at any time and you can restart from where it left off simply
by rerunning the spearmint command.

If you go back in to the braninpy directory you will see a number of
new files that spearmint uses to do bookkeeping.  Of particular
interest are **trace.csv** and the **output** directory.  **trace.csv**
contains a record of the experiments run so far and the best result
(and which experiment it came from) as a series over time.  Each line
of trace.csv contains the following in csv format: a timestamp, the
best value observed up to that timestamp, the job-id of the best value
observed, the number of potential candidates left, the number of
pending (currently running) experiments, the number of experiments
completed thus far.  The output directory contains a text file for
each job-id, containing the output of that job.  So if you want to
see, e.g. what the output (i.e. standard out and standard error) was
for the best job (as obtained from trace.csv) you can look up
job-id.txt in the output directory. 

 If you are debugging your code,
or the code is crashing for some reason, it's a good idea to look at
these files. Finally for ease of use, spearmint also prints out at
each iteration a file called 'best_job_and_result.txt' that contains the
best result observed so far, the job-id it came from and a dump of 
the names and values of all of the parameters corresponding to that result.

A script, bin/cleanup, is provided to completely restart an experiment
and delete all the results and intermediate files.  Simply run
`bin/cleanup <experiment_dir>`

Matlab code can also be optimized using this package. To do so, you
must specify in config.pb "type: Matlab" and use a matlab wrapper with
the "name" specified in config.pb.  The matlab wrapper must have a
function with the same name as the file name of the following form:
"function result = braninhoo(job_id, params)" Above we assume the file
name is "braninhoo.m".  Spearmint will pass in to this wrapper a
job_id and a matlab struct 'params' where the fields are given by the
variables specified in config.pb.  See the subdirectory "braninhoo"
for a matlab example matching that of python 'braninpy' described
above.

To run multiple jobs in parallel, pass to spearmint the argument:
`--max-concurrent=<#jobs>`

Spearmint is designed to be run in parallel either using multiple processors on a single machine or in a cluster environment.  These different environments, however, involve different queuing and fault-checking code and are thus coded as 'driver' modules.  Currently two drivers are available, but one can easily create a driver for a different environment by creating a new driver module (see the driver subdirectory for examples).

Using the `--driver=sge` flag, Spearmint can run on a system with Sun Grid Engine and it uses SGE to distribute experiments on a multi-node cluster in parallel using a queueing system in a fault-tolerant way.  It is particularly
well suited to the Amazon EC2 system.  Using [StarCluster](http://star.mit.edu/cluster/) will allow you to set up a large cluster and start distributing experiments within minutes.

Using the `--driver=local` flag will run Spearmint on a single machine with potentially many cores.  This driver simply spawns a new process on the current machine to run a new experiment.  This does not allow you to distribute across multiple machines, however.

### Web Status Page
Running spearmint with the flag `-w` will spawn a local web server that will display useful info and statistics about your optimization run in a much more interpretable and intuitive interface than the command line.  Spearmint will provide a link to the status page that you can simply paste into a browser window.


Running the basic code: Spearmint-lite 
---------------------------------------

Spearmint-lite is designed to be simple.  To run an experiment in
spearmint-lite, create a subdirectory as explained above.  Again, the
braninpy directory is provided as a demonstration.  In this case, the
experiment specification, which must be provided in config.json, is in
JSON format.  You must specify your problem as a sequence of JSON
objects.  As in the protocol buffer format above, each object must
have a name, a type (float, int or enum), a 'min', a 'max' and a
'size'. Nothing else needs to be specified.  

Go back to the top-level directory and run: 

	python spearmint-lite.py braninpy

Spearmint-lite will run one iteration of Bayesian
optimization and write out to a file named results.dat in the braninpy
subdirectory.  results.dat will contain a white-space delimited line
for each experiment, of the format: 
`<result> <time-taken> <list of parameters in the same order as config.json>`

Spearmint will propose new experiments and append them to results.dat each 
time it is run. Each proposed experiment will have a 'pending' result and 
time-taken, indicated by the letter P. The user must then run the experiment 
and fill in these values. Note that the time can safely be set to an arbitrary
value if the chooser module does not use it (only GPEIperSecChooser currently 
does). Spearmint will condition on the pending experiments when proposing new 
ones, so any number of experiments can be conducted in parallel.

A script, **cleanup.sh**, is provided to completely clean up all the intermediate
files and results in an experimental directory and restart the
experiment from scratch.

Chooser modules:
--------------- 

The chooser modules implement functions that tell spearmint which next
job to run.  Some correspond to 'acquisition functions' in the
Bayesian optimization literature.  Spearmint takes as an argument
`--method=ChooserModule` which allows one to easy swap out acquisition
functions. Choosers may optionally include parameters that can be
passed to spearmint using the argument
`--method-args=argument1,argument2,etc`.  These include, for example, the
number of GP hyperparameter samples to use. See the comments in
chooser files for chooser dependent arguments.  Below are described
the choosers provided in this package:

* **SequentialChooser:** Chooses the next experiment using a high
discrepancy Sobol sequence.  Experiments are taken sequentially from a
coarse-to-fine grid.

* **RandomChooser**: Experiments are sampled randomly from the unit hypercube.

* **GPEIOptChooser:** The GP EI MCMC algorithm from the paper. Jobs 
are first sampled densely from a dense grid on the unit hypercube
and then the best candidates are optimized 'fine-tuned' according
to EI.

* **GPEIperSecChooser:** The GP EI per Second algorithm from the paper.
Similar to GPEIOptChooser except points are optimized and evaluated
based on the EI per Second criterion, where each job is weighted
by the expected running time of the experiment.

* **GPEIChooser:** Points are densely sampled on the unit hypercube and the
best is returned according to the EI criterion.  This is considerably
faster than the GPEIOptChooser and works well in low-dimensional cases
where the grid covers the search space densely.

**IMPORTANT!**

When estimating noise, the Gaussian process prior over noise assumes
that the noise level is 'low' (e.g. between -1 to 1). If this is not
the case, make sure to rescale your function to make this true
(e.g. to approximately be between -1 and 1).  Otherwise, the algorithm
will find a bad high-noise mode that will result in bad performance.

function [descriptor] = pb_descriptor_Experiment()
%pb_descriptor_Experiment Returns the descriptor for message Experiment.
%   function [descriptor] = pb_descriptor_Experiment()
%
%   See also pb_read_Experiment
  
  descriptor = struct( ...
    'name', 'Experiment', ...
    'full_name', 'Experiment', ...
    'filename', 'spearmint.proto', ...
    'containing_type', '', ...
    'fields', [ ...
      struct( ...
        'name', 'language', ...
        'full_name', 'Experiment.language', ...
        'index', 1, ...
        'number', uint32(1), ...
        'type', uint32(14), ...
        'matlab_type', uint32(10), ...
        'wire_type', uint32(0), ...
        'label', uint32(2), ...
        'default_value', int32(1), ...
        'read_function', @(x) pblib_helpers_first(typecast(x, 'int32')), ...
        'write_function', @(x) typecast(int32(x), 'uint32'), ...
        'options', struct('packed', false) ...
      ), ...
      struct( ...
        'name', 'name', ...
        'full_name', 'Experiment.name', ...
        'index', 2, ...
        'number', uint32(2), ...
        'type', uint32(9), ...
        'matlab_type', uint32(7), ...
        'wire_type', uint32(2), ...
        'label', uint32(2), ...
        'default_value', '', ...
        'read_function', @(x) char(x{1}(x{2} : x{3})), ...
        'write_function', @uint8, ...
        'options', struct('packed', false) ...
      ), ...
      struct( ...
        'name', 'variable', ...
        'full_name', 'Experiment.variable', ...
        'index', 3, ...
        'number', uint32(3), ...
        'type', uint32(11), ...
        'matlab_type', uint32(9), ...
        'wire_type', uint32(2), ...
        'label', uint32(3), ...
        'default_value', struct([]), ...
        'read_function', @(x) pb_read_Experiment__ParameterSpec(x{1}, x{2}, x{3}), ...
        'write_function', @pblib_generic_serialize_to_string, ...
        'options', struct('packed', false) ...
      ) ...
    ], ...
    'extensions', [ ... % Not Implemented
    ], ...
    'nested_types', [ ... % Not implemented
    ], ...
    'enum_types', [ ... % Not Implemented
    ], ...
    'options', [ ... % Not Implemented
    ] ...
  );
  
  descriptor.field_indeces_by_number = java.util.HashMap;
  put(descriptor.field_indeces_by_number, uint32(1), 1);
  put(descriptor.field_indeces_by_number, uint32(2), 2);
  put(descriptor.field_indeces_by_number, uint32(3), 3);
  

function [descriptor] = pb_descriptor_Experiment__ParameterSpec()
%pb_descriptor_Experiment__ParameterSpec Returns the descriptor for message ParameterSpec.
%   function [descriptor] = pb_descriptor_Experiment__ParameterSpec()
%
%   See also pb_read_Experiment__ParameterSpec
  
  descriptor = struct( ...
    'name', 'ParameterSpec', ...
    'full_name', 'Experiment.ParameterSpec', ...
    'filename', 'spearmint.proto', ...
    'containing_type', 'Experiment', ...
    'fields', [ ...
      struct( ...
        'name', 'name', ...
        'full_name', 'Experiment.ParameterSpec.name', ...
        'index', 1, ...
        'number', uint32(1), ...
        'type', uint32(9), ...
        'matlab_type', uint32(7), ...
        'wire_type', uint32(2), ...
        'label', uint32(2), ...
        'default_value', '', ...
        'read_function', @(x) char(x{1}(x{2} : x{3})), ...
        'write_function', @uint8, ...
        'options', struct('packed', false) ...
      ), ...
      struct( ...
        'name', 'size', ...
        'full_name', 'Experiment.ParameterSpec.size', ...
        'index', 2, ...
        'number', uint32(2), ...
        'type', uint32(13), ...
        'matlab_type', uint32(3), ...
        'wire_type', uint32(0), ...
        'label', uint32(2), ...
        'default_value', uint32(0), ...
        'read_function', @(x) pblib_helpers_first(typecast(x, 'uint32')), ...
        'write_function', @(x) typecast(uint32(x), 'uint32'), ...
        'options', struct('packed', false) ...
      ), ...
      struct( ...
        'name', 'type', ...
        'full_name', 'Experiment.ParameterSpec.type', ...
        'index', 3, ...
        'number', uint32(3), ...
        'type', uint32(14), ...
        'matlab_type', uint32(10), ...
        'wire_type', uint32(0), ...
        'label', uint32(2), ...
        'default_value', int32(1), ...
        'read_function', @(x) pblib_helpers_first(typecast(x, 'int32')), ...
        'write_function', @(x) typecast(int32(x), 'uint32'), ...
        'options', struct('packed', false) ...
      ), ...
      struct( ...
        'name', 'options', ...
        'full_name', 'Experiment.ParameterSpec.options', ...
        'index', 4, ...
        'number', uint32(4), ...
        'type', uint32(9), ...
        'matlab_type', uint32(7), ...
        'wire_type', uint32(2), ...
        'label', uint32(3), ...
        'default_value', char([]), ...
        'read_function', @(x) char(x{1}(x{2} : x{3})), ...
        'write_function', @uint8, ...
        'options', struct('packed', false) ...
      ), ...
      struct( ...
        'name', 'min', ...
        'full_name', 'Experiment.ParameterSpec.min', ...
        'index', 5, ...
        'number', uint32(5), ...
        'type', uint32(1), ...
        'matlab_type', uint32(5), ...
        'wire_type', uint32(1), ...
        'label', uint32(1), ...
        'default_value', double(0), ...
        'read_function', @(x) typecast(x, 'double'), ...
        'write_function', @(x) typecast(double(x), 'uint8'), ...
        'options', struct('packed', false) ...
      ), ...
      struct( ...
        'name', 'max', ...
        'full_name', 'Experiment.ParameterSpec.max', ...
        'index', 6, ...
        'number', uint32(6), ...
        'type', uint32(1), ...
        'matlab_type', uint32(5), ...
        'wire_type', uint32(1), ...
        'label', uint32(1), ...
        'default_value', double(0), ...
        'read_function', @(x) typecast(x, 'double'), ...
        'write_function', @(x) typecast(double(x), 'uint8'), ...
        'options', struct('packed', false) ...
      ) ...
    ], ...
    'extensions', [ ... % Not Implemented
    ], ...
    'nested_types', [ ... % Not implemented
    ], ...
    'enum_types', [ ... % Not Implemented
    ], ...
    'options', [ ... % Not Implemented
    ] ...
  );
  
  descriptor.field_indeces_by_number = java.util.HashMap;
  put(descriptor.field_indeces_by_number, uint32(1), 1);
  put(descriptor.field_indeces_by_number, uint32(2), 2);
  put(descriptor.field_indeces_by_number, uint32(3), 3);
  put(descriptor.field_indeces_by_number, uint32(4), 4);
  put(descriptor.field_indeces_by_number, uint32(5), 5);
  put(descriptor.field_indeces_by_number, uint32(6), 6);
  

function [descriptor] = pb_descriptor_Job()
%pb_descriptor_Job Returns the descriptor for message Job.
%   function [descriptor] = pb_descriptor_Job()
%
%   See also pb_read_Job
  
  descriptor = struct( ...
    'name', 'Job', ...
    'full_name', 'Job', ...
    'filename', 'spearmint.proto', ...
    'containing_type', '', ...
    'fields', [ ...
      struct( ...
        'name', 'id', ...
        'full_name', 'Job.id', ...
        'index', 1, ...
        'number', uint32(1), ...
        'type', uint32(4), ...
        'matlab_type', uint32(4), ...
        'wire_type', uint32(0), ...
        'label', uint32(2), ...
        'default_value', uint64(0), ...
        'read_function', @(x) typecast(x, 'uint64'), ...
        'write_function', @(x) typecast(uint64(x), 'uint64'), ...
        'options', struct('packed', false) ...
      ), ...
      struct( ...
        'name', 'expt_dir', ...
        'full_name', 'Job.expt_dir', ...
        'index', 2, ...
        'number', uint32(2), ...
        'type', uint32(9), ...
        'matlab_type', uint32(7), ...
        'wire_type', uint32(2), ...
        'label', uint32(2), ...
        'default_value', '', ...
        'read_function', @(x) char(x{1}(x{2} : x{3})), ...
        'write_function', @uint8, ...
        'options', struct('packed', false) ...
      ), ...
      struct( ...
        'name', 'name', ...
        'full_name', 'Job.name', ...
        'index', 3, ...
        'number', uint32(3), ...
        'type', uint32(9), ...
        'matlab_type', uint32(7), ...
        'wire_type', uint32(2), ...
        'label', uint32(2), ...
        'default_value', '', ...
        'read_function', @(x) char(x{1}(x{2} : x{3})), ...
        'write_function', @uint8, ...
        'options', struct('packed', false) ...
      ), ...
      struct( ...
        'name', 'language', ...
        'full_name', 'Job.language', ...
        'index', 4, ...
        'number', uint32(4), ...
        'type', uint32(14), ...
        'matlab_type', uint32(10), ...
        'wire_type', uint32(0), ...
        'label', uint32(2), ...
        'default_value', int32(1), ...
        'read_function', @(x) pblib_helpers_first(typecast(x, 'int32')), ...
        'write_function', @(x) typecast(int32(x), 'uint32'), ...
        'options', struct('packed', false) ...
      ), ...
      struct( ...
        'name', 'status', ...
        'full_name', 'Job.status', ...
        'index', 5, ...
        'number', uint32(5), ...
        'type', uint32(9), ...
        'matlab_type', uint32(7), ...
        'wire_type', uint32(2), ...
        'label', uint32(1), ...
        'default_value', '', ...
        'read_function', @(x) char(x{1}(x{2} : x{3})), ...
        'write_function', @uint8, ...
        'options', struct('packed', false) ...
      ), ...
      struct( ...
        'name', 'param', ...
        'full_name', 'Job.param', ...
        'index', 6, ...
        'number', uint32(6), ...
        'type', uint32(11), ...
        'matlab_type', uint32(9), ...
        'wire_type', uint32(2), ...
        'label', uint32(3), ...
        'default_value', struct([]), ...
        'read_function', @(x) pb_read_Parameter(x{1}, x{2}, x{3}), ...
        'write_function', @pblib_generic_serialize_to_string, ...
        'options', struct('packed', false) ...
      ), ...
      struct( ...
        'name', 'submit_t', ...
        'full_name', 'Job.submit_t', ...
        'index', 7, ...
        'number', uint32(7), ...
        'type', uint32(4), ...
        'matlab_type', uint32(4), ...
        'wire_type', uint32(0), ...
        'label', uint32(1), ...
        'default_value', uint64(0), ...
        'read_function', @(x) typecast(x, 'uint64'), ...
        'write_function', @(x) typecast(uint64(x), 'uint64'), ...
        'options', struct('packed', false) ...
      ), ...
      struct( ...
        'name', 'start_t', ...
        'full_name', 'Job.start_t', ...
        'index', 8, ...
        'number', uint32(8), ...
        'type', uint32(4), ...
        'matlab_type', uint32(4), ...
        'wire_type', uint32(0), ...
        'label', uint32(1), ...
        'default_value', uint64(0), ...
        'read_function', @(x) typecast(x, 'uint64'), ...
        'write_function', @(x) typecast(uint64(x), 'uint64'), ...
        'options', struct('packed', false) ...
      ), ...
      struct( ...
        'name', 'end_t', ...
        'full_name', 'Job.end_t', ...
        'index', 9, ...
        'number', uint32(9), ...
        'type', uint32(4), ...
        'matlab_type', uint32(4), ...
        'wire_type', uint32(0), ...
        'label', uint32(1), ...
        'default_value', uint64(0), ...
        'read_function', @(x) typecast(x, 'uint64'), ...
        'write_function', @(x) typecast(uint64(x), 'uint64'), ...
        'options', struct('packed', false) ...
      ), ...
      struct( ...
        'name', 'value', ...
        'full_name', 'Job.value', ...
        'index', 10, ...
        'number', uint32(10), ...
        'type', uint32(1), ...
        'matlab_type', uint32(5), ...
        'wire_type', uint32(1), ...
        'label', uint32(1), ...
        'default_value', double(0), ...
        'read_function', @(x) typecast(x, 'double'), ...
        'write_function', @(x) typecast(double(x), 'uint8'), ...
        'options', struct('packed', false) ...
      ), ...
      struct( ...
        'name', 'duration', ...
        'full_name', 'Job.duration', ...
        'index', 11, ...
        'number', uint32(11), ...
        'type', uint32(1), ...
        'matlab_type', uint32(5), ...
        'wire_type', uint32(1), ...
        'label', uint32(1), ...
        'default_value', double(0), ...
        'read_function', @(x) typecast(x, 'double'), ...
        'write_function', @(x) typecast(double(x), 'uint8'), ...
        'options', struct('packed', false) ...
      ) ...
    ], ...
    'extensions', [ ... % Not Implemented
    ], ...
    'nested_types', [ ... % Not implemented
    ], ...
    'enum_types', [ ... % Not Implemented
    ], ...
    'options', [ ... % Not Implemented
    ] ...
  );
  
  descriptor.field_indeces_by_number = java.util.HashMap;
  put(descriptor.field_indeces_by_number, uint32(1), 1);
  put(descriptor.field_indeces_by_number, uint32(2), 2);
  put(descriptor.field_indeces_by_number, uint32(3), 3);
  put(descriptor.field_indeces_by_number, uint32(4), 4);
  put(descriptor.field_indeces_by_number, uint32(5), 5);
  put(descriptor.field_indeces_by_number, uint32(6), 6);
  put(descriptor.field_indeces_by_number, uint32(7), 7);
  put(descriptor.field_indeces_by_number, uint32(8), 8);
  put(descriptor.field_indeces_by_number, uint32(9), 9);
  put(descriptor.field_indeces_by_number, uint32(10), 10);
  put(descriptor.field_indeces_by_number, uint32(11), 11);
  

function [descriptor] = pb_descriptor_Parameter()
%pb_descriptor_Parameter Returns the descriptor for message Parameter.
%   function [descriptor] = pb_descriptor_Parameter()
%
%   See also pb_read_Parameter
  
  descriptor = struct( ...
    'name', 'Parameter', ...
    'full_name', 'Parameter', ...
    'filename', 'spearmint.proto', ...
    'containing_type', '', ...
    'fields', [ ...
      struct( ...
        'name', 'name', ...
        'full_name', 'Parameter.name', ...
        'index', 1, ...
        'number', uint32(1), ...
        'type', uint32(9), ...
        'matlab_type', uint32(7), ...
        'wire_type', uint32(2), ...
        'label', uint32(2), ...
        'default_value', '', ...
        'read_function', @(x) char(x{1}(x{2} : x{3})), ...
        'write_function', @uint8, ...
        'options', struct('packed', false) ...
      ), ...
      struct( ...
        'name', 'int_val', ...
        'full_name', 'Parameter.int_val', ...
        'index', 2, ...
        'number', uint32(2), ...
        'type', uint32(3), ...
        'matlab_type', uint32(2), ...
        'wire_type', uint32(0), ...
        'label', uint32(3), ...
        'default_value', int64([]), ...
        'read_function', @(x) typecast(x, 'int64'), ...
        'write_function', @(x) typecast(int64(x), 'uint64'), ...
        'options', struct('packed', false) ...
      ), ...
      struct( ...
        'name', 'str_val', ...
        'full_name', 'Parameter.str_val', ...
        'index', 3, ...
        'number', uint32(3), ...
        'type', uint32(9), ...
        'matlab_type', uint32(7), ...
        'wire_type', uint32(2), ...
        'label', uint32(3), ...
        'default_value', char([]), ...
        'read_function', @(x) char(x{1}(x{2} : x{3})), ...
        'write_function', @uint8, ...
        'options', struct('packed', false) ...
      ), ...
      struct( ...
        'name', 'dbl_val', ...
        'full_name', 'Parameter.dbl_val', ...
        'index', 4, ...
        'number', uint32(4), ...
        'type', uint32(1), ...
        'matlab_type', uint32(5), ...
        'wire_type', uint32(1), ...
        'label', uint32(3), ...
        'default_value', double([]), ...
        'read_function', @(x) typecast(x, 'double'), ...
        'write_function', @(x) typecast(double(x), 'uint8'), ...
        'options', struct('packed', false) ...
      ) ...
    ], ...
    'extensions', [ ... % Not Implemented
    ], ...
    'nested_types', [ ... % Not implemented
    ], ...
    'enum_types', [ ... % Not Implemented
    ], ...
    'options', [ ... % Not Implemented
    ] ...
  );
  
  descriptor.field_indeces_by_number = java.util.HashMap;
  put(descriptor.field_indeces_by_number, uint32(1), 1);
  put(descriptor.field_indeces_by_number, uint32(2), 2);
  put(descriptor.field_indeces_by_number, uint32(3), 3);
  put(descriptor.field_indeces_by_number, uint32(4), 4);
  

Spearmint
---------

Spearmint is a package to perform Bayesian optimization according to the
algorithms outlined in the paper:  

**Practical Bayesian Optimization of Machine Learning Algorithms**  
Jasper Snoek, Hugo Larochelle and Ryan P. Adams  
*Advances in Neural Information Processing Systems*, 2012  

This code is designed to automatically run experiments (thus the code
name 'spearmint') in a manner that iteratively adjusts a number of
parameters so as to minimize some objective in as few runs as
possible.

Dependencies
------------
This package requires:

* Python 2.7

* [Numpy](http://www.numpy.org/) version 1.6.1+
On Ubuntu linux you can install this package using the command:

		apt-get install python-numpy

* [Scipy](http://www.scipy.org/) version 0.9.0+
On Ubuntu linux you can install this package using the command:

		apt-get install python-scipy

* [Google Protocol Buffers](https://developers.google.com/protocol-buffers/) (for the fully automated code).
Note that you should be able to install protocol-buffers from source without requiring administrator privileges.  Otherwise, on Ubuntu linux you can install this package using the command:

		apt-get install python-protobuf
						
	and on Mac with:

		pip install protobuf

This package has been tested on Ubuntu linux (versions 11.0+) and
Mac-OSX.

The code consists of several parts.  It is designed to be modular to
allow swapping out various 'driver' and 'chooser' modules.  The
'chooser' modules are implementations of acquisition functions such as
expected improvement, UCB or random.  The drivers determine how
experiments are distributed and run on the system.  As the code is
designed to run experiments in parallel (spawning a new experiment as
soon a result comes in), this requires some engineering.  The current
implementations of these are in the 'spearmint' and 'spearmint-lite' subdirectories:

**Spearmint** is designed to automatically manage the launching and associated bookkeeping 
of experiments in either a single machine or cluster environment.  This requires that you provide
a 'wrapper' in a supported language (currently Python or Matlab) and a configuration file detailing parameters
to be tuned and their respective bounds. The wrapper must accept parameter values and then return simply a value which you wish to minimize with respect to the parameters. Spearmint will then iteratively call the wrapper with different 
parameter settings in an order that seeks to find the minimum value in as few evaluations (or cost) as possible.

**Spearmint-lite** is the 'bare-bones' stripped version of the code.
This version is simply driven by a flat-file and does not
automatically run experiments.  Instead, it proposes new experiments
(potentially multiple at a time) and requires that the user fill in
the result.  This is well suited to the case where writing a wrapper
around the code doesn't make sense (e.g. if the experiments don't
involve code at all) or if the user desires full control of the
process.  Also, the dependency on Google protocol buffers is replaced
with JSON.

Running the automated code: Spearmint
--------------------------------------------------------

The simplest way to get to know the code is probably to look at an
example.  In order to start a new experiment, you must create a directory 
that includes a wrapper script and config file.
We have created one simple example for you that optimizes the
'Braninhoo' benchmark in the subdirectory **examples/braninpy**.  Take a look at
**config.pb**.  It contains the specifications of the algorithm in
protocol buffer format.  In order to specify your optimization, you
have to fill in the variables 'language' (e.g. PYTHON or MATLAB) and
'name' (the name of the wrapper function you want to optimize).

Followed by these is a list of 'variables', which specifies the name,
type and size of the variables you wish to optimize over.  Each
variable must be either a FLOAT, INT or ENUM type, corresponding to
continuous real valued parameters, integer sequences and categorical
variables respectively.  MAX and MIN specify the bounds of the
variables over which to optimize and SIZE is the number of variables
of this type with these bounds.  Spearmint will call your wrapper
function with a dictionary type (in python) containing each of your
variables in a vector of size 'size', which you can access using the
name specified.  

Now take a look at branin.py (the wrapper which was
specified in the 'name' variable at the top of config.pb).  You will
see the file has a function 'main(job_id, params)'.  Your wrapper must
include this function, which spearmint will call passing in a job_id
(which is probably not interesting to you) and a dictionary, 'params',
containing the parameter vectors of the next experiment spearmint
wants to run.  The main function should take as input these parameters
and return a single real valued number representing the observed
function value (that is being optimized) at these inputs.

To install spearmint, go into the spearmint subdirectory and type (most likely preceded with 'sudo'):

	python setup.py install

You should add the spearmint subdirectory to your PYTHONPATH directory.  Note that you can often avoid the above step, but may have to add all the relevant modules to your PYTHONPATH and call spearmint directory from the directory using main.py.

To run spearmint, go into the **/bin** subdirectory and type:

	./spearmint ../examples/braninpy/config.pb --driver=local --method=GPEIOptChooser --method-args=noiseless=1

or alternatively in the **/spearmint** subdirectory:

	python main.py --driver=local --method=GPEIOptChooser --method-args=noiseless=1 ../examples/braninpy/config.pb

This will run spearmint according to the GP-EI MCMC strategy.  The code will sequentially spawn
processes that call the wrapper function and it will poll for results.
You will see that the code prints out the current best (i.e. lowest)
observation seen thus far and sequences of numbers corresponding to GP
hyperparameter samples and candidates it is optimizing over.  The
'method' argument specifies the chooser module (acquisition function)
to use and 'method-args' specifies chooser specific arguments.  In
this case, as braninhoo is an analytic function we tell the GP
hyperparameter sampling routine to not try to estimate noise.  This parameter is very important to specify correctly for the optimization to proceed properly.  If your algorithm is entirely deterministic (e.g. analytic) then specifying that it is noiseless will speed up the optimization considerably.  If your algorithm is not deterministic, as we expect for most machine learning algorithms and indeed most expensive experiments, then you should leave this out or set noiseless=0.

If you let it run for a while you will see that the current-best
decreases, eventually reaching the minimum at ~0.39. You can kill the
process (ctrl-c) at any time and you can restart from where it left off simply
by rerunning the spearmint command.

If you go back in to the braninpy directory you will see a number of
new files that spearmint uses to do bookkeeping.  Of particular
interest are **trace.csv** and the **output** directory.  **trace.csv**
contains a record of the experiments run so far and the best result
(and which experiment it came from) as a series over time.  Each line
of trace.csv contains the following in csv format: a timestamp, the
best value observed up to that timestamp, the job-id of the best value
observed, the number of potential candidates left, the number of
pending (currently running) experiments, the number of experiments
completed thus far.  The output directory contains a text file for
each job-id, containing the output of that job.  So if you want to
see, e.g. what the output (i.e. standard out and standard error) was
for the best job (as obtained from trace.csv) you can look up
job-id.txt in the output directory. 

 If you are debugging your code,
or the code is crashing for some reason, it's a good idea to look at
these files. Finally for ease of use, spearmint also prints out at
each iteration a file called 'best_job_and_result.txt' that contains the
best result observed so far, the job-id it came from and a dump of 
the names and values of all of the parameters corresponding to that result.

A script, bin/cleanup, is provided to completely restart an experiment
and delete all the results and intermediate files.  Simply run
`bin/cleanup <experiment_dir>`

Matlab code can also be optimized using this package. To do so, you
must specify in config.pb "type: Matlab" and use a matlab wrapper with
the "name" specified in config.pb.  The matlab wrapper must have a
function with the same name as the file name of the following form:
"function result = braninhoo(job_id, params)" Above we assume the file
name is "braninhoo.m".  Spearmint will pass in to this wrapper a
job_id and a matlab struct 'params' where the fields are given by the
variables specified in config.pb.  See the subdirectory "braninhoo"
for a matlab example matching that of python 'braninpy' described
above.

To run multiple jobs in parallel, pass to spearmint the argument:
`--max-concurrent=<#jobs>`

Spearmint is designed to be run in parallel either using multiple processors on a single machine or in a cluster environment.  These different environments, however, involve different queuing and fault-checking code and are thus coded as 'driver' modules.  Currently two drivers are available, but one can easily create a driver for a different environment by creating a new driver module (see the driver subdirectory for examples).

Using the `--driver=sge` flag, Spearmint can run on a system with Sun Grid Engine and it uses SGE to distribute experiments on a multi-node cluster in parallel using a queueing system in a fault-tolerant way.  It is particularly
well suited to the Amazon EC2 system.  Using [StarCluster](http://star.mit.edu/cluster/) will allow you to set up a large cluster and start distributing experiments within minutes.

Using the `--driver=local` flag will run Spearmint on a single machine with potentially many cores.  This driver simply spawns a new process on the current machine to run a new experiment.  This does not allow you to distribute across multiple machines, however.

Running the basic code: Spearmint-lite 
---------------------------------------

Spearmint-lite is designed to be simple.  To run an experiment in
spearmint-lite, create a subdirectory as explained above.  Again, the
braninpy directory is provided as a demonstration.  In this case, the
experiment specification, which must be provided in config.json, is in
JSON format.  You must specify your problem as a sequence of JSON
objects.  As in the protocol buffer format above, each object must
have a name, a type (float, int or enum), a 'min', a 'max' and a
'size'. Nothing else needs to be specified.  

Go back to the top-level directory and run: 

	python spearmint-lite.py braninpy

Spearmint-lite will run one iteration of Bayesian
optimization and write out to a file named results.dat in the braninpy
subdirectory.  results.dat will contain a white-space delimited line
for each experiment, of the format: 
`<result> <time-taken> <list of parameters in the same order as config.json>`

Spearmint will propose new experiments and append them to results.dat each 
time it is run. Each proposed experiment will have a 'pending' result and 
time-taken, indicated by the letter P. The user must then run the experiment 
and fill in these values. Note that the time can safely be set to an arbitrary
value if the chooser module does not use it (only GPEIperSecChooser currently 
does). Spearmint will condition on the pending experiments when proposing new 
ones, so any number of experiments can be conducted in parallel.

A script, **cleanup.sh**, is provided to completely clean up all the intermediate
files and results in an experimental directory and restart the
experiment from scratch.

Chooser modules:
--------------- 

The chooser modules implement functions that tell spearmint which next
job to run.  Some correspond to 'acquisition functions' in the
Bayesian optimization literature.  Spearmint takes as an argument
`--method=ChooserModule` which allows one to easy swap out acquisition
functions. Choosers may optionally include parameters that can be
passed to spearmint using the argument
`--method-args=argument1,argument2,etc`.  These include, for example, the
number of GP hyperparameter samples to use. See the comments in
chooser files for chooser dependent arguments.  Below are described
the choosers provided in this package:

* **SequentialChooser:** Chooses the next experiment using a high
discrepancy Sobol sequence.  Experiments are taken sequentially from a
coarse-to-fine grid.

* **RandomChooser**: Experiments are sampled randomly from the unit hypercube.

* **GPEIOptChooser:** The GP EI MCMC algorithm from the paper. Jobs 
are first sampled densely from a dense grid on the unit hypercube
and then the best candidates are optimized 'fine-tuned' according
to EI.

* **GPEIperSecChooser:** The GP EI per Second algorithm from the paper.
Similar to GPEIOptChooser except points are optimized and evaluated
based on the EI per Second criterion, where each job is weighted
by the expected running time of the experiment.

* **GPEIChooser:** Points are densely sampled on the unit hypercube and the
best is returned according to the EI criterion.  This is considerably
faster than the GPEIOptChooser and works well in low-dimensional cases
where the grid covers the search space densely.

**IMPORTANT!**

When estimating noise, the Gaussian process prior over noise assumes
that the noise level is 'low' (e.g. between -1 to 1). If this is not
the case, make sure to rescale your function to make this true
(e.g. to approximately be between -1 and 1).  Otherwise, the algorithm
will find a bad high-noise mode that will result in bad performance.

