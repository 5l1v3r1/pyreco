__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Toto documentation build configuration file, created by
# sphinx-quickstart on Thu Oct 18 20:26:32 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Toto'
copyright = u'2013, Jeremy Olmsted-Thompson'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.12.5'
# The full version, including alpha/beta/rc tags.
release = '0.12.5'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'haiku'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Totodoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Toto.tex', u'Toto Documentation',
   u'Jeremy Olmsted-Thompson', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'toto', u'Toto Documentation',
     [u'Jeremy Olmsted-Thompson'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'Toto', u'Toto Documentation',
   u'Jeremy Olmsted-Thompson', 'Toto', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = post_message
import toto
from toto.invocation import *
from toto.events import EventManager

@requires("message")
def invoke(handler, params):
  EventManager.instance().send("message", params["message"])
  return "message sent!"

########NEW FILE########
__FILENAME__ = receive_message
import toto
from toto.invocation import *
from tornado.ioloop import IOLoop

@asynchronous
def invoke(handler, params):
  def receive_message(message):
    handler.respond(result={'message': message})
  handler.register_event_handler('message', receive_message, deregister_on_finish=True)

########NEW FILE########
__FILENAME__ = eventserver
#!/usr/bin/env python

import toto.server

if __name__ == "__main__":
  toto.server.TotoServer('event.conf').run()

########NEW FILE########
__FILENAME__ = receive_chat
#!/usr/bin/env python

import urllib2
import json
import multiprocessing

def listen(port):
  print "Listening on %d" % port
  print urllib2.urlopen(urllib2.Request('http://localhost:%d' % port, json.dumps({'method': 'receive_message', 'parameters': {}}), {'content-type': 'application/json'})).read()
  print "Received from %d" % port

def listen_url(port):
  print "Listening on %d" % port
  print urllib2.urlopen(urllib2.Request('http://localhost:%d/receive_message' % port, headers={'content-type': 'application/json'})).read()
  print "Received from %d" % port

p1 = multiprocessing.Process(target=listen, args=(8888,))
p2 = multiprocessing.Process(target=listen, args=(8889,))
p3 = multiprocessing.Process(target=listen_url, args=(8888,))
p4 = multiprocessing.Process(target=listen_url, args=(8889,))
p1.start()
p2.start()
p3.start()
p4.start()
p1.join()
p2.join()
p3.join()
p4.join()

########NEW FILE########
__FILENAME__ = send_chat
#!/usr/bin/env python

import urllib2
import json

print urllib2.urlopen(urllib2.Request('http://localhost:8888', json.dumps({'method': 'post_message', 'parameters': {'message': 'test message, welcome to Toto'}}), {'content-type': 'application/json'})).read()

########NEW FILE########
__FILENAME__ = totoserver
#!/usr/bin/env python

import toto.server

if __name__ == "__main__":
  toto.server.TotoServer('toto.conf').run()

########NEW FILE########
__FILENAME__ = increment
from toto.invocation import *

@authenticated
def invoke(handler, params):
  handler.session['counter'] = (handler.session['counter'] or 0) + 1
  handler.session.save()
  return {'count': handler.session['counter']}

########NEW FILE########
__FILENAME__ = benchmark
#!/usr/bin/env python

from create import create_account
from request import toto_request
from uuid import uuid4
from time import time

def checkresponse(response):
  if 'error' in response:
    print response['error']
    exit()
  return response

def verify_count(response, n):
  response = checkresponse(response)
  if n != response['result']['count']:
    print 'Counter not incrementing, expected %s got %s' % (n, response['result']['count'])
    print response
    exit()
  return response


count = int(raw_input('How many requests? (default 1000)') or 1000)
user_id = uuid4().hex
password = uuid4().hex
print "user_id: %s password: %s" % (user_id, password)
print checkresponse(create_account(user_id, password))
session = {}
execfile('session.conf', session, session)
start = time()
for i in xrange(1, count + 1):
  verify_count(toto_request('increment', session=session), i)
total = time() - start
print 'Ran %s successful requests in %s seconds' % (count, total)

########NEW FILE########
__FILENAME__ = create
#!/usr/bin/python

from sys import stdin
from request import toto_request

def create_account(user_id, password):
  response = toto_request('account.create', {'user_id': user_id, 'password': password})
  if 'result' in response:
    with open('session.conf', 'wb') as session_file:
      session_file.write("session_id='%s'\n" % response['result']['session_id'])
      session_file.write("user_id='%s'\n" % response['result']['user_id'])
  return response

if __name__ == '__main__':
  print "Enter your username"
  user_id = stdin.readline().strip()
  print "Enter your password"
  password = stdin.readline().strip()
  print create_account(user_id, password)

########NEW FILE########
__FILENAME__ = increment
#!/usr/bin/python

from request import toto_request

session = {}
execfile('session.conf', session, session)

print toto_request('increment', session=session)

########NEW FILE########
__FILENAME__ = login
#!/usr/bin/python

from request import toto_request
from sys import stdin

def login(user_id, password):
  response = toto_request('account.login', {'user_id': user_id, 'password': password})
  if 'result' in response:
    with open('session.conf', 'wb') as session_file:
      session_file.write("session_id='%s'\n" % response['result']['session_id'])
      session_file.write("user_id='%s'\n" % response['result']['user_id'])
  return response

if __name__ == '__main__':
  print "Enter your username"
  user_id = stdin.readline().strip()
  print "Enter your password"
  password = stdin.readline().strip()
  print login(user_id, password)

########NEW FILE########
__FILENAME__ = request
import urllib2
import json
import hmac
import hashlib
import time
import base64
from sys import stdin

def toto_request(method, params={}, session={}):
  request = {}
  request['method'] = method
  request['parameters'] = params
  headers = {'content-type': 'application/json'}
  body = json.dumps(request)
  if session.get('session_id'):
    headers['x-toto-session-id'] = session['session_id']
    headers['x-toto-hmac'] = base64.b64encode(hmac.new(session['user_id'], body, hashlib.sha1).digest())
  req = urllib2.Request('http://localhost:8888/', body, headers)
  f = urllib2.urlopen(req)
  return json.loads(f.read())


########NEW FILE########
__FILENAME__ = test_server
#!/usr/bin/env python

from create import create_account
from login import login
from request import toto_request
from uuid import uuid4

def checkresponse(response):
  if 'error' in response:
    print response['error']
    exit()
  return response

def verify_count(response, n):
  response = checkresponse(response)
  if n != response['result']['count']:
    print 'Counter not incrementing, expected %s got %s' % (n, response['result']['count'])
    print response
    exit()
  return response

user_id = uuid4().hex
password = uuid4().hex
print "user_id: %s password: %s" % (user_id, password)

print checkresponse(create_account(user_id, password))
session = {}
execfile('session.conf', session, session)
print verify_count(toto_request('increment', session=session), 1)
print verify_count(toto_request('increment', session=session), 2)
print verify_count(toto_request('increment', session=session), 3)
're-authenticate'
print checkresponse(login(user_id, password))
session = {}
execfile('session.conf', session, session)
print verify_count(toto_request('increment', session=session), 1)
print verify_count(toto_request('increment', session=session), 2)
print verify_count(toto_request('increment', session=session), 3)
print 'new user'
user_id = uuid4().hex
password = uuid4().hex
print "user_id: %s password: %s" % (user_id, password)
print checkresponse(create_account(user_id, password))
session = {}
execfile('session.conf', session, session)
print verify_count(toto_request('increment', session=session), 1)
print verify_count(toto_request('increment', session=session), 2)
print verify_count(toto_request('increment', session=session), 3)
're-authenticate'
print checkresponse(login(user_id, password))
session = {}
execfile('session.conf', session, session)
print verify_count(toto_request('increment', session=session), 1)
print verify_count(toto_request('increment', session=session), 2)
print verify_count(toto_request('increment', session=session), 3)
print 'Session storage ok'

########NEW FILE########
__FILENAME__ = totoserver
#!/usr/bin/env python

import toto.server

if __name__ == "__main__":
  toto.server.TotoServer('toto.conf').run()

########NEW FILE########
__FILENAME__ = benchmark_server
import unittest
import urllib2
import json
import os
import signal
from uuid import uuid4
from toto.secret import *
from multiprocessing import Process, active_children
from toto.server import TotoServer
from time import sleep, time

def run_server(processes=1):
  TotoServer(method_module='web_methods', port=9000, processes=processes).run()

class TestWeb(unittest.TestCase):
  
  @classmethod
  def setUpClass(cls):
    print 'Starting server'
    cls.service_process = Process(target=run_server, args=[1])
    cls.service_process.start()
    sleep(0.5)
  
  @classmethod
  def tearDownClass(cls):
    print 'Stopping server'
    processes = [int(l.split()[0]) for l in os.popen('ps').readlines() if 'python' in l and 'unittest' in l]
    for p in processes:
      if p == os.getpid():
        continue
      print 'killing', p
      os.kill(p, signal.SIGKILL)
    sleep(0.5)
  
  def test_method(self):
    request = {}
    request['method'] = 'test.ok'
    request['parameters'] = {'arg1': 1, 'arg2': 'hello'}
    headers = {'content-type': 'application/json'}
    req = urllib2.Request('http://127.0.0.1:9000/', json.dumps(request), headers)
    start = time()
    for i in xrange(1000):
      f = urllib2.urlopen(req)
    total = time() - start
    print '1000 requests in %s seconds\nAverage time %s ms (%s requests/second)' % (total, total/1000.0*1000.0, 1000.0/total)


########NEW FILE########
__FILENAME__ = test_secret
import unittest

from uuid import uuid4
from toto.secret import *

class TestSecret(unittest.TestCase):

  def test_password_hash(self):
    pw = uuid4().hex
    self.assertTrue(pw != password_hash(pw))
    self.assertTrue(password_hash(pw) != password_hash(pw + uuid4().hex))
    self.assertTrue(password_hash(pw) != password_hash(uuid4().hex))
    self.assertTrue(password_hash(pw) != password_hash(pw)) #check salt
  
  def test_verify_password(self):
    pw = uuid4().hex
    pw_hash = password_hash(pw)
    self.assertTrue(not verify_password('', pw_hash))
    self.assertTrue(not verify_password(pw + uuid4().hex, pw_hash))
    self.assertTrue(not verify_password(uuid4().hex, pw_hash))
    self.assertTrue(verify_password(pw, pw_hash))

########NEW FILE########
__FILENAME__ = test_server
import unittest
import urllib2
import json
import os
import signal
from uuid import uuid4
from toto.secret import *
from multiprocessing import Process, active_children
from toto.server import TotoServer
from time import sleep, time

def run_server(processes=1, daemon='start'):
  TotoServer(method_module='web_methods', port=9000, debug=True, processes=processes, daemon=daemon, pidfile='server.pid').run()

class TestWeb(unittest.TestCase):
  
  @classmethod
  def setUpClass(cls):
    print 'Starting server'
    Process(target=run_server, args=[int(os.environ.get('NUM_PROCS', -1))]).start()
    sleep(0.5)
  
  @classmethod
  def tearDownClass(cls):
    print 'Stopping server'
    Process(target=run_server, args=[int(os.environ.get('NUM_PROCS', -1)), 'stop']).start()
  
  def test_method(self):
    request = {}
    request['method'] = 'return_value'
    request['parameters'] = {'arg1': 1, 'arg2': 'hello'}
    headers = {'content-type': 'application/json'}
    req = urllib2.Request('http://127.0.0.1:9000/', json.dumps(request), headers)
    f = urllib2.urlopen(req)
    response = json.loads(f.read())['result']
    self.assertEqual(request['parameters'], response['parameters'])
  
  def test_method_async(self):
    request = {}
    request['method'] = 'return_value_async'
    request['parameters'] = {'arg1': 1, 'arg2': 'hello'}
    headers = {'content-type': 'application/json'}
    req = urllib2.Request('http://127.0.0.1:9000/', json.dumps(request), headers)
    f = urllib2.urlopen(req)
    response = json.loads(f.read())['result']
    self.assertEqual(request['parameters'], response['parameters'])
  
  def test_method_coroutine(self):
    request = {}
    request['method'] = 'return_value_coroutine'
    request['parameters'] = {'arg1': 1, 'arg2': 'hello'}
    headers = {'content-type': 'application/json'}
    req = urllib2.Request('http://127.0.0.1:9000/', json.dumps(request), headers)
    f = urllib2.urlopen(req)
    response = json.loads(f.read())['result']
    self.assertEqual(request['parameters'], response['parameters'])
  
  def test_method_task(self):
    request = {}
    request['method'] = 'return_value_task'
    request['parameters'] = {'arg1': 1, 'arg2': 'hello'}
    headers = {'content-type': 'application/json'}
    req = urllib2.Request('http://127.0.0.1:9000/', json.dumps(request), headers)
    f = urllib2.urlopen(req)
    response = json.loads(f.read())['result']
    self.assertEqual(request['parameters'], response['parameters'])
  
  def test_method_task_coroutine(self):
    request = {}
    request['method'] = 'return_value_task_coroutine'
    request['parameters'] = {'arg1': 1, 'arg2': 'hello'}
    headers = {'content-type': 'application/json'}
    req = urllib2.Request('http://127.0.0.1:9000/', json.dumps(request), headers)
    f = urllib2.urlopen(req)
    response = json.loads(f.read())['result']
    self.assertEqual(request['parameters'], response['parameters'])
  
  def test_no_method(self):
    request = {}
    request['parameters'] = {'arg1': 1, 'arg2': 'hello'}
    headers = {'content-type': 'application/json'}
    req = urllib2.Request('http://127.0.0.1:9000/', json.dumps(request), headers)
    f = urllib2.urlopen(req)
    response = json.loads(f.read())
    self.assertEqual({'error': {'code': 1002, 'value': 'Missing method.'}}, response)
  
  def test_bad_method(self):
    request = {}
    request['method'] = 'bad_method.test'
    request['parameters'] = {'arg1': 1, 'arg2': 'hello'}
    headers = {'content-type': 'application/json'}
    req = urllib2.Request('http://127.0.0.1:9000/', json.dumps(request), headers)
    f = urllib2.urlopen(req)
    response = json.loads(f.read())
    self.assertEqual({'error': {'code': 1001, 'value': "Cannot call 'bad_method.test'."}}, response)
  
  def test_method_form_post(self):
    request = {}
    headers = {'content-type': 'application/x-www-form-urlencoded'}
    req = urllib2.Request('http://127.0.0.1:9000/return_value', 'arg1=1&arg2=hello', headers)
    f = urllib2.urlopen(req)
    response = json.loads(f.read())['result']
    self.assertEqual(response['parameters']['arg1'][0], '1')
    self.assertEqual(response['parameters']['arg2'][0], 'hello')
  
  def test_method_no_params(self):
    request = {}
    request['method'] = 'return_value'
    headers = {'content-type': 'application/json'}
    req = urllib2.Request('http://127.0.0.1:9000/', json.dumps(request), headers)
    f = urllib2.urlopen(req)
    response = json.loads(f.read())['result']
    self.assertFalse(response['parameters'])

  def test_url_method(self):
    request = {}
    request['parameters'] = {'arg1': 1, 'arg2': 'hello'}
    headers = {'content-type': 'application/json'}
    req = urllib2.Request('http://127.0.0.1:9000/return_value', json.dumps(request), headers)
    f = urllib2.urlopen(req)
    response = json.loads(f.read())['result']
    self.assertEqual(request['parameters'], response['parameters'])

  def test_get_method(self):
    request = {}
    request['parameters'] = {'arg1': '1', 'arg2': 'hello'}
    req = urllib2.Request('http://127.0.0.1:9000/return_value?arg1=1&arg2=hello')
    f = urllib2.urlopen(req)
    response = json.loads(f.read())['result']
    self.assertEqual(request['parameters'], response['parameters'])

  def test_batch_method(self):
    batch = {}
    headers = {'content-type': 'application/json'}
    for i in xrange(3):
      rid = uuid4().hex
      request = {}
      request['method'] = 'return_value'
      request['parameters'] = {'arg1': 1, 'arg2': rid}
      batch[rid] = request
    req = urllib2.Request('http://127.0.0.1:9000/', json.dumps({'batch': batch}), headers)
    f = urllib2.urlopen(req)
    batch_response = json.loads(f.read())['batch']
    for rid, response in batch_response.iteritems():
      request['parameters']['arg2'] = rid
      self.assertEqual(request['parameters'], response['result']['parameters'])

  def test_batch_method_async(self):
    batch = {}
    headers = {'content-type': 'application/json'}
    for i in xrange(3):
      rid = uuid4().hex
      request = {}
      request['method'] = 'return_value_async'
      request['parameters'] = {'arg1': 1, 'arg2': rid}
      batch[rid] = request
    req = urllib2.Request('http://127.0.0.1:9000/', json.dumps({'batch': batch}), headers)
    f = urllib2.urlopen(req)
    batch_response = json.loads(f.read())['batch']
    for rid, response in batch_response.iteritems():
      request['parameters']['arg2'] = rid
      self.assertEqual(request['parameters'], response['result']['parameters'])

  def test_batch_method_task(self):
    batch = {}
    headers = {'content-type': 'application/json'}
    for i in xrange(3):
      rid = uuid4().hex
      request = {}
      request['method'] = 'return_value_task'
      request['parameters'] = {'arg1': 1, 'arg2': rid}
      batch[rid] = request
    req = urllib2.Request('http://127.0.0.1:9000/', json.dumps({'batch': batch}), headers)
    f = urllib2.urlopen(req)
    batch_response = json.loads(f.read())['batch']
    for rid, response in batch_response.iteritems():
      request['parameters']['arg2'] = rid
      self.assertEqual(request['parameters'], response['result']['parameters'])
    
  def test_get_method(self):
    request = {}
    request['parameters'] = {'arg1': '1', 'arg2': 'hello'}
    req = urllib2.Request('http://127.0.0.1:9000/return_value?arg1=1&arg2=hello')
    f = urllib2.urlopen(req)
    response = json.loads(f.read())['result']
    self.assertEqual(request['parameters'], response['parameters'])
  
  def test_exception(self):
    request = {}
    request['method'] = 'throw_exception'
    request['parameters'] = {'arg1': 1, 'arg2': 'hello'}
    headers = {'content-type': 'application/json'}
    req = urllib2.Request('http://127.0.0.1:9000/', json.dumps(request), headers)
    f = urllib2.urlopen(req)
    response = json.loads(f.read())
    self.assertEqual({'error': {'code': 1000, 'value': "Test Exception"}}, response)
  
  def test_toto_exception(self):
    request = {}
    request['method'] = 'throw_toto_exception'
    request['parameters'] = {'arg1': 1, 'arg2': 'hello'}
    headers = {'content-type': 'application/json'}
    req = urllib2.Request('http://127.0.0.1:9000/', json.dumps(request), headers)
    f = urllib2.urlopen(req)
    response = json.loads(f.read())
    self.assertEqual({'error': {'code': 4242, 'value': "Test Toto Exception"}}, response)

  def test_toto_exception_async_coroutine(self):
    request = {}
    request['method'] = 'throw_toto_exception_async_coroutine'
    request['parameters'] = {'arg1': 1, 'arg2': 'hello'}
    headers = {'content-type': 'application/json'}
    req = urllib2.Request('http://127.0.0.1:9000/', json.dumps(request), headers)
    f = urllib2.urlopen(req)
    response = json.loads(f.read())
    self.assertEqual({'error': {'code': 4242, 'value': "Test Toto Exception"}}, response)

  def test_toto_exception_task_coroutine(self):
    request = {}
    request['method'] = 'throw_toto_exception_task_coroutine'
    request['parameters'] = {'arg1': 1, 'arg2': 'hello'}
    headers = {'content-type': 'application/json'}
    req = urllib2.Request('http://127.0.0.1:9000/', json.dumps(request), headers)
    f = urllib2.urlopen(req)
    response = json.loads(f.read())
    self.assertEqual({'error': {'code': 4242, 'value': "Test Toto Exception"}}, response)
  
  def test_exception_async_coroutine(self):
    request = {}
    request['method'] = 'throw_exception_async_coroutine'
    request['parameters'] = {'arg1': 1, 'arg2': 'hello'}
    headers = {'content-type': 'application/json'}
    req = urllib2.Request('http://127.0.0.1:9000/', json.dumps(request), headers)
    f = urllib2.urlopen(req)
    response = json.loads(f.read())
    self.assertEqual({'error': {'code': 1000, 'value': "Test Exception"}}, response)
  
  def test_exception_task_coroutine(self):
    request = {}
    request['method'] = 'throw_exception_task_coroutine'
    request['parameters'] = {'arg1': 1, 'arg2': 'hello'}
    headers = {'content-type': 'application/json'}
    req = urllib2.Request('http://127.0.0.1:9000/', json.dumps(request), headers)
    f = urllib2.urlopen(req)
    response = json.loads(f.read())
    self.assertEqual({'error': {'code': 1000, 'value': "Test Exception"}}, response)




########NEW FILE########
__FILENAME__ = test_session
import unittest
import urllib2
import urllib
import urlparse
import json
import os
import signal
import cPickle as pickle
from uuid import uuid4
from toto.secret import *
from multiprocessing import Process, active_children
from toto.session import TotoSession, SESSION_ID_LENGTH
from time import sleep, time

class TestSession(unittest.TestCase):

  def test_generate_id(self):
    session_id = TotoSession.generate_id()
    self.assertEqual(len(session_id), SESSION_ID_LENGTH)
    url_safe = urllib.quote_plus(session_id)
    self.assertEqual(session_id, url_safe)
    
  def test_data_storage(self):
    user_id = 'test@toto.li'
    expires = time() + 1000.0
    session_id = TotoSession.generate_id()
    session_data = {'session_id': session_id, 'expires': expires, 'user_id': user_id}
    session = TotoSession(None, session_data)
    self.assertEqual(session.session_id, session_id)
    self.assertEqual(session.user_id, user_id)
    self.assertEqual(session.expires, expires)
    session['int'] = 1268935
    session['float'] = 92385.03
    session['str'] = 'some test'
    self.assertEqual(session['int'], 1268935)
    self.assertEqual(session['float'], 92385.03)
    self.assertEqual(session['str'], 'some test')
    
  def test_clone(self):
    user_id = 'test@toto.li'
    expires = time() + 1000.0
    session_id = TotoSession.generate_id()
    session_data = {'session_id': session_id, 'expires': expires, 'user_id': user_id}
    session = TotoSession(None, session_data)
    session['int'] = 1268935
    session['float'] = 92385.03
    session['str'] = 'some test'
    new_session = TotoSession(None, session.session_data())
    self.assertEqual(new_session.session_id, session_id)
    self.assertEqual(new_session.user_id, user_id)
    self.assertEqual(new_session.expires, expires)
    self.assertEqual(new_session['int'], 1268935)
    self.assertEqual(new_session['float'], 92385.03)
    self.assertEqual(new_session['str'], 'some test')
    
  def test_serialization(self):
    user_id = 'test@toto.li'
    expires = time() + 1000.0
    session_id = TotoSession.generate_id()
    session_data = {'session_id': session_id, 'expires': expires, 'user_id': user_id}
    session = TotoSession(None, session_data)
    session['int'] = 1268935
    session['float'] = 92385.03
    session['str'] = 'some test'
    data = TotoSession.dumps(session.session_data())
    new_session = TotoSession(None, TotoSession.loads(data))
    self.assertEqual(new_session.session_id, session_id)
    self.assertEqual(new_session.user_id, user_id)
    self.assertEqual(new_session.expires, expires)
    self.assertEqual(new_session['int'], 1268935)
    self.assertEqual(new_session['float'], 92385.03)
    self.assertEqual(new_session['str'], 'some test')

  def test_set_serializer(self):
    session = {'session_id': TotoSession.generate_id(), 'expires': time() + 1000.0, 'user_id': 'test@toto.li'}
    TotoSession.set_serializer(pickle)
    pickle_serialized = TotoSession.dumps(session)
    self.assertTrue(isinstance(pickle_serialized, str))
    TotoSession.set_serializer(json)
    json_serialized = TotoSession.dumps(session)
    self.assertTrue(isinstance(json_serialized, str))
    self.assertNotEqual(pickle_serialized, json_serialized)
    TotoSession.set_serializer(pickle)
    self.assertEqual(TotoSession.loads(pickle_serialized), session)
    TotoSession.set_serializer(json)
    self.assertEqual(TotoSession.loads(json_serialized), session)


########NEW FILE########
__FILENAME__ = test_worker
import unittest
import urllib2
import json
import os
import signal
from uuid import uuid4
from toto.secret import *
from multiprocessing import Process, active_children
from toto.worker import TotoWorkerService
from toto.workerconnection import WorkerConnection
from tornado.gen import engine
from time import sleep, time

def run_server(port, daemon='start'):
  TotoWorkerService(method_module='worker_methods', worker_bind_address='tcp://*:%d' % port, worker_socket_address='ipc:///tmp/workerservice%d.sock' % port, control_socket_address='ipc:///tmp/workercontrol%d.sock', debug=True, daemon=daemon, pidfile='worker-%d.pid' % port).run()

def invoke_synchronously(worker, method, parameters, **kwargs):
  resp = []
  def cb(response):
    resp.append(response)
  worker.invoke(method, parameters, callback=cb, **kwargs)
  while not resp:
    sleep(0.1)
  return resp[0]

class TestWorker(unittest.TestCase):
  
  @classmethod
  def setUpClass(cls):
    print 'Starting worker'
    for p in [Process(target=run_server, args=[9001 + i]) for i in xrange(3)]:
      p.start()
    sleep(0.5)
    cls.worker_addresses = ['tcp://127.0.0.1:%d' % (9001 + i) for i in xrange(3)]
    cls.worker = WorkerConnection(cls.worker_addresses[0])

  @classmethod
  def tearDownClass(cls):
    print 'Stopping worker'
    for p in [Process(target=run_server, args=[9001 + i, 'stop']) for i in xrange(3)]:
      p.start()
    sleep(0.5)
  
  def test_method(self):
    resp = []
    def cb(response):
      resp.append(response)
    parameters = {'arg1': 1, 'arg2': 'hello'}
    self.worker.invoke('return_value', parameters, callback=cb)
    while not resp:
      sleep(0.1)
    self.assertEqual(parameters, resp[0]['parameters'])

  def test_method_generator(self):
    resp = []
    parameters = {'arg1': 1, 'arg2': 'hello'}
    @engine
    def run():
      resp.append((yield self.worker.invoke('return_value', parameters, await=True)))
    run()
    while not resp:
      sleep(0.1)
    self.assertEqual(parameters, resp[0]['parameters'])
  
  def test_method_alt_invocation(self):
    resp = []
    def cb(response):
      resp.append(response)
    parameters = {'arg1': 1, 'arg2': 'hello'}
    self.worker.return_value(parameters, callback=cb)
    while not resp:
      sleep(0.1)
    self.assertEqual(parameters, resp[0]['parameters'])
  
  def test_method_alt_invocation_generator(self):
    resp = []
    parameters = {'arg1': 1, 'arg2': 'hello'}
    @engine
    def run():
      resp.append((yield self.worker.return_value(parameters, await=True)))
    run()
    while not resp:
      sleep(0.1)
    self.assertEqual(parameters, resp[0]['parameters'])
  
  def test_bad_method(self):
    resp = []
    def cb(response):
      resp.append(response)
    parameters = {'arg1': 1, 'arg2': 'hello'}
    self.worker.invoke('bad_method', parameters, callback=cb)
    while not resp:
      sleep(0.1)
    self.assertEqual(resp[0]['error']['code'], 1000)
    self.assertEqual(resp[0]['error']['value'], "'module' object has no attribute 'bad_method'")

  def test_exception(self):
    resp = []
    def cb(response):
      resp.append(response)
    parameters = {'arg1': 1, 'arg2': 'hello'}
    self.worker.invoke('throw_exception', parameters, callback=cb)
    while not resp:
      sleep(0.1)
    self.assertEqual(resp[0]['error']['code'], 1000)
    self.assertEqual(resp[0]['error']['value'], "Test Exception")

  def test_exception_generator(self):
    resp = []
    parameters = {'arg1': 1, 'arg2': 'hello'}
    @engine
    def run():
      resp.append((yield self.worker.invoke('throw_exception', parameters, await=True)))
    run()
    while not resp:
      sleep(0.1)
    self.assertEqual(resp[0]['error']['code'], 1000)
    self.assertEqual(resp[0]['error']['value'], "Test Exception")

  def test_toto_exception(self):
    resp = []
    def cb(response):
      resp.append(response)
    parameters = {'arg1': 1, 'arg2': 'hello'}
    self.worker.invoke('throw_toto_exception', parameters, callback=cb)
    while not resp:
      sleep(0.1)
    self.assertEqual(resp[0]['error']['code'], 4242)
    self.assertEqual(resp[0]['error']['value'], "Test Toto Exception")

  def test_toto_exception_generator(self):
    resp = []
    @engine
    def run():
      parameters = {'arg1': 1, 'arg2': 'hello'}
      resp.append((yield self.worker.invoke('throw_toto_exception', parameters, await=True)))
    run()
    while not resp:
      sleep(0.1)
    self.assertEqual(resp[0]['error']['code'], 4242)
    self.assertEqual(resp[0]['error']['value'], "Test Toto Exception")
  
  def test_add_connection(self):
    self.worker.add_connection(self.worker_addresses[1])
    sleep(0.1)
    self.assertTrue(self.worker_addresses[0] in self.worker.active_connections)
    self.assertTrue(self.worker_addresses[1] in self.worker.active_connections)
    self.worker.add_connection(self.worker_addresses[2])
    sleep(0.1)
    self.assertTrue(self.worker_addresses[0] in self.worker.active_connections)
    self.assertTrue(self.worker_addresses[1] in self.worker.active_connections)
    self.assertTrue(self.worker_addresses[2] in self.worker.active_connections)

    self.worker.set_connections(self.worker_addresses[:1])
    sleep(0.1)
    self.assertTrue(self.worker_addresses[0] in self.worker.active_connections)
    self.assertTrue(self.worker_addresses[1] not in self.worker.active_connections)
    self.assertTrue(self.worker_addresses[2] not in self.worker.active_connections)
    self.worker.set_connections(self.worker_addresses)
    sleep(0.1)
    self.assertTrue(self.worker_addresses[0] in self.worker.active_connections)
    self.assertTrue(self.worker_addresses[1] in self.worker.active_connections)
    self.assertTrue(self.worker_addresses[2] in self.worker.active_connections)
    self.worker.set_connections(self.worker_addresses[2:])
    sleep(0.1)
    self.assertTrue(self.worker_addresses[0] not in self.worker.active_connections)
    self.assertTrue(self.worker_addresses[1] not in self.worker.active_connections)
    self.assertTrue(self.worker_addresses[2] in self.worker.active_connections)
    self.worker.set_connections(self.worker_addresses[:1])
    sleep(0.1)
    self.assertTrue(self.worker_addresses[0] in self.worker.active_connections)
    self.assertTrue(self.worker_addresses[1] not in self.worker.active_connections)
    self.assertTrue(self.worker_addresses[2] not in self.worker.active_connections)

  def test_remove_connection(self):
    self.worker.set_connections(self.worker_addresses)
    sleep(0.1)
    self.assertTrue(self.worker_addresses[0] in self.worker.active_connections)
    self.assertTrue(self.worker_addresses[1] in self.worker.active_connections)
    self.assertTrue(self.worker_addresses[2] in self.worker.active_connections)
    self.worker.remove_connection(self.worker_addresses[1])
    sleep(0.1)
    self.assertTrue(self.worker_addresses[0] in self.worker.active_connections)
    self.assertTrue(self.worker_addresses[1] not in self.worker.active_connections)
    self.assertTrue(self.worker_addresses[2] in self.worker.active_connections)
    self.worker.remove_connection(self.worker_addresses[2])
    sleep(0.1)
    self.assertTrue(self.worker_addresses[0] in self.worker.active_connections)
    self.assertTrue(self.worker_addresses[1] not in self.worker.active_connections)
    self.assertTrue(self.worker_addresses[2] not in self.worker.active_connections)
    
  def test_remote_messaging(self):
    self.worker.set_connections(self.worker_addresses)
    sleep(0.1)
    worker_ids = list()
    for i in xrange(3):
      self.worker.return_pid(callback=lambda response: worker_ids.append(response['pid']))
    while len(worker_ids) < 3:
      sleep(0.1)
    self.assertEqual(len(set(worker_ids)), 3)
    self.worker.set_connections(self.worker_addresses[:1])
    sleep(0.1)
    worker_ids = list()
    for i in xrange(3):
      self.worker.return_pid(callback=lambda response: worker_ids.append(response['pid']))
    while len(worker_ids) < 3:
      sleep(0.1)
    self.assertEqual(len(set(worker_ids)), 1)
    
  def test_worker_routing(self):
    self.worker.set_connections(self.worker_addresses)
    sleep(0.1)
    worker_ids = list()
    for i in xrange(30):
      sleep(0.01)
      self.worker.return_pid(callback=lambda response: worker_ids.append(response['pid']))
    while len(worker_ids) < 30:
      sleep(0.1)
    self.worker.set_connections(self.worker_addresses[:1])
    sleep(0.1)
    order = (worker_ids[0], worker_ids[1], worker_ids[2])
    self.assertEqual(len(set(order)), len(order))
    for i in xrange(3, 3, 30):
      self.assertSquenceEqual(order, worker_ids[i:i+3])


########NEW FILE########
__FILENAME__ = return_value
from toto.invocation import *

def invoke(handler, parameters):
  return {'parameters': parameters}

########NEW FILE########
__FILENAME__ = return_value_async
from toto.invocation import *
from time import sleep
from threading import Thread

@asynchronous
def invoke(handler, parameters):
  def respond():
    sleep(0.1)
    handler.respond({'parameters': parameters})
  Thread(target=respond).start()

########NEW FILE########
__FILENAME__ = return_value_coroutine
from toto.invocation import *
from time import sleep
from threading import Thread
from tornado.gen import coroutine, Return, Task

@coroutine
def invoke(handler, parameters):
  def respond(callback):
    sleep(0.1)
    callback({'parameters': parameters})
  result = yield Task(lambda callback: Thread(target=respond, args=[callback]).start())
  raise Return(result)

########NEW FILE########
__FILENAME__ = return_value_task
from toto.invocation import *
from toto.tasks import TaskQueue
from time import sleep

@asynchronous
def invoke(handler, parameters):
  def respond(params):
    sleep(0.1)
    handler.respond({'parameters': parameters})
  TaskQueue.instance('test').add_task(respond, parameters)

########NEW FILE########
__FILENAME__ = return_value_task_coroutine
from toto.invocation import *
from toto.tasks import TaskQueue
from time import sleep
from tornado.gen import coroutine, Return, Task, Callback, Wait

@coroutine
def invoke(handler, parameters):
  def respond(params):
    sleep(0.1)
    return {'parameters': parameters}
  def return_true():
    sleep(0.1)
    return True

  response = TaskQueue.instance('test1').yield_task(respond, parameters)
  value = TaskQueue.instance('test2').yield_task(return_true)
  raise Return((yield value) and (yield response))
  

########NEW FILE########
__FILENAME__ = ok
def invoke(handler, parameters):
  return {'status': 'ok', 'parameters': parameters}

########NEW FILE########
__FILENAME__ = throw_exception
from toto.invocation import *

def invoke(handler, parameters):
  raise Exception('Test Exception')

########NEW FILE########
__FILENAME__ = throw_exception_async_coroutine
from toto.invocation import *
from time import sleep
from threading import Thread
from tornado.gen import coroutine, Return, Task

@coroutine
def invoke(handler, parameters):
  raise Exception('Test Exception')

########NEW FILE########
__FILENAME__ = throw_exception_task_coroutine
from toto.invocation import *
from toto.tasks import TaskQueue
from time import sleep
from tornado.gen import coroutine, Return, Task, Callback, Wait

@coroutine
def invoke(handler, parameters):
  def respond(params):
    sleep(0.1)
    raise Exception('Test Exception')
  raise Return((yield TaskQueue.instance('test1').yield_task(respond, parameters)))
  

########NEW FILE########
__FILENAME__ = throw_toto_exception
from toto.invocation import *

def invoke(handler, parameters):
  raise TotoException(4242, 'Test Toto Exception')

########NEW FILE########
__FILENAME__ = throw_toto_exception_async_coroutine
from toto.invocation import *
from time import sleep
from threading import Thread
from tornado.gen import coroutine, Return, Task

@coroutine
def invoke(handler, parameters):
  raise TotoException(4242, 'Test Toto Exception')

########NEW FILE########
__FILENAME__ = throw_toto_exception_task_coroutine
from toto.invocation import *
from toto.tasks import TaskQueue
from time import sleep
from tornado.gen import coroutine, Return, Task, Callback, Wait

@coroutine
def invoke(handler, parameters):
  def respond(params):
    sleep(0.1)
    raise TotoException(4242, 'Test Toto Exception')
  raise Return((yield TaskQueue.instance('test1').yield_task(respond, parameters)))
  

########NEW FILE########
__FILENAME__ = return_pid
from toto.invocation import *
import os

def invoke(worker, parameters):
  return {'pid': os.getpid()}

########NEW FILE########
__FILENAME__ = return_value
from toto.invocation import *

def invoke(worker, parameters):
  return {'parameters': parameters}

########NEW FILE########
__FILENAME__ = throw_exception
from toto.invocation import *

def invoke(worker, parameters):
  raise Exception('Test Exception')

########NEW FILE########
__FILENAME__ = throw_toto_exception
from toto.invocation import *

def invoke(worker, parameters):
  raise TotoException(4242, 'Test Toto Exception')

########NEW FILE########
__FILENAME__ = cassandraconnection
from pycassa import ColumnFamily, ConnectionPool

"""
  A simple wrapper around a pycassa.ConnectionPool object that provides easy access and caching for ColumnFamily objects.

  Creation:
  connection = CassandraConnection(ConnectionPool('my_keyspace', ['localhost:9160']))
  connection = CassandraConnection('my_keyspace', ['localhost:9160'])

  Usage:
  cf = connection.my_column_family #Equivalent to ColumnFamily(connection.pool, 'my_column_family')
  cf = connection['my_column_family']
  cf = connection.column_families['my_column_family']
"""
class CassandraConnection():
  def __init__(self, *args, **kwargs):
    if len(args) and isinstance(args[0], ConnectionPool):
      self.pool = args[0]
    else:
      self.pool = ConnectionPool(*args, **kwargs)
    self.column_families = {}

  def __getattr__(self, name):
    return self[name]

  def __getitem__(self, name):
    try:
      return self.column_families[name]
    except:
      self.column_families[name] = ColumnFamily(self.pool, name)
      return self.column_families[name]

  def __str__(self):
    return  '<toto.cassandraconnection.CassandraConnection %d [%s]>' % (id(self), ','.join(self.column_families.keys()))

  def __repr__(self):
    return str(self)

########NEW FILE########
__FILENAME__ = clientsideworker
from tornado.web import *
import json
from invocation import *
from exceptions import *
from tornado.options import define, options
from events import EventManager
from tornado.websocket import WebSocketHandler
import logging
from collections import deque

class ClientSideWorkerManager(object):
  
  def __init__(self):
    self.__workers = {}
    self.__worker_queue = deque()
    self.__operation_queue = deque()
    self.__operation_callbacks = {}

  def add_worker(self, worker):
    self.__workers[id(worker)] = worker
    self.__worker_queue.append(id(worker))
    self.run_operation()

  def remove_worker(self, worker):
    del self.__workers[id(worker)]

  def run_operation(self):
    while self.__operation_queue and self.__worker_queue:
      operation = self.__operation_queue.popleft()
      worker_id = self.__worker_queue.popleft()
      self.__workers[worker_id].write_message({'operation_id': operation[0], 'script': operation[1]})
      if (operation[2]):
        self.__operation_queue.append(operation)

  def add_operation(self, operation_id, operation_script, callback_method=None, max_nodes=1, continuous=False):
    nodes = min(max_nodes, len(self.__worker_queue)) or 1
    if callback_method:
      self.__operation_callbacks[operation_id] = callback_method
    for i in xrange(nodes):
      self.__operation_queue.append((operation_id, operation_script, continuous))
    self.run_operation()

  def finish_operation(self, worker, operation_id, result):
    self.__worker_queue.append(id(worker))
    if operation_id in self.__operation_callbacks:
      self.__operation_callbacks[operation_id](worker, result)
    self.run_operation()

  @staticmethod
  def instance():
    if not hasattr(ClientSideWorkerManager, '_instance'):
      ClientSideWorkerManager._instance = ClientSideWorkerManager()
    return ClientSideWorkerManager._instance

# These methods allow ClientSideWorkerSocketHandler to be swapped with the bulkier TotoSocketHandler
def worker_connected(worker):
  ClientSideWorkerManager.instance().add_worker(worker)

def worker_disconnected(worker):
  ClientSideWorkerManager.instance().remove_worker(worker)

def complete(worker, data):
  ClientSideWorkerManager.instance().finish_operation(worker, data['operation_id'], data['result'])

class ClientSideWorkerSocketHandler(WebSocketHandler):

  @classmethod
  def configure(cls):
    if options.debug:
      import traceback
      def log_error(self, e): 
        logging.error('%s\nHeaders: %s\n' % (traceback.format_exc(), repr(self.request.headers)))
      cls.log_error = log_error

  def log_error(self, e):
    if isinstance(exception , TotoException):
      logging.error("TotoException: %s Value: %s" % (e.code, e.value))
    else:
      logging.error("TotoException: %s Value: %s" % (ERROR_SERVER, repr(e)))

  def open(self):
    ClientSideWorkerManager.instance().add_worker(self)

  def on_message(self, message_data):
    message = json.loads(message_data)
    ClientSideWorkerManager.instance().finish_operation(self, message['operation_id'], message['result'])

  def on_close(self):
    ClientSideWorkerManager.instance().remove_worker(self)

########NEW FILE########
__FILENAME__ = dbconnection
class DBConnection(object):
  '''Toto uses subclasses of DBConnection to support session and account storage as well as general
    access to the backing database. Usually, direct access to the underlying database driver will
    be available via the ``DBConnection.db`` property.

    Currently, toto provides the following ``DBConnection`` drivers:

    * ``toto.mongodbconnection.MongoDBConnection``
    * ``toto.mysqldbconnection.MySQLdbConnection``
    * ``toto.postgresconnection.PostgresConnection``
    * ``toto.redisconnection.RedisConnection``
  '''

  _session_cache = None

  def create_account(self, user_id, password, additional_values={}, **values):
    '''Create an account for the given ``user_id`` and ``password``. Optionally set additional account
      values by passing them as keyword arguments (the ``additional_values`` parameter is deprecated).

      Note: if your database uses a predefined schema, make sure to create the appropriate columns
      before passing additional arguments to ``create_account``.
    '''
    raise NotImplementedError()

  def create_session(self, user_id=None, password=None, verify_password=True):
    '''Create a new session for the account with the given ``user_id`` and ``password``, or an anonymous
      session if anonymous sessions are enabled. This method returns a subclass of ``TotoSession``
      designed for the current backing database. Pass ``verify_password=False`` to create a session
      without checking the password. This feature can be used to implement alternative authentication
      methods like Facebook, Twitter or Google+.
    '''
    raise NotImplementedError()

  def retrieve_session(self, session_id, hmac_data=None, data=None):
    '''Retrieve an existing session with the given ``session_id``. Pass the request body and the value
    of the ``x-toto-hmac`` header as ``data`` and ``hmac_data`` respectively to verify an authenticated request.
    If ``hmac_data`` and ``data`` are both ``None``, HMAC verification will be skipped. This method returns a
    subclasses of ``TotoSession`` designed for the current backing database.

    Toto uses HMAC verification to ensure that requests and responses are not corrupted in transmission.
    The session's ``user_id`` is used as the key which makes it easy for an attacker to forge a request
    so long as they have an active session ID and the associated user ID - both of which are contained
    in the response body of each authenticated request. A future update may contain an option to use
    a secret key for HMAC verification instead.

    The use of HTTPS is strongly recommended for any communication involving sensitive information.
    '''
    raise NotImplementedError()

  def remove_session(self, session_id):
    '''Invalidate the session with the given ``session_id``.
    '''
    raise NotImplementedError()

  def clear_sessions(self, user_id):
    '''If implemented, invalidates all sessions tied to the account with the given ``user_id``.
    '''
    pass

  def change_password(self, user_id, password, new_password):
    '''Updates the password for the account with the given ``user_id`` and ``password`` to match
    ``new_password`` for all future requests.
    '''
    raise NotImplementedError()

  def generate_password(self, user_id):
    '''Generates a new password for the account with the given ``user_id`` and makes it active
    for all future requests. The new password will be returned. This method is designed to
    support "forgot password" functionality.
    '''
    raise NotImplementedError()

  def set_session_cache(self, session_cache):
    '''Optionally set an instance of ``TotoSessionCache`` that will be used to store sessions separately from
    this database.
    '''
    self._session_cache = session_cache

  def _load_session_data(self, session_id):
    '''Called by ``DBConnection.retrieve_session``. Will attempt to load data from an associated ``TotoSessionCache``.
    If no ``TotoSessionCache`` is associated with the current instance, the result of ``self._load_uncached_data(session_id)``
    is returned.
    '''
    if self._session_cache:
      return self._session_cache.load_session(session_id)
    return self._load_uncached_data(session_id)

  def _load_uncached_data(self, session_id):
    '''Load a session data ``dict`` from the local database. Called by default and if no ``TotoSessionCache`` has been
    associated with the current instance of ``DBConnection``. 
    '''
    raise NotImplementedError()

  def _cache_session_data(self, session_data):
    '''Called by ``DBConnection.create_session`` and by ``DBConnection.retrieve_session`` if there is a change in ``TotoSession.expires``.
    Returns ``True`` if the session has been written to an associated ``TotoSessionCache``, ``False`` otherwise.
    '''
    if self._session_cache:
      self._session_cache.store_session(session_data)
      return True
    return False

from tornado.options import define, options

define("database", metavar='mysql|mongodb|redis|postgres|none', default="none", help="the database driver to use")
define("db_host", default='localhost', help="The host to use for database connections.")
define("db_port", default=0, help="The port to use for database connections. Leave this at zero to use the default for the selected database type")
define("mysql_database", type=str, help="Main MySQL schema name")
define("mysql_user", type=str, help="Main MySQL user")
define("mysql_password", type=str, help="Main MySQL user password")
define("mysql_uuid_account_id", default=False, help="Use binary(16) UUIDs for account_id in MySQL databases instead of int(8) unsigned auto_increment. UUID(bytes=handler.session.account_id) can be used to get a UUID representing the account_id.")
define("postgres_database", type=str, help="Main Postgres database name")
define("postgres_user", type=str, help="Main Postgres user")
define("postgres_password", type=str, help="Main Postgres user password")
define("postgres_min_connections", type=int, default=1, help="The minimum number of connections to keep in the Postgres connection pool")
define("postgres_max_connections", type=int, default=100, help="The maximum number of connections to keep in the Postgres connection pool")
define("mongodb_database", default="toto_server", help="MongoDB database")
define("redis_database", default=0, help="Redis DB")
define("session_ttl", default=24*60*60*365, help="The number of seconds after creation a session should expire")
define("anon_session_ttl", default=24*60*60, help="The number of seconds after creation an anonymous session should expire")
define("session_renew", default=0, help="The number of seconds before a session expires that it should be renewed, or zero to renew on every request")
define("anon_session_renew", default=0, help="The number of seconds before an anonymous session expires that it should be renewed, or zero to renew on every request")

def configured_connection():  
    if options.database == "mongodb":
      from mongodbconnection import MongoDBConnection
      return MongoDBConnection(options.db_host, options.db_port or 27017, options.mongodb_database, options.session_ttl, options.anon_session_ttl, options.session_renew, options.anon_session_renew)
    elif options.database == "redis":
      from redisconnection import RedisConnection
      return RedisConnection(options.db_host, options.db_port or 6379, options.redis_database, options.session_ttl, options.anon_session_ttl, options.session_renew, options.anon_session_renew)
    elif options.database == "mysql":
      from mysqldbconnection import MySQLdbConnection
      return MySQLdbConnection('%s:%s' % (options.db_host, options.db_port or 3306), options.mysql_database, options.mysql_user, options.mysql_password, options.session_ttl, options.anon_session_ttl, options.session_renew, options.anon_session_renew, options.mysql_uuid_account_id)
    elif options.database == 'postgres':
      from postgresconnection import PostgresConnection
      return PostgresConnection(options.db_host, options.db_port or 5432, options.postgres_database, options.postgres_user, options.postgres_password,  options.session_ttl, options.anon_session_ttl, options.session_renew, options.anon_session_renew, options.postgres_min_connections, options.postgres_max_connections)
    else:
      from fakeconnection import FakeConnection
      return FakeConnection() 

########NEW FILE########
__FILENAME__ = events
'''Toto's event framework is used to allow external events to affect client requests, or to run scheduled tasks
after a specified signal is received. It can be used to send messages to active requests, even between multiple
server processes. The event framework can also be used outside of Toto to send messages to running Toto servers.
'''

import cPickle as pickle
from threading import Thread
from collections import deque
from tornado.web import *
from tornado.ioloop import IOLoop
from traceback import format_exc
from tornado.options import options
import zmq
import logging
import zlib
from random import choice, shuffle

class EventManager():
  '''Instances will listen on ``address`` for incoming events.
  '''

  def __init__(self, address=None):
    self.__handlers = {}
    self.address = address
    self.__zmq_context = zmq.Context()
    self.__remote_servers = {}
    self.__thread = None
    self.__queued_servers = deque()
  
  def register_server(self, address):
    '''Add a server located at ``address``. This server will now be included in the
    recipient list whenever ``send()`` is called.
    '''
    if address in self.__remote_servers:
      raise Exception('Server already registered: %s', address)
    socket = self.__zmq_context.socket(zmq.PUSH)
    socket.connect(address)
    self.__remote_servers[address] = socket
    self.refresh_server_queue()

  def remove_server(self, address):
    '''Remove the server located at ``address`` from the recipient list for all
    future calls to ``send()``.
    '''
    del self.__remote_servers[address]
    self.refresh_server_queue()
    
  def remove_all_servers(self):
    '''Clear the recipient list for all future calls to ``send``.
    '''
    self.__remote_servers.clear()
    self.refresh_server_queue()

  def refresh_server_queue(self):
    '''Reload and shuffle the registered server queue used for round-robin load
    balancing of non-broadcast events.
    '''
    self.__queued_servers.clear()
    self.__queued_servers.extend(self.__remote_servers.itervalues())
    shuffle(self.__queued_servers)
  
  def register_handler(self, event_name, event_handler, run_on_main_loop=False, request_handler=None, persist=False):
    '''Register ``event_handler`` to run when ``event_name`` is received. Handlers are meant to respond to
    a single event matching ``event_name`` only. If ``run_on_main_loop`` is ``True`` the handler will be executed
    on Tornado's main ``IOLoop`` (required if the handler will write to a response stream). If ``request_handler``
    is set, ``event_handler`` will not fire once ``request_handler`` has finished. Set ``persist`` to ``True``
    to automatically requeue ``event_handler`` each time it is executed.
    '''
    if not event_name in self.__handlers:
      self.__handlers[event_name] = set()
    handler_tuple = (event_handler, run_on_main_loop, request_handler, persist)
    self.__handlers[event_name].add(handler_tuple)
    return (event_name, handler_tuple)

  def remove_handler(self, handler_sig):
    '''Disable and remove the handler matching ``handler_sig``.
    '''
    self.__handlers[handler_sig[0]].discard(handler_sig[1])
  
  def start_listening(self):
    '''Starts listening for incoming events on ``EventManager.address``.
    '''
    if self.__thread:
      return
    def receive():
      context = zmq.Context()
      socket = context.socket(zmq.PULL)
      socket.bind(self.address)
      while True:
        event = pickle.loads(zlib.decompress(socket.recv()))
        event_name = event['name']
        event_args = event['args']
        if event_name in self.__handlers:
          handlers = self.__handlers[event_name]
          for handler in list(handlers):
            if not handler[3]:
              handlers.remove(handler)
            try:
              if handler[2] and handler[2]._finished:
                continue
              if handler[1]:
                (lambda h: IOLoop.instance().add_callback(lambda: h[0](event_args)))(handler)
              else:
                handler[0](event_args)
            except Exception as e:
              logging.error(format_exc())
    self.__thread = Thread(target=receive)
    self.__thread.daemon = True
    self.__thread.start()
  
  def send_to_server(self, address, event_name, event_args):
    '''Send a message with ``event_name`` and ``event_args`` only
    to the server listening at ``address``. ``address`` must have
    previously been passed to ``register_server``. This is more
    efficient than ``send`` if you only intent to send the event
    to a single server and know the address in advance.
    '''
    event = {'name': event_name, 'args': event_args}
    event_data = zlib.compress(pickle.dumps(event))
    self.__remote_servers[address].send(event_data)
  
  def send(self, event_name, event_args, broadcast=True):
    '''Send a message with ``event_name`` and ``event_args`` to
    all servers previously registered with ``register_server()``.
    If ``broadcast`` is false, the event will be sent to only
    a single server. Non-broadcast events are round-robin load
    balanced between registered servers.
    '''
    if not self.__remote_servers:
      return
    event = {'name': event_name, 'args': event_args}
    event_data = zlib.compress(pickle.dumps(event))
    if not broadcast:
      self.__queued_servers[0].send(event_data)
      self.__queued_servers.rotate(-1)
      return
    for socket in self.__queued_servers:
      socket.send(event_data)

  @classmethod
  def instance(cls):
    '''Returns the shared instance of ``EventManager``, instantiating on the first call.
    '''
    if not hasattr(cls, '_instance'):
      cls._instance = cls()
    return cls._instance

########NEW FILE########
__FILENAME__ = exceptions
'''Toto uses the following error codes internally:

  * ``ERROR_SERVER = 1000``
  * ``ERROR_MISSING_METHOD = 1002``
  * ``ERROR_MISSING_PARAMS = 1003``
  * ``ERROR_NOT_AUTHORIZED = 1004``
  * ``ERROR_USER_NOT_FOUND = 1005``
  * ``ERROR_USER_ID_EXISTS = 1006``
  * ``ERROR_INVALID_SESSION_ID = 1007``
  * ``ERROR_INVALID_HMAC = 1008``
  * ``ERROR_INVALID_RESPONSE_HMAC = 1009``
  * ``ERROR_INVALID_USER_ID 1010``
'''

ERROR_SERVER = 1000
ERROR_INVALID_METHOD = 1001
ERROR_MISSING_METHOD = 1002
ERROR_MISSING_PARAMS = 1003
ERROR_NOT_AUTHORIZED = 1004
ERROR_USER_NOT_FOUND = 1005
ERROR_USER_ID_EXISTS = 1006
ERROR_INVALID_SESSION_ID = 1007
ERROR_INVALID_HMAC = 1008
ERROR_INVALID_RESPONSE_HMAC = 1009
ERROR_INVALID_USER_ID = 1010

class TotoException(Exception):
  '''This class is used to return errors from Toto methods. ``TotoException.value``
  is used to describe the exception and ``TotoException.code`` should be set to a
  status code that can be used to programmatically reference the exception. Toto's
  error redirecting capabilities use ``code`` to look up the redirect URL.
  '''
  def __init__(self, code, value):
    self.value = value
    self.code = code
  def __str__(self):
    return str(self.__dict__)
  def __repr__(self):
    return repr(self.__dict__)

########NEW FILE########
__FILENAME__ = fakeconnection
from dbconnection import DBConnection


class FakeConnection(DBConnection):

  def __init__(self):
    self.db = None

  def create_account(self, user_id, password, additional_values={}, **values):
    pass

  def create_session(self, user_id=None, password=None):
    return None

  def retrieve_session(self, session_id, hmac_data=None, data=None):
    return None

  def remove_session(self, session_id):
    pass

  def clear_sessions(self, user_id):
    pass

  def change_password(self, user_id, password, new_password):
    pass

  def generate_password(self, user_id):
    return None

########NEW FILE########
__FILENAME__ = handler
from tornado.web import *
import json
import hashlib
import hmac
from invocation import *
from exceptions import *
from tornado.options import define, options
import base64
from tornado.httputil import parse_multipart_form_data
from tornado.ioloop import IOLoop
from tornado.gen import coroutine, Return, engine
from tornado.concurrent import return_future, Future
import logging

define("allow_origin", default="*", help="This is the value for the Access-Control-Allow-Origin header (default *)")
define("method_select", default="both", metavar="both|url|parameter", help="Selects whether methods can be specified via URL, parameter in the message body or both (default both)")
define("bson_enabled", default=False, help="Allows requests to use BSON with content-type application/bson")
define("msgpack_enabled", default=False, help="Allows requests to use MessagePack with content-type application/msgpack")
define("hmac_enabled", default=True, help="Uses the x-toto-hmac header to verify authenticated requests.")

class BatchHandlerProxy(object):
  '''A proxy to a handler, this class intercepts calls to ``handler.respond()`` in order to match the
  response to the proper batch ``request_key``. If a method is invoked as part of a batch request,
  an instance of ``BatchHandlerProxy`` will be passed instead of a ``TotoHandler``. Though this
  replacement should be transparent to the method invocation, you may access the underlying handler
  with ``proxy.handler``.
  '''

  _non_proxy_keys = {'handler', 'request_key', 'async'}

  def __init__(self, handler, request_key):
    self.handler = handler
    self.request_key = request_key

  def __getattr__(self, attr):
    return getattr(self.handler, attr)

  def __setattr__(self, attr, value):
    if attr in self._non_proxy_keys:
      self.__dict__[attr] = value
    else:
      setattr(self.handler, attr, value)

  def respond(self, result=None, error=None, allow_async=True):
    '''Sets the response for the corresponding batch ``request_key``. When all requests have been processed,
    the combined response will passed to the underlying handler's ``respond()``.

    The ``allow_async`` parameter is for internal use only and is not intended to be supplied manually.
    '''
    #if the handler is processing an async method, schedule the response on the main runloop
    if self.async and allow_async:
      IOLoop.instance().add_callback(lambda: self.respond(result, error, False))
      return
    self.handler.batch_results[self.request_key] = error is not None and {'error': isinstance(error, dict) and error or self.handler.error_info(error)} or {'result': result}
    if len(self.handler.batch_results) == len(self.handler.request_keys):
      self.handler.respond(batch_results=self.handler.batch_results, allow_async=False)

class TotoHandler(RequestHandler):
  '''The handler is responsible for processing all requests to the server. An instance
  will be initialized for each incoming request and will handle authentication, session
  management and method delegation for you.
  
  You can set the module to use for method delegation via the ``method_module`` parameter.
  Methods are modules that contain an invoke function::

    def invoke(handler, parameters)
  
  The request handler will be passed as the first parameter to the invoke function and
  provides access to the server's database connection, the current session and other
  useful request properties. Request parameters will be passed as the second argument
  to the invoke function. Any return values from ``invoke()`` functions should be
  JSON serializable.
  
  Toto methods are generally invoked via a POST request to the server with a JSON
  serialized object as the body. The body should contain two properties:

  1. method - The name of the method to invoke.
  2. parameters - Any parameters to pass to the Toto function.

  For example::

    {"method": "account.create", "parameters": {"user_id": "test", "password": "testpassword"}}

  Will call method_module.account.create.invoke(handler, {'user_id': 'test', 'password': 'testpassword'})

  An ``invoke()`` function can be decorated with ``@tornado.gen.coroutine`` and be run as a Tornado coroutine.

  Alternatively, an ``invoke(handler, parameters)`` function may be decorated with ``@toto.invocation.asynchronous``.
  If a function decorated in this manner does not return a value, the connection well remain open until
  ``handler.respond(result, error)`` is called where ``error`` is an ``Exception`` or ``None`` and ``result``
  is a normal ``invoke()`` return value or ``None``.

  There are client libraries for iOS and Javascript that will make using Toto much easier. They are
  available at https://github.com/JeremyOT/TotoClient-iOS and https://github.com/JeremyOT/TotoClient-JS
  respectively.
  '''

  SUPPORTED_METHODS = {"POST", "OPTIONS", "GET", "HEAD"}
  ACCESS_CONTROL_ALLOW_ORIGIN = options.allow_origin

  def initialize(self, db_connection):
    self.db_connection = db_connection
    self.db = self.db_connection.db
    self.bson = options.bson_enabled and __import__('bson').BSON
    self.msgpack = options.msgpack_enabled and __import__('msgpack')
    self.response_type = 'application/json'
    self.body = None
    self.registered_event_handlers = []
    self.__active_methods = []
    self.headers_only = False
    self.async = False

  @classmethod
  def configure(cls):
    """Runtime method configuration.
    """
    #Method configuration
    if options.event_mode != 'off':
      from toto.events import EventManager
      cls.event_manager = EventManager
    if options.method_select == 'url':
      def get_method_path(self, path, body):
        if path:
          return '.'.join(path.split('/'))
        else:
          raise TotoException(ERROR_MISSING_METHOD, "Missing method.")
      cls.__get_method_path = get_method_path
    elif options.method_select == 'parameter':
      def get_method_path(self, path, body):
        if body and 'method' in body:
          logging.info(body['method'])
          return body['method']
        else:
          raise TotoException(ERROR_MISSING_METHOD, "Missing method.")
      cls.__get_method_path = get_method_path
    
    if options.use_cookies:
      import math
      set_cookie = options.secure_cookies and cls.set_secure_cookie or cls.set_cookie
      get_cookie = options.secure_cookies and cls.get_secure_cookie or cls.get_cookie
      def create_session(self, user_id=None, password=None, verify_password=True):
        self.session = self.db_connection.create_session(user_id, password, verify_password=verify_password)
        set_cookie(self, name='toto-session-id', value=self.session.session_id, expires_days=math.ceil(self.session.expires / (24.0 * 60.0 * 60.0)), domain=options.cookie_domain)
        return self.session
      cls.create_session = create_session
      
      def retrieve_session(self, session_id=None):
        if not self.session or (session_id and self.session.session_id != session_id):
          headers = self.request.headers
          if not session_id:
            session_id = 'x-toto-session-id' in headers and headers['x-toto-session-id'] or get_cookie(self, 'toto-session-id')
          if session_id:
            self.session = self.db_connection.retrieve_session(session_id, options.hmac_enabled and headers.get('x-toto-hmac'), options.hmac_enabled and 'x-toto-hmac' in headers and self.request.body or None)
        if self.session:
          set_cookie(self, name='toto-session-id', value=self.session.session_id, expires_days=math.ceil(self.session.expires / (24.0 * 60.0 * 60.0)), domain=options.cookie_domain)
        return self.session
      cls.retrieve_session = retrieve_session
    if options.debug:
      import traceback
      def error_info(self, e):
        if not isinstance(e, TotoException):
          e = TotoException(ERROR_SERVER, str(e))
        logging.error('%s\n%s\nHeaders: %s\n' % (e, traceback.format_exc(), repr(self.request.headers)))
        return e.__dict__
      cls.error_info = error_info
    cls.__method_root = __import__(options.method_module)
    cls.__method_cache = {}
      
  def __get_method_path(self, path, body):
    """The default method_select "both" (or any unsupported value) will
    call this method. The class method ``configure()`` will update this
    to a more efficient method according to ``tornado.options``.
    """
    if path:
      return '.'.join(path.split('/'))
    elif body and 'method' in body:
      logging.info(body['method'])
      return body['method']
    else:
      raise TotoException(ERROR_MISSING_METHOD, "Missing method.")

  def __get_method(self, path):
    try:
      return self.__method_cache[path]
    except KeyError:
      try:
        method = self.__method_root
        for component in path.split('.'):
          method = getattr(method, component)
        self.__method_cache[path] = method
      except AttributeError:
        raise TotoException(ERROR_INVALID_METHOD, "Cannot call '" + path + "'.")
    return self.__method_cache[path]

  def error_info(self, e):
    if not isinstance(e, TotoException):
      e = TotoException(ERROR_SERVER, str(e))
    logging.error("TotoException: %s Value: %s" % (e.code, e.value))
    return e.__dict__

  @coroutine
  def invoke_method(self, path, request_body, parameters, handler=None):
    result = None
    error = None
    method = None
    try:
      method = self.__get_method(self.__get_method_path(path, request_body))
      self.__active_methods.append(method)
      output = method.invoke(handler or self, parameters)
      if isinstance(output, Future):
        #result is a future, so yield the real response
        result = yield output
      else:
        result = output
    except Exception as e:
      error = self.error_info(e)
    raise Return((result, error, (hasattr(method, 'asynchronous'))))

  def options(self, path=None):
    allowed_headers = set(['x-toto-hmac','x-toto-session-id','origin','content-type'])
    if 'access-control-request-headers' in self.request.headers:
      allowed_headers = allowed_headers.union(self.request.headers['access-control-request-headers'].lower().replace(' ','').split(','))
    self.add_header('access-control-allow-headers', ','.join(allowed_headers))
    if 'access-control-request-method' in self.request.headers and self.request.headers['access-control-request-method'] not in self.SUPPORTED_METHODS:
      raise HTTPError(405, 'Method not supported')
    self.add_header('access-control-allow-origin', self.ACCESS_CONTROL_ALLOW_ORIGIN)
    self.add_header('access-control-allow-methods', ','.join(self.SUPPORTED_METHODS))
    self.add_header('access-control-expose-headers', 'x-toto-hmac')
  
  @coroutine
  def head(self, path=None):
    self.headers_only = True
    self.get(path)

  @coroutine
  def get(self, path=None):
    parameters = {}
    # Convert parameters with one item to string, will cause undesired behavior if user means to pass array with length 1
    for k, v in self.request.arguments.items():
      if len(v) == 1:
        parameters[k] = v[0]
      else:
        parameters[k] = v
    yield self.process_request(path, self.body, parameters)

  @coroutine
  def post(self, path=None):
    content_type = 'content-type' in self.request.headers and self.request.headers['content-type'] or 'application/json'
    if not content_type.startswith('application/json'):
      if content_type.startswith('application/x-www-form-urlencoded'):
        self.body = {'parameters': self.request.arguments}
      elif content_type.startswith('multipart/form-data'):
        self.body = {'parameters': {'arguments': self.request.arguments, 'files': self.request.files}}
      elif self.bson and content_type.startswith('application/bson'):
        self.response_type = 'application/bson'
        self.body = self.bson(self.request.body).decode()
      elif self.msgpack and content_type.startswith('application/msgpack'):
        self.response_type = 'application/msgpack'
        self.body = self.msgpack.loads(self.request.body)
    else:
      self.body = json.loads(self.request.body)
    if self.body and 'batch' in self.body:
      yield self.batch_process_request(self.body['batch'])
    else:
      yield self.process_request(path, self.body, self.body and 'parameters' in self.body and self.body['parameters'] or {})
  
  @return_future
  @engine
  def batch_process_request(self, requests, callback):
    self._request_callback = callback
    self.session = None
    self.add_header('access-control-allow-origin', self.ACCESS_CONTROL_ALLOW_ORIGIN)
    self.add_header('access-control-expose-headers', 'x-toto-hmac')
    self.request_keys = sorted(requests.keys())
    self.batch_results = {}
    for k, v in ((i, requests[i]) for i in self.request_keys):
      proxy = BatchHandlerProxy(self, k)
      result, error, async = yield self.invoke_method(None, v, v.get('parameters', {}), handler=proxy)
      if async:
        proxy.async = True
      if result or error or not async:
        proxy.respond(result, error, allow_async=False)

  @return_future
  @engine 
  def process_request(self, path, request_body, parameters, callback):
    self._request_callback = callback
    self.session = None
    self.add_header('access-control-allow-origin', self.ACCESS_CONTROL_ALLOW_ORIGIN)
    self.add_header('access-control-expose-headers', 'x-toto-hmac')
    result, error, async = yield self.invoke_method(path, request_body, parameters)
    if async:
      self.async = True
    if result is not None or error:
      self.respond(result, error, allow_async=False)
    elif not async and not self._finished:
      self._request_callback()

  def respond(self, result=None, error=None, batch_results=None, allow_async=True):
    '''Respond to the request with the given result or error object (the ``batch_results`` and
    ``allow_async`` parameters are for internal use only and not intended to be supplied manually).
    Responses will be serialized according to the ``response_type`` propery. The default
    serialization is "application/json". Other supported protocols are:

    * application/bson - requires pymongo
    * application/msgpack - requires msgpack-python

    The response will also contain any available session information.
    
    To help with error handling in asynchronous methods, calling ``handler.respond(error=<your_error>)`` with a caught
    exception will trigger a normal Toto error response, log the error and finish the request. This is the same basic
    flow that is used internally when exceptions are raised from synchronous method calls.

    The "error" property of the response is derived from the ``error`` parameter in the following ways:

    1. If ``error`` is an instance of ``TotoException``, "error" will be a dictionary with "value" and "code" keys matching those of the ``TotoException``.
    2. In all other cases, ``error`` is first converted to a ``TotoException`` with ``code = <ERROR_SERVER>`` and ``value = str(error)`` before following (1.).

    To send custom error information, pass an instance of ``TotoException`` with ``value = <some_json_serializable_object>``.
    '''
    #if the handler is processing an async method, schedule the response on the main runloop
    if self.async and allow_async:
      IOLoop.instance().add_callback(lambda: self.respond(result, error, batch_results, False))
      return
    response = {}
    if result is not None:
      response['result'] = result
    if error:
      response['error'] = isinstance(error, dict) and error or self.error_info(error)
    if batch_results:
      response['batch'] = batch_results
    if self.session:
      response['session'] = {'session_id': self.session.session_id, 'expires': self.session.expires, 'user_id': str(self.session.user_id)}
    if self.response_type == 'application/bson':
      response_body = str(self.bson.encode(response))
    elif self.response_type == 'application/msgpack':
      response_body = self.msgpack.dumps(response)
    else:
      response_body = json.dumps(response)
    if self.session and options.hmac_enabled:
      self.add_header('x-toto-hmac', base64.b64encode(hmac.new(str(self.session.user_id).lower(), response_body, hashlib.sha1).digest()))
    self.respond_raw(response_body, self.response_type)

  def respond_raw(self, body, content_type, finish=True):
    '''Respond raw is used by respond to send the response to the client. You can pass a string as the body parameter
    and it will be written directly to the response stream. The response "content-type" header will be set to ``content_type``.
    Use finish to specify whether or not the response stream should be closed after body is written. Use ``finish=False``
    to send the response in multiple calls to ``respond_raw``.
    '''
    self.add_header('content-type', content_type)
    if not self.headers_only:
      self.write(body)
    if finish:
      self._request_callback()

  def on_connection_close(self):
    '''You should not call this method directly, but if you implement an ``on_connection_close()`` function in a
    method module (where you defined invoke) it will be called when the connection closes if that method was
    invoked. E.G.::

      def invoke(handler, parameters):
        #main method body

      def on_connection_close(handler):
        #clean up
    '''
    for method in self.__active_methods:
      if hasattr(method, 'on_connection_close'):
        method.on_connection_close(self);
    self.on_finish()

  def register_event_handler(self, event_name, handler, run_on_main_loop=True, deregister_on_finish=False):
    '''If using Toto's event framework, this method makes it easy to register an event callback tied to the
    current connection and handler. Event handlers registered via this method will not be called once this handler
    has finished (connection closed). The ``deregister_on_finish`` parameter will cause this handler to be explicitly
    deregisted as part of the ``handler.on_finish`` event. Otherwise, event handlers are only cleaned up when the
    associated event is received.

    The return value can be used to manually deregister the event handler at a later point.
    '''
    sig = TotoHandler.event_manager.instance().register_handler(event_name, handler, run_on_main_loop, self)
    if deregister_on_finish:
      self.registered_event_handlers.append(sig)
    return sig

  def deregister_event_handler(self, sig):
    '''Pass the value returned from ``register_event_handler`` to deregister an active event handler.
    '''
    TotoHandler.event_manager.instance().remove_handler(sig)
    self.registered_event_handlers.remove(sig)

  def create_session(self, user_id=None, password=None, verify_password=True):
    '''Create a new session for the given user id and password (or an anonymous session if ``user_id`` is ``None``).
    After this method is called, the session will be available via ``self.session``. As with the
    ``db_connection.create_session()`` method, you may pass ``verify_password=False`` to create a session without
    checking the password. This can be used to implement alternative authentication methods like Facebook, Twitter
    and Google+.
    '''
    self.session = self.db_connection.create_session(user_id, password, verify_password)
    return self.session

  def retrieve_session(self, session_id=None):
    '''Retrieve the session specified by the request headers (or if enabled, the request cookie) and store it
    in ``self.session``. Alternatively, pass a ``session_id`` to this function to retrieve that session explicitly.
    '''
    if not self.session or (session_id and self.session.session_id != session_id):
      headers = self.request.headers
      if not session_id and 'x-toto-session-id' in headers:
        session_id = 'x-toto-session-id' in headers and headers['x-toto-session-id'] or None
      if session_id:
        self.session = self.db_connection.retrieve_session(session_id, options.hmac_enabled and headers.get('x-toto-hmac'), options.hmac_enabled and 'x-toto-hmac' in headers and self.request.body or None)
    return self.session
    
  def on_finish(self):
    while self.registered_event_handlers:
      self.deregister_event_handler(self.registered_event_handlers[0])


########NEW FILE########
__FILENAME__ = invocation
'''``toto.invocation`` contains many decorators that may be applied to the ``invoke(handler, parameters)`` functions in
  method modules in order to modify their behavior.
'''

from exceptions import *
from tornado.options import options
from traceback import format_exc
import logging
import json

"""
This is a list of all attributes that may be added by a decorator,
it is used to allow decorators to be order agnostic.
"""
invocation_attributes = ['asynchronous', '__doc__', '__module__', '__name__', '__repr__']

def _add_doc(fn, wrapper, doc):
  '''A convenience method for appending to a decorated method's docstring.'''
  wrapper.__name__ = fn.__name__
  wrapper.__module__ = fn.__module__
  wrapper.__doc__ = fn.__doc__ and '%s\n\n%s' % (fn.__doc__, doc) or doc

def _copy_attributes(fn, wrapper, doc=None, attributes=invocation_attributes):
  '''A convenience method for copying certain attributes to a decorated method. Optionally, ``doc``
  can be passed to append to a the method's docstring. To specify which attributes to copy, pass
  an iterable as the ``attributes`` argument.
  '''
  for a in attributes:
    if hasattr(fn, a):
      setattr(wrapper, a, getattr(fn, a))
  if doc:
    _add_doc(fn, wrapper, doc)

def asynchronous(fn):
  '''Invoke functions with the ``@asynchronous`` decorator will not cause the request
  handler to finish when they return. Use this decorator to support long running
  operations like tasks sent to workers or long polling.
  '''
  fn.asynchronous = True
  return fn

def anonymous_session(fn):
  '''Invoke functions marked with the ``@anonymous_session`` decorator will attempt to load
  the current session (either referenced by the x-toto-session-id request headers or cookie).
  If no session is found, an anonymous session will be created.

  Note: If the user was previously authenticated, the authenticated session
  will be loaded.
  '''
  def wrapper(handler, parameters):
    handler.retrieve_session()
    if not handler.session:
      handler.create_session()
    return fn(handler, parameters)
  _copy_attributes(fn, wrapper, '*If not authenticated, this request will use an anonymous session for state persistence*.')
  return wrapper

def authenticated(fn):
  '''Invoke functions marked with the ``@authenticated`` decorator will attempt to
  load the current session (either referenced by the x-toto-session-id request header or cookie).
  If no session is found, or if the current session is anonymous, a "Not authorized"
  error will be returned to the client.
  '''
  def wrapper(handler, parameters):
    handler.retrieve_session()
    if not handler.session or not handler.session.user_id:
      raise TotoException(ERROR_NOT_AUTHORIZED, "Not authorized")
    return fn(handler, parameters)
  _copy_attributes(fn, wrapper, '*Requires authentication*.')
  return wrapper

def optionally_authenticated(fn):
  '''Invoke functions marked with the ``@optionally_authenticated`` decorator will
  attempt to load the current session (either referenced by the x-toto-session-id request header or cookie).
  If no session is found, the request proceeds as usual.
  '''
  def wrapper(handler, parameters):
    handler.retrieve_session()
    return fn(handler, parameters)
  _copy_attributes(fn, wrapper)
  return wrapper

def authenticated_with_parameter(fn):
  '''Invoke functions marked with the ``@authenticated_with_parameter`` decorator will
  behave like functions decorated with ``@authenticated`` but will use the session_id
  parameter to find the current session instead of the x-toto-session-id header or cookie.
  '''
  def wrapper(handler, parameters):
    if 'session_id' in parameters:
      handler.retrieve_session(parameters['session_id'])
      del parameters['session_id']
    if not handler.session:
      raise TotoException(ERROR_NOT_AUTHORIZED, "Not authorized")
    return fn(handler, parameters)
  _copy_attributes(fn, wrapper, '*Authenticated session. Requires the session to be passed as* ``session_id``.')
  return wrapper

def requires(*args):
  '''Invoke functions marked with the ``@requires`` decorator will error if any of the parameters
  passed to the decorator are missing. The following example will error if either "param1" or "param2"
  is not included in the request::
    
    @requires('param1', 'param2')
    def invoke(handler, parameters):
      pass
  '''
  required_parameters = set(args)
  def decorator(fn):
    def wrapper(handler, parameters):
      missing_parameters = required_parameters.difference(parameters)
      if missing_parameters:
        raise TotoException(ERROR_MISSING_PARAMS, "Missing parameters: " + ', '.join(missing_parameters))
      return fn(handler, parameters)
    _copy_attributes(fn, wrapper, '*Required parameters:* %s.' % ', '.join('``%s``' % i for i in args))
    return wrapper
  return decorator

def raw_response(fn):
  '''Invoke functions marked with the ``@raw_response`` decorator will not be serialized before response
  to the client. This can be used to send text, html or other binary data without the usual JSON (or other)
  processing. The ``handler.response_type`` property will be used to set the response "Content-Type" header.
  By default this will be "application/octet-stream".
  '''
  def wrapper(handler, parameters):
    handler.response_type = 'application/octet-stream'
    handler.respond_raw(fn(handler, parameters), handler.response_type)
    return None
  _copy_attributes(fn, wrapper)
  return wrapper

def jsonp(callback_name='jsonp'):
  '''Invoke functions marked with the ``@jsonp`` decorator will return a wrapper response that will
  call a client-side javascript function. This decorator requires a "jsonp" parameter set to the name of the javascript
  callback function to be passed with the request. If no "jsonp" parameter is passed, the request will respond
  like any other Toto request. The decorator can be applied with an optional ``callback_name`` argument to
  specify a parameter to use instead of "jsonp", e.g.::
  
    @jsonp('callback')
    def invoke(handler, parameters):
      #do stuff
  
  Will allow JSONP requests that call the function specified by "callback" in their response. Applying the
  decorator without the ``callback_name`` parameter will use the default "jsonp"::

    @jsonp
    def invoke(handler, parameters):
      #do stuff

  Note: JSONP requests will only be affected by decorators before ``@jsonp`` in the decorator chain.
  '''
  def decorator(fn):
    def wrapper(handler, parameters):
      callback = parameters.get(callback_name, None)
      if callback:
        del parameters[callback_name]
        handler.respond_raw('%s(%s)' % (callback, json.dumps(fn(handler, parameters))), 'text/javascript')
        return None
      else:
        return fn(handler, parameters)
    _copy_attributes(fn, wrapper, '*Supports JSONP requests with the callback parameter* ``%s``.' % callback_name)
    return wrapper

  if isinstance(callback_name, basestring):
    return decorator
  fn = callback_name
  callback_name = 'jsonp'
  return decorator(fn)

def error_redirect(redirect_map, default=None):
  '''Invoke functions marked with the ``@error_redirect`` decorator will redirect according to the ``redirect_map``
  dictionary. ``redirect_map`` should consist of ``status_code``, ``url`` pairs. This decorator will check the ``code``
  then ``status_code`` properties of the raised error for matches in the redirect map before falling back to the usual
  error behavior. The optional ``default`` parameter can be used to specify a url to redirect to if there are no matches
  in ``redirect_map``.

  The following code will redirect to "not_found.html" on 404, and "error.html" otherwise::
    
    @error_redirect({'404': 'not_found.html'}, 'error.html')
    def invoke(handler, parameters):
      pass
  '''
  def decorator(fn):
    def wrapper(handler, parameters):
      try:
        return fn(handler, parameters)
      except Exception as e:
        if options.debug:
          logging.error(format_exc())
        if hasattr(e, 'code') and str(e.code) in redirect_map:
          handler.redirect(redirect_map[str(e.code)])
        elif hasattr(e, 'status_code') and str(e.status_code) in redirect_map:
          handler.redirect(redirect_map[str(e.status_code)])
        elif default:
          handler.redirect(default)
        else:
          raise
    _copy_attributes(fn, wrapper)
    return wrapper
  return decorator

def default_parameters(defaults):
  '''Invoke functions marked with the ``@default_parameters`` decorator will set missing parameters according to the
  dictionary passed as the ``defaults`` argument.
  '''
  def decorator(fn):
    def wrapper(handler, parameters):
      for p in defaults:
        if p not in parameters:
          parameters[p] = defaults[p]
      return fn(handler, parameters)
    _copy_attributes(fn, wrapper, '*Automatically adds default parameters:* %s.' % ', '.join(('``%s: %s``' % (k, v) for k, v in defaults.iteritems())))
    return wrapper
  return decorator

########NEW FILE########
__FILENAME__ = messaging
from threading import Thread
from traceback import format_exc
import zmq
import logging

class MessageQueue():

  def __init__(self):
    self.__handlers = {}
    self.__zmq_context = zmq.Context()
    self.__out_socket = self.__zmq_context.socket(zmq.PUSH)
    self.__thread = None
    self.__protocol = None
    self.__port = 0
    self.__interface = None
    self.on_recv = None
  
  @property
  def port(self):
    return self.__port
  
  @property
  def interface(self):
    return self.__interface
  
  @property
  def protocol(self):
    return self.__protocol

  def address(self):
    return '%s://%s:%s' % (protocol, interface, port)

  def connect_output(self, *addresses):
    for address in addresses:
      self.__socket.connect(addresses)

  def start_listening(self, on_recv=None, port=0, protocol='tcp', interface='*'):
    if self.__thread:
      return
    if on_recv:
      self.on_recv = on_recv
    self.__protocol = protocol
    self.__interface = interface
    def listen():
      context = zmq.Context()
      socket = context.socket(zmq.PULL)
      if port:
        self.__port = port
        socket.bind(self.address)
      else:
        self.__port = socket.bind_to_random_port('%s://%s', protocol, interface)
      while True:
        try:
          message = socket.recv()
          if on_recv:
            on_recv(message)
        except Exception as e:
          logging.error(format_exc())
      self.__thread = None
    self.__thread = Thread(target=listen)
    self.__thread.daemon = True
    self.__thread.start()
  
  def send(self, message):
    self.__out_socket.send(message)

  _instances = {}

  @classmethod
  def instance(cls, name='MessageQueue'):
    try:
      return cls._instances[name]
    except:
      cls._instances[name] = cls()
      return cls._instances[name]

########NEW FILE########
__FILENAME__ = create
import login
from toto.invocation import *

@requires('user_id', 'password')
def invoke(handler, params):
  '''Create an account with the given ``user_id`` and ``password`` if no account
  matching the ``user_id`` exists. Any other parameters will be added as
  additional properties of the account. If using a database with a predefined
  schema, make sure they match existing columns, otherwise an error will be
  returned.

  Requires: ``user_id``, ``password``
  '''
  handler.db_connection.create_account(params['user_id'], params['password'], {k: params[k] for k in params})
  return login.invoke(handler, params)

########NEW FILE########
__FILENAME__ = login
from toto.invocation import *

@requires('user_id', 'password')
def invoke(handler, params):
  '''Creates a new session for the account matching ``user_id`` and ``password``. If no
  matching account is found, a "User not found" error will be returned.

  Requires: ``user_id``, ``password``
  '''
  handler.create_session(params['user_id'], params['password'])
  return {'session_id': handler.session.session_id, 'expires': handler.session.expires, 'user_id': handler.session.user_id}

########NEW FILE########
__FILENAME__ = logout
from toto.invocation import *

@authenticated
def invoke(handler, parameters):
  '''Invalidates the current authenticated session. If the request is
  not authenticated, a "Not authorized" error will be returned.
  '''
  handler.db_connection.remove_session(handler.session.session_id)
  return {'authenticated': False}

########NEW FILE########
__FILENAME__ = update
import toto.methods.account.login
from toto.invocation import *

@authenticated
def invoke(handler, params):
  result = {'updated_fields': []}
  if 'new_password' in params:
    handler.db_connection.change_password(params['user_id'], params['password'], params['new_password'])
    result['updated_fields'].append('password')
    result.update(login.invoke(handler, {'user_id': params['user_id'], 'password': params['new_password']}))
    del params['new_password']
  del params['password']
  account = handler.session.get_account()
  for k in params:
    account[k] = params[k]
    result['updated_fields'].append(k)
    account.save()
  return result
  

########NEW FILE########
__FILENAME__ = client_error
import logging
from toto.invocation import *

@requires('client_error', 'client_type')
def invoke(handler, parameters):
  '''A convenince method for writing browser errors
  to Toto's server log. It works with the ``registerErrorHandler()`` method in ``toto.js``.

  The "client_error" parameter should be set to the string to be written to Toto's log.
  Currently, the "client_type" parameter must be set to "browser_js" for an event
  to be written. Otherwise, this method has no effect.

  Requires: ``client_error``, ``client_type``
  '''
  if parameters['client_type'] != 'browser_js':
    return {'logged': False}
  logging.error(str(parameters['client_error']))
  return {'logged': True}

########NEW FILE########
__FILENAME__ = mongodbconnection
import pymongo
from toto.exceptions import *
from toto.session import *
from time import time
from datetime import datetime
import base64
import uuid
import hmac
import hashlib
import toto.secret as secret
from dbconnection import DBConnection

class MongoDBSession(TotoSession):
  _account = None

  class MongoDBAccount(TotoAccount):
    def _load_property(self, *args):
      return self._session._db.accounts.find_one({'user_id': self._session.user_id}, {a: 1 for a in args})

    def _save_property(self, *args):
      self._session._db.accounts.update({'user_id': self._session.user_id}, {'$set': {k: self[k] for k in args}})

  def get_account(self):
    if not self._account:
      self._account = MongoDBSession.MongoDBAccount(self)
    return self._account

  def refresh(self):
    session_data = self._refresh_cache() or self._db.sessions.find_one({'session_id': self.session_id})
    self.__init__(self._db, session_data, self._session_cache)
  
  def save(self):
    if not self._verified:
      raise TotoException(ERROR_NOT_AUTHORIZED, "Not authorized")
    if not self._save_cache(): 
      self._db.sessions.update({'session_id': self.session_id}, {'$set': {'state': TotoSession.dumps(self.state)}})

class MongoDBConnection(DBConnection):

  def _ensure_indexes(self):
    session_indexes = self.db.sessions.index_information()
    if not 'session_id' in session_indexes:
      self.db.sessions.ensure_index('session_id', unique=True, name='session_id')
    if not 'user_id' in session_indexes:
      self.db.sessions.ensure_index('user_id', name='user_id')
    if not 'expires' in session_indexes:
      self.db.sessions.ensure_index('expires', name='expires')
    account_indexes = self.db.accounts.index_information()
    if not 'user_id' in account_indexes:
      self.db.accounts.ensure_index('user_id', name='user_id')
  
  def __init__(self, host, port, database, session_ttl=24*60*60*365, anon_session_ttl=24*60*60, session_renew=0, anon_session_renew=0):
    self.db = pymongo.Connection(host, port)[database]
    self._ensure_indexes()
    self.session_ttl = session_ttl
    self.anon_session_ttl = anon_session_ttl or self.session_ttl
    self.session_renew = session_renew or self.session_ttl
    self.anon_session_renew = anon_session_renew or self.anon_session_ttl

  def create_account(self, user_id, password, additional_values={}, **values):
    if not user_id:
      raise TotoException(ERROR_INVALID_USER_ID, "Invalid user ID.")
    if self.db.accounts.find_one({'user_id': user_id}):
      raise TotoException(ERROR_USER_ID_EXISTS, "User ID already in use.")
    values.update(additional_values)
    values['user_id'] = user_id
    values['password'] = secret.password_hash(password)
    self.db.accounts.insert(values)

  def _load_uncached_data(self, session_id):
    return self.db.sessions.find_one({'session_id': session_id, 'expires': {'$gt': time()}})

  def create_session(self, user_id=None, password=None, verify_password=True):
    if not user_id:
      user_id = ''
    account = user_id and self.db.accounts.find_one({'user_id': user_id})
    if user_id and (not account or (verify_password and not secret.verify_password(password, account['password']))):
      raise TotoException(ERROR_USER_NOT_FOUND, "Invalid user ID or password")
    session_id = MongoDBSession.generate_id()
    expires = time() + (user_id and self.session_ttl or self.anon_session_ttl)
    session_data = {'user_id': user_id, 'expires': expires, 'session_id': session_id}
    if not self._cache_session_data(session_data):
      self.db.sessions.remove({'user_id': user_id, 'expires': {'$lt': time()}})
      self.db.sessions.insert(session_data)
    session = MongoDBSession(self.db, session_data, self._session_cache)
    session._verified = True
    return session

  def retrieve_session(self, session_id, hmac_data=None, data=None):
    session_data = self._load_session_data(session_id)
    if not session_data:
      return None
    user_id = session_data['user_id']
    if user_id and data and hmac_data != base64.b64encode(hmac.new(str(user_id), data, hashlib.sha1).digest()):
      raise TotoException(ERROR_INVALID_HMAC, "Invalid HMAC")
    expires = time() + (user_id and self.session_renew or self.anon_session_renew)
    if session_data['expires'] < expires:
      session_data['expires'] = expires
      if not self._cache_session_data(session_data):
        self.db.sesions.update({'session_id': session_id}, {'$set': {'expires': session_data['expires']}})
    session = MongoDBSession(self.db, session_data, self._session_cache)
    session._verified = True
    return session

  def remove_session(self, session_id):
    self.db.sessions.remove({'session_id': session_id})

  def clear_sessions(self, user_id):
    self.db.sessions.remove({'user_id': user_id})

  def change_password(self, user_id, password, new_password):
    account = self.db.accounts.find_one({'user_id': user_id})
    if not account or not secret.verify_password(password, account['password']):
      raise TotoException(ERROR_USER_NOT_FOUND, "Invalid user ID or password")
    self.db.accounts.update({'user_id': user_id}, {'$set': {'password': secret.password_hash(new_password)}})
    self.clear_sessions(user_id)

  def generate_password(self, user_id):
    account = self.db.accounts.find_one({'user_id': user_id})
    if not account:
      raise TotoException(ERROR_USER_NOT_FOUND, "Invalid user ID or password")
    pass_chars = string.ascii_letters + string.digits 
    new_password = ''.join([random.choice(pass_chars) for x in xrange(10)])
    self.db.accounts.update({'user_id': user_id}, {'$set': {'password': secret.password_hash(new_password)}})
    self.clear_sessions(user_id)
    return new_password

########NEW FILE########
__FILENAME__ = mysqldbconnection
from torndb import *
from toto.exceptions import *
from toto.session import *
from time import time, mktime
from datetime import datetime
from dbconnection import DBConnection
from uuid import uuid4
import toto.secret as secret
import base64
import uuid
import hmac
import hashlib
import random
import string

class MySQLdbSession(TotoSession):
  _account = None

  class MySQLdbAccount(TotoAccount):
    
    def __init__(self, session):
      super(MySQLdbSession.MySQLdbAccount, self).__init__(session)
      self._properties['account_id'] = session.account_id

    def _load_property(self, *args):
      return self._session._db.get('select ' + ', '.join(args) + ' from account where account_id = %s', self._session.account_id)

    def _save_property(self, *args):
      self._session._db.execute('update account set ' + ', '.join(['%s = %%s' % k for k in args]) + ' where account_id = %s', *([self[k] for k in args] + [self._session.account_id,]))

    def __setitem__(self, key, value):
      if key != 'account_id':
        super(MySQLdbSession.MySQLdbAccount, self).__setitem__(key, value)
    
  def __init__(self, db, session_data, session_cache=None):
    super(MySQLdbSession, self).__init__(db, session_data, session_cache)
    self.account_id = session_data['account_id']

  def get_account(self):
    if not self._account:
      self._account = MySQLdbSession.MySQLdbAccount(self)
    return self._account

  def session_data(self):
   return {'user_id': self.user_id, 'expires': self.expires, 'session_id': self.session_id, 'state': TotoSession.dumps(self.state), 'account_id': self.account_id} 
  
  def refresh(self):
    session_data = self._refresh_cache() or self.db.get("select session.session_id, session.expires, session.state, account.user_id, account.account_id from session join account on account.account_id = session.account_id where session.session_id = %s", session_id)
    self.__init__(self._db, session_data, self._session_cache)

  def save(self):
    if not self._verified:
      raise TotoException(ERROR_NOT_AUTHORIZED, "Not authorized")
    if not self._save_cache():
      self._db.execute("update session set state = %s where session_id = %s", TotoSession.dumps(self.state), self.session_id)

class MySQLdbConnection(DBConnection):

  def create_tables(self, database):
    if not self.db.get('''show tables like "account"'''):
      self.db.execute(''.join(['''create table if not exists `account` (''',
        self.uuid_account_id and '''`account_id` binary(16) not null,''' or '''`account_id` int(8) unsigned not null auto_increment,''',
        '''`password` char(48) default null,
        `user_id` varchar(191) not null,
        primary key (`account_id`),
        unique key `user_id_unique` (`user_id`),
        index `user_id_password` (`user_id`, `password`)
      )''']))
    if not self.db.get('''show tables like "session"'''):
      self.db.execute(''.join(['''create table if not exists `session` (
        `session_id` char(22) not null,''',
        self.uuid_account_id and '''`account_id` binary(16) not null,''' or '''`account_id` int(8) unsigned not null,''',
        '''`expires` double not null,
        `state` blob,
        primary key (`session_id`),
        index (`expires`),
        foreign key (`account_id`) references `account`(`account_id`)
      )''']))

  def __init__(self, host, database, username, password, session_ttl=24*60*60*365, anon_session_ttl=24*60*60, session_renew=0, anon_session_renew=0, uuid_account_id=False):
    self.db = Connection(host, database, username, password)
    self.uuid_account_id = uuid_account_id
    self.create_tables(database)
    self.session_ttl = session_ttl
    self.anon_session_ttl = anon_session_ttl or self.session_ttl
    self.session_renew = session_renew or self.session_ttl
    self.anon_session_renew = anon_session_renew or self.anon_session_ttl

  def create_account(self, user_id, password, additional_values={}, **values):
    if not user_id:
      raise TotoException(ERROR_INVALID_USER_ID, "Invalid user ID.")
    user_id = user_id.lower()
    if self.db.get("select account_id from account where user_id = %s", user_id):
      raise TotoException(ERROR_USER_ID_EXISTS, "User ID already in use.")
    additional_values.pop('account_id', None)
    values.update(additional_values)
    values['user_id'] = user_id
    values['password'] = secret.password_hash(password)
    if self.uuid_account_id:
      values['account_id'] = uuid4().bytes
    self.db.execute("insert into account (" + ', '.join([k for k in values]) + ") values (" + ','.join(['%s' for k in values]) + ")", *[values[k] for k in values])

  def _load_uncached_data(self, session_id):
    return self.db.get("select session.session_id, session.expires, session.state, account.user_id, account.account_id from session join account on account.account_id = session.account_id where session.session_id = %s and session.expires > %s", session_id, time())

  def create_session(self, user_id=None, password=None, verify_password=True):
    if not user_id:
      user_id = ''
    user_id = user_id.lower()
    account = user_id and self.db.get("select account_id, password from account where user_id = %s", user_id)
    if user_id and (not account or (verify_password and not secret.verify_password(password, account['password']))):
      raise TotoException(ERROR_USER_NOT_FOUND, "Invalid user ID or password")
    session_id = MySQLdbSession.generate_id()
    expires = time() + (user_id and self.session_ttl or self.anon_session_ttl)
    session_data = {'user_id': user_id, 'expires': expires, 'session_id': session_id, 'account_id': account['account_id']}
    if not self._cache_session_data(session_data):
      self.db.execute("delete from session where account_id = %s and expires <= %s", account['account_id'], time())
      self.db.execute("insert into session (account_id, expires, session_id) values (%s, %s, %s)", account['account_id'], expires, session_id)
    session = MySQLdbSession(self.db, session_data, self._session_cache)
    session._verified = True
    return session

  def retrieve_session(self, session_id, hmac_data=None, data=None):
    session_data = self._load_session_data(session_id)
    if not session_data:
      return None
    user_id = session_data['user_id']
    if user_id and data and hmac_data != base64.b64encode(hmac.new(str(user_id), data, hashlib.sha1).digest()):
      raise TotoException(ERROR_INVALID_HMAC, "Invalid HMAC")
    expires = time() + (user_id and self.session_renew or self.anon_session_renew)
    if session_data['expires'] < expires:
      session_data['expires'] = expires
      if not self._cache_session_data(session_data):
        self.db.execute("update session set expires = %s where session_id = %s", session_data['expires'], session_id)
    session = MySQLdbSession(self.db, session_data, self._session_cache)
    session._verified = True
    return session

  def remove_session(self, session_id):
    self.db.execute("delete from session where session_id = %s", session_id)

  def clear_sessions(self, user_id):
    user_id = user_id.lower()
    self.db.execute("delete from session using session join account on account.account_id = session.account_id where account.user_id = %s", user_id)

  def change_password(self, user_id, password, new_password):
    user_id = user_id.lower()
    account = self.db.get("select account_id, user_id, password from account where user_id = %s", user_id)
    if not account or not secret.verify_password(password, account['password']):
      raise TotoException(ERROR_USER_NOT_FOUND, "Invalid user ID or password")
    self.db.execute("update account set password = %s where account_id = %s", secret.password_hash(new_password), account['account_id'])
    self.clear_sessions(user_id)

  def generate_password(self, user_id):
    user_id = user_id.lower()
    account = self.db.get("select account_id, user_id from account where user_id = %s", user_id)
    if not account:
      raise TotoException(ERROR_USER_NOT_FOUND, "Invalid user ID")
    pass_chars = string.ascii_letters + string.digits
    new_password = ''.join([random.choice(pass_chars) for x in xrange(10)])
    self.db.execute("update account set password = %s where account_id = %s", secret.password_hash(new_password), account['account_id'])
    self.clear_sessions(user_id)
    return new_password

########NEW FILE########
__FILENAME__ = options
from tornado.options import define, options
import logging

def safe_define(*args, **kwargs):
  try:
    define(*args, **kwargs)
  except Exception as e:
    logging.error(str(e))

########NEW FILE########
__FILENAME__ = postgresconnection
from toto.exceptions import *
from toto.session import *
from time import time, mktime
from datetime import datetime
from psycopg2.pool import ThreadedConnectionPool
from itertools import izip
import toto.secret as secret
import base64
import uuid
import hmac
import hashlib
import random
import string
from dbconnection import DBConnection

def pg_get(self, query, parameters=None):
  conn = self.getconn()
  cur = conn.cursor()
  cur.execute(query, parameters)
  result = cur.fetchone()
  self.putconn(conn)
  return result and dict(izip((d[0] for d in cur.description), result))
ThreadedConnectionPool.get = pg_get

def pg_execute(self, query, parameters=None):
  conn = self.getconn()
  cur = conn.cursor()
  cur.execute(query, parameters)
  conn.commit()
  self.putconn(conn)
ThreadedConnectionPool.execute = pg_execute

def pg_query(self, query, parameters=None):
  conn = self.getconn()
  cur = conn.cursor()
  cur.execute(query, parameters)
  columns = [d[0] for d in cur.description]
  for r in cur:
    yield dict(izip(columns, r))
  self.putconn(conn)
ThreadedConnectionPool.query = pg_query


class PostgresSession(TotoSession):
  _account = None

  class PostgresAccount(TotoAccount):
    
    def __init__(self, session):
      super(PostgresSession.PostgresAccount, self).__init__(session)
      self._properties['account_id'] = session.account_id

    def _load_property(self, *args):
      return self._session._db.get('select ' + ', '.join(args) + ' from account where account_id = %s', (self._session.account_id))

    def _save_property(self, *args):
      self._session._db.execute('update account set ' + ', '.join(['%s = %%s' % k for k in args]) + ' where account_id = %s', ([self[k] for k in args] + [self._session.account_id,]))

    def __setitem__(self, key, value):
      if key != 'account_id':
        super(PostgresSession.PostgresAccount, self).__setitem__(key, value)
    
  def __init__(self, db, session_data, session_cache=None):
    super(PostgresSession, self).__init__(db, session_data, session_cache)
    self.account_id = session_data['account_id']

  def get_account(self):
    if not self._account:
      self._account = PostgresSession.PostgresAccount(self)
    return self._account

  def session_data(self):
    return {'user_id': self.user_id, 'expires': self.expires, 'session_id': self.session_id, 'state': TotoSession.dumps(self.state), 'account_id': self.account_id}

  def refresh(self):
    session_data = self._refresh_cache() or self.db.get("select session.session_id, session.expires, session.state, account.user_id, account.account_id from session join account on account.account_id = session.account_id where session.session_id = %s", (session_id,))
    self.__init__(session_data, self._session_cache)

  def save(self):
    if not self._verified:
      raise TotoException(ERROR_NOT_AUTHORIZED, "Not authorized")
    if not self._save_cache():
      self._db.execute("update session set state = %s where session_id = %s", (TotoSession.dumps(self.state), self.session_id))

class PostgresConnection(DBConnection):

  def create_tables(self):
    if not self.db.get("select table_name from information_schema.tables where table_schema = 'public' and table_name = 'account'"):
      self.db.execute('''create table if not exists account (
        account_id bigserial primary key,
        password char(48) default null,
        user_id varchar(45) not null,
        unique (user_id)
      );''')
    if not self.db.get("select table_name from information_schema.tables where table_schema = 'public' and table_name = 'session'"):
      self.db.execute('''create table if not exists session (
        session_id char(22) not null primary key,
        account_id bigint not null references account (account_id),
        expires double precision not null,
        state bytea
      );''')
      self.db.execute('create index session_expires on session using btree (expires);')

  def __init__(self, host, port, database, username, password, session_ttl=24*60*60*365, anon_session_ttl=24*60*60, session_renew=0, anon_session_renew=0, min_connections=1, max_connections=10):
    self.db = ThreadedConnectionPool(min_connections, max_connections, database=database, user=username, password=password, host=host, port=port)
    self.create_tables()
    self.session_ttl = session_ttl
    self.anon_session_ttl = anon_session_ttl or self.session_ttl
    self.session_renew = session_renew or self.session_ttl
    self.anon_session_renew = anon_session_renew or self.anon_session_ttl

  def create_account(self, user_id, password, additional_values={}, **values):
    if not user_id:
      raise TotoException(ERROR_INVALID_USER_ID, "Invalid user ID.")
    user_id = user_id.lower()
    if self.db.get("select account_id from account where user_id = %s", (user_id,)):
      raise TotoException(ERROR_USER_ID_EXISTS, "User ID already in use.")
    values.update(additional_values)
    values['user_id'] = user_id
    values['password'] = secret.password_hash(password)
    self.db.execute("insert into account (" + ', '.join([k for k in values]) + ") values (" + ','.join(['%s' for k in values]) + ")", [values[k] for k in values])

  def _load_uncached_data(self, session_id):
    return self.db.get("select session.session_id, session.expires, session.state, account.user_id, account.account_id from session join account on account.account_id = session.account_id where session.session_id = %s and session.expires > %s", (session_id, time()))

  def create_session(self, user_id=None, password=None, verify_password=True):
    if not user_id:
      user_id = ''
    user_id = user_id.lower()
    account = user_id and self.db.get("select account_id, password from account where user_id = %s", (user_id,))
    if user_id and (not account or (verify_password and not secret.verify_password(password, account['password']))):
      raise TotoException(ERROR_USER_NOT_FOUND, "Invalid user ID or password")
    session_id = PostgresSession.generate_id()
    expires = time() + (user_id and self.session_ttl or self.anon_session_ttl)
    session_data = {'user_id': user_id, 'expires': expires, 'session_id': session_id, 'account_id': account['account_id']}
    if not self._cache_session_data(session_data):
      self.db.execute("delete from session where account_id = %s and expires <= %s", (account['account_id'], time()))
      self.db.execute("insert into session (account_id, expires, session_id) values (%s, %s, %s)", (account['account_id'], expires, session_id))
    session = PostgresSession(self.db, session_data, self._session_cache)
    session._verified = True
    return session

  def retrieve_session(self, session_id, hmac_data=None, data=None):
    session_data = self._load_session_data(session_id)
    if not session_data:
      return None
    user_id = session_data['user_id']
    if user_id and data and hmac_data != base64.b64encode(hmac.new(str(user_id), data, hashlib.sha1).digest()):
      raise TotoException(ERROR_INVALID_HMAC, "Invalid HMAC")
    expires = time() + (user_id and self.session_renew or self.anon_session_renew)
    if session_data['expires'] < expires:
      session_data['expires'] = expires
      if not self._cache_session_data(session_data):
        self.db.execute("update session set expires = %s where session_id = %s", (session_data['expires'], session_id))
    session = PostgresSession(self.db, session_data, self._session_cache)
    session._verified = True
    return session

  def remove_session(self, session_id):
    self.db.execute("delete from session where session_id = %s", (session_id,))

  def clear_sessions(self, user_id):
    user_id = user_id.lower()
    self.db.execute("delete from session using session join account on account.account_id = session.account_id where account.user_id = %s", (user_id,))

  def change_password(self, user_id, password, new_password):
    user_id = user_id.lower()
    account = self.db.get("select account_id, user_id, password from account where user_id = %s", (user_id,))
    if not account or not secret.verify_password(password, account['password']):
      raise TotoException(ERROR_USER_NOT_FOUND, "Invalid user ID or password")
    self.db.execute("update account set password = %s where account_id = %s", (secret.password_hash(new_password), account['account_id']))
    self.clear_sessions(user_id)

  def generate_password(self, user_id):
    user_id = user_id.lower()
    account = self.db.get("select account_id, user_id from account where user_id = %s", (user_id,))
    if not account:
      raise TotoException(ERROR_USER_NOT_FOUND, "Invalid user ID")
    pass_chars = string.ascii_letters + string.digits
    new_password = ''.join([random.choice(pass_chars) for x in xrange(10)])
    self.db.execute("update account set password = %s where account_id = %s", (secret.password_hash(new_password), account['account_id']))
    self.clear_sessions(user_id)
    return new_password

########NEW FILE########
__FILENAME__ = pycassa_util
from pycassa import ColumnFamily
from itertools import islice

def get_all(self, key, column_count=100, yield_batch=False, **kwargs):
  kwargs['key'] = key
  kwargs['column_count'] = column_count
  results = self.get(**kwargs)
  result_count = len(results)
  if yield_batch:
    k = next(reversed(results))
    yield results
  else:
    for k, v in results.iteritems():
      yield k, v
  while result_count == column_count:
    kwargs['column_start'] = k
    results = self.get(**kwargs)
    result_count = len(results)
    if result_count:
      results.popitem(False)
    if yield_batch:
      k = next(reversed(results))
      yield results
    else:
      for k, v in results.iteritems():
        yield k, v

ColumnFamily.get_all = get_all

def get_columns(self, key, columns, column_count=100, yield_batch=False, **kwargs):
  kwargs['key'] = key
  kwargs['column_count'] = column_count
  index = 0
  while index < len(columns):
    kwargs['columns'] = columns[index:index + column_count]
    if yield_batch:
      yield self.get(**kwargs)
    else:
      for k, v in self.get(**kwargs).iteritems():
        yield k, v
    index += column_count

ColumnFamily.get_columns = get_columns

def xmultiget(self, keys, buffer_size=0, *args, **kwargs):
  buffer_size = buffer_size or self.buffer_size
  key_iter = iter(keys)
  key_batch = list(islice(key_iter, buffer_size))
  while key_batch:
    for k, v in self.multiget(key_batch, buffer_size=buffer_size, *args, **kwargs).iteritems():
      yield k, v
    key_batch = list(islice(key_iter, buffer_size))

ColumnFamily.xmultiget = xmultiget

def get_page(self, key, last_column=None, *args, **kwargs):
  if last_column is None:
    return self.get(key, *args, **kwargs)
  else:
    results = self.get(key, column_start=last_column, *args, **kwargs)
    try:
      del results[last_column]
    except:
      pass
    return results

ColumnFamily.get_page = get_page

########NEW FILE########
__FILENAME__ = redisconnection
import redis
from toto.exceptions import *
from toto.session import *
from time import time
from datetime import datetime
from dbconnection import DBConnection
import base64
import uuid
import hmac
import hashlib
import toto.secret as secret

def _account_key(user_id):
  return 'account:%s' % user_id

def _session_key(session_id):
  return 'session:%s' % session_id

class RedisSession(TotoSession):
  _account = None

  class RedisAccount(TotoAccount):
    def _load_property(self, *args):
      return dict(zip(args, self._session._db.hmget(_account_key(self._session.user_id), args)))

    def _save_property(self, *args):
      self._session._db.hmset(_account_key(self._session.user_id), {k: self[k] for k in args})

  def get_account(self):
    if not self._account:
      self._account = RedisSession.RedisAccount(self)
    return self._account

  def refresh(self):
    session_data = self._refresh_cache() or TotoSession.loads(self._db.get(_session_key(self.session_id)))
    self.__init__(self._db, session_data, self._session_cache)
  
  def save(self):
    if not self._verified:
      raise TotoException(ERROR_NOT_AUTHORIZED, "Not authorized")
    if not self._save_cache():
      self._db.setex(_session_key(self.session_id), int(self.expires - time()), TotoSession.dumps(self.session_data()))

class RedisConnection(DBConnection):
  
  def __init__(self, host='localhost', port=6379, database=0, session_ttl=24*60*60*365, anon_session_ttl=24*60*60, session_renew=0, anon_session_renew=0):
    self.db = redis.StrictRedis(host=host, port=port, db=database)
    self.session_ttl = session_ttl
    self.anon_session_ttl = anon_session_ttl or self.session_ttl
    self.session_renew = session_renew or self.session_ttl
    self.anon_session_renew = anon_session_renew or self.anon_session_ttl

  def create_account(self, user_id, password, additional_values={}, **values):
    if not user_id:
      raise TotoException(ERROR_INVALID_USER_ID, "Invalid user ID.")
    user_id = user_id.lower()
    account_key = _account_key(user_id)
    if self.db.exists(account_key):
      raise TotoException(ERROR_USER_ID_EXISTS, "User ID already in use.")
    values.update(additional_values)
    values['user_id'] = user_id
    values['password'] = secret.password_hash(password)
    self.db.hmset(account_key, values)

  def _load_uncached_data(self, session_id):
    data = self.db.get(_session_key(session_id))
    if data:
      return TotoSession.loads(data)
    return None

  def create_session(self, user_id=None, password=None, verify_password=True):
    user_id = user_id.lower()
    if not user_id:
      user_id = ''
    account_key = _account_key(user_id)
    account = user_id and password and self.db.hmget(account_key, 'user_id', 'password')
    if user_id and (account[0] != user_id or (verify_password and not secret.verify_password(password, account[1]))):
      raise TotoException(ERROR_USER_NOT_FOUND, "Invalid user ID or password")
    session_id = RedisSession.generate_id()
    ttl = (user_id and self.session_ttl or self.anon_session_ttl)
    expires = time() + ttl
    session_key = _session_key(session_id)
    session_data = {'user_id': user_id, 'expires': expires, 'session_id': session_id}
    if not self._cache_session_data(session_data):
      self.db.setex(session_key, int(ttl), TotoSession.dumps(session_data))
    session = RedisSession(self.db, session_data, self._session_cache)
    session._verified = True
    return session

  def retrieve_session(self, session_id, hmac_data=None, data=None):
    session_key = _session_key(session_id)
    session_data = self._load_session_data(session_id)
    if not session_data:
      return None
    user_id = session_data['user_id']
    if user_id and data and hmac_data != base64.b64encode(hmac.new(str(user_id), data, hashlib.sha1).digest()):
      raise TotoException(ERROR_INVALID_HMAC, "Invalid HMAC")
    ttl = user_id and self.session_renew or self.anon_session_renew
    if session_data['expires'] < (time() + ttl):
      session_data['expires'] = time() + ttl
      if not self._cache_session_data(session_data):
        self.db.setex(session_key, int(ttl), TotoSession.dumps(session_data))
    session = RedisSession(self.db, session_data, self._session_cache)
    session._verified = True
    return session

  def remove_session(self, session_id):
    session_key = _session_key(session_id)
    self.db.delete(session_key)

  def clear_sessions(self, user_id):
    pass

  def change_password(self, user_id, password, new_password):
    user_id = user_id.lower()
    account_key = _account_key(user_id)
    account = self.db.hmget(account_key, 'user_id', 'password')
    if account[0] != user_id or not secret.verify_password(password, account[1]):
      raise TotoException(ERROR_USER_NOT_FOUND, "Invalid user ID or password")
    self.db.hset(account_key, 'password', secret.password_hash(new_password))

  def generate_password(self, user_id):
    user_id = user_id.lower()
    account_key = _account_key(user_id)
    if self.db.hget(account_key, 'user_id') != user_id:
      raise TotoException(ERROR_USER_NOT_FOUND, "Invalid user ID or password")
    pass_chars = string.ascii_letters + string.digits 
    new_password = ''.join([random.choice(pass_chars) for x in xrange(10)])
    self.db.hset(account_key, 'password', secret.password_hash(new_password))
    return new_password

class RedisSessionCache(TotoSessionCache):

  def __init__(self, db):
    '''``db`` must be an instance of ``redis.StrictRedis`` initialized to the target database.
    '''
    self.db = db

  def store_session(self, session_data):
    session_key = _session_key(session_data['session_id'])
    self.db.setex(session_key, int(session_data['expires'] - time()), TotoSession.dumps(session_data))

  def load_session(self, session_id):
    session_key = _session_key(session_id)
    session_data = self.db.get(session_key)
    if not session_data:
      return None
    else:
      return TotoSession.loads(session_data)
    

########NEW FILE########
__FILENAME__ = secret
from pbkdf2 import crypt

def password_hash(secret):
  return crypt(secret)

def verify_password(secret, pwhash):
  return pwhash == crypt(secret, pwhash)

########NEW FILE########
__FILENAME__ = server
'''The Toto server and handler classes are designed to simplify most of the boilerplate that comes with
building web services so you can focus on the important parts specific to your application.

Most of the time you'll only need this script to start your server::

  from toto.server import TotoServer
  
  TotoServer('settings.conf').run()

Methods, startup functions and databases can all be configured with the conf file.

Run your startup script with --help to see all available options.
'''

import os
import sys
import logging
import tornado
from tornado.web import Application
from tornado.ioloop import IOLoop
from tornado.httpserver import HTTPServer
from tornado.options import options
from tornado.netutil import bind_sockets
from handler import TotoHandler
from toto.service import TotoService, process_count
from dbconnection import configured_connection
from toto.options import safe_define

safe_define("port", default=8888, help="The port this server will bind to.")
safe_define("root", default='/', help="The path to run the server on. This can be helpful when hosting multiple services on the same domain")
safe_define("method_module", default='methods', help="The root module to use for method lookup")
safe_define("cookie_secret", default=None, type=str, help="A long random string to use as the HMAC secret for secure cookies, ignored if use_cookies is not enabled")
safe_define("autoreload", default=False, help="This option autoreloads modules as changes occur - useful for debugging.")
safe_define("remote_event_receivers", type=str, help="A comma separated list of remote event address that this event manager should connect to. e.g.: 'tcp://192.168.1.2:8889'", multiple=True)
safe_define("event_mode", default='off', metavar='off|on|only', help="This option enables or disables the event system, also providing an option to launch this server as an event server only")
safe_define("event_init_module", default=None, type=str, help="If defined, this module's 'invoke' function will be called with the EventManager instance after the main event handler is registered (e.g.: myevents.setup)")
safe_define("event_port", default=8999, help="The address to listen to event connections on - due to message queuing, servers use the next higher port as well")
safe_define("startup_function", default=None, type=str, help="An optional function to run on startup - e.g. module.function. The function will be called for each server instance before the server starts listening as function(connection=<active database connection>, application=<tornado.web.Application>).")
safe_define("use_cookies", default=False, help="Select whether to use cookies for session storage, replacing the x-toto-session-id header. You must set cookie_secret if using this option and secure_cookies is not set to False")
safe_define("secure_cookies", default=True, help="If using cookies, select whether or not they should be secure. Secure cookies require cookie_secret to be set")
safe_define("cookie_domain", default=None, type=str, help="The value to use for the session cookie's domain attribute - e.g. '.example.com'")
safe_define("socket_opened_method", default=None, type=str, help="An optional function to run when a new web socket is opened, the socket handler will be passed as the only argument")
safe_define("socket_closed_method", default=None, type=str, help="An optional function to run when a web socket is closed, the socket handler will be passed as the only argument")
safe_define("socket_method_module", default=None, type=str, help="The root module to use for web socket method lookup")
safe_define("use_web_sockets", default=False, help="Whether or not web sockets should be installed as an alternative way to call methods")
safe_define("socket_path", default='websocket', help="The path to use for websocket connections")
safe_define("client_side_worker_path", default="", help="The path to use for client side worker connections - functionality will be disabled if this is not set.")

class TotoServer(TotoService):
  '''Instances can be configured in three ways:

  1. (Most common) Pass the path to a config file as the first parameter to the constructor.
  2. Pass config parameters as command line arguments to the initialization script.
  3. Pass keyword arguments to the constructor.

  Precidence is as follows:

  Keyword args, config file, command line
  '''

  def __init__(self, conf_file=None, **kwargs):
    module_options = {'method_module', 'socket_method_module', 'event_init_module'}
    function_options = {'startup_function', 'socket_opened_method', 'socket_closed_method'}
    original_argv, sys.argv = sys.argv, [i for i in sys.argv if i.strip('-').split('=')[0] in module_options]
    self._load_options(conf_file, **{i: kwargs[i] for i in kwargs if i in module_options})
    modules = {getattr(options, i) for i in module_options if getattr(options, i)}
    for module in modules:
      __import__(module)
    function_modules = {getattr(options, i).rsplit('.', 1)[0] for i in function_options if getattr(options, i)}
    for module in function_modules:
      __import__(module)
    sys.argv = original_argv
    #clear root logger handlers to prevent duplicate logging if user has specified a log file
    super(TotoServer, self).__init__(conf_file, **kwargs)
    #clear method_module references so we can fully reload with new options
    for module in modules:
      for i in (m for m in sys.modules.keys() if m.startswith(module)):
        del sys.modules[i]
    for module in function_modules:
      for i in (m for m in sys.modules.keys() if m.startswith(module)):
        del sys.modules[i]
    #prevent the reloaded module from re-defining options
    define, tornado.options.define = tornado.options.define, lambda *args, **kwargs: None
    self.__event_init = options.event_init_module and __import__(options.event_init_module) or None
    TotoHandler.configure()
    if options.use_web_sockets:
      from sockets import TotoSocketHandler
      TotoSocketHandler.configure()
    if options.client_side_worker_path:
      from clientsideworker import ClientSideWorkerSocketHandler
      ClientSideWorkerSocketHandler.configure()
    tornado.options.define = define

  def prepare(self):
    self.__pending_sockets = bind_sockets(options.port)

  def main_loop(self):
    db_connection = configured_connection()
  
    application_settings = {}
    if options.cookie_secret:
      application_settings['cookie_secret'] = options.cookie_secret
    if options.autoreload:
      application_settings['debug'] = True

    handlers = []
    if options.use_web_sockets:
      handlers.append(('%s/?([^/]?[\w\./]*)' % os.path.join(options.root, options.socket_path), TotoSocketHandler, {'db_connection': db_connection}))
    if options.client_side_worker_path:
      handlers.append((os.path.join(options.root, options.client_side_worker_path), ClientSideWorkerSocketHandler))
    if not options.event_mode == 'off':
      from toto.events import EventManager
      event_manager = EventManager.instance()
      event_manager.address = 'tcp://*:%s' % (options.event_port + self.service_id)
      event_manager.start_listening()
      for i in xrange(process_count()):
        event_manager.register_server('tcp://127.0.0.1:%s' % (options.event_port + i))
      if options.remote_event_receivers:
        for address in options.remote_event_receivers:
          event_manager.register_server(address)
      init_module = self.__event_init
      if init_module:
        init_module.invoke(event_manager)
    if not options.event_mode == 'only':
      handlers.append(('%s/?([^/]?[\w\./]*)' % options.root.rstrip('/'), TotoHandler, {'db_connection': db_connection}))
    
    application = Application(handlers, **application_settings)
    
    if options.startup_function:
      startup_path = options.startup_function.rsplit('.')
      __import__(startup_path[0]).__dict__[startup_path[1]](db_connection=db_connection, application=application)
  
    server = HTTPServer(application)
    server.add_sockets(self.__pending_sockets)
    print "Starting server %d on port %s" % (self.service_id, options.port)
    IOLoop.instance().start()

########NEW FILE########
__FILENAME__ = service
'''``TotoService`` can be used to write general processes that take advantage of the process creation/management features
  used by ``TotoServer`` and ``TotoWorker`` - the two built in subclasses of ``TotoService``.  ``TotoService`` subclasses can be
  run with the ``--start`` (or ``--stop``)  and ``--processes`` options
  to start the service as a daemon process or run multiple instances simultaneously.
  
  To run a subclass of ``TotoService`` create a script like this::

    from toto.service import TotoService

    class MyServiceSubclass(TotoService):

      def main_loop(self):
        while 1:
          #run some job continuously

    MyServiceSubclass('conf_file.conf').run()
'''

import os
import tornado
import logging
from tornado.options import define, options
from multiprocessing import Process, cpu_count
from time import sleep

define("daemon", metavar='start|stop|restart', help="Start, stop or restart this script as a daemon process. Use this setting in conf files, the shorter start, stop, restart aliases as command line arguments. Requires the multiprocessing module.")
define("processes", default=1, help="The number of daemon processes to run")
define("pidfile", default="toto.daemon.pid", help="The path to the pidfile for daemon processes will be named <path>.<num>.pid (toto.daemon.pid -> toto.daemon.0.pid)")
define("start", default=False, help="Alias for daemon=start for command line usage - overrides daemon setting.")
define("stop", default=False, help="Alias for daemon=start for command line usage - overrides daemon setting.")
define("restart", default=False, help="Alias for daemon=start for command line usage - overrides daemon setting.")
define("nodaemon", default=False, help="Alias for daemon='' for command line usage - overrides daemon setting.")
define("debug", default=False, help="Set this to true to prevent Toto from nicely formatting generic errors. With debug=True, errors will print to the command line")

#convert p to the absolute path, insert ".i" before the last "." or at the end of the path
def pid_path(i):
  '''Used to generate PID files for daemonized TotoServices. Child processes with PID files
  matching the paths returned by this function will be killed with SIGTERM when the server daemon process is stopped using the
  ``--stop`` or ``--daemon=stop`` arguments::

    proc = Process()
    proc.start()
    with open(pid_path(process_count() + 1), 'wb') as f:
      f.write(str(proc.pid))
  
  Note that ``i`` must be an integer.
  '''
  (d, f) = os.path.split(os.path.abspath(options.pidfile))
  components = f.rsplit('.', 1)
  f = '%s.%s' % (components[0], i)
  if len(components) > 1:
    f += "." + components[1]
  return os.path.join(d, f)

def process_count():
  '''Returns the number of service processes that will run with the current configuration. This will match
  the ``--processes=n`` option if n >= 0. Otherwise ``multiprocessing.cpu_count()`` will be used.
  '''
  return options.processes if options.processes >= 0 else cpu_count()


class TotoService(object):
  '''Subclass ``TotoService`` to create a service that can be easily daemonised or
  ran in multiple processes simultaneously.
  '''

  def _load_options(self, conf_file=None, final=True, **kwargs):
    for k in kwargs:
      setattr(options, k, kwargs[k])
    if conf_file:
      tornado.options.parse_config_file(conf_file, final=False)
    tornado.options.parse_command_line(final=final)
    if options.start:
      setattr(options, 'daemon', 'start')
    elif options.stop:
      setattr(options, 'daemon', 'stop')
    elif options.restart:
      setattr(options, 'daemon', 'restart')
    elif options.nodaemon:
      setattr(options, 'daemon', '')

  def __init__(self, conf_file=None, **kwargs):
    if options.log_file_prefix:
      root_logger = logging.getLogger()
      for handler in [h for h in root_logger.handlers]:
        root_logger.removeHandler(handler)
    self._load_options(conf_file, **kwargs)

  def __run_service(self, pidfile=None):

    def start_server_process(pidfile, service_id=0):
      self.service_id = service_id
      self.main_loop()
      if pidfile:
        os.remove(pidfile)
    count = process_count()
    processes = []
    pidfiles = options.daemon and [pid_path(i) for i in xrange(1, count + 1)] or []
    self.prepare()
    for i in xrange(count):
      proc = Process(target=start_server_process, args=(pidfiles and pidfiles[i], i))
      proc.daemon = True
      processes.append(proc)
      proc.start()
    else:
      print "Starting %s %s process%s." % (count, self.__class__.__name__, count > 1 and 'es' or '')
    if options.daemon:
      i = 1
      for proc in processes:
        with open(pidfiles[i - 1], 'w') as f:
          f.write(str(proc.pid))
        i += 1
    for proc in processes:
      proc.join()
    self.finish()
    if pidfile:
      os.remove(pidfile)

  def run(self): 
    '''Start the service. Depending on the initialization options, this may run more than one
    service process.
    '''
    if options.daemon:
      import multiprocessing
      import signal, re

      pattern = pid_path(r'\d+').replace('.', r'\.')
      piddir = os.path.dirname(pattern).replace('\\.', '.')
      master_pidfile = pid_path('master')

      if options.daemon == 'stop' or options.daemon == 'restart':
        existing_pidfiles = [pidfile for pidfile in (os.path.join(piddir, fn) for fn in os.listdir(piddir)) if re.match(pattern, pidfile)]
        try:
          with open(master_pidfile, 'rb') as f:
            master_pid = int(f.read())
        except:
          master_pid = 0
        for pidfile in existing_pidfiles:
          try:
            with open(pidfile, 'r') as f:
              pid = int(f.read())
            try:
              os.kill(pid, signal.SIGTERM)
            except OSError as e:
              if e.errno != 3:
                raise
            print "Stopped %s %s" % (self.__class__.__name__, pid)
            os.remove(pidfile)
          except (OSError, IOError) as e:
            if e.errno != 2:
              raise
        if not existing_pidfiles and master_pid:
          try:
            os.kill(master_pid, signal.SIGTERM)
          except OSError as e:
            if e.errno != 3:
              raise
          os.remove(master_pidfile)
          print 'Force stopped %s %s' % (self.__class__.__name__, master_pid)
        else:
          while os.path.exists(master_pidfile):
            sleep(0.01)

      if options.daemon == 'start' or options.daemon == 'restart':
        existing_pidfiles = [pidfile for pidfile in (os.path.join(piddir, fn) for fn in os.listdir(piddir)) if re.match(pattern.replace(r'\d', r'[\w\d]'), pidfile)]
        if existing_pidfiles:
          print "Not starting %s, pidfile%s exist%s at %s" % (self.__class__.__name__, len(existing_pidfiles) > 1 and 's' or '', len(existing_pidfiles) == 1 and 's' or '', ', '.join(existing_pidfiles))
          return
        #fork and only continue on child process
        if not os.fork():
          #detach from controlling terminal
          os.setsid()
          #fork again and write pid to pidfile from parent, run server on child
          pid = os.fork()
          if pid:
            with open(master_pidfile, 'w') as f:
              f.write(str(pid))
          else:
            self.__run_service(master_pidfile)

      if options.daemon not in ('start', 'stop', 'restart'):
        print "Invalid daemon option: " + options.daemon

    else:
      self.__run_service()

  def prepare(self):
    '''Override this method in a ``TotoService`` subclass and it will be called before any service processes
    are created. You can set instance variables here and they will be available in ``main_loop()`` but be
    careful that any retained objects are safe to access across processes'''
    pass

  def main_loop(self):
    '''Subclass ``TotoService`` and override ``main_loop()`` with your desired functionality.'''
    raise NotImplementedError()

  def finish(self):
    '''Override this method in a ``TotoService`` subclass and it will be called after all service processes
    have exited (after each ``main_loop()`` has returned).

    Note: This method will only be called once and only after all child processes have finished.'''
    pass


########NEW FILE########
__FILENAME__ = session
import cPickle as pickle
from uuid import uuid4
from base64 import b64encode

SESSION_ID_LENGTH = 22

class TotoAccount(object):
  '''Instances of TotoAccount provide dictionary-like access to user account properties. Unlike
  sessions, account properties are loaded directly from distinct fields in the database so if
  you're not using a schemaless database you'll need to make sure the fields (columns) exist
  in advance.
  '''

  def __init__(self, session):
    self._session = session
    self._modified_properties = set()
    self._properties = {}

  def __getitem__(self, key):
    if key not in self._properties:
      self.load_property(key)
    return key in self._properties and self._properties[key] or None

  def __setitem__(self, key, value):
    self._properties[key] = value
    self._modified_properties.add(key)

  def __contains__(self, key):
    return key in self._properties

  def __iter__(self):
    return self._properties.__iter__()

  def iterkeys(self):
    return self.__iter__()

  def save(self):
    '''Save any modified keys to the user account stored in the database.
    '''
    self._save_property(*self._modified_properties)
    self._modified_properties.clear()

  def load_property(self, *args):
    '''Load the properties passed to args. Properties will be dynamically loaded as they are accessed,
    but if you know you'll be referencing multiple properties, it can be faster to load them in bulk
    by passing all the keys you want to load as arguments to this method first.
    '''
    loaded = self._load_property(*args)
    for k in loaded:
      self._properties[k] = loaded[k]
    return self

  def __str__(self):
    return str({'properties': self._properties, 'modified': self._modified_properties})

  def _load_property(self, *args):
    raise Exception("Unimplemented operation: _load_property")

  def _save_property(self, *args):
    raise Exception("Unimplemented operation: _save_property")

class TotoSession(object):
  '''Instances of ``TotoSession`` provide dictionary-like access to current session variables, and the current
  account (if authenticated).
  '''

  __serializer = pickle

  def __init__(self, db, session_data, session_cache=None):
    self._db = db
    self._session_cache = session_cache
    self.user_id = session_data['user_id']
    self.expires = session_data['expires']
    self.session_id = session_data['session_id']
    self.state = session_data.get('state') and TotoSession.loads(session_data['state']) or {}
    self._verified = False

  def get_account(self, *args):
    '''Load the account associated with this session (if authenticated). Session properties are
    serialized to a binary string and stored as the ``TotoSession.state`` property, so you don't need to configure your database to handle them in
    advance.
    '''
    raise Exception("Unimplemented operation: get_account")

  def session_data(self):
    '''Return a session data ``dict`` that could be used to instantiate a session identical to the current one.
    '''
    return {'user_id': self.user_id, 'expires': self.expires, 'session_id': self.session_id, 'state': TotoSession.dumps(self.state)}

  def __getitem__(self, key):
    return key in self.state and self.state[key] or None
  
  def __setitem__(self, key, value):
    self.state[key] = value

  def __delitem__(self, key):
    if key in self.state:
      del self.state[key]

  def __iter__(self):
    return self.state.__iter__()

  def iterkeys():
    return self.__iter__()

  def __contains__(self, key):
    return key in self.state

  def __str__(self):
    return str({'user_id': self.user_id, 'expires': self.expires, 'id': self.session_id, 'state': self.state})

  def _refresh_cache(self):
    if self._session_cache:
      return self._session_cache.load_session(self.session_id)
    return None

  def refresh(self):
    '''Refresh the current session to the state in the database.
    '''
    raise Exception("Unimplemented operation: refresh")

  def _save_cache(self):
    if self._session_cache:
      self._session_cache.store_session(self.session_data())
      return True
    return False

  def save(self):
    '''Save the session to the database.
    '''
    raise Exception("Unimplemented operation: save")

  @classmethod
  def set_serializer(cls, serializer):
    '''Set the module that instances of ``TotoSession`` and ``TotoSessionCache`` will use to serialize session state. The module must implement ``loads`` and ``dumps``
    and support serialization and deserialization of any data you want to store in the session.
    By default, ``cPickle`` is used.
    '''
    cls.__serializer = serializer

  @classmethod
  def loads(cls, data):
    '''A convenience method to call ``serializer.loads()`` on the active serializer.
    '''
    return cls.__serializer.loads(str(data))

  @classmethod
  def dumps(cls, data):
    '''A convenience method to call ``serializer.dumps()`` on the active serializer.
    '''
    return cls.__serializer.dumps(data)

  @classmethod
  def generate_id(cls):
    '''Generate a random 22 character url safe session ID string.
    '''
    return b64encode(uuid4().bytes, '-_')[:-2]

class TotoSessionCache(object):
  '''Instances of ``TotoSessionCache`` allow for sessions to be stored separately from the main application database. As sessions must be retrieved
  for each authenticated request, it can be useful to keep them in a specialized database (redis, memcached) separate from the rest of your data.

  Note: cached sessions cannot currently be removed before their expiry.
  '''

  def store_session(self, session_data):
    '''Store a ``TotoSession`` with the given ``session_data``. ``session_data`` can be expected to contain, at a minimum, ``session_id`` and ``expires``.
    If an existing session matches the ``session_id`` contained in ``session_data``, it should be overwritten. The session is expected to be removed
    after the time specified by ``expires``.
    '''
    raise Exception("Unimplemented operation: store_session")

  def load_session(self, session_id):
    '''Retrieve the session with the given ``session_id``. This method should return the ``session_data`` ``dict`` that was originally passed to
    ``store_session()``.
    '''
    raise Exception("Unimplemented operation: retrieve_session")

########NEW FILE########
__FILENAME__ = sockets
from tornado.web import *
import json
from invocation import *
from exceptions import *
from tornado.options import define, options
from events import EventManager
from tornado.websocket import WebSocketHandler
import logging

class TotoSocketHandler(WebSocketHandler):

  @classmethod
  def configure(cls):
    if options.debug:
      import traceback
      def log_error(self, e): 
        logging.error('%s\nHeaders: %s\n' % (traceback.format_exc(), repr(self.request.headers)))
      cls.log_error = log_error
    open_function = options.socket_opened_method and options.socket_opened_method.rsplit('.', 1)
    cls._on_open = open_function and getattr(__import__(open_function[0]), open_function[1]) or None
    closed_function = options.socket_closed_method and options.socket_closed_method.rsplit('.', 1)
    cls._on_close = closed_function and getattr(__import__(closed_function[0]), closed_function[1]) or None
    cls.__method = __import__(options.socket_method_module)

  def initialize(self, db_connection):
    self.db_connection = db_connection
    self.db = self.db_connection.db
    self.session = None
    self.registered_event_handlers = []

  def log_error(self, e):
    if isinstance(exception , TotoException):
      logging.error("TotoException: %s Value: %s" % (e.code, e.value))
    else:
      logging.error("TotoException: %s Value: %s" % (ERROR_SERVER, repr(e)))
  
  def create_session(self, user_id=None, password=None):
    self.session = self.db_connection.create_session(user_id, password)
    return self.session

  def retrieve_session(self, session_id):
      self.session = self.db_connection.retrieve_session(session_id, None, None)
      return self.session

  def open(self, session_id=None):
    if session_id:
      self.retrieve_session(session_id)
    if(self._on_open):
      self._on_open()

  def on_message(self, message_data):
    method = self.__method
    try:
      message = json.loads(message_data)
      for i in message['method'].split('.'):
        method = getattr(method, i)
      method.invoke(self, message['parameters'])
    except Exception as e:
      self.log_error(e)

  def send_message(self, data, message_id=None):
    self.write_message(message_id and {'message_id': message_id, 'data': data} or data)

  def register_event_handler(self, event_name, handler, run_on_main_loop=True, deregister_on_finish=False):
    sig = EventManager.instance().register_handler(event_name, handler, run_on_main_loop, self)
    if deregister_on_finish:
      self.registered_event_handlers.append(sig)
    return sig

  def deregister_event_handler(self, sig):
    EventManager.instance().remove_handler(sig)
    self.registered_event_handlers.remove(sig)

  def on_close(self):
    while self.registered_event_handlers:
      self.deregister_event_handler(self.registered_event_handlers[0])
    if(self._on_close):
      self._on_close()

########NEW FILE########
__FILENAME__ = tasks
'''Toto provides build a built in task queue for performing work in the background
while limiting the number of active jobs. The task queue is designed primarily for
shorter, lightweight jobs. For CPU intensive tasks or tasks that are expected to
run for a long time, look at Toto's worker functionality instead.
'''
from threading import Thread, Lock
from collections import deque
from tornado.gen import coroutine, Task, Return
import logging
import traceback

class TaskQueue():
  '''Instances will run up to ``thread_count`` tasks at a time
  whenever there are tasks in the queue.
  '''

  def __init__(self, thread_count=1):
    self.tasks = deque()
    self.running = False
    self.lock = Lock()
    self.threads = set()
    self.thread_count = thread_count
  
  def add_task(self, fn, *args, **kwargs):
    '''Add the function ``fn`` to the queue to be invoked with
    ``args`` and ``kwargs`` as arguments. If the ``TaskQueue``
    is not currently running, it will be started now.
    '''
    self.tasks.append((fn, args, kwargs))
    self.lock.acquire()
    self.run()
    self.lock.release()

  @coroutine
  def yield_task(self, fn, *args, **kwargs):
    '''Like add_task but will call the function as a coroutine, allowing you
    to yield the return value from within a function decorated with ``@tornado.gen.coroutine``
    or ``@tornado.gen.engine``.

    Usage::

      def add(arg1, arg2):
        return arg1 + arg2

      @tornado.gen.engine
      def caller():
        value = yield TaskQueue.instance('myqueue').yield_task(add, 1, 2)
        print value #prints 3
    
    '''
    def call(callback):
      result = None
      error = None
      try:
        result = fn(*args, **kwargs)
      except Exception as e:
        error = e
      callback(result, error)
    (result, error), _ = yield Task(lambda callback: self.add_task(call, callback))
    if error:
      raise error
    raise Return(result)

  def run(self):
    '''Start processing jobs in the queue. You should not need
    to call this as ``add_task`` automatically starts the queue.
    Processing threads will stop when there are no jobs available
    in the queue.
    '''
    if len(self.threads) >= self.thread_count:
      return
    thread = None
    def task_loop():
      while 1:
        self.lock.acquire()
        try:
          task = self.tasks.popleft()
        except IndexError:
          self.threads.remove(thread)
          return
        except Exception as e:
          logging.error(traceback.format_exc())
        finally:
          self.lock.release()
        task[0](*task[1], **task[2])
    thread = Thread(target=task_loop)
    thread.daemon = True
    self.threads.add(thread)
    thread.start()

  def __len__(self):
    '''Returns the number of active threads plus the number of
    queued tasks/'''
    return len(self.threads) + len(self.tasks)

  @classmethod
  def instance(cls, name, thread_count=1):
    '''A convenience method for accessing shared instances of ``TaskQueue``.
    If ``name`` references an existing instance created with this method,
    that instance will be returned. Otherwise, a new ``TaskQueue`` will be
    instantiated with ``thread_count`` threads and stored under ``name``.
    '''
    if not hasattr(cls, '_task_queues'):
      cls._task_queues = {}
    try:
      return cls._task_queues[name]
    except KeyError:
      cls._task_queues[name] = cls(thread_count)
      return cls._task_queues[name]

########NEW FILE########
__FILENAME__ = worker
'''The Toto worker and worker connection classes are designed to help build RPC systems,
allowing you to pass CPU intensive work to other processeses or machines. Workers
were originally designed for use with the Toto server, making it easy to perform
long running tasks without effecting the server's responsiveness, but they have been
designed to be used independently and have no direct ties to the web server
architecture.

``TotoWorkers`` and ``WorkerConnections`` use ZMQ for messaging and require the ``pyzmq`` module.

The ``TotoWorkerService`` has a built in message router that will round-robin balance incoming
messages. The router can be disabled through configuration if only one worker process is needed.
Alternatively, the router can be configured to run without any worker processes, allowing multiple
machines to share a common router.

Most of the time you'll only need this script to start your server::

  from toto.worker import TotoWorkerService
  
  TotoWorkerService('settings.conf').run()

Methods, startup functions and databases can all be configured with the conf file.

Run your startup script with --help to see all available options.
'''

import os
import zmq
from zmq.devices.basedevice import ProcessDevice
import tornado
from tornado.options import options
import logging
import zlib
import cPickle as pickle
import sys
import time
from threading import Thread
from multiprocessing import Process, cpu_count
from toto.service import TotoService, process_count, pid_path
from toto.dbconnection import configured_connection
from exceptions import *
from toto.options import safe_define

safe_define("method_module", default='methods', help="The root module to use for method lookup")
safe_define("remote_event_receivers", type=str, help="A comma separated list of remote event address that this event manager should connect to. e.g.: 'tcp://192.168.1.2:8889'", multiple=True)
safe_define("event_init_module", default=None, type=str, help="If defined, this module's 'invoke' function will be called with the EventManager instance after the main event handler is registered (e.g.: myevents.setup)")
safe_define("startup_function", default=None, type=str, help="An optional function to run on startup - e.g. module.function. The function will be called for each worker process after it is configured and before it starts listening for tasks with the named parameters worker and db_connection.")
safe_define("worker_bind_address", default="tcp://*:55555", help="The service will bind to this address with a zmq PULL socket and listen for incoming tasks. Tasks will be load balanced to all workers. If this is set to an empty string, workers will connect directly to worker_socket_address.")
safe_define("worker_socket_address", default="ipc:///tmp/workerservice.sock", help="The load balancer will use this address to coordinate tasks between local workers")
safe_define("control_socket_address", default="ipc:///tmp/workercontrol.sock", help="Workers will subscribe to messages on this socket and listen for control commands. If this is an empty string, the command option will have no effect")
safe_define("command", type=str, metavar='status|shutdown', help="Specify a command to send to running workers on the control socket")
safe_define("compression_module", type=str, help="The module to use for compressing and decompressing messages. The module must have 'decompress' and 'compress' methods. If not specified, no compression will be used. You can also set worker.compress and worker.decompress in your startup method for increased flexibility")
safe_define("serialization_module", type=str, help="The module to use for serializing and deserializing messages. The module must have 'dumps' and 'loads' methods. If not specified, cPickle will be used. You can also set worker.dumps and worker.loads in your startup method for increased flexibility")

class TotoWorkerService(TotoService):
  '''Instances can be configured in three ways:

  1. (Most common) Pass the path to a config file as the first parameter to the constructor.
  2. Pass config parameters as command line arguments to the initialization script.
  3. Pass keyword arguments to the constructor.

  Precidence is as follows:

  Keyword args, config file, command line
  '''
  def __init__(self, conf_file=None, **kwargs):
    module_options = {'method_module', 'event_init_module'}
    function_options = {'startup_function'}
    original_argv, sys.argv = sys.argv, [i for i in sys.argv if i.strip('-').split('=')[0] in module_options]
    self._load_options(conf_file, **{i: kwargs[i] for i in kwargs if i in module_options})
    modules = {getattr(options, i) for i in module_options if getattr(options, i)}
    for module in modules:
      __import__(module)
    function_modules = {getattr(options, i).rsplit('.', 1)[0] for i in function_options if getattr(options, i)}
    for module in function_modules:
      __import__(module)
    sys.argv = original_argv
    #clear root logger handlers to prevent duplicate logging if user has specified a log file
    super(TotoWorkerService, self).__init__(conf_file, **kwargs)
    #clear method_module references so we can fully reload with new options
    for module in modules:
      for i in (m for m in sys.modules.keys() if m.startswith(module)):
        del sys.modules[i]
    for module in function_modules:
      for i in (m for m in sys.modules.keys() if m.startswith(module)):
        del sys.modules[i]
    #prevent the reloaded module from re-defining options
    define, tornado.options.define = tornado.options.define, lambda *args, **kwargs: None
    self.__event_init = options.event_init_module and __import__(options.event_init_module) or None
    self.__method_module = options.method_module and __import__(options.method_module) or None
    tornado.options.define = define

  def prepare(self):
    self.balancer = None
    if options.worker_bind_address:
      self.balancer = ProcessDevice(zmq.QUEUE, zmq.ROUTER, zmq.DEALER)
      self.balancer.daemon = True
      self.balancer.bind_in(options.worker_bind_address)
      self.balancer.bind_out(options.worker_socket_address)
      self.balancer.setsockopt_in(zmq.IDENTITY, 'ROUTER')
      self.balancer.setsockopt_out(zmq.IDENTITY, 'DEALER')
      self.balancer.start()
      if options.daemon:
        with open(pid_path(0), 'wb') as f:
          f.write(str(self.balancer.launcher.pid))
    count = options.processes if options.processes >= 0 else cpu_count()
    if count == 0:
      print 'Starting load balancer. Listening on "%s". Routing to "%s"' % (options.worker_bind_address, options.worker_socket_address)
    else:
      print "Starting %s worker process%s. %s." % (count, count > 1 and 'es' or '', options.worker_bind_address and ('Listening on "%s"' % options.worker_bind_address) or ('Connecting to "%s"' % options.worker_socket_address))

  def main_loop(self):
    db_connection = configured_connection()

    if options.remote_event_receivers:
      from toto.events import EventManager
      event_manager = EventManager.instance()
      if options.remote_instances:
        for address in options.remote_event_receivers.split(','):
          event_manager.register_server(address)
      init_module = self.__event_init
      if init_module:
        init_module.invoke(event_manager)
    serialization = options.serialization_module and __import__(options.serialization_module) or pickle
    compression = options.compression_module and __import__(options.compression_module)
    worker = TotoWorker(self.__method_module, options.worker_socket_address, db_connection, compression, serialization)
    if options.startup_function:
      startup_path = options.startup_function.rsplit('.')
      __import__(startup_path[0]).__dict__[startup_path[1]](worker=worker, db_connection=db_connection)
    worker.start()

  def send_worker_command(self, command):
    if options.control_socket_address:
      socket = zmq.Context().socket(zmq.PUB)
      socket.bind(options.control_socket_address)
      time.sleep(1)
      socket.send_string('command %s' % command)
      print "Sent command: %s" % options.command

  def run(self): 
    if options.command:
      self.send_worker_command(options.command)
      return
    super(TotoWorkerService, self).run()

class TotoWorker():
  '''The worker is responsible for processing all RPC calls. An instance
  will be initialized for each incoming request.
  
  You can set the module to use for method delegation via the ``method_module`` parameter.
  Methods are modules that contain an invoke function::

    def invoke(handler, parameters)
  
  The request worker instance will be passed as the first parameter to the invoke function and
  provides access to the server's database connection. Request parameters will be passed as the
  second argument to the invoke function.

  Any value returned from a method invocation will be sent to the caller, closing the
  message->response cycle. If you only need to let the caller know that the task has begun, you
  should decorate your ``invoke`` function with ``@toto.invocation.asynchronous`` to send a
  response before processing begins.
  '''
  def __init__(self, method_module, socket_address, db_connection, compression=None, serialization=None):
    self.context = zmq.Context()
    self.socket_address = socket_address
    self.method_module = method_module
    self.db_connection = db_connection
    self.db = db_connection and db_connection.db or None
    self.status = 'Initialized'
    self.running = False
    self.compress = compression and compression.compress or (lambda x: x)
    self.decompress = compression and compression.decompress or (lambda x: x)
    self.loads = serialization and serialization.loads or pickle.loads
    self.dumps = serialization and serialization.dumps or pickle.dumps
    if options.debug:
      from traceback import format_exc
      def error_info(self, e):
        if not isinstance(e, TotoException):
          e = TotoException(ERROR_SERVER, str(e))
        logging.error('%s\n%s\n' % (e, format_exc()))
        return e.__dict__
      TotoWorker.error_info = error_info
  
  def error_info(self, e):
    if not isinstance(e, TotoException):
      e = TotoException(ERROR_SERVER, str(e))
    logging.error(str(e))
    return e.__dict__

  def log_status(self):
    logging.info('Pid: %s status: %s' % (os.getpid(), self.status))
  
  def __monitor_control(self, address=options.control_socket_address):
    def monitor():
      socket = self.context.socket(zmq.SUB)
      socket.setsockopt(zmq.SUBSCRIBE, 'command')
      socket.connect(address)
      while self.running:
        try:
          command = socket.recv().split(' ', 1)[1]
          logging.info("Received command: %s" % command)
          if command == 'shutdown':
            self.running = False
            self.context.term()
            return
          elif command == 'status':
            self.log_status()
        except Exception as e:
          self.error_info(e)
    if address:
      thread = Thread(target=monitor)
      thread.daemon = True
      thread.start()

  def start(self):
    self.running = True
    self.__monitor_control()
    socket = self.context.socket(zmq.REP)
    socket.connect(self.socket_address)
    pending_reply = False
    while self.running:
      try:
        self.status = 'Listening'
        message = socket.recv_multipart()
        pending_reply = True
        message_id = message[0]
        data = self.loads(self.decompress(message[1]))
        logging.info('Received Task %s: %s' % (message_id, data['method']))
        method = self.method_module
        for i in data['method'].split('.'):
          method = getattr(method, i)
        if hasattr(method.invoke, 'asynchronous'):
          socket.send_multipart((message_id,))
          pending_reply = False
          self.status = 'Working'
          method.invoke(self, data['parameters'])
        else:
          self.status = 'Working'
          response = method.invoke(self, data['parameters'])
          socket.send_multipart((message_id, self.compress(self.dumps(response))))
          pending_reply = False
      except Exception as e:
        if pending_reply:
          socket.send_multipart((message_id, self.compress(self.dumps({'error': self.error_info(e)}))))

    self.status = 'Finished'
    self.log_status()

########NEW FILE########
__FILENAME__ = workerconnection
import toto
import zmq
import cPickle as pickle
import zlib
import logging
from threading import Thread
from tornado.options import options
from tornado.gen import Task
from collections import deque
from zmq.eventloop.ioloop import ZMQPoller, IOLoop, PeriodicCallback
from zmq.eventloop.zmqstream import ZMQStream
from time import time
from uuid import uuid4
from traceback import format_exc
from toto.options import safe_define

safe_define("worker_compression_module", type=str, help="The module to use for compressing and decompressing messages to workers. The module must have 'decompress' and 'compress' methods. If not specified, no compression will be used. Only the default instance will be affected")
safe_define("worker_serialization_module", type=str, help="The module to use for serializing and deserializing messages to workers. The module must have 'dumps' and 'loads' methods. If not specified, cPickle will be used. Only the default instance will be affected")
safe_define("worker_timeout", default=10.0, help="The default worker (instance()) will wait at least this many seconds before retrying a request (if retry is true), or timing out (if retry is false). Negative values will never retry or timeout. Note: This abs(value) is also the minimum resolution of any request-specific timeouts. Must not be 0.")
safe_define("worker_auto_retry", default=False, help="If True, the default timeout behavior of a worker RPC will be to retry instead of failing when the timeout is reached.")
safe_define("worker_address", default='', help="This is the address that toto.workerconnection.invoke(method, params) will send tasks too (As specified in the worker conf file). A comma separated list may be used to round-robin load balance tasks between workers.")

WORKER_SOCKET_CONNECT = 'CONNECT'
WORKER_SOCKET_DISCONNECT = 'DISCONNECT'

class WorkerConnection(object):
  '''Use a ``WorkerConnection`` to make RPCs to the remote worker service(s) or worker/router specified by ``address``.
     ``address`` may be either an enumerable of address strings or a string of comma separated addresses. RPC retries
     and timeouts will happen by at most every ``abs(timeout)`` seconds when a periodic callback runs through all active
     messages and checks for prolonged requests. This is also the default timeout for any new calls. ``timeout`` must not be
     ``0``.

     Optionally pass any object or module with ``compress`` and ``decompress`` methods as the ``compression`` parameter to
     compress messages. The module must implement the same algorithm used on the worker service. By default, messages are not
     compressed.

     Optionally pass any object or module with ``dumps`` and ``loads`` methods that convert an ``object`` to and from a
     ``str`` to replace the default ``cPickle`` serialization with a protocol of your choice.

     Use ``auto_retry`` to specify whether or not messages should be retried by default. Retrying messages can cause substantial
     congestion in your worker service. Use with caution.
  '''

  def __init__(self, address, timeout=10.0, compression=None, serialization=None, auto_retry=False):
    if not address:
      self.active_connections = set()
    elif isinstance(address, str):
      self.active_connections = {i.strip() for i in address.split(',')}
    else:
      self.active_connections = set(address)
    self.message_address = 'inproc://WorkerConnection%s' % id(self)
    self.__context = zmq.Context()
    self.__queue_socket = self.__context.socket(zmq.PUSH)
    self.__queue_socket.bind(self.message_address)
    self.__thread = None
    self.__timeout = timeout
    self.__callbacks = {}
    self.__queued_messages = {}
    self.__message_auto_retry = {}
    self.__message_timeouts = {}
    self.__ioloop = None
    self.__auto_retry = auto_retry
    self.loads = serialization and serialization.loads or pickle.loads
    self.dumps = serialization and serialization.dumps or pickle.dumps
    self.compress = compression and compression.compress or (lambda x: x)
    self.decompress = compression and compression.decompress or (lambda x: x)

  def invoke(self, method, parameters={}, callback=None, timeout=0, auto_retry=None, await=False):
    '''Invoke a ``method`` to be run on a remote worker process with the given ``parameters``. If specified, ``callback`` will be
       invoked with any response from the remote worker. By default the worker will timeout or retry based on the settings of the
       current ``WorkerConnection`` but ``timeout`` and ``auto_retry`` can be used for invocation specific behavior.

       Note: ``callback`` will be invoked with ``{'error': 'timeout'}`` on ``timeout`` if ``auto_retry`` is false. Invocations
       set to retry will never timeout and will instead be re-sent until a response is received. This behavior can be useful for
       critical operations but has the potential to cause substantial congestion in the worker system. Use with caution. Negative
       values of ``timeout`` will prevent messages from ever expiring or retrying regardless of ``auto_retry``. The default
       values of ``timeout`` and ``auto_retry`` cause a fallback to the values used to initialize ``WorkerConnection``.

       Passing ``await=True`` will wrap the call in a ``tornado.gen.Task`` allowing you to ``yield`` the response from the worker.
       The ``Task`` replaces ``callback`` so any user supplied callback will be ignored when ``await=True``.

       Alternatively, you can invoke methods with ``WorkerConnection.<module>.<method>(*args, **kwargs)``
       where ``"<module>.<method>"`` will be passed as the ``method`` argument to ``invoke()``.
    '''
    if await:
      return Task(lambda callback: self._queue_message(self.compress(self.dumps({'method': method, 'parameters': parameters})), callback, timeout, auto_retry))
    self._queue_message(self.compress(self.dumps({'method': method, 'parameters': parameters})), callback, timeout, auto_retry)

  def add_connection(self, address):
    '''Connect to the worker at ``address``. Worker invocations will be round robin load balanced between all connected workers.'''
    self._queue_message(address, command=WORKER_SOCKET_CONNECT)

  def remove_connection(self, address):
    '''Disconnect from the worker at ``address``. Worker invocations will be round robin load balanced between all connected workers.'''
    self._queue_message(address, command=WORKER_SOCKET_DISCONNECT)

  def set_connections(self, addresses):
    '''A convenience method to set the connected addresses. A connection will be made to any new address included in the ``addresses``
       enumerable and any currently connected address not included in ``addresses`` will be disconnected. If an address in ``addresses``
       is already connected, it will not be affected.
    '''
    addresses = set(addresses)
    to_remove = self.active_connections - addresses
    to_add = addresses - self.active_connections
    for a in to_remove:
      self.remove_connection(a)
    for a in to_add:
      self.add_connection(a)

  def __len__(self):
    return len(self.__queued_messages)

  def __getattr__(self, path):
    return WorkerInvocation(path, self)

  def _queue_message(self, message, callback=None, timeout=0, auto_retry=None, command=''):
    if not self.__ioloop:
      self.start()
    message_id = str(uuid4())
    if callback:
      self.__callbacks[message_id] = callback
    if timeout != 0:
      self.__message_timeouts[message_id] = timeout
    if auto_retry is not None:
      self.__message_auto_retry[message_id] = auto_retry
    self.__queue_socket.send_multipart((command, message_id, message))
  
  def log_error(self, error):
    logging.error(repr(error))

  def start(self):
    if self.__ioloop:
      return
    def loop():
      self.__ioloop = IOLoop()
      queue_socket = self.__context.socket(zmq.PULL)
      queue_socket.connect(self.message_address)
      queue_stream = ZMQStream(queue_socket, self.__ioloop)

      def receive_response(message, response_override=None):
        self.__queued_messages.pop(message[1], None)
        self.__message_timeouts.pop(message[1], None)
        callback = self.__callbacks.pop(message[1], None)
        if callback:
          try:
            callback(response_override or self.loads(self.decompress(message[2])))
          except Exception as e:
            self.log_error(e)
            callback({'error': e})

      def create_worker_stream():
        def close_callback():
          logging.info('Worker stream closed')
          create_worker_stream()
        worker_socket = self.__context.socket(zmq.DEALER)
        for address in self.active_connections:
          worker_socket.connect(address)
        worker_stream = ZMQStream(worker_socket, self.__ioloop)
        worker_stream.on_recv(receive_response)
        worker_stream.set_close_callback(close_callback)
        self._worker_stream = worker_stream
      create_worker_stream()

      def queue_message(message):
        if message[0]:
          if message[0] == WORKER_SOCKET_CONNECT and message[2] not in self.active_connections:
            self.active_connections.add(message[2])
            self._worker_stream.socket.connect(message[2])
          elif message[0] == WORKER_SOCKET_DISCONNECT and message[2] in self.active_connections:
            self.active_connections.remove(message[2])
            self._worker_stream.socket.disconnect(message[2])
          return
        self.__queued_messages[message[1]] = (time(), message)
        try:
          self._worker_stream.send_multipart(message)
        except IOError as e:
          self.log_error(e)
          logging.info('Reconnecting')
          create_worker_stream()
        except Exception as e:
          self.log_error(e)
      queue_stream.on_recv(queue_message)

      def timeout_message():
        now = time()
        for message, retry in [(item[1], self.__message_auto_retry.get(item[1][1], self.__auto_retry)) for item, t in ((i, self.__message_timeouts.get(i[1][1], self.__timeout)) for i in self.__queued_messages.itervalues()) if t >= 0 and (item[0] + t < now)]:
          if retry:
            logging.info('Worker timeout, requeuing ' + message[1])
            queue_message(message)
          else:
            receive_response(('', message[1]), {'error': 'timeout'})
      timeout_callback = PeriodicCallback(timeout_message, int(abs(self.__timeout * 1000.0)), io_loop = self.__ioloop)
      timeout_callback.start()

      self.__ioloop.start()
      self.__thread = None
    self.__thread = Thread(target=loop)
    self.__thread.daemon = True
    self.__thread.start()

  def stop(self):
    if self.__ioloop:
      self.__ioloop.stop()
  
  def join(self):
    if self.__thread:
      self.__thread.join()

  def enable_traceback_logging(self):
    from new import instancemethod
    from traceback import format_exc
    def log_error(self, e):
      logging.error(format_exc())
    self.log_error = instancemethod(log_error, self)

  @classmethod
  def instance(cls):
    '''Returns the default instance of ``WorkerConnection`` as configured by the options prefixed
      with ``worker_``, instantiating it if necessary. Import the ``workerconnection`` module within
      your ``TotoService`` and run it with ``--help`` to see all available options.
    '''
    if not hasattr(cls, '_instance'):
      cls._instance = cls(options.worker_address, timeout=options.worker_timeout, compression=options.worker_compression_module and __import__(options.worker_compression_module), serialization=options.worker_serialization_module and __import__(options.worker_serialization_module), auto_retry=options.worker_auto_retry)
    return cls._instance

class WorkerInvocation(object):
  
  def __init__(self, path, connection):
    self._path = path
    self._connection = connection

  def __call__(self, *args, **kwargs):
    return self._connection.invoke(self._path, *args, **kwargs)

  def __getattr__(self, path):
    return getattr(self._connection, self._path + '.' + path)

########NEW FILE########
