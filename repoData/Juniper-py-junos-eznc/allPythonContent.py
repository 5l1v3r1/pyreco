__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Junos PyEZ documentation build configuration file, created by
# sphinx-quickstart on Thu May  8 10:38:09 2014.
#
# This file is execfile()d with the current directory set to its
# containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys
import os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('../lib'))

# -- General configuration ------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.viewcode',
    'sphinx.ext.coverage',
]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
import jnpr.junos
project = u'Junos PyEZ'
copyright = u'2014, Juniper Networks, Inc.'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = jnpr.junos.__version__
# The full version, including alpha/beta/rc tags.
release = version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all
# documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
#keep_warnings = False


# -- Options for HTML output ----------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
html_logo = 'juniper.jpg'

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# Add any extra paths that contain custom files (such as robots.txt or
# .htaccess) here, relative to this directory. These files are copied
# directly to the root of the documentation.
#html_extra_path = []

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'JunosPyEZdoc'


# -- Options for LaTeX output ---------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title,
#  author, documentclass [howto, manual, or own class]).
latex_documents = [
  ('index', 'JunosPyEZ.tex', u'Junos PyEZ Documentation',
   u'Juniper Networks, Inc.', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output ---------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'junospyez', u'Junos PyEZ Documentation',
     [u'Juniper Networks, Inc.'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output -------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'JunosPyEZ', u'Junos PyEZ Documentation',
   u'Juniper Networks, Inc.', 'JunosPyEZ', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
#texinfo_no_detailmenu = False


# -- Options for Epub output ----------------------------------------------

# Bibliographic Dublin Core info.
epub_title = u'Junos PyEZ'
epub_author = u'Juniper Networks, Inc.'
epub_publisher = u'Juniper Networks, Inc.'
epub_copyright = u'2014, Juniper Networks, Inc.'

# The basename for the epub file. It defaults to the project name.
#epub_basename = u'Junos PyEZ'

# The HTML theme for the epub output. Since the default themes are not optimized
# for small screen space, using the same theme for HTML and epub output is
# usually not wise. This defaults to 'epub', a theme designed to save visual
# space.
#epub_theme = 'epub'

# The language of the text. It defaults to the language option
# or en if the language is not set.
#epub_language = ''

# The scheme of the identifier. Typical schemes are ISBN or URL.
#epub_scheme = ''

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
#epub_identifier = ''

# A unique identification for the text.
#epub_uid = ''

# A tuple containing the cover image and cover page html template filenames.
#epub_cover = ()

# A sequence of (type, uri, title) tuples for the guide element of content.opf.
#epub_guide = ()

# HTML files that should be inserted before the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_pre_files = []

# HTML files shat should be inserted after the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_post_files = []

# A list of files that should not be packed into the epub file.
epub_exclude_files = ['search.html']

# The depth of the table of contents in toc.ncx.
#epub_tocdepth = 3

# Allow duplicate toc entries.
#epub_tocdup = True

# Choose between 'default' and 'includehidden'.
#epub_tocscope = 'default'

# Fix unsupported image types using the PIL.
#epub_fix_images = False

# Scale large images.
#epub_max_image_width = 0

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#epub_show_urls = 'inline'

# If false, no index is generated.
#epub_use_index = True

########NEW FILE########
__FILENAME__ = base
# 3rd-party
from lxml.builder import E

# local module
from jnpr.junos.cfg.resource import Resource


class PhyPortBase(Resource):

    """
    [edit interfaces <name>]

    Resource name: str
      <name> is the interface-name (IFD), e.g. 'ge-0/0/0'
    """

    PROPERTIES = [
        'admin',              # True
        'description',        # str
        'speed',              # ['10m','100m','1g','10g']
        'duplex',             # ['full','half']
        'mtu',                # int
        'loopback',           # True
        '$unit_count'         # number of units defined
    ]

    PORT_DUPLEX = {
        'full': 'full-duplex',
        'half': 'half-duplex'
    }

    @classmethod
    def _set_invert(cls, in_this, item, from_this):
        from_item = in_this[item]
        in_this[item] = [
            _k for _k,
            _v in from_this.items() if _v == from_item][0]

    # -----------------------------------------------------------------------
    # XML readers
    # -----------------------------------------------------------------------

    def _xml_at_top(self):
        return E.interfaces(E.interface(
            E.name(self._name)
        ))

    def _xml_at_res(self, xml):
        return xml.find('.//interface')

    def _xml_to_py(self, has_xml, has_py):
        # common to all subclasses
        Resource._r_has_xml_status(has_xml, has_py)
        has_py['admin'] = bool(has_xml.find('disable') is None)
        Resource.copyifexists(has_xml, 'description', has_py)
        Resource.copyifexists(has_xml, 'mtu', has_py)
        has_py['$unit_count'] = len(has_xml.findall('unit'))

    # -----------------------------------------------------------------------
    # XML writers
    # -----------------------------------------------------------------------

    # description handed by Resource

    def _xml_change_admin(self, xml):
        xml.append(
            Resource.xmltag_set_or_del(
                'disable',
                (self.admin == False)))
        return True

    def _xml_change_mtu(self, xml):
        Resource.xml_set_or_delete(xml, 'mtu', self.mtu)
        return True

    # -----------------------------------------------------------------------
    # Manager List, Catalog
    # -----------------------------------------------------------------------

    def _r_list(self):
        got = self.R.get_interface_information(
            media=True,
            interface_name="[xgf]e*")
        self._rlist = [
            name.text.strip() for name in got.xpath('physical-interface/name')]

########NEW FILE########
__FILENAME__ = classic
# 3rd-party
from lxml.builder import E

# local
from jnpr.junos.cfg.resource import Resource
from jnpr.junos import JXML
from jnpr.junos.cfg.phyport.base import PhyPortBase


class PhyPortClassic(PhyPortBase):

    # -----------------------------------------------------------------------
    # XML readers
    # -----------------------------------------------------------------------

    def _xml_to_py(self, has_xml, has_py):
        PhyPortBase._xml_to_py(self, has_xml, has_py)

        Resource.copyifexists(has_xml, 'speed', has_py)
        Resource.copyifexists(has_xml, 'link-mode', has_py, 'duplex')
        if has_xml.find('gigether-options/loopback') is not None:
            has_py['loopback'] = True
        has_py['$unit_count'] = len(has_xml.findall('unit'))

        # normalizers
        if 'duplex' in has_py:
            PhyPortBase._set_invert(has_py, 'duplex', self.PORT_DUPLEX)

    # -----------------------------------------------------------------------
    # XML writers
    # -----------------------------------------------------------------------

    def _xml_change_speed(self, xml):
        Resource.xml_set_or_delete(xml, 'speed', self.speed)
        return True

    def _xml_change_duplex(self, xml):
        value = self.PORT_DUPLEX.get(self.duplex)
        Resource.xml_set_or_delete(xml, 'link-mode', value)
        return True

    def _xml_change_loopback(self, xml):
        opts = E('gigether-options')
        opts.append(Resource.xmltag_set_or_del('loopback', self.loopback))
        xml.append(opts)
        return True

########NEW FILE########
__FILENAME__ = switch
# 3rd-party
from lxml.builder import E

# local
from jnpr.junos.cfg import Resource
from jnpr.junos import JXML
from jnpr.junos.cfg.phyport.base import PhyPortBase


class PhyPortSwitch(PhyPortBase):

    PORT_SPEED = {
        'auto': 'auto-negotiation',
        '10m': 'ethernet-10m',
        '100m': 'ethernet-100m',
        '1g': 'ethernet-1g'
    }

    # -----------------------------------------------------------------------
    # XML readers
    # -----------------------------------------------------------------------

    def _xml_to_py(self, has_xml, has_py):
        PhyPortBase._xml_to_py(self, has_xml, has_py)

        # speed, duplex, loopback are all under 'ether-options'
        ethopts = has_xml.find('ether-options')
        if ethopts is None:
            return

        if ethopts.find('loopback') is not None:
            has_py['loopback'] = True

        speed = ethopts.find('speed')
        if speed is not None:
            # take the first child element
            has_py['speed'] = speed[0].tag
            PhyPortBase._set_invert(has_py, 'speed', self.PORT_SPEED)

        Resource.copyifexists(ethopts, 'link-mode', has_py, 'duplex')
        if 'duplex' in has_py:
            PhyPortBase._set_invert(has_py, 'duplex', self.PORT_DUPLEX)

    # -----------------------------------------------------------------------
    # XML writers
    # -----------------------------------------------------------------------

    def _xml_hook_build_change_begin(self, xml):
        if any([this in self.should for this in ['speed', 'duplex',
                                                 'loopback']]):
            self._ethopts = E('ether-options')
            xml.append(self._ethopts)

    def _xml_change_speed(self, xml):
        speed_tag = self.PORT_SPEED.get(self.speed)
        add_this = E.speed(
            JXML.DEL) if speed_tag is None else E.speed(
            E(speed_tag))
        self._ethopts.append(add_this)
        return True

    def _xml_change_duplex(self, xml):
        value = self.PORT_DUPLEX.get(self.duplex)
        Resource.xml_set_or_delete(self._ethopts, 'link-mode', value)
        return True

    def _xml_change_loopback(self, xml):
        self._ethopts.append(
            Resource.xmltag_set_or_del(
                'loopback',
                self.loopback))
        return True

########NEW FILE########
__FILENAME__ = resource
# stdlib
import warnings
from pprint import pformat
from copy import deepcopy

# 3rd-party
from lxml.builder import E

# package modules
from jnpr.junos import jxml as JXML

P_JUNOS_EXISTS = '_exists'
P_JUNOS_ACTIVE = '_active'


class Resource(object):

    PROPERTIES = [
        P_JUNOS_EXISTS,
        P_JUNOS_ACTIVE
    ]

    def __init__(self, junos, namevar=None, **kvargs):
        """
        Resource or Resource-Manager constructor.  All managed resources
        and resource-managers inherit from this class.

        junos
          Instance of Device, this is bound to the Resource for
          device access

        namevar
          If not None, identifies a specific resource by 'name'.  The
          format of the name is resource dependent.  Most resources take
          a single string name, while others use tuples for compound names.
          refer to each resource for the 'namevar' definition

          If namevar is None, then the instance is a Resource-Manager (RM).
          The RM is then used to select specific resources by name using
          the __getitem__ overload.

        kvargs['P'] or kvargs['parent']
          Instance to the resource parent.  This is set when resources have
          hierarchical relationships, like rules within rulesets

        kvargs['M']
          Instance to the resource manager.
        """
        self._junos = junos
        self._name = namevar
        self._parent = kvargs.get('parent') or kvargs.get('P')
        self._opts = kvargs
        self._manager = kvargs.get('M')

        if not namevar:
            # then this is a resource-manager instance. setup the list and
            # catalog attributes, but do not load them now.  when the caller
            # invokes the properties, they will auto-load when empty.
            self._rlist = []
            self._rcatalog = {}
            return

        # otherwise, a resource includes public attributes:

        self.properties = []
        self.properties.extend(Resource.PROPERTIES)
        if self.__class__ != Resource:
            self.properties.extend(self.__class__.PROPERTIES)

        # if this resource manages others, then hook that
        # into the :manages: list

        if hasattr(self, 'MANAGES'):
            self._manages = self.MANAGES.keys()
            for k, v in self.MANAGES.items():
                self.__dict__[k] = v(junos, parent=self)

        # setup resource cache-attributes

        self.has = {}
        self.should = {}
        self._is_new = False

        # now load the properties from the device.
        self.read()

    # -----------------------------------------------------------------------
    # PROPERTIES
    # -----------------------------------------------------------------------

    @property
    def active(self):
        """
        is this resource configuration active on the Junos device?

        :RuntimeError: if invoked on a manager object
        """
        if self.is_mgr:
            raise RuntimeError("Not on a manager!")
        return self.has[P_JUNOS_ACTIVE]

    @property
    def exists(self):
        """
        does this resource configuration exist on the Junos device?

        :RuntimError: if invoked on a manager
        """
        if self.is_mgr:
            raise RuntimeError("Not on a manager!")
        return self.has[P_JUNOS_EXISTS]

    @property
    def is_mgr(self):
        """
        is this a resource manager?
        """
        return (self._name is None)

    @property
    def is_new(self):
        """
        is this a new resource? that is, it does not exist
        on the Junos device when it was initally retrieved

        :RuntimeError: if invoked on a manager
        """
        if self.is_mgr:
            raise RuntimeError("Not on a manager!")
        return self._is_new

    @property
    def name(self):
        """
        the name of the resource

        :RuntimeError: if invoked on a manager
        """
        if self.is_mgr:
            raise RuntimeError("Not on a manager!")
        return self._name

    @name.setter
    def name(self, value):
        if self.is_mgr:
            raise RuntimeError("Not on a manager!")
        raise AttributeError("name is currently read-only")

    @property
    def manages(self):
        """
        a resource may contain sub-managers for hierarchical
        oriented resources.  this method will return a list
        of manager names attached to this resource, or
        :None: if there are not any
        """
        if hasattr(self, '_manages'):
            return self._manages
        return None

    @manages.setter
    def manages(self):
        raise AttributeError("read-only")

    @property
    def xml(self):
        """
        for debugging the resource XML configuration that was
        read from the Junos device
        """
        if self.is_mgr:
            raise RuntimeError("Not on a manager!")
        return self._has_xml

    @property
    def list(self):
        """
        returns a list of named resources
        """
        if not self.is_mgr:
            raise RuntimeError("Must be a manager!")
        if not len(self._rlist):
            self.list_refresh()
        return self._rlist

    @property
    def catalog(self):
        """
        returns a dictionary of resources
        """
        if not self.is_mgr:
            raise RuntimeError("Must be a manager!")
        if not len(self._rcatalog):
            self.catalog_refresh()
        return self._rcatalog

    # -------------------------------------------------------------------------
    # shortcuts
    # -------------------------------------------------------------------------

    @property
    def D(self):
        """ returns the Device object bound to this resource/manager """
        return self._junos

    @property
    def R(self):
        """ returns the Device RPC meta object """
        return self._junos.rpc

    @property
    def M(self):
        """ returns the :Resource: manager associated to this resource """
        return self._manager

    @property
    def P(self):
        """ returns the parent of the associated Junos object """
        return self._parent

    # -----------------------------------------------------------------------
    # PUBLIC METHODS
    # -----------------------------------------------------------------------

    # -------------------------------------------------------------------------
    # read
    # -------------------------------------------------------------------------

    def read(self):
        """
        read resource configuration from device
        """

        self._r_has_init()
        self._has_xml = self._r_config_read_xml()

        if None == self._has_xml or not len(self._has_xml):
            self._is_new = True
            self._r_when_new()
            return None

        # the xml_read_parser *MUST* be implement by the
        # resource subclass.  it is used to parse the XML
        # into native python structures.

        self._xml_to_py(self._has_xml, self.has)

        # return the python structure represntation
        return True

    # -------------------------------------------------------------------------
    # write
    # -------------------------------------------------------------------------

    def write(self, **kvargs):
        """
        write resource configuration stored in :should: back to device

        kvargs['touch']
          if True, then write() will skip the check to see if any
          items exist in :should:
        """
        if self.is_mgr:
            raise RuntimeError("Not on a manager!")

        if not len(self.should) and 'touch' not in kvargs:
            return False

        # if this resource did not previously exist,
        # then mark it now into :should:

        if P_JUNOS_EXISTS not in self.should:
            self._r_set_exists(self.should, True)

        if self.is_new:
            self._r_set_active(self.should, True)

        # construct the XML change structure
        xml_change = self._xml_build_change()
        if None == xml_change:
            return False

        # write these changes to the device
        rsp = self._r_config_write_xml(xml_change)

        # copy :should: into :has: and then clear :should:
        self.has.update(self.should)
        self.should.clear()

        return True

    # -------------------------------------------------------------------------
    # activate
    # -------------------------------------------------------------------------

    def activate(self):
        """
        activate resource in Junos config
        the same as the Junos config-mode "activate" command
        """
        # no action needed if it's already active
        if self.active:
            return False
        self._r_set_active(self.should, True)
        return self.write()

    # -------------------------------------------------------------------------
    # deactivate
    # -------------------------------------------------------------------------

    def deactivate(self):
        """
        activate resource in Junos config
        the same as the Junos config-mode "deactivate" command
        """
        # no action needed if it's already deactive
        if not self.active:
            return False
        self._r_set_active(self.should, False)
        return self.write()

    # -------------------------------------------------------------------------
    # delete
    # -------------------------------------------------------------------------

    def delete(self):
        """
        remove configuration from Junos device
        the same as the Junos config-mode "delete" command
        """
        # cannot delete something that doesn't exist
        # @@@ should raise?

        if not self.exists:
            return False

        # remove the config from Junos
        xml = self._xml_edit_at_res()
        xml.attrib.update(JXML.DEL)
        self._xml_hook_on_delete(xml)
        rsp = self._r_config_write_xml(xml)

        # reset the :has: attribute
        self._r_has_init()
        return True

    # -------------------------------------------------------------------------
    # rename
    # -------------------------------------------------------------------------

    def rename(self, new_name):
        """
        rename resource in Junos configuration
        the same as the Junos config-mode "rename" command
        """
        # cannot rename something that doesn't exist
        # @@@ should raise?

        if not self.exists:
            return False

        xml = self._xml_edit_at_res()
        xml.attrib.update(JXML.REN)
        xml.attrib.update(JXML.NAME(new_name))

        rsp = self._r_config_write_xml(xml)
        self._name = new_name

        return True

    # -------------------------------------------------------------------------
    # reorder
    # -------------------------------------------------------------------------

    def reorder(self, **kvargs):
        """
        move the configuration within the Junos hierarcy
        the same as the Junos config-mode "insert" command

        :kvargs:
          after="<name>"
          before="<name>"
        """
        cmd, name = next(kvargs.iteritems())
        if cmd != 'before' and cmd != 'after':
            raise ValueError("Must be either 'before' or 'after'")

        xml = self._xml_edit_at_res()
        xml.attrib.update(JXML.INSERT(cmd))
        xml.attrib.update(JXML.NAME(name))

        rsp = self._r_config_write_xml(xml)
        return True

    def list_refresh(self):
        """
        reloads the managed resource list from the Junos device
        """
        if not self.is_mgr:
            raise RuntimeError("Only on a manager!")
        del self._rlist[:]
        self._r_list()      # invoke the specific resource method

    def catalog_refresh(self):
        """
        reloads the resource catalog from the Junos device
        """
        if not self.is_mgr:
            raise RuntimeError("Only on a manager!")
        self._rcatalog.clear()
        self._r_catalog()  # invoke the specific resource method

    def _r_catalog(self):
        """
        provide a 'default' catalog creator method that simply uses
        the manager list and runs through each resource making
        a refcopy to the :has: properties
        """
        zone_list = self.list
        for name in zone_list:
            r = self[name]
            self._rcatalog[name] = r.has

    def refresh(self):
        if not self.is_mgr:
            raise RuntimeError("Only on a manager!")
        self.list_refresh()
        self.catalog_refresh()

    def propcopy(self, p_name):
        """
        proptery from :has: to :should:

        performs a 'deepcopy' of the property; used to make
        changes to list, dict type properties
        """
        self.should[p_name] = deepcopy(self.has[p_name])
        return self.should[p_name]

    # -----------------------------------------------------------------------
    # OVERLOADS
    # -----------------------------------------------------------------------

        # ---------------------------------------------------------------------
        # ITEMS: for read/write of resource managed properties
        # ---------------------------------------------------------------------

    def __getitem__(self, namekey):
        """
        implements [] to obtain property value.  value will come
        from :should: if set or from :has: otherwise.
        """

        if self.is_mgr:
            # ---------------------------------------------------------------
            # use is resource-manager accessing specific index/name
            # to return resource instance
            # ---------------------------------------------------------------

            self._opts['M'] = self
            if isinstance(namekey, int):
                # index, not name
                namekey = self.list[namekey]

            res = self.__class__(self._junos, namekey, **self._opts)
            return res

        # ---------------------------------------------------------------
        # use-case is resource instance for read property
        # ---------------------------------------------------------------

        if namekey in self.should:
            return self.should[namekey]

        if namekey in self.has:
            return self.has[namekey]

        if namekey in self.properties:
            # it's a valid property, just not set in the resource
            return None

        raise ValueError("Unknown property request: %s" % namekey)

    def __setitem__(self, r_prop, value):
        """
        implements []= to set property value into :should:
        """
        if self.is_mgr:
            raise RuntimeError("Not on a manager!")
        if r_prop in self.properties:
            self.should[r_prop] = value
        else:
            raise ValueError("Uknown property request: %s" % r_prop)

    def __call__(self, **kvargs):
        """
        alternative way to set property values as aggregation of
        key/value pairs.  this will automatically call :write():
        when completed.
        """
        if self.is_mgr:
            raise RuntimeError("Not on a manager!")
        if not kvargs:
            return False

        # validate property names first!
        for p_name, p_val in kvargs.items():
            if p_name not in self.properties:
                raise ValueError("Unknown property: %s" % p_name)

        # now cleared to add all the values
        self.should.update(kvargs)
        return self.write()

        # ---------------------------------------------------------------------
        # ATTRIBUTE: for read/write of resource managed properties
        # ---------------------------------------------------------------------

    def __getattr__(self, namekey):
        """
        returns property value, accessed as attribute <resource>.<property>
        only for resource instance
        """
        if self.is_mgr:
            raise RuntimeError("not on a resource-manager")
        return self[namekey]

    def __setattr__(self, name, value):
        if hasattr(self, 'properties') and name in self.properties:
            # we can set this name/value in the resource property
            self[name] = value
        else:
            # pass 'up' to standard setattr method
            object.__setattr__(self, name, value)

        # ---------------------------------------------------------------------
        # PRINT/DEBUG
        # ---------------------------------------------------------------------

    def __repr__(self):
        """
          stringify for debug/printing

          this will show the resource manager (class) name,
          the resource (Junos) name, and the contents
          of the :has: dict and the contents of the :should: dict
        """
        mgr_name = self.__class__.__name__
        return "NAME: %s: %s\nHAS: %s\nSHOULD:%s" % \
            (mgr_name, self._name, pformat(self.has), pformat(self.should)) \
            if not self.is_mgr \
            else "Resource Manager: %s" % mgr_name

        # ---------------------------------------------------------------------
        # ITERATOR
        # ---------------------------------------------------------------------

    def __iter__(self):
        """ iterate through each Resource in the Manager list """
        for name in self.list:
            yield self[name]

    # -----------------------------------------------------------------------
    # XML reading
    # -----------------------------------------------------------------------

    def _r_config_read_xml(self):
        """
        read the resource config from the Junos device
        """
        get = self._xml_at_top()
        self._xml_hook_read_begin(get)
        got = self._junos.rpc.get_config(get)
        return self._xml_at_res(got)

    def _xml_at_top(self):
        """
        ~| WARNING |~
        resource subclass *MUST* implement this!

        Create an XML structure that will be used to retrieve
        the resource configuration from the device.
        """
        raise RuntimeError("Resource missing method: %s" %
                           self.__class__.__name__)

    def _xml_at_res(self, xml):
        """
        ~| WARNING |~
        resource subclass *MUST* implement this!

        Return the XML element of the specific resource from
        the :xml: structure.  The :xml: will be the configuration
        starting at the top of the Junos config, i.e.
        <configuration>, and the resource needs to "cursor" at
        the specific resource within that structure
        """
        raise RuntimeError("Resource missing method: %s" %
                           self.__class__.__name__)

    # -----------------------------------------------------------------------
    # XML writing
    # -----------------------------------------------------------------------

    def _xml_build_change(self):
        """
          iterate through the :should: properties creating the
          necessary configuration change structure.  if there
          are no changes, then return :None:
        """
        edit_xml = self._xml_edit_at_res()

        # if there is resource hook to do something
        # before we build up the xml configuration,
        # then do that now

        self._xml_hook_build_change_begin(edit_xml)

        # if this resource should be deleted then
        # handle that case and return

        if not self.should[P_JUNOS_EXISTS]:
            self._xml_change__exists(edit_xml)
            return edit_xml

        # otherwise, this is an update, and we need to
        # construct the XML for change

        changed = False
        for r_prop in self.properties:
            if r_prop in self.should:
                edit_fn = "_xml_change_" + r_prop
                changed |= getattr(self, edit_fn)(edit_xml)

        # if there is a resource hook to do something
        # after we've run through all the property methods
        # then invoke that now

        changed |= self._xml_hook_build_change_end(edit_xml)

        return edit_xml if changed else None

    def _r_config_write_xml(self, xml):
        """
          write the xml change to the Junos device,
          trapping on exceptions.
        """
        top_xml = xml.getroottree().getroot()

        try:
            result = self._junos.rpc.load_config(top_xml, action='replace')
        except Exception as err:
            # see if this is OK or just a warning
            if len(err.rsp.xpath('.//error-severity[. = "error"]')):
                raise err
            return err.rsp

        return result

    # ------------------------------------------------------------------------
    # XML edit cursor methods
    # ------------------------------------------------------------------------

    def _xml_edit_at_res(self):
        return self._xml_at_res(self._xml_at_top())

    # ------------------------------------------------------------------------
    # XML standard properties "writers"
    # ------------------------------------------------------------------------

    def _xml_change_description(self, xml):
        Resource.xml_set_or_delete(
            xml,
            'description',
            self.should['description'])
        return True

    def _xml_change__active(self, xml):
        if self.should[P_JUNOS_ACTIVE] == self.has[P_JUNOS_ACTIVE]:
            return False
        value = 'active' if self.should[P_JUNOS_ACTIVE] else 'inactive'
        xml.attrib[value] = value
        return True

    def _xml_change__exists(self, xml):
        # if this is a change to create something new,
        # then invoke the 'on-create' hook and return
        # the results

        if self.should[P_JUNOS_EXISTS]:
            return self._xml_hook_on_new(xml)

        # otherwise, we are deleting this resource
        xml.attrib.update(JXML.DEL)

        # now call the 'on-delete' hook and return
        # the results

        return self._xml_hook_on_delete(xml)

    # -----------------------------------------------------------------------
    # XML HOOK methods
    # -----------------------------------------------------------------------

    def _xml_hook_read_begin(self, xml):
        """
        called from :_r_config_read_xml(): after call to :_xml_at_top(): and
        before the config request is made to the Junos device.  This hook
        allows the subclass to munge the XML get-request with additional items
        if necessary

        Returns:
          :True: when :xml: is changed
          :False: otherwise
        """
        return False

    def _xml_hook_build_change_begin(self, xml):
        """
        called from :_xml_build_change(): before the individual property
        methods are invoked.  allows the resource to do anything, like pruning
        stub elements that were generated as part of :_xml_at_top():

        Returns:
          :True: when :xml: is changed
          :False: otherwise
        """
        return False

    def _xml_hook_build_change_end(self, xml):
        """
        called from :_xml_build_change(): after all of the properties
        methods have been processed.

        Returns:
          :True: when :xml: is changed
          :False: otherwise
        """
        return False

    def _xml_hook_on_delete(self, xml):
        """
        called when an XML write operation is going to delete the resource.

        Returns:
          :True: when :xml: is changed
          :False: otherwise
        """
        return False

    def _xml_hook_on_new(self, xml):
        """
        called when an XML write operation is going to create a new resource.

        Returns:
          :True: when :xml: is changed
          :False: otherwise
        """
        return False

    # -----------------------------------------------------------------------
    # Resource HOOK methods
    # -----------------------------------------------------------------------

    def _r_when_new(self):
        """
          called by :read(): when the resource is new; i.e.
          there is no existing Junos configuration
        """
        pass

    def _r_when_delete(self):
        """
        ~| not used yet |~
        """
        pass

    # -----------------------------------------------------------------------
    # ~private~ resource methods
    # -----------------------------------------------------------------------

    def _r_set_active(self, my_props, value):
        my_props[P_JUNOS_ACTIVE] = value

    def _r_set_exists(self, my_props, value):
        my_props[P_JUNOS_EXISTS] = value

    def _r_has_init(self):
        self.has.clear()
        self.has[P_JUNOS_EXISTS] = False
        self.has[P_JUNOS_ACTIVE] = False

    @classmethod
    def _r_has_xml_status(klass, as_xml, as_py):
        """
          set the 'exists' and 'active' :has: values
        """
        as_py[P_JUNOS_ACTIVE] = False if as_xml.attrib.get(
            'inactive') else True
        as_py[P_JUNOS_EXISTS] = True

    @classmethod
    def xml_set_or_delete(klass, xml, ele_name, value):
        """
        HELPER function to either set a value or remove the element
        """
        if value is not None and not isinstance(value, str):
            value = str(value)
        xml.append(E(ele_name, (value if value else JXML.DEL)))

    @classmethod
    def xmltag_set_or_del(klass, ele_name, value):
        """
        HELPER function creates an XML element tag read-only
        that includes the DEL attribute depending on :value:
        """
        return E(ele_name, ({} if value else JXML.DEL))

    @classmethod
    def copyifexists(klass, xml, ele_name, to_py, py_name=None):
        ele_val = xml.find(ele_name)
        if ele_val is not None:
            to_py[(py_name if py_name else ele_name)] = ele_val.text.strip()

    @classmethod
    def diff_list(klass, has_list, should_list):
        # covert lists to perform differencing
        should = set(should_list)
        has = set(has_list)

        # return lists (added, removed)
        return (list(should - has), list(has - should))

    def _xml_list_property_add_del_names(self, xml, prop_name, element_name):
        """
        utility method use to process :list: properties.  this will add/delete
        items give the propery type and associated XML element name
        """
        (adds, dels) = Resource.diff_list(
            self.has.get(prop_name, []), self.should[prop_name])
        for this in adds:
            xml.append(E(element_name, E.name(this)))
        for this in dels:
            xml.append(E(element_name, JXML.DEL, E.name(this)))

########NEW FILE########
__FILENAME__ = user
# 3rd-party modules
from lxml.builder import E

# module packages
from jnpr.junos.cfg import Resource
from jnpr.junos import jxml as JXML
from jnpr.junos.cfg.user_ssh_key import UserSSHKey


class User(Resource):

    """
    [edit system login user <name>]

    Resource name: str
      <name> is the user login name

    Manages resources:
      sshkey, UserSSHKey
    """

    PROPERTIES = [
        'uid',
        'fullname',       # the full-name field
        'userclass',      # user class
        'password',       # write-only clear-text password, will get crypt'd
        '$password',      # read-only crypt'd password
        '$sshkeys',       # read-only names of ssh-keys
    ]

    MANAGES = {'sshkey': UserSSHKey}

    # -----------------------------------------------------------------------
    # XML readers
    # -----------------------------------------------------------------------

    def _xml_at_top(self):
        return E.system(E.login(E.user(E.name(self._name))))

    def _xml_at_res(self, xml):
        return xml.find('.//user')

    def _xml_to_py(self, has_xml, has_py):
        Resource._r_has_xml_status(has_xml, has_py)

        has_py['userclass'] = has_xml.findtext('class')

        Resource.copyifexists(has_xml, 'full-name', has_py, 'fullname')

        Resource.copyifexists(has_xml, 'uid', has_py)
        if 'uid' in has_py:
            has_py['uid'] = int(has_py['uid'])

        auth = has_xml.find('authentication')
        if auth is not None:
            # plain-text password
            Resource.copyifexists(
                auth,
                'encrypted-password',
                has_py,
                '$password')

            # ssh-keys
            sshkeys = auth.xpath('ssh-rsa | ssh-dsa')
            if sshkeys is not None:
                has_py['$sshkeys'] = [(sshkey.tag,
                                       sshkey.findtext('name').strip())
                                      for sshkey in sshkeys
                                      ]

    # -----------------------------------------------------------------------
    # XML property writers
    # -----------------------------------------------------------------------

    def _xml_change_fullname(self, xml):
        xml.append(E('full-name', self['fullname']))
        return True

    def _xml_change_userclass(self, xml):
        xml.append(E('class', self['userclass']))
        return True

    def _xml_change_password(self, xml):
        xml.append(E.authentication(
            E('plain-text-password-value', self['password'])
        ))
        return True

    def _xml_change_uid(self, xml):
        xml.append(E.uid(str(self['uid'])))
        return True

    # -----------------------------------------------------------------------
    # Manager List, Catalog
    # -----------------------------------------------------------------------

    def _r_list(self):
        get = E.system(E.login(E.user(JXML.NAMES_ONLY)))
        got = self.R.get_config(get)
        self._rlist = [name.text for name in got.xpath('.//user/name')]

########NEW FILE########
__FILENAME__ = user_ssh_key
# 3rd-party modules
from lxml.builder import E

# local module
from jnpr.junos.cfg import Resource
from jnpr.junos import jxml as JXML


class UserSSHKey(Resource):

    """
    [edit system login user <name> authentication <key-type> <key-value> ]

    Resource name: tuple(<key-type>, <key-value>)
      <key-type> : ['ssh-dsa', 'ssh-rsa']
      <key-value> : SSH public key string (usually something very long)

    Resource manager utilities:
      load_key - allows you to load an ssh-key from a file or str
    """

    # there are no properties, since the name <key-value> constitutes the
    # actual ssk key data, yo!

    PROPERTIES = []

    # -----------------------------------------------------------------------
    # XML readers
    # -----------------------------------------------------------------------

    def _xml_at_top(self):
        key_t, key_v = self._name
        return E.system(E.login(E.user(
            E.name(self.P.name),
            E.authentication(
                E(key_t, E.name(key_v)
                  )
            ))))

    def _xml_at_res(self, xml):
        return xml.find('.//authentication/%s' % self._name[0])

    def _xml_to_py(self, has_xml, has_py):
        Resource._r_has_xml_status(has_xml, has_py)

    # -----------------------------------------------------------------------
    # UTILITY FUNCTIONS
    # -----------------------------------------------------------------------

    def load_key(self, path=None, key_value=None):
        """
        Adds a new ssh-key to the user authentication.  You can
        provide either the path to the ssh-key file, or the contents
        of they key (useful for loading the same key on many devices)

        :path: (optional)
          path to public ssh-key file on the local server,

        :key_value: (optional)
          the contents of the ssh public key
        """

        if not self.is_mgr:
            raise RuntimeError("must be a resource-manager!")

        if path is None and key_value is None:
            raise RuntimeError("You must provide either path or key_value")

        if path is not None:
            # snarf the file into key_value, yo!
            with open(path, 'r') as f:
                key_value = f.read().strip()

        # extract some data from the key value, this will either
        # be 'ssh-rsa' or 'ssh-dss'.  we need to decode this to set
        # the type correctly in the RPC.

        vt = key_value[0:7]
        key_map = {'ssh-rsa': 'ssh-rsa', 'ssh-dss': 'ssh-dsa'}
        key_type = key_map.get(vt)
        if key_type is None:
            raise RuntimeError("Unknown ssh public key file type: %s" % vt)

        # at this point we are going to add a new key, so really what we are
        # doing is accessing a new instance of this class and
        # doing a write, but just a touch since there are no properties, yo!

        new_key = self[(key_type, key_value)]
        return new_key.write(touch=True)

    # -----------------------------------------------------------------------
    # Manager List, Catalog
    # -----------------------------------------------------------------------

    def _r_list(self):
        # the key list comes from the parent object.
        self._rlist = self.P['$sshkeys']

    def _r_catalog(self):
        # no catalog but the keys
        self._rcatalog = dict((k, None) for k in self.list)

########NEW FILE########
__FILENAME__ = device
# stdlib
import os
import types
from inspect import isclass
import platform

# stdlib, in support of the the 'probe' method
import socket
import datetime
import time
import sys

# 3rd-party packages
from lxml import etree
from ncclient import manager as netconf_ssh
import ncclient.transport.errors as NcErrors
import paramiko
import jinja2

# local modules
from jnpr.junos.rpcmeta import _RpcMetaExec
from jnpr.junos import exception as EzErrors
from jnpr.junos.cfg import Resource
from jnpr.junos.facts import *
from jnpr.junos import jxml as JXML

_MODULEPATH = os.path.dirname(__file__)


class _MyTemplateLoader(jinja2.BaseLoader):

    """
    Create a jinja2 template loader class that can be used to
    load templates from all over the filesystem, but defaults
    to the CWD and the 'templates' directory of the module
    """

    def __init__(self):
        self.paths = ['.', os.path.join(_MODULEPATH, 'templates')]

    def get_source(self, environment, template):

        def _in_path(dir):
            return os.path.exists(os.path.join(dir, template))

        path = filter(_in_path, self.paths)
        if not path:
            raise jinja2.TemplateNotFound(template)

        path = os.path.join(path[0], template)
        mtime = os.path.getmtime(path)
        with file(path) as f:
            source = f.read().decode('utf-8')
        return source, path, lambda: mtime == os.path.getmtime(path)

_Jinja2ldr = jinja2.Environment(loader=_MyTemplateLoader())


class Device(object):
    ON_JUNOS = platform.system().upper() == 'JUNOS'    
    auto_probe = 0          # default is no auto-probe

    # -------------------------------------------------------------------------
    # PROPERTIES
    # -------------------------------------------------------------------------
    
    # ------------------------------------------------------------------------
    # property: hostname
    # ------------------------------------------------------------------------

    @property
    def hostname(self):
        """
        The hostname/ip-addr of the Junos device
        """
        return self._hostname if (
            self._hostname != 'localhost') else self.facts.get('hostname')

    # ------------------------------------------------------------------------
    # property: user
    # ------------------------------------------------------------------------

    @property
    def user(self):
        """
        The login user accessing the Junos device
        """
        return self._auth_user

    # ------------------------------------------------------------------------
    # property: password
    # ------------------------------------------------------------------------

    @property
    def password(self):
        """
          The login password to access the Junos deviec
        """
        return None  # read-only

    @password.setter
    def password(self, value):
        self._password = value

    # ------------------------------------------------------------------------
    # property: logfile
    # ------------------------------------------------------------------------

    @property
    def logfile(self):
        """
          simply returns the log file object
        """
        return self._logfile

    @logfile.setter
    def logfile(self, value):
        """
          assigns an opened file object to the device for logging
          If there is an open logfile, and 'value' is None/False
          then close the existing file
        """
        # got an existing file that we need to close
        if (not value) and (None != self._logfile):
            rc = self._logfile.close()
            self._logfile = False
            return rc

        if not isinstance(value, file):
            raise ValueError("value must be a file object")

        self._logfile = value
        return self._logfile

    # ------------------------------------------------------------------------
    # property: timeout
    # ------------------------------------------------------------------------

    @property
    def timeout(self):
        """ the netconf timeout value """
        return self._conn.timeout

    @timeout.setter
    def timeout(self, value):
        """ set the netconf timeout value """
        self._conn.timeout = value

    # ------------------------------------------------------------------------
    # property: facts
    # ------------------------------------------------------------------------

    @property
    def facts(self):
        return self._facts

    @facts.setter
    def facts(self, value):
        raise RuntimeError("facts is read-only!")

    # ------------------------------------------------------------------------
    # property: manages
    # ------------------------------------------------------------------------

    @property
    def manages(self):
        """
        returns a list of Resource Managers/Utilities attached to this
        isinstance using the :bind(): method
        """
        return self._manages

    # -----------------------------------------------------------------------
    # OVERLOADS
    # -----------------------------------------------------------------------

    def __repr__(self):
        return "Device(%s)" % self.hostname

    # -----------------------------------------------------------------------
    # CONSTRUCTOR
    # -----------------------------------------------------------------------

    def _sshconf_lkup(self):
        home = os.getenv('HOME')
        if not home:
            return
        sshconf_path = os.path.join(os.getenv('HOME'), '.ssh/config')
        if not os.path.exists(sshconf_path):
            return

        sshconf = paramiko.SSHConfig()
        sshconf.parse(open(sshconf_path, 'r'))
        found = sshconf.lookup(self._hostname)
        self._hostname = found.get('hostname', self._hostname)
        self._port = found.get('port', self._port)
        self._auth_user = found.get('user')

    def __init__(self, *vargs, **kvargs):
        """
        vargs[0] -- ALTERNATIVE for kvargs['host']

        kvargs['host'] -- REQUIRED for off-box
          device hostname or ipaddress

        kvargs['user'] -- OPTIONAL
          login user-name, uses $USER if not provided

        kvargs['password'] -- OPTIONAL
        kvargs['passwd'] -- OPTIONAL
          login password.  if not provided, assumed ssh-keys are enforced

        kvargs['port'] -- OPTIONAL
          device login port (defaults to 830)

        kvargs['gather_facts'] -- optional
          if :False: then the facts are not gathered on call to :open():

        kvargs['auto_probe'] -- OPTIONAL
            if non-zero then this enables auto_probe at time of :open():
            and defines the amount of time/seconds for the probe timeout
        """

        # ----------------------------------------
        # setup instance connection/open variables
        # ----------------------------------------

        hostname = vargs[0] if len(vargs) else kvargs.get('host')

        self._port = kvargs.get('port', 830)
        self._gather_facts = kvargs.get('gather_facts', True)
        self._auto_probe = kvargs.get('auto_probe', self.__class__.auto_probe)

        if self.__class__.ON_JUNOS is True and hostname is None:
            # ---------------------------------
            # running on a Junos device locally
            # ---------------------------------            
            self._auth_user = None
            self._auth_password = None
            self._hostname = 'localhost'
        else:
            # --------------------------            
            # making a remote connection
            # --------------------------
            if hostname is None:
                raise ValueError("You must provide the 'host' value")
            self._hostname = hostname
            # user will default to $USER
            self._auth_user = os.getenv('USER')
            # user can get updated by ssh_config
            self._sshconf_lkup()
            # but if user is explit from call, then use it.
            self._auth_user = kvargs.get('user') or self._auth_user
            self._auth_password = kvargs.get('password') or kvargs.get('passwd')
        
        # -----------------------------
        # initialize instance variables
        # ------------------------------

        self._conn = None
        self._j2ldr = _Jinja2ldr
        self._manages = []
        self._facts = {}

        # public attributes

        self.connected = False
        self.rpc = _RpcMetaExec(self)

    # -----------------------------------------------------------------------
    # Basic device methods
    # -----------------------------------------------------------------------

    def open(self, *vargs, **kvargs):
        """
        opens a connection to the device using existing login/auth
        information.

        kvargs['gather_facts']:
            If set to True/False will override the device instance value
            for only this open process

        kvargs['auto_probe']:
            if non-zero then this enables auto_probe and defines the amount 
            of time/seconds for the probe timeout
        """

        auto_probe = kvargs.get('auto_probe', self._auto_probe)
        if auto_probe is not 0:
            if not self.probe(auto_probe):
                raise EzErrors.ProbeError(self)

        try:
            ts_start = datetime.datetime.now()

            # open connection using ncclient transport
            self._conn = netconf_ssh.connect(
                host=self._hostname,
                port=self._port,
                username=self._auth_user,
                password=self._auth_password,
                hostkey_verify=False,
                device_params={'name': 'junos'})

        except NcErrors.AuthenticationError as err:
            # bad authentication credentials
            raise EzErrors.ConnectAuthError(self)

        except NcErrors.SSHError as err:
            # this is a bit of a hack for now, since we want to 
            # know if the connection was refused or we simply could
            # not open a connection due to reachability.  so using
            # a timestamp to differentiate the two conditions for now
            # if the diff is < 3 sec, then assume the host is 
            # reachable, but NETCONF connection is refushed. 

            ts_err = datetime.datetime.now()
            diff_ts = ts_err - ts_start
            if diff_ts.seconds < 3:
                raise EzErrors.ConnectRefusedError(self)

            # at this point, we assume that the connection
            # has timeed out due to ip-reachability issues

            if err.message.find('not open') > 0:
                raise EzErrors.ConnectTimeoutError(self)
            else:
                # otherwise raise a generic connection
                # error for now.  tag the new exception
                # with the original for debug
                cnx = EzErrors.ConnectError(self)
                cnx._orig = err
                raise cnx

        except socket.gaierror:
            # invalid DNS name, so unreachable
            raise EzErrors.ConnectUnknownHostError(self)

        except Exception as err:
            # anything else, we will re-raise as a
            # generic ConnectError
            cnx_err = EzErrors.ConnectError(self)
            cnx_err._orig = err 
            raise cnx_err

        self.connected = True

        gather_facts = kvargs.get('gather_facts', self._gather_facts)
        if gather_facts is True:
            self.facts_refresh()

        return self

    def close(self):
        """
        closes the connection to the device
        """
        self._conn.close_session()
        self.connected = False

    def execute(self, rpc_cmd, **kvargs):
        """
        Executes an XML RPC and returns results as either XML or native python

        rpc_cmd
          can either be an XML Element or xml-as-string.  In either case
          the command starts with the specific command element, i.e., not the
          <rpc> element itself

        kvargs['to_py']
          is a caller provided function that takes the response and
          will convert the results to native python types.  all kvargs
          will be passed to this function as well in the form:
          :to_py:( self, rpc_rsp, \**kvargs )
        """

        if isinstance(rpc_cmd, str):
            rpc_cmd_e = etree.XML(rpc_cmd)
        elif isinstance(rpc_cmd, etree._Element):
            rpc_cmd_e = rpc_cmd
        else:
            raise ValueError(
                "Dont know what to do with rpc of type %s" %
                rpc_cmd.__class__.__name__)

        # invoking a bad RPC will cause a connection object exception
        # will will be raised directly to the caller ... for now ...
        # @@@ need to trap this and re-raise accordingly.

        try:
            rpc_rsp_e = self._conn.rpc(rpc_cmd_e)._NCElement__doc
        except Exception as err:
            # err is an NCError from ncclient
            rsp = JXML.remove_namespaces(err.xml)
            # see if this is a permission error
            e = EzErrors.PermissionError if rsp.findtext('error-message') == 'permission denied' else EzErrors.RpcError
            raise e(cmd=rpc_cmd_e, rsp=rsp)

        # for RPCs that have embedded rpc-errors, need to check for those now

        rpc_errs = rpc_rsp_e.xpath('.//rpc-error')
        if len(rpc_errs):
            raise EzErrors.RpcError(rpc_cmd_e, rpc_rsp_e, rpc_errs)

        # skip the <rpc-reply> element and pass the caller first child element
        # generally speaking this is what they really want. If they want to
        # uplevel they can always call the getparent() method on it.

        try:
            ret_rpc_rsp = rpc_rsp_e[0]
        except IndexError:
            # no children, so assume it means we are OK
            return True

        # if the caller provided a "to Python" conversion function, then invoke
        # that now and return the results of that function.  otherwise just
        # return the RPC results as XML

        if kvargs.get('to_py'):
            return kvargs['to_py'](self, ret_rpc_rsp, **kvargs)
        else:
            return ret_rpc_rsp

    # ------------------------------------------------------------------------
    # cli - for cheating commands :-)
    # ------------------------------------------------------------------------

    def cli(self, command, format='text'):
        """
        Executes the CLI command and returns the CLI text output by default.

        command
          The CLI command to execute, e.g. "show version"

        format
          The return format, by default is text.  You can optionally select
          'xml' to return the XML structure.

        Notes:
          You can also use this method to obtain the XML RPC command for a
          given CLI command by using the pipe filter "| display xml rpc". When
          you do this, the return value is the XML RPC command. For example if
          you provide as the command "show version | display xml rpc", you will
          get back the XML Element <get-software-information>
        """
        try:
            rsp = self.rpc.cli(command, format)
            if rsp.tag == 'output':
                return rsp.text
            if rsp.tag == 'configuration-information':
                return rsp.findtext('configuration-output')
            if rsp.tag == 'rpc':
                return rsp[0]
            return rsp
        except:
            return "invalid command: " + command

    # ------------------------------------------------------------------------
    # Template: retrieves a Jinja2 template
    # ------------------------------------------------------------------------

    def Template(self, filename, parent=None, gvars=None):

        # templates are XML files, and the assumption here is that they will
        # have .xml extensions.  if the caller doesn't include any extension
        # be kind and add '.xml' for them

        if os.path.splitext(filename)[1] == '':
            filename = filename + '.xml'

        return self._j2ldr.get_template(filename, parent, gvars)

    # ------------------------------------------------------------------------
    # dealing with bind aspects
    # ------------------------------------------------------------------------

    def bind(self, *vargs, **kvargs):
        """
        Used to attach things to this Device instance

        vargs
          a list of functions that will get bound as instance methods to
          this Device instance

        kvargs
          name/class pairs that will create resource-managers bound as
          instance attributes to this Device instance
        """
        if len(vargs):
            for fn in vargs:
                # check for name clashes before binding
                if hasattr(self, fn.__name__):
                    raise ValueError(
                        "request attribute name %s already exists" %
                        fn.__name__)
            for fn in vargs:
                # bind as instance method, majik.
                self.__dict__[
                    fn.__name__] = types.MethodType(
                    fn,
                    self,
                    self.__class__)
            return

        # first verify that the names do not conflict with
        # existing object attribute names

        for name in kvargs.keys():
            # check for name-clashes before binding
            if hasattr(self, name):
                raise ValueError(
                    "requested attribute name %s already exists" %
                    name)

        # now instantiate items and bind to this :Device:
        for name, thing in kvargs.items():
            new_inst = thing(self)
            self.__dict__[name] = new_inst
            self._manages.append(name)

    # ------------------------------------------------------------------------
    # facts
    # ------------------------------------------------------------------------

    def facts_refresh(self):
        """
        reload the facts from the Junos device into :facts: property
        """
        for gather in FACT_LIST:
            gather(self, self._facts)

    # ------------------------------------------------------------------------
    # probe
    # ------------------------------------------------------------------------

    def probe(self, timeout=5, intvtimeout=1):
        """
        Probe the device to determine if the Device can accept a remote
        connection.
        This method is meant to be called *prior* to :open():
        This method will not work with ssh-jumphost environments.

        :timeout:
          the probe will report True/False if the device report connectivity
          within this timeout (seconds)

        :intvtimeout:
          timeout interval on the socket connection. Generally you should not
          change this value, but you can if you want to twiddle the frequency
          of the socket attempts on the connection
        """
        start = datetime.datetime.now()
        end = start + datetime.timedelta(seconds=timeout)
        probe_ok = True

        while datetime.datetime.now() < end:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(intvtimeout)
            try:
                s.connect((self.hostname, self._port))
                s.shutdown(socket.SHUT_RDWR)
                s.close()
                break
            except:
                time.sleep(1)
                pass
        else:
            elapsed = datetime.datetime.now() - start
            probe_ok = False

        return probe_ok

########NEW FILE########
__FILENAME__ = exception
from lxml import etree
from jnpr.junos import jxml


class RpcError(Exception):
    """
    Parent class for all junos-pyez RPC Exceptions
    """
    def __init__(self, cmd=None, rsp=None, errs=None):
        """
          :cmd: is the rpc command
          :rsp: is the rpc response (after <rpc-reply>)
          :errs: is a list of <rpc-error> elements
        """
        self.cmd = cmd
        self.rsp = rsp
        self.errs = errs

    def __repr__(self):
        """
          pprints the response XML attribute
        """
        if None != self.rsp:
            return etree.tostring(self.rsp, pretty_print=True)


class CommitError(RpcError):
    """
    Generated in response to a commit-check or a commit action.
    """
    def __init__(self, cmd=None, rsp=None, errs=None):
        RpcError.__init__(self, cmd, rsp, errs)
        self.rpc_error = jxml.rpc_error(rsp)


class LockError(RpcError):
    """
    Generated in response to attempting to take an exclusive
    lock on the configuration database.
    """
    def __init__(self, rsp):
        RpcError.__init__(self, rsp=rsp)
        self.rpc_error = jxml.rpc_error(rsp)


class UnlockError(RpcError):
    """
    Generated in response to attempting to unlock the
    configuration database.
    """
    def __init__(self, rsp):
        RpcError.__init__(self, rsp=rsp)
        self.rpc_error = jxml.rpc_error(rsp)


class PermissionError(RpcError):
    """
    Generated in response to invoking an RPC for which the
    auth user does not have user-class permissions.

    PermissionError.message gives you the specific RPC that cause
    the exceptions
    """
    def __init__(self, cmd=None, rsp=None):
        RpcError.__init__(self, cmd=cmd, rsp=rsp)
        self.message = rsp.findtext('.//bad-element')

#### ================================================================
#### ================================================================
####                    Connection Exceptions
#### ================================================================
#### ================================================================


class ConnectError(Exception):
    """
    Parent class for all connection related exceptions
    """

    @property
    def user(self):
        """ login user-name """
        return self.dev.user

    @property
    def host(self):
        """ login host name/ipaddr """
        return self.dev.hostname

    @property
    def port(self):
        """ login SSH port """
        return self.dev._port

    def __init__(self, dev):
        self.dev = dev
        # @@@ need to attach attributes for each access
        # @@@ to user-name, host, jump-host, etc.

    def __repr__(self):
        return "{0}({1})".format(
            self.__class__.__name__,
            self.dev.hostname)

    __str__ = __repr__


class ProbeError(ConnectError):
    """
    Generated if auto_probe is enabled and the probe action fails
    """
    pass


class ConnectAuthError(ConnectError):
    """
    Generated if the user-name, password is invalid
    """
    pass


class ConnectTimeoutError(ConnectError):
    """
    Generated if the NETCONF session fails to connect, could
    be due to the fact the device is not ip reachable; bad
    ipaddr or just due to routing
    """
    pass


class ConnectUnknownHostError(ConnectError):
    """
    Generated if the specific hostname does not DNS resolve
    """
    pass


class ConnectRefusedError(ConnectError):
    """
    Generated if the specified host denies the NETCONF; could
    be that the serivces is not enabled, or the host has
    too many connections already.
    """
    pass


class ConnectNotMasterError(ConnectError):
    """
    Generated if the connection is made to a non-master
    routing-engine.  This could be a backup RE on an MX
    device, or a virtual-chassis member (linecard), for example
    """
    pass

########NEW FILE########
__FILENAME__ = cfgtable
from lxml.builder import E
from jnpr.junos.factory.table import Table


class CfgTable(Table):

    # -----------------------------------------------------------------------
    # CONSTRUCTOR
    # -----------------------------------------------------------------------

    def __init__(self, dev):
        Table.__init__(self, dev)       # call parent constructor

        self._data_dict = self.DEFINE  # crutch
        self.ITEM_NAME_XPATH = self._data_dict.get('key', 'name')
        self.ITEM_XPATH = self._data_dict['get']
        self.view = self._data_dict.get('view')

    # -----------------------------------------------------------------------
    # PROPERTIES
    # -----------------------------------------------------------------------

    @property
    def required_keys(self):
        """
        return a list of the keys required when invoking :get():
        and :get_keys():
        """
        return self._data_dict.get('required_keys')

    @property
    def keys_required(self):
        """ True/False - if this Table requires keys """
        return self.required_keys is not None

    # -----------------------------------------------------------------------
    # PRIVATE METHODS
    # -----------------------------------------------------------------------

    def _buildxml(self, namesonly=True):
        """
        Return an lxml Element starting with <configuration> and comprised
        of the elements specified in the xpath expression.

        For example, and xpath = 'interfaces/interface' would produce:

         <configuration>
            <interfaces>
              <interface/>
            </interfaces>
          </configuration>

        If :namesonly: is True, then the XML will be encoded only to
        retrieve the XML name keys at the 'end' of the XPath expression.

        This return value can then be passed to dev.rpc.get_config()
        to retrieve the specifc data
        """
        xpath = self._data_dict['get']
        top = E('configuration')
        dot = top
        for name in xpath.split('/'):
            dot.append(E(name))
            dot = dot[0]

        if namesonly is True:
            dot.attrib['recurse'] = 'false'
        return top

    def _grindkey(self, key_xpath, key_value):
        """ returns list of XML elements for key values """
        simple = lambda: [E(key_xpath.replace('_', '-'), key_value)]
        composite = lambda: [E(xp.replace('_', '-'), xv)
                             for xp, xv in zip(key_xpath, key_value)]
        return simple() if isinstance(key_xpath, str) else composite()

    def _encode_requiredkeys(self, get_cmd, kvargs):
        """
        used to encode the required_keys values into the XML get-command.
        each of the required_key=<value> pairs are defined in :kvargs:
        """
        rqkeys = self._data_dict['required_keys']
        for key_name in self.required_keys:
            # create an XML element with the key/value
            key_value = kvargs.get(key_name)
            if key_value is None:
                raise ValueError("Missing required-key: '%s'" % key_name)
            key_xpath = rqkeys[key_name]
            add_keylist_xml = self._grindkey(key_xpath, key_value)

            # now link this item into the XML command, where key_name
            # designates the XML parent element
            dot = get_cmd.find('.//' + key_name.replace('_', '-'))
            if dot is None:
                raise RuntimeError(
                    "Unable to find parent XML for key: '%'" %
                    key_name)
            for _at, _add in enumerate(add_keylist_xml):
                dot.insert(_at, _add)

    def _encode_namekey(self, get_cmd, dot, namekey_value):
        """
        encodes the specific namekey_value into the get command so that the
        returned XML configuration is the complete hierarchy of data.
        """
        namekey_xpath = self._data_dict.get('key', 'name')
        keylist_xml = self._grindkey(namekey_xpath, namekey_value)
        for _add in keylist_xml:
            dot.append(_add)

    def _encode_getfields(self, get_cmd, dot):
        for field_xpath in self._data_dict['get_fields']:
            dot.append(E(field_xpath))

    def _keyspec(self):
        """ returns tuple (keyname-xpath, item-xpath) """
        return (self._data_dict.get('key', 'name'), self._data_dict['get'])

    # -------------------------------------------------------------------------
    # get - retrieve Table data
    # -------------------------------------------------------------------------

    def get(self, *vargs, **kvargs):
        """
        Retrieve configuration data for this table.  By default only the
        keys of the table is loaded.  This behavior can be overriden by
        either requesting a sepcifc table item, or by calling with
        kvargs['values']=True

        :vargs:
          [0] identifies a unique item in the table,
          same as calling with :kvargs['key']: value

        RESERVED :kvargs:
          'values' - True/False*, when set to True will cause all data item
          values to be retrieved, not just the name-keys.

          'key' - used to retrieve the contents of the table record, and not
          just the list of keys (default) [when namesonly=True]
        """
        if self.keys_required is True and not len(kvargs):
            raise ValueError(
                "This table has required-keys\n",
                self.required_keys)

        self._clearkeys()

        # determine if we need to get only the names of keys, or all of the
        # hierarchical data from the config.  The caller can explicitly set
        # :namesonly: in the call, or request a specific items.  A specific
        # item can be identified either by vargs[0] or kvargs['key'].
        #
        # a caller might want to *botH* specify a named item, and
        # namesonly=True simply to test for the existence of an item in the
        # config, yo!
        # this 'feature' doesn't work yet, but looking into it.

        b_values = kvargs.get('values')
        namesonly = (
            not (
                len(vargs) or (
                    'key' in kvargs))) if b_values is None else not(b_values)

        get_cmd = self._buildxml(namesonly=namesonly)

        # if this table requires additional keys, for the hierarchical
        # use-cases then make sure these are provided by the caller. Then
        # encode them into the 'get-cmd' XML

        if self.keys_required is True:
            self._encode_requiredkeys(get_cmd, kvargs)

        try:
            # see if the caller provided a named item.  this must
            # be an actual name of a thing, and not an index number.
            # ... at least for now ...
            named_item = kvargs.get('key') or vargs[0]
            dot = get_cmd.find(self._data_dict['get'])
            self._encode_namekey(get_cmd, dot, named_item)

            if 'get_fields' in self._data_dict:
                self._encode_getfields(get_cmd, dot)

        except:
            # caller not requesting a specific table item
            pass

        self._get_cmd = get_cmd   # for debug purposes

        # retrieve the XML configuration
        self.xml = self.RPC.get_config(get_cmd)

        # return self for call-chaining, yo!
        return self



    # -----------------------------------------------------------------------
    # OVERLOADS
    # -----------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = factory_cls
# stdlib
from copy import deepcopy

# local
from jnpr.junos.factory.cfgtable import CfgTable
from jnpr.junos.factory.optable import OpTable
from jnpr.junos.factory.table import Table

from jnpr.junos.factory.view import View
from jnpr.junos.factory.viewfields import ViewFields


def FactoryCfgTable(table_name=None, data_dict={}):
    if table_name is None:
        table_name = "CfgTable"
    new_cls = type(table_name, (CfgTable,), {})
    new_cls.DEFINE = deepcopy(data_dict)
    new_cls.__module__ = __name__.replace('factory_cls', 'CfgTable')
    return new_cls


def FactoryOpTable(cmd, args=None, args_key=None, item=None,
                   key=OpTable.ITEM_NAME_XPATH, view=None, table_name=None):
    if table_name is None:
        table_name = "OpTable." + cmd
    new_cls = type(table_name, (OpTable,), {})
    new_cls.GET_RPC = cmd
    new_cls.GET_ARGS = args or {}
    if args_key is not None:
        new_cls.GET_KEY = args_key
    new_cls.ITEM_XPATH = item
    new_cls.ITEM_NAME_XPATH = key
    new_cls.VIEW = view
    new_cls.__module__ = __name__.replace('factory_cls', 'OpTable')
    return new_cls


def FactoryTable(item, key=Table.ITEM_NAME_XPATH, view=None, table_name=None):
    if table_name is None:
        table_name = 'Table.' + item
    new_cls = type(table_name, (Table,), {})
    new_cls.ITEM_XPATH = item
    new_cls.ITEM_NAME_XPATH = key
    new_cls.VIEW = view
    new_cls.__module__ = __name__.replace('factory_cls', 'Table')
    return new_cls


def FactoryView(fields, **kvargs):
    """
    :fields:
      dictionary of fields, structure of which is ~internal~ and should
      not be defined explicitly. use the RunstatMaker.Fields() mechanism to
      create theserather than hardcoding the dictionary structures;
      since they might change over time.

    :kvargs:
      'view_name' to name the class.  this could be useful for debug
      or eventual callback mechanisms.

      'groups' is a dict of name/xpath assocaited to fields
      this technique would be used to extract fields from
      node-set elements like port <if-device-flags>.

      'extends' names the base View class to extend.  using this
      technique you can add to existing defined Views.
    """

    view_name = kvargs.get('view_name', 'RunstatView')
    new_cls = type(view_name, (View,), {})

    if 'extends' in kvargs:
        base_cls = kvargs['extends']
        new_cls.FIELDS = deepcopy(base_cls.FIELDS)
        new_cls.FIELDS.update(fields)
        if 'groups' in kvargs:
            new_cls.GROUPS = deepcopy(base_cls.GROUPS)
            new_cls.GROUPS.update(kvargs['groups'])
    else:
        new_cls.FIELDS = fields
        new_cls.GROUPS = kvargs['groups'] if 'groups' in kvargs else None

    new_cls.__module__ = __name__.replace('factory_cls', 'View')
    return new_cls

########NEW FILE########
__FILENAME__ = factory_loader
"""
This file contains the FactoryLoader class that is used to dynamically
create Runstat Table and View objects from a <dict> of data.  The <dict> can
originate from any kind of source: YAML, JSON, program.  For examples of YAML
refer to the .yml files in this jnpr.junos.op directory.
"""
# stdlib
from copy import deepcopy

# locally
from jnpr.junos.factory.factory_cls import *
from jnpr.junos.factory.viewfields import *

__all__ = ['FactoryLoader']

# internally used shortcuts

_VIEW = FactoryView
_FIELDS = ViewFields
_GET = FactoryOpTable
_TABLE = FactoryTable
_CFGTBL = FactoryCfgTable


class FactoryLoader(object):

    """
    Used to load a <dict> of data that contains Table and View definitions.

    The primary method is :load(): which will return a <dict> of item-name and
    item-class definitions.

    If you want to import these definitions directly into your namespace,
    (like a module) you would do the following:

      loader = FactoryLoader()
      catalog = loader.load( <catalog_dict> )
      globals().update( catalog )

    If you did not want to do this, you can access the items as the catalog.
    For example, if your <catalog_dict> contained a Table called MyTable, then
    you could do something like:

      MyTable = catalog['MyTable']
      table = MyTable(dev)
      table.get()
      ...
    """

    def __init__(self):
        self._catalog_dict = None       # YAML data

        self._item_optables = []    # list of the get/op-tables
        self._item_cfgtables = []   # list of get/cfg-tables
        self._item_views = []        # list of views to build
        self._item_tables = []       # list of tables to build

        self.catalog = {}           # catalog of built classes

    # -----------------------------------------------------------------------
    # Create a View class from YAML definition
    # -----------------------------------------------------------------------

    def _fieldfunc_True(self, value_rhs):
        return lambda x: x == value_rhs

    def _fieldfunc_False(self, value_rhs):
        return lambda x: x != value_rhs

    def _add_dictfield(self, fields, f_name, f_dict, kvargs):
        """ add a field based on its associated dictionary """
        # at present if a field is a <dict> then there is **one
        # item** - { the xpath value : the option control }.  typically
        # the option would be a bultin class type like 'int'
        # however, as this framework expands in capability, this
        # will be enhaced, yo!

        xpath, opt = f_dict.items()[0]       # get first/only key,value
        if 'flag' == opt:
            opt = 'bool'       # flag is alias for bool

        # first check to see if the option is a built-in Python
        # type, most commonly would be 'int' for numbers, like counters

        astype = __builtins__.get(opt) or globals().get(opt)
        if astype is not None:
            kvargs['astype'] = astype
            fields.astype(f_name, xpath, **kvargs)
            return

        # next check to see if this is a "field-function"
        # operator in the form "func=value", like "True=enabled"

        if isinstance(opt, str) and opt.find('=') > 0:
            field_cmd, value_rhs = opt.split('=')
            fn_field = '_fieldfunc_' + field_cmd
            if not hasattr(self, fn_field):
                raise ValueError("Unknown field-func: '%'" % field_cmd)
            kvargs['astype'] = getattr(self, fn_field)(value_rhs)
            fields.astype(f_name, xpath, **kvargs)
            return

        raise RuntimeError("Dont know what to do with field: '%s'" % f_name)

    # ---[ END: _add_dictfield ] ---------------------------------------------

    def _add_view_fields(self, view_dict, fields_name, fields):
        """ add a group of fields to the view """
        fields_dict = view_dict[fields_name]
        try:
            # see if this is a 'fields_<group>' collection, and if so
            # then we automatically setup using the group mechanism
            mark = fields_name.index('_')
            group = {'group': fields_name[mark + 1:]}
        except:
            # otherwise, no group, just standard 'fields'
            group = {}

        for f_name, f_data in fields_dict.items():
            # each field could have its own unique set of properties
            # so create a kvargs <dict> each time.  but copy in the
            # groups <dict> (single item) generically.
            kvargs = {}
            kvargs.update(group)

            if isinstance(f_data, dict):
                self._add_dictfield(fields, f_name, f_data, kvargs)
                continue

            if f_data in self._catalog_dict:
                # f_data is the table name
                cls_tbl = self.catalog.get(f_data, self._build_table(f_data))
                fields.table(f_name, cls_tbl)
                continue

            # if we are here, then it means that the field is a string value
            xpath = f_name if f_data is True else f_data
            fields.str(f_name, xpath, **kvargs)

    # -------------------------------------------------------------------------

    def _build_view(self, view_name):
        """ build a new View definition """
        if view_name in self.catalog:
            return self.catalog[view_name]

        view_dict = self._catalog_dict[view_name]
        kvargs = {'view_name': view_name}

        # if there are field groups, then get that now.
        if 'groups' in view_dict:
            kvargs['groups'] = view_dict['groups']

        # if this view extends another ...
        if 'extends' in view_dict:
            base_cls = self.catalog.get(view_dict['extends'])
            # @@@ should check for base_cls is None!
            kvargs['extends'] = base_cls

        fields = _FIELDS()
        fg_list = [name for name in view_dict if name.startswith('fields')]
        for fg_name in fg_list:
            self._add_view_fields(view_dict, fg_name, fields)

        cls = _VIEW(fields.end, **kvargs)
        self.catalog[view_name] = cls
        return cls

    # -----------------------------------------------------------------------
    # Create a Get-Table from YAML definition
    # -----------------------------------------------------------------------

    def _build_optable(self, table_name):
        """ build a new Get-Table definition """
        if table_name in self.catalog:
            return self.catalog[table_name]

        tbl_dict = self._catalog_dict[table_name]
        kvargs = deepcopy(tbl_dict)

        rpc = kvargs.pop('rpc')
        kvargs['table_name'] = table_name

        if 'view' in tbl_dict:
            view_name = tbl_dict['view']
            cls_view = self.catalog.get(view_name, self._build_view(view_name))
            kvargs['view'] = cls_view

        cls = _GET(rpc, **kvargs)
        self.catalog[table_name] = cls
        return cls

    # -----------------------------------------------------------------------
    # Create a Table class from YAML definition
    # -----------------------------------------------------------------------

    def _build_table(self, table_name):
        """ build a new Table definition """
        if table_name in self.catalog:
            return self.catalog[table_name]

        tbl_dict = self._catalog_dict[table_name]

        table_item = tbl_dict.pop('item')
        kvargs = deepcopy(tbl_dict)
        kvargs['table_name'] = table_name

        if 'view' in tbl_dict:
            view_name = tbl_dict['view']
            cls_view = self.catalog.get(view_name, self._build_view(view_name))
            kvargs['view'] = cls_view

        cls = _TABLE(table_item, **kvargs)
        self.catalog[table_name] = cls
        return cls

    def _build_cfgtable(self, table_name):
        """ build a new Config-Table definition """
        if table_name in self.catalog:
            return self.catalog[table_name]
        tbl_dict = self._catalog_dict[table_name]

        if 'view' in tbl_dict:
            # transpose name to class
            view_name = tbl_dict['view']
            tbl_dict['view'] = self.catalog.get(
                view_name,
                self._build_view(view_name))

        cls = _CFGTBL(table_name, tbl_dict)
        self.catalog[table_name] = cls
        return cls

    # -----------------------------------------------------------------------
    # Primary builders ...
    # -----------------------------------------------------------------------

    def _sortitems(self):
        for k, v in self._catalog_dict.items():
            if 'rpc' in v:
                self._item_optables.append(k)
            elif 'get' in v:
                self._item_cfgtables.append(k)
            elif 'view' in v:
                self._item_tables.append(k)
            else:
                self._item_views.append(k)

    def load(self, catalog_dict, envrion={}):

        # load the yaml data and extract the item names.  these names will
        # become the new class definitions

        self._catalog_dict = catalog_dict
        self._sortitems()

        map(self._build_optable, self._item_optables)
        map(self._build_cfgtable, self._item_cfgtables)
        map(self._build_table, self._item_tables)
        map(self._build_view, self._item_views)

        return self.catalog

########NEW FILE########
__FILENAME__ = optable
# 3rd-party
from lxml import etree

# local
from jnpr.junos.factory.table import Table


class OpTable(Table):

    # -------------------------------------------------------------------------
    # PUBLIC METHODS
    # -------------------------------------------------------------------------

    def get(self, *vargs, **kvargs):
        """
        Retrieve the XML table data from the Device instance and
        returns back the Table instance - for call-chaining purposes.

        If the Table was created with a :path: rather than a Device,
        then this method will load the XML from that file.  In this
        case, the \*vargs, and \**kvargs are not used.

        ALIAS: __call__

        :vargs:
          [0] is the table :arg_key: value.  This is used so that
          the caller can retrieve just one item from the table without
          having to know the Junos RPC argument.

        :kvargs:
          these are the name/value pairs relating to the specific Junos
          XML command attached to the table.  For example, if the RPC
          is 'get-route-information', there are parameters such as
          'table' and 'destination'.  Any valid RPC argument can be
          passed to :kvargs: to further filter the results of the :get():
          operation.  neato!

        NOTES:
          If you need to create a 'stub' for unit-testing
          purposes, you want to create a subclass of your table and
          overload this methods.
        """
        self._clearkeys()

        if self._path is not None:
            # for loading from local file-path
            self.xml = etree.parse(self._path).getroot()
            return self

        argkey = vargs[0] if len(vargs) else None

        rpc_args = {}                     # create empty <dict>
        rpc_args.update(self.GET_ARGS)    # copy default args
        rpc_args.update(kvargs)           # copy caller provided args

        if hasattr(self, 'GET_KEY') and argkey is not None:
            rpc_args.update({self.GET_KEY: argkey})

        # execute the Junos RPC to retrieve the table
        self.xml = getattr(self.RPC, self.GET_RPC)(**rpc_args)

        # returning self for call-chaining purposes, yo!
        return self

########NEW FILE########
__FILENAME__ = table
# stdlib
from inspect import isclass
from time import time
from datetime import datetime
import os

# 3rd-party
from lxml import etree

_TSFMT = "%Y%m%d%H%M%S"


class Table(object):
    ITEM_XPATH = None
    ITEM_NAME_XPATH = 'name'
    VIEW = None

    def __init__(self, dev=None, xml=None, path=None):
        """
        :dev: Device instance
        :xml: lxml Element instance
        :path: file path to XML, to be used rather than :dev:
        """
        self._dev = dev
        self.xml = xml
        self.view = self.VIEW
        self._key_list = []
        self._path = path

    # -------------------------------------------------------------------------
    # PROPERTIES
    # -------------------------------------------------------------------------

    @property
    def D(self):
        """ the Device instance """
        return self._dev

    @property
    def RPC(self):
        """ the Device.rpc instance """
        return self.D.rpc

    @property
    def view(self):
        """ returns the current view assigned to this table """
        return self._view

    @view.setter
    def view(self, cls):
        """ assigns a new view to the table """
        if cls is None:
            self._view = None
            return

        if not isclass(cls):
            raise ValueError("Must be given RunstatView class")

        self._view = cls

    @property
    def hostname(self):
        return self.D.hostname

    @property
    def is_container(self):
        """
        True if this table does not have records, but is a container of fields
        False otherwise
        """
        return self.ITEM_XPATH is None

    @property
    def key_list(self):
        """ the list of keys, as property for caching """
        return self._key_list

    # -------------------------------------------------------------------------
    # PRIVATE METHODS
    # -------------------------------------------------------------------------

    def _assert_data(self):
        if self.xml is None:
            raise RuntimeError("Table is empty, use get()")

    def _keys_composite(self, xpath, key_list):
        """ composite keys return a tuple of key-items """
#    _tkey = lambda this: tuple([this.findtext(k) for k in key_list ])
        _tkey = lambda this: tuple([this.xpath(k)[0].text for k in key_list])
        return [_tkey(item) for item in self.xml.xpath(xpath)]

    def _keys_simple(self, xpath):
        return [x.text.strip() for x in self.xml.xpath(xpath)]

    def _keyspec(self):
        """ returns tuple (keyname-xpath, item-xpath) """
        return (self.ITEM_NAME_XPATH, self.ITEM_XPATH)

    def _clearkeys(self):
        self._key_list = []

    # -------------------------------------------------------------------------
    # PUBLIC METHODS
    # -------------------------------------------------------------------------

    # ------------------------------------------------------------------------
    # keys
    # ------------------------------------------------------------------------

    def _keys(self):
        """ return a list of data item keys from the Table XML """

        self._assert_data()
        key_value, xpath = self._keyspec()

        if isinstance(key_value, str):
            return self._keys_simple(xpath + '/' + key_value)

        if not isinstance(key_value, list):
            raise RuntimeError(
                "What to do with key, table:'%'" %
                self.__class__.__name__)

        # ok, so it's a list, which means we need to extract tuple values
        return self._keys_composite(xpath, key_value)

    def keys(self):
        # if the key_list has been cached, then use it
        if len(self.key_list):
            return self.key_list

        # otherwise, build the list of keys into the cache
        self._key_list = self._keys()
        return self._key_list

    # ------------------------------------------------------------------------
    # values
    # ------------------------------------------------------------------------

    def values(self):
        """ returns list of table entry items() """

        self._assert_data()
        if self.view is None:
            # no View, so provide XML for each item
            return [this for this in self]
        else:
            # view object for each item
            return [this.items() for this in self]

    # ------------------------------------------------------------------------
    # items
    # ------------------------------------------------------------------------

    def items(self):
        """ returns list of tuple(name,values) for each table entry """
        return zip(self.keys(), self.values())

    # ------------------------------------------------------------------------
    # get - loads the data from source
    # ------------------------------------------------------------------------

    def get(self, *vargs, **kvargs):
        # implemented by either OpTable or CfgTable
        # @@@ perhaps this should raise an exception rather than just 'pass',??
        pass

    # ------------------------------------------------------------------------
    # savexml - saves the table XML to a local file
    # ------------------------------------------------------------------------

    def savexml(self, path, hostname=False, timestamp=False, append=None):
        """
        Save a copy of the table XML data to a local file.  The name of the
        output file (:path:) can include the name of the Device host, the
        timestamp of this action, as well as any user-defined appended value.
        These 'add-ons' will be added to the :path: value prior to the file
        extension in the order (hostname,timestamp,append), separated by
        underscore (_).

        For example, if both hostname=True and append='BAZ1', then when
        :path: = '/var/tmp/foo.xml' and the Device.hostname is "srx123", the
        final file-path will be "/var/tmp/foo_srx123_BAZ1.xml"

        :path:
          file-path to write the XML file on the local filesystem

        :hostname:
          if True, will append the hostname to the :path:

        :timestamp:
          if True, will append the timestamp to the :path: using the default
            timestamp format
          if <str> the timestamp will use the value as the timestamp format as
            defied by strftime()

        :append:
          any <str> value that you'd like appended to the :path: value
          preceding the filename extension.
        """
        fname, fext = os.path.splitext(path)

        if hostname is True:
            fname += "_%s" % self.D.hostname

        if timestamp is not False:
            tsfmt = _TSFMT if timestamp is True else timestamp
            tsfmt_val = datetime.fromtimestamp(time()).strftime(tsfmt)
            fname += "_%s" % tsfmt_val

        if append is not None:
            fname += "_%s" % append

        path = fname + fext
        return etree.ElementTree(self.xml).write(file(path, 'w'))

    # -------------------------------------------------------------------------
    # OVERLOADS
    # -------------------------------------------------------------------------

    __call__ = get

    def __repr__(self):
        cls_name = self.__class__.__name__
        source = self.D.hostname if self.D is not None else self._path

        if self.xml is None:
            return "%s:%s - Table empty" % (cls_name, source)
        else:
            n_items = len(self.keys())
            return "%s:%s: %s items" % (cls_name, source, n_items)

    def __len__(self):
        self._assert_data()
        return len(self.keys())

    def __iter__(self):
        """ iterate over each time in the table """
        self._assert_data()

        as_xml = lambda table, view_xml: view_xml
        view_as = self.view or as_xml

        for this in self.xml.xpath(self.ITEM_XPATH):
            yield view_as(self, this)

    def __getitem__(self, value):
        """
        returns a table item. If a table view is set (should be by default)
        then the item will be converted to the view upon return.  if there is
        no table view, then the XML object will be returned.

        :value:
          for <string>, this will perform a select based on key-name
          for <tuple>, this will perform a select based on compsite key-name
          for <int>, this will perform a select based by position, like <list>
            [0] is the first item
            [-1] is the last item
          when it is a <slice> then this will return a <list> of View widgets
        """
        self._assert_data()
        keys = self.keys()

        if isinstance(value, int):
            # if selection by index, then grab the key at this index and
            # recursively call this method using that key, yo!
            return self.__getitem__(keys[value])

        if isinstance(value, slice):
            # implements the 'slice' mechanism
            return [self.__getitem__(key) for key in keys[value]]

        # ---[ get_xpath ] ----------------------------------------------------

        def get_xpath(find_value):
            namekey_xpath, item_xpath = self._keyspec()
            xnkv = '[normalize-space({})="{}"]'

            if isinstance(find_value, str):
                # find by name, simple key
                return item_xpath + xnkv.format(namekey_xpath, find_value)

            if isinstance(find_value, tuple):
                # composite key (value1, value2, ...) will create an
                # iterative xpath of the fmt statement for each key/value pair
                xpf = ''.join([xnkv.format(k.replace('_', '-'), v)
                              for k, v in zip(namekey_xpath, find_value)])
                return item_xpath + xpf

        # ---[END: get_xpath ] ------------------------------------------------

        found = self.xml.xpath(get_xpath(value))
        if not len(found):
            return None

        as_xml = lambda table, view_xml: view_xml
        use_view = self.view or as_xml

        return use_view(table=self, view_xml=found[0])

    def __contains__(self, key):
        """ membership for use with 'in' """
        return bool(key in self.keys())

########NEW FILE########
__FILENAME__ = view
import warnings
from contextlib import contextmanager
from copy import deepcopy
from lxml import etree

from jnpr.junos.factory.viewfields import ViewFields


class View(object):

    """
    View is the base-class that makes extracting values from XML
    data appear as objects with attributes.
    """

    ITEM_NAME_XPATH = 'name'
    FIELDS = {}
    GROUPS = None

    # -------------------------------------------------------------------------
    # CONSTRUCTOR
    # -------------------------------------------------------------------------

    def __init__(self, table, view_xml):
        """
        :table:
          instance of the RunstatTable

        :view_xml:
          this should be an lxml etree Elemenet object.  This
          constructor also accepts a list with a single item/XML
        """
        # if as_xml is passed as a list, make sure it only has
        # a single item, common response from an xpath search
        if isinstance(view_xml, list):
            if 1 == len(view_xml):
                view_xml = view_xml[0]
            else:
                raise ValueError("constructor only accepts a single item")

        # now ensure that the thing provided is an lxml etree Element
        if not isinstance(view_xml, etree._Element):
            raise ValueError("constructor only accecpts lxml.etree._Element")

        self._table = table
        self.ITEM_NAME_XPATH = table.ITEM_NAME_XPATH
        self._init_xml(view_xml)

    def _init_xml(self, given_xml):
        self._xml = given_xml
        if self.GROUPS is not None:
            self._groups = {}
            for xg_name, xg_xpath in self.GROUPS.items():
                xg_xml = self._xml.xpath(xg_xpath)
                # @@@ this is technically an error; need to trap it
                if not len(xg_xml):
                    continue
                self._groups[xg_name] = xg_xml[0]

    # -------------------------------------------------------------------------
    # PROPERTIES
    # -------------------------------------------------------------------------

    @property
    def T(self):
        """ return the Table instance for the View """
        return self._table

    @property
    def D(self):
        """ return the Device instance for this View """
        return self.T.D

    @property
    def name(self):
        """ return the name of view item """
        if self.ITEM_NAME_XPATH is None:
            return self._table.D.hostname
        if isinstance(self.ITEM_NAME_XPATH, str):
            # simple key
            return self._xml.findtext(self.ITEM_NAME_XPATH).strip()
        else:
            # composite key
# return tuple([self.xml.findtext(i).strip() for i in
# self.ITEM_NAME_XPATH])
            return tuple([self.xml.xpath(i)[0].text.strip()
                         for i in self.ITEM_NAME_XPATH])

    # ALIAS key <=> name
    key = name

    @property
    def xml(self):
        """ returns the XML associated to the item """
        return self._xml

    # -------------------------------------------------------------------------
    # METHODS
    # -------------------------------------------------------------------------

    def keys(self):
        """ list of view keys, i.e. field names """
        return self.FIELDS.keys()

    def values(self):
        """ list of view values """
        return [getattr(self, field) for field in self.keys()]

    def items(self):
        """ list of tuple(key,value) """
        return zip(self.keys(), self.values())

    def _updater_instance(self, more):
        """ called from extend """
        if hasattr(more, 'fields'):
            self.FIELDS = deepcopy(self.__class__.FIELDS)
            self.FIELDS.update(more.fields.end)

        if hasattr(more, 'groups'):
            self.GROUPS = deepcopy(self.__class__.GROUPS)
            self.GROUPS.update(more.groups)

    def _updater_class(self, more):
        """ called from extend """
        if hasattr(more, 'fields'):
            self.FIELDS.update(more.fields.end)

        if hasattr(more, 'groups'):
            self.GROUPS.update(more.groups)

    @contextmanager
    def updater(self, fields=True, groups=False, all=True, **kvargs):
        """
        provide the ability for subclassing objects to extend the
        definitions of the fields.  this is implemented as a
        context manager with the form called from the subclass
        constructor:

          with self.extend() as more:
            more.fields = <dict>
            more.groups = <dict>   # optional
        """
        # ---------------------------------------------------------------------
        # create a new object class so we can attach stuff to it arbitrarily.
        # then pass that object to the caller, yo!
        # ---------------------------------------------------------------------

        more = type('RunstatViewMore', (object,), {})()
        if fields is True:
            more.fields = RunstatMakerViewFields()

        # ---------------------------------------------------------------------
        # callback through context manager
        # ---------------------------------------------------------------------

        yield more
        updater = self._updater_class if all is True else \
            self._updater_instance
        updater(more)

    def asview(self, view_cls):
        """ create a new View object for this item """
        return view_cls(self._table, self._xml)

    def refresh(self):
        """
        ~~~ EXPERIMENTAL ~~~
        refresh the data from the Junos device.  this only works if the table
        provides an "args_key", does not update the original table, just this
        specific view/item
        """
        warnings.warn("Experimental method: refresh")

        if self._table.can_refresh is not True:
            raise RuntimeError("table does not support this feature")

        # create a new table instance that gets only the specific named
        # value of this view

        tbl_xml = self._table._rpc_get(self.name)
        new_xml = tbl_xml.xpath(self._table.ITEM_XPATH)[0]
        self._init_xml(new_xml)
        return self

    # -------------------------------------------------------------------------
    # OVERLOADS
    # -------------------------------------------------------------------------

    def __repr__(self):
        """ returns the name of the View with the associate item name """
        return "%s:%s" % (self.__class__.__name__, self.name)

    def __getattr__(self, name):
        """
        returns a view item value, called as :obj.name:
        """
        item = self.FIELDS.get(name)
        if item is None:
            raise ValueError("Unknown field: '%s'" % name)

        if 'table' in item:
            # if this is a sub-table, then return that now
            return item['table'](self.D, self._xml)

        # otherwise, not a sub-table, and handle the field
        astype = item.get('astype', str)
        if 'group' in item:
            found = self._groups[item['group']].xpath(item['xpath'])
        else:
            found = self._xml.xpath(item['xpath'])

        len_found = len(found)

        if astype is bool:
            # handle the boolean flag case separately
            return bool(len_found)

        if not len_found:
            # even for the case of numbers, do not set the value.  we
            # want to detect "does not exist" vs. defaulting to 0
            # -- 2013-nov-19, JLS.
            return None

        try:
            # added exception handler to catch malformed xpath expressesion
            # -- 2013-nov-19, JLS.
            # added support to handle multiple xpath values, i.e. a list of
            # things that have the same xpath expression (common in configs)
            # -- 2031-dec-06, JLS
            # added support to use the element tag if the text is empty
            def _munch(x):
                as_str = x if isinstance(x, str) else x.text
                if as_str is not None:
                    as_str = as_str.strip()
                if not as_str:
                    as_str = x.tag     # use 'not' to test for empty
                return astype(as_str)

            if 1 == len_found:
                return _munch(found[0])
            return [_munch(this) for this in found]

        except:
            raise RuntimeError("Unable to handle field:'%s'" % name)

        # and if we are here, then we didn't handle the field.
        raise RuntimeError("Unable to handle field:'%s'" % name)

    def __getitem__(self, name):
        """
        allow the caller to extract field values using :obj['name']:
        the same way they would do :obj.name:
        """
        return getattr(self, name)

########NEW FILE########
__FILENAME__ = viewfields
class ViewFields(object):

    """
    Used to dynamically create a field dictionary used with the
    RunstatView class
    """

    def __init__(self):
        self._fields = dict()

    def _prockvargs(self, field, name, **kvargs):
        if not len(kvargs):
            return
        field[name].update(kvargs)

    @property
    def end(self):
        return self._fields

    def str(self, name, xpath=None, **kvargs):
        """ field is a string """
        if xpath is None:
            xpath = name
        field = {name: {'xpath': xpath}}
        self._prockvargs(field, name, **kvargs)
        self._fields.update(field)
        return self

    def astype(self, name, xpath=None, astype=int, **kvargs):
        """
        field string value will be passed to function :astype:

        This is typically used to do simple type conversions,
        but also works really well if you set :astype: to
        a function that does a basic converstion like look
        at the value and change it to a True/False.  For
        example:

          astype=lambda x: True if x == 'enabled' else False
        """
        if xpath is None:
            xpath = name
        field = {
            name: {'xpath': xpath, 'astype': astype}
        }
        self._prockvargs(field, name, **kvargs)
        self._fields.update(field)
        return self

    def int(self, name, xpath=None, **kvargs):
        """ field is an integer """
        return self.astype(name, xpath, int, **kvargs)

    def flag(self, name, xpath=None, **kvargs):
        """
        field is a flag, results in True/False if the xpath element exists or
        not. Model this as a boolean type <bool>
        """
        return self.astype(name, xpath, bool, **kvargs)

    def table(self, name, table):
        """ field is a RunstatTable """
        self._fields.update({
            name: {'table': table}
        })
        return self

########NEW FILE########
__FILENAME__ = chassis
from lxml.builder import E
from jnpr.junos import jxml as JXML
from jnpr.junos.exception import ConnectNotMasterError

def facts_chassis(junos, facts):
    """
    The following facts are assigned:
      facts['model'] : product model
      facts['serialnumber'] : serial number

    NOTES:
        (1) if in a 2RE system, this routine will only load the information
            from the first chassis item.
        (2) hostname, domain, and fqdn are retrieved from configuration data;
            inherited configs are checked.
    """
    try:
        rsp = junos.rpc.get_chassis_inventory()
        if rsp.tag == 'error': raise RuntimeError()
    except:
        # this means that the RPC caused a trap.  this should generally
        # never happen, but we'll trap it cleanly for now
        facts['2RE'] = False
        facts['model'] = ''
        facts['serialnumber'] = ''      
        return  

    if rsp.tag == 'output':
        # this means that there was an error; due to the
        # fact that this connection is not on the master
        # @@@ need to validate on VC-member
        raise ConnectNotMasterError(junos)

    if rsp.tag == 'multi-routing-engine-results':
        facts['2RE'] = True
        x_ch = rsp.xpath('.//chassis-inventory')[0].find('chassis')
    else:
        facts['2RE'] = False
        x_ch = rsp.find('chassis')

    facts['model'] = x_ch.find('description').text
    try:
        facts['serialnumber'] = x_ch.find('serial-number').text
    except:
        # if the toplevel chassis does not have a serial-number, then
        # check the Backplane chassis-module
        facts['serialnumber'] = x_ch.xpath(
            'chassis-module[name="Backplane"]/serial-number')[0].text

########NEW FILE########
__FILENAME__ = domain
from jnpr.junos.utils.fs import FS

def facts_domain(junos, facts):
    """
    The following facts are required:
        facts['hostname']

    The following facts are assigned:
        facts['domain']
        facts['fqdn']
    """
    fs = FS(junos)
    words = fs.cat('/etc/resolv.conf').split()
    if 'domain' not in words:
        facts['domain'] = None
        facts['fqdn'] = facts['hostname']
    else:
        idx = words.index('domain') + 1
        facts['domain'] = words[idx]
        facts['fqdn'] = facts['hostname'] + '.' + facts['domain']

########NEW FILE########
__FILENAME__ = ifd_style
def facts_ifd_style(junos, facts):
    persona = facts['personality']
    if persona == 'SWITCH':
        facts['ifd_style'] = 'SWITCH'
    else:
        facts['ifd_style'] = 'CLASSIC'

########NEW FILE########
__FILENAME__ = personality
import re

def facts_personality(junos, facts):

    model = facts['model']

    if model != 'Virtual Chassis':
        examine = model
    else:
        for fact in facts:
            if re.match("^RE\d", fact):
                examine = facts[fact]['model']
                break

    if re.match("^(EX)|(QFX)", examine):
        persona = 'SWITCH'
    elif examine.startswith("MX"):
        persona = 'MX'
    elif examine.startswith("vMX"):
        facts['virtual'] = True
        persona = 'MX'
    elif examine.startswith("VJX"):
        facts['virtual'] = True
        persona = 'SRX_BRANCH'
    elif examine.startswith("M"):
        persona = "M"
    elif examine.startswith("T"):
        persona = "T"
    elif examine.startswith("PTX"):
        persona = "PTX"
    elif re.match("SRX\s?(\d){4}", examine):
        persona = 'SRX_HIGHEND'
    elif re.match("SRX\s?(\d){3}", examine):
        persona = 'SRX_BRANCH'
    elif re.search("firefly", examine, re.IGNORECASE):
        facts['virtual'] = True
        persona = 'SRX_BRANCH'
    elif 'olive' == examine:
        facts['virtual'] = True
        persona = 'OLIVE'
    else:
        persona = "UNKNOWN"

    facts['personality'] = persona

########NEW FILE########
__FILENAME__ = routing_engines
import re as RE

def facts_routing_engines(junos, facts):

    re_facts = [
        'mastership-state',
        'status',
        'model',
        'up-time',
        'last-reboot-reason']

    try:
        re_info = junos.rpc.get_route_engine_information()
    except:
        # this means that the RPC failed.  this should "never"
        # happen, but we will trap it cleanly for now
        return

    master = []
    re_list = re_info.xpath('.//route-engine')
    if len(re_list) > 1:
        facts['2RE'] = True

    for re in re_list:
        x_re_name = re.xpath('ancestor::multi-routing-engine-item/re-name')

        if not x_re_name:
            # not a multi-instance routing engine platform, but could
            # have multiple RE slots
            re_name = "RE"
            x_slot = re.find('slot')
            slot_id = x_slot.text if x_slot is not None else "0"
            re_name = re_name + slot_id
        else:
            # multi-instance routing platform
            m = RE.search('(\d)', x_re_name[0].text)
            re_name = "RE" + m.group(0)   # => RE0 | RE1

        re_fd = {}
        facts[re_name] = re_fd
        for factoid in re_facts:
            x_f = re.find(factoid)
            if x_f is not None:
                re_fd[factoid.replace('-', '_')] = x_f.text

        if 'mastership_state' in re_fd:
            if facts[re_name]['mastership_state'] == 'master':
                master.append(re_name)

    # --[ end for-each 're' ]-------------------------------------------------

    len_master = len(master)
    if len_master > 1:
        facts['master'] = master
    elif len_master == 1:
        facts['master'] = master[0]

########NEW FILE########
__FILENAME__ = session
"""
  facts['HOME'] = login home directory
"""
from lxml.builder import E

def facts_session(dev, facts):
    facts['HOME'] = dev.rpc(
        E.command("show cli directory")).findtext('./working-directory')

########NEW FILE########
__FILENAME__ = srx_cluster
"""
facts['srx_cluster'] = True | False
  if personality.startswith('SRX')
  device responds to the "show" command to extract the data

Facts Required:
  personality
"""


def facts_srx_cluster(junos, facts):
    if not facts['personality'].startswith('SRX'):
        return

    # we should check the 'cluster status' on redundancy group 0 to see who is
    # master.  we use a try/except block for cases when SRX is not clustered

    try:
        cluster_st = junos.rpc.get_chassis_cluster_status(redundancy_group="0")
        primary = cluster_st.xpath(
            './/redundancy-group-status[.="primary"]')[0]
        node = primary.xpath(
            'preceding-sibling::device-name[1]')[0].text.replace('node', 'RE')
        if not facts.get('master'):
            facts['master'] = node
        elif node not in facts['master']:
            facts['master'].append(node)
        facts['srx_cluster'] = True
    except:
        facts['srx_cluster'] = False
        pass

########NEW FILE########
__FILENAME__ = switch_style
import re

def facts_switch_style(junos, facts):
    persona = facts['personality']

    if persona in ['MX', 'SRX_HIGHEND']:
        style = 'BRIDGE_DOMAIN'
    elif persona in ['SWITCH', 'SRX_BRANCH']:
        model = facts['model']
        if re.match('firefly', model, re.IGNORECASE):
            style = 'NONE'
        elif re.match('^(EX9)|(EX43)', model):
            style = 'VLAN_L2NG'
        else:
            style = 'VLAN'
    else:
        style = 'NONE'

    facts['switch_style'] = style

########NEW FILE########
__FILENAME__ = swver
import re


class version_info(object):

    def __init__(self, verstr):
        """verstr - version string"""
        m1 = re.match('(.*?)([RBIXS-])(.*)', verstr)
        self.type = m1.group(2)

        self.major = tuple(map(int, m1.group(1).split('.')))  # creates tuyple
        after_type = m1.group(3).split('.')
        self.minor = after_type[0]

        if 'X' == self.type:
            # assumes form similar to "45-D10", so extract the bits from this
            xm = re.match("(\d+)-(\w)(.*)", self.minor)
            self.minor = tuple(
                [int(xm.group(1)), xm.group(2), int(xm.group(3))])
            if len(after_type) < 2:
                self.build = None
            else:
                self.build = int(after_type[1])
        elif ('I' == self.type) or ('-' == self.type):
            self.type = 'I'
            try:
                # assumes that we have a build/spin, but not numeric
                self.build = after_type[1]
            except:
                self.build = None
        else:
            try:
                self.build = int(after_type[1])   # assumes numeric build/spin
            except:
                self.build = after_type[0]  # non-numeric

        self.as_tuple = self.major + tuple([self.minor, self.build])

    def __repr__(self):
        retstr = "junos.version_info(major={major}, type={type}," \
                 " minor={minor}, build={build})".format(
                     major=self.major,
                     type=self.type,
                     minor=self.minor,
                     build=self.build
                 )
        return retstr

    def _cmp_tuple(self, other):
        bylen = {
            2: (self.as_tuple[0:2]),
            4: self.as_tuple
        }
        return bylen[len(other)]

    def __lt__(self, other):
        return self._cmp_tuple(other) < other

    def __le__(self, other):
        return self._cmp_tuple(other) <= other

    def __gt__(self, other):
        return self._cmp_tuple(other) > other

    def __ge__(self, other):
        return self._cmp_tuple(other) >= other

    def __eq__(self, other):
        return self._cmp_tuple(other) == other

    def __ne__(self, other):
        return self._cmp_tuple(other) != other


def _get_swver(dev, facts):
    try:
        return dev.rpc.cli(
            "show version invoke-on all-routing-engines", format='xml')
    except:
        try:
            facts['vc_capable'] = True
            return dev.rpc.cli("show version all-members", format='xml')
        except:
            facts['vc_capable'] = False
            return dev.rpc.get_software_information()


def facts_software_version(junos, facts):
    """
    The following facts are required:
        facts['master']

    The following facts are assigned:
        facts['hostname']
        facts['version']
        facts['version_<RE#>'] for each RE in dual-RE, cluster or VC system
        facts['version_info'] for master RE
    """

    x_swver = _get_swver(junos, facts)

    if not facts.get('model'):
        # try to extract the model from the version information
        facts['model'] = x_swver.findtext('.//product-model')

    # ------------------------------------------------------------------------
    # extract the version information out of the RPC response
    # ------------------------------------------------------------------------

    f_master = facts.get('master')

    if x_swver.tag == 'multi-routing-engine-results':
        # we need to find/identify each of the routing-engine (CPU) versions.

        facts['2RE'] = True
        versions = []

        if isinstance(f_master, list):
            xpath = './multi-routing-engine-item[re-name="{0}"' \
                    ']/software-information/host-name'.format(
            f_master[0].lower())
        else:
            xpath = './multi-routing-engine-item[re-name="{0}"' \
                    ']/software-information/host-name'.format(
            f_master.lower())

        facts['hostname'] = x_swver.findtext(xpath)
        if facts['hostname'] is None:
            # then there the re-name is not what we are expecting; we should
            # handle this better, eh?  For now, just assume there is one
            # software-information element and take that host-name. @@@ hack.
            facts['hostname'] = x_swver.findtext(
                './/software-information/host-name')

        for re_sw in x_swver.xpath('.//software-information'):
            re_name = re_sw.xpath('preceding-sibling::re-name')[0].text

            # handle the cases where the "RE name" could be things like
            # "FPC<n>" or "ndoe<n>", and normalize to "RE<n>".
            re_name = re.sub(r'(\w+)(\d+)', 'RE\\2', re_name)

            pkginfo = re_sw.xpath(
                'package-information[normalize-space(name)="junos"]/comment'
            )[0].text

            try:
                versions.append(
                    (re_name.upper(),
                     re.findall(
                         r'\[(.*)\]',
                         pkginfo)[0]))
            except:
                versions.append((re_name.upper(), "0.0I0.0"))

        # now add the versions to the facts <dict>
        for re_ver in versions:
            facts['version_' + re_ver[0]] = re_ver[1]

        if f_master is not None:
            master = f_master[0] if isinstance(f_master, list) else f_master
            facts['version'] = facts['version_' + master]
        else:
            facts['version'] = versions[0][1]

    else:
        # single-RE
        facts['hostname'] = x_swver.findtext('host-name')

        pkginfo = x_swver.xpath(
            './/package-information[normalize-space(name)="junos"]/comment'
        )[0].text
        facts['version'] = re.findall(r'\[(.*)\]', pkginfo)[0]

    # ------------------------------------------------------------------------
    # create a 'version_info' object based on the master version
    # ------------------------------------------------------------------------

    facts['version_info'] = version_info(facts['version'])

########NEW FILE########
__FILENAME__ = jxml
# jxml.py

"""
  These are Junos XML 'helper' definitions use for generic XML processing

  .DEL to delete an item
  .REN to rename an item, requires the use of NAME()

  .INSERT(<'before'|'after'>) to reorder an item, requires the use of NAME()
  .BEFORE to reorder an item before another, requires the use of NAME()
  .AFTER to reorder an item after another, requires the use of NAME()

  .NAME(name) to assign the name attribute

"""

DEL = {'delete': 'delete'}              # Junos XML resource delete
REN = {'rename': 'rename'}              # Junos XML resource rename
ACTIVATE = {'active': 'active'}         # activate resource
DEACTIVATE = {'inactive': 'inactive'}   # deactivate resource
REPLACE = {'replace': 'replace'}         # replace elements


def NAME(name):
    return {'name': name}


def INSERT(cmd):
    return {'insert': cmd}

BEFORE = {'insert': 'before'}
AFTER = {'insert': 'after'}

# used with <get-configuration> to load only the object identifiers and
# not all the subsequent configuration

NAMES_ONLY = {'recurse': "false"}

# for <get-configuration>, attributes to retrieve from apply-groups
INHERIT = {'inherit': 'inherit'}
INHERIT_GROUPS = {'inherit': 'inherit', 'groups': 'groups'}
INHERIT_DEFAULTS = {'inherit': 'defaults', 'groups': 'groups'}


def remove_namespaces(xml):
    for elem in xml.getiterator():
        i = elem.tag.find('}')
        if i > 0:
            elem.tag = elem.tag[i + 1:]
    return xml


def rpc_error(rpc_xml):
    """
      extract the various bits from an <rpc-error> element
      into a dictionary
    """
    remove_namespaces(rpc_xml)

    if 'rpc-reply' == rpc_xml.tag:
        rpc_xml = rpc_xml[0]

    def find_strip(x):
        ele = rpc_xml.find(x)
        return ele.text.strip() if None != ele else None

    this_err = {}
    this_err['severity'] = find_strip('error-severity')
    this_err['source'] = find_strip('source-daemon')
    this_err['edit_path'] = find_strip('error-path')
    this_err['bad_element'] = find_strip('error-info/bad-element')
    this_err['message'] = find_strip('error-message')

    return this_err

########NEW FILE########
__FILENAME__ = arp
"""
Pythonifier for ARP Table/View
"""
from jnpr.junos.factory import loadyaml
from os.path import splitext
_YAML_ = splitext(__file__)[0] + '.yml'
globals().update(loadyaml(_YAML_))

########NEW FILE########
__FILENAME__ = bfd
"""
Pythonifier for BFD Table/View
"""
from jnpr.junos.factory import loadyaml
from os.path import splitext
_YAML_ = splitext(__file__)[0] + '.yml'
globals().update(loadyaml(_YAML_))

########NEW FILE########
__FILENAME__ = ethport
"""
Pythonifier for EthPort Table/View
"""
from jnpr.junos.factory import loadyaml
from os.path import splitext
_YAML_ = splitext(__file__)[0] + '.yml'
globals().update(loadyaml(_YAML_))

########NEW FILE########
__FILENAME__ = fpc
"""
Pythonifier for Route Table/View
"""
from jnpr.junos.factory import loadyaml
from os.path import splitext
_YAML_ = splitext(__file__)[0] + '.yml'
globals().update(loadyaml(_YAML_))

########NEW FILE########
__FILENAME__ = isis
"""
Pythonifier for ISIS Table/View
"""
from jnpr.junos.factory import loadyaml
from os.path import splitext
_YAML_ = splitext(__file__)[0] + '.yml'
globals().update(loadyaml(_YAML_))

########NEW FILE########
__FILENAME__ = lacp
"""
Pythonifier for LACP Table/View
"""
from jnpr.junos.factory import loadyaml
from os.path import splitext
_YAML_ = splitext(__file__)[0] + '.yml'
globals().update(loadyaml(_YAML_))

########NEW FILE########
__FILENAME__ = ldp
"""
Pythonifier for LDP Table/View
"""
from jnpr.junos.factory import loadyaml
from os.path import splitext
_YAML_ = splitext(__file__)[0] + '.yml'
globals().update(loadyaml(_YAML_))

########NEW FILE########
__FILENAME__ = lldp
"""
Pythonifier for LLDP Table/View
"""
from jnpr.junos.factory import loadyaml
from os.path import splitext
_YAML_ = splitext(__file__)[0] + '.yml'
globals().update(loadyaml(_YAML_))

########NEW FILE########
__FILENAME__ = phyport
"""
Pythonifier for PhyPort Table/View
"""
from jnpr.junos.factory import loadyaml
from os.path import splitext
_YAML_ = splitext(__file__)[0] + '.yml'
globals().update(loadyaml(_YAML_))

########NEW FILE########
__FILENAME__ = routes
"""
Pythonifier for Route Table/View
"""
from jnpr.junos.factory import loadyaml
from os.path import splitext
_YAML_ = splitext(__file__)[0] + '.yml'
globals().update(loadyaml(_YAML_))

########NEW FILE########
__FILENAME__ = xcvr
"""
Pythonifier for Xcvr Table/View
"""
from jnpr.junos.factory import loadyaml
from os.path import splitext
_YAML_ = splitext(__file__)[0] + '.yml'
globals().update(loadyaml(_YAML_))

########NEW FILE########
__FILENAME__ = rpcmeta
import re
from lxml import etree
from lxml.builder import E


class _RpcMetaExec(object):

    # -----------------------------------------------------------------------
    # CONSTRUCTOR
    # -----------------------------------------------------------------------

    def __init__(self, junos):
        """
          ~PRIVATE CLASS~
          creates an RPC meta-executor object bound to the provided
          ez-netconf :junos: object
        """
        self._junos = junos

    # -----------------------------------------------------------------------
    # get_config
    # -----------------------------------------------------------------------

    def get_config(self, filter_xml=None, options={}):
        """
        retrieve configuration from the Junos device

        :filter_xml: is options, defines what to retrieve.  if omitted then the entire configuration is returned

        :options: is a dict, creates attributes for the RPC

        """
        rpc = E('get-configuration', options)

        if filter_xml is not None:
            # wrap the provided filter with toplevel <configuration> if
            # it does not already have one
            cfg_tag = 'configuration'
            at_here = rpc if cfg_tag == filter_xml.tag else E(cfg_tag)
            at_here.append(filter_xml)
            if at_here is not rpc: rpc.append(at_here)

        return self._junos.execute(rpc)

    # -----------------------------------------------------------------------
    # load_config
    # -----------------------------------------------------------------------

    def load_config(self, contents, **options):
        """
        loads :contents: onto the Junos device, does not commit the change.

        :options: is a dictionary of XML attributes to set within the <load-configuration> RPC.

        The :contents: are interpreted by the :options: as follows:

        format='text' and action='set', then :contents: is a string containing a series of "set" commands

        format='text', then :contents: is a string containing Junos configuration in curly-brace/text format

        <otherwise> :contents: is XML structure
        """
        rpc = E('load-configuration', options)

        if ('action' in options) and (options['action'] == 'set'):
            rpc.append(E('configuration-set', contents))
        elif ('format' in options) and (options['format'] == 'text'):
            rpc.append(E('configuration-text', contents))
        else:
            # otherwise, it's just XML Element
            etree.SubElement(rpc, 'configuration').append(contents)

        return self._junos.execute(rpc)

    # -----------------------------------------------------------------------
    # cli
    # -----------------------------------------------------------------------

    def cli(self, command, format='text'):
        rpc = E('command', command)
        if 'text' == format:
            rpc.attrib['format'] = 'text'
        return self._junos.execute(rpc)

    # -----------------------------------------------------------------------
    # method missing
    # -----------------------------------------------------------------------

    def __getattr__(self, rpc_cmd_name):
        """
          metaprograms a function to execute the :rpc_cmd_name:

          the caller will be passing (*vargs, **kvargs) on
          execution of the meta function; these are the specific
          rpc command arguments(**kvargs) and options bound
          as XML attributes (*vargs)
        """

        rpc_cmd = re.sub('_', '-', rpc_cmd_name)

        def _exec_rpc(*vargs, **kvargs):
            # create the rpc as XML command
            rpc = etree.Element(rpc_cmd)

            # kvargs are the command parameter/values
            if kvargs:
                for arg_name, arg_value in kvargs.items():
                    arg_name = re.sub('_', '-', arg_name)
                    if isinstance(arg_value, (tuple, list)):
                        for a in arg_value:
                            arg = etree.SubElement(rpc, arg_name)
                            if a is not True:
                                arg.text = a
                    else:
                        arg = etree.SubElement(rpc, arg_name)
                        if arg_value is not True:
                            arg.text = arg_value

            # vargs[0] is a dict, command options like format='text'
            if vargs:
                for k, v in vargs[0].items():
                    if v is not True:
                        rpc.attrib[k] = v

            # now invoke the command against the
            # associated :junos: device and return
            # the results per :junos:execute()

            return self._junos.execute(rpc)

        # metabind help() and the function name to the :rpc_cmd_name:
        # provided by the caller ... that's about all we can do, yo!

        _exec_rpc.__doc__ = rpc_cmd
        _exec_rpc.__name__ = rpc_cmd_name

        # return the metafunction that the caller will in-turn invoke
        return _exec_rpc

    # -----------------------------------------------------------------------
    # callable
    # -----------------------------------------------------------------------

    def __call__(self, rpc_cmd, **kvargs):
        """
          callable will execute the provided :rpc_cmd: against the
          attached :junos: object and return the RPC response per
          :junos:execute()

          kvargs is simply passed 'as-is' to :junos:execute()
        """
        return self._junos.execute(rpc_cmd, **kvargs)

########NEW FILE########
__FILENAME__ = config
# utils/config.py
import os

# 3rd-party modules
from lxml import etree

# package modules
from jnpr.junos.exception import *
from jnpr.junos import jxml as JXML
from jnpr.junos.utils.util import Util


class Config(Util):

    """
    Configuration Utilities:

      commit - commit changes
      commit_check - perform the commit check operation
      diff - return the diff string between running and candidate config
      pdiff - prints the diff string (debug/helper)
      load - load changes into the candidate config
      lock - take an exclusive lock on the candidate config
      unlock - release the exclusive lock
      rollback - perform the load rollback command

    """

    # ------------------------------------------------------------------------
    # commit
    # ------------------------------------------------------------------------

    def commit(self, **kvargs):
        """
        commit a configuration.  returns either :True: or
        raises an RPCError exception

        kvargs
          confirm = [True | <timeout-minutes>]
          comment = <comment log string>
        """
        rpc_args = {}

        # if a comment is provided, then include that in the RPC

        comment = kvargs.get('comment')
        if comment:
            rpc_args['log'] = comment

        # if confirm is provided, then setup the RPC args
        # so that Junos will either use the default confirm
        # timeout (confirm=True) or a specific timeout
        # (confirm=<minutes>)

        confirm = kvargs.get('confirm')
        if confirm:
            rpc_args['confirmed'] = True
            confirm_val = str(confirm)
            if 'True' != confirm_val:
                rpc_args['confirm-timeout'] = confirm_val

        # dbl-splat the rpc_args since we want to pass key/value to metaexec
        # if there is a commit/check error, this will raise an execption

        try:
            self.rpc.commit_configuration(**rpc_args)
        except RpcError as err:        # jnpr.junos exception
            if err.rsp.find('ok') is not None:
                # this means there are warnings, but no errors
                return True
            else:
                raise CommitError(cmd=err.cmd, rsp=err.rsp)
        except Exception as err:
            # so the ncclient gives us something I don't want.  I'm going to
            # convert it and re-raise the commit error
            JXML.remove_namespaces(err.xml)
            raise CommitError(rsp=err.xml)

        return True

    # -------------------------------------------------------------------------
    # commit check
    # -------------------------------------------------------------------------

    def commit_check(self):
        """
        perform a commit check.  if the commit check passes, this function
        will return :True:

        If there is a commit check error, then the RPC error reply XML
        structure will be returned
        """
        try:
            self.rpc.commit_configuration(check=True)
        except RpcError as err:        # jnpr.junos exception
            if err.rsp.find('ok') is not None:
                # this means there is a warning, but no errors
                return True
            else:
                raise CommitError(cmd=err.cmd, rsp=err.rsp)
        except Exception as err:
            # :err: is from ncclient, so extract the XML data
            # and convert into dictionary
            return JXML.rpc_error(err.xml)

        return True

    # -------------------------------------------------------------------------
    # show | compare rollback <number|0*>
    # -------------------------------------------------------------------------

    def diff(self, **kvargs):
        """
        retrieve a diff-format report of the candidate config against
        either the current active config, or a different rollback.

        kvargs
          'rollback' is a number [0..50]
        """

        rb_id = kvargs.get('rollback', 0)
        if rb_id < 0 or rb_id > 50:
            raise ValueError("Invalid rollback #" + str(rb_id))

        rsp = self.rpc.get_configuration(dict(
            compare='rollback', rollback=str(rb_id), format='text'
        ))

        diff_txt = rsp.find('configuration-output').text
        return None if diff_txt == "\n" else diff_txt

    def pdiff(self, **kvargs):
        print self.diff(**kvargs)

    # -------------------------------------------------------------------------
    # helper on loading configs
    # -------------------------------------------------------------------------

    def load(self, *vargs, **kvargs):
        """
        loads configuration into the device

        vargs (optional)
          is the content to load.  if the contents is a string, then you
          must specify kvargs['format'].

        kvargs['path']
            path to file of configuration.  the path extension will be used
            to determine the format of the contents.

                | ['conf','text','txt'] is curly-text-style
                | ['set'] is set-style
                | ['xml'] is XML

            the format can specific set by using kvarg['format']

        kvargs['format']
          determines the format of the contents.  options are
          ['xml','set','text'] for XML/etree, set-style, curly-brace-style

        kvargs['overwrite']
          determines if the contents completely replace the existing
          configuration.  options are [True/False], default: False

        kvargs['template_path']
          path to a jinja2 template file.  used in conjection with the
          kvargs['template_vars'] option, this will perform a templating
          render and then load the result.  The template extension will
          be used to determine the format-style of the contents, or you
          can override using kvargs['format']

        kvargs['template']
          jinja2 Template.  same description as kvargs['template_path'],
          except this option you provide the actual Template, rather than
          a path to the template file

        kvargs['template_vars']
          used in conjection with the other template options.  this option
          contains a dictionary of variables to render into the template
        """
        rpc_xattrs = {'format': 'xml'}      # junos attributes, default to XML
        rpc_contents = None

        # support the ability to completely replace the Junos configuration
        # note: this cannot be used if format='set', per Junos API.

        overwrite = kvargs.get('overwrite', False)
        if True == overwrite:
            rpc_xattrs['action'] = 'override'

        # ---------------------------------------------------------------------
        # private helpers ...
        # ---------------------------------------------------------------------

        def _lformat_byext(path):
            """ determine the format style from the file extension """
            ext = os.path.splitext(path)[1]
            if ext == '.xml':
                return 'xml'
            if ext in ['.conf', '.text', '.txt']:
                return 'text'
            if ext in ['.set']:
                return 'set'
            raise ValueError("Unknown file contents from extension: %s" % ext)

        def _lset_format(kvargs, rpc_xattrs):
            """ setup the kvargs/rpc_xattrs """
            # when format is given, setup the xml attrs appropriately
            if kvargs['format'] == 'set':
                if True == overwrite:
                    raise ValueError(
                        "conflicting args, cannot use 'set' with 'overwrite'")
                rpc_xattrs['action'] = 'set'
                kvargs['format'] = 'text'
            rpc_xattrs['format'] = kvargs['format']

        def _lset_fromfile(path):
            """ setup the kvargs/rpc_xattrs based on path """
            if 'format' not in kvargs:
                # we use the extension to determine the format
                kvargs['format'] = _lformat_byext(path)
                _lset_format(kvargs, rpc_xattrs)

        # ---------------------------------------------------------------------
        # end-of: private helpers
        # ---------------------------------------------------------------------

        if 'format' in kvargs:
            _lset_format(kvargs, rpc_xattrs)

        # ---------------------------------------------------------------------
        # if contents are provided as vargs[0], then process that as XML or str
        # ---------------------------------------------------------------------

        if len(vargs):
            # caller is providing the content directly.
            rpc_contents = vargs[0]
            if isinstance(rpc_contents, str) and not 'format' in kvargs:
                raise RuntimeError(
                    "You must define the format of the contents")
            return self.rpc.load_config(rpc_contents, **rpc_xattrs)

            #~! UNREACHABLE !~#

        # ---------------------------------------------------------------------
        # if path is provided, use the static-config file
        # ---------------------------------------------------------------------

        if 'path' in kvargs:
            # then this is a static-config file.  load that as our rpc_contents
            rpc_contents = open(kvargs['path'], 'rU').read()
            _lset_fromfile(kvargs['path'])
            if rpc_xattrs['format'] == 'xml':
                # covert the XML string into XML structure
                rpc_contents = etree.XML(rpc_contents)

            return self.rpc.load_config(rpc_contents, **rpc_xattrs)

            #~! UNREACHABLE !~#

        # ---------------------------------------------------------------------
        # if template_path is provided, then jinja2 load the template, and
        # render the results.  if template_vars are provided, use those
        # in the render process.
        # ---------------------------------------------------------------------

        if 'template_path' in kvargs:
            path = kvargs['template_path']
            template = self.dev.Template(path)
            rpc_contents = template.render(kvargs.get('template_vars', {}))
            _lset_fromfile(path)
            return self.rpc.load_config(rpc_contents, **rpc_xattrs)

            #~! UNREACHABLE !~#

        # ---------------------------------------------------------------------
        # if template is provided, then this is a pre-loaded jinja2 Template
        # object.  Use the template.filename to determine the format style
        # ---------------------------------------------------------------------

        if 'template' in kvargs:
            template = kvargs['template']
            path = template.filename
            rpc_contents = template.render(kvargs.get('template_vars', {}))
            _lset_fromfile(path)
            return self.rpc.load_config(rpc_contents, **rpc_xattrs)

            #~! UNREACHABLE !~#

        raise RuntimeError("Unhandled load request")

    # -------------------------------------------------------------------------
    # config exclusive
    # -------------------------------------------------------------------------

    def lock(self):
        """
        attempts an exclusive lock on the candidate configuration
        """
        try:
            self.rpc.lock_configuration()
        except Exception as err:
            if isinstance(err, RpcError):
                raise LockError(rsp=err.rsp)
            else:
                # :err: is from ncclient
                raise LockError(rsp=JXML.remove_namespaces(err.xml))

        return True

    # -------------------------------------------------------------------------
    # releases the exclusive lock
    # -------------------------------------------------------------------------

    def unlock(self):
        """
        unlocks the candidate configuration
        """
        try:
            self.rpc.unlock_configuration()
        except Exception as err:
            if isinstance(err, RpcError):
                raise LockError(rsp=err.rsp)
            else:
            # :err: is from ncclient
                raise UnlockError(rsp=JXML.remove_namespaces(err.xml))

        return True

    # -------------------------------------------------------------------------
    # rollback <number|0*>
    # -------------------------------------------------------------------------

    def rollback(self, rb_id=0):
        """
        rollback the candidate config to either the last active or
        a specific rollback number.
        """

        if rb_id < 0 or rb_id > 50:
            raise ValueError("Invalid rollback #" + str(rb_id))

        self.rpc.load_configuration(dict(
            compare='rollback', rollback=str(rb_id)
        ))

        return True

########NEW FILE########
__FILENAME__ = fs
from lxml.builder import E

from jnpr.junos.utils.util import Util
from jnpr.junos.utils.start_shell import StartShell


class FS(Util):

    """
    Filesystem (FS) utilities:

      cat - show the contents of a file
      checksum - calculate file checksum (md5,sha256,sha1)
      copy - local file copy (not scp)
      cwd - change working directory
      ls - return file/dir listing
      mkdir - create a directory
      pwd - get working directory
      rename - local file rename
      rm - local file delete
      rmdir - remove a directory
      stat - return file/dir information
      storage_usage - return storage usage
      storage_cleanup - perform storage storage_cleanup
      storage_cleanup_check - returns a list of files to remove at cleanup
      symlink - create a symlink
      tgz - tar+gzip a directory

    NOTES:
      The following methods require 'start shell' priveldges:
      [mkdir, rmdir, symlink]
    """

    # -------------------------------------------------------------------------
    # cat - show file contents
    # -------------------------------------------------------------------------

    def cat(self, path):
        """
        returns the contents of the file :path:
        """
        try:
            rsp = self._dev.rpc.file_show(filename=path)
        except:
            return None
        return rsp.text

    # -------------------------------------------------------------------------
    # cwd - change working directory
    # -------------------------------------------------------------------------

    def cwd(self, path):
        """
        change working directory to path
        """
        self._dev.rpc.set_cli_working_directory(directory=path)

    # -------------------------------------------------------------------------
    # pwd - return current working directory
    # -------------------------------------------------------------------------

    def pwd(self):
        """
        returns the current working directory
        """
        rsp = self._dev.rpc(E.command("show cli directory"))
        return rsp.findtext('./working-directory')

    # -------------------------------------------------------------------------
    # checksum - compute file checksum
    # -------------------------------------------------------------------------

    def checksum(self, path, calc='md5'):
        """
        performs the checksum command on the given file path using the
        required calculation method ['md5', 'sha256', 'sha1'] and returns
        the string value.  if the :path: is not found on the device, then
        None is returned.
        """
        cmd_map = {
            'md5': self._dev.rpc.get_checksum_information,
            'sha256': self._dev.rpc.get_sha256_checksum_information,
            'sha1': self._dev.rpc.get_sha1_checksum_information
        }
        rpc = cmd_map.get(calc)
        if rpc is None:
            raise ValueError("Unknown calculation method: '%s'" % calc)
        try:
            rsp = rpc(path=path)
            return rsp.findtext('.//checksum').strip()
        except:
            # the only exception is that the path is not found
            return None

    @classmethod
    def _decode_file(cls, fileinfo):
        results = {}

        not_file = fileinfo.xpath('file-directory | file-symlink-target')
        if len(not_file):
            results['type'] = {'file-directory': 'dir',
                               'file-symlink-target': 'link'}[not_file[0].tag]
            if 'link' == results['type']:
                results['link'] = not_file[0].text.strip()
        else:
            results['type'] = 'file'

        results['path'] = fileinfo.findtext('file-name').strip()
        results['owner'] = fileinfo.findtext('file-owner').strip()
        results['size'] = int(fileinfo.findtext('file-size'))
        fper = fileinfo.find('file-permissions')
        results['permissions'] = int(fper.text.strip())
        results['permissions_text'] = fper.get('format')
        fdate = fileinfo.find('file-date')
        results['ts_date'] = fdate.get('format')
        results['ts_epoc'] = fdate.text.strip()
        return results

    @classmethod
    def _decode_dir(cls, dirinfo, files=None):
        results = {}
        results['type'] = 'dir'
        results['path'] = dirinfo.get('name')
        if files is None:
            files = dirinfo.xpath('file-information')
        results['file_count'] = len(files)
        results['size'] = sum([int(f.findtext('file-size')) for f in files])
        return results

    # -------------------------------------------------------------------------
    # stat - file information
    # -------------------------------------------------------------------------

    def stat(self, path):
        """
        Returns a dictionary of status information on the path, or None
        if the path does not exist.

        @@@ MORE NEEDED @@@
        """
        rsp = self._dev.rpc.file_list(detail=True, path=path)

        # if there is an output tag, then it means that the path
        # was not found
        if rsp.find('output') is not None:
            return None

        # ok, so we've either got a directory or a file at
        # this point, so decode accordingly

        xdir = rsp.find('directory')
        if xdir.get('name'):  # then this is a directory path
            return FS._decode_dir(xdir)
        else:
            return FS._decode_file(xdir.find('file-information'))

    # -------------------------------------------------------------------------
    # ls - file/dir listing
    # -------------------------------------------------------------------------

    def ls(self, path='.', brief=False, followlink=True):
        """
        File listing, returns a dict of file information.  If the
        path is a symlink, then by default (:followlink):) will
        recursively call this method to obtain the symlink specific
        information.
        """
        rsp = self._dev.rpc.file_list(detail=True, path=path)

        # if there is an output tag, then it means that the path
        # was not found, and we return :None:

        if rsp.find('output') is not None:
            return None

        xdir = rsp.find('directory')

        # check to see if the directory element has a :name:
        # attribute, and if it does not, then this is a file, and
        # decode accordingly.  If the file is a symlink, then we
        # want to follow the symlink to get what we want.

        if not xdir.get('name'):
            results = FS._decode_file(xdir.find('file-information'))
            link_path = results.get('link')
            if not link_path:  # then we are done
                return results
            else:
                return results if followlink is False else self.ls(
                    path=link_path)

        # if we are here, then it's a directory, include information on all
        # files
        files = xdir.xpath('file-information')
        results = FS._decode_dir(xdir, files)

        if brief is True:
            results['files'] = [f.findtext('file-name').strip() for f in files]
        else:
            results['files'] = dict((f.findtext('file-name').strip(), FS._decode_file(f)) for f in files)

        return results

    # -------------------------------------------------------------------------
    # storage_usage - filesystem storage usage
    # -------------------------------------------------------------------------

    def storage_usage(self):
        rsp = self._dev.rpc.get_system_storage()

        _name = lambda fs: fs.findtext('filesystem-name').strip()

        def _decode(fs):
            r = {}
            r['mount'] = fs.find('mounted-on').text.strip()
            tb = fs.find('total-blocks')
            r['total'] = tb.get('format')
            r['total_blocks'] = int(tb.text)
            ub = fs.find('used-blocks')
            r['used'] = ub.get('format')
            r['used_blocks'] = int(ub.text)
            r['used_pct'] = fs.find('used-percent').text.strip()
            ab = fs.find('available-blocks')
            r['avail'] = ab.get('format')
            r['avail_block'] = int(ab.text)
            return r

        return dict((_name(fs), _decode(fs)) for fs in rsp.xpath('filesystem'))

    # -------------------------------------------------------------------------
    ### storage_cleanup_check, storage_cleanip
    # -------------------------------------------------------------------------

    @classmethod
    def _decode_storage_cleanup(cls, files):
        _name = lambda f: f.findtext('file-name').strip()

        def _decode(f):
            return {
                'size': int(f.findtext('size')),
                'ts_date': f.findtext('date').strip()
            }

        # return a dict of name/decode pairs for each file
        return dict((_name(f), _decode(f)) for f in files)

    def storage_cleanup_check(self):
        """
        Perform the 'request system storage cleanup dry-run' command
        to return a :dict: of files/info that would be removed if
        the cleanup command was executed.
        """
        rsp = self._dev.rpc.request_system_storage_cleanup(dry_run=True)
        files = rsp.xpath('file-list/file')
        return FS._decode_storage_cleanup(files)

    def storage_cleanup(self):
        """
        Perform the 'request system storage cleanup' command to remove
        files from the filesystem.  Return a :dict: of file name/info
        on the files that were removed.
        """
        rsp = self._dev.rpc.request_system_storage_cleanup()
        files = rsp.xpath('file-list/file')
        return FS._decode_storage_cleanup(files)

    # -------------------------------------------------------------------------
    # rm - local file delete
    # -------------------------------------------------------------------------

    def rm(self, path):
        """
        Performs a local file delete action, per Junos CLI command
        "file delete". If the file does not exist, then this returns False.
        """
        # the return value from this RPC will return either True if the delete
        # was successful, or an XML structure otherwise.  So we can do a simple
        # test to provide the return result to the caller.
        rsp = self._dev.rpc.file_delete(path=path)
        if rsp is True:
            return True
        else:
            return False

    # -------------------------------------------------------------------------
    # cp - local file copy
    # -------------------------------------------------------------------------

    def cp(self, from_path, to_path):
        """
        Perform a local file copy where :from_path: and :to_path: can be any
        valid Junos path argument.  Refer to the Junos "file copy" command
        documentation for details.

        Returns True if OK, False if file does not exist.
        """
        # this RPC returns True if it is OK.  If the file does not exist
        # this RPC will generate an RpcError exception, so just return False
        try:
            self._dev.rpc.file_copy(source=from_path, destination=to_path)
        except:
            return False
        return True

    # -------------------------------------------------------------------------
    # mv - local file rename
    # -------------------------------------------------------------------------

    def mv(self, from_path, to_path):
        """
        Perform a local file rename function, same as "file rename" Junos CLI.
        """
        rsp = self._dev.rpc.file_rename(source=from_path, destination=to_path)
        if rsp is True:
            return True
        else:
            return False

    def tgz(self, from_path, tgz_path):
        """
        create a file called :tgz_path: that is the tar-gzip of the given
        directory specified :from_path:
        """
        rsp = self._dev.rpc.file_archive(compress=True,
                                         source=from_path,
                                         destination=tgz_path)

        # if the rsp is True, then the command executed OK.
        if rsp is True:
            return True

        # otherwise, return the error string to the caller
        return rsp.text

    # -------------------------------------------------------------------------
    # !!!!! methods that use SSH shell commands, requires that the user
    # !!!!! has 'start shell' priveldges
    # -------------------------------------------------------------------------

    def _ssh_exec(self, command):
        with StartShell(self._dev) as sh:
            got = sh.run(command)
            ok = sh.last_ok
        return (ok, got)

    def rmdir(self, path):
        """
        *REQUIRES SHELL PRIVILEGES*

        executes the 'rmdir' command on path
        returns True if OK, or error string
        """
        results = self._ssh_exec("rmdir %s" % path)
        return True if results[0] is True else ''.join(results[1][2:-1])

    def mkdir(self, path):
        """
        *REQUIRES SHELL PRIVILEGES*

        executes the 'mkdir -p' command on path
        returns True if OK, or error string
        """
        results = self._ssh_exec("mkdir -p %s" % path)
        return True if results[0] is True else ''.join(results[1][2:-1])

    def symlink(self, from_path, to_path):
        """
        *REQUIRES SHELL PRIVILEGES*

        executes the 'ln -sf <from_path> <to_path>' command
        returns True if OK, or error string
        """
        results = self._ssh_exec("ln -sf %s %s" % (from_path, to_path))
        return True if results[0] is True else ''.join(results[1][2:-1])

########NEW FILE########
__FILENAME__ = scp
from __future__ import absolute_import

import paramiko
from scp import SCPClient


class SCP(object):

    def __init__(self, junos, **scpargs):
        """
        constructor that wraps a paramiko 'scp' object.
        """
        self._junos = junos
        self._scpargs = scpargs

    def open(self, **scpargs):
        """
        creates an instance of the scp object and return to caller for use
        """
        #@@@ should check for multi-calls to connect to ensure we don't keep
        #@@@ opening new connections
        junos = self._junos
        self._ssh = paramiko.SSHClient()
        self._ssh.load_system_host_keys()
        self._ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())

        # use junos._hostname since this will be correct if we are going
        # through a jumphost.

        self._ssh.connect(hostname=junos._hostname,
                          port=(
                              22, int(
                                  junos._port))[
                              junos._hostname == 'localhost'],
                          username=junos._auth_user,
                          password=junos._auth_password,
                          )
        return SCPClient(self._ssh.get_transport(), **scpargs)

    def close(self):
        """
        closes the ssh/scp connection to the device
        """
        self._ssh.close()

    # -------------------------------------------------------------------------
    # CONTEXT MANAGER
    # -------------------------------------------------------------------------

    def __enter__(self):
        return self.open(**self._scpargs)

    def __exit__(self, exc_ty, exc_val, exc_tb):
        self.close()

########NEW FILE########
__FILENAME__ = start_shell
import paramiko
from select import select

_JUNOS_PROMPT = '> '
_SHELL_PROMPT = '% '
_SELECT_WAIT = 0.1
_RECVSZ = 1024


class StartShell(object):

    def __init__(self, nc):
        self._nc = nc

    def wait_for(self, this=_SHELL_PROMPT):
        """
        wait for the result of the command, expecting :this:
        @@@ need to add a timeout safeguard
        """
        chan = self._chan
        got = []
        while True:
            rd, wr, err = select([chan], [], [], _SELECT_WAIT)
            if rd:
                data = chan.recv(_RECVSZ)
                got.append(data)
                if data.endswith(this):
                    break
        return got

    def send(self, data):
        """
        send the command :data: followed by a \'\\\\n\' character
        """
        self._chan.send(data)
        self._chan.send('\n')

    def open(self):
        """
        open an ssh-client connection and issue the 'start shell' command to
        drop into the Junos shell (csh).
        """
        junos = self._nc

        client = paramiko.SSHClient()
        client.load_system_host_keys()
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        client.connect(hostname=junos.hostname,
                       port=(22, junos._port)[junos.hostname == 'localhost'],
                       username=junos._auth_user,
                       password=junos._auth_password,
                       )

        chan = client.invoke_shell()
        self._client = client
        self._chan = chan

        self.wait_for(_JUNOS_PROMPT)
        self.send('start shell')
        self.wait_for(_SHELL_PROMPT)

    def close(self):
        self._chan.close()
        self._client.close()

    def run(self, command, this=_SHELL_PROMPT):
        """
        run a shell command and wait for the response.  The return is a
        tuple. The first item is True/False if exit-code is 0.  The second
        item is the output of the command.
        """
        # run the command and capture the output
        self.send(command)
        got = self.wait_for(this)

        # use $? to get the exit code of the command
        self.send('echo $?')
        rc = ''.join(self.wait_for(this))
        self.last_ok = True if rc.find('0') > 0 else False

        return got

    # -------------------------------------------------------------------------
    # CONTEXT MANAGER
    # -------------------------------------------------------------------------

    def __enter__(self):
        self.open()
        return self

    def __exit__(self, exc_ty, exc_val, exc_tb):
        self.close()

########NEW FILE########
__FILENAME__ = sw
# stdlib
import hashlib
import re
from os import path
import logging

# 3rd-party modules
from lxml.builder import E

# local modules
from jnpr.junos.utils.util import Util
from jnpr.junos.utils.scp import SCP

__all__ = ['SW']


def _hashfile(afile, hasher, blocksize=65536):
    buf = afile.read(blocksize)
    while len(buf) > 0:
        hasher.update(buf)
        buf = afile.read(blocksize)
    return hasher.hexdigest()


class SW(Util):

    """
    Software Utility class, used to perform a software upgrade and
    associated functions.

    Primary methods:
      install - perform the entire software installation process
      reboot - reboots the system for the new image to take effect
      poweroff - shutdown the system

    Helpers called from install, but you can use these individually if needed:
      put - SCP put package file onto Junos device
      pkgadd - performs the 'request' operation to install the package
      validate - performs the 'request' to validate the package

    Other utils:
      rollback - same as 'request softare rollback'
      inventory - (property) provides file info for current and rollback
      images on the device
    """

    def __init__(self, dev):
        Util.__init__(self, dev)
        self._RE_list = [
            x for x in dev.facts.keys() if x.startswith('version_RE')]
        self._multi_RE = bool(len(self._RE_list) > 1)
        self._multi_VC = bool(
            self._multi_RE is True and dev.facts.get('vc_capable') is True)

    # -----------------------------------------------------------------------
    # CLASS METHODS
    # -----------------------------------------------------------------------

    @classmethod
    def local_sha256(cls, package):
        """
        computes the SHA-256 value on the package file.

        :package:
          complete path to the package (\*.tgz) file on the local server
        """
        return _hashfile(open(package, 'rb'), hashlib.sha256())

    @classmethod
    def local_md5(cls, package):
        """
        computes the MD5 checksum value on the local package file.

        :package:
          complete path to the package (\*.tgz) file on the local server
        """
        return _hashfile(open(package, 'rb'), hashlib.md5())

    @classmethod
    def local_sha1(cls, package):
        """
        computes the SHA1 checksum value on the local package file.

        :package:
          complete path to the package (\*.tgz) file on the local server
        """
        return _hashfile(open(package, 'rb'), hashlib.sha1())

    @classmethod
    def progress(cls, dev, report):
        """ simple progress report function """
        print dev.hostname + ": " + report

    # -------------------------------------------------------------------------
    # put - SCP put the image onto the device
    # -------------------------------------------------------------------------

    def put(self, package, remote_path='/var/tmp', progress=None):
        """
        SCP 'put' the package file from the local server to the remote device.

        :package:
          file path to the package file on the local file system

        :remote_path:
          the directory on the device where the package will be copied to

        :progress:
          callback function to indicate progress.  You can use :SW.progress:
          for basic reporting.  See that class method for details.
        """
        def _progress(report):
        # report progress only if a progress callback was provided
            if progress is not None:
                progress(self._dev, report)

        def _scp_progress(_path, _total, _xfrd):
            # init static variable
            if not hasattr(_scp_progress, 'by10pct'):
                _scp_progress.by10pct = 0

            # calculate current percentage xferd
            pct = int(float(_xfrd) / float(_total) * 100)

            # if 10% more has been copied, then print a message
            if 0 == (pct % 10) and pct != _scp_progress.by10pct:
                _scp_progress.by10pct = pct
                _progress(
                    "%s: %s / %s (%s%%)" %
                    (_path, _xfrd, _total, str(pct)))

        # check for the logger barncale for 'paramiko.transport'
        plog = logging.getLogger('paramiko.transport')
        if not plog.handlers: 
            class NullHandler(logging.Handler):
                def emit(self, record): pass
            plog.addHandler(NullHandler())

        # execute the secure-copy with the Python SCP module
        with SCP(self._dev, progress=_scp_progress) as scp:            
            scp.put(package, remote_path)

    # -------------------------------------------------------------------------
    # pkgadd - used to perform the 'request system software add ...'
    # -------------------------------------------------------------------------

    def pkgadd(self, remote_package, **kvargs):
        """
        Issue the 'request system software add' command on the package.  No
        validate is auto-set.  If you want to validate the image, do that
        using the specific :validate(): method.  Also, if you want to
        reboot the device, suggest using the :reboot(): method rather
        than kvargs['reboot']=True.

        :remote_package:
          the file-path to the install package

        :kvargs:
          any additional parameters to the 'request' command can
          be passed within kvargs, following the RPC syntax
          methodology (dash-2-underscore,etc.)
        """

        args = dict(no_validate=True, package_name=remote_package)
        args.update(kvargs)

        dev_to = self.dev.timeout     # store device/rpc timeout
        # hardset to 1 hr for long running process
        self.dev.timeout = 60 * 60
        rsp = self.rpc.request_package_add(**args)
        self.dev.timeout = dev_to     # restore original timeout

        got = rsp.getparent()
        rc = int(got.findtext('package-result').strip())
        return True if rc == 0 else got.findtext('output').strip()

    # -------------------------------------------------------------------------
    # validate - perform 'request' operation to validate the package
    # -------------------------------------------------------------------------

    def validate(self, remote_package):
        """ Issues the 'request' operation to validate the package against the
            config
        """
        rsp = self.rpc.request_package_validate(
            package_name=remote_package).getparent()
        errcode = int(rsp.findtext('package-result'))
        return True if 0 == errcode else rsp.findtext('output').strip()

    def remote_checksum(self, remote_package):
        """ computes the MD5 checksum on the remote device """
        rsp = self.rpc.get_checksum_information(path=remote_package)
        return rsp.findtext('.//checksum').strip()

    # -------------------------------------------------------------------------
    # safe_copy - copies the package and performs checksum
    # -------------------------------------------------------------------------

    def safe_copy(self, package, **kvargs):
        """
        Copy the install package safely to the remote device.  By default
        this means to clean the filesystem to make space, perform the
        secure-copy, and then verify the MD5 checksum.

        For :kvargs: values, please refer to the :install(): method.
        """
        remote_path = kvargs.get('remote_path', '/var/tmp')
        progress = kvargs.get('progress')
        checksum = kvargs.get('checksum')
        cleanfs = kvargs.get('cleanfs', True)

        def _progress(report):
            if progress is not None:
                progress(self._dev, report)

        if checksum is None:
            _progress('computing local checksum on: %s' % package)
            checksum = SW.local_md5(package)

        if cleanfs is True:
            dto = self.dev.timeout
            self.dev.timeout = 5 * 60
            _progress('cleaning filesystem ...')
            self.rpc.request_system_storage_cleanup()
            self.dev.timeout = dto

        # we want to give the caller an override so we don't always
        # need to copy the file, but the default is to do this, yo!
        self.put(package, remote_path, progress)

        # validate checksum:
        remote_package = remote_path + '/' + path.basename(package)
        _progress('computing remote checksum on: %s' % remote_package)
        remote_checksum = self.remote_checksum(remote_package)

        if remote_checksum != checksum:
            _progress("checksum check failed.")
            return False
        _progress("checksum check passed.")

        return True

    # -------------------------------------------------------------------------
    # install - complete installation process, but not reboot
    # -------------------------------------------------------------------------

    def install(self, package, remote_path='/var/tmp', progress=None,
                validate=False, checksum=None, cleanfs=True, no_copy=False,
                timeout=1800):
        """
        Performs the complete installation of the :package: that includes the
        following steps:
        When no_copy is False (default-case)

        1. computes the local MD5 checksum if not provided in :checksum:
        2. performs a storage cleanup if :cleanfs: is True
        3. SCP copies the package to the :remote_path: directory
        4. computes remote MD5 checksum and matches it to the local value
        5. validates the package if :validate: is True
        6. installs the package

        You can get a progress report on this process by providing a :progress:
        callback;
        see description below.

        You will need to invoke the :reboot(): method explicitly to reboot
        the device.

        :package:
          is the install package tarball on the local filesystem.

        :remote_path:
          is the directory on the Junos device where the package file will be
          SCP'd to.

        :validate:
          determines whether or not to perform a config validation against the
          new image

        :checksum:
          MD5 hexdigest of the package file. If this is not provided, then this
          method will perform the calculation. If you are planning on using the
          same image for multiple updates, you should consider using the
          :local_md5(): method to pre calculate this value and then provide to
          this method.

        :cleanfs:
          Determines whether or not to perform a 'storeage cleanup' before
          SCP'ing the file to the device.

        :progress:
          If provided, this is a callback function with a function prototype
          given the Device instance and the report string, e.g.

            def myprogress(dev, report):
              print "host: %s, report: %s" % (dev.hostname, report)

        :timeout:
          The amount of time (seconds) before declaring an RPC timeout.  This
          argument was added since most of the time the "package add" RPC
          takes a significant amount of time.  The default RPC timeout is 
          generally around 30 seconds.  So this :timeout: value will be
          used in the context of the SW installation process.  Defaults to
          30 minutes (30*60=1800)
        """
        def _progress(report):
            if progress is not None:
                progress(self._dev, report)

        rpc = self.rpc
        dev = self.dev

        # ---------------------------------------------------------------------
        # perform a 'safe-copy' of the image to the remote device
        # ---------------------------------------------------------------------

        if no_copy is False:
            copy_ok = self.safe_copy(package, remote_path=remote_path,
                                     progress=progress, cleanfs=cleanfs,
                                     checksum=checksum)
            if copy_ok is False:
                return False

        # ---------------------------------------------------------------------
        # at this point, the file exists on the remote device
        # ---------------------------------------------------------------------

        remote_package = remote_path + '/' + path.basename(package)

        restore_timeout = dev.timeout      # for restoration later
        dev.timeout = timeout              # set for long timeout

        if validate is True:
            _progress(
                "validating software against current config,"
                " please be patient ...")
            v_ok = self.validate(remote_package)
            if v_ok is not True:
                dev.timeout = restore_timeout
                return v_ok  # will be the string of output

        if self._multi_RE is False:
            # simple case of device with only one RE
            _progress("installing software ... please be patient ...")
            add_ok = self.pkgadd(remote_package)
            dev.timeout = restore_timeout
            return add_ok
        else:
            # we need to update multiple devices
            if self._multi_VC is True:
                ok = True
                # extract the VC number out of the 'version_RE<n>' string
                vc_members = [
                    re.search(
                        '(\d+)',
                        x).group(1) for x in self._RE_list]
                for vc_id in vc_members:
                    _progress(
                        "installing software on VC member: {0} ... please be"
                        " patient ...".format(vc_id))
                    ok &= self.pkgadd(remote_package, member=vc_id)
                dev.timeout = restore_timeout
                return ok
            else:
                # then this is a device with two RE that supports the "re0"
                # and "re1" options to the command (M, MX tested only)
                ok = True
                _progress(
                    "installing software on RE0 ... please be patient ...")
                ok &= self.pkgadd(remote_package, re0=True)
                _progress(
                    "installing software on RE1 ... please be patient ...")
                ok &= self.pkgadd(remote_package, re1=True)
                dev.timeout = restore_timeout
                return ok

    # -------------------------------------------------------------------------
    # rebbot - system reboot
    # -------------------------------------------------------------------------

    def reboot(self, in_min=0):
        """
        Perform a system reboot, with optional delay (in minutes).

        If the device is equipped with dual-RE, then both RE will be
        rebooted.  This code also hanldes EX/QFX VC.
        """
        cmd = E('request-reboot', E('in', str(in_min)))

        if self._multi_RE is True and self._multi_VC is False:
            cmd.append(E('both-routing-engines'))
        try:
            rsp = self.rpc(cmd)
            got = rsp.getparent().findtext('.//request-reboot-status').strip()
            return got
        except Exception as err:
            if err.rsp.findtext('.//error-severity') != 'warning':
                raise err

    # -------------------------------------------------------------------------
    # poweroff - system shutdown
    # -------------------------------------------------------------------------

    def poweroff(self, in_min=0):
        """
        Perform a system shutdown, with optional delay (in minutes) .

        If the device is equipped with dual-RE, then both RE will be
        rebooted.  This code also hanldes EX/QFX VC.
        """
        cmd = E('request-power-off', E('in', str(in_min)))

        if self._multi_RE is True and self._multi_VC is False:
            cmd.append(E('both-routing-engines'))
        try:
            rsp = self.rpc(cmd)
            return rsp.getparent().findtext('.//request-reboot-status').strip()
        except Exception as err:
            if err.rsp.findtext('.//error-severity') != 'warning':
                raise err

    # -------------------------------------------------------------------------
    # rollback - clears the install request
    # -------------------------------------------------------------------------

    def rollback(self):
        """
        issues the 'request' command to do the rollback and returns the string
        output of the results
        """
        rsp = self.rpc.request_package_rollback()
        return rsp.text.strip()

    # -------------------------------------------------------------------------
    # inventory - file info on current and rollback packages
    # -------------------------------------------------------------------------

    @property
    def inventory(self):
        """
        Returns dictionary of file listing information for current and rollback
        Junos install packages. This information comes from the /packages
        directory.
        """
        from jnpr.junos.utils.fs import FS
        fs = FS(self.dev)
        pkgs = fs.ls('/packages')
        return dict(current=pkgs['files'].get(
            'junos'), rollback=pkgs['files'].get('junos.old'))

########NEW FILE########
__FILENAME__ = util
class Util(object):

    """ Base class for all utility classes """

    def __init__(self, dev):
        self._dev = dev

    def __repr__(self):
        return "jnpr.junos.utils.%s(%s)" % (
            self.__class__.__name__, self._dev.hostname)

    # -------------------------------------------------------------------------
    # property: dev
    # -------------------------------------------------------------------------

    @property
    def dev(self):
        """ return the Device device object """
        return self._dev

    @dev.setter
    def dev(self, value):
        raise RuntimeError("read-only: dev")

    # -------------------------------------------------------------------------
    # property: rpc
    # -------------------------------------------------------------------------

    @property
    def rpc(self):
        """ return the Device RPC meta object """
        return self._dev.rpc

    @rpc.setter
    def rpc(self, value):
        raise RuntimeError("read-only: rpc")

########NEW FILE########
__FILENAME__ = version
#import time
#__date__ = time.strftime("%Y-%b-%d")

VERSION = "0.2.0"
DATE = "2014-May-15"


########NEW FILE########
__FILENAME__ = test_core
'''

@author: rsherman
'''
import unittest
from nose.plugins.attrib import attr


@attr('functional')
class TestCore(unittest.TestCase):

    @classmethod
    def setUpClass(self):
        from jnpr.junos import Device
        self.dev = Device(host='pabst.englab.juniper.net',
                          user='jenkins', password='password123')
        self.dev.open()

    @classmethod
    def tearDownClass(self):
        self.dev.close()

    def test_device_open(self):
        self.assertEqual(self.dev.connected, True)

    def test_device_facts(self):
        assert self.dev.facts['hostname'] == 'pabst'

    def test_device_get_timeout(self):
        assert self.dev.timeout == 30

    def test_device_set_timeout(self):
        self.dev.timeout = 35
        assert self.dev.timeout == 35

    def test_device_cli(self):
        self.assertTrue('srx210' in self.dev.cli('show version'))

    def test_device_rpc(self):
        sw = self.dev.rpc.get_software_information()
        hostname = sw.findtext('.//host-name')
        self.assertEqual(hostname, 'pabst')


if __name__ == "__main__":
    #import sys;sys.argv = ['', 'TestCore.testName']
    unittest.main()

########NEW FILE########
__FILENAME__ = test_chassis
__author__ = "Nitin Kumar, Rick Sherman"
__credits__ = "Jeremy Schulman"

import unittest
from nose.plugins.attrib import attr
from mock import patch, MagicMock
from lxml import etree
import os

from jnpr.junos import Device
from jnpr.junos.facts.chassis import facts_chassis as chassis
from jnpr.junos.exception import ConnectNotMasterError

from ncclient.manager import Manager, make_device_handler
from ncclient.transport import SSHSession


@attr('unit')
class TestChassis(unittest.TestCase):

    @patch('ncclient.manager.connect')
    def setUp(self, mock_connect):
        mock_connect.side_effect = self._mock_manager
        self.dev = Device(host='1.1.1.1', user='rick', password='password123',
                          gather_facts=False)
        self.dev.open()
        self.facts = {}

    @patch('jnpr.junos.Device.execute')
    def test_2RE_true(self, mock_execute):
        mock_execute.side_effect = self._mock_manager
        chassis(self.dev, self.facts)
        self.assertTrue(self.facts['2RE'])

    def test_chassis_exception_ConnectNotMasterError(self):
        xmldata = etree.XML('<rpc-reply><output>test</output></rpc-reply>')
        self.dev.rpc.get_chassis_inventory = MagicMock(side_effect=xmldata)
        self.assertRaises(ConnectNotMasterError, chassis, self.dev, self.facts)

    def _read_file(self, fname):
        from ncclient.xml_ import NCElement

        fpath = os.path.join(os.path.dirname(__file__),
                             'rpc-reply', fname)
        foo = open(fpath).read()

        rpc_reply = NCElement(foo,
                              self.dev._conn._device_handler
                              .transform_reply())._NCElement__doc[0]
        return rpc_reply

    def _mock_manager(self, *args, **kwargs):
        if kwargs:
            device_params = kwargs['device_params']
            device_handler = make_device_handler(device_params)
            session = SSHSession(device_handler)
            return Manager(session, device_handler)

        if args:
            return self._read_file('chassis_' + args[0].tag + '.xml')

########NEW FILE########
__FILENAME__ = test_domain
__author__ = "Nitin Kumar, Rick Sherman"
__credits__ = "Jeremy Schulman"

import unittest
from nose.plugins.attrib import attr
from mock import patch

from jnpr.junos.facts.domain import facts_domain
from jnpr.junos import Device


@attr('unit')
class TestDomain(unittest.TestCase):

    def setUp(self):
        self.dev = Device(host='1.1.1.1', user='rick', password='password123',
                          gather_facts=False)
        self.facts = {}

    @patch('jnpr.junos.facts.domain.FS.cat')
    def test_resolv_conf(self, mock_fs_cat):
        mock_fs_cat.return_value =\
            """# domain juniper.net
        search englab.juniper.net spglab.juniper.net juniper.net jnpr.net
        nameserver 10.11.12.13
        """
        self.facts['hostname'] = 'test'
        facts_domain(self.dev, self.facts)
        self.assertEqual(self.facts['domain'], 'juniper.net')
        self.assertEqual(self.facts['fqdn'], 'test.juniper.net')

    @patch('jnpr.junos.facts.domain.FS.cat')
    def test_resolv_conf_no_domain(self, mock_fs_cat):
        mock_fs_cat.return_value =\
            """
        search englab.juniper.net spglab.juniper.net juniper.net jnpr.net
        nameserver 10.11.12.13
        """
        self.facts['hostname'] = 'test'
        facts_domain(self.dev, self.facts)
        self.assertEqual(self.facts['domain'], None)
        self.assertEqual(self.facts['fqdn'], 'test')

########NEW FILE########
__FILENAME__ = test_ifd_style
__author__ = "Nitin Kumar, Rick Sherman"
__credits__ = "Jeremy Schulman"

import unittest
from nose.plugins.attrib import attr

from jnpr.junos import Device
from jnpr.junos.facts.ifd_style import facts_ifd_style as ifd_style


@attr('unit')
class TestIFDStyle(unittest.TestCase):

    def setUp(self):
        self.facts = {}
        self.dev = Device(host='1.1.1.1', user='rick', password='password123',
                          gather_facts=False)

    def test_ifd_style_if_condition(self):
        self.facts['personality'] = 'SWITCH'
        ifd_style(self.dev, self.facts)
        self.assertEqual(self.facts['ifd_style'], 'SWITCH')

    def test_ifd_style_else_condition(self):
        self.facts['personality'] = 'TEXT'
        ifd_style(self.dev, self.facts)
        self.assertEqual(self.facts['ifd_style'], 'CLASSIC')

########NEW FILE########
__FILENAME__ = test_personality
__author__ = "Nitin Kumar, Rick Sherman"
__credits__ = "Jeremy Schulman"

import unittest
from nose.plugins.attrib import attr

from jnpr.junos import Device
from jnpr.junos.facts.personality import facts_personality as personality


@attr('unit')
class TestPersonality(unittest.TestCase):

    def setUp(self):
        self.facts = {}
        self.dev = Device(host='1.1.1.1', user='rick', password='password123',
                          gather_facts=False)

    def test_virtual_hassis(self):
        self.facts['model'] = 'Virtual Chassis'
        self.facts['RE0'] = {'model': 'QFX5100'}
        personality(self.dev, self.facts)
        self.assertEqual(self.facts['personality'], 'SWITCH')

    def test_m_ex_qfx_series(self):
        self.facts['model'] = 'QFX5100'
        personality(self.dev, self.facts)
        self.assertEqual(self.facts['personality'], 'SWITCH')

    def test_mx_series(self):
        self.facts['model'] = 'MX80'
        personality(self.dev, self.facts)
        self.assertEqual(self.facts['personality'], 'MX')

    def test_vmx_series(self):
        self.facts['model'] = 'vMX80'
        personality(self.dev, self.facts)
        self.assertEqual(self.facts['personality'], 'MX')
        self.assertTrue(self.facts['virtual'])

    def test_vjx_series(self):
        self.facts['model'] = 'VJX480'
        personality(self.dev, self.facts)
        self.assertEqual(self.facts['personality'], 'SRX_BRANCH')
        self.assertTrue(self.facts['virtual'])

    def test_m_series(self):
        self.facts['model'] = 'M7i'
        personality(self.dev, self.facts)
        self.assertEqual(self.facts['personality'], 'M')

    def test_t_series(self):
        self.facts['model'] = 'T320'
        personality(self.dev, self.facts)
        self.assertEqual(self.facts['personality'], 'T')

    def test_ptx_series(self):
        self.facts['model'] = 'PTX5000'
        personality(self.dev, self.facts)
        self.assertEqual(self.facts['personality'], 'PTX')

    def test_srx_series(self):
        self.facts['model'] = 'SRX210'
        personality(self.dev, self.facts)
        self.assertEqual(self.facts['personality'], 'SRX_BRANCH')

    def test_srx_high_series(self):
        self.facts['model'] = 'SRX5600'
        personality(self.dev, self.facts)
        self.assertEqual(self.facts['personality'], 'SRX_HIGHEND')

    def test_invalid_series(self):
        self.facts['model'] = 'invalid'
        personality(self.dev, self.facts)
        self.assertEqual(self.facts['personality'],'UNKNOWN')

########NEW FILE########
__FILENAME__ = test_routing_engines
__author__ = "Nitin Kumar, Rick Sherman"
__credits__ = "Jeremy Schulman"

import unittest
from nose.plugins.attrib import attr
from mock import patch
import os

from jnpr.junos import Device
from jnpr.junos.facts.routing_engines import facts_routing_engines as routing_engines

from ncclient.manager import Manager, make_device_handler
from ncclient.transport import SSHSession


@attr('unit')
class TestRoutingEngines(unittest.TestCase):

    @patch('ncclient.manager.connect')
    def setUp(self, mock_connect):
        mock_connect.side_effect = self._mock_manager
        self.dev = Device(host='1.1.1.1', user='rick', password='password123',
                          gather_facts=False)
        self.dev.open()
        self.facts = {}
        self.mode = ''

    @patch('jnpr.junos.Device.execute')
    def test_multi_instance(self, mock_execute):
        mock_execute.side_effect = self._mock_manager
        self.mode = 'multi'
        routing_engines(self.dev, self.facts)
        self.assertTrue(self.facts['2RE'])

    @patch('jnpr.junos.Device.execute')
    def test_master(self, mock_execute):
        mock_execute.side_effect = self._mock_manager
        self.mode = 'master'
        routing_engines(self.dev, self.facts)
        self.assertEqual(self.facts['RE0']['mastership_state'], 'master')

    def _read_file(self, fname):
        from ncclient.xml_ import NCElement

        fpath = os.path.join(os.path.dirname(__file__),
                             'rpc-reply', fname)
        foo = open(fpath).read()

        rpc_reply = NCElement(foo, self.dev._conn.
                              _device_handler.transform_reply()).\
            _NCElement__doc[0]
        return rpc_reply

    def _mock_manager(self, *args, **kwargs):
        if kwargs:
            device_params = kwargs['device_params']
            device_handler = make_device_handler(device_params)
            session = SSHSession(device_handler)
            return Manager(session, device_handler)

        if args:
            return self._read_file(args[0].tag + '_' + self.mode + '.xml')

########NEW FILE########
__FILENAME__ = test_srx_cluster
__author__ = "Nitin Kumar, Rick Sherman"
__credits__ = "Jeremy Schulman"

import unittest
from nose.plugins.attrib import attr
from mock import patch
import os

from jnpr.junos import Device
from jnpr.junos.facts.srx_cluster import facts_srx_cluster as srx_cluster

from ncclient.manager import Manager, make_device_handler
from ncclient.transport import SSHSession


@attr('unit')
class TestSrxCluster(unittest.TestCase):

    @patch('ncclient.manager.connect')
    def setUp(self, mock_connect):
        mock_connect.side_effect = self._mock_manager
        self.dev = Device(host='1.1.1.1', user='rick', password='password123',
                          gather_facts=False)
        self.dev.open()
        self.facts = {}

    @patch('jnpr.junos.Device.execute')
    def test_srx_cluster(self, mock_execute):
        mock_execute.side_effect = self._mock_manager
        self.facts['personality'] = 'SRX'
        self.facts['master'] = ['RE0']
        srx_cluster(self.dev, self.facts)
        self.assertTrue(self.facts['srx_cluster'])

    def test_srx_cluster_none(self):
        self.facts['personality'] = 'MX'
        self.assertEqual(srx_cluster(self.dev, self.facts), None)

    @patch('jnpr.junos.Device.execute')
    def test_srx_cluster_no_node(self, mock_execute):
        mock_execute.side_effect = self._mock_manager
        self.facts['personality'] = 'SRX'
        srx_cluster(self.dev, self.facts)
        self.assertTrue(self.facts['srx_cluster'])

    @patch('jnpr.junos.Device.execute')
    def test_srx_cluster_node(self, mock_execute):
        mock_execute.side_effect = self._mock_manager
        self.facts['personality'] = 'SRX'
        self.facts['master'] = ['RE1']
        srx_cluster(self.dev, self.facts)
        self.assertTrue(self.facts['srx_cluster'])

    def _read_file(self, fname):
        from ncclient.xml_ import NCElement

        fpath = os.path.join(os.path.dirname(__file__),
                             'rpc-reply', fname)
        foo = open(fpath).read()

        rpc_reply = NCElement(foo, self.dev._conn.
                              _device_handler.transform_reply()).\
            _NCElement__doc[0]
        return rpc_reply

    def _mock_manager(self, *args, **kwargs):
        if kwargs:
            device_params = kwargs['device_params']
            device_handler = make_device_handler(device_params)
            session = SSHSession(device_handler)
            return Manager(session, device_handler)

        if args:
            return self._read_file(args[0].tag + '.xml')

########NEW FILE########
__FILENAME__ = test_switch_style
__author__ = "Nitin Kumar, Rick Sherman"
__credits__ = "Jeremy Schulman"

import unittest
from nose.plugins.attrib import attr

from jnpr.junos import Device
from jnpr.junos.facts.switch_style import facts_switch_style as switch_style


@attr('unit')
class TestSwitchStyle(unittest.TestCase):

    def setUp(self):
        self.facts = {}
        self.dev = Device(host='1.1.1.1', user='rick', password='password123',
                          gather_facts=False)

    def test_switch_style_mx_srx(self):
        self.facts['personality'] = 'SRX_HIGHEND'
        switch_style(self.dev, self.facts)
        self.assertEqual(self.facts['switch_style'], 'BRIDGE_DOMAIN')

    def test_switch_style_model_firefly(self):
        self.facts['personality'] = 'SWITCH'
        self.facts['model'] = 'FIReFly'
        switch_style(self.dev, self.facts)
        self.assertEqual(self.facts['switch_style'], 'NONE')

    def test_switch_style_model_ex9000(self):
        self.facts['personality'] = 'SWITCH'
        self.facts['model'] = 'EX9000'
        switch_style(self.dev, self.facts)
        self.assertEqual(self.facts['switch_style'], 'VLAN_L2NG')

    def test_switch_style_model_not_specific(self):
        self.facts['personality'] = 'SWITCH'
        self.facts['model'] = 'abc'
        switch_style(self.dev, self.facts)
        self.assertEqual(self.facts['switch_style'], 'VLAN')

    def test_switch_style_persona_not_specific(self):
        self.facts['personality'] = 'PTX'
        self.facts['model'] = 'abc'
        switch_style(self.dev, self.facts)
        self.assertEqual(self.facts['switch_style'], 'NONE')

########NEW FILE########
__FILENAME__ = test_swver
__author__ = "Nitin Kumar, Rick Sherman"
__credits__ = "Jeremy Schulman"

import unittest
from nose.plugins.attrib import attr
from mock import patch
import os

from jnpr.junos import Device
from jnpr.junos.facts.swver import facts_software_version as software_version, version_info
from ncclient.manager import Manager, make_device_handler
from ncclient.transport import SSHSession


@attr('unit')
class TestVersionInfo(unittest.TestCase):

    def test_version_info_after_type_len_else(self):
        self.assertEqual(version_info('12.1X46-D10').build, None)

    def test_version_info_constructor_else_exception(self):
        self.assertEqual(version_info('11.4R7').build, '7')

    def test_version_info_repr(self):
        self.assertEqual(repr(version_info('11.4R7.5')),
                         'junos.version_info(major=(11, 4), '
                         'type=R, minor=7, build=5)')

    def test_version_info_lt(self):
        self.assertTrue(version_info('13.3-20131120') < (14, 1))

    def test_version_info_lt_eq(self):
        self.assertTrue(version_info('13.3-20131120') <= (14, 1))

    def test_version_info_gt(self):
        self.assertTrue(version_info('13.3-20131120') > (12, 1))

    def test_version_info_gt_eq(self):
        self.assertTrue(version_info('13.3-20131120') >= (12, 1))

    def test_version_info_eq(self):
        self.assertEqual(version_info('13.3-20131120'), (13, 3))

    def test_version_info_not_eq(self):
        self.assertNotEqual(version_info('13.3-20131120'), (15, 3))


@attr('unit')
class TestSrxCluster(unittest.TestCase):

    @patch('ncclient.manager.connect')
    def setUp(self, mock_connect):
        mock_connect.side_effect = self._mock_manager
        self.dev = Device(host='1.1.1.1', user='rick', password='password123',
                          gather_facts=False)
        self.dev.open()
        self.facts = {}

    @patch('jnpr.junos.Device.execute')
    def test_swver(self, mock_execute):
        mock_execute.side_effect = self._mock_manager
        self.facts['master'] = 'RE0'
        software_version(self.dev, self.facts)
        self.assertEqual(self.facts['version'], '12.3R6.6')

    @patch('jnpr.junos.Device.execute')
    def test_swver_f_master_list(self, mock_execute):
        mock_execute.side_effect = self._mock_manager
        self.facts['master'] = ['RE0', 'RE1']
        software_version(self.dev, self.facts)
        self.assertEqual(self.facts['version'], '12.3R6.6')

    @patch('jnpr.junos.Device.execute')
    def test_swver_hostname_none(self, mock_execute):
        mock_execute.side_effect = self._mock_manager
        self.facts['master'] = 'RE5'
        self.facts['version_RE5'] = '15.3R6.6'
        software_version(self.dev, self.facts)
        self.assertEqual(self.facts['version'], '15.3R6.6')

# --> JLS, there should always be a facts['master'] assigned.
    # @patch('jnpr.junos.Device.execute')
    # def test_swver_master_none(self, mock_execute):
    #     mock_execute.side_effect = self._mock_manager
    #     self.facts['master'] = None
    #     software_version(self.dev, self.facts)
    #     self.assertEqual(self.facts['version'], '12.3R6.6')

    @patch('jnpr.junos.Device.execute')
    @patch('jnpr.junos.facts.swver.re.findall')
    def test_swver_exception_handling(self, mock_re_findall, mock_execute):
        mock_execute.side_effect = self._mock_manager
        mock_re_findall.side_effect = IndexError
        self.facts['master'] = 'RE0'
        software_version(self.dev, self.facts)
        self.assertEqual(self.facts['version'], '0.0I0.0')

    def _read_file(self, fname):
        from ncclient.xml_ import NCElement

        fpath = os.path.join(os.path.dirname(__file__),
                             'rpc-reply', fname)
        foo = open(fpath).read()

        rpc_reply = NCElement(foo, self.dev._conn.
                              _device_handler.transform_reply())\
            ._NCElement__doc[0]
        return rpc_reply

    def _mock_manager(self, *args, **kwargs):
        if kwargs:
            device_params = kwargs['device_params']
            device_handler = make_device_handler(device_params)
            session = SSHSession(device_handler)
            return Manager(session, device_handler)

        if args:
            return self._read_file(args[0].tag + '.xml')

########NEW FILE########
__FILENAME__ = test_device
__author__ = "Rick Sherman, Nitin Kumar"
__credits__ = "Jeremy Schulman"

import unittest
from nose.plugins.attrib import attr
from mock import MagicMock, patch, mock_open
import os
from lxml import etree

from ncclient.manager import Manager, make_device_handler
from ncclient.transport import SSHSession
import ncclient.transport.errors as NcErrors

from jnpr.junos.facts.swver import version_info
from jnpr.junos import Device
from jnpr.junos.exception import RpcError
from jnpr.junos import exception as EzErrors


facts = {'domain': None, 'hostname': 'firefly', 'ifd_style': 'CLASSIC',
         'version_info': version_info('12.1X46-D15.3'),
         '2RE': False, 'serialnumber': 'aaf5fe5f9b88', 'fqdn': 'firefly',
         'virtual': True, 'switch_style': 'NONE', 'version': '12.1X46-D15.3',
         'HOME': '/cf/var/home/rick', 'srx_cluster': False,
         'model': 'FIREFLY-PERIMETER',
         'RE0': {'status': 'Testing',
                 'last_reboot_reason': 'Router rebooted after a '
                 'normal shutdown.',
                 'model': 'FIREFLY-PERIMETER RE',
                 'up_time': '6 hours, 29 minutes, 30 seconds'},
         'vc_capable': False, 'personality': 'SRX_BRANCH'}


@attr('unit')
class Test_MyTemplateLoader(unittest.TestCase):
    def setUp(self):
        from jnpr.junos.device import _MyTemplateLoader
        self.template_loader = _MyTemplateLoader()

    @patch('__builtin__.filter')
    def test_temp_load_get_source_filter_false(self, filter_mock):
        filter_mock.return_value = False
        try:
            self.template_loader.get_source(None, None)
        except Exception as ex:
            import jinja2
            self.assertEqual(type(ex), jinja2.exceptions.TemplateNotFound)

    @patch('jnpr.junos.device.os.path')
    def test_temp_load_get_source_filter_true(self, os_path_mock):
        #cant use @patch here as with statement will have exit
        m = mock_open()
        with patch('__builtin__.file', m, create=True):
            self.template_loader.get_source(None, None)


@attr('unit')
class TestDevice(unittest.TestCase):

    @patch('ncclient.manager.connect')
    def setUp(self, mock_connect):
        mock_connect.side_effect = self._mock_manager
        self.dev = Device(host='1.1.1.1', user='rick', password='password123',
                          gather_facts=False)
        self.dev.open()

    @patch('ncclient.operations.session.CloseSession.request')
    def tearDown(self, mock_session):
        self.dev.close()

    @patch('jnpr.junos.device.netconf_ssh')
    def test_device_ConnectAuthError(self, mock_manager):
        mock_manager.connect.side_effect = NcErrors.AuthenticationError
        self.assertRaises(EzErrors.ConnectAuthError, self.dev.open)

    @patch('jnpr.junos.device.netconf_ssh')
    def test_device_ConnectRefusedError(self, mock_manager):
        mock_manager.connect.side_effect = NcErrors.SSHError
        self.assertRaises(EzErrors.ConnectRefusedError, self.dev.open)

    @patch('jnpr.junos.device.netconf_ssh')
    @patch('jnpr.junos.device.datetime')
    def test_device_ConnectTimeoutError(self, mock_datetime, mock_manager):
        NcErrors.SSHError.message = 'cannot open'
        mock_manager.connect.side_effect = NcErrors.SSHError
        from datetime import timedelta, datetime
        currenttime = datetime.now()
        mock_datetime.datetime.now.side_effect = [currenttime,
                                                  currenttime + timedelta(minutes=4)]
        self.assertRaises(EzErrors.ConnectTimeoutError, self.dev.open)

    @patch('jnpr.junos.device.netconf_ssh')
    @patch('jnpr.junos.device.datetime')
    def test_device_diff_err_message(self, mock_datetime, mock_manager):
        NcErrors.SSHError.message = 'why are you trying :)'
        mock_manager.connect.side_effect = NcErrors.SSHError
        from datetime import timedelta, datetime
        currenttime = datetime.now()
        mock_datetime.datetime.now.side_effect = [currenttime,
                                                  currenttime + timedelta(minutes=4)]
        self.assertRaises(EzErrors.ConnectError, self.dev.open)

    @patch('jnpr.junos.device.netconf_ssh')
    def test_device_ConnectUnknownHostError(self, mock_manager):
        import socket
        mock_manager.connect.side_effect = socket.gaierror
        self.assertRaises(EzErrors.ConnectUnknownHostError, self.dev.open)

    @patch('jnpr.junos.device.netconf_ssh')
    def test_device_other_error(self, mock_manager):
        mock_manager.connect.side_effect = TypeError
        self.assertRaises(EzErrors.ConnectError, self.dev.open)

    def test_device_property_logfile_isinstance(self):
        mock = MagicMock()
        with patch('__builtin__.open', mock):
            with patch('__builtin__.file', MagicMock):
                handle = open('filename', 'r')
                self.dev.logfile = handle
                self.assertEqual(self.dev.logfile, handle)

    def test_device_host_mand_param(self):
        self.assertRaises(ValueError, Device, user='rick',
                          password='password123',
                          gather_facts=False)

    def test_device_property_logfile_close(self):
        self.dev._logfile = MagicMock()
        self.dev._logfile.close.return_value = 0
        self.dev.logfile = None
        self.assertFalse(self.dev._logfile)

    def test_device_property_logfile_exception(self):
        try:
            self.dev.logfile = True
        except Exception as ex:
            self.assertEqual(type(ex), ValueError)

    def test_device_repr(self):
        localdev = Device(host='1.1.1.1', user='rick', password='password123',
                          gather_facts=False)
        self.assertEqual(repr(localdev), 'Device(1.1.1.1)')

    @patch('jnpr.junos.device.os')
    @patch('__builtin__.open')
    @patch('paramiko.config.SSHConfig.lookup')
    def test_device__sshconf_lkup(self, os_mock, open_mock, mock_paramiko):
        os_mock.path.exists.return_value = True
        self.dev._sshconf_lkup()
        mock_paramiko.assert_called_any()

    @patch('os.getenv')
    def test_device__sshconf_lkup_path_not_exists(self, mock_env):
        mock_env.return_value = '/home/test'
        self.assertEqual(self.dev._sshconf_lkup(), None)

    @patch('os.getenv')
    def test_device__sshconf_lkup_home_not_defined(self, mock_env):
        mock_env.return_value = None
        self.assertEqual(self.dev._sshconf_lkup(), None)
        mock_env.assert_called_with('HOME')

    @patch('ncclient.manager.connect')
    @patch('jnpr.junos.Device.execute')
    def test_device_open(self, mock_connect, mock_execute):
        with patch('jnpr.junos.utils.fs.FS.cat') as mock_cat:
            mock_cat.return_value = """

    domain jls.net

            """
            mock_connect.side_effect = self._mock_manager
            mock_execute.side_effect = self._mock_manager
            self.dev2 = Device(host='2.2.2.2', user='rick', password='password123')
            self.dev2.open()
            self.assertEqual(self.dev2.connected, True)

    @patch('jnpr.junos.Device.execute')
    def test_device_facts(self, mock_execute):
        with patch('jnpr.junos.utils.fs.FS.cat') as mock_cat:
            mock_execute.side_effect = self._mock_manager
            mock_cat.return_value = """

    domain jls.net

            """
            self.dev.facts_refresh()
            assert self.dev.facts['version'] == facts['version']

    def test_device_hostname(self):
        self.assertEqual(self.dev.hostname, '1.1.1.1')

    def test_device_user(self):
        self.assertEqual(self.dev.user, 'rick')

    def test_device_get_password(self):
        self.assertEqual(self.dev.password, None)

    def test_device_set_password(self):
        self.dev.password = 'secret'
        self.assertEqual(self.dev._password, 'secret')

    def test_device_get_timeout(self):
        self.assertEqual(self.dev.timeout, 30)

    def test_device_set_timeout(self):
        self.dev.timeout = 10
        self.assertEqual(self.dev.timeout, 10)

    def test_device_manages(self):
        self.assertEqual(self.dev.manages, [],
                         'By default manages will be empty list')

    def test_device_set_facts_exception(self):
        try:
            self.dev.facts = 'test'
        except RuntimeError as ex:
            self.assertEqual(RuntimeError, type(ex))

    @patch('jnpr.junos.Device.execute')
    def test_device_cli(self, mock_execute):
        mock_execute.side_effect = self._mock_manager
        self.assertEqual(self.dev.cli('show cli directory').tag, 'cli')

    @patch('jnpr.junos.Device.execute')
    def test_device_cli_conf_info(self, mock_execute):
        mock_execute.side_effect = self._mock_manager
        self.assertTrue('ge-0/0/0' in self.dev.cli('show configuration'))

    @patch('jnpr.junos.Device.execute')
    def test_device_cli_output(self, mock_execute):
        mock_execute.side_effect = self._mock_manager
        self.assertTrue('Alarm' in self.dev.cli('show system alarms'))

    @patch('jnpr.junos.Device.execute')
    def test_device_cli_rpc(self, mock_execute):
        mock_execute.side_effect = self._mock_manager
        self.assertEqual(self.dev.cli('show system uptime | display xml rpc')\
                         .tag, 'get-system-uptime-information')

    def test_device_cli_exception(self):
        self.dev.rpc.cli = MagicMock(side_effect=AttributeError)
        val = self.dev.cli('show version')
        self.assertEqual(val, 'invalid command: show version')

    def test_device_execute(self):
        self.dev._conn.rpc = MagicMock(side_effect=self._mock_manager)
        self.assertEqual(self.dev.execute('<get-system-core-dumps/>').tag,
                         'directory-list')

    def test_device_execute_topy(self):
        self.dev._conn.rpc = MagicMock(side_effect=self._mock_manager)
        self.assertEqual(self.dev.execute('<get-system-core-dumps/>',
                                          to_py=self._do_nothing), 'Nothing')

    def test_device_execute_exception(self):
        class MyException(Exception):
            rpc_err = """
<rpc-error xmlns="urn:ietf:params:xml:ns:netconf:base:1.0" xmlns:junos="http://xml.juniper.net/junos/12.1X46/junos" xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0">
<error-severity>error</error-severity>
<error-info>
<bad-element>get-bgp-summary-information</bad-element>
</error-info>
<error-message>permission denied</error-message>
</rpc-error>                
            """
            xml = etree.XML(rpc_err)

        self.dev._conn.rpc = MagicMock(side_effect=MyException)
        self.assertRaises(RpcError, self.dev.execute, 
            '<get-software-information/>')

    def test_device_execute_rpc_error(self):
        self.dev._conn.rpc = MagicMock(side_effect=self._mock_manager)
        self.assertRaises(RpcError, self.dev.rpc.get_rpc_error)

    def test_device_execute_index_error(self):
        self.dev._conn.rpc = MagicMock(side_effect=self._mock_manager)
        self.assertTrue(self.dev.rpc.get_index_error())

    def test_device_execute_ValueError(self):
        self.assertRaises(ValueError, self.dev.execute, None)

    def test_device_rpcmeta(self):
        self.assertEqual(self.dev.rpc.get_software_information.func_doc,
                         'get-software-information')

    def test_device_probe_timeout_zero(self):
        with patch('jnpr.junos.device.socket'):
            self.assertFalse(self.dev.probe(0))

    def test_device_probe_timeout_gt_zero(self):
        with patch('jnpr.junos.device.socket'):
            self.assertTrue(self.dev.probe(1),
                            'probe fn is not working for'
                            ' timeout greater than zero')

    def test_device_probe_timeout_exception(self):
        with patch('jnpr.junos.device.socket') as mock_socket:
            with patch('jnpr.junos.device.time.sleep') as mock_time:
                mock_socket.socket.return_value.close.side_effect \
                    = RuntimeError
                mock_time.return_value = None
                self.assertFalse(self.dev.probe(.01))

    def test_device_bind_varg(self):
        self.dev.bind()
        mock = MagicMock()
        mock.__name__ = 'magic_mock'
        self.dev.bind(mock)
        self.assertEqual(self.dev.magic_mock.__name__, 'magic_mock')

    def test_device_bind_kvarg(self):
        self.dev.bind()
        mock = MagicMock()
        mock.return_value = 'Test'
        self.dev.bind(kw=mock)
        self.assertEqual(self.dev.kw, 'Test')

    def test_device_bind_varg_exception(self):
        def varg():
            self.dev.bind()
            mock = MagicMock()
            mock.__name__ = 'magic mock'
            #for *args
            self.dev.bind(mock)
            self.dev.bind(mock)
        self.assertRaises(ValueError, varg)

    def test_device_bind_kvarg_exception(self):
        def kve():
            self.dev.bind()
            mock = MagicMock()
            mock.__name__ = 'magic mock'
            #for **kwargs
            self.dev.bind(kw=mock)
            self.dev.bind(kw=mock)
        self.assertRaises(ValueError, kve)

    def test_device_template(self):
        # Try to load the template relative to module base
        try:
            template = self.dev.Template('tests/unit/templates/config-example')
        except:
            # Try to load the template relative to test base
            try:
                template = self.dev.Template('templates/config-example')
            except:
                raise
        self.assertEqual(template.render({'host_name': '1',
                               'domain_name': '2'}),
                               'system {\n  host-name 1;\n  domain-name 2;\n}')

    def test_device_close(self):
        def close_conn():
            self.dev.connected = False
        self.dev.close = MagicMock(name='close')
        self.dev.close.side_effect = close_conn
        self.dev.close()
        self.assertEqual(self.dev.connected, False)

    def _read_file(self, fname):
        from ncclient.xml_ import NCElement

        fpath = os.path.join(os.path.dirname(__file__),
                             'rpc-reply', fname)
        foo = open(fpath).read()

        if (fname == 'get-rpc-error.xml' or
                fname == 'get-index-error.xml' or
                fname == 'get-system-core-dumps.xml'):
            rpc_reply = NCElement(foo, self.dev._conn._device_handler
                                  .transform_reply())
        elif (fname == 'show-configuration.xml' or
              fname == 'show-system-alarms.xml'):
            rpc_reply = NCElement(foo, self.dev._conn._device_handler
                                  .transform_reply())._NCElement__doc
        else:
            rpc_reply = NCElement(foo, self.dev._conn._device_handler
                                  .transform_reply())._NCElement__doc[0]
        return rpc_reply

    def _mock_manager(self, *args, **kwargs):
        if kwargs:
            device_params = kwargs['device_params']
            device_handler = make_device_handler(device_params)
            session = SSHSession(device_handler)
            return Manager(session, device_handler)

        elif args:
            if args[0].tag == 'command':
                if args[0].text == 'show cli directory':
                    return self._read_file('show-cli-directory.xml')
                elif args[0].text == 'show configuration':
                    return self._read_file('show-configuration.xml')
                elif args[0].text == 'show system alarms':
                    return self._read_file('show-system-alarms.xml')
                elif args[0].text == 'show system uptime | display xml rpc':
                    return self._read_file('show-system-uptime-rpc.xml')
                else:
                    raise RpcError

            else:
                return self._read_file(args[0].tag + '.xml')

    def _do_nothing(self, *args, **kwargs):
        return 'Nothing'
    

########NEW FILE########
__FILENAME__ = test_exception
__author__ = "Nitin Kumar, Rick Sherman"
__credits__ = "Jeremy Schulman"

import unittest
from nose.plugins.attrib import attr
from jnpr.junos.exception import RpcError, CommitError, ConnectError
from jnpr.junos import Device
from lxml import etree


@attr('unit')
class Test_RpcError(unittest.TestCase):

    def test_rpcerror_repr(self):
        rsp = etree.XML('<root><a>test</a></root>')
        obj = RpcError(rsp=rsp)
        self.assertEquals(str, type(obj.__repr__()))
        self.assertEqual(obj.__repr__(), '<root>\n  <a>test</a>\n</root>\n')

    def test_rpcerror_jxml_check(self):
        # this test is intended to hit jxml code
        rsp = etree.XML('<rpc-reply><a>test</a></rpc-reply>')
        obj = CommitError(rsp=rsp)
        self.assertEqual(type(obj.rpc_error), dict)

    def test_ConnectError(self):
        self.dev = Device(host='1.1.1.1', user='rick', password='password123',
                          gather_facts=False)
        obj = ConnectError(self.dev)
        self.assertEqual(obj.user, 'rick')
        self.assertEqual(obj.host, '1.1.1.1')
        self.assertEqual(obj.port, 830)
        self.assertEqual(repr(obj), 'ConnectError(1.1.1.1)')

########NEW FILE########
__FILENAME__ = test_jxml
__author__ = "Nitin Kumar, Rick Sherman"
__credits__ = "Jeremy Schulman"

import unittest
from nose.plugins.attrib import attr
from jnpr.junos.jxml import NAME, INSERT, remove_namespaces


@attr('unit')
class Test_JXML(unittest.TestCase):

    def test_name(self):
        op = NAME('test')
        self.assertEqual(op['name'], 'test')

    def test_insert(self):
        op = INSERT('test')
        self.assertEqual(op['insert'], 'test')

    def test_remove_namespaces(self):
        xmldata = \
            """<xsl:stylesheet xmlns:xsl="http://xml.juniper.net/junos">
                    <xsl:template>
                        <xsl:attribute name="{myname}">
                        </xsl:attribute>
                    </xsl:template>
                </xsl:stylesheet>"""
        import xml.etree.ElementTree as ET
        root = ET.fromstring(xmldata)
        test = remove_namespaces(root)
        for elem in test.getiterator():
            i = elem.tag.find('}')
            if i > 0:
                i = i + 1
        self.assertTrue(i <= 0)

########NEW FILE########
__FILENAME__ = test_rpcmeta
__author__ = "Nitin Kumar, Rick Sherman"
__credits__ = "Jeremy Schulman"

import unittest
from nose.plugins.attrib import attr

from jnpr.junos.device import Device
from jnpr.junos.rpcmeta import _RpcMetaExec

from mock import patch
from lxml import etree


@attr('unit')
class Test_RpcMetaExec(unittest.TestCase):

    def setUp(self):
        self.dev = Device(host='1.1.1.1')
        self.rpc = _RpcMetaExec(self.dev)

    def test_rpcmeta_constructor(self):
        self.assertTrue(isinstance(self.rpc._junos, Device))

    @patch('jnpr.junos.device.Device.execute')
    def test_rpcmeta_load_config(self, mock_execute_fn):
        root = etree.XML('<root><a>test</a></root>')
        self.rpc.load_config(root)
        self.assertEqual(mock_execute_fn.call_args[0][0].tag,
                         'load-configuration')

    @patch('jnpr.junos.device.Device.execute')
    def test_rpcmeta_load_config_option_action(self, mock_execute_fn):
        set_commands = """
            set system host-name test_rpc
            set system domain-name test.juniper.net
        """
        self.rpc.load_config(set_commands, action='set')
        self.assertEqual(mock_execute_fn.call_args[0][0].get('action'),
                         'set')

    @patch('jnpr.junos.device.Device.execute')
    def test_rpcmeta_option_format(self, mock_execute_fn):
        set_commands = """
            set system host-name test_rpc
            set system domain-name test.juniper.net
        """
        self.rpc.load_config(set_commands, format='text')
        self.assertEqual(mock_execute_fn.call_args[0][0].get('format'),
                         'text')

    @patch('jnpr.junos.device.Device.execute')
    def test_rpcmeta_exec_rpc_vargs(self, mock_execute_fn):
        self.rpc.system_users_information(dict(format='text'))
        self.assertEqual(mock_execute_fn.call_args[0][0].get('format'),
                         'text')

    @patch('jnpr.junos.device.Device.execute')
    def test_rpcmeta_exec_rpc_kvargs(self, mock_execute_fn):
        self.rpc.system_users_information(set_data=('test',))
        self.assertEqual(mock_execute_fn.call_args[0][0][0].text,
                         'test')

    @patch('jnpr.junos.device.Device.execute')
    def test_rpcmeta_get_config(self, mock_execute_fn):
        root = etree.XML('<root><a>test</a></root>')
        self.rpc.get_config(root)
        self.assertEqual(mock_execute_fn.call_args[0][0].tag,
                         'get-configuration')

########NEW FILE########
__FILENAME__ = test_config
__author__ = "Nitin Kumar, Rick Sherman"
__credits__ = "Jeremy Schulman"

import unittest
from nose.plugins.attrib import attr

from jnpr.junos import Device
from jnpr.junos.utils.config import Config
from jnpr.junos.exception import RpcError, LockError,\
    UnlockError, CommitError

from mock import MagicMock, patch


@attr('unit')
class TestConfig(unittest.TestCase):
    def setUp(self):
        self.dev = Device(host='1.1.1.1')
        self.conf = Config(self.dev)

    def test_config_constructor(self):
        self.assertTrue(isinstance(self.conf._dev, Device))

    def test_config_confirm(self):
        self.conf.rpc.commit_configuration = MagicMock()
        self.assertTrue(self.conf.commit(confirm=True))

    def test_config_commit_confirm_timeout(self):
        self.conf.rpc.commit_configuration = MagicMock()
        self.conf.commit(confirm=10)
        self.conf.rpc.commit_configuration\
            .assert_called_with(**{'confirm-timeout': '10', 'confirmed': True})

    def test_config_commit_comment(self):
        self.conf.rpc.commit_configuration = MagicMock()
        self.conf.commit(comment='Test')
        self.conf.rpc.commit_configuration.assert_called_with(log='Test')

    @patch('jnpr.junos.utils.config.JXML.remove_namespaces')
    def test_config_commit_exception(self, mock_jxml):
        class MyException(Exception):
            xml = 'test'
        self.conf.rpc.commit_configuration = \
            MagicMock(side_effect=MyException)
        self.assertRaises(AttributeError, self.conf.commit)

    def test_config_commit_exception_RpcError(self):
        ex = RpcError(rsp='ok')
        self.conf.rpc.commit_configuration = MagicMock(side_effect=ex)
        self.assertTrue(self.conf.commit())
        import xml.etree.ElementTree as ET
        xmldata = """<data><company name="Juniper">
            <code>pyez</code>
            <year>2013</year>
            </company></data>"""
        root = ET.fromstring(xmldata)
        el = root.find('company')
        ex = RpcError(rsp=el)
        self.conf.rpc.commit_configuration = MagicMock(side_effect=ex)
        self.assertRaises(CommitError, self.conf.commit)

    def test_commit_check(self):
        self.conf.rpc.commit_configuration = MagicMock()
        self.assertTrue(self.conf.commit_check())

    @patch('jnpr.junos.utils.config.JXML.rpc_error')
    def test_commit_check_exception(self, mock_jxml):
        class MyException(Exception):
                xml = 'test'
        self.conf.rpc.commit_configuration = MagicMock(side_effect=MyException)
        #with self.assertRaises(AttributeError):
        self.conf.commit_check()

    def test_config_commit_check_exception_RpcError(self):
        ex = RpcError(rsp='ok')
        self.conf.rpc.commit_configuration = MagicMock(side_effect=ex)
        self.assertTrue(self.conf.commit_check())
        import xml.etree.ElementTree as ET
        xmldata = """<data><company name="Juniper">
            <code>pyez</code>
            <year>2013</year>
            </company></data>"""
        root = ET.fromstring(xmldata)
        el = root.find('company')
        ex = RpcError(rsp=el)
        self.conf.rpc.commit_configuration = MagicMock(side_effect=ex)
        self.assertRaises(CommitError, self.conf.commit_check)

    def test_config_diff(self):
        self.conf.rpc.get_configuration = MagicMock()
        self.conf.diff()
        self.conf.rpc.get_configuration.\
            assert_called_with({'compare': 'rollback', 'rollback': '0', 'format':'text'})

    def test_config_pdiff(self):
        self.conf.diff = MagicMock(return_value='')
        self.conf.pdiff()
        self.conf.diff.assert_any_call()

    def test_config_load(self):
        self.assertRaises(RuntimeError, self.conf.load)

    def test_config_load_vargs_len(self):
        self.assertRaises(RuntimeError, self.conf.load,
                          'test.xml')

    def test_config_load_len_with_format(self):
        self.conf.rpc.load_config = \
            MagicMock(return_value='rpc_contents')
        self.assertEqual(self.conf.load('test.xml', format='set'),
                         'rpc_contents')

    @patch('__builtin__.open')
    def test_config_load_lformat_byext_ValueError(self, mock_open):
        self.conf.rpc.load_config = \
            MagicMock(return_value='rpc_contents')
        self.assertRaises(ValueError, self.conf.load, path='test.jnpr')

    def test_config_load_lset_format_ValueError(self):
        self.conf.rpc.load_config = \
            MagicMock(return_value='rpc_contents')
        self.assertRaises(ValueError, self.conf.load,
                          'test.xml', format='set', overwrite=True)

    @patch('__builtin__.open')
    @patch('jnpr.junos.utils.config.etree.XML')
    def test_config_load_path_xml(self, mock_etree, mock_open):
        self.conf.dev.Template = MagicMock()
        mock_etree.return_value = 'rpc_contents'
        self.conf.rpc.load_config = \
            MagicMock(return_value=mock_etree.return_value)
        self.assertEqual(self.conf.load(path='test.xml'), 'rpc_contents')

    @patch('__builtin__.open')
    def test_config_load_path_text(self, mock_open):
        self.conf.rpc.load_config = MagicMock()
        self.conf.load(path='test.conf')
        self.assertEqual(self.conf.rpc.load_config.call_args[1]['format'],
                         'text')

    @patch('__builtin__.open')
    def test_config_load_path_set(self, mock_open):
        self.conf.rpc.load_config = MagicMock()
        self.conf.load(path='test.set')
        self.assertEqual(self.conf.rpc.load_config.call_args[1]['action'],
                         'set')

    def test_config_load_template_path(self):
        self.conf.rpc.load_config = MagicMock()
        self.conf.dev.Template = MagicMock()
        self.conf.load(template_path='test.xml')
        self.conf.dev.Template.assert_called_with('test.xml')

    def test_config_load_template(self):
        class Temp:
            filename = 'abc.xml'
            render = MagicMock()
        self.conf.rpc.load_config = MagicMock()
        self.conf.load(template=Temp)
        self.assertEqual(self.conf.rpc.load_config.call_args[1]['format'],
                         'xml')

    def test_config_diff_exception(self):
        self.conf.rpc.get_configuration = MagicMock()
        self.assertRaises(ValueError, self.conf.diff, rollback=51)
        self.assertRaises(ValueError, self.conf.diff, rollback=-1)

    def test_config_lock(self):
        self.conf.rpc.lock_configuration = MagicMock()
        self.assertTrue(self.conf.lock())

    @patch('jnpr.junos.utils.config.JXML.rpc_error')
    def test_config_lock_LockError(self, mock_jxml):
        ex = RpcError(rsp='ok')
        self.conf.rpc.lock_configuration = MagicMock(side_effect=ex)
        self.assertRaises(LockError, self.conf.lock)

    @patch('jnpr.junos.utils.config.JXML.remove_namespaces')
    def test_config_lock_exception(self, mock_jxml):
        class MyException(Exception):
                xml = 'test'
        self.conf.rpc.lock_configuration = MagicMock(side_effect=MyException)
        self.assertRaises(LockError, self.conf.lock)

    def test_config_unlock(self):
        self.conf.rpc.unlock_configuration = MagicMock()
        self.assertTrue(self.conf.unlock())

    @patch('jnpr.junos.utils.config.JXML.rpc_error')
    def test_config_unlock_LockError(self, mock_jxml):
        ex = RpcError(rsp='ok')
        self.conf.rpc.unlock_configuration = MagicMock(side_effect=ex)
        self.assertRaises(LockError, self.conf.unlock)

    @patch('jnpr.junos.utils.config.JXML.remove_namespaces')
    def test_config_unlock_exception(self, mock_jxml):
        class MyException(Exception):
                xml = 'test'
        self.conf.rpc.unlock_configuration = MagicMock(side_effect=MyException)
        self.assertRaises(UnlockError, self.conf.unlock)

    def test_config_rollback(self):
        self.conf.rpc.load_configuration = MagicMock()
        self.assertTrue(self.conf.rollback())

    def test_config_rollback_exception(self):
        self.conf.rpc.load_configuration = MagicMock()
        self.assertRaises(ValueError, self.conf.rollback, 51)
        self.assertRaises(ValueError, self.conf.rollback, -1)

########NEW FILE########
__FILENAME__ = test_fs
__author__ = "Nitin Kumar, Rick Sherman"
__credits__ = "Jeremy Schulman"

import unittest
from nose.plugins.attrib import attr
import os

from ncclient.manager import Manager, make_device_handler
from ncclient.transport import SSHSession

from jnpr.junos import Device
from jnpr.junos.utils.fs import FS

from mock import patch, MagicMock, call


@attr('unit')
class TestFS(unittest.TestCase):

    @patch('ncclient.manager.connect')
    def setUp(self, mock_connect):
        mock_connect.side_effect = self._mock_manager
        self.dev = Device(host='1.1.1.1', user='rick', password='password123',
                          gather_facts=False)
        self.dev.open()
        self.fs = FS(self.dev)

    def test_cat_wrong_path_return_none(self):
        path = 'test/report'
        self.assertEqual(self.fs.cat(path), None)

    def test_cat(self):
        self.fs._dev.rpc.file_show = MagicMock(side_effect=self._mock_manager)
        path = 'test/cat.txt'
        self.assertTrue('testing cat functionality' in self.fs.cat(path))
        self.fs._dev.rpc.file_show.assert_called_with(filename='test/cat.txt')

    def test_cwd(self):
        self.fs._dev.rpc.set_cli_working_directory = MagicMock()
        folder = 'test/report'
        self.fs.cwd(folder)
        self.fs._dev.rpc.set_cli_working_directory.\
            assert_called_with(directory='test/report')

    @patch('jnpr.junos.Device.execute')
    def test_pwd(self, mock_execute):
        mock_execute.side_effect = MagicMock(side_effect=self._mock_manager)
        self.fs.pwd()
        self.assertEqual(self.fs.pwd(), '/cf/var/home/rick')

    def test_checksum_return_none(self):
        path = 'test/report'
        self.assertEqual(self.fs.checksum(path), None)

    def test_checksum_unknown_calc(self):
        path = 'test/report'
        self.assertRaises(ValueError, self.fs.checksum, path=path, calc='abc')

    def test_checksum_return_rsp(self):
        self.fs.dev.rpc.get_sha256_checksum_information = \
            MagicMock(side_effect=self._mock_manager)
        path = 'test/checksum'
        self.assertEqual(self.fs.checksum(path, 'sha256'), 'xxxx')
        self.fs.dev.rpc.get_sha256_checksum_information.\
            assert_called_with(path='test/checksum')

    def test_stat_calling___decode_file(self):
        path = 'test/stat/decode_file'
        self.fs.dev.rpc.file_list = \
            MagicMock(side_effect=self._mock_manager)
        self.assertEqual(self.fs.stat(path),
                             {'owner': 'pqr', 'path': '/var/abc.sh',
                              'permissions': 755,
                              'permissions_text': '-rwxr-xr-x', 'size': 2,
                              'ts_date': 'Mar 13 06:54',
                              'ts_epoc': '1394693680',
                              'type': 'file'})

    def test_stat_calling___decode_dir(self):
        path = 'test/stat/decode_dir'
        self.fs.dev.rpc.file_list = \
            MagicMock(side_effect=self._mock_manager)
        self.assertEqual(self.fs.stat(path),
                             {'path': '/var', 'type': 'dir', 'file_count': 1,
                              'size': 2})

    def test_stat_return_none(self):
        path = 'test/abc'
        self.fs.dev.rpc.file_list = MagicMock()
        self.fs.dev.rpc.file_list.find.return_value = 'output'
        self.assertEqual(self.fs.stat(path), None)

    def test_ls_calling___decode_file(self):
        path = 'test/stat/decode_file'
        self.fs.dev.rpc.file_list = \
            MagicMock(side_effect=self._mock_manager)
        self.assertEqual(self.fs.ls(path),
                             {'owner': 'pqr', 'path': '/var/abc.sh',
                              'permissions': 755,
                              'permissions_text': '-rwxr-xr-x', 'size': 2,
                              'ts_date': 'Mar 13 06:54',
                              'ts_epoc': '1394693680',
                              'type': 'file'})

    def test_ls_calling___decode_dir(self):
        path = 'test/stat/decode_dir'
        self.fs.dev.rpc.file_list = \
            MagicMock(side_effect=self._mock_manager)
        self.assertEqual(self.fs.ls(path),
                             {'files':
                              {'abc': {'permissions_text': 'drwxr-xr-x',
                                       'ts_date': 'Feb 17 15:30',
                                       'ts_epoc': '1392651039',
                                       'owner': 'root', 'path': 'abc',
                                       'size': 2, 'type': 'dir',
                                       'permissions': 555}},
                                 'path': '/var', 'type': 'dir',
                                 'file_count': 1,
                                 'size': 2})

    def test_ls_return_none(self):
        path = 'test/abc'
        self.fs.dev.rpc.file_list = MagicMock()
        self.fs.dev.rpc.file_list.find.return_value = 'output'
        self.assertEqual(self.fs.ls(path), None)

    @patch('jnpr.junos.utils.fs.FS._decode_file')
    def test_ls_link_path_false(self, mock_decode_file):
        mock_decode_file.get.return_value = False
        path = 'test/stat/decode_file'
        self.fs.dev.rpc.file_list = \
            MagicMock(side_effect=self._mock_manager)
        op = self.fs.ls(path, followlink=False)
        mock_decode_file.assert_has_calls(call().get('link'))

    def test_ls_brief_true(self):
        path = 'test/stat/decode_dir'
        self.fs.dev.rpc.file_list = \
            MagicMock(side_effect=self._mock_manager)
        self.assertEqual(self.fs.ls(path, brief=True),
                             {'files': ['abc'], 'path': '/var',
                              'type': 'dir', 'file_count': 1, 'size': 2})

    def test_ls_calling___decode_dir_type_symbolic_link(self):
        path = 'test/stat/decode_symbolic_link'
        self.fs.dev.rpc.file_list = \
            MagicMock(side_effect=self._mock_manager)
        self.assertEqual(self.fs.ls(path),
                             {'files':
                              {'abc': {'permissions_text': 'drwxr-xr-x',
                                       'ts_date': 'Feb 17 15:30',
                                       'link': 'symlink test',
                                       'ts_epoc': '1392651039',
                                       'owner': 'root', 'path': 'abc',
                                       'size': 2, 'type': 'link',
                                       'permissions': 555}},
                              'path': '/var', 'type': 'dir', 'file_count': 1,
                              'size': 2})

    def test_rm_return_true(self):
        self.fs.dev.rpc.file_delete = MagicMock(return_value=True)
        path = 'test/abc'
        self.assertTrue(self.fs.rm(path))
        self.fs.dev.rpc.file_delete.assert_called_once_with(
            path='test/abc')

    def test_rm_return_false(self):
        path = 'test/abc'
        self.fs.dev.rpc.file_delete = MagicMock(return_value=False)
        self.assertFalse(self.fs.rm(path))
        self.fs.dev.rpc.file_delete.assert_called_once_with(
            path='test/abc')

    def test_copy_return_true(self):
        self.fs.dev.rpc.file_copy = MagicMock()
        initial = 'test/abc'
        final = 'test/xyz'
        self.assertTrue(self.fs.cp(initial, final))
        self.fs.dev.rpc.file_copy.assert_called_once_with(
            source='test/abc',
            destination='test/xyz')

    def test_copy_return_false(self):
        initial = 'test/abc'
        final = 'test/xyz'
        self.fs.dev.rpc.file_copy = MagicMock(side_effect=Exception)
        self.assertFalse(self.fs.cp(initial, final))
        self.fs.dev.rpc.file_copy.assert_called_once_with(
            source='test/abc',
            destination='test/xyz')

    def test_move_return_true(self):
        self.fs.dev.rpc.file_rename = MagicMock(return_value=True)
        initial = 'test/abc'
        final = 'test/xyz'
        self.assertTrue(self.fs.mv(initial, final))
        self.fs.dev.rpc.file_rename.assert_called_once_with(
            source='test/abc',
            destination='test/xyz')

    def test_move_return_false(self):
        initial = 'test/abc'
        final = 'test/xyz'
        self.fs.dev.rpc.file_rename = MagicMock(return_value=False)
        self.assertFalse(self.fs.mv(initial, final))
        self.fs.dev.rpc.file_rename.assert_called_once_with(
            source='test/abc',
            destination='test/xyz')

    def test_tgz_return_true(self):
        src = 'test/tgz.txt'
        dst = 'test/xyz'
        self.fs.dev.rpc.file_archive = MagicMock(return_value=True)
        self.assertTrue(self.fs.tgz(src, dst))
        self.fs.dev.rpc.file_archive.assert_called_once_with(
            source='test/tgz.txt',
            destination='test/xyz', compress=True)

    @patch('jnpr.junos.Device.execute')
    def test_tgz_return_error(self, mock_execute):
        mock_execute.side_effect = self._mock_manager
        src = 'test/tgz.txt'
        dst = 'test/xyz'
        self.assertTrue('testing tgz' in self.fs.tgz(src, dst))

    @patch('jnpr.junos.utils.fs.StartShell')
    def test_rmdir(self, mock_StartShell):
        path = 'test/rmdir'
        print self.fs.rmdir(path)
        calls = [
            call().__enter__(),
            call().__enter__().run('rmdir test/rmdir'),
            call().__exit__(None, None, None)]
        mock_StartShell.assert_has_calls(calls)

    @patch('jnpr.junos.utils.fs.StartShell')
    def test_mkdir(self, mock_StartShell):
        path = 'test/mkdir'
        print self.fs.mkdir(path)
        calls = [
            call().__enter__(),
            call().__enter__().run('mkdir -p test/mkdir'),
            call().__exit__(None, None, None)]
        mock_StartShell.assert_has_calls(calls)

    @patch('jnpr.junos.utils.fs.StartShell')
    def test_symlink(self, mock_StartShell):
        src = 'test/tgz.txt'
        dst = 'test/xyz'
        print self.fs.symlink(src, dst)
        calls = [
            call().__enter__(),
            call().__enter__().run('ln -sf test/tgz.txt test/xyz'),
            call().__exit__(None, None, None)]
        mock_StartShell.assert_has_calls(calls)

    @patch('jnpr.junos.Device.execute')
    def test_storage_usage(self, mock_execute):
        mock_execute.side_effect = self._mock_manager
        self.assertEqual(self.fs.storage_usage(),
                             {'/dev/abc':
                              {'avail_block': 234234,
                               'used_blocks': 2346455, 'used_pct': '1',
                               'mount': '/', 'total_blocks': 567431,
                               'avail': '2F', 'used': '481M',
                               'total': '4F'}})

    @patch('jnpr.junos.Device.execute')
    def test_storage_cleanup(self, mock_execute):
        mock_execute.side_effect = self._mock_manager
        self.assertEqual(self.fs.storage_cleanup(),
                             {'/var/abc.txt':
                              {'ts_date': 'Apr 25 10:38', 'size': 11}})

    @patch('jnpr.junos.Device.execute')
    def test_storage_cleanup_check(self, mock_execute):
        mock_execute.side_effect = self._mock_manager
        self.assertEqual(self.fs.storage_cleanup_check(),
                             {'/var/abc.txt':
                              {'ts_date': 'Apr 25 10:38', 'size': 11}})

    def _read_file(self, fname):
        from ncclient.xml_ import NCElement
        fpath = os.path.join(os.path.dirname(__file__),
                             'rpc-reply', fname)
        foo = open(fpath).read()

        if (fname == 'get-rpc-error.xml' or
                fname == 'get-index-error.xml' or
                fname == 'get-system-core-dumps.xml'):
            rpc_reply = NCElement(foo, self.dev._conn._device_handler
                                  .transform_reply())
        elif (fname == 'show-configuration.xml' or
              fname == 'show-system-alarms.xml'):
            rpc_reply = NCElement(foo, self.dev._conn._device_handler
                                  .transform_reply())._NCElement__doc
        else:
            rpc_reply = NCElement(foo, self.dev._conn._device_handler
                                  .transform_reply())._NCElement__doc[0]
        return rpc_reply

    def _mock_manager(self, *args, **kwargs):
        if kwargs:
            # if 'path' in kwargs and 'detail' in kwargs:
            #     return self._read_file('dir_list_detail.xml')

            if 'path' in kwargs:
                if kwargs['path'] == 'test/stat/decode_dir':
                    return self._read_file('file-list_dir.xml')
                elif kwargs['path'] == 'test/stat/decode_file':
                    return self._read_file('file-list_file.xml')
                elif kwargs['path'] == 'test/checksum':
                    return self._read_file('checksum.xml')
                elif kwargs['path'] == 'test/stat/decode_symbolic_link':
                    return self._read_file('file-list_symlink.xml')
            if 'filename' in kwargs:
                if kwargs['filename'] == 'test/cat.txt':
                    return self._read_file('file-show.xml')
            device_params = kwargs['device_params']
            device_handler = make_device_handler(device_params)
            session = SSHSession(device_handler)
            return Manager(session, device_handler)

        elif args:
            if args[0].tag == 'command':
                if args[0].text == 'show cli directory':
                    return self._read_file('show-cli-directory.xml')
            elif args[0].tag == 'get-system-storage':
                return self._read_file('get-system-storage.xml')
            elif args[0].tag == 'request-system-storage-cleanup':
                return self._read_file('request-system-storage-cleanup.xml')
            elif args[0].tag == 'file-archive':
                return self._read_file('file-archive.xml')

########NEW FILE########
__FILENAME__ = test_scp
__author__ = "Rick Sherman"
__credits__ = "Jeremy Schulman, Nitin Kumar"

import unittest
from nose.plugins.attrib import attr

from jnpr.junos import Device
from jnpr.junos.utils.scp import SCP

from mock import patch


@attr('unit')
class TestScp(unittest.TestCase):
    def setUp(self):
        self.dev = Device(host='1.1.1.1')

    @patch('paramiko.SSHClient')
    def test_scp_open(self, mock_connect):
        from scp import SCPClient
        self.dev.bind(scp=SCP)
        assert isinstance(self.dev.scp.open(), SCPClient)

    @patch('paramiko.SSHClient')
    def test_scp_close(self, mock_connect):
        self.dev.bind(scp=SCP)
        self.dev.scp.open()
        self.assertEqual(self.dev.scp.close(), None)

    @patch('paramiko.SSHClient')
    def test_scp_context(self, mock_connect):
        with SCP(self.dev) as scp:
            scp.get('addrbook.conf')

########NEW FILE########
__FILENAME__ = test_start_shell
__author__ = "Rick Sherman"
__credits__ = "Jeremy Schulman, Nitin Kumar"

import unittest
from nose.plugins.attrib import attr

from jnpr.junos import Device
from jnpr.junos.utils.start_shell import StartShell

from mock import patch, MagicMock, call


@attr('unit')
class TestStartShell(unittest.TestCase):
    @patch('paramiko.SSHClient')
    def setUp(self, mock_connect):
        self.dev = Device(host='1.1.1.1')
        self.shell = StartShell(self.dev)

    @patch('paramiko.SSHClient')
    @patch('jnpr.junos.utils.start_shell.StartShell.wait_for')
    def test_startshell_open(self, mock_connect, mock_wait):
        self.shell.open()
        mock_connect.assert_called_with('% ')

    @patch('paramiko.SSHClient')
    def test_startshell_close(self, mock_connect):
        self.shell._chan = MagicMock()
        self.shell._client = MagicMock()
        self.shell.close()
        self.shell._client.close.assert_called_once()

    @patch('jnpr.junos.utils.start_shell.StartShell.wait_for')
    def test_startshell_run(self, mock_wait):
        self.shell._chan = MagicMock()
        self.shell.run('ls')
        self.assertTrue(call.send('echo $?') in self.shell._chan.mock_calls)

    @patch('jnpr.junos.utils.start_shell.select')
    def test_startshell_wait_for(self, mock_select):
        mock_select.return_value = ['> ', 2, 3]
        self.shell._chan = MagicMock()
        self.assertTrue(call.endswith('> ') in self.shell.wait_for('> ')[0].mock_calls)

    @patch('jnpr.junos.utils.start_shell.StartShell.open')
    @patch('jnpr.junos.utils.start_shell.StartShell.close')
    def test_startshell_context(self, mock_open, mock_close):
        with StartShell(self.dev) as shell:
            shell._chan = MagicMock()
            shell.send('test')
            mock_close.assert_called_once(call())

########NEW FILE########
__FILENAME__ = test_sw
__author__ = "Nitin Kumar, Rick Sherman"
__credits__ = "Jeremy Schulman"

import unittest
from nose.plugins.attrib import attr

import os
import sys
from cStringIO import StringIO
from contextlib import contextmanager

from jnpr.junos import Device
from jnpr.junos.exception import RpcError
from jnpr.junos.utils.sw import SW
from jnpr.junos.facts.swver import version_info
from ncclient.manager import Manager, make_device_handler
from ncclient.transport import SSHSession

from jnpr.junos.exception import RpcError
from lxml import etree

from mock import patch, MagicMock, call, mock_open


facts = {'domain': None, 'hostname': 'firefly', 'ifd_style': 'CLASSIC',
         'version_info': version_info('12.1X46-D15.3'),
         '2RE': False, 'serialnumber': 'aaf5fe5f9b88', 'fqdn': 'firefly',
         'virtual': True, 'switch_style': 'NONE', 'version': '12.1X46-D15.3',
         'HOME': '/cf/var/home/rick', 'srx_cluster': False,
         'model': 'FIREFLY-PERIMETER',
         'RE0': {'status': 'Testing',
                 'last_reboot_reason': 'Router rebooted after a '
                 'normal shutdown.',
                 'model': 'FIREFLY-PERIMETER RE',
                 'up_time': '6 hours, 29 minutes, 30 seconds'},
         'vc_capable': False, 'personality': 'SRX_BRANCH'}


@attr('unit')
class TestSW(unittest.TestCase):

    @patch('ncclient.manager.connect')
    def setUp(self, mock_connect):
        mock_connect.side_effect = self._mock_manager
        self.dev = Device(host='1.1.1.1', user='rick', password='password123',
                          gather_facts=False)
        self.dev.open()
        self.dev._facts = facts
        self.sw = self.get_sw()

    @patch('jnpr.junos.Device.execute')
    def get_sw(self, mock_execute):
        mock_execute.side_effect = self._mock_manager
        return SW(self.dev)

    @patch('ncclient.operations.session.CloseSession.request')
    def tearDown(self, mock_session):
        self.dev.close()

    def test_sw_hashfile(self):
        with patch('__builtin__.open', mock_open(), create=True) as m:
            import jnpr.junos.utils.sw
            with open('foo') as h:
                h.read.side_effect = ('abc', 'a', '')
                jnpr.junos.utils.sw._hashfile(h, MagicMock())
                self.assertEqual(h.read.call_count, 3)

    @patch('jnpr.junos.Device.execute')
    def test_sw_constructor_multi_re(self, mock_execute):
        mock_execute.side_effect = self._mock_manager
        self.sw = SW(self.dev)
        self.assertFalse(self.sw._multi_RE)

    @patch('jnpr.junos.Device.execute')
    def test_sw_constructor_multi_vc(self, mock_execute):
        mock_execute.side_effect = self._mock_manager
        self.sw = SW(self.dev)
        self.assertFalse(self.sw._multi_VC)

    @patch('__builtin__.open')
    def test_sw_local_sha256(self, mock_built_open):
        package = 'test.tgz'
        self.assertEqual(SW.local_sha256(package),
                         'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934'
                         'ca495991b7852b855')

    @patch('__builtin__.open')
    def test_sw_local_md5(self, mock_built_open):
        package = 'test.tgz'
        self.assertEqual(SW.local_md5(package),
                         'd41d8cd98f00b204e9800998ecf8427e')

    @patch('__builtin__.open')
    def test_sw_local_sha1(self, mock_built_open):
        package = 'test.tgz'
        self.assertEqual(SW.local_sha1(package),
                         'da39a3ee5e6b4b0d3255bfef95601890afd80709')

    def test_sw_progress(self):
        with self.capture(SW.progress, self.dev, 'running') as output:
            self.assertEqual('1.1.1.1: running\n', output)

    @patch('paramiko.SSHClient')
    @patch('scp.SCPClient.put')
    def test_sw_put(self, mock_scp_put, mock_scp):
        #mock_scp_put.side_effect = self.mock_put
        package = 'test.tgz'
        self.sw.put(package)
        self.assertTrue(call('test.tgz', '/var/tmp') in mock_scp_put.mock_calls)

    @patch('jnpr.junos.utils.scp.SCP.__exit__')
    @patch('jnpr.junos.utils.scp.SCP.__init__')
    @patch('jnpr.junos.utils.scp.SCP.__enter__')
    def test_sw_put_progress(self, mock_enter, mock_scp, mock_exit):
        package = 'test.tgz'
        mock_scp.side_effect = self._fake_scp
        self.sw.put(package, progress=self._myprogress)
        self.assertEqual(mock_scp.call_args_list[0][1]['progress'].by10pct, 50)

    def _fake_scp(self, *args, **kwargs):
        progress = kwargs['progress']
        progress('test.tgz', 100, 50)

    @patch('jnpr.junos.Device.execute')
    def test_sw_pkgadd(self, mock_execute):
        mock_execute.side_effect = self._mock_manager
        package = 'test.tgz'
        self.assertTrue(self.sw.pkgadd(package))

    @patch('jnpr.junos.Device.execute')
    def test_sw_validate(self, mock_execute):
        mock_execute.side_effect = self._mock_manager
        package = 'package.tgz'
        self.assertTrue(self.sw.validate(package))

    @patch('jnpr.junos.Device.execute')
    def test_sw_safe_copy(self, mock_execute):
        mock_execute.side_effect = self._mock_manager
        package = 'safecopy.tgz'
        self.sw.put = MagicMock()
        SW.local_md5 = MagicMock()

        self.assertTrue(self.sw.safe_copy(package, progress=self._myprogress, cleanfs=True,
                                          checksum='96a35ab371e1ca10408c3caecdbd8a67'))

    @patch('jnpr.junos.Device.execute')
    def test_sw_safe_copy_return_false(self, mock_execute):
        # not passing checksum value, will get random from magicmock
        mock_execute.side_effect = self._mock_manager
        package = 'safecopy.tgz'
        self.sw.put = MagicMock()
        SW.local_md5 = MagicMock()

        self.assertFalse(self.sw.safe_copy(package, progress=self._myprogress,
                                           cleanfs=True))
        SW.local_md5.assert_called_with(package)

    @patch('jnpr.junos.Device.execute')
    def test_sw_safe_copy_checksum_none(self, mock_execute):
        mock_execute.side_effect = self._mock_manager
        package = 'safecopy.tgz'
        self.sw.put = MagicMock()
        SW.local_md5 = MagicMock(return_value='96a35ab371e1ca10408c3caecdbd8a67')

        self.assertTrue(self.sw.safe_copy(package, progress=self._myprogress,
                                          cleanfs=True))

    @patch('jnpr.junos.Device.execute')
    def test_sw_safe_install(self, mock_execute):
        mock_execute.side_effect = self._mock_manager
        package = 'install.tgz'
        self.sw.put = MagicMock()
        SW.local_md5 = MagicMock(return_value='96a35ab371e1ca10408c3caecdbd8a67')
        self.assertTrue(self.sw.install(package, progress=self._myprogress,
                                        cleanfs=True))

    @patch('jnpr.junos.utils.sw.SW.safe_copy')
    def test_sw_safe_install_copy_fail(self, mock_copy):
        mock_copy.return_value = False
        self.assertFalse(self.sw.install('file'))

    @patch('jnpr.junos.utils.sw.SW.validate')
    def test_sw_install_validate(self, mock_validate):
        mock_validate.return_value = False
        self.assertFalse(self.sw.install('file', validate=True, no_copy=True))

    @patch('jnpr.junos.utils.sw.SW.pkgadd')
    def test_sw_install_multi_mx(self, mock_pkgadd):
        mock_pkgadd.return_value = True
        self.sw._multi_RE = True
        self.sw._multi_MX = True
        self.assertTrue(self.sw.install('file', no_copy=True))

    @patch('jnpr.junos.utils.sw.SW.pkgadd')
    def test_sw_install_multi_vc(self, mock_pkgadd):
        mock_pkgadd.return_value = True
        self.sw._multi_RE = True
        self.sw._multi_VC = True
        self.sw._RE_list = ('version_RE0', 'version_RE1')
        self.assertTrue(self.sw.install('file', no_copy=True))

    @patch('jnpr.junos.Device.execute')
    def test_sw_rollback(self, mock_execute):
        # we need proper xml for this test case, update request-package-roll
        # back.xml
        mock_execute.side_effect = self._mock_manager
        self.assertEqual(self.sw.rollback(), '')

    def test_sw_inventory(self):
        self.sw.dev.rpc.file_list = \
            MagicMock(side_effect=self._mock_manager)
        self.assertEqual(self.sw.inventory,
                             {'current': None, 'rollback': None})

    @patch('jnpr.junos.Device.execute')
    def test_sw_reboot(self, mock_execute):
        mock_execute.side_effect = self._mock_manager
        self.sw._multi_MX = True
        self.assertTrue('Shutdown NOW' in self.sw.reboot())

    @patch('jnpr.junos.Device.execute')
    def test_sw_reboot_exception(self, mock_execute):
        rsp = etree.XML('<rpc-reply><a>test</a></rpc-reply>')
        mock_execute.side_effect = RpcError(rsp=rsp)
        self.assertRaises(Exception, self.sw.reboot)

    @patch('jnpr.junos.Device.execute')
    def test_sw_poweroff(self, mock_execute):
        mock_execute.side_effect = self._mock_manager
        self.sw._multi_MX = True
        self.assertTrue('Shutdown NOW' in self.sw.poweroff())

    @patch('jnpr.junos.Device.execute')
    def test_sw_poweroff_exception(self, mock_execute):
        rsp = etree.XML('<rpc-reply><a>test</a></rpc-reply>')
        mock_execute.side_effect = RpcError(rsp=rsp)
        self.assertRaises(Exception, self.sw.poweroff)

    def _myprogress(self, dev, report):
        pass

    @contextmanager
    def capture(self, command, *args, **kwargs):
        out, sys.stdout = sys.stdout, StringIO()
        command(*args, **kwargs)
        sys.stdout.seek(0)
        yield sys.stdout.read()
        sys.stdout = out

    def _read_file(self, fname):
        from ncclient.xml_ import NCElement

        fpath = os.path.join(os.path.dirname(__file__),
                             'rpc-reply', fname)
        foo = open(fpath).read()
        rpc_reply = NCElement(foo, self.dev._conn._device_handler.transform_reply())._NCElement__doc[0]
        return rpc_reply

    def _mock_manager(self, *args, **kwargs):
        if kwargs:
            if 'path' in kwargs:
                if kwargs['path'] == '/packages':
                    return self._read_file('file-list_dir.xml')
            device_params = kwargs['device_params']
            device_handler = make_device_handler(device_params)
            session = SSHSession(device_handler)
            return Manager(session, device_handler)

        elif args:
            return self._read_file(args[0].tag + '.xml')

########NEW FILE########
__FILENAME__ = test_util
__author__ = "Nitin Kumar, Rick Sherman"
__credits__ = "Jeremy Schulman"

import unittest
from nose.plugins.attrib import attr

from jnpr.junos import Device
from jnpr.junos.utils.util import Util

from mock import patch


@attr('unit')
class TestUtil(unittest.TestCase):

    @patch('ncclient.manager.connect')
    def setUp(self, mock_connect):
        self.dev = Device(host='1.1.1.1', user='nitin', password='password123',
                          gather_facts=False)
        self.dev.open()
        self.util = Util(self.dev)

    def test_repr(self):
        self.assertEqual(repr(self.util), 'jnpr.junos.utils.Util(1.1.1.1)')

    def test_dev_setter_exception(self):
        def mod_dev():
            self.util.dev = 'abc'
        self.assertRaises(RuntimeError, mod_dev)

    def test_rpc_setter_exception(self):
        def mod_rpc():
            self.util.rpc = 'abc'
        self.assertRaises(RuntimeError, mod_rpc)

########NEW FILE########
