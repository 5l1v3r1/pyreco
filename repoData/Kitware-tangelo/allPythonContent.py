__FILENAME__ = conf
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Tangelo Web Framework documentation build configuration file, created by
# sphinx-quickstart on Thu Apr 11 11:42:23 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os
#import sphinx_bootstrap_theme

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.todo', 'sphinx.ext.coverage', 'sphinx.ext.mathjax', 'sphinx.ext.ifconfig', 'sphinx.ext.viewcode', 'sphinx.ext.extlinks']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = 'Tangelo Web Framework'
copyright = '2013, Kitware, Inc.'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# These are set to None here, but this is overridden in CMakeLists.txt via -D
# flags to set them explicitly using a variable defined there.
#
# The short X.Y version.
version = None
# The full version, including alpha/beta/rc tags.
release = None

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

# Define an external link to refer to the base Tangelo installation - this is
# the actual installation if the docs are built locally, or the default location
# of localhost, port 80, for the documentation built on readthedocs.
import os
on_rtd = os.environ.get("READTHEDOCS", None) is not None
extlinks = {"root": ("http://localhost:8080%s" if on_rtd else "%s", None)}

# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
#html_theme = 'pyramid'
#html_theme = 'bootstrap'
#html_theme_path = sphinx_bootstrap_theme.get_html_theme_path()

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {
#	'bootswatch_theme': "readable"
#}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
html_favicon = "tangelo.ico"

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
html_domain_indices = False

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# Show "todo" notes.
todo_include_todos = False

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'TangeloWebFrameworkdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'TangeloWebFramework.tex', 'Tangelo Web Framework Documentation',
   'Kitware, Inc.', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'tangelowebframework', 'Tangelo Web Framework Documentation',
     ['Kitware, Inc.'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'TangeloWebFramework', 'Tangelo Web Framework Documentation',
   'Kitware, Inc.', 'TangeloWebFramework', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = vtkweb-launcher
#!python

r"""
    This module is a VTK Web server application.
    The following command line illustrate how to use it::

        $ vtkpython .../vtk_web_tree.py

    Any VTK Web executable script come with a set of standard arguments that
    can be overriden if need be::

        --port 8080
             Port number on which the HTTP server will listen to.

        --content /path-to-web-content/
             Directory that you want to server as static web content.  By
             default, this variable is empty which mean that we rely on another
             server to deliver the static content and the current process only
             focus on the WebSocket connectivity of clients.

        --authKey vtk-secret
             Secret key that should be provided by the client to allow it to
             make any WebSocket communication. The client will assume if none
             is given that the server expect "vtk-secret" as secret key.
"""

import imp

# import to process args
import sys
import os

# import vtk modules.
from vtk.web import server, wamp, protocols

# import annotations
from autobahn.wamp import exportRpc

try:
    import argparse
except ImportError:
    # since  Python 2.6 and earlier don't have argparse, we simply provide
    # the source for the same as _argparse and we use it instead.
    import _argparse as argparse

# =============================================================================
# Create custom File Opener class to handle clients requests
# =============================================================================


def VTKWebAppProtocol(args, usermod):
    class VTKWebApp(wamp.ServerProtocol):
        # Application configuration
        view = None
        authKey = "vtkweb-secret"

        def __init__(self):
            # Because the ServerProtocol constructor directly calls
            # initialize(), be sure to set these instance properties FIRST.
            self.args = args
            self.app = usermod

            wamp.ServerProtocol.__init__(self)

        def initialize(self):
            # Bring used components
            self.registerVtkWebProtocol(protocols.vtkWebMouseHandler())
            self.registerVtkWebProtocol(protocols.vtkWebViewPort())
            self.registerVtkWebProtocol(
                protocols.vtkWebViewPortImageDelivery())
            self.registerVtkWebProtocol(
                protocols.vtkWebViewPortGeometryDelivery())

            # Update authentication key to use
            self.updateSecret(VTKWebApp.authKey)

            if "initialize" in self.app.__dict__:
                self.app.initialize(self, VTKWebApp, self.args)

    return VTKWebApp

# =============================================================================
# Main: Parse args and start server
# =============================================================================

if __name__ == "__main__":
    # Get the full path to the user's application file.
    if len(sys.argv) < 2:
        print >>sys.stderr, ("usage: vtkweb-launcher.py " +
                             "[tangelo-vtkweb-app] [arg1, arg2, arg3, ...]")
        sys.exit(1)
    userfile = sys.argv[1]

    # Import the user file as a module.
    try:
        usermod = imp.load_source("usermod", userfile)
    except IOError:
        print >>sys.stderr, "error: could not open file '%s'" % (userfile)
        sys.exit(2)
    except ImportError as e:
        print >>sys.stderr, "error: could not import module '%s'" % (userfile)
        print >>sys.stderr, "({})".format(e)
        sys.exit(2)

    # Create argument parser
    parser = argparse.ArgumentParser(description="Tangelo/VTKWeb application")

    # Add default arguments
    server.add_arguments(parser)

    # Add local arguments, if any are specified in the user module.
    if "add_arguments" in usermod.__dict__:
        usermod.add_arguments(parser)

    # Extract arguments (dropping the "usermodule" argument first).
    del sys.argv[1]
    args = parser.parse_args()

    # Configure our current application
    VTKWebApp = VTKWebAppProtocol(args, usermod)
    VTKWebApp.authKey = args.authKey

    # Start server
    server.start_webserver(options=args, protocol=VTKWebApp)

########NEW FILE########
__FILENAME__ = get-flickr-data
#!python

# To reproduce the 'flickr_paris_1000.json' file, run this script as follows:
#
#     get-flickr-data.py <your-api-key> 1000 >flickr_paris_1000.json
#
# This will retrieve 1000 photos bounded to the Paris area, taken between the
# dates indicated in the "data" dict below, and save them as a JSON array.
#
# To upload these entries to a Mongo database, use the following command (after
# setting up and launching a Mongo instance):
#
#     mongoimport -d tangelo -c flickr_paris --jsonArray --file flickr_paris_1000.json
#
# This will store the 1000 photo entries in a collection called "flickr_paris",
# in a database named "tangelo".  This is the default location the flickr
# example application will look for data.

import datetime
import json
import sys
import urllib

# Construct a JSON representation of a Javascript date (which uses
# *milli*seconds since the epoch, rather than seconds).
def get_javascript_date(datestring):
    date = datetime.datetime.strptime(datestring, "%Y-%m-%d %H:%M:%S")
    return {"$date": int(date.strftime("%s")) * 1000}


# Find tokens in the given text beginning with a hashmark.
def extract_hashtags(text):
    return [token[1:] for token in text.split() if len(token) > 1 and token[0] == "#"]


# Send a flickr API request, then strip off the JSONP container from the result,
# and parse the remainder as a JSON object.
def get_photos(url, data):
    req = urllib.urlopen(url, urllib.urlencode(data))
    result = req.read()
    return json.loads(result[len("jsonFlickrApi("):-1])["photos"]


# This program uses a flickr API key to find photos taken in Paris between July
# 30, 2012, and October 6, 2012.
def main():
    if len(sys.argv) < 2:
        print >>sys.stderr, "usage: getflickr.py <api_key> [<max_photos>]"
        sys.exit(1)

    api_key = sys.argv[1]
    url = "http://api.flickr.com/services/rest"
    data = {"method": "flickr.photos.search",
            "api_key": api_key,
            "format": "json",
            "min_taken_date": "1343611866",
            "max_taken_date": "1349545963",
            "bbox": "2.26,48.8,2.4,48.9",
            "per_page": "250",
            "extras": "geo,url_z,date_taken"}

    # Get the initial page of results, which will specify how many total extra
    # pages there are.
    sys.stderr.write("reading initial page...")
    sys.stderr.flush()
    result = get_photos(url, data)
    print >>sys.stderr, "done"

    pages = result["pages"]
    photos = result["photo"]

    if len(sys.argv) > 2:
        try:
            max_photos = int(sys.argv[2])
        except ValueError:
            print >>sys.stderr, "error: <max_photos> argument must be an int, was %s" % (sys.argv[2])
            sys.exit(1)

        if max_photos < 250:
            data["per_page"] = str(max_photos)

        sys.stderr.write("Retrieving a maximum of %d photo%s " % (max_photos, "" if max_photos == 1 else "s"))
    else:
        max_photos = int(result["total"])
        sys.stderr.write("Retrieving all photos (%d) " % (max_photos))
    print >>sys.stderr, "from %d page%s of results" % (pages, "" if pages == 1 else "s")

    if len(photos) > max_photos:
        photos = photos[:max_photos]
    else:
        # Retrieve the remaining pagefuls of results.
        class Done: pass
        try:
            for page in xrange(2, pages+1):
                data["page"] = page

                sys.stderr.write("reading page %d..." % (page))
                sys.stderr.flush()
                result = get_photos(url, data)
                print >>sys.stderr, "done"

                if len(photos) + len(result["photo"]) >= max_photos:
                    photos += result["photo"][:(max_photos - len(photos))]
                    raise Done()
                else:
                    photos += result["photo"]
        except Done:
            pass

    # These properties are to be struck from the JSON records after prep is
    # complete.
    strike = ["context",
              "server",
              "longitude",
              "latitude",
              "ispublic",
              "geo_is_family",
              "geo_is_contact",
              "geo_is_friend",
              "woeid",
              "id",
              "place_id",
              "geo_is_public",
              "isfriend",
              "secret",
              "accuracy",
              "isfamily",
              "farm",
              "url_z",
              "height_z",
              "width_z",
              "datetakengranularity"]
                
    # Perform a bit of processing: gather the long/lat values into a single
    # field (for use by Mongo indices, etc.); copy the "z" url into a simpler
    # named field; process the date and hashtags out of the appropriate strings.
    for p in photos:
        p["location"] = [p["longitude"], p["latitude"]]
        p["url"] = p["url_z"] if "url_z" in p else None
        p["datetaken"] = get_javascript_date(p["datetaken"])
        p["hashtags"] = extract_hashtags(p["title"])

        for s in strike:
            if s in p:
                del p[s]

    # Dump the JSON to stdout.
    print json.dumps(photos)


if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = flashpolicy
###############################################################################
##
##  Copyright 2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

__all__ = ("FlashPolicyProtocol", "FlashPolicyFactory",)


import re

from twisted.python import log
from twisted.internet import reactor
from twisted.application.internet import TCPServer
from twisted.internet.protocol import Protocol, Factory


class FlashPolicyProtocol(Protocol):
   """
   Flash Player 9 (version 9.0.124.0 and above) implements a strict new access
   policy for Flash applications that make Socket or XMLSocket connections to
   a remote host. It now requires the presence of a socket policy file
   on the server.

   We want this to support the Flash WebSockets bridge which is needed for
   older browser, in particular MSIE9/8.

   See:
      * `Autobahn WebSocket fallbacks example <https://github.com/tavendo/AutobahnPython/tree/master/examples/websocket/echo_wsfallbacks>`_
      * `Flash policy files background <http://www.lightsphere.com/dev/articles/flash_socket_policy.html>`_
   """

   REQUESTPAT = re.compile("^\s*<policy-file-request\s*/>")
   REQUESTMAXLEN = 200
   REQUESTTIMEOUT = 5
   POLICYFILE = """<?xml version="1.0"?><cross-domain-policy><allow-access-from domain="*" to-ports="%d" /></cross-domain-policy>"""

   def __init__(self, allowedPort):
      """
      Ctor.

      :param allowedPort: The port to which Flash player should be allowed to connect.
      :type allowedPort: int
      """
      self.allowedPort = allowedPort
      self.received = ""
      self.dropConnection = None


   def connectionMade(self):
      ## DoS protection
      ##
      def dropConnection():
         self.transport.abortConnection()
         self.dropConnection = None
      self.dropConnection = reactor.callLater(FlashPolicyProtocol.REQUESTTIMEOUT, dropConnection)


   def connectionLost(self, reason):
      if self.dropConnection:
         self.dropConnection.cancel()
         self.dropConnection = None


   def dataReceived(self, data):
      self.received += data
      if FlashPolicyProtocol.REQUESTPAT.match(self.received):
         ## got valid request: send policy file
         ##
         self.transport.write(FlashPolicyProtocol.POLICYFILE % self.allowedPort)
         self.transport.loseConnection()
      elif len(self.received) > FlashPolicyProtocol.REQUESTMAXLEN:
         ## possible DoS attack
         ##
         self.transport.abortConnection()
      else:
         ## need more data
         ##
         pass


class FlashPolicyFactory(Factory):

   def __init__(self, allowedPort):
      """
      Ctor.

      :param allowedPort: The port to which Flash player should be allowed to connect.
      :type allowedPort: int
      """
      self.allowedPort = allowedPort

   def buildProtocol(self, addr):
      return FlashPolicyProtocol(self.allowedPort)

########NEW FILE########
__FILENAME__ = httpstatus
###############################################################################
##
##  Copyright 201-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

##
## HTTP Status Codes
##
## Source: http://en.wikipedia.org/wiki/List_of_HTTP_status_codes
## Adapted on 2011/10/11
##

##
## 1xx Informational
##
## Request received, continuing process.
##
## This class of status code indicates a provisional response, consisting only of
## the Status-Line and optional headers, and is terminated by an empty line.
## Since HTTP/1.0 did not define any 1xx status codes, servers must not send
## a 1xx response to an HTTP/1.0 client except under experimental conditions.
##

HTTP_STATUS_CODE_CONTINUE                 = (100, "Continue",
                                             "This means that the server has received the request headers, and that the client should proceed to send the request body (in the case of a request for which a body needs to be sent; for example, a POST request). If the request body is large, sending it to a server when a request has already been rejected based upon inappropriate headers is inefficient. To have a server check if the request could be accepted based on the request's headers alone, a client must send Expect: 100-continue as a header in its initial request[2] and check if a 100 Continue status code is received in response before continuing (or receive 417 Expectation Failed and not continue).")

HTTP_STATUS_CODE_SWITCHING_PROTOCOLS      = (101, "Switching Protocols",
                                             "This means the requester has asked the server to switch protocols and the server is acknowledging that it will do so.")

HTTP_STATUS_CODE_PROCESSING               = (102, "Processing (WebDAV) (RFC 2518)",
                                             "As a WebDAV request may contain many sub-requests involving file operations, it may take a long time to complete the request. This code indicates that the server has received and is processing the request, but no response is available yet.[3] This prevents the client from timing out and assuming the request was lost.")

HTTP_STATUS_CODE_CHECKPOINT               = (103, "Checkpoint",
                                             "This code is used in the Resumable HTTP Requests Proposal to resume aborted PUT or POST requests.")

HTTP_STATUS_CODE_REQUEST_URI_TOO_LONG     = (122, "Request-URI too long",
                                             "This is a non-standard IE7-only code which means the URI is longer than a maximum of 2083 characters.[5][6] (See code 414.)")

##
## 2xx Success
##
## This class of status codes indicates the action requested by the client was
## received, understood, accepted and processed successfully.
##

HTTP_STATUS_CODE_OK                       = (200, "OK",
                                             "Standard response for successful HTTP requests. The actual response will depend on the request method used. In a GET request, the response will contain an entity corresponding to the requested resource. In a POST request the response will contain an entity describing or containing the result of the action.")

HTTP_STATUS_CODE_CREATED                  = (201, "Created",
                                             "The request has been fulfilled and resulted in a new resource being created.")

HTTP_STATUS_CODE_ACCEPTED                 = (202, "Accepted",
                                             "The request has been accepted for processing, but the processing has not been completed. The request might or might not eventually be acted upon, as it might be disallowed when processing actually takes place.")

HTTP_STATUS_CODE_NON_AUTHORATIVE          = (203, "Non-Authoritative Information (since HTTP/1.1)",
                                             "The server successfully processed the request, but is returning information that may be from another source.")

HTTP_STATUS_CODE_NO_CONTENT               = (204, "No Content",
                                             "The server successfully processed the request, but is not returning any content.")

HTTP_STATUS_CODE_RESET_CONTENT            = (205, "Reset Content",
                                             "The server successfully processed the request, but is not returning any content. Unlike a 204 response, this response requires that the requester reset the document view.")

HTTP_STATUS_CODE_PARTIAL_CONTENT          = (206, "Partial Content",
                                             "The server is delivering only part of the resource due to a range header sent by the client. The range header is used by tools like wget to enable resuming of interrupted downloads, or split a download into multiple simultaneous streams.")

HTTP_STATUS_CODE_MULTI_STATUS             = (207, "Multi-Status (WebDAV) (RFC 4918)",
                                             "The message body that follows is an XML message and can contain a number of separate response codes, depending on how many sub-requests were made.")

HTTP_STATUS_CODE_IM_USED                  = (226, "IM Used (RFC 3229)",
                                             "The server has fulfilled a GET request for the resource, and the response is a representation of the result of one or more instance-manipulations applied to the current instance.")

##
## 3xx Redirection
##
## The client must take additional action to complete the request.
##
## This class of status code indicates that further action needs to be taken
## by the user agent in order to fulfil the request. The action required may
## be carried out by the user agent without interaction with the user if and
## only if the method used in the second request is GET or HEAD. A user agent
## should not automatically redirect a request more than five times, since such
## redirections usually indicate an infinite loop.
##

HTTP_STATUS_CODE_MULTIPLE_CHOICES         = (300, "Multiple Choices",
                                             "Indicates multiple options for the resource that the client may follow. It, for instance, could be used to present different format options for video, list files with different extensions, or word sense disambiguation.")

HTTP_STATUS_CODE_MOVED_PERMANENTLY        = (301, "Moved Permanently",
                                             "This and all future requests should be directed to the given URI.")

HTTP_STATUS_CODE_FOUND                    = (302, "Found",
                                             "This is an example of industrial practice contradicting the standard. HTTP/1.0 specification (RFC 1945) required the client to perform a temporary redirect (the original describing phrase was 'Moved Temporarily', but popular browsers implemented 302 with the functionality of a 303 See Other. Therefore, HTTP/1.1 added status codes 303 and 307 to distinguish between the two behaviours. However, some Web applications and frameworks use the 302 status code as if it were the 303.")

HTTP_STATUS_CODE_SEE_OTHER                = (303, "See Other (since HTTP/1.1)",
                                             "The response to the request can be found under another URI using a GET method. When received in response to a POST (or PUT/DELETE), it should be assumed that the server has received the data and the redirect should be issued with a separate GET message.")

HTTP_STATUS_CODE_NOT_MODIFIED             = (304, "Not Modified",
                                             "Indicates the resource has not been modified since last requested.[2] Typically, the HTTP client provides a header like the If-Modified-Since header to provide a time against which to compare. Using this saves bandwidth and reprocessing on both the server and client, as only the header data must be sent and received in comparison to the entirety of the page being re-processed by the server, then sent again using more bandwidth of the server and client.")

HTTP_STATUS_CODE_USE_PROXY                = (305, "Use Proxy (since HTTP/1.1)",
                                             "Many HTTP clients (such as Mozilla[11] and Internet Explorer) do not correctly handle responses with this status code, primarily for security reasons.")

HTTP_STATUS_CODE_SWITCH_PROXY             = (306, "Switch Proxy",
                                             "No longer used. Originally meant 'Subsequent requests should use the specified proxy'.")

HTTP_STATUS_CODE_TEMPORARY_REDIRECT       = (307, "Temporary Redirect (since HTTP/1.1)",
                                             "In this occasion, the request should be repeated with another URI, but future requests can still use the original URI.[2] In contrast to 303, the request method should not be changed when reissuing the original request. For instance, a POST request must be repeated using another POST request.")

HTTP_STATUS_CODE_RESUME_INCOMPLETE        = (308, "Resume Incomplete",
                                             "This code is used in the Resumable HTTP Requests Proposal to resume aborted PUT or POST requests.")

##
## 4xx Client Error
##
## The 4xx class of status code is intended for cases in which the client
## seems to have erred. Except when responding to a HEAD request, the server
## should include an entity containing an explanation of the error situation,
## and whether it is a temporary or permanent condition. These status codes are
## applicable to any request method. User agents should display any included
## entity to the user. These are typically the most common error codes
## encountered while online.
##

HTTP_STATUS_CODE_BAD_REQUEST              = (400, "Bad Request",
                                             "The request cannot be fulfilled due to bad syntax.")

HTTP_STATUS_CODE_UNAUTHORIZED             = (401, "Unauthorized",
                                             "Similar to 403 Forbidden, but specifically for use when authentication is possible but has failed or not yet been provided.[2] The response must include a WWW-Authenticate header field containing a challenge applicable to the requested resource. See Basic access authentication and Digest access authentication.")

HTTP_STATUS_CODE_PAYMENT_REQUIRED         = (402, "Payment Required",
                                             "Reserved for future use.[2] The original intention was that this code might be used as part of some form of digital cash or micropayment scheme, but that has not happened, and this code is not usually used. As an example of its use, however, Apple's MobileMe service generates a 402 error if the MobileMe account is delinquent.")

HTTP_STATUS_CODE_FORBIDDEN                = (403, "Forbidden",
                                             "The request was a legal request, but the server is refusing to respond to it.[2] Unlike a 401 Unauthorized response, authenticating will make no difference.[2]")

HTTP_STATUS_CODE_NOT_FOUND                = (404, "Not Found",
                                             "The requested resource could not be found but may be available again in the future.[2] Subsequent requests by the client are permissible.")

HTTP_STATUS_CODE_METHOD_NOT_ALLOWED       = (405, "Method Not Allowed",
                                             "A request was made of a resource using a request method not supported by that resource;[2] for example, using GET on a form which requires data to be presented via POST, or using PUT on a read-only resource.")

HTTP_STATUS_CODE_NOT_ACCEPTABLE           = (406, "Not Acceptable",
                                             "The requested resource is only capable of generating content not acceptable according to the Accept headers sent in the request.")

HTTP_STATUS_CODE_PROXY_AUTH_REQUIRED      = (407, "Proxy Authentication Required",
                                             "The client must first authenticate itself with the proxy.")

HTTP_STATUS_CODE_REQUEST_TIMEOUT          = (408, "Request Timeout",
                                             "The server timed out waiting for the request. According to W3 HTTP specifications: 'The client did not produce a request within the time that the server was prepared to wait. The client MAY repeat the request without modifications at any later time.'")

HTTP_STATUS_CODE_CONFLICT                 = (409, "Conflict",
                                             "Indicates that the request could not be processed because of conflict in the request, such as an edit conflict.")

HTTP_STATUS_CODE_GONE                     = (410, "Gone",
                                             "Indicates that the resource requested is no longer available and will not be available again.[2] This should be used when a resource has been intentionally removed and the resource should be purged. Upon receiving a 410 status code, the client should not request the resource again in the future. Clients such as search engines should remove the resource from their indices. Most use cases do not require clients and search engines to purge the resource, and a '404 Not Found' may be used instead.")

HTTP_STATUS_CODE_LENGTH_REQUIRED          = (411, "Length Required",
                                             "The request did not specify the length of its content, which is required by the requested resource.")

HTTP_STATUS_CODE_PRECONDITION_FAILED      = (412, "Precondition Failed",
                                             "The server does not meet one of the preconditions that the requester put on the request.")

HTTP_STATUS_CODE_REQUEST_ENTITY_TOO_LARGE = (413, "Request Entity Too Large",
                                             "The request is larger than the server is willing or able to process.")

HTTP_STATUS_CODE_REQUEST_URI_TOO_LARGE    = (414, "Request-URI Too Long",
                                             "The URI provided was too long for the server to process.")

HTTP_STATUS_CODE_UNSUPPORTED_MEDIA_TYPE   = (415, "Unsupported Media Type",
                                             "The request entity has a media type which the server or resource does not support. For example, the client uploads an image as image/svg+xml, but the server requires that images use a different format.")

HTTP_STATUS_CODE_INVALID_REQUEST_RANGE    = (416, "Requested Range Not Satisfiable",
                                             "The client has asked for a portion of the file, but the server cannot supply that portion.[2] For example, if the client asked for a part of the file that lies beyond the end of the file.")

HTTP_STATUS_CODE_EXPECTATION_FAILED       = (417, "Expectation Failed",
                                             "The server cannot meet the requirements of the Expect request-header field.")

HTTP_STATUS_CODE_TEAPOT                   = (418, "I'm a teapot (RFC 2324)",
                                             "This code was defined in 1998 as one of the traditional IETF April Fools' jokes, in RFC 2324, Hyper Text Coffee Pot Control Protocol, and is not expected to be implemented by actual HTTP servers.")

HTTP_STATUS_CODE_UNPROCESSABLE_ENTITY     = (422, "Unprocessable Entity (WebDAV) (RFC 4918)",
                                             "The request was well-formed but was unable to be followed due to semantic errors.")

HTTP_STATUS_CODE_LOCKED                   = (423, "Locked (WebDAV) (RFC 4918)",
                                             "The resource that is being accessed is locked.")

HTTP_STATUS_CODE_FAILED_DEPENDENCY        = (424, "Failed Dependency (WebDAV) (RFC 4918)",
                                             "The request failed due to failure of a previous request (e.g. a PROPPATCH).")

HTTP_STATUS_CODE_UNORDERED_COLLECTION     = (425, "Unordered Collection (RFC 3648)",
                                             "Defined in drafts of 'WebDAV Advanced Collections Protocol', but not present in 'Web Distributed Authoring and Versioning (WebDAV) Ordered Collections Protocol'.")

HTTP_STATUS_CODE_UPGRADE_REQUIRED         = (426, "Upgrade Required (RFC 2817)",
                                             "The client should switch to a different protocol such as TLS/1.0.")

HTTP_STATUS_CODE_NO_RESPONSE              = (444, "No Response",
                                             "A Nginx HTTP server extension. The server returns no information to the client and closes the connection (useful as a deterrent for malware).")

HTTP_STATUS_CODE_RETRY_WITH               = (449, "Retry With",
                                             "A Microsoft extension. The request should be retried after performing the appropriate action.")

HTTP_STATUS_CODE_PARANTAL_BLOCKED         = (450, "Blocked by Windows Parental Controls",
                                             "A Microsoft extension. This error is given when Windows Parental Controls are turned on and are blocking access to the given webpage.")

HTTP_STATUS_CODE_CLIENT_CLOSED_REQUEST    = (499, "Client Closed Request",
                                             "An Nginx HTTP server extension. This code is introduced to log the case when the connection is closed by client while HTTP server is processing its request, making server unable to send the HTTP header back.")


##
## 5xx Server Error
##
## The server failed to fulfill an apparently valid request.
##
## Response status codes beginning with the digit "5" indicate cases in which
## the server is aware that it has encountered an error or is otherwise incapable
## of performing the request. Except when responding to a HEAD request, the server
## should include an entity containing an explanation of the error situation, and
## indicate whether it is a temporary or permanent condition. Likewise, user agents
## should display any included entity to the user. These response codes are
## applicable to any request method.
##

HTTP_STATUS_CODE_INTERNAL_SERVER_ERROR    = (500, "Internal Server Error",
                                             "A generic error message, given when no more specific message is suitable.")

HTTP_STATUS_CODE_NOT_IMPLEMENTED          = (501, "Not Implemented",
                                             "The server either does not recognise the request method, or it lacks the ability to fulfill the request.")

HTTP_STATUS_CODE_BAD_GATEWAY              = (502, "Bad Gateway",
                                             "The server was acting as a gateway or proxy and received an invalid response from the upstream server.")

HTTP_STATUS_CODE_SERVICE_UNAVAILABLE      = (503, "Service Unavailable",
                                             "The server is currently unavailable (because it is overloaded or down for maintenance). Generally, this is a temporary state.")

HTTP_STATUS_CODE_GATEWAY_TIMEOUT          = (504, "Gateway Timeout",
                                             "The server was acting as a gateway or proxy and did not receive a timely response from the upstream server.")

HTTP_STATUS_CODE_UNSUPPORTED_HTTP_VERSION = (505, "HTTP Version Not Supported",
                                             "The server does not support the HTTP protocol version used in the request.")

HTTP_STATUS_CODE_VARIANT_ALSO_NEGOTIATES  = (506, "Variant Also Negotiates (RFC 2295)",
                                             "Transparent content negotiation for the request results in a circular reference.")

HTTP_STATUS_CODE_INSUFFICIENT_STORAGE     = (507, "Insufficient Storage (WebDAV)(RFC 4918)",
                                             "The server is unable to store the representation needed to complete the request.")

HTTP_STATUS_CODE_BANDWIDTH_LIMIT_EXCEEDED = (509, "Bandwidth Limit Exceeded (Apache bw/limited extension)",
                                             "This status code, while used by many servers, is not specified in any RFCs.")

HTTP_STATUS_CODE_NOT_EXTENDED             = (510, "Not Extended (RFC 2774)",
                                             "Further extensions to the request are required for the server to fulfill it.")

HTTP_STATUS_CODE_NETWORK_READ_TIMEOUT     = (598, "Network read timeout error (Informal convention)",
                                             "This status code is not specified in any RFCs, but is used by some HTTP proxies to signal a network read timeout behind the proxy to a client in front of the proxy.")

HTTP_STATUS_CODE_NETWORK_CONNECT_TIMEOUT  = (599, "Network connect timeout error (Informal convention)",
                                             "This status code is not specified in any RFCs, but is used by some HTTP proxies to signal a network connect timeout behind the proxy to a client in front of the proxy.")

########NEW FILE########
__FILENAME__ = pbkdf2
# -*- coding: utf-8 -*-
"""
    pbkdf2
    ~~~~~~

    This module implements pbkdf2 for Python.  It also has some basic
    tests that ensure that it works.  The implementation is straightforward
    and uses stdlib only stuff and can be easily be copy/pasted into
    your favourite application.

    Use this as replacement for bcrypt that does not need a c implementation
    of a modified blowfish crypto algo.

    Example usage:

    >>> pbkdf2_hex('what i want to hash', 'the random salt')
    'fa7cc8a2b0a932f8e6ea42f9787e9d36e592e0c222ada6a9'

    How to use this:

    1.  Use a constant time string compare function to compare the stored hash
        with the one you're generating::

            def safe_str_cmp(a, b):
                if len(a) != len(b):
                    return False
                rv = 0
                for x, y in izip(a, b):
                    rv |= ord(x) ^ ord(y)
                return rv == 0

    2.  Use `os.urandom` to generate a proper salt of at least 8 byte.
        Use a unique salt per hashed password.

    3.  Store ``algorithm$salt:costfactor$hash`` in the database so that
        you can upgrade later easily to a different algorithm if you need
        one.  For instance ``PBKDF2-256$thesalt:10000$deadbeef...``.


    :copyright: (c) Copyright 2011 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
"""

__all__ = ("pbkdf2_hex",
           "pbkdf2_bin",)

import hmac
import hashlib
from struct import Struct
from operator import xor
from itertools import izip, starmap


_pack_int = Struct('>I').pack


def pbkdf2_hex(data, salt, iterations=1000, keylen=24, hashfunc=None):
    """Like :func:`pbkdf2_bin` but returns a hex encoded string."""
    return pbkdf2_bin(data, salt, iterations, keylen, hashfunc).encode('hex')


def pbkdf2_bin(data, salt, iterations=1000, keylen=24, hashfunc=None):
    """Returns a binary digest for the PBKDF2 hash algorithm of `data`
    with the given `salt`.  It iterates `iterations` time and produces a
    key of `keylen` bytes.  By default SHA-1 is used as hash function,
    a different hashlib `hashfunc` can be provided.
    """
    hashfunc = hashfunc or hashlib.sha1
    mac = hmac.new(data, None, hashfunc)
    def _pseudorandom(x, mac=mac):
        h = mac.copy()
        h.update(x)
        return map(ord, h.digest())
    buf = []
    for block in xrange(1, -(-keylen // mac.digest_size) + 1):
        rv = u = _pseudorandom(salt + _pack_int(block))
        for i in xrange(iterations - 1):
            u = _pseudorandom(''.join(map(chr, u)))
            rv = starmap(xor, izip(rv, u))
        buf.extend(rv)
    return ''.join(map(chr, buf))[:keylen]


def test():
    failed = []
    def check(data, salt, iterations, keylen, expected):
        rv = pbkdf2_hex(data, salt, iterations, keylen)
        if rv != expected:
            print 'Test failed:'
            print '  Expected:   %s' % expected
            print '  Got:        %s' % rv
            print '  Parameters:'
            print '    data=%s' % data
            print '    salt=%s' % salt
            print '    iterations=%d' % iterations
            print
            failed.append(1)

    # From RFC 6070
    check('password', 'salt', 1, 20,
          '0c60c80f961f0e71f3a9b524af6012062fe037a6')
    check('password', 'salt', 2, 20,
          'ea6c014dc72d6f8ccd1ed92ace1d41f0d8de8957')
    check('password', 'salt', 4096, 20,
          '4b007901b765489abead49d926f721d065a429c1')
    check('passwordPASSWORDpassword', 'saltSALTsaltSALTsaltSALTsaltSALTsalt',
          4096, 25, '3d2eec4fe41c849b80c8d83662c0e44a8b291a964cf2f07038')
    check('pass\x00word', 'sa\x00lt', 4096, 16,
          '56fa6aa75548099dcc37d7f03425e0c3')
    # This one is from the RFC but it just takes for ages
    ##check('password', 'salt', 16777216, 20,
    ##      'eefe3d61cd4da4e4e9945b3d6ba2158c2634e984')

    # From Crypt-PBKDF2
    check('password', 'ATHENA.MIT.EDUraeburn', 1, 16,
          'cdedb5281bb2f801565a1122b2563515')
    check('password', 'ATHENA.MIT.EDUraeburn', 1, 32,
          'cdedb5281bb2f801565a1122b25635150ad1f7a04bb9f3a333ecc0e2e1f70837')
    check('password', 'ATHENA.MIT.EDUraeburn', 2, 16,
          '01dbee7f4a9e243e988b62c73cda935d')
    check('password', 'ATHENA.MIT.EDUraeburn', 2, 32,
          '01dbee7f4a9e243e988b62c73cda935da05378b93244ec8f48a99e61ad799d86')
    check('password', 'ATHENA.MIT.EDUraeburn', 1200, 32,
          '5c08eb61fdf71e4e4ec3cf6ba1f5512ba7e52ddbc5e5142f708a31e2e62b1e13')
    check('X' * 64, 'pass phrase equals block size', 1200, 32,
          '139c30c0966bc32ba55fdbf212530ac9c5ec59f1a452f5cc9ad940fea0598ed1')
    check('X' * 65, 'pass phrase exceeds block size', 1200, 32,
          '9ccad6d468770cd51b10e6a68721be611a8b4d282601db3b36be9246915ec82a')

    raise SystemExit(bool(failed))


if __name__ == '__main__':
    test()

########NEW FILE########
__FILENAME__ = prefixmap
###############################################################################
##
##  Copyright 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

__all__ = ("PrefixMap",)

class PrefixMap:
   """
   Provides a two-way mapping between CURIEs (Compact URI Expressions) and
   full URIs. See http://www.w3.org/TR/curie/.
   """

   def __init__(self):
      self.index = {}
      self.rindex = {}

      ## add a couple of well-know prefixes
      ##
      #self.set("owl", "http://www.w3.org/2002/07/owl#")
      #self.set("rdf", "http://www.w3.org/1999/02/22-rdf-syntax-ns#")
      #self.set("rdfs", "http://www.w3.org/2000/01/rdf-schema#")
      #self.set("rdfa", "http://www.w3.org/ns/rdfa#")
      #self.set("xhv", "http://www.w3.org/1999/xhtml/vocab#")
      #self.set("xml", "http://www.w3.org/XML/1998/namespace")
      #self.set("xsd", "http://www.w3.org/2001/XMLSchema#")


   def get(self, prefix):
      """
      Returns the URI for the prefix or None if prefix has no mapped URI.

      :param prefix: Prefix to map.
      :type prefix: str
      :returns: str -- Mapped URI for prefix or None.
      """
      return self.index.get(prefix, None)


   def set(self, prefix, uri):
      """
      Set mapping of prefix to URI.

      :param prefix: Prefix to be mapped.
      :type prefix: str
      :param uri: URI the prefix is to be mapped to.
      :type uri: str
      """
      self.index[prefix] = uri
      self.rindex[uri] = prefix


   def setDefault(self, uri):
      """
      Set default URI mapping of empty prefix (prefix of length 0).

      :param uri: URI the empty prefix to be mapped to (i.e. :label should map to uri:label).
      :type str
      """
      self.set("", uri)


   def remove(self, prefix):
      """
      Remove mapping of prefix to URI.

      :param prefix: Prefix for which mapping should be removed.
      :type str
      """
      uri = index.get(index, None)
      if uri:
         del self.index[prefix]
         del self.rindex[uri]


   def resolve(self, curie):
      """
      Resolve given CURIE to full URI.

      :param curie: CURIE (i.e. "rdf:label").
      :type curie: str
      :returns: str -- Full URI for CURIE or None.
      """
      i = curie.find(":")
      if i > 0:
         prefix = curie[:i]
         if self.index.has_key(prefix):
            return self.index[prefix] + curie[i+1:]
      return None


   def resolveOrPass(self, curieOrUri):
      """
      Resolve given CURIE/URI and return string verbatim if cannot be resolved.

      :param curieOrUri: CURIE or URI.
      :type curieOrUri: str
      :returns: str -- Full URI for CURIE or original string.
      """
      u = self.resolve(curieOrUri)
      if u:
         return u
      else:
         return curieOrUri


   def shrink(self, uri):
      """
      Shrink given URI to CURIE. If no appropriate prefix mapping is available,
      return original URI.

      :param uri: URI to shrink.
      :type uri: str
      :returns str -- CURIE or original URI.
      """
      for i in xrange(len(uri), 1, -1):
         u = uri[:i]
         p = self.rindex.get(u, None)
         if p:
            return p + ":" + uri[i:]
      return uri


if __name__ == '__main__':
   m = PrefixMap()
   print m.resolve("http://www.w3.org/1999/02/22-rdf-syntax-ns#label")
   print m.resolve("rdf:label")
   print m.resolve("foobar:label")
   print m.shrink("http://www.w3.org/1999/02/22-rdf-syntax-ns#")
   print m.shrink("http://www.w3.org/1999/02/22-rdf-syntax-ns#label")
   print m.shrink("http://foobar.org#label")

########NEW FILE########
__FILENAME__ = resource
###############################################################################
##
##  Copyright 2012-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

__all__ = ("WebSocketResource",
           "HTTPChannelHixie76Aware",
           "WSGIRootResource",)


from zope.interface import implements

from twisted.python import log
from twisted.protocols.policies import ProtocolWrapper
try:
   from twisted.web.error import NoResource
except:
   ## starting from Twisted 12.2, NoResource has moved
   from twisted.web.resource import NoResource
from twisted.web.error import UnsupportedMethod
from twisted.web.resource import IResource, Resource
from twisted.web.server import NOT_DONE_YET
from twisted.web.http import HTTPChannel

from websocket import WebSocketServerFactory, WebSocketServerProtocol


class HTTPChannelHixie76Aware(HTTPChannel):
   """
   Hixie-76 is deadly broken. It includes 8 bytes of body, but then does not
   set content-length header. This hacked HTTPChannel injects the missing
   HTTP header upon detecting Hixie-76. We need this since otherwise
   Twisted Web will silently ignore the body.

   To use this, set `protocol = HTTPChannelHixie76Aware` on your
   `twisted.web.server.Site <http://twistedmatrix.com/documents/current/api/twisted.web.server.Site.html>`_ instance.

   See:
      * `Autobahn Twisted Web site example <https://github.com/tavendo/AutobahnPython/tree/master/examples/websocket/echo_site>`_
   """

   def headerReceived(self, line):
      header = line.split(':')[0].lower()
      if header == "sec-websocket-key1" and not self._transferDecoder:
         HTTPChannel.headerReceived(self, "Content-Length: 8")
      HTTPChannel.headerReceived(self, line)


class WSGIRootResource(Resource):
   """
   Root resource when you want a WSGI resource be the default serving
   resource for a Twisted Web site, but have subpaths served by
   different resources.

   This is a hack needed since
   `twisted.web.wsgi.WSGIResource <http://twistedmatrix.com/documents/current/api/twisted.web.wsgi.WSGIResource.html>`_.
   does not provide a `putChild()` method.

   See also:
      * `Autobahn Twisted Web WSGI example <https://github.com/tavendo/AutobahnPython/tree/master/examples/websocket/echo_wsgi>`_
      * `Original hack <http://blog.vrplumber.com/index.php?/archives/2426-Making-your-Twisted-resources-a-url-sub-tree-of-your-WSGI-resource....html>`_
   """

   def __init__(self, wsgiResource, children):
      """
      Creates a Twisted Web root resource.

      :param wsgiResource:
      :type wsgiResource: Instance of `twisted.web.wsgi.WSGIResource <http://twistedmatrix.com/documents/current/api/twisted.web.wsgi.WSGIResource.html>`_.
      :param children: A dictionary with string keys constituting URL subpaths, and Twisted Web resources as values.
      :type children: dict
      """
      Resource.__init__(self)
      self._wsgiResource = wsgiResource
      self.children = children

   def getChild(self, path, request):
      request.prepath.pop()
      request.postpath.insert(0, path)
      return self._wsgiResource


class WebSocketResource(object):
   """
   A Twisted Web resource for WebSocket. This resource needs to be instantiated
   with a factory derived from WebSocketServerFactory.
   """

   implements(IResource)

   isLeaf = True

   def __init__(self, factory):
      """
      Ctor.

      :param factory: An instance of WebSocketServerFactory.
      :type factory: obj
      """
      self._factory = factory


   def getChildWithDefault(self, name, request):
      """
      This resource cannot have children, hence this will always fail.
      """
      return NoResource("No such child resource.")


   def putChild(self, path, child):
      """
      This resource cannot have children, hence this is always ignored.
      """
      pass


   def render(self, request):
      """
      Render the resource. This will takeover the transport underlying
      the request, create a WebSocketServerProtocol and let that do
      any subsequent communication.
      """

      ## Create Autobahn WebSocket protocol.
      ##
      protocol = self._factory.buildProtocol(request.transport.getPeer())
      if not protocol:
         ## If protocol creation fails, we signal "internal server error"
         request.setResponseCode(500)
         return ""

      ## Take over the transport from Twisted Web
      ##
      transport, request.transport = request.transport, None

      ## Connect the transport to our protocol. Once #3204 is fixed, there
      ## may be a cleaner way of doing this.
      ## http://twistedmatrix.com/trac/ticket/3204
      ##
      if isinstance(transport, ProtocolWrapper):
         ## i.e. TLS is a wrapping protocol
         transport.wrappedProtocol = protocol
      else:
         transport.protocol = protocol
      protocol.makeConnection(transport)

      ## We recreate the request and forward the raw data. This is somewhat
      ## silly (since Twisted Web already did the HTTP request parsing
      ## which we will do a 2nd time), but it's totally non-invasive to our
      ## code. Maybe improve this.
      ##
      data = "%s %s HTTP/1.1\x0d\x0a" % (request.method, request.path)
      for h in request.requestHeaders.getAllRawHeaders():
         data += "%s: %s\x0d\x0a" % (h[0], ",".join(h[1]))
      data += "\x0d\x0a"
      data += request.content.read() # we need this for Hixie-76
      protocol.dataReceived(data)

      return NOT_DONE_YET

########NEW FILE########
__FILENAME__ = useragent
###############################################################################
##
##  Copyright 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

__all__ = ("lookupWsSupport",)


import re

UA_FIREFOX = re.compile(".*Firefox/(\d*).*")
UA_CHROME = re.compile(".*Chrome/(\d*).*")
UA_CHROMEFRAME = re.compile(".*chromeframe/(\d*).*")
UA_WEBKIT = re.compile(".*AppleWebKit/([0-9+\.]*)\w*.*")
UA_WEBOS = re.compile(".*webos/([0-9+\.]*)\w*.*")
UA_HPWEBOS = re.compile(".*hpwOS/([0-9+\.]*)\w*.*")



# Chrome =============================================================

# Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11


# Chrome Frame =======================================================

# IE6 on Windows with Chrome Frame
# Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; chromeframe/11.0.660.0)


# Firefox ============================================================

# Windows 7 64 Bit
# Mozilla/5.0 (Windows NT 6.1; WOW64; rv:12.0a2) Gecko/20120227 Firefox/12.0a2


# Android ============================================================

# Firefox Mobile
# Mozilla/5.0 (Android; Linux armv7l; rv:10.0.2) Gecko/20120215 Firefox/10.0.2 Fennec/10.0.2

# Chrome for Android (on ICS)
# Mozilla/5.0 (Linux; U; Android-4.0.3; en-us; Galaxy Nexus Build/IML74K) AppleWebKit/535.7 (KHTML, like Gecko) CrMo/16.0.912.75 Mobile Safari/535.7

# Android builtin browser

# Samsung Galaxy Tab 1
# Mozilla/5.0 (Linux; U; Android 2.2; de-de; GT-P1000 Build/FROYO) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1

# Samsung Galaxy S
# Mozilla/5.0 (Linux; U; Android 2.3.3; de-de; GT-I9000 Build/GINGERBREAD) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1

# Samsung Galaxy Note
# Mozilla/5.0 (Linux; U; Android 2.3.6; de-de; GT-N7000 Build/GINGERBREAD) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1

# Samsung Galaxy ACE (no Flash since ARM)
# Mozilla/5.0 (Linux; U; Android 2.2.1; de-de; GT-S5830 Build/FROYO) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1


# WebOS ==============================================================

# HP Touchpad
# Mozilla/5.0 (hp-tablet; Linux; hpwOS/3.0.5; U; en-US) AppleWebKit/534.6 (KHTML, like Gecko) wOSBrowser/234.83 Safari/534.6 TouchPad/1.0
# => Qt-WebKit, Hixie-76, Flash


# Safari =============================================================

# iPod Touch, iOS 4.2.1
# Mozilla/5.0 (iPod; U; CPU iPhone OS 4_2_1 like Mac OS X; de-de) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8C148 Safari/6533.18.5
# => Hixie-76

# MacBook Pro, OSX 10.5.8, Safari 5.0.6
# Mozilla/5.0 (Macintosh; Intel Mac OS X 10_5_8) AppleWebKit/534.50.2 (KHTML, like Gecko) Version/5.0.6 Safari/533.22.3
# => Hixie-76

# RFC6455
# Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534+ (KHTML, like Gecko) Version/5.1.2 Safari/534.52.7
# Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.24+ (KHTML, like Gecko) Version/5.1.3 Safari/534.53.10

# Hixie-76
# Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/534.53.11 (KHTML, like Gecko) Version/5.1.3 Safari/534.53.10

# Hixie-76
# Mozilla/5.0 (Macintosh; Intel Mac OS X 10_5_8) AppleWebKit/534.50.2 (KHTML, like Gecko) Version/5.0.6 Safari/533.22.3


# Opera ==============================================================

# Windows 7 32-Bit
# Opera/9.80 (Windows NT 6.1; U; de) Presto/2.10.229 Version/11.61

# Windows 7 64-Bit
# Opera/9.80 (Windows NT 6.1; WOW64; U; de) Presto/2.10.229 Version/11.62

# Samsung Galaxy S
# Opera/9.80 (Android 2.3.3; Linux; Opera Mobi/ADR-1202231246; U; de) Presto/2.10.254 Version/12.00

# Samsung Galaxy Tab 1
# Opera/9.80 (Android 2.2; Linux; Opera Tablet/ADR-1203051631; U; de) Presto/2.10.254 Version/12.00

# Samsung Galaxy ACE:
# Opera/9.80 (Android 2.2.1; Linux; Opera Mobi/ADR-1203051631; U; de) Presto/2.10.254 Version/12.00

# Nokia N8, Symbian S60 5th Ed., S60 Bell
# Opera/9.80 (S60; SymbOS; Opera Mobi/SYB-1111151949; U; de) Presto/2.9.201 Version/11.50


def _lookupWsSupport(ua):
   ## Internet Explorer
   ##
   ## FIXME: handle Windows Phone
   ##
   if ua.find("MSIE") >= 0:
      # IE10 has native support
      if ua.find("MSIE 10") >= 0:
         # native Hybi-10+
         return (True, False, True)

      # first, check for Google Chrome Frame
      # http://www.chromium.org/developers/how-tos/chrome-frame-getting-started/understanding-chrome-frame-user-agent
      if ua.find("chromeframe") >= 0:

         r = UA_CHROMEFRAME.match(ua)
         try:
            v = int(r.groups()[0])
            if v >= 14:
               # native Hybi-10+
               return (True, False, True)
         except:
            # detection problem
            return (False, False, False)

      # Flash fallback
      if ua.find("MSIE 8") >= 0 or ua.find("MSIE 9") >= 0:
         return (True, True, True)

      # unsupported
      return (False, False, True)


   ## iOS
   ##
   if ua.find("iPhone") >= 0 or ua.find("iPad") >= 0 or ua.find("iPod") >= 0:
      ## native Hixie76 (as of March 2012), no Flash, no alternative browsers
      return (True, False, True)


   ## Android
   ##
   if ua.find("Android") >= 0:

      ## Firefox Mobile
      ##
      if ua.find("Firefox") >= 0:
         # Hybi-10+ for FF Mobile 8+
         return (True, False, True)

      ## Opera Mobile
      ##
      if ua.find("Opera") >= 0:
         # Hixie76 for Opera 11+
         return (True, False, True)

      ## Chrome for Android
      ##
      if ua.find("CrMo") >= 0:
         # http://code.google.com/chrome/mobile/docs/faq.html
         return (True, False, True)

      ## Android builtin Browser (ooold WebKit)
      ##
      if ua.find("AppleWebKit") >= 0:

         # Though we return WS = True, and Flash = True here, when the device has no actual Flash support, that
         # will get later detected in JS. This applies to i.e. ARMv6 devices like Samsung Galaxy ACE

         # builtin browser, only works via Flash
         return (True, True, True)

      # detection problem
      return (False, False, False)


   ## webOS
   ##
   if ua.find("hpwOS") >= 0 or ua.find("webos") >= 0:
      try:
         if ua.find("hpwOS") >= 0:
            vv = [int(x) for x in UA_HPWEBOS.match(ua).groups()[0].split('.')]
            if vv[0] >= 3:
               return (True, False, True)
         elif ua.find("webos") >= 0:
            vv = [int(x) for x in UA_WEBOS.match(ua).groups()[0].split('.')]
            if vv[0] >= 2:
               return (True, False, True)
      except:
         # detection problem
         return (False, False, False)
      else:
         # unsupported
         return (False, False, True)


   ## Opera
   ##
   if ua.find("Opera") >= 0:
      # Opera 11+ has Hixie76 (needs to be manually activated though)
      return (True, False, True)


   ## Firefox
   ##
   if ua.find("Firefox") >= 0:
      r = UA_FIREFOX.match(ua)
      try:
         v = int(r.groups()[0])
         if v >= 7:
            # native Hybi-10+
            return (True, False, True)
         elif v >= 3:
            # works with Flash bridge
            return (True, True, True)
         else:
            # unsupported
            return (False, False, True)
      except:
         # detection problem
         return (False, False, False)


   ## Safari
   ##
   if ua.find("Safari") >= 0 and not ua.find("Chrome") >= 0:

      # rely on at least Hixie76
      return (True, False, True)


   ## Chrome
   ##
   if ua.find("Chrome") >= 0:
      r = UA_CHROME.match(ua)
      try:
         v = int(r.groups()[0])
         if v >= 14:
            # native Hybi-10+
            return (True, False, True)
         elif v >= 4:
            # works with Flash bridge
            return (True, True, True)
         else:
            # unsupported
            return (False, False, True)
      except:
         # detection problem
         return (False, False, False)


   # detection problem
   return (False, False, False)


UA_DETECT_WS_SUPPORT_DB = {}

def lookupWsSupport(ua, debug = True):
   """
   Lookup if browser supports WebSocket (Hixie76, Hybi10+, RFC6455) natively,
   and if not, whether the `web-socket-js <https://github.com/gimite/web-socket-js>`_
   Flash bridge works to polyfill that.

   Returns a tuple of booleans `(ws_supported, needs_flash, detected)` where

      * `ws_supported`: WebSocket is supported
      * `needs_flash`: Flash Bridge is needed for support
      * `detected` the code has explicitly mapped the support/nosupport

   :param ua: The browser user agent string as sent in the HTTP header, e.g. provided as `flask.request.user_agent.string` in Flask.
   :type ua: str

   :returns: tuple -- A tuple `(ws_supported, needs_flash, detected)`.
   """
   ws = _lookupWsSupport(ua)
   if debug:
      if not UA_DETECT_WS_SUPPORT_DB.has_key(ua):
         UA_DETECT_WS_SUPPORT_DB[ua] = ws

      if not ws[2]:
         msg = "UNDETECTED"
      elif ws[0]:
         msg = "SUPPORTED"
      elif not ws[0]:
         msg = "UNSUPPORTED"
      else:
         msg = "ERROR"

      print "DETECT_WS_SUPPORT", ua, ws[0], ws[1], ws[2], msg

   return ws

########NEW FILE########
__FILENAME__ = utf8validator
###############################################################################
##
##  Copyright 2011-2013 Tavendo GmbH
##
##  Note:
##
##  This code is a Python implementation of the algorithm
##
##            "Flexible and Economical UTF-8 Decoder"
##
##  by Bjoern Hoehrmann
##
##       bjoern@hoehrmann.de
##       http://bjoern.hoehrmann.de/utf-8/decoder/dfa/
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

__all__ = ("Utf8Validator",)

## use Cython implementation of UTF8 validator if available
##
try:
   from wsaccel.utf8validator import Utf8Validator

except:
   ## fallback to pure Python implementation

   class Utf8Validator:
      """
      Incremental UTF-8 validator with constant memory consumption (minimal state).

      Implements the algorithm "Flexible and Economical UTF-8 Decoder" by
      Bjoern Hoehrmann (http://bjoern.hoehrmann.de/utf-8/decoder/dfa/).
      """

      ## DFA transitions
      UTF8VALIDATOR_DFA = [
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, # 00..1f
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, # 20..3f
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, # 40..5f
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, # 60..7f
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, # 80..9f
        7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, # a0..bf
        8,8,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, # c0..df
        0xa,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x4,0x3,0x3, # e0..ef
        0xb,0x6,0x6,0x6,0x5,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8, # f0..ff
        0x0,0x1,0x2,0x3,0x5,0x8,0x7,0x1,0x1,0x1,0x4,0x6,0x1,0x1,0x1,0x1, # s0..s0
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1, # s1..s2
        1,2,1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1, # s3..s4
        1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,3,1,1,1,1,1,1, # s5..s6
        1,3,1,1,1,1,1,3,1,3,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1, # s7..s8
      ]

      UTF8_ACCEPT = 0
      UTF8_REJECT = 1

      def __init__(self):
         self.reset()

      def decode(self, b):
         """
         Eat one UTF-8 octet, and validate on the fly.

         Returns UTF8_ACCEPT when enough octets have been consumed, in which case
         self.codepoint contains the decoded Unicode code point.

         Returns UTF8_REJECT when invalid UTF-8 was encountered.

         Returns some other positive integer when more octets need to be eaten.
         """
         type = Utf8Validator.UTF8VALIDATOR_DFA[b]
         if self.state != Utf8Validator.UTF8_ACCEPT:
            self.codepoint = (b & 0x3f) | (self.codepoint << 6)
         else:
            self.codepoint = (0xff >> type) & b
         self.state = Utf8Validator.UTF8VALIDATOR_DFA[256 + self.state * 16 + type]
         return self.state

      def reset(self):
         """
         Reset validator to start new incremental UTF-8 decode/validation.
         """
         self.state = Utf8Validator.UTF8_ACCEPT
         self.codepoint = 0
         self.i = 0

      def validate(self, ba):
         """
         Incrementally validate a chunk of bytes provided as string.

         Will return a quad (valid?, endsOnCodePoint?, currentIndex, totalIndex).

         As soon as an octet is encountered which renders the octet sequence
         invalid, a quad with valid? == False is returned. currentIndex returns
         the index within the currently consumed chunk, and totalIndex the
         index within the total consumed sequence that was the point of bail out.
         When valid? == True, currentIndex will be len(ba) and totalIndex the
         total amount of consumed bytes.
         """
         l = len(ba)
         for i in xrange(l):
            ## optimized version of decode(), since we are not interested in actual code points
            self.state = Utf8Validator.UTF8VALIDATOR_DFA[256 + (self.state << 4) + Utf8Validator.UTF8VALIDATOR_DFA[ord(ba[i])]]
            if self.state == Utf8Validator.UTF8_REJECT:
               self.i += i
               return False, False, i, self.i
         self.i += l
         return True, self.state == Utf8Validator.UTF8_ACCEPT, l, self.i

########NEW FILE########
__FILENAME__ = util
###############################################################################
##
##  Copyright 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

__all__ = ("utcnow",
           "parseutc",
           "utcstr",
           "newid",
           "rtime",
           "Stopwatch",)

import datetime
import time
import random
import sys

UTC_TIMESTAMP_FORMAT = "%Y-%m-%dT%H:%M:%SZ"


def utcnow():
   """
   Get current time in UTC as ISO 8601 string.
   """
   now = datetime.datetime.utcnow()
   return now.strftime(UTC_TIMESTAMP_FORMAT)


def parseutc(s):
   """
   Parse an ISO 8601 combined date and time string, like i.e. 2011-11-23T12:23Z
   into a UTC datetime instance.
   """
   try:
      return datetime.datetime.strptime(s, UTC_TIMESTAMP_FORMAT)
   except:
      return None


def utcstr(dt):
   """
   Convert an UTC datetime instance into an ISO 8601 combined date and time,
   like i.e. 2011-11-23T12:23Z
   """
   try:
      return dt.strftime(UTC_TIMESTAMP_FORMAT)
   except:
      return None


def newid():
   """
   Generate a new random object ID.
   """
   return ''.join([random.choice("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_") for i in xrange(16)])



## Select the most precise walltime measurement function available
## on the platform
##
if sys.platform.startswith('win'):
   ## On Windows, this function returns wall-clock seconds elapsed since the
   ## first call to this function, as a floating point number, based on the
   ## Win32 function QueryPerformanceCounter(). The resolution is typically
   ## better than one microsecond
   rtime = time.clock
   _ = rtime()
else:
   ## On Unix-like platforms, this used the first available from this list:
   ## (1) gettimeofday() -- resolution in microseconds
   ## (2) ftime() -- resolution in milliseconds
   ## (3) time() -- resolution in seconds
   rtime = time.time


class Stopwatch:
   """
   Stopwatch based on walltime. Can be used to do code timing and uses the
   most precise walltime measurement available on the platform. This is
   a very light-weight object, so create/dispose is very cheap.
   """

   def __init__(self, start = True):
      """
      Creates a new stopwatch and by default immediately starts (= resumes) it.
      """
      self._elapsed = 0
      if start:
         self._started = rtime()
         self._running = True
      else:
         self._started = None
         self._running = False

   def elapsed(self):
      """
      Return total time elapsed in seconds during which the stopwatch was running.
      """
      if self._running:
         now = rtime()
         return self._elapsed + (now - self._started)
      else:
         return self._elapsed

   def pause(self):
      """
      Pauses the stopwatch and returns total time elapsed in seconds during which
      the stopwatch was running.
      """
      if self._running:
         now = rtime()
         self._elapsed += now - self._started
         self._running = False
         return self._elapsed
      else:
         return self._elapsed

   def resume(self):
      """
      Resumes a paused stopwatch and returns total elapsed time in seconds
      during which the stopwatch was running.
      """
      if not self._running:
         self._started = rtime()
         self._running = True
         return self._elapsed
      else:
         now = rtime()
         return self._elapsed + (now - self._started)

   def stop(self):
      """
      Stops the stopwatch and returns total time elapsed in seconds during which
      the stopwatch was (previously) running.
      """
      elapsed = self.pause()
      self._elapsed = 0
      self._started = None
      self._running = False
      return elapsed

########NEW FILE########
__FILENAME__ = wamp
###############################################################################
##
##  Copyright 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

__all__ = ("WampProtocol",
           "WampFactory",
           "WampServerProtocol",
           "WampServerFactory",
           "WampClientProtocol",
           "WampClientFactory",
           "WampCraProtocol",
           "WampCraClientProtocol",
           "WampCraServerProtocol",)

import json
import random
import inspect, types
import traceback

import hashlib, hmac, binascii

from twisted.python import log
from twisted.internet import reactor
from twisted.internet.defer import Deferred, \
                                   maybeDeferred, \
                                   returnValue, \
                                   inlineCallbacks

from _version import __version__
from websocket import WebSocketProtocol, HttpException, Timings
from websocket import WebSocketClientProtocol, WebSocketClientFactory
from websocket import WebSocketServerFactory, WebSocketServerProtocol

from httpstatus import HTTP_STATUS_CODE_BAD_REQUEST
from pbkdf2 import pbkdf2_bin
from prefixmap import PrefixMap
from util import utcstr, utcnow, parseutc, newid


def exportRpc(arg = None):
   """
   Decorator for RPC'ed callables.
   """
   ## decorator without argument
   if type(arg) is types.FunctionType:
      arg._autobahn_rpc_id = arg.__name__
      return arg
   ## decorator with argument
   else:
      def inner(f):
         f._autobahn_rpc_id = arg
         return f
      return inner

def exportSub(arg, prefixMatch = False):
   """
   Decorator for subscription handlers.
   """
   def inner(f):
      f._autobahn_sub_id = arg
      f._autobahn_sub_prefix_match = prefixMatch
      return f
   return inner

def exportPub(arg, prefixMatch = False):
   """
   Decorator for publication handlers.
   """
   def inner(f):
      f._autobahn_pub_id = arg
      f._autobahn_pub_prefix_match = prefixMatch
      return f
   return inner


class WampProtocol:
   """
   WAMP protocol base class. Mixin for WampServerProtocol and WampClientProtocol.
   """

   URI_WAMP_BASE = "http://api.wamp.ws/"
   """
   WAMP base URI for WAMP predefined things.
   """

   URI_WAMP_ERROR = URI_WAMP_BASE + "error#"
   """
   Prefix for WAMP errors.
   """

   URI_WAMP_PROCEDURE = URI_WAMP_BASE + "procedure#"
   """
   Prefix for WAMP predefined RPC endpoints.
   """

   URI_WAMP_TOPIC = URI_WAMP_BASE + "topic#"
   """
   Prefix for WAMP predefined PubSub topics.
   """

   URI_WAMP_ERROR_GENERIC = URI_WAMP_ERROR + "generic"
   """
   WAMP error URI for generic errors.
   """

   DESC_WAMP_ERROR_GENERIC = "generic error"
   """
   Description for WAMP generic errors.
   """

   URI_WAMP_ERROR_INTERNAL = URI_WAMP_ERROR + "internal"
   """
   WAMP error URI for internal errors.
   """

   DESC_WAMP_ERROR_INTERNAL = "internal error"
   """
   Description for WAMP internal errors.
   """

   WAMP_PROTOCOL_VERSION         = 1
   """
   WAMP version this server speaks. Versions are numbered consecutively
   (integers, no gaps).
   """

   MESSAGE_TYPEID_WELCOME        = 0
   """
   Server-to-client welcome message containing session ID.
   """

   MESSAGE_TYPEID_PREFIX         = 1
   """
   Client-to-server message establishing a URI prefix to be used in CURIEs.
   """

   MESSAGE_TYPEID_CALL           = 2
   """
   Client-to-server message initiating an RPC.
   """

   MESSAGE_TYPEID_CALL_RESULT    = 3
   """
   Server-to-client message returning the result of a successful RPC.
   """

   MESSAGE_TYPEID_CALL_ERROR     = 4
   """
   Server-to-client message returning the error of a failed RPC.
   """

   MESSAGE_TYPEID_SUBSCRIBE      = 5
   """
   Client-to-server message subscribing to a topic.
   """

   MESSAGE_TYPEID_UNSUBSCRIBE    = 6
   """
   Client-to-server message unsubscribing from a topic.
   """

   MESSAGE_TYPEID_PUBLISH        = 7
   """
   Client-to-server message publishing an event to a topic.
   """

   MESSAGE_TYPEID_EVENT          = 8
   """
   Server-to-client message providing the event of a (subscribed) topic.
   """

   def connectionMade(self):
      self.debugWamp = self.factory.debugWamp
      self.debugApp = self.factory.debugApp
      self.prefixes = PrefixMap()
      self.calls = {}
      self.procs = {}


   def connectionLost(self, reason):
      pass


   def _protocolError(self, reason):
      if self.debugWamp:
         log.msg("Closing Wamp session on protocol violation : %s" % reason)

      ## FIXME: subprotocols are probably not supposed to close with CLOSE_STATUS_CODE_PROTOCOL_ERROR
      ##
      self.protocolViolation("Wamp RPC/PubSub protocol violation ('%s')" % reason)


   def shrink(self, uri, passthrough = False):
      """
      Shrink given URI to CURIE according to current prefix mapping.
      If no appropriate prefix mapping is available, return original URI.

      :param uri: URI to shrink.
      :type uri: str

      :returns str -- CURIE or original URI.
      """
      return self.prefixes.shrink(uri)


   def resolve(self, curieOrUri, passthrough = False):
      """
      Resolve given CURIE/URI according to current prefix mapping or return
      None if cannot be resolved.

      :param curieOrUri: CURIE or URI.
      :type curieOrUri: str

      :returns: str -- Full URI for CURIE or None.
      """
      return self.prefixes.resolve(curieOrUri)


   def resolveOrPass(self, curieOrUri):
      """
      Resolve given CURIE/URI according to current prefix mapping or return
      string verbatim if cannot be resolved.

      :param curieOrUri: CURIE or URI.
      :type curieOrUri: str

      :returns: str -- Full URI for CURIE or original string.
      """
      return self.prefixes.resolveOrPass(curieOrUri)


   def serializeMessage(self, msg):
      """
      Delegate message serialization to the factory.
      :param msg: The message to be serialized.
      :type msg: str
      :return: The serialized message.
      """
      return self.factory._serialize(msg)


   def registerForRpc(self, obj, baseUri = "", methods = None):
      """
      Register an service object for RPC. A service object has methods
      which are decorated using @exportRpc.

      :param obj: The object to be registered (in this WebSockets session) for RPC.
      :type obj: Object with methods decorated using @exportRpc.
      :param baseUri: Optional base URI which is prepended to method names for export.
      :type baseUri: String.
      :param methods: If not None, a list of unbound class methods corresponding to obj
                     which should be registered. This can be used to register only a subset
                     of the methods decorated with @exportRpc.
      :type methods: List of unbound class methods.
      """
      for k in inspect.getmembers(obj.__class__, inspect.ismethod):
         if k[1].__dict__.has_key("_autobahn_rpc_id"):
            if methods is None or k[1] in methods:
               uri = baseUri + k[1].__dict__["_autobahn_rpc_id"]
               proc = k[1]
               self.registerMethodForRpc(uri, obj, proc)


   def registerMethodForRpc(self, uri, obj, proc):
      """
      Register a method of an object for RPC.

      :param uri: URI to register RPC method under.
      :type uri: str
      :param obj: The object on which to register a method for RPC.
      :type obj: object
      :param proc: Unbound object method to register RPC for.
      :type proc: unbound method
      """
      self.procs[uri] = (obj, proc, False)
      if self.debugWamp:
         log.msg("registered remote method on %s" % uri)


   def registerProcedureForRpc(self, uri, proc):
      """
      Register a (free standing) function/procedure for RPC.

      :param uri: URI to register RPC function/procedure under.
      :type uri: str
      :param proc: Free-standing function/procedure.
      :type proc: callable
      """
      self.procs[uri] = (None, proc, False)
      if self.debugWamp:
         log.msg("registered remote procedure on %s" % uri)


   def registerHandlerMethodForRpc(self, uri, obj, handler, extra = None):
      """
      Register a handler on an object for RPC.

      :param uri: URI to register RPC method under.
      :type uri: str
      :param obj: The object on which to register the RPC handler
      :type obj: object
      :param proc: Unbound object method to register RPC for.
      :type proc: unbound method
      :param extra: Optional extra data that will be given to the handler at call time.
      :type extra: object
      """
      self.procs[uri] = (obj, handler, True, extra)
      if self.debugWamp:
         log.msg("registered remote handler method on %s" % uri)


   def registerHandlerProcedureForRpc(self, uri, handler, extra = None):
      """
      Register a (free standing) handler for RPC.

      :param uri: URI to register RPC handler under.
      :type uri: str
      :param proc: Free-standing handler
      :type proc: callable
      :param extra: Optional extra data that will be given to the handler at call time.
      :type extra: object
      """
      self.procs[uri] = (None, handler, True, extra)
      if self.debugWamp:
         log.msg("registered remote handler procedure on %s" % uri)


   def procForUri(self, uri):
      """
      Returns the procedure specification for `uri` or None, if it does not exist.

      :param uri: URI to be checked.
      :type uri: str
      :returns: The procedure specification for `uri`, if it exists,
                `None` otherwise.
      """
      return self.procs[uri] if uri in self.procs else None


   def onBeforeCall(self, callid, uri, args, isRegistered):
      """
      Callback fired before executing incoming RPC. This can be used for
      logging, statistics tracking or redirecting RPCs or argument mangling i.e.

      The default implementation just returns the incoming URI/args.

      :param uri: RPC endpoint URI (fully-qualified).
      :type uri: str
      :param args: RPC arguments array.
      :type args: list
      :param isRegistered: True, iff RPC endpoint URI is registered in this session.
      :type isRegistered: bool
      :returns pair -- Must return URI/Args pair.
      """
      return uri, args


   def onAfterCallSuccess(self, result, call):
      """
      Callback fired after executing incoming RPC with success, but before
      sending the RPC success message.

      The default implementation will just return `result` to the client.

      :param result: Result returned for executing the incoming RPC.
      :type result: Anything returned by the user code for the endpoint.
      :param call: WAMP call object for incoming RPC.
      :type call: instance of Call
      :returns obj -- Result send back to client.
      """
      return result


   def onAfterCallError(self, error, call):
      """
      Callback fired after executing incoming RPC with failure, but before
      sending the RPC error message.

      The default implementation will just return `error` to the client.

      :param error: Error that occurred during incomnig RPC call execution.
      :type error: Instance of twisted.python.failure.Failure
      :param call: WAMP call object for incoming RPC.
      :type call: instance of Call
      :returns twisted.python.failure.Failure -- Error sent back to client.
      """
      return error


   def onAfterSendCallSuccess(self, msg, call):
      """
      Callback fired after sending RPC success message.

      :param msg: Serialized WAMP message.
      :type msg: str
      :param call: WAMP call object for incoming RPC.
      :type call: instance of Call
      """
      pass


   def onAfterSendCallError(self, msg, call):
      """
      Callback fired after sending RPC error message.

      :param msg: Serialized WAMP message.
      :type msg: str
      :param call: WAMP call object for incoming RPC.
      :type call: instance of Call
      """
      pass


   def call(self, *args):
      """
      Perform a remote-procedure call (RPC). The first argument is the procedure
      URI (mandatory). Subsequent positional arguments can be provided (must be
      JSON serializable). The return value is a Twisted Deferred.
      """

      if len(args) < 1:
         raise Exception("missing procedure URI")

      if type(args[0]) not in [unicode, str]:
         raise Exception("invalid type for procedure URI")

      procuri = args[0]
      while True:
         callid = newid()
         if not self.calls.has_key(callid):
            break
      d = Deferred()
      self.calls[callid] = d
      msg = [WampProtocol.MESSAGE_TYPEID_CALL, callid, procuri]
      msg.extend(args[1:])

      try:
         o = self.factory._serialize(msg)
      except:
         raise Exception("call argument(s) not JSON serializable")

      self.sendMessage(o)
      return d



class WampFactory:
   """
   WAMP factory base class. Mixin for WampServerFactory and WampClientFactory.
   """

   def _serialize(self, obj):
      """
      Default object serializer.
      """
      return json.dumps(obj)


   def _unserialize(self, bytes):
      """
      Default object deserializer.
      """
      return json.loads(bytes)



class WampServerProtocol(WebSocketServerProtocol, WampProtocol):
   """
   Server factory for Wamp RPC/PubSub.
   """

   SUBSCRIBE = 1
   PUBLISH = 2

   def onSessionOpen(self):
      """
      Callback fired when WAMP session was fully established.
      """
      pass


   def onOpen(self):
      """
      Default implementation for WAMP connection opened sends
      Welcome message containing session ID.
      """
      self.session_id = newid()

      ## include traceback as error detail for RPC errors with
      ## no error URI - that is errors returned with URI_WAMP_ERROR_GENERIC
      self.includeTraceback = True

      msg = [WampProtocol.MESSAGE_TYPEID_WELCOME,
             self.session_id,
             WampProtocol.WAMP_PROTOCOL_VERSION,
             "Autobahn/%s" % __version__]
      o = self.factory._serialize(msg)
      self.sendMessage(o)

      self.factory._addSession(self, self.session_id)
      self.onSessionOpen()


   def onConnect(self, connectionRequest):
      """
      Default implementation for WAMP connection acceptance:
      check if client announced WAMP subprotocol, and only accept connection
      if client did so.
      """
      for p in connectionRequest.protocols:
         if p in self.factory.protocols:
            return p
      raise HttpException(HTTP_STATUS_CODE_BAD_REQUEST[0], "this server only speaks WAMP")


   def connectionMade(self):
      WebSocketServerProtocol.connectionMade(self)
      WampProtocol.connectionMade(self)

      ## RPCs registered in this session (a URI map of (object, procedure)
      ## pairs for object methods or (None, procedure) for free standing procedures)
      self.procs = {}

      ## Publication handlers registered in this session (a URI map of (object, pubHandler) pairs
      ## pairs for object methods (handlers) or (None, None) for topic without handler)
      self.pubHandlers = {}

      ## Subscription handlers registered in this session (a URI map of (object, subHandler) pairs
      ## pairs for object methods (handlers) or (None, None) for topic without handler)
      self.subHandlers = {}

      self.handlerMapping = {
         self.MESSAGE_TYPEID_CALL: CallHandler(self, self.prefixes),
         self.MESSAGE_TYPEID_CALL_RESULT: CallResultHandler(self, self.prefixes),
         self.MESSAGE_TYPEID_CALL_ERROR: CallErrorHandler(self, self.prefixes)}


   def connectionLost(self, reason):
      self.factory._unsubscribeClient(self)
      self.factory._removeSession(self)

      WampProtocol.connectionLost(self, reason)
      WebSocketServerProtocol.connectionLost(self, reason)


   def sendMessage(self, payload):
      if self.debugWamp:
         log.msg("TX WAMP: %s" % str(payload))
      WebSocketServerProtocol.sendMessage(self, payload)


   def _getPubHandler(self, topicUri):
      ## Longest matching prefix based resolution of (full) topic URI to
      ## publication handler.
      ## Returns a 5-tuple (consumedUriPart, unconsumedUriPart, handlerObj, handlerProc, prefixMatch)
      ##
      for i in xrange(len(topicUri), -1, -1):
         tt = topicUri[:i]
         if self.pubHandlers.has_key(tt):
            h = self.pubHandlers[tt]
            return (tt, topicUri[i:], h[0], h[1], h[2])
      return None


   def _getSubHandler(self, topicUri):
      ## Longest matching prefix based resolution of (full) topic URI to
      ## subscription handler.
      ## Returns a 5-tuple (consumedUriPart, unconsumedUriPart, handlerObj, handlerProc, prefixMatch)
      ##
      for i in xrange(len(topicUri), -1, -1):
         tt = topicUri[:i]
         if self.subHandlers.has_key(tt):
            h = self.subHandlers[tt]
            return (tt, topicUri[i:], h[0], h[1], h[2])
      return None


   def registerForPubSub(self, topicUri, prefixMatch = False, pubsub = PUBLISH | SUBSCRIBE):
      """
      Register a topic URI as publish/subscribe channel in this session.

      :param topicUri: Topic URI to be established as publish/subscribe channel.
      :type topicUri: str
      :param prefixMatch: Allow to match this topic URI by prefix.
      :type prefixMatch: bool
      :param pubsub: Allow publication and/or subscription.
      :type pubsub: WampServerProtocol.PUB, WampServerProtocol.SUB, WampServerProtocol.PUB | WampServerProtocol.SUB
      """
      if pubsub & WampServerProtocol.PUBLISH:
         self.pubHandlers[topicUri] = (None, None, prefixMatch)
         if self.debugWamp:
            log.msg("registered topic %s for publication (match by prefix = %s)" % (topicUri, prefixMatch))
      if pubsub & WampServerProtocol.SUBSCRIBE:
         self.subHandlers[topicUri] = (None, None, prefixMatch)
         if self.debugWamp:
            log.msg("registered topic %s for subscription (match by prefix = %s)" % (topicUri, prefixMatch))


   def registerHandlerForPubSub(self, obj, baseUri = ""):
      """
      Register a handler object for PubSub. A handler object has methods
      which are decorated using @exportPub and @exportSub.

      :param obj: The object to be registered (in this WebSockets session) for PubSub.
      :type obj: Object with methods decorated using @exportPub and @exportSub.
      :param baseUri: Optional base URI which is prepended to topic names for export.
      :type baseUri: String.
      """
      for k in inspect.getmembers(obj.__class__, inspect.ismethod):
         if k[1].__dict__.has_key("_autobahn_pub_id"):
            uri = baseUri + k[1].__dict__["_autobahn_pub_id"]
            prefixMatch = k[1].__dict__["_autobahn_pub_prefix_match"]
            proc = k[1]
            self.registerHandlerForPub(uri, obj, proc, prefixMatch)
         elif k[1].__dict__.has_key("_autobahn_sub_id"):
            uri = baseUri + k[1].__dict__["_autobahn_sub_id"]
            prefixMatch = k[1].__dict__["_autobahn_sub_prefix_match"]
            proc = k[1]
            self.registerHandlerForSub(uri, obj, proc, prefixMatch)


   def registerHandlerForSub(self, uri, obj, proc, prefixMatch = False):
      """
      Register a method of an object as subscription handler.

      :param uri: Topic URI to register subscription handler for.
      :type uri: str
      :param obj: The object on which to register a method as subscription handler.
      :type obj: object
      :param proc: Unbound object method to register as subscription handler.
      :type proc: unbound method
      :param prefixMatch: Allow to match this topic URI by prefix.
      :type prefixMatch: bool
      """
      self.subHandlers[uri] = (obj, proc, prefixMatch)
      if not self.pubHandlers.has_key(uri):
         self.pubHandlers[uri] = (None, None, False)
      if self.debugWamp:
         log.msg("registered subscription handler for topic %s" % uri)


   def registerHandlerForPub(self, uri, obj, proc, prefixMatch = False):
      """
      Register a method of an object as publication handler.

      :param uri: Topic URI to register publication handler for.
      :type uri: str
      :param obj: The object on which to register a method as publication handler.
      :type obj: object
      :param proc: Unbound object method to register as publication handler.
      :type proc: unbound method
      :param prefixMatch: Allow to match this topic URI by prefix.
      :type prefixMatch: bool
      """
      self.pubHandlers[uri] = (obj, proc, prefixMatch)
      if not self.subHandlers.has_key(uri):
         self.subHandlers[uri] = (None, None, False)
      if self.debugWamp:
         log.msg("registered publication handler for topic %s" % uri)


   def dispatch(self, topicUri, event, exclude = [], eligible = None):
      """
      Dispatch an event for a topic to all clients subscribed to
      and authorized for that topic.

      Optionally, exclude list of clients and/or only consider clients
      from explicit eligibles. In other words, the event is delivered
      to the set

         (subscribers - excluded) & eligible

      :param topicUri: URI of topic to publish event to.
      :type topicUri: str
      :param event: Event to dispatch.
      :type event: obj
      :param exclude: Optional list of clients (WampServerProtocol instances) to exclude.
      :type exclude: list of obj
      :param eligible: Optional list of clients (WampServerProtocol instances) eligible at all (or None for all).
      :type eligible: list of obj

      :returns twisted.internet.defer.Deferred -- Will be fired when event was
      dispatched to all subscribers. The return value provided to the deferred
      is a pair (delivered, requested), where delivered = number of actual
      receivers, and requested = number of (subscribers - excluded) & eligible.
      """
      return self.factory.dispatch(topicUri, event, exclude, eligible)


   def onMessage(self, msg, binary):
      """
      Handle WAMP messages received from WAMP client.
      """

      if self.debugWamp:
         log.msg("RX WAMP: %s" % str(msg))

      if not binary:
         try:
            obj = self.factory._unserialize(msg)
            if type(obj) == list:

               msgtype = obj[0]

               ### XXX Replace check by try...except when all handlers
               ### XXX are in place. Exception handling should create
               ### XXX a protocolError message about unsupported
               ### XXX message type
               if msgtype in [WampProtocol.MESSAGE_TYPEID_CALL,
                              WampProtocol.MESSAGE_TYPEID_CALL_RESULT,
                              WampProtocol.MESSAGE_TYPEID_CALL_ERROR]:
                  self.handlerMapping[msgtype].handleMessage(obj)

               ### XXX Move remaining code to appropriate handlers

               ## Subscribe Message
               ##
               elif msgtype == WampProtocol.MESSAGE_TYPEID_SUBSCRIBE:
                  topicUri = self.prefixes.resolveOrPass(obj[1]) ### PFX - remove
                  h = self._getSubHandler(topicUri)
                  if h:
                     ## either exact match or prefix match allowed
                     if h[1] == "" or h[4]:

                        ## direct topic
                        if h[2] is None and h[3] is None:
                           self.factory._subscribeClient(self, topicUri)

                        ## topic handled by subscription handler
                        else:
                           try:
                              ## handler is object method
                              if h[2]:
                                 a = h[3](h[2], str(h[0]), str(h[1]))

                              ## handler is free standing procedure
                              else:
                                 a = h[3](str(h[0]), str(h[1]))

                              ## only subscribe client if handler did return True
                              if a:
                                 self.factory._subscribeClient(self, topicUri)
                           except:
                              if self.debugWamp:
                                 log.msg("exception during topic subscription handler:")
                              traceback.print_exc()
                     else:
                        if self.debugWamp:
                           log.msg("topic %s matches only by prefix and prefix match disallowed" % topicUri)
                  else:
                     if self.debugWamp:
                        log.msg("no topic / subscription handler registered for %s" % topicUri)

               ## Unsubscribe Message
               ##
               elif msgtype == WampProtocol.MESSAGE_TYPEID_UNSUBSCRIBE:
                  topicUri = self.prefixes.resolveOrPass(obj[1]) ### PFX - remove
                  self.factory._unsubscribeClient(self, topicUri)

               ## Publish Message
               ##
               elif msgtype == WampProtocol.MESSAGE_TYPEID_PUBLISH:
                  topicUri = self.prefixes.resolveOrPass(obj[1]) ### PFX - remove
                  h = self._getPubHandler(topicUri)
                  if h:
                     ## either exact match or prefix match allowed
                     if h[1] == "" or h[4]:

                        ## Event
                        ##
                        event = obj[2]

                        ## Exclude Sessions List
                        ##
                        exclude = [self] # exclude publisher by default
                        if len(obj) >= 4:
                           if type(obj[3]) == bool:
                              if not obj[3]:
                                 exclude = []
                           elif type(obj[3]) == list:
                              ## map session IDs to protos
                              exclude = self.factory.sessionIdsToProtos(obj[3])
                           else:
                              ## FIXME: invalid type
                              pass

                        ## Eligible Sessions List
                        ##
                        eligible = None # all sessions are eligible by default
                        if len(obj) >= 5:
                           if type(obj[4]) == list:
                              ## map session IDs to protos
                              eligible = self.factory.sessionIdsToProtos(obj[4])
                           else:
                              ## FIXME: invalid type
                              pass

                        ## direct topic
                        if h[2] is None and h[3] is None:
                           self.factory.dispatch(topicUri, event, exclude, eligible)

                        ## topic handled by publication handler
                        else:
                           try:
                              ## handler is object method
                              if h[2]:
                                 e = h[3](h[2], str(h[0]), str(h[1]), event)

                              ## handler is free standing procedure
                              else:
                                 e = h[3](str(h[0]), str(h[1]), event)

                              ## only dispatch event if handler did return event
                              if e:
                                 self.factory.dispatch(topicUri, e, exclude, eligible)
                           except:
                              if self.debugWamp:
                                 log.msg("exception during topic publication handler:")
                              traceback.print_exc()
                     else:
                        if self.debugWamp:
                           log.msg("topic %s matches only by prefix and prefix match disallowed" % topicUri)
                  else:
                     if self.debugWamp:
                        log.msg("no topic / publication handler registered for %s" % topicUri)

               ## Define prefix to be used in CURIEs
               ##
               elif msgtype == WampProtocol.MESSAGE_TYPEID_PREFIX:
                  prefix = obj[1]
                  uri = obj[2]
                  self.prefixes.set(prefix, uri) ### PFX - remove whole block (this msg type won't survive)

               else:
                  log.msg("unknown message type")
            else:
               log.msg("msg not a list")
         except Exception, e:
            traceback.print_exc()
      else:
         log.msg("binary message")



class WampServerFactory(WebSocketServerFactory, WampFactory):
   """
   Server factory for Wamp RPC/PubSub.
   """

   protocol = WampServerProtocol
   """
   Twisted protocol used by default for WAMP servers.
   """

   def __init__(self, url, debug = False, debugCodePaths = False, debugWamp = False, debugApp = False, externalPort = None):
      WebSocketServerFactory.__init__(self, url, protocols = ["wamp"], debug = debug, debugCodePaths = debugCodePaths, externalPort = externalPort)
      self.debugWamp = debugWamp
      self.debugApp = debugApp


   def onClientSubscribed(self, proto, topicUri):
      """
      Callback fired when peer was (successfully) subscribed on some topic.

      :param proto: Peer protocol instance subscribed.
      :type proto: Instance of WampServerProtocol.
      :param topicUri: Fully qualified, resolved URI of topic subscribed.
      :type topicUri: str
      """
      pass


   def _subscribeClient(self, proto, topicUri):
      """
      Called from proto to subscribe client for topic.
      """
      if not self.subscriptions.has_key(topicUri):
         self.subscriptions[topicUri] = set()
         if self.debugWamp:
            log.msg("subscriptions map created for topic %s" % topicUri)
      if not proto in self.subscriptions[topicUri]:
         self.subscriptions[topicUri].add(proto)
         if self.debugWamp:
            log.msg("subscribed peer %s on topic %s" % (proto.peerstr, topicUri))
         self.onClientSubscribed(proto, topicUri)
      else:
         if self.debugWamp:
            log.msg("peer %s already subscribed on topic %s" % (proto.peerstr, topicUri))


   def onClientUnsubscribed(self, proto, topicUri):
      """
      Callback fired when peer was (successfully) unsubscribed from some topic.

      :param proto: Peer protocol instance unsubscribed.
      :type proto: Instance of WampServerProtocol.
      :param topicUri: Fully qualified, resolved URI of topic unsubscribed.
      :type topicUri: str
      """
      pass


   def _unsubscribeClient(self, proto, topicUri = None):
      """
      Called from proto to unsubscribe client from topic.
      """
      if topicUri:
         if self.subscriptions.has_key(topicUri) and proto in self.subscriptions[topicUri]:
            self.subscriptions[topicUri].discard(proto)
            if self.debugWamp:
               log.msg("unsubscribed peer %s from topic %s" % (proto.peerstr, topicUri))
            if len(self.subscriptions[topicUri]) == 0:
               del self.subscriptions[topicUri]
               if self.debugWamp:
                  log.msg("topic %s removed from subscriptions map - no one subscribed anymore" % topicUri)
            self.onClientUnsubscribed(proto, topicUri)
         else:
            if self.debugWamp:
               log.msg("peer %s not subscribed on topic %s" % (proto.peerstr, topicUri))
      else:
         for topicUri, subscribers in self.subscriptions.items():
            if proto in subscribers:
               subscribers.discard(proto)
               if self.debugWamp:
                  log.msg("unsubscribed peer %s from topic %s" % (proto.peerstr, topicUri))
               if len(subscribers) == 0:
                  del self.subscriptions[topicUri]
                  if self.debugWamp:
                     log.msg("topic %s removed from subscriptions map - no one subscribed anymore" % topicUri)
               self.onClientUnsubscribed(proto, topicUri)
         if self.debugWamp:
            log.msg("unsubscribed peer %s from all topics" % (proto.peerstr))


   def dispatch(self, topicUri, event, exclude = [], eligible = None):
      """
      Dispatch an event to all peers subscribed to the event topic.

      :param topicUri: Topic to publish event to.
      :type topicUri: str
      :param event: Event to publish (must be JSON serializable).
      :type event: obj
      :param exclude: List of WampServerProtocol instances to exclude from receivers.
      :type exclude: List of obj
      :param eligible: List of WampServerProtocol instances eligible as receivers (or None for all).
      :type eligible: List of obj

      :returns twisted.internet.defer.Deferred -- Will be fired when event was
      dispatched to all subscribers. The return value provided to the deferred
      is a pair (delivered, requested), where delivered = number of actual
      receivers, and requested = number of (subscribers - excluded) & eligible.
      """
      if self.debugWamp:
         log.msg("publish event %s for topicUri %s" % (str(event), topicUri))

      d = Deferred()

      if self.subscriptions.has_key(topicUri) and len(self.subscriptions[topicUri]) > 0:

         ## FIXME: this might break ordering of event delivery from a
         ## receiver perspective. We might need to have send queues
         ## per receiver OR do recvs = deque(sorted(..))

         ## However, see http://twistedmatrix.com/trac/ticket/1396

         if eligible is not None:
            subscrbs = set(eligible) & self.subscriptions[topicUri]
         else:
            subscrbs = self.subscriptions[topicUri]

         if len(exclude) > 0:
            recvs = subscrbs - set(exclude)
         else:
            recvs = subscrbs

         l = len(recvs)
         if l > 0:

            ## ok, at least 1 subscriber not excluded and eligible
            ## => prepare message for mass sending
            ##
            o = [WampProtocol.MESSAGE_TYPEID_EVENT, topicUri, event]
            try:
               msg = self._serialize(o)
               if self.debugWamp:
                  log.msg("serialized event msg: " + str(msg))
            except Exception, e:
               raise Exception("invalid type for event - serialization failed [%s]" % e)

            preparedMsg = self.prepareMessage(msg)

            ## chunked sending of prepared message
            ##
            self._sendEvents(preparedMsg, recvs.copy(), 0, l, d)

         else:
            ## receivers list empty after considering exlude and eligible sessions
            ##
            d.callback((0, 0))
      else:
         ## no one subscribed on topic
         ##
         d.callback((0, 0))

      return d


   def _sendEvents(self, preparedMsg, recvs, delivered, requested, d):
      """
      Delivers events to receivers in chunks and reenters the reactor
      in-between, so that other stuff can run.
      """
      ## deliver a batch of events
      done = False
      for i in xrange(0, 256):
         try:
            proto = recvs.pop()
            if proto.state == WebSocketProtocol.STATE_OPEN:
               try:
                  proto.sendPreparedMessage(preparedMsg)
               except:
                  pass
               else:
                  if self.debugWamp:
                     log.msg("delivered event to peer %s" % proto.peerstr)
                  delivered += 1
         except KeyError:
            # all receivers done
            done = True
            break

      if not done:
         ## if there are receivers left, redo
         reactor.callLater(0, self._sendEvents, preparedMsg, recvs, delivered, requested, d)
      else:
         ## else fire final result
         d.callback((delivered, requested))


   def _addSession(self, proto, session_id):
      """
      Add proto for session ID.
      """
      if not self.protoToSessions.has_key(proto):
         self.protoToSessions[proto] = session_id
      else:
         raise Exception("logic error - dublicate _addSession for protoToSessions")
      if not self.sessionsToProto.has_key(session_id):
         self.sessionsToProto[session_id] = proto
      else:
         raise Exception("logic error - dublicate _addSession for sessionsToProto")


   def _removeSession(self, proto):
      """
      Remove session by proto.
      """
      if self.protoToSessions.has_key(proto):
         session_id = self.protoToSessions[proto]
         del self.protoToSessions[proto]
         if self.sessionsToProto.has_key(session_id):
            del self.sessionsToProto[session_id]


   def sessionIdToProto(self, sessionId):
      """
      Map WAMP session ID to connected protocol instance (object of type WampServerProtocol).

      :param sessionId: WAMP session ID to be mapped.
      :type sessionId: str

      :returns obj -- WampServerProtocol instance or None.
      """
      return self.sessionsToProto.get(sessionId, None)


   def sessionIdsToProtos(self, sessionIds):
      """
      Map WAMP session IDs to connected protocol instances (objects of type WampServerProtocol).

      :param sessionIds: List of session IDs to be mapped.
      :type sessionIds: list of str

      :returns list -- List of WampServerProtocol instances corresponding to the WAMP session IDs.
      """
      protos = []
      for s in sessionIds:
         if self.sessionsToProto.has_key(s):
            protos.append(self.sessionsToProto[s])
      return protos


   def protoToSessionId(self, proto):
      """
      Map connected protocol instance (object of type WampServerProtocol) to WAMP session ID.

      :param proto: Instance of WampServerProtocol to be mapped.
      :type proto: obj of WampServerProtocol

      :returns str -- WAMP session ID or None.
      """
      return self.protoToSessions.get(proto, None)


   def protosToSessionIds(self, protos):
      """
      Map connected protocol instances (objects of type WampServerProtocol) to WAMP session IDs.

      :param protos: List of instances of WampServerProtocol to be mapped.
      :type protos: list of WampServerProtocol

      :returns list -- List of WAMP session IDs corresponding to the protos.
      """
      sessionIds = []
      for p in protos:
         if self.protoToSessions.has_key(p):
            sessionIds.append(self.protoToSessions[p])
      return sessionIds


   def startFactory(self):
      """
      Called by Twisted when the factory starts up. When overriding, make
      sure to call the base method.
      """
      if self.debugWamp:
         log.msg("WampServerFactory starting")
      self.subscriptions = {}
      self.protoToSessions = {}
      self.sessionsToProto = {}


   def stopFactory(self):
      """
      Called by Twisted when the factory shuts down. When overriding, make
      sure to call the base method.
      """
      if self.debugWamp:
         log.msg("WampServerFactory stopped")



class WampClientProtocol(WebSocketClientProtocol, WampProtocol):
   """
   Twisted client protocol for WAMP.
   """

   def onSessionOpen(self):
      """
      Callback fired when WAMP session was fully established. Override
      in derived class.
      """
      pass


   def onOpen(self):
      ## do nothing here .. onSessionOpen is only fired when welcome
      ## message was received (and thus session ID set)
      pass


   def onConnect(self, connectionResponse):
      if connectionResponse.protocol not in self.factory.protocols:
         raise Exception("server does not speak WAMP")


   def connectionMade(self):
      WebSocketClientProtocol.connectionMade(self)
      WampProtocol.connectionMade(self)

      self.subscriptions = {}

      self.handlerMapping = {
         self.MESSAGE_TYPEID_CALL: CallHandler(self, self.prefixes),
         self.MESSAGE_TYPEID_CALL_RESULT: CallResultHandler(self, self.prefixes),
         self.MESSAGE_TYPEID_CALL_ERROR: CallErrorHandler(self, self.prefixes)}


   def connectionLost(self, reason):
      WampProtocol.connectionLost(self, reason)
      WebSocketClientProtocol.connectionLost(self, reason)


   def sendMessage(self, payload):
      if self.debugWamp:
         log.msg("TX WAMP: %s" % str(payload))
      WebSocketClientProtocol.sendMessage(self, payload)


   def onMessage(self, msg, binary):
      """Internal method to handle WAMP messages received from WAMP server."""

      ## WAMP is text message only
      ##
      if binary:
         self._protocolError("binary WebSocket message received")
         return

      if self.debugWamp:
         log.msg("RX WAMP: %s" % str(msg))

      ## WAMP is proper JSON payload
      ##
      try:
         obj = self.factory._unserialize(msg)
      except Exception, e:
         self._protocolError("WAMP message payload could not be unserialized [%s]" % e)
         return

      ## Every WAMP message is a list
      ##
      if type(obj) != list:
         self._protocolError("WAMP message payload not a list")
         return

      ## Every WAMP message starts with an integer for message type
      ##
      if len(obj) < 1:
         self._protocolError("WAMP message without message type")
         return
      if type(obj[0]) != int:
         self._protocolError("WAMP message type not an integer")
         return

      ## WAMP message type
      ##
      msgtype = obj[0]

      ## Valid WAMP message types received by WAMP clients
      ##
      if msgtype not in [WampProtocol.MESSAGE_TYPEID_WELCOME,
                         WampProtocol.MESSAGE_TYPEID_CALL,
                         WampProtocol.MESSAGE_TYPEID_CALL_RESULT,
                         WampProtocol.MESSAGE_TYPEID_CALL_ERROR,
                         WampProtocol.MESSAGE_TYPEID_EVENT]:
         self._protocolError("invalid WAMP message type %d" % msgtype)
         return

      if msgtype in [WampProtocol.MESSAGE_TYPEID_CALL,
                     WampProtocol.MESSAGE_TYPEID_CALL_RESULT,
                     WampProtocol.MESSAGE_TYPEID_CALL_ERROR]:
         self.handlerMapping[msgtype].handleMessage(obj)

      ## WAMP EVENT
      ##
      elif msgtype == WampProtocol.MESSAGE_TYPEID_EVENT:
         ## Topic
         ##
         if len(obj) != 3:
            self._protocolError("WAMP EVENT message invalid length %d" % len(obj))
            return
         if type(obj[1]) not in [unicode, str]:
            self._protocolError("invalid type for <topic> in WAMP EVENT message")
            return
         unresolvedTopicUri = str(obj[1])
         topicUri = self.prefixes.resolveOrPass(unresolvedTopicUri) ### PFX - remove

         ## Fire PubSub Handler
         ##
         if self.subscriptions.has_key(topicUri):
            event = obj[2]
            self.subscriptions[topicUri](topicUri, event)
         else:
            ## event received for non-subscribed topic (could be because we
            ## just unsubscribed, and server already sent out event for
            ## previous subscription)
            pass

      ## WAMP WELCOME
      ##
      elif msgtype == WampProtocol.MESSAGE_TYPEID_WELCOME:
         ## Session ID
         ##
         if len(obj) < 2:
            self._protocolError("WAMP WELCOME message invalid length %d" % len(obj))
            return
         if type(obj[1]) not in [unicode, str]:
            self._protocolError("invalid type for <sessionid> in WAMP WELCOME message")
            return
         self.session_id = str(obj[1])

         ## WAMP Protocol Version
         ##
         if len(obj) > 2:
            if type(obj[2]) not in [int]:
               self._protocolError("invalid type for <version> in WAMP WELCOME message")
               return
            else:
               self.session_protocol_version = obj[2]
         else:
            self.session_protocol_version = None

         ## Server Ident
         ##
         if len(obj) > 3:
            if type(obj[3]) not in [unicode, str]:
               self._protocolError("invalid type for <server> in WAMP WELCOME message")
               return
            else:
               self.session_server = obj[3]
         else:
            self.session_server = None

         self.onSessionOpen()

      else:
         raise Exception("logic error")


   def prefix(self, prefix, uri):
      """
      Establishes a prefix to be used in CURIEs instead of URIs having that
      prefix for both client-to-server and server-to-client messages.

      :param prefix: Prefix to be used in CURIEs.
      :type prefix: str
      :param uri: URI that this prefix will resolve to.
      :type uri: str
      """

      if type(prefix) != str:
         raise Exception("invalid type for prefix")

      if type(uri) not in [unicode, str]:
         raise Exception("invalid type for URI")

      if self.prefixes.get(prefix):  ### PFX - keep
         raise Exception("prefix already defined")

      self.prefixes.set(prefix, uri) ### PFX - keep

      msg = [WampProtocol.MESSAGE_TYPEID_PREFIX, prefix, uri]

      self.sendMessage(self.factory._serialize(msg))


   def publish(self, topicUri, event, excludeMe = None, exclude = None, eligible = None):
      """
      Publish an event under a topic URI. The latter may be abbreviated using a
      CURIE which has been previously defined using prefix(). The event must
      be JSON serializable.

      :param topicUri: The topic URI or CURIE.
      :type topicUri: str
      :param event: Event to be published (must be JSON serializable) or None.
      :type event: value
      :param excludeMe: When True, don't deliver the published event to myself (when I'm subscribed).
      :type excludeMe: bool
      :param exclude: Optional list of session IDs to exclude from receivers.
      :type exclude: list of str
      :param eligible: Optional list of session IDs to that are eligible as receivers.
      :type eligible: list of str
      """

      if type(topicUri) not in [unicode, str]:
         raise Exception("invalid type for parameter 'topicUri' - must be string (was %s)" % type(topicUri))

      if excludeMe is not None:
         if type(excludeMe) != bool:
            raise Exception("invalid type for parameter 'excludeMe' - must be bool (was %s)" % type(excludeMe))

      if exclude is not None:
         if type(exclude) != list:
            raise Exception("invalid type for parameter 'exclude' - must be list (was %s)" % type(exclude))

      if eligible is not None:
         if type(eligible) != list:
            raise Exception("invalid type for parameter 'eligible' - must be list (was %s)" % type(eligible))

      if exclude is not None or eligible is not None:
         if exclude is None:
            if excludeMe is not None:
               if excludeMe:
                  exclude = [self.session_id]
               else:
                  exclude = []
            else:
               exclude = [self.session_id]
         if eligible is not None:
            msg = [WampProtocol.MESSAGE_TYPEID_PUBLISH, topicUri, event, exclude, eligible]
         else:
            msg = [WampProtocol.MESSAGE_TYPEID_PUBLISH, topicUri, event, exclude]
      else:
         if excludeMe:
            msg = [WampProtocol.MESSAGE_TYPEID_PUBLISH, topicUri, event]
         else:
            msg = [WampProtocol.MESSAGE_TYPEID_PUBLISH, topicUri, event, excludeMe]

      try:
         o = self.factory._serialize(msg)
      except:
         raise Exception("invalid type for parameter 'event' - not JSON serializable")

      self.sendMessage(o)


   def subscribe(self, topicUri, handler):
      """
      Subscribe to topic. When already subscribed, will overwrite the handler.

      :param topicUri: URI or CURIE of topic to subscribe to.
      :type topicUri: str
      :param handler: Event handler to be invoked upon receiving events for topic.
      :type handler: Python callable, will be called as in <callable>(eventUri, event).
      """
      if type(topicUri) not in [unicode, str]:
         raise Exception("invalid type for parameter 'topicUri' - must be string (was %s)" % type(topicUri))

      if type(handler) not in [types.FunctionType, types.MethodType, types.BuiltinFunctionType, types.BuiltinMethodType]:
         raise Exception("invalid type for parameter 'handler' - must be a callable (was %s)" % type(handler))

      turi = self.prefixes.resolveOrPass(topicUri) ### PFX - keep
      if not self.subscriptions.has_key(turi):
         msg = [WampProtocol.MESSAGE_TYPEID_SUBSCRIBE, topicUri]
         o = self.factory._serialize(msg)
         self.sendMessage(o)
      self.subscriptions[turi] = handler


   def unsubscribe(self, topicUri):
      """
      Unsubscribe from topic. Will do nothing when currently not subscribed to the topic.

      :param topicUri: URI or CURIE of topic to unsubscribe from.
      :type topicUri: str
      """
      if type(topicUri) not in [unicode, str]:
         raise Exception("invalid type for parameter 'topicUri' - must be string (was %s)" % type(topicUri))

      turi = self.prefixes.resolveOrPass(topicUri) ### PFX - keep
      if self.subscriptions.has_key(turi):
         msg = [WampProtocol.MESSAGE_TYPEID_UNSUBSCRIBE, topicUri]
         o = self.factory._serialize(msg)
         self.sendMessage(o)
         del self.subscriptions[turi]



class WampClientFactory(WebSocketClientFactory, WampFactory):
   """
   Twisted client factory for WAMP.
   """

   protocol = WampClientProtocol

   def __init__(self, url, debug = False, debugCodePaths = False, debugWamp = False, debugApp = False):
      WebSocketClientFactory.__init__(self, url, protocols = ["wamp"], debug = debug, debugCodePaths = debugCodePaths)
      self.debugWamp = debugWamp
      self.debugApp = debugApp


   def startFactory(self):
      """
      Called by Twisted when the factory starts up. When overriding, make
      sure to call the base method.
      """
      if self.debugWamp:
         log.msg("WebSocketClientFactory starting")


   def stopFactory(self):
      """
      Called by Twisted when the factory shuts down. When overriding, make
      sure to call the base method.
      """
      if self.debugWamp:
         log.msg("WebSocketClientFactory stopped")



class WampCraProtocol(WampProtocol):
   """
   Base class for WAMP Challenge-Response Authentication protocols (client and server).

   WAMP-CRA is a cryptographically strong challenge response authentication
   protocol based on HMAC-SHA256.

   The protocol performs in-band authentication of WAMP clients to WAMP servers.

   WAMP-CRA does not introduce any new WAMP protocol level message types, but
   implements the authentication handshake via standard WAMP RPCs with well-known
   procedure URIs and signatures.
   """

   def deriveKey(secret, extra = None):
      """
      Computes a derived cryptographic key from a password according to PBKDF2
      http://en.wikipedia.org/wiki/PBKDF2.

      The function will only return a derived key if at least 'salt' is
      present in the 'extra' dictionary. The complete set of attributes
      that can be set in 'extra':

         salt: The salt value to be used.
         iterations: Number of iterations of derivation algorithm to run.
         keylen: Key length to derive.

      :returns str -- The derived key or the original secret.
      """
      if type(extra) == dict and extra.has_key('salt'):
         salt = str(extra['salt'])
         iterations = int(extra.get('iterations', 10000))
         keylen = int(extra.get('keylen', 32))
         b = pbkdf2_bin(secret, salt, iterations, keylen, hashlib.sha256)
         return binascii.b2a_base64(b).strip()
      else:
         return secret

   deriveKey = staticmethod(deriveKey)


   def authSignature(self, authChallenge, authSecret = None, authExtra = None):
      """
      Compute the authentication signature from an authentication challenge and a secret.

      :param authChallenge: The authentication challenge.
      :type authChallenge: str
      :param authSecret: The authentication secret.
      :type authSecret: str
      :authExtra: Extra authentication information for salting the secret. (salt, keylen,
              iterations)
      :type authExtra: dict

      :returns str -- The authentication signature.
      """
      if authSecret is None:
         authSecret = ""
      authSecret = WampCraProtocol.deriveKey(authSecret, authExtra)
      h = hmac.new(authSecret, authChallenge, hashlib.sha256)
      sig = binascii.b2a_base64(h.digest()).strip()
      return sig



class WampCraClientProtocol(WampClientProtocol, WampCraProtocol):
   """
   Simple, authenticated WAMP client protocol.

   The client can perform WAMP-Challenge-Response-Authentication ("WAMP-CRA") to authenticate
   itself to a WAMP server. The server needs to implement WAMP-CRA also of course.
   """

   def authenticate(self, authKey = None, authExtra = None, authSecret = None):
      """
      Authenticate the WAMP session to server.

      :param authKey: The key of the authentication credentials, something like a user or application name.
      :type authKey: str
      :param authExtra: Any extra authentication information.
      :type authExtra: dict
      :param authSecret: The secret of the authentication credentials, something like the user password or application secret key.
      :type authsecret: str

      :returns Deferred -- Deferred that fires upon authentication success (with permissions) or failure.
      """

      def _onAuthChallenge(challenge):
         if authKey is not None:
            challengeObj =  self.factory._unserialize(challenge)
            if 'authextra' in challengeObj:
                authExtra = challengeObj['authextra']
                sig = self.authSignature(challenge, authSecret, authExtra)
            else:
                sig = self.authSignature(challenge, authSecret)
         else:
            sig = None
         d = self.call(WampProtocol.URI_WAMP_PROCEDURE + "auth", sig)
         return d

      d = self.call(WampProtocol.URI_WAMP_PROCEDURE + "authreq", authKey, authExtra)
      d.addCallback(_onAuthChallenge)
      return d



class WampCraServerProtocol(WampServerProtocol, WampCraProtocol):
   """
   Simple, authenticating WAMP server protocol.

   The server lets clients perform WAMP-Challenge-Response-Authentication ("WAMP-CRA")
   to authenticate. The clients need to implement WAMP-CRA also of course.

   To implement an authenticating server, override:

      * getAuthSecret
      * getAuthPermissions
      * onAuthenticated

   in your class deriving from this class.
   """

   clientAuthTimeout = 0
   """
   Client authentication timeout in seconds or 0 for infinite. A client
   must perform authentication after the initial WebSocket handshake within
   this timeout or the connection is failed.
   """

   clientAuthAllowAnonymous = True
   """
   Allow anonymous client authentication. When this is set to True, a client
   may "authenticate" as anonymous.
   """


   def getAuthPermissions(self, authKey, authExtra):
      """
      Get the permissions the session is granted when the authentication succeeds
      for the given key / extra information.

      Override in derived class to implement your authentication.

      A permissions object is structured like this::

         {'permissions': {'rpc': [
                                    {'uri':  / RPC Endpoint URI - String /,
                                     'call': / Allow to call? - Boolean /}
                                 ],
                          'pubsub': [
                                       {'uri':    / PubSub Topic URI / URI prefix - String /,
                                        'prefix': / URI matched by prefix? - Boolean /,
                                        'pub':    / Allow to publish? - Boolean /,
                                        'sub':    / Allow to subscribe? - Boolean /}
                                    ]
                          }
         }

      You can add custom information to this object. The object will be provided again
      when the client authentication succeeded in :meth:`onAuthenticated`.

      :param authKey: The authentication key.
      :type authKey: str
      :param authExtra: Authentication extra information.
      :type authExtra: dict

      :returns obj or Deferred -- Return a permissions object or None when no permissions granted.
      """
      return None


   def getAuthSecret(self, authKey):
      """
      Get the authentication secret for an authentication key, i.e. the
      user password for the user name. Return None when the authentication
      key does not exist.

      Override in derived class to implement your authentication.

      :param authKey: The authentication key.
      :type authKey: str

      :returns str or Deferred -- The authentication secret for the key or None when the key does not exist.
      """
      return None


   def onAuthTimeout(self):
      """
      Fired when the client does not authenticate itself in time. The default implementation
      will simply fail the connection.

      May be overridden in derived class.
      """
      if not self._clientAuthenticated:
         log.msg("failing connection upon client authentication timeout [%s secs]" % self.clientAuthTimeout)
         self.failConnection()


   def onAuthenticated(self, permissions):
      """
      Fired when client authentication was successful.

      Override in derived class and register PubSub topics and/or RPC endpoints.

      :param permissions: The permissions object returned from :meth:`getAuthPermissions`.
      :type permissions: obj
      """
      pass


   def registerForPubSubFromPermissions(self, permissions):
      """
      Register topics for PubSub from auth permissions.

      :param permissions: The permissions granted to the now authenticated client.
      :type permissions: list
      """
      for p in permissions['pubsub']:
         ## register topics for the clients
         ##
         pubsub = (WampServerProtocol.PUBLISH if p['pub'] else 0) | \
                  (WampServerProtocol.SUBSCRIBE if p['sub'] else 0)
         topic = p['uri']
         if self.pubHandlers.has_key(topic) or self.subHandlers.has_key(topic):
            ## FIXME: handle dups!
            log.msg("DUPLICATE TOPIC PERMISSION !!! " + topic)
         self.registerForPubSub(topic, p['prefix'], pubsub)


   def onSessionOpen(self):
      """
      Called when WAMP session has been established, but not yet authenticated. The default
      implementation will prepare the session allowing the client to authenticate itself.
      """

      ## register RPC endpoints for WAMP-CRA authentication
      ##
      self.registerForRpc(self, WampProtocol.URI_WAMP_PROCEDURE, [WampCraServerProtocol.authRequest,
                                                                  WampCraServerProtocol.auth])

      ## reset authentication state
      ##
      self._clientAuthenticated = False
      self._clientPendingAuth = None
      self._clientAuthTimeoutCall = None

      ## client authentication timeout
      ##
      if self.clientAuthTimeout > 0:
         self._clientAuthTimeoutCall = reactor.callLater(self.clientAuthTimeout, self.onAuthTimeout)


   @exportRpc("authreq")
   def authRequest(self, authKey = None, extra = None):
      """
      RPC endpoint for clients to initiate the authentication handshake.

      :param authKey: Authentication key, such as user name or application name.
      :type authKey: str
      :param extra: Authentication extra information.
      :type extra: dict

      :returns str -- Authentication challenge. The client will need to create an authentication signature from this.
      """

      ## check authentication state
      ##
      if self._clientAuthenticated:
         raise Exception(self.shrink(WampProtocol.URI_WAMP_ERROR + "already-authenticated"), "already authenticated")
      if self._clientPendingAuth is not None:
         raise Exception(self.shrink(WampProtocol.URI_WAMP_ERROR + "authentication-already-requested"), "authentication request already issues - authentication pending")

      ## check extra
      ##
      if extra:
         if type(extra) != dict:
            raise Exception(self.shrink(WampProtocol.URI_WAMP_ERROR + "invalid-argument"), "extra not a dictionary (was %s)." % str(type(extra)))
      else:
         extra = {}
      #for k in extra:
      #   if type(extra[k]) not in [str, unicode, int, long, float, bool, types.NoneType]:
      #      raise Exception(self.shrink(WampProtocol.URI_WAMP_ERROR + "invalid-argument"), "attribute '%s' in extra not a primitive type (was %s)" % (k, str(type(extra[k]))))

      ## check authKey
      ##
      if authKey is None and not self.clientAuthAllowAnonymous:
         raise Exception(self.shrink(WampProtocol.URI_WAMP_ERROR + "anonymous-auth-forbidden"), "authentication as anonymous forbidden")

      if type(authKey) not in [str, unicode, types.NoneType]:
         raise Exception(self.shrink(WampProtocol.URI_WAMP_ERROR + "invalid-argument"), "authentication key must be a string (was %s)" % str(type(authKey)))

      d = maybeDeferred(self.getAuthSecret, authKey)

      def onGetAuthSecretOk(authSecret, authKey, extra):
         if authKey is not None and authSecret is None:
            raise Exception(self.shrink(WampProtocol.URI_WAMP_ERROR + "no-such-authkey"), "authentication key '%s' does not exist." % authKey)

         ## each authentication request gets a unique authid, which can only be used (later) once!
         ##
         authid = newid()

         ## create authentication challenge
         ##
         info = {}
         info['authid'] = authid
         info['authkey'] = authKey
         info['timestamp'] = utcnow()
         info['sessionid'] = self.session_id
         info['extra'] = extra

         pp = maybeDeferred(self.getAuthPermissions, authKey, extra)

         def onAuthPermissionsOk(res):
            if res is None:
               res = {'permissions': {}}
               res['permissions'] = {'pubsub': [], 'rpc': []}
            info['permissions'] = res['permissions']
            if 'authextra' in res:
                info['authextra'] = res['authextra']

            if authKey:
               ## authenticated session
               ##
               infoser = self.factory._serialize(info)
               sig = self.authSignature(infoser, authSecret)

               self._clientPendingAuth = (info, sig, res)
               return infoser
            else:
               ## anonymous session
               ##
               self._clientPendingAuth = (info, None, res)
               return None

         def onAuthPermissionsError(e):
            raise Exception(self.shrink(WampProtocol.URI_WAMP_ERROR + "auth-permissions-error"), str(e))

         pp.addCallbacks(onAuthPermissionsOk, onAuthPermissionsError)

         return pp

      d.addCallback(onGetAuthSecretOk, authKey, extra)
      return d


   @exportRpc("auth")
   def auth(self, signature = None):
      """
      RPC endpoint for clients to actually authenticate after requesting authentication and computing
      a signature from the authentication challenge.

      :param signature: Authentication signature computed by the client.
      :type signature: str

      :returns list -- A list of permissions the client is granted when authentication was successful.
      """

      ## check authentication state
      ##
      if self._clientAuthenticated:
         raise Exception(self.shrink(WampProtocol.URI_WAMP_ERROR + "already-authenticated"), "already authenticated")
      if self._clientPendingAuth is None:
         raise Exception(self.shrink(WampProtocol.URI_WAMP_ERROR + "no-authentication-requested"), "no authentication previously requested")

      ## check signature
      ##
      if type(signature) not in [str, unicode, types.NoneType]:
         raise Exception(self.shrink(WampProtocol.URI_WAMP_ERROR + "invalid-argument"), "signature must be a string or None (was %s)" % str(type(signature)))
      if self._clientPendingAuth[1] != signature:
         ## delete pending authentication, so that no retries are possible. authid is only valid for 1 try!!
         ## FIXME: drop the connection?
         self._clientPendingAuth = None
         raise Exception(self.shrink(WampProtocol.URI_WAMP_ERROR + "invalid-signature"), "signature for authentication request is invalid")

      ## at this point, the client has successfully authenticated!

      ## get the permissions we determined earlier
      ##
      perms = self._clientPendingAuth[2]

      ## delete auth request and mark client as authenticated
      ##
      authKey = self._clientPendingAuth[0]['authkey']
      self._clientAuthenticated = True
      self._clientPendingAuth = None
      if self._clientAuthTimeoutCall is not None:
         self._clientAuthTimeoutCall.cancel()
         self._clientAuthTimeoutCall = None

      ## fire authentication callback
      ##
      self.onAuthenticated(authKey, perms)

      ## return permissions to client
      ##
      return perms['permissions']



class Call:
   """
   Thin-wrapper for incoming RPCs provided to call handlers registered via

     - registerHandlerMethodForRpc
     - registerHandlerProcedureForRpc
   """


   def __init__(self,
             proto,
             callid,
             uri,
             args,
             extra = None):
      self.proto = proto
      self.callid = callid
      self.uri = uri
      self.args = args
      self.extra = extra
      self.timings = None



class Handler(object):
   """
   A handler for a certain class of messages.
   """


   typeid = None


   def __init__(self, proto, prefixes):
      """
      Remember protocol and prefix map in instance variables.
      """
      self.proto = proto
      self.prefixes = prefixes


   def handleMessage(self, msg_parts):
      """
      Template method for handling a message.

      Check if the correct handler for the message type was
      called. Afterwards, assign all relevant parts of the message to
      instance variables and call the (overridden) method
      _handleMessage to actually handle the message.
      """
      msgtype = msg_parts[0]
      if self.typeid:
         assert msgtype == self.typeid, \
             "Message type %s does not match type id %s" % (msgtype,
                                                            self.typeid)
      else:
         assert False, \
             "No typeid defined for %s" % self.__class__.__name__

      if self._messageIsValid(msg_parts):
         self._parseMessageParts(msg_parts)
         self._handleMessage()


   def _parseMessageParts(self, msg_parts):
      """
      Assign the message parts to instance variables.
      Has to be overridden in subclasses.
      """
      raise NotImplementedError

   def _messageIsValid(self, msg_parts):
      """
      Check if the message parts have expected properties (type, etc.).
      Has to be overridden in subclasses.
      """
      raise NotImplementedError


   def _handleMessage(self):
      """
      Handle a specific kind of message.
      Has to be overridden in subclasses.
      """
      raise NotImplementedError


   def maybeTrackTimings(self, call, msg):
      """
      Track timings, if desired.
      """
      if self.proto.trackTimings:
         self.proto.doTrack(msg)
         call.timings = self.proto.trackedTimings
         self.proto.trackedTimings = Timings()



class CallHandler(Handler):
   """
   A handler for incoming RPC calls.
   """


   typeid = WampProtocol.MESSAGE_TYPEID_CALL


   def _messageIsValid(self, msg_parts):
      callid, uri = msg_parts[1:3]
      if not isinstance(callid, (str, unicode)):
         self.proto._protocolError(
            ("WAMP CALL message with invalid type %s for "
            "<callid>") % type(callid))
         return False

      if not isinstance(uri, (str, unicode)):
         self.proto._protocolError(
            ("WAMP CALL message with invalid type %s for "
            "<uri>") % type(uri))
         return False

      return True


   def _parseMessageParts(self, msg_parts):
      """
      Parse message and create call object.
      """
      self.callid = msg_parts[1]
      self.uri = self.prefixes.resolveOrPass(msg_parts[2]) ### PFX - remove
      self.args = msg_parts[3:]


   def _handleMessage(self):
      """
      Perform the RPC call and attach callbacks to its deferred object.
      """
      call = self._onBeforeCall()
      ## execute incoming RPC
      d = maybeDeferred(self._callProcedure, call)
      ## register callback and errback with extra argument call
      d.addCallbacks(self._onAfterCallSuccess,
                     self._onAfterCallError,
                     callbackArgs = (call,),
                     errbackArgs = (call,))


   def _onBeforeCall(self):
      """
      Create call object to move around call data
      """
      uri, args = self.proto.onBeforeCall(self.callid, self.uri, self.args,
                                          bool(self.proto.procForUri(self.uri)))

      call = Call(self.proto, self.callid, uri, args)
      self.maybeTrackTimings(call, "onBeforeCall")
      return call


   def _callProcedure(self, call):
      """
      Actually performs the call of a procedure invoked via RPC.
      """
      m = self.proto.procForUri(call.uri)
      if m is None:
         raise Exception("no procedure registered for %s" % call.uri)

      obj, method_or_proc, is_handler = m[:3]
      if not is_handler:
         return self._performProcedureCall(call, obj, method_or_proc)
      else:
         call.extra = m[3]
         return self._delegateToRpcHandler(call, obj, method_or_proc)


   def _performProcedureCall(self, call, obj, method_or_proc):
      """
      Perform a RPC method / procedure call.
      """
      cargs = tuple(call.args) if call.args else ()
      if obj:
         ## call object method
         return method_or_proc(obj, *cargs)
      else:
         ## call free-standing function/procedure
         return method_or_proc(*cargs)


   def _delegateToRpcHandler(self, call, obj, method_or_proc):
      """
      Delegate call to RPC handler.
      """
      if obj:
         ## call RPC handler on object
         return method_or_proc(obj, call)
      else:
         ## call free-standing RPC handler
         return method_or_proc(call)


   def _onAfterCallSuccess(self, result, call):
      """
      Execute custom success handler and send call result.
      """
      self.maybeTrackTimings(call, "onAfterCallSuccess")
      call.result = self.proto.onAfterCallSuccess(result, call)

      ## send out WAMP message
      self._sendCallResult(call)


   def _onAfterCallError(self, error, call):
      """
      Execute custom error handler and send call error.
      """
      self.maybeTrackTimings(call, "onAfterCallError")
      ## fire user callback
      call.error = self.proto.onAfterCallError(error, call)

      ## send out WAMP message
      self._sendCallError(call)


   def _sendCallResult(self, call):
      """
      Marshal and send a RPC success result.
      """
      msg = [WampProtocol.MESSAGE_TYPEID_CALL_RESULT, call.callid, call.result]
      try:
         rmsg = self.proto.serializeMessage(msg)
      except:
         raise Exception("call result not JSON serializable")
      else:
         self.proto.sendMessage(rmsg)
         ### XXX self.maybeTrackTimings(call, "onAfterSendCallSuccess")
         if self.proto.trackTimings:
            self.proto.trackedTimings.track("onAfterSendCallSuccess")
         self.proto.onAfterSendCallSuccess(rmsg, call)


   def _sendCallError(self, call):
      """
      Marshal and send a RPC error result.
      """
      killsession = False
      try:
         error_info, killsession = self._extractErrorInfo(call)
         rmsg = self._assembleErrorMessage(call, *error_info)
      except Exception, e:
         rmsg = self._handleProcessingError(call, e)
      finally:
         self._sendMessageAndCleanUp(rmsg, call, killsession)


   def _extractErrorInfo(self, call):
      """
      Extract error information from the call.
      """
      ## get error args and len
      ##
      eargs = call.error.value.args
      num_args = len(eargs)

      if num_args > 4:
         raise Exception("invalid args length %d for exception" % num_args)

      erroruri = (WampProtocol.URI_WAMP_ERROR_GENERIC
                  if num_args < 1
                  else eargs[0])
      errordesc = (WampProtocol.DESC_WAMP_ERROR_GENERIC
                   if num_args < 2
                   else eargs[1])
      # errordetails must be JSON serializable .. if not, we get exception
      # later in sendMessage
      errordetails = (eargs[2]
                      if num_args >= 3
                      else (call.error.getTraceback().splitlines()
                            if self.proto.includeTraceback
                            else None))
      killsession = (eargs[3]
                     if num_args >= 4
                     else False)

      if type(erroruri) not in [str, unicode]:
         raise Exception("invalid type %s for errorUri" % type(erroruri))
      if type(errordesc) not in [str, unicode]:
         raise Exception("invalid type %s for errorDesc" % type(errordesc))
      if type(killsession) not in [bool, types.NoneType]:
         raise Exception("invalid type %s for killSession" %
                         type(killsession))

      return (erroruri, errordesc, errordetails), killsession


   def _assembleErrorMessage(self, call, erroruri, errordesc, errordetails):
      """
      Assemble a WAMP RPC error message.
      """
      if errordetails is not None:
         msg = [WampProtocol.MESSAGE_TYPEID_CALL_ERROR,
                call.callid,
                self.prefixes.shrink(erroruri), ### PFX - remove
                errordesc,
                errordetails]
      else:
         msg = [WampProtocol.MESSAGE_TYPEID_CALL_ERROR,
                call.callid,
                self.prefixes.shrink(erroruri), ### PFX - remove
                errordesc]

      ## serialize message. this can fail if errorDetails is not
      ## serializable
      try:
         rmsg = self.proto.serializeMessage(msg)
      except Exception, e:
         raise Exception(
            "invalid object for errorDetails - not serializable (%s)" %
            str(e))

      return rmsg


   def _handleProcessingError(self, call, e):
      """
      Create a message describing what went wrong during processing an
      exception.
      """
      msg = [WampProtocol.MESSAGE_TYPEID_CALL_ERROR,
             call.callid,
              ### PFX - remove
             self.prefixes.shrink(WampProtocol.URI_WAMP_ERROR_INTERNAL),
             str(e)]

      if self.proto.includeTraceback:
         msg.append(call.error.getTraceback().splitlines())
      result = self.proto.serializeMessage(msg)
      return result


   def _sendMessageAndCleanUp(self, rmsg, call, killsession):
      self.proto.sendMessage(rmsg)
      ### XXX maybeTrackTimings("onAfterSendCallError")
      if self.proto.trackTimings:
         self.proto.doTrack("onAfterSendCallError")
      self.proto.onAfterSendCallError(rmsg, call)

      if killsession:
         self.proto.sendClose(3000,
            "killing WAMP session upon request by application exception")



class CallResultHandler(Handler):
   """
   A handler for to RPC call results.
   """

   typeid = WampProtocol.MESSAGE_TYPEID_CALL_RESULT


   def _messageIsValid(self, msg_parts):
      if len(msg_parts) < 2:
         self.proto._protocolError(
            "WAMP CALL_RESULT message without <callid>")
         return False
      if len(msg_parts) != 3:
         self.proto._protocolError(
            "WAMP CALL_RESULT message with invalid length %d" % len(msg_parts))
         return False

      if type(msg_parts[1]) not in [unicode, str]:
         self.proto._protocolError(
            ("WAMP CALL_RESULT message with invalid type %s for "
            "<callid>") % type(msg_parts[1]))
         return False

      return True


   def _parseMessageParts(self, msg_parts):
      """
      Extract call result from message parts.
      """
      self.callid = str(msg_parts[1])
      self.result = msg_parts[2]


   def _handleMessage(self):
      ## Pop and process Call Deferred
      ##
      d = self.proto.calls.pop(self.callid, None)
      if d:
         ## WAMP CALL_RESULT
         ##
         d.callback(self.result)
      else:
         if self.proto.debugWamp:
            log.msg("callid not found for received call result message")



class CallErrorHandler(Handler):

   typeid = WampProtocol.MESSAGE_TYPEID_CALL_ERROR


   def _messageIsValid(self, msg_parts):
      if len(msg_parts) not in [4, 5]:
         self.proto._protocolError(
            "call error message invalid length %d" % len(msg_parts))
         return False

      ## Error URI
      ##
      if type(msg_parts[2]) not in [unicode, str]:
         self.proto._protocolError(
            "invalid type %s for errorUri in call error message" %
            str(type(msg_parts[2])))
         return False

      ## Error Description
      ##
      if type(msg_parts[3]) not in [unicode, str]:
         self.proto._protocolError(
            "invalid type %s for errorDesc in call error message" %
            str(type(msg_parts[3])))
         return False

      return True


   def _parseMessageParts(self, msg_parts):
      """
      Extract error information from message parts.
      """
      self.callid = str(msg_parts[1])
      self.erroruri = str(msg_parts[2])
      self.errordesc = str(msg_parts[3])

      ## Error Details
      ##
      if len(msg_parts) > 4:
         self.errordetails = msg_parts[4]
      else:
         self.errordetails = None


   def _handleMessage(self):
      """
      Fire Call Error Deferred.
      """
      ##
      ## Pop and process Call Deferred
      d = self.proto.calls.pop(self.callid, None)
      if d:
         e = Exception()
         e.args = (self.erroruri, self.errordesc, self.errordetails)
         d.errback(e)
      else:
         if self.proto.debugWamp:
            log.msg("callid not found for received call error message")

########NEW FILE########
__FILENAME__ = websocket
###############################################################################
##
##  Copyright 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

__all__ = ["createWsUrl",
           "parseWsUrl",
           "connectWS",
           "listenWS",

           "HttpException",
           "ConnectionRequest",
           "ConnectionResponse",
           "Timings",

           "WebSocketProtocol",
           "WebSocketFactory",
           "WebSocketServerProtocol",
           "WebSocketServerFactory",
           "WebSocketClientProtocol",
           "WebSocketClientFactory"]

## The Python urlparse module currently does not contain the ws/wss
## schemes, so we add those dynamically (which is a hack of course).
##
import urlparse
wsschemes = ["ws", "wss"]
urlparse.uses_relative.extend(wsschemes)
urlparse.uses_netloc.extend(wsschemes)
urlparse.uses_params.extend(wsschemes)
urlparse.uses_query.extend(wsschemes)
urlparse.uses_fragment.extend(wsschemes)

import urllib
import binascii
import hashlib
import base64
import struct
import random
import os
from pprint import pformat
from array import array
from collections import deque

from twisted.internet import reactor, protocol
from twisted.python import log

from _version import __version__
from utf8validator import Utf8Validator
from xormasker import XorMaskerNull, createXorMasker
from httpstatus import *
from util import Stopwatch


def createWsUrl(hostname, port = None, isSecure = False, path = None, params = None):
   """
   Create a WebSocket URL from components.

   :param hostname: WebSocket server hostname.
   :type hostname: str
   :param port: WebSocket service port or None (to select default ports 80/443 depending on isSecure).
   :type port: int
   :param isSecure: Set True for secure WebSocket ("wss" scheme).
   :type isSecure: bool
   :param path: Path component of addressed resource (will be properly URL escaped).
   :type path: str
   :param params: A dictionary of key-values to construct the query component of the addressed resource (will be properly URL escaped).
   :type params: dict

   :returns: str -- Constructed WebSocket URL.
   """
   if port is not None:
      netloc = "%s:%d" % (hostname, port)
   else:
      if isSecure:
         netloc = "%s:443" % hostname
      else:
         netloc = "%s:80" % hostname
   if isSecure:
      scheme = "wss"
   else:
      scheme = "ws"
   if path is not None:
      ppath = urllib.quote(path)
   else:
      ppath = "/"
   if params is not None:
      query = urllib.urlencode(params)
   else:
      query = None
   return urlparse.urlunparse((scheme, netloc, ppath, None, query, None))


def parseWsUrl(url):
   """
   Parses as WebSocket URL into it's components and returns a tuple (isSecure, host, port, resource, path, params).

   isSecure is a flag which is True for wss URLs.
   host is the hostname or IP from the URL.
   port is the port from the URL or standard port derived from scheme (ws = 80, wss = 443).
   resource is the /resource name/ from the URL, the /path/ together with the (optional) /query/ component.
   path is the /path/ component properly unescaped.
   params is the /query) component properly unescaped and returned as dictionary.

   :param url: A valid WebSocket URL, i.e. `ws://localhost:9000/myresource?param1=23&param2=666`
   :type url: str

   :returns: tuple -- A tuple (isSecure, host, port, resource, path, params)
   """
   parsed = urlparse.urlparse(url)
   if parsed.scheme not in ["ws", "wss"]:
      raise Exception("invalid WebSocket scheme '%s'" % parsed.scheme)
   if parsed.port is None or parsed.port == "":
      if parsed.scheme == "ws":
         port = 80
      else:
         port = 443
   else:
      port = int(parsed.port)
   if parsed.fragment is not None and parsed.fragment != "":
      raise Exception("invalid WebSocket URL: non-empty fragment '%s" % parsed.fragment)
   if parsed.path is not None and parsed.path != "":
      ppath = parsed.path
      path = urllib.unquote(ppath)
   else:
      ppath = "/"
      path = ppath
   if parsed.query is not None and parsed.query != "":
      resource = ppath + "?" + parsed.query
      params = urlparse.parse_qs(parsed.query)
   else:
      resource = ppath
      params = {}
   return (parsed.scheme == "wss", parsed.hostname, port, resource, path, params)


def connectWS(factory, contextFactory = None, timeout = 30, bindAddress = None):
   """
   Establish WebSocket connection to a server. The connection parameters like target
   host, port, resource and others are provided via the factory.

   :param factory: The WebSocket protocol factory to be used for creating client protocol instances.
   :type factory: An :class:`autobahn.websocket.WebSocketClientFactory` instance.
   :param contextFactory: SSL context factory, required for secure WebSocket connections ("wss").
   :type contextFactory: A `twisted.internet.ssl.ClientContextFactory <http://twistedmatrix.com/documents/current/api/twisted.internet.ssl.ClientContextFactory.html>`_ instance.
   :param timeout: Number of seconds to wait before assuming the connection has failed.
   :type timeout: int
   :param bindAddress: A (host, port) tuple of local address to bind to, or None.
   :type bindAddress: tuple

   :returns: obj -- An object which implements `twisted.interface.IConnector <http://twistedmatrix.com/documents/current/api/twisted.internet.interfaces.IConnector.html>`_.
   """
   if factory.isSecure:
      if contextFactory is None:
         # create default client SSL context factory when none given
         from twisted.internet import ssl
         contextFactory = ssl.ClientContextFactory()
      conn = reactor.connectSSL(factory.host, factory.port, factory, contextFactory, timeout, bindAddress)
   else:
      conn = reactor.connectTCP(factory.host, factory.port, factory, timeout, bindAddress)
   return conn


def listenWS(factory, contextFactory = None, backlog = 50, interface = ''):
   """
   Listen for incoming WebSocket connections from clients. The connection parameters like
   listening port and others are provided via the factory.

   :param factory: The WebSocket protocol factory to be used for creating server protocol instances.
   :type factory: An :class:`autobahn.websocket.WebSocketServerFactory` instance.
   :param contextFactory: SSL context factory, required for secure WebSocket connections ("wss").
   :type contextFactory: A twisted.internet.ssl.ContextFactory.
   :param backlog: Size of the listen queue.
   :type backlog: int
   :param interface: The interface (derived from hostname given) to bind to, defaults to '' (all).
   :type interface: str

   :returns: obj -- An object that implements `twisted.interface.IListeningPort <http://twistedmatrix.com/documents/current/api/twisted.internet.interfaces.IListeningPort.html>`_.
   """
   if factory.isSecure:
      if contextFactory is None:
         raise Exception("Secure WebSocket listen requested, but no SSL context factory given")
      listener = reactor.listenSSL(factory.port, factory, contextFactory, backlog, interface)
   else:
      listener = reactor.listenTCP(factory.port, factory, backlog, interface)
   return listener


class FrameHeader:
   """
   Thin-wrapper for storing WebSocket frame metadata.

   FOR INTERNAL USE ONLY!
   """

   def __init__(self, opcode, fin, rsv, length, mask):
      """
      Constructor.

      :param opcode: Frame opcode (0-15).
      :type opcode: int
      :param fin: Frame FIN flag.
      :type fin: bool
      :param rsv: Frame reserved flags (0-7).
      :type rsv: int
      :param length: Frame payload length.
      :type length: int
      :param mask: Frame mask (binary string) or None.
      :type mask: str
      """
      self.opcode = opcode
      self.fin = fin
      self.rsv = rsv
      self.length = length
      self.mask = mask


class HttpException:
   """
   Throw an instance of this class to deny a WebSocket connection
   during handshake in :meth:`autobahn.websocket.WebSocketServerProtocol.onConnect`.
   You can find definitions of HTTP status codes in module :mod:`autobahn.httpstatus`.
   """

   def __init__(self, code, reason):
      """
      Constructor.

      :param code: HTTP error code.
      :type code: int
      :param reason: HTTP error reason.
      :type reason: str
      """
      self.code = code
      self.reason = reason


class ConnectionRequest:
   """
   Thin-wrapper for WebSocket connection request information
   provided in :meth:`autobahn.websocket.WebSocketServerProtocol.onConnect` when a WebSocket
   client establishes a connection to a WebSocket server.
   """
   def __init__(self, peer, peerstr, headers, host, path, params, version, origin, protocols, extensions):
      """
      Constructor.

      :param peer: IP address/port of the connecting client.
      :type peer: object
      :param peerstr: IP address/port of the connecting client as string.
      :type peerstr: str
      :param headers: HTTP headers from opening handshake request.
      :type headers: dict
      :param host: Host from opening handshake HTTP header.
      :type host: str
      :param path: Path from requested HTTP resource URI. For example, a resource URI of `/myservice?foo=23&foo=66&bar=2` will be parsed to `/myservice`.
      :type path: str
      :param params: Query parameters (if any) from requested HTTP resource URI. For example, a resource URI of `/myservice?foo=23&foo=66&bar=2` will be parsed to `{'foo': ['23', '66'], 'bar': ['2']}`.
      :type params: dict of arrays of strings
      :param version: The WebSocket protocol version the client announced (and will be spoken, when connection is accepted).
      :type version: int
      :param origin: The WebSocket origin header or None. Note that this only a reliable source of information for browser clients!
      :type origin: str
      :param protocols: The WebSocket (sub)protocols the client announced. You must select and return one of those (or None) in :meth:`autobahn.websocket.WebSocketServerProtocol.onConnect`.
      :type protocols: array of strings
      :param extensions: The WebSocket extensions the client requested and the server accepted (and thus will be spoken, when WS connection is established).
      :type extensions: array of strings
      """
      self.peer = peer
      self.peerstr = peerstr
      self.headers = headers
      self.host = host
      self.path = path
      self.params = params
      self.version = version
      self.origin = origin
      self.protocols = protocols
      self.extensions = extensions


class ConnectionResponse():
   """
   Thin-wrapper for WebSocket connection response information
   provided in :meth:`autobahn.websocket.WebSocketClientProtocol.onConnect` when a WebSocket
   client has established a connection to a WebSocket server.
   """
   def __init__(self, peer, peerstr, headers, version, protocol, extensions):
      """
      Constructor.

      :param peer: IP address/port of the connected server.
      :type peer: object
      :param peerstr: IP address/port of the connected server as string.
      :type peerstr: str
      :param headers: HTTP headers from opening handshake response.
      :type headers: dict
      :param version: The WebSocket protocol version that is spoken.
      :type version: int
      :param protocol: The WebSocket (sub)protocol in use.
      :type protocol: str
      :param extensions: The WebSocket extensions in use.
      :type extensions: array of strings
      """
      self.peer = peer
      self.peerstr = peerstr
      self.headers = headers
      self.version = version
      self.protocol = protocol
      self.extensions = extensions


def parseHttpHeader(data):
   """
   Parses the beginning of a HTTP request header (the data up to the \n\n line) into a pair
   of status line and HTTP headers dictionary.
   Header keys are normalized to all-lower-case.

   FOR INTERNAL USE ONLY!

   :param data: The HTTP header data up to the \n\n line.
   :type data: str

   :returns: tuple -- Tuple of HTTP status line, headers and headers count.
   """
   raw = data.splitlines()
   http_status_line = raw[0].strip()
   http_headers = {}
   http_headers_cnt = {}
   for h in raw[1:]:
      i = h.find(":")
      if i > 0:
         ## HTTP header keys are case-insensitive
         key = h[:i].strip().lower()

         ## not sure if UTF-8 is allowed for HTTP header values..
         value = h[i+1:].strip().decode("utf-8")

         ## handle HTTP headers split across multiple lines
         if http_headers.has_key(key):
            http_headers[key] += ", %s" % value
            http_headers_cnt[key] += 1
         else:
            http_headers[key] = value
            http_headers_cnt[key] = 1
      else:
         # skip bad HTTP header
         pass
   return (http_status_line, http_headers, http_headers_cnt)


class Timings:
   """
   Helper class to track timings by key. This class also supports item access,
   iteration and conversion to string.
   """

   def __init__(self):
      self._stopwatch = Stopwatch()
      self._timings = {}

   def track(self, key):
      """
      Track elapsed for key.

      :param key: Key under which to track the timing.
      :type key: str
      """
      self._timings[key] = self._stopwatch.elapsed()

   def diff(self, startKey, endKey, format = True):
      """
      Get elapsed difference between two previously tracked keys.

      :param startKey: First key for interval (older timestamp).
      :type startKey: str
      :param endKey: Second key for interval (younger timestamp).
      :type endKey: str
      :param format: If `True`, format computed time period and return string.
      :type format: bool

      :returns: float or str -- Computed time period in seconds (or formatted string).
      """
      if self._timings.has_key(endKey) and self._timings.has_key(startKey):
         d = self._timings[endKey] - self._timings[startKey]
         if format:
            if d < 0.00001: # 10us
               s = "%d ns" % round(d * 1000000000.)
            elif d < 0.01: # 10ms
               s = "%d us" % round(d * 1000000.)
            elif d < 10: # 10s
               s = "%d ms" % round(d * 1000.)
            else:
               s = "%d s" % round(d)
            return s.rjust(8)
         else:
            return d
      else:
         if format:
            return "n.a.".rjust(8)
         else:
            return None

   def __getitem__(self, key):
      return self._timings.get(key, None)

   def __iter__(self):
      return self._timings.__iter__(self)

   def __str__(self):
      return pformat(self._timings)



class WebSocketProtocol(protocol.Protocol):
   """
   A Twisted Protocol class for WebSocket. This class is used by both WebSocket
   client and server protocol version. It is unusable standalone, for example
   the WebSocket initial handshake is implemented in derived class differently
   for clients and servers.
   """

   SUPPORTED_SPEC_VERSIONS = [0, 10, 11, 12, 13, 14, 15, 16, 17, 18]
   """
   WebSocket protocol spec (draft) versions supported by this implementation.
   Use of version 18 indicates RFC6455. Use of versions < 18 indicate actual
   draft spec versions (Hybi-Drafts). Use of version 0 indicates Hixie-76.
   """

   SUPPORTED_PROTOCOL_VERSIONS = [0, 8, 13]
   """
   WebSocket protocol versions supported by this implementation. For Hixie-76,
   there is no protocol version announced in HTTP header, and we just use the
   draft version (0) in this case.
   """

   SPEC_TO_PROTOCOL_VERSION = {0: 0, 10: 8, 11: 8, 12: 8, 13: 13, 14: 13, 15: 13, 16: 13, 17: 13, 18: 13}
   """
   Mapping from protocol spec (draft) version to protocol version.  For Hixie-76,
   there is no protocol version announced in HTTP header, and we just use the
   pseudo protocol version 0 in this case.
   """

   PROTOCOL_TO_SPEC_VERSION = {0: 0, 8: 12, 13: 18}
   """
   Mapping from protocol version to the latest protocol spec (draft) version
   using that protocol version.  For Hixie-76, there is no protocol version
   announced in HTTP header, and we just use the draft version (0) in this case.
   """

   DEFAULT_SPEC_VERSION = 18
   """
   Default WebSocket protocol spec version this implementation speaks: final RFC6455.
   """

   DEFAULT_ALLOW_HIXIE76 = False
   """
   By default, this implementation will not allow to speak the obsoleted
   Hixie-76 protocol version. That protocol version has security issues, but
   is still spoken by some clients. Enable at your own risk! Enabling can be
   done by using setProtocolOptions() on the factories for clients and servers.
   """

   _WS_MAGIC = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"
   """
   Protocol defined magic used during WebSocket handshake (used in Hybi-drafts
   and final RFC6455.
   """

   _QUEUED_WRITE_DELAY = 0.00001
   """
   For synched/chopped writes, this is the reactor reentry delay in seconds.
   """

   MESSAGE_TYPE_TEXT = 1
   """
   WebSocket text message type (UTF-8 payload).
   """

   MESSAGE_TYPE_BINARY = 2
   """
   WebSocket binary message type (arbitrary binary payload).
   """

   ## WebSocket protocol state:
   ## STATE_CONNECTING => STATE_OPEN => STATE_CLOSING => STATE_CLOSED
   ##
   STATE_CLOSED = 0
   STATE_CONNECTING = 1
   STATE_CLOSING = 2
   STATE_OPEN = 3

   ## Streaming Send State
   SEND_STATE_GROUND = 0
   SEND_STATE_MESSAGE_BEGIN = 1
   SEND_STATE_INSIDE_MESSAGE = 2
   SEND_STATE_INSIDE_MESSAGE_FRAME = 3

   ## WebSocket protocol close codes
   ##
   CLOSE_STATUS_CODE_NORMAL = 1000
   """Normal close of connection."""

   CLOSE_STATUS_CODE_GOING_AWAY = 1001
   """Going away."""

   CLOSE_STATUS_CODE_PROTOCOL_ERROR = 1002
   """Protocol error."""

   CLOSE_STATUS_CODE_UNSUPPORTED_DATA = 1003
   """Unsupported data."""

   CLOSE_STATUS_CODE_RESERVED1 = 1004
   """RESERVED"""

   CLOSE_STATUS_CODE_NULL = 1005 # MUST NOT be set in close frame!
   """No status received. (MUST NOT be used as status code when sending a close)."""

   CLOSE_STATUS_CODE_ABNORMAL_CLOSE = 1006 # MUST NOT be set in close frame!
   """Abnormal close of connection. (MUST NOT be used as status code when sending a close)."""

   CLOSE_STATUS_CODE_INVALID_PAYLOAD = 1007
   """Invalid frame payload data."""

   CLOSE_STATUS_CODE_POLICY_VIOLATION = 1008
   """Policy violation."""

   CLOSE_STATUS_CODE_MESSAGE_TOO_BIG = 1009
   """Message too big."""

   CLOSE_STATUS_CODE_MANDATORY_EXTENSION = 1010
   """Mandatory extension."""

   CLOSE_STATUS_CODE_INTERNAL_ERROR = 1011
   """The peer encountered an unexpected condition or internal error."""

   CLOSE_STATUS_CODE_TLS_HANDSHAKE_FAILED = 1015 # MUST NOT be set in close frame!
   """TLS handshake failed, i.e. server certificate could not be verified. (MUST NOT be used as status code when sending a close)."""

   CLOSE_STATUS_CODES_ALLOWED = [CLOSE_STATUS_CODE_NORMAL,
                                 CLOSE_STATUS_CODE_GOING_AWAY,
                                 CLOSE_STATUS_CODE_PROTOCOL_ERROR,
                                 CLOSE_STATUS_CODE_UNSUPPORTED_DATA,
                                 CLOSE_STATUS_CODE_INVALID_PAYLOAD,
                                 CLOSE_STATUS_CODE_POLICY_VIOLATION,
                                 CLOSE_STATUS_CODE_MESSAGE_TOO_BIG,
                                 CLOSE_STATUS_CODE_MANDATORY_EXTENSION,
                                 CLOSE_STATUS_CODE_INTERNAL_ERROR]
   """Status codes allowed to send in close."""


   def onOpen(self):
      """
      Callback when initial WebSocket handshake was completed. Now you may send messages.
      Default implementation does nothing. Override in derived class.

      Modes: Hybi, Hixie
      """
      if self.debugCodePaths:
         log.msg("WebSocketProtocol.onOpen")


   def onMessageBegin(self, opcode):
      """
      Callback when receiving a new message has begun. Default implementation will
      prepare to buffer message frames. Override in derived class.

      Modes: Hybi, Hixie

      :param opcode: Opcode of message.
      :type opcode: int
      """
      self.message_opcode = opcode
      self.message_data = []
      self.message_data_total_length = 0


   def onMessageFrameBegin(self, length, reserved):
      """
      Callback when receiving a new message frame has begun. Default implementation will
      prepare to buffer message frame data. Override in derived class.

      Modes: Hybi

      :param length: Payload length of message frame which is to be received.
      :type length: int
      :param reserved: Reserved bits set in frame (an integer from 0 to 7).
      :type reserved: int
      """
      self.frame_length = length
      self.frame_reserved = reserved
      self.frame_data = []
      self.message_data_total_length += length
      if not self.failedByMe:
         if self.maxMessagePayloadSize > 0 and self.message_data_total_length > self.maxMessagePayloadSize:
            self.wasMaxMessagePayloadSizeExceeded = True
            self.failConnection(WebSocketProtocol.CLOSE_STATUS_CODE_MESSAGE_TOO_BIG, "message exceeds payload limit of %d octets" % self.maxMessagePayloadSize)
         elif self.maxFramePayloadSize > 0 and length > self.maxFramePayloadSize:
            self.wasMaxFramePayloadSizeExceeded = True
            self.failConnection(WebSocketProtocol.CLOSE_STATUS_CODE_POLICY_VIOLATION, "frame exceeds payload limit of %d octets" % self.maxFramePayloadSize)


   def onMessageFrameData(self, payload):
      """
      Callback when receiving data witin message frame. Default implementation will
      buffer data for frame. Override in derived class.

      Modes: Hybi, Hixie

      Notes:
        - For Hixie mode, this method is slightly misnamed for historic reasons.

      :param payload: Partial payload for message frame.
      :type payload: str
      """
      if not self.failedByMe:
         if self.websocket_version == 0:
            self.message_data_total_length += len(payload)
            if self.maxMessagePayloadSize > 0 and self.message_data_total_length > self.maxMessagePayloadSize:
               self.wasMaxMessagePayloadSizeExceeded = True
               self.failConnection(WebSocketProtocol.CLOSE_STATUS_CODE_MESSAGE_TOO_BIG, "message exceeds payload limit of %d octets" % self.maxMessagePayloadSize)
            self.message_data.append(payload)
         else:
            self.frame_data.append(payload)


   def onMessageFrameEnd(self):
      """
      Callback when a message frame has been completely received. Default implementation
      will flatten the buffered frame data and callback onMessageFrame. Override
      in derived class.

      Modes: Hybi
      """
      if not self.failedByMe:
         self.onMessageFrame(self.frame_data, self.frame_reserved)

      self.frame_data = None


   def onMessageFrame(self, payload, reserved):
      """
      Callback fired when complete message frame has been received. Default implementation
      will buffer frame for message. Override in derived class.

      Modes: Hybi

      :param payload: Message frame payload.
      :type payload: list of str
      :param reserved: Reserved bits set in frame (an integer from 0 to 7).
      :type reserved: int
      """
      if not self.failedByMe:
         self.message_data.extend(payload)


   def onMessageEnd(self):
      """
      Callback when a message has been completely received. Default implementation
      will flatten the buffered frames and callback onMessage. Override
      in derived class.

      Modes: Hybi, Hixie
      """
      if not self.failedByMe:
         payload = ''.join(self.message_data)
         if self.trackedTimings:
            self.trackedTimings.track("onMessage")
         self.onMessage(payload, self.message_opcode == WebSocketProtocol.MESSAGE_TYPE_BINARY)

      self.message_data = None


   def onMessage(self, payload, binary):
      """
      Callback when a complete message was received. Default implementation does nothing.
      Override in derived class.

      Modes: Hybi, Hixie

      :param payload: Message payload (UTF-8 encoded text string or binary string). Can also be an empty string, when message contained no payload.
      :type payload: str
      :param binary: If True, payload is binary, otherwise text.
      :type binary: bool
      """
      if self.debug:
         log.msg("WebSocketProtocol.onMessage")


   def onPing(self, payload):
      """
      Callback when Ping was received. Default implementation responds
      with a Pong. Override in derived class.

      Modes: Hybi

      :param payload: Payload of Ping, when there was any. Can be arbitrary, up to 125 octets.
      :type payload: str
      """
      if self.debug:
         log.msg("WebSocketProtocol.onPing")
      if self.state == WebSocketProtocol.STATE_OPEN:
         self.sendPong(payload)


   def onPong(self, payload):
      """
      Callback when Pong was received. Default implementation does nothing.
      Override in derived class.

      Modes: Hybi

      :param payload: Payload of Pong, when there was any. Can be arbitrary, up to 125 octets.
      """
      if self.debug:
         log.msg("WebSocketProtocol.onPong")


   def onClose(self, wasClean, code, reason):
      """
      Callback when the connection has been closed. Override in derived class.

      Modes: Hybi, Hixie

      :param wasClean: True, iff the connection was closed cleanly.
      :type wasClean: bool
      :param code: None or close status code (sent by peer), if there was one (:class:`WebSocketProtocol`.CLOSE_STATUS_CODE_*).
      :type code: int
      :param reason: None or close reason (sent by peer) (when present, a status code MUST have been also be present).
      :type reason: str
      """
      if self.debugCodePaths:
         s = "WebSocketProtocol.onClose:\n"
         s += "wasClean=%s\n" % wasClean
         s += "code=%s\n" % code
         s += "reason=%s\n" % reason
         s += "self.closedByMe=%s\n" % self.closedByMe
         s += "self.failedByMe=%s\n" % self.failedByMe
         s += "self.droppedByMe=%s\n" % self.droppedByMe
         s += "self.wasClean=%s\n" % self.wasClean
         s += "self.wasNotCleanReason=%s\n" % self.wasNotCleanReason
         s += "self.localCloseCode=%s\n" % self.localCloseCode
         s += "self.localCloseReason=%s\n" % self.localCloseReason
         s += "self.remoteCloseCode=%s\n" % self.remoteCloseCode
         s += "self.remoteCloseReason=%s\n" % self.remoteCloseReason
         log.msg(s)


   def onCloseFrame(self, code, reasonRaw):
      """
      Callback when a Close frame was received. The default implementation answers by
      sending a Close when no Close was sent before. Otherwise it drops
      the TCP connection either immediately (when we are a server) or after a timeout
      (when we are a client and expect the server to drop the TCP).

      Modes: Hybi, Hixie

      Notes:
        - For Hixie mode, this method is slightly misnamed for historic reasons.
        - For Hixie mode, code and reasonRaw are silently ignored.

      :param code: None or close status code, if there was one (:class:`WebSocketProtocol`.CLOSE_STATUS_CODE_*).
      :type code: int
      :param reason: None or close reason (when present, a status code MUST have been also be present).
      :type reason: str
      """
      if self.debugCodePaths:
         log.msg("WebSocketProtocol.onCloseFrame")

      self.remoteCloseCode = code
      self.remoteCloseReason = reasonRaw

      ## reserved close codes: 0-999, 1004, 1005, 1006, 1011-2999, >= 5000
      ##
      if code is not None and (code < 1000 or (code >= 1000 and code <= 2999 and code not in WebSocketProtocol.CLOSE_STATUS_CODES_ALLOWED) or code >= 5000):
         if self.protocolViolation("invalid close code %d" % code):
            return True

      ## closing reason
      ##
      if reasonRaw is not None:
         ## we use our own UTF-8 validator to get consistent and fully conformant
         ## UTF-8 validation behavior
         u = Utf8Validator()
         val = u.validate(reasonRaw)
         if not val[0]:
            if self.invalidPayload("invalid close reason (non-UTF-8 payload)"):
               return True

      if self.state == WebSocketProtocol.STATE_CLOSING:
         ## We already initiated the closing handshake, so this
         ## is the peer's reply to our close frame.

         ## cancel any closing HS timer if present
         ##
         if self.closeHandshakeTimeoutCall is not None:
            if self.debugCodePaths:
               log.msg("closeHandshakeTimeoutCall.cancel")
            self.closeHandshakeTimeoutCall.cancel()
            self.closeHandshakeTimeoutCall = None

         self.wasClean = True

         if self.isServer:
            ## When we are a server, we immediately drop the TCP.
            self.dropConnection(abort = True)
         else:
            ## When we are a client, the server should drop the TCP
            ## If that doesn't happen, we do. And that will set wasClean = False.
            if self.serverConnectionDropTimeout > 0:
               self.serverConnectionDropTimeoutCall = reactor.callLater(self.serverConnectionDropTimeout, self.onServerConnectionDropTimeout)

      elif self.state == WebSocketProtocol.STATE_OPEN:
         ## The peer initiates a closing handshake, so we reply
         ## by sending close frame.

         self.wasClean = True

         if self.websocket_version == 0:
            self.sendCloseFrame(isReply = True)
         else:
            ## Either reply with same code/reason, or code == NORMAL/reason=None
            if self.echoCloseCodeReason:
               self.sendCloseFrame(code = code, reasonUtf8 = reason.encode("UTF-8"), isReply = True)
            else:
               self.sendCloseFrame(code = WebSocketProtocol.CLOSE_STATUS_CODE_NORMAL, isReply = True)

         if self.isServer:
            ## When we are a server, we immediately drop the TCP.
            self.dropConnection(abort = False)
         else:
            ## When we are a client, we expect the server to drop the TCP,
            ## and when the server fails to do so, a timeout in sendCloseFrame()
            ## will set wasClean = False back again.
            pass

      else:
         ## STATE_CONNECTING, STATE_CLOSED
         raise Exception("logic error")


   def onServerConnectionDropTimeout(self):
      """
      We (a client) expected the peer (a server) to drop the connection,
      but it didn't (in time self.serverConnectionDropTimeout).
      So we drop the connection, but set self.wasClean = False.

      Modes: Hybi, Hixie
      """
      self.serverConnectionDropTimeoutCall = None
      if self.state != WebSocketProtocol.STATE_CLOSED:
         if self.debugCodePaths:
            log.msg("onServerConnectionDropTimeout")
         self.wasClean = False
         self.wasNotCleanReason = "server did not drop TCP connection (in time)"
         self.wasServerConnectionDropTimeout = True
         self.dropConnection(abort = True)
      else:
         if self.debugCodePaths:
            log.msg("skipping onServerConnectionDropTimeout since connection is already closed")


   def onOpenHandshakeTimeout(self):
      """
      We expected the peer to complete the opening handshake with to us.
      It didn't do so (in time self.openHandshakeTimeout).
      So we drop the connection, but set self.wasClean = False.

      Modes: Hybi, Hixie
      """
      self.openHandshakeTimeoutCall = None
      if self.state == WebSocketProtocol.STATE_CONNECTING:
         if self.debugCodePaths:
            log.msg("onOpenHandshakeTimeout fired")
         self.wasClean = False
         self.wasNotCleanReason = "peer did not finish (in time) the opening handshake"
         self.wasOpenHandshakeTimeout = True
         self.dropConnection(abort = True)
      elif self.state == WebSocketProtocol.STATE_OPEN:
         if self.debugCodePaths:
            log.msg("skipping onOpenHandshakeTimeout since WebSocket connection is open (opening handshake already finished)")
      elif self.state == WebSocketProtocol.STATE_CLOSING:
         if self.debugCodePaths:
            log.msg("skipping onOpenHandshakeTimeout since WebSocket connection is closing")
      elif self.state == WebSocketProtocol.STATE_CLOSED:
         if self.debugCodePaths:
            log.msg("skipping onOpenHandshakeTimeout since WebSocket connection already closed")
      else:
         # should not arrive here
         raise Exception("logic error")


   def onCloseHandshakeTimeout(self):
      """
      We expected the peer to respond to us initiating a close handshake. It didn't
      respond (in time self.closeHandshakeTimeout) with a close response frame though.
      So we drop the connection, but set self.wasClean = False.

      Modes: Hybi, Hixie
      """
      self.closeHandshakeTimeoutCall = None
      if self.state != WebSocketProtocol.STATE_CLOSED:
         if self.debugCodePaths:
            log.msg("onCloseHandshakeTimeout fired")
         self.wasClean = False
         self.wasNotCleanReason = "peer did not respond (in time) in closing handshake"
         self.wasCloseHandshakeTimeout = True
         self.dropConnection(abort = True)
      else:
         if self.debugCodePaths:
            log.msg("skipping onCloseHandshakeTimeout since connection is already closed")


   def dropConnection(self, abort = False):
      """
      Drop the underlying TCP connection. For abort parameter, see:

        * http://twistedmatrix.com/documents/current/core/howto/servers.html#auto2
        * https://github.com/tavendo/AutobahnPython/issues/96

      Modes: Hybi, Hixie
      """
      if self.state != WebSocketProtocol.STATE_CLOSED:
         if self.debugCodePaths:
            log.msg("dropping connection")
         self.droppedByMe = True
         self.state = WebSocketProtocol.STATE_CLOSED

         if abort:
            self.transport.abortConnection()
         else:
            self.transport.loseConnection()
      else:
         if self.debugCodePaths:
            log.msg("skipping dropConnection since connection is already closed")


   def failConnection(self, code = CLOSE_STATUS_CODE_GOING_AWAY, reason = "Going Away"):
      """
      Fails the WebSocket connection.

      Modes: Hybi, Hixie

      Notes:
        - For Hixie mode, the code and reason are silently ignored.
      """
      if self.state != WebSocketProtocol.STATE_CLOSED:
         if self.debugCodePaths:
            log.msg("Failing connection : %s - %s" % (code, reason))
         self.failedByMe = True
         if self.failByDrop:
            ## brutally drop the TCP connection
            self.wasClean = False
            self.wasNotCleanReason = "I failed the WebSocket connection by dropping the TCP connection"
            self.dropConnection(abort = True)
         else:
            ## perform WebSocket closing handshake
            if self.state != WebSocketProtocol.STATE_CLOSING:
               self.sendCloseFrame(code = code, reasonUtf8 = reason.encode("UTF-8"), isReply = False)
            else:
               if self.debugCodePaths:
                  log.msg("skipping failConnection since connection is already closing")
      else:
         if self.debugCodePaths:
            log.msg("skipping failConnection since connection is already closed")


   def protocolViolation(self, reason):
      """
      Fired when a WebSocket protocol violation/error occurs.

      Modes: Hybi, Hixie

      Notes:
        - For Hixie mode, reason is silently ignored.

      :param reason: Protocol violation that was encountered (human readable).
      :type reason: str

      :returns: bool -- True, when any further processing should be discontinued.
      """
      if self.debugCodePaths:
         log.msg("Protocol violation : %s" % reason)
      self.failConnection(WebSocketProtocol.CLOSE_STATUS_CODE_PROTOCOL_ERROR, reason)
      if self.failByDrop:
         return True
      else:
         ## if we don't immediately drop the TCP, we need to skip the invalid frame
         ## to continue to later receive the closing handshake reply
         return False


   def invalidPayload(self, reason):
      """
      Fired when invalid payload is encountered. Currently, this only happens
      for text message when payload is invalid UTF-8 or close frames with
      close reason that is invalid UTF-8.

      Modes: Hybi, Hixie

      Notes:
        - For Hixie mode, reason is silently ignored.

      :param reason: What was invalid for the payload (human readable).
      :type reason: str

      :returns: bool -- True, when any further processing should be discontinued.
      """
      if self.debugCodePaths:
         log.msg("Invalid payload : %s" % reason)
      self.failConnection(WebSocketProtocol.CLOSE_STATUS_CODE_INVALID_PAYLOAD, reason)
      if self.failByDrop:
         return True
      else:
         ## if we don't immediately drop the TCP, we need to skip the invalid frame
         ## to continue to later receive the closing handshake reply
         return False


   def setTrackTimings(self, enable):
      """
      Enable/disable tracking of detailed timings.

      :param enable: Turn time tracking on/off.
      :type enable: bool
      """
      if not hasattr(self, 'trackTimings') or self.trackTimings != enable:
         self.trackTimings = enable
         if self.trackTimings:
            self.trackedTimings = Timings()
         else:
            self.trackedTimings = None


   def doTrack(self, msg):
      if not hasattr(self, 'trackTimings') or not self.trackTimings:
         return
      self.trackedTimings.track(msg)


   def connectionMade(self):
      """
      This is called by Twisted framework when a new TCP connection has been established
      and handed over to a Protocol instance (an instance of this class).

      Modes: Hybi, Hixie
      """

      ## copy default options from factory (so we are not affected by changed on those)
      ##

      self.debug = self.factory.debug
      self.debugCodePaths = self.factory.debugCodePaths

      self.logOctets = self.factory.logOctets
      self.logFrames = self.factory.logFrames

      self.setTrackTimings(self.factory.trackTimings)

      self.allowHixie76 = self.factory.allowHixie76
      self.utf8validateIncoming = self.factory.utf8validateIncoming
      self.applyMask = self.factory.applyMask
      self.maxFramePayloadSize = self.factory.maxFramePayloadSize
      self.maxMessagePayloadSize = self.factory.maxMessagePayloadSize
      self.autoFragmentSize = self.factory.autoFragmentSize
      self.failByDrop = self.factory.failByDrop
      self.echoCloseCodeReason = self.factory.echoCloseCodeReason
      self.openHandshakeTimeout = self.factory.openHandshakeTimeout
      self.closeHandshakeTimeout = self.factory.closeHandshakeTimeout
      self.tcpNoDelay = self.factory.tcpNoDelay

      if self.isServer:
         self.versions = self.factory.versions
         self.webStatus = self.factory.webStatus
         self.requireMaskedClientFrames = self.factory.requireMaskedClientFrames
         self.maskServerFrames = self.factory.maskServerFrames
      else:
         self.version = self.factory.version
         self.acceptMaskedServerFrames = self.factory.acceptMaskedServerFrames
         self.maskClientFrames = self.factory.maskClientFrames
         self.serverConnectionDropTimeout = self.factory.serverConnectionDropTimeout

      ## Set "Nagle"
      self.transport.setTcpNoDelay(self.tcpNoDelay)

      ## the peer we are connected to
      self.peer = self.transport.getPeer()
      self.peerstr = "%s:%d" % (self.peer.host, self.peer.port)

      ## initial state
      self.state = WebSocketProtocol.STATE_CONNECTING
      self.send_state = WebSocketProtocol.SEND_STATE_GROUND
      self.data = ""

      ## for chopped/synched sends, we need to queue to maintain
      ## ordering when recalling the reactor to actually "force"
      ## the octets to wire (see test/trickling in the repo)
      self.send_queue = deque()
      self.triggered = False

      ## incremental UTF8 validator
      self.utf8validator = Utf8Validator()

      ## track when frame/message payload sizes (incoming) were exceeded
      self.wasMaxFramePayloadSizeExceeded = False
      self.wasMaxMessagePayloadSizeExceeded = False

      ## the following vars are related to connection close handling/tracking

      # True, iff I have initiated closing HS (that is, did send close first)
      self.closedByMe = False

      # True, iff I have failed the WS connection (i.e. due to protocol error)
      # Failing can be either by initiating close HS or brutal drop (this is
      # controlled by failByDrop option)
      self.failedByMe = False

      # True, iff I dropped the TCP connection (called transport.loseConnection())
      self.droppedByMe = False

      # True, iff full WebSocket closing handshake was performed (close frame sent
      # and received) _and_ the server dropped the TCP (which is its responsibility)
      self.wasClean = False

      # When self.wasClean = False, the reason (what happened)
      self.wasNotCleanReason = None

      # When we are a client, and we expected the server to drop the TCP, but that
      # didn't happen in time, this gets True
      self.wasServerConnectionDropTimeout = False

      # When the initial WebSocket opening handshake times out, this gets True
      self.wasOpenHandshakeTimeout = False

      # When we initiated a closing handshake, but the peer did not respond in
      # time, this gets True
      self.wasCloseHandshakeTimeout = False

      # The close code I sent in close frame (if any)
      self.localCloseCode = None

      # The close reason I sent in close frame (if any)
      self.localCloseReason = None

      # The close code the peer sent me in close frame (if any)
      self.remoteCloseCode = None

      # The close reason the peer sent me in close frame (if any)
      self.remoteCloseReason = None

      # timers, which might get set up later, and remembered here to get canceled
      # when appropriate
      if not self.isServer:
         self.serverConnectionDropTimeoutCall = None
      self.openHandshakeTimeoutCall = None
      self.closeHandshakeTimeoutCall = None

      # set opening handshake timeout handler
      if self.openHandshakeTimeout > 0:
         self.openHandshakeTimeoutCall = reactor.callLater(self.openHandshakeTimeout, self.onOpenHandshakeTimeout)


   def connectionLost(self, reason):
      """
      This is called by Twisted framework when a TCP connection was lost.

      Modes: Hybi, Hixie
      """
      ## cancel any server connection drop timer if present
      ##
      if not self.isServer and self.serverConnectionDropTimeoutCall is not None:
         if self.debugCodePaths:
            log.msg("serverConnectionDropTimeoutCall.cancel")
         self.serverConnectionDropTimeoutCall.cancel()
         self.serverConnectionDropTimeoutCall = None

      self.state = WebSocketProtocol.STATE_CLOSED
      if not self.wasClean:
         if not self.droppedByMe and self.wasNotCleanReason is None:
            self.wasNotCleanReason = "peer dropped the TCP connection without previous WebSocket closing handshake"
         self.onClose(self.wasClean, WebSocketProtocol.CLOSE_STATUS_CODE_ABNORMAL_CLOSE, "connection was closed uncleanly (%s)" % self.wasNotCleanReason)
      else:
         self.onClose(self.wasClean, self.remoteCloseCode, self.remoteCloseReason)


   def logRxOctets(self, data):
      """
      Hook fired right after raw octets have been received, but only when self.logOctets == True.

      Modes: Hybi, Hixie
      """
      log.msg("RX Octets from %s : octets = %s" % (self.peerstr, binascii.b2a_hex(data)))


   def logTxOctets(self, data, sync):
      """
      Hook fired right after raw octets have been sent, but only when self.logOctets == True.

      Modes: Hybi, Hixie
      """
      log.msg("TX Octets to %s : sync = %s, octets = %s" % (self.peerstr, sync, binascii.b2a_hex(data)))


   def logRxFrame(self, frameHeader, payload):
      """
      Hook fired right after WebSocket frame has been received and decoded, but only when self.logFrames == True.

      Modes: Hybi
      """
      data = ''.join(payload)
      info = (self.peerstr,
              frameHeader.fin,
              frameHeader.rsv,
              frameHeader.opcode,
              binascii.b2a_hex(frameHeader.mask) if frameHeader.mask else "-",
              frameHeader.length,
              data if frameHeader.opcode == 1 else binascii.b2a_hex(data))

      log.msg("RX Frame from %s : fin = %s, rsv = %s, opcode = %s, mask = %s, length = %s, payload = %s" % info)


   def logTxFrame(self, frameHeader, payload, repeatLength, chopsize, sync):
      """
      Hook fired right after WebSocket frame has been encoded and sent, but only when self.logFrames == True.

      Modes: Hybi
      """
      info = (self.peerstr,
              frameHeader.fin,
              frameHeader.rsv,
              frameHeader.opcode,
              binascii.b2a_hex(frameHeader.mask) if frameHeader.mask else "-",
              frameHeader.length,
              repeatLength,
              chopsize,
              sync,
              payload if frameHeader.opcode == 1 else binascii.b2a_hex(payload))

      log.msg("TX Frame to %s : fin = %s, rsv = %s, opcode = %s, mask = %s, length = %s, repeat_length = %s, chopsize = %s, sync = %s, payload = %s" % info)


   def dataReceived(self, data):
      """
      This is called by Twisted framework upon receiving data on TCP connection.

      Modes: Hybi, Hixie
      """
      if self.logOctets:
         self.logRxOctets(data)
      self.data += data
      self.consumeData()


   def consumeData(self):
      """
      Consume buffered (incoming) data.

      Modes: Hybi, Hixie
      """

      ## WebSocket is open (handshake was completed) or close was sent
      ##
      if self.state == WebSocketProtocol.STATE_OPEN or self.state == WebSocketProtocol.STATE_CLOSING:

         ## process until no more buffered data left or WS was closed
         ##
         while self.processData() and self.state != WebSocketProtocol.STATE_CLOSED:
            pass

      ## WebSocket needs handshake
      ##
      elif self.state == WebSocketProtocol.STATE_CONNECTING:

         ## the implementation of processHandshake() in derived
         ## class needs to perform client or server handshake
         ## from other party here ..
         ##
         self.processHandshake()

      ## we failed the connection .. don't process any more data!
      ##
      elif self.state == WebSocketProtocol.STATE_CLOSED:

         ## ignore any data received after WS was closed
         ##
         if self.debugCodePaths:
            log.msg("received data in STATE_CLOSED")

      ## should not arrive here (invalid state)
      ##
      else:
         raise Exception("invalid state")


   def processHandshake(self):
      """
      Process WebSocket handshake.

      Modes: Hybi, Hixie
      """
      raise Exception("must implement handshake (client or server) in derived class")


   def registerProducer(self, producer, streaming):
      """
      Register a Twisted producer with this protocol.

      Modes: Hybi, Hixie

      :param producer: A Twisted push or pull producer.
      :type producer: object
      :param streaming: Producer type.
      :type streaming: bool
      """
      self.transport.registerProducer(producer, streaming)


   def _trigger(self):
      """
      Trigger sending stuff from send queue (which is only used for chopped/synched writes).

      Modes: Hybi, Hixie
      """
      if not self.triggered:
         self.triggered = True
         self._send()


   def _send(self):
      """
      Send out stuff from send queue. For details how this works, see test/trickling
      in the repo.

      Modes: Hybi, Hixie
      """
      if len(self.send_queue) > 0:
         e = self.send_queue.popleft()
         if self.state != WebSocketProtocol.STATE_CLOSED:
            self.transport.write(e[0])
            if self.logOctets:
               self.logTxOctets(e[0], e[1])
         else:
            if self.debugCodePaths:
               log.msg("skipped delayed write, since connection is closed")
         # we need to reenter the reactor to make the latter
         # reenter the OS network stack, so that octets
         # can get on the wire. Note: this is a "heuristic",
         # since there is no (easy) way to really force out
         # octets from the OS network stack to wire.
         reactor.callLater(WebSocketProtocol._QUEUED_WRITE_DELAY, self._send)
      else:
         self.triggered = False


   def sendData(self, data, sync = False, chopsize = None):
      """
      Wrapper for self.transport.write which allows to give a chopsize.
      When asked to chop up writing to TCP stream, we write only chopsize octets
      and then give up control to select() in underlying reactor so that bytes
      get onto wire immediately. Note that this is different from and unrelated
      to WebSocket data message fragmentation. Note that this is also different
      from the TcpNoDelay option which can be set on the socket.

      Modes: Hybi, Hixie
      """
      if chopsize and chopsize > 0:
         i = 0
         n = len(data)
         done = False
         while not done:
            j = i + chopsize
            if j >= n:
               done = True
               j = n
            self.send_queue.append((data[i:j], True))
            i += chopsize
         self._trigger()
      else:
         if sync or len(self.send_queue) > 0:
            self.send_queue.append((data, sync))
            self._trigger()
         else:
            self.transport.write(data)
            if self.logOctets:
               self.logTxOctets(data, False)


   def sendPreparedMessage(self, preparedMsg):
      """
      Send a message that was previously prepared with
      WebSocketFactory.prepareMessage().

      Modes: Hybi, Hixie
      """
      if self.websocket_version == 0:
         self.sendData(preparedMsg.payloadHixie)
      else:
         self.sendData(preparedMsg.payloadHybi)


   def processData(self):
      """
      After WebSocket handshake has been completed, this procedure will do all
      subsequent processing of incoming bytes.

      Modes: Hybi, Hixie
      """
      if self.websocket_version == 0:
         return self.processDataHixie76()
      else:
         return self.processDataHybi()


   def processDataHixie76(self):
      """
      Hixie-76 incoming data processing.

      Modes: Hixie
      """
      buffered_len = len(self.data)

      ## outside a message, that is we are awaiting data which starts a new message
      ##
      if not self.inside_message:
         if buffered_len >= 2:

            ## new message
            ##
            if self.data[0] == '\x00':

               self.inside_message = True

               if self.utf8validateIncoming:
                  self.utf8validator.reset()
                  self.utf8validateIncomingCurrentMessage = True
                  self.utf8validateLast = (True, True, 0, 0)
               else:
                  self.utf8validateIncomingCurrentMessage = False

               self.data = self.data[1:]
               if self.trackedTimings:
                  self.trackedTimings.track("onMessageBegin")
               self.onMessageBegin(1)

            ## Hixie close from peer received
            ##
            elif self.data[0] == '\xff' and self.data[1] == '\x00':
               self.onCloseFrame(None, None)
               self.data = self.data[2:]
               # stop receiving/processing after having received close!
               return False

            ## malformed data
            ##
            else:
               if self.protocolViolation("malformed data received"):
                  return False
         else:
            ## need more data
            return False

      end_index = self.data.find('\xff')
      if end_index > 0:
         payload = self.data[:end_index]
         self.data = self.data[end_index + 1:]
      else:
         payload = self.data
         self.data = ''

      ## incrementally validate UTF-8 payload
      ##
      if self.utf8validateIncomingCurrentMessage:
         self.utf8validateLast = self.utf8validator.validate(payload)
         if not self.utf8validateLast[0]:
            if self.invalidPayload("encountered invalid UTF-8 while processing text message at payload octet index %d" % self.utf8validateLast[3]):
               return False

      self.onMessageFrameData(payload)

      if end_index > 0:
         self.inside_message = False
         self.onMessageEnd()

      return len(self.data) > 0


   def processDataHybi(self):
      """
      RFC6455/Hybi-Drafts incoming data processing.

      Modes: Hybi
      """
      buffered_len = len(self.data)

      ## outside a frame, that is we are awaiting data which starts a new frame
      ##
      if self.current_frame is None:

         ## need minimum of 2 octets to for new frame
         ##
         if buffered_len >= 2:

            ## FIN, RSV, OPCODE
            ##
            b = ord(self.data[0])
            frame_fin = (b & 0x80) != 0
            frame_rsv = (b & 0x70) >> 4
            frame_opcode = b & 0x0f

            ## MASK, PAYLOAD LEN 1
            ##
            b = ord(self.data[1])
            frame_masked = (b & 0x80) != 0
            frame_payload_len1 = b & 0x7f

            ## MUST be 0 when no extension defining
            ## the semantics of RSV has been negotiated
            ##
            if frame_rsv != 0:
               if self.protocolViolation("RSV != 0 and no extension negotiated"):
                  return False

            ## all client-to-server frames MUST be masked
            ##
            if self.isServer and self.requireMaskedClientFrames and not frame_masked:
               if self.protocolViolation("unmasked client-to-server frame"):
                  return False

            ## all server-to-client frames MUST NOT be masked
            ##
            if not self.isServer and not self.acceptMaskedServerFrames and frame_masked:
               if self.protocolViolation("masked server-to-client frame"):
                  return False

            ## check frame
            ##
            if frame_opcode > 7: # control frame (have MSB in opcode set)

               ## control frames MUST NOT be fragmented
               ##
               if not frame_fin:
                  if self.protocolViolation("fragmented control frame"):
                     return False

               ## control frames MUST have payload 125 octets or less
               ##
               if frame_payload_len1 > 125:
                  if self.protocolViolation("control frame with payload length > 125 octets"):
                     return False

               ## check for reserved control frame opcodes
               ##
               if frame_opcode not in [8, 9, 10]:
                  if self.protocolViolation("control frame using reserved opcode %d" % frame_opcode):
                     return False

               ## close frame : if there is a body, the first two bytes of the body MUST be a 2-byte
               ## unsigned integer (in network byte order) representing a status code
               ##
               if frame_opcode == 8 and frame_payload_len1 == 1:
                  if self.protocolViolation("received close control frame with payload len 1"):
                     return False

            else: # data frame

               ## check for reserved data frame opcodes
               ##
               if frame_opcode not in [0, 1, 2]:
                  if self.protocolViolation("data frame using reserved opcode %d" % frame_opcode):
                     return False

               ## check opcode vs message fragmentation state 1/2
               ##
               if not self.inside_message and frame_opcode == 0:
                  if self.protocolViolation("received continuation data frame outside fragmented message"):
                     return False

               ## check opcode vs message fragmentation state 2/2
               ##
               if self.inside_message and frame_opcode != 0:
                  if self.protocolViolation("received non-continuation data frame while inside fragmented message"):
                     return False

            ## compute complete header length
            ##
            if frame_masked:
               mask_len = 4
            else:
               mask_len = 0

            if frame_payload_len1 <  126:
               frame_header_len = 2 + mask_len
            elif frame_payload_len1 == 126:
               frame_header_len = 2 + 2 + mask_len
            elif frame_payload_len1 == 127:
               frame_header_len = 2 + 8 + mask_len
            else:
               raise Exception("logic error")

            ## only proceed when we have enough data buffered for complete
            ## frame header (which includes extended payload len + mask)
            ##
            if buffered_len >= frame_header_len:

               ## minimum frame header length (already consumed)
               ##
               i = 2

               ## extract extended payload length
               ##
               if frame_payload_len1 == 126:
                  frame_payload_len = struct.unpack("!H", self.data[i:i+2])[0]
                  if frame_payload_len < 126:
                     if self.protocolViolation("invalid data frame length (not using minimal length encoding)"):
                        return False
                  i += 2
               elif frame_payload_len1 == 127:
                  frame_payload_len = struct.unpack("!Q", self.data[i:i+8])[0]
                  if frame_payload_len > 0x7FFFFFFFFFFFFFFF: # 2**63
                     if self.protocolViolation("invalid data frame length (>2^63)"):
                        return False
                  if frame_payload_len < 65536:
                     if self.protocolViolation("invalid data frame length (not using minimal length encoding)"):
                        return False
                  i += 8
               else:
                  frame_payload_len = frame_payload_len1

               ## when payload is masked, extract frame mask
               ##
               frame_mask = None
               if frame_masked:
                  frame_mask = self.data[i:i+4]
                  i += 4

               if frame_masked and frame_payload_len > 0 and self.applyMask:
                  self.current_frame_masker = createXorMasker(frame_mask, frame_payload_len)
               else:
                  self.current_frame_masker = XorMaskerNull()


               ## remember rest (payload of current frame after header and everything thereafter)
               ##
               self.data = self.data[i:]

               ## ok, got complete frame header
               ##
               self.current_frame = FrameHeader(frame_opcode,
                                                frame_fin,
                                                frame_rsv,
                                                frame_payload_len,
                                                frame_mask)

               ## process begin on new frame
               ##
               self.onFrameBegin()

               ## reprocess when frame has no payload or and buffered data left
               ##
               return frame_payload_len == 0 or len(self.data) > 0

            else:
               return False # need more data
         else:
            return False # need more data

      ## inside a started frame
      ##
      else:

         ## cut out rest of frame payload
         ##
         rest = self.current_frame.length - self.current_frame_masker.pointer()
         if buffered_len >= rest:
            data = self.data[:rest]
            length = rest
            self.data = self.data[rest:]
         else:
            data = self.data
            length = buffered_len
            self.data = ""

         if length > 0:
            ## unmask payload
            ##
            payload = self.current_frame_masker.process(data)

            ## process frame data
            ##
            fr = self.onFrameData(payload)
            if fr == False:
               return False

         ## fire frame end handler when frame payload is complete
         ##
         if self.current_frame_masker.pointer() == self.current_frame.length:
            fr = self.onFrameEnd()
            if fr == False:
               return False

         ## reprocess when no error occurred and buffered data left
         ##
         return len(self.data) > 0


   def onFrameBegin(self):
      """
      Begin of receive new frame.

      Modes: Hybi
      """
      if self.current_frame.opcode > 7:
         self.control_frame_data = []
      else:
         ## new message started
         ##
         if not self.inside_message:

            self.inside_message = True

            if self.current_frame.opcode == WebSocketProtocol.MESSAGE_TYPE_TEXT and self.utf8validateIncoming:
               self.utf8validator.reset()
               self.utf8validateIncomingCurrentMessage = True
               self.utf8validateLast = (True, True, 0, 0)
            else:
               self.utf8validateIncomingCurrentMessage = False

            if self.trackedTimings:
               self.trackedTimings.track("onMessageBegin")
            self.onMessageBegin(self.current_frame.opcode)

         self.onMessageFrameBegin(self.current_frame.length, self.current_frame.rsv)


   def onFrameData(self, payload):
      """
      New data received within frame.

      Modes: Hybi
      """
      if self.current_frame.opcode > 7:
         self.control_frame_data.append(payload)
      else:
         ## incrementally validate UTF-8 payload
         ##
         if self.utf8validateIncomingCurrentMessage:
            self.utf8validateLast = self.utf8validator.validate(payload)
            if not self.utf8validateLast[0]:
               if self.invalidPayload("encountered invalid UTF-8 while processing text message at payload octet index %d" % self.utf8validateLast[3]):
                  return False

         self.onMessageFrameData(payload)


   def onFrameEnd(self):
      """
      End of frame received.

      Modes: Hybi
      """
      if self.current_frame.opcode > 7:
         if self.logFrames:
            self.logRxFrame(self.current_frame, self.control_frame_data)
         self.processControlFrame()
      else:
         if self.logFrames:
            self.logRxFrame(self.current_frame, self.frame_data)
         self.onMessageFrameEnd()
         if self.current_frame.fin:
            if self.utf8validateIncomingCurrentMessage:
               if not self.utf8validateLast[1]:
                  if self.invalidPayload("UTF-8 text message payload ended within Unicode code point at payload octet index %d" % self.utf8validateLast[3]):
                     return False
            self.onMessageEnd()
            self.inside_message = False
      self.current_frame = None


   def processControlFrame(self):
      """
      Process a completely received control frame.

      Modes: Hybi
      """

      payload = ''.join(self.control_frame_data)
      self.control_frame_data = None

      ## CLOSE frame
      ##
      if self.current_frame.opcode == 8:

         code = None
         reasonRaw = None
         ll = len(payload)
         if ll > 1:
            code = struct.unpack("!H", payload[0:2])[0]
            if ll > 2:
               reasonRaw = payload[2:]

         if self.onCloseFrame(code, reasonRaw):
            return False

      ## PING frame
      ##
      elif self.current_frame.opcode == 9:
         self.onPing(payload)

      ## PONG frame
      ##
      elif self.current_frame.opcode == 10:
         self.onPong(payload)

      else:
         ## we might arrive here, when protocolViolation
         ## wants us to continue anyway
         pass

      return True


   def sendFrame(self, opcode, payload = "", fin = True, rsv = 0, mask = None, payload_len = None, chopsize = None, sync = False):
      """
      Send out frame. Normally only used internally via sendMessage(), sendPing(), sendPong() and sendClose().

      This method deliberately allows to send invalid frames (that is frames invalid
      per-se, or frames invalid because of protocol state). Other than in fuzzing servers,
      calling methods will ensure that no invalid frames are sent.

      In addition, this method supports explicit specification of payload length.
      When payload_len is given, it will always write that many octets to the stream.
      It'll wrap within payload, resending parts of that when more octets were requested
      The use case is again for fuzzing server which want to sent increasing amounts
      of payload data to peers without having to construct potentially large messges
      themselfes.

      Modes: Hybi
      """
      if self.websocket_version == 0:
         raise Exception("function not supported in Hixie-76 mode")

      if payload_len is not None:
         if len(payload) < 1:
            raise Exception("cannot construct repeated payload with length %d from payload of length %d" % (payload_len, len(payload)))
         l = payload_len
         pl = ''.join([payload for k in range(payload_len / len(payload))]) + payload[:payload_len % len(payload)]
      else:
         l = len(payload)
         pl = payload

      ## first byte
      ##
      b0 = 0
      if fin:
         b0 |= (1 << 7)
      b0 |= (rsv % 8) << 4
      b0 |= opcode % 128

      ## second byte, payload len bytes and mask
      ##
      b1 = 0
      if mask or (not self.isServer and self.maskClientFrames) or (self.isServer and self.maskServerFrames):
         b1 |= 1 << 7
         if not mask:
            mask = struct.pack("!I", random.getrandbits(32))
            mv = mask
         else:
            mv = ""

         ## mask frame payload
         ##
         if l > 0 and self.applyMask:
            masker = createXorMasker(mask, l)
            plm = masker.process(pl)
         else:
            plm = pl

      else:
         mv = ""
         plm = pl

      el = ""
      if l <= 125:
         b1 |= l
      elif l <= 0xFFFF:
         b1 |= 126
         el = struct.pack("!H", l)
      elif l <= 0x7FFFFFFFFFFFFFFF:
         b1 |= 127
         el = struct.pack("!Q", l)
      else:
         raise Exception("invalid payload length")

      raw = ''.join([chr(b0), chr(b1), el, mv, plm])

      if self.logFrames:
         frameHeader = FrameHeader(opcode, fin, rsv, l, mask)
         self.logTxFrame(frameHeader, payload, payload_len, chopsize, sync)

      ## send frame octets
      ##
      self.sendData(raw, sync, chopsize)


   def sendPing(self, payload = None):
      """
      Send out Ping to peer. A peer is expected to Pong back the payload a soon
      as "practical". When more than 1 Ping is outstanding at a peer, the peer may
      elect to respond only to the last Ping.

      Modes: Hybi

      :param payload: An optional, arbitrary payload of length < 126 octets.
      :type payload: str
      """
      if self.websocket_version == 0:
         raise Exception("function not supported in Hixie-76 mode")
      if self.state != WebSocketProtocol.STATE_OPEN:
         return
      if payload:
         l = len(payload)
         if l > 125:
            raise Exception("invalid payload for PING (payload length must be <= 125, was %d)" % l)
         self.sendFrame(opcode = 9, payload = payload)
      else:
         self.sendFrame(opcode = 9)


   def sendPong(self, payload = None):
      """
      Send out Pong to peer. A Pong frame MAY be sent unsolicited.
      This serves as a unidirectional heartbeat. A response to an unsolicited pong is "not expected".

      Modes: Hybi

      :param payload: An optional, arbitrary payload of length < 126 octets.
      :type payload: str
      """
      if self.websocket_version == 0:
         raise Exception("function not supported in Hixie-76 mode")
      if self.state != WebSocketProtocol.STATE_OPEN:
         return
      if payload:
         l = len(payload)
         if l > 125:
            raise Exception("invalid payload for PONG (payload length must be <= 125, was %d)" % l)
         self.sendFrame(opcode = 10, payload = payload)
      else:
         self.sendFrame(opcode = 10)


   def sendCloseFrame(self, code = None, reasonUtf8 = None, isReply = False):
      """
      Send a close frame and update protocol state. Note, that this is
      an internal method which deliberately allows not send close
      frame with invalid payload.

      Modes: Hybi, Hixie

      Notes:
        - For Hixie mode, this method is slightly misnamed for historic reasons.
        - For Hixie mode, code and reasonUtf8 will be silently ignored.
      """
      if self.state == WebSocketProtocol.STATE_CLOSING:
         if self.debugCodePaths:
            log.msg("ignoring sendCloseFrame since connection is closing")

      elif self.state == WebSocketProtocol.STATE_CLOSED:
         if self.debugCodePaths:
            log.msg("ignoring sendCloseFrame since connection already closed")

      elif self.state == WebSocketProtocol.STATE_CONNECTING:
         raise Exception("cannot close a connection not yet connected")

      elif self.state == WebSocketProtocol.STATE_OPEN:

         if self.websocket_version == 0:
            self.sendData("\xff\x00")
         else:
            ## construct Hybi close frame payload and send frame
            payload = ""
            if code is not None:
               payload += struct.pack("!H", code)
            if reasonUtf8 is not None:
               payload += reasonUtf8
            self.sendFrame(opcode = 8, payload = payload)

         ## update state
         self.state = WebSocketProtocol.STATE_CLOSING
         self.closedByMe = not isReply

         ## remember payload of close frame we sent
         self.localCloseCode = code
         self.localCloseReason = reasonUtf8

         ## drop connection when timeout on receiving close handshake reply
         if self.closedByMe and self.closeHandshakeTimeout > 0:
            self.closeHandshakeTimeoutCall = reactor.callLater(self.closeHandshakeTimeout, self.onCloseHandshakeTimeout)

      else:
         raise Exception("logic error")


   def sendClose(self, code = None, reason = None):
      """
      Starts a closing handshake.

      Modes: Hybi, Hixie

      Notes:
        - For Hixie mode, code and reason will be silently ignored.

      :param code: An optional close status code (:class:`WebSocketProtocol`.CLOSE_STATUS_CODE_NORMAL or 3000-4999).
      :type code: int
      :param reason: An optional close reason (a string that when present, a status code MUST also be present).
      :type reason: str
      """
      if code is not None:
         if type(code) != int:
            raise Exception("invalid type %s for close code" % type(code))
         if code != 1000 and not (code >= 3000 and code <= 4999):
            raise Exception("invalid close code %d" % code)
      if reason is not None:
         if code is None:
            raise Exception("close reason without close code")
         if type(reason) not in [str, unicode]:
            raise Exception("invalid type %s for close reason" % type(reason))
         reasonUtf8 = reason.encode("UTF-8")
         if len(reasonUtf8) + 2 > 125:
            raise Exception("close reason too long (%d)" % len(reasonUtf8))
      else:
         reasonUtf8 = None
      self.sendCloseFrame(code = code, reasonUtf8 = reasonUtf8, isReply = False)


   def beginMessage(self, opcode = MESSAGE_TYPE_TEXT):
      """
      Begin sending new message.

      Modes: Hybi, Hixie

      :param opcode: Message type, normally either WebSocketProtocol.MESSAGE_TYPE_TEXT (default) or
                     WebSocketProtocol.MESSAGE_TYPE_BINARY (only Hybi mode).
      """
      if self.state != WebSocketProtocol.STATE_OPEN:
         return

      ## check if sending state is valid for this method
      ##
      if self.send_state != WebSocketProtocol.SEND_STATE_GROUND:
         raise Exception("WebSocketProtocol.beginMessage invalid in current sending state")

      if self.websocket_version == 0:
         if opcode != 1:
            raise Exception("cannot send non-text message in Hixie mode")

         self.sendData('\x00')
         self.send_state = WebSocketProtocol.SEND_STATE_INSIDE_MESSAGE
      else:
         if opcode not in [1, 2]:
            raise Exception("use of reserved opcode %d" % opcode)

         ## remember opcode for later (when sending first frame)
         ##
         self.send_message_opcode = opcode
         self.send_state = WebSocketProtocol.SEND_STATE_MESSAGE_BEGIN


   def beginMessageFrame(self, length, reserved = 0, mask = None):
      """
      Begin sending new message frame.

      Modes: Hybi

      :param length: Length of frame which is started. Must be >= 0 and <= 2^63.
      :type length: int
      :param reserved: Reserved bits for frame (an integer from 0 to 7). Note that reserved != 0 is only legal when an extension has been negoiated which defines semantics.
      :type reserved: int
      :param mask: Optional frame mask. When given, this is used. When None and the peer is a client, a mask will be internally generated. For servers None is default.
      :type mask: str
      """
      if self.websocket_version == 0:
         raise Exception("function not supported in Hixie-76 mode")

      if self.state != WebSocketProtocol.STATE_OPEN:
         return
      ## check if sending state is valid for this method
      ##
      if self.send_state not in [WebSocketProtocol.SEND_STATE_MESSAGE_BEGIN, WebSocketProtocol.SEND_STATE_INSIDE_MESSAGE]:
         raise Exception("WebSocketProtocol.beginMessageFrame invalid in current sending state")

      if (not type(length) in [int, long]) or length < 0 or length > 0x7FFFFFFFFFFFFFFF: # 2**63
         raise Exception("invalid value for message frame length")

      if type(reserved) is not int or reserved < 0 or reserved > 7:
         raise Exception("invalid value for reserved bits")

      self.send_message_frame_length = length

      if mask:
         ## explicit mask given
         ##
         assert type(mask) == str
         assert len(mask) == 4
         self.send_message_frame_mask = mask

      elif (not self.isServer and self.maskClientFrames) or (self.isServer and self.maskServerFrames):
         ## automatic mask:
         ##  - client-to-server masking (if not deactivated)
         ##  - server-to-client masking (if activated)
         ##
         self.send_message_frame_mask = struct.pack("!I", random.getrandbits(32))

      else:
         ## no mask
         ##
         self.send_message_frame_mask = None

      ## payload masker
      ##
      if self.send_message_frame_mask and length > 0 and self.applyMask:
         self.send_message_frame_masker = createXorMasker(self.send_message_frame_mask, length)
      else:
         self.send_message_frame_masker = XorMaskerNull()

      ## first byte
      ##
      b0 = (reserved % 8) << 4 # FIN = false .. since with streaming, we don't know when message ends

      if self.send_state == WebSocketProtocol.SEND_STATE_MESSAGE_BEGIN:
         self.send_state = WebSocketProtocol.SEND_STATE_INSIDE_MESSAGE
         b0 |= self.send_message_opcode % 128
      else:
         pass # message continuation frame

      ## second byte, payload len bytes and mask
      ##
      b1 = 0
      if self.send_message_frame_mask:
         b1 |= 1 << 7
         mv = self.send_message_frame_mask
      else:
         mv = ""

      el = ""
      if length <= 125:
         b1 |= length
      elif length <= 0xFFFF:
         b1 |= 126
         el = struct.pack("!H", length)
      elif length <= 0x7FFFFFFFFFFFFFFF:
         b1 |= 127
         el = struct.pack("!Q", length)
      else:
         raise Exception("invalid payload length")

      ## write message frame header
      ##
      header = ''.join([chr(b0), chr(b1), el, mv])
      self.sendData(header)

      ## now we are inside message frame ..
      ##
      self.send_state = WebSocketProtocol.SEND_STATE_INSIDE_MESSAGE_FRAME


   def sendMessageFrameData(self, payload, sync = False):
      """
      Send out data when within message frame (message was begun, frame was begun).
      Note that the frame is automatically ended when enough data has been sent
      that is, there is no endMessageFrame, since you have begun the frame specifying
      the frame length, which implicitly defined the frame end. This is different from
      messages, which you begin and end, since a message can contain an unlimited number
      of frames.

      Modes: Hybi, Hixie

      Notes:
        - For Hixie mode, this method is slightly misnamed for historic reasons.

      :param payload: Data to send.

      :returns: int -- Hybi mode: when frame still incomplete, returns outstanding octets, when frame complete, returns <= 0, when < 0, the amount of unconsumed data in payload argument. Hixie mode: returns None.
      """
      if self.state != WebSocketProtocol.STATE_OPEN:
         return

      if self.websocket_version == 0:
         ## Hixie Mode
         ##
         if self.send_state != WebSocketProtocol.SEND_STATE_INSIDE_MESSAGE:
            raise Exception("WebSocketProtocol.sendMessageFrameData invalid in current sending state")
         self.sendData(payload, sync = sync)
         return None

      else:
         ## Hybi Mode
         ##
         if self.send_state != WebSocketProtocol.SEND_STATE_INSIDE_MESSAGE_FRAME:
            raise Exception("WebSocketProtocol.sendMessageFrameData invalid in current sending state")

         rl = len(payload)
         if self.send_message_frame_masker.pointer() + rl > self.send_message_frame_length:
            l = self.send_message_frame_length - self.send_message_frame_masker.pointer()
            rest = -(rl - l)
            pl = payload[:l]
         else:
            l = rl
            rest = self.send_message_frame_length - self.send_message_frame_masker.pointer() - l
            pl = payload

         ## mask frame payload
         ##
         plm = self.send_message_frame_masker.process(pl)

         ## send frame payload
         ##
         self.sendData(plm, sync = sync)

         ## if we are done with frame, move back into "inside message" state
         ##
         if self.send_message_frame_masker.pointer() >= self.send_message_frame_length:
            self.send_state = WebSocketProtocol.SEND_STATE_INSIDE_MESSAGE

         ## when =0 : frame was completed exactly
         ## when >0 : frame is still uncomplete and that much amount is still left to complete the frame
         ## when <0 : frame was completed and there was this much unconsumed data in payload argument
         ##
         return rest


   def endMessage(self):
      """
      End a previously begun message. No more frames may be sent (for that message). You have to
      begin a new message before sending again.

      Modes: Hybi, Hixie
      """
      if self.state != WebSocketProtocol.STATE_OPEN:
         return
      ## check if sending state is valid for this method
      ##
      if self.send_state != WebSocketProtocol.SEND_STATE_INSIDE_MESSAGE:
         raise Exception("WebSocketProtocol.endMessage invalid in current sending state [%d]" % self.send_state)

      if self.websocket_version == 0:
         self.sendData('\x00')
      else:
         self.sendFrame(opcode = 0, fin = True)

      self.send_state = WebSocketProtocol.SEND_STATE_GROUND


   def sendMessageFrame(self, payload, reserved = 0, mask = None, sync = False):
      """
      When a message has begun, send a complete message frame in one go.

      Modes: Hybi
      """
      if self.websocket_version == 0:
         raise Exception("function not supported in Hixie-76 mode")

      if self.state != WebSocketProtocol.STATE_OPEN:
         return
      if self.websocket_version == 0:
         raise Exception("function not supported in Hixie-76 mode")
      self.beginMessageFrame(len(payload), reserved, mask)
      self.sendMessageFrameData(payload, sync)


   def sendMessage(self, payload, binary = False, payload_frag_size = None, sync = False):
      """
      Send out a message in one go.

      You can send text or binary message, and optionally specifiy a payload fragment size.
      When the latter is given, the payload will be split up into frames with
      payload <= the payload_frag_size given.

      Modes: Hybi, Hixie
      """
      if self.trackedTimings:
         self.trackedTimings.track("sendMessage")
      if self.state != WebSocketProtocol.STATE_OPEN:
         return
      if self.websocket_version == 0:
         if binary:
            raise Exception("cannot send binary message in Hixie76 mode")
         if payload_frag_size:
            raise Exception("cannot fragment messages in Hixie76 mode")
         self.sendMessageHixie76(payload, sync)
      else:
         self.sendMessageHybi(payload, binary, payload_frag_size, sync)


   def sendMessageHixie76(self, payload, sync = False):
      """
      Hixie76-Variant of sendMessage().

      Modes: Hixie
      """
      self.sendData('\x00' + payload + '\xff', sync = sync)


   def sendMessageHybi(self, payload, binary = False, payload_frag_size = None, sync = False):
      """
      Hybi-Variant of sendMessage().

      Modes: Hybi
      """
      ## (initial) frame opcode
      ##
      if binary:
         opcode = 2
      else:
         opcode = 1

      ## explicit payload_frag_size arguments overrides autoFragmentSize setting
      ##
      if payload_frag_size is not None:
         pfs = payload_frag_size
      else:
         if self.autoFragmentSize > 0:
            pfs = self.autoFragmentSize
         else:
            pfs = None

      ## send unfragmented
      ##
      if pfs is None or len(payload) <= pfs:
         self.sendFrame(opcode = opcode, payload = payload, sync = sync)

      ## send data message in fragments
      ##
      else:
         if pfs < 1:
            raise Exception("payload fragment size must be at least 1 (was %d)" % pfs)
         n = len(payload)
         i = 0
         done = False
         first = True
         while not done:
            j = i + pfs
            if j > n:
               done = True
               j = n
            if first:
               self.sendFrame(opcode = opcode, payload = payload[i:j], fin = done, sync = sync)
               first = False
            else:
               self.sendFrame(opcode = 0, payload = payload[i:j], fin = done, sync = sync)
            i += pfs



class PreparedMessage:
   """
   Encapsulates a prepared message to be sent later once or multiple
   times. This is used for optimizing Broadcast/PubSub.

   The message serialization formats currently created internally are:
      * Hybi
      * Hixie

   The construction of different formats is needed, since we support
   mixed clients (speaking different protocol versions).

   It will also be the place to add a 3rd format, when we support
   the deflate extension, since then, the clients will be mixed
   between Hybi-Deflate-Unsupported, Hybi-Deflate-Supported and Hixie.
   """

   def __init__(self, payload, binary, masked):
      """
      Ctor for a prepared message.

      :param payload: The message payload.
      :type payload: str
      :param binary: Provide `True` for binary payload.
      :type binary: bool
      :param masked: Provide `True` if WebSocket message is to be masked (required for client to server WebSocket messages).
      :type masked: bool
      """
      self._initHixie(payload, binary)
      self._initHybi(payload, binary, masked)


   def _initHixie(self, payload, binary):
      if binary:
         # silently filter out .. probably do something else:
         # base64?
         # dunno
         self.payloadHixie = ''
      else:
         self.payloadHixie = '\x00' + payload + '\xff'


   def _initHybi(self, payload, binary, masked):
      l = len(payload)

      ## first byte
      ##
      b0 = ((1 << 7) | 2) if binary else ((1 << 7) | 1)

      ## second byte, payload len bytes and mask
      ##
      if masked:
         b1 = 1 << 7
         mask = struct.pack("!I", random.getrandbits(32))
         if l == 0:
            plm = payload
         else:
            plm = createXorMasker(mask, l).process(payload)
      else:
         b1 = 0
         mask = ""
         plm = payload

      ## payload extended length
      ##
      el = ""
      if l <= 125:
         b1 |= l
      elif l <= 0xFFFF:
         b1 |= 126
         el = struct.pack("!H", l)
      elif l <= 0x7FFFFFFFFFFFFFFF:
         b1 |= 127
         el = struct.pack("!Q", l)
      else:
         raise Exception("invalid payload length")

      ## raw WS message (single frame)
      ##
      self.payloadHybi = ''.join([chr(b0), chr(b1), el, mask, plm])



class WebSocketFactory:
   """
   Mixin for
   :class:`autobahn.websocket.WebSocketClientFactory` and
   :class:`autobahn.websocket.WebSocketServerFactory`.
   """

   def prepareMessage(self, payload, binary = False, masked = None):
      """
      Prepare a WebSocket message. This can be later used on multiple
      instances of :class:`autobahn.websocket.WebSocketProtocol` using
      :meth:`autobahn.websocket.WebSocketProtocol.sendPreparedMessage`.

      By doing so, you can avoid the (small) overhead of framing the
      *same* payload into WS messages when that payload is to be sent
      out on multiple connections.

      Caveats:

         1. Only use when you know what you are doing. I.e. calling
            :meth:`autobahn.websocket.WebSocketProtocol.sendPreparedMessage`
            on the *same* protocol instance multiples times with the *same*
            prepared message might break the spec, since i.e. the frame mask
            will be the same!

         2. Treat the object returned as opaque. It may change!

      Modes: Hybi, Hixie

      :param payload: The message payload.
      :type payload: str
      :param binary: Provide `True` for binary payload.
      :type binary: bool
      :param masked: Provide `True` if WebSocket message is to be
                     masked (required for client-to-server WebSocket messages).
      :type masked: bool

      :returns: obj -- The prepared message.
      """
      if masked is None:
         masked = not self.isServer

      return PreparedMessage(payload, binary, masked)



class WebSocketServerProtocol(WebSocketProtocol):
   """
   A Twisted protocol for WebSocket servers.
   """

   def onConnect(self, connectionRequest):
      """
      Callback fired during WebSocket opening handshake when new WebSocket client
      connection is about to be established.

      Throw HttpException when you don't want to accept the WebSocket
      connection request. For example, throw a
      `HttpException(httpstatus.HTTP_STATUS_CODE_UNAUTHORIZED[0], "You are not authorized for this!")`.

      When you want to accept the connection, return the accepted protocol
      from list of WebSocket (sub)protocols provided by client or None to
      speak no specific one or when the client list was empty.

      :param connectionRequest: WebSocket connection request information.
      :type connectionRequest: instance of :class:`autobahn.websocket.ConnectionRequest`
      """
      return None


   def connectionMade(self):
      """
      Called by Twisted when new TCP connection from client was accepted. Default
      implementation will prepare for initial WebSocket opening handshake.
      When overriding in derived class, make sure to call this base class
      implementation *before* your code.
      """
      self.isServer = True
      WebSocketProtocol.connectionMade(self)
      self.factory.countConnections += 1
      if self.debug:
         log.msg("connection accepted from peer %s" % self.peerstr)


   def connectionLost(self, reason):
      """
      Called by Twisted when established TCP connection from client was lost. Default
      implementation will tear down all state properly.
      When overriding in derived class, make sure to call this base class
      implementation *after* your code.
      """
      WebSocketProtocol.connectionLost(self, reason)
      self.factory.countConnections -= 1
      if self.debug:
         log.msg("connection from %s lost" % self.peerstr)


   def parseHixie76Key(self, key):
      """
      Parse Hixie76 opening handshake key provided by client.
      """
      return int(filter(lambda x: x.isdigit(), key)) / key.count(" ")


   def processHandshake(self):
      """
      Process WebSocket opening handshake request from client.
      """
      ## only proceed when we have fully received the HTTP request line and all headers
      ##
      end_of_header = self.data.find("\x0d\x0a\x0d\x0a")
      if end_of_header >= 0:

         self.http_request_data = self.data[:end_of_header + 4]
         if self.debug:
            log.msg("received HTTP request:\n\n%s\n\n" % self.http_request_data)

         ## extract HTTP status line and headers
         ##
         (self.http_status_line, self.http_headers, http_headers_cnt) = parseHttpHeader(self.http_request_data)

         ## validate WebSocket opening handshake client request
         ##
         if self.debug:
            log.msg("received HTTP status line in opening handshake : %s" % str(self.http_status_line))
            log.msg("received HTTP headers in opening handshake : %s" % str(self.http_headers))

         ## HTTP Request line : METHOD, VERSION
         ##
         rl = self.http_status_line.split()
         if len(rl) != 3:
            return self.failHandshake("Bad HTTP request status line '%s'" % self.http_status_line)
         if rl[0].strip() != "GET":
            return self.failHandshake("HTTP method '%s' not allowed" % rl[0], HTTP_STATUS_CODE_METHOD_NOT_ALLOWED[0])
         vs = rl[2].strip().split("/")
         if len(vs) != 2 or vs[0] != "HTTP" or vs[1] not in ["1.1"]:
            return self.failHandshake("Unsupported HTTP version '%s'" % rl[2], HTTP_STATUS_CODE_UNSUPPORTED_HTTP_VERSION[0])

         ## HTTP Request line : REQUEST-URI
         ##
         self.http_request_uri = rl[1].strip()
         try:
            (scheme, netloc, path, params, query, fragment) = urlparse.urlparse(self.http_request_uri)

            ## FIXME: check that if absolute resource URI is given,
            ## the scheme/netloc matches the server
            if scheme != "" or netloc != "":
               pass

            ## Fragment identifiers are meaningless in the context of WebSocket
            ## URIs, and MUST NOT be used on these URIs.
            if fragment != "":
               return self.failHandshake("HTTP requested resource contains a fragment identifier '%s'" % fragment)

            ## resource path and query parameters .. this will get forwarded
            ## to onConnect()
            self.http_request_path = path
            self.http_request_params = urlparse.parse_qs(query)
         except:
            return self.failHandshake("Bad HTTP request resource - could not parse '%s'" % rl[1].strip())

         ## Host
         ##
         if not self.http_headers.has_key("host"):
            return self.failHandshake("HTTP Host header missing in opening handshake request")
         if http_headers_cnt["host"] > 1:
            return self.failHandshake("HTTP Host header appears more than once in opening handshake request")
         self.http_request_host = self.http_headers["host"].strip()
         if self.http_request_host.find(":") >= 0:
            (h, p) = self.http_request_host.split(":")
            try:
               port = int(str(p.strip()))
            except:
               return self.failHandshake("invalid port '%s' in HTTP Host header '%s'" % (str(p.strip()), str(self.http_request_host)))
            if port != self.factory.externalPort:
               return self.failHandshake("port %d in HTTP Host header '%s' does not match server listening port %s" % (port, str(self.http_request_host), self.factory.externalPort))
            self.http_request_host = h
         else:
            if not ((self.factory.isSecure and self.factory.externalPort == 443) or (not self.factory.isSecure and self.factory.externalPort == 80)):
               return self.failHandshake("missing port in HTTP Host header '%s' and server runs on non-standard port %d (wss = %s)" % (str(self.http_request_host), self.factory.externalPort, self.factory.isSecure))

         ## Upgrade
         ##
         if not self.http_headers.has_key("upgrade"):
            ## When no WS upgrade, render HTML server status page
            ##
            if self.webStatus:
               if self.http_request_params.has_key('redirect') and len(self.http_request_params['redirect']) > 0:
                  ## To specifiy an URL for redirection, encode the URL, i.e. from JavaScript:
                  ##
                  ##    var url = encodeURIComponent("http://autobahn.ws/python");
                  ##
                  ## and append the encoded string as a query parameter 'redirect'
                  ##
                  ##    http://localhost:9000?redirect=http%3A%2F%2Fautobahn.ws%2Fpython
                  ##    https://localhost:9000?redirect=https%3A%2F%2Ftwitter.com%2F
                  ##
                  ## This will perform an immediate HTTP-303 redirection. If you provide
                  ## an additional parameter 'after' (int >= 0), the redirection happens
                  ## via Meta-Refresh in the rendered HTML status page, i.e.
                  ##
                  ##    https://localhost:9000/?redirect=https%3A%2F%2Ftwitter.com%2F&after=3
                  ##
                  url = self.http_request_params['redirect'][0]
                  if self.http_request_params.has_key('after') and len(self.http_request_params['after']) > 0:
                     after = int(self.http_request_params['after'][0])
                     if self.debugCodePaths:
                        log.msg("HTTP Upgrade header missing : render server status page and meta-refresh-redirecting to %s after %d seconds" % (url, after))
                     self.sendServerStatus(url, after)
                  else:
                     if self.debugCodePaths:
                        log.msg("HTTP Upgrade header missing : 303-redirecting to %s" % url)
                     self.sendRedirect(url)
               else:
                  if self.debugCodePaths:
                     log.msg("HTTP Upgrade header missing : render server status page")
                  self.sendServerStatus()
               self.dropConnection(abort = False)
               return
            else:
               return self.failHandshake("HTTP Upgrade header missing", HTTP_STATUS_CODE_UPGRADE_REQUIRED[0])
         upgradeWebSocket = False
         for u in self.http_headers["upgrade"].split(","):
            if u.strip().lower() == "websocket":
               upgradeWebSocket = True
               break
         if not upgradeWebSocket:
            return self.failHandshake("HTTP Upgrade headers do not include 'websocket' value (case-insensitive) : %s" % self.http_headers["upgrade"])

         ## Connection
         ##
         if not self.http_headers.has_key("connection"):
            return self.failHandshake("HTTP Connection header missing")
         connectionUpgrade = False
         for c in self.http_headers["connection"].split(","):
            if c.strip().lower() == "upgrade":
               connectionUpgrade = True
               break
         if not connectionUpgrade:
            return self.failHandshake("HTTP Connection headers do not include 'upgrade' value (case-insensitive) : %s" % self.http_headers["connection"])

         ## Sec-WebSocket-Version PLUS determine mode: Hybi or Hixie
         ##
         if not self.http_headers.has_key("sec-websocket-version"):
            if self.debugCodePaths:
               log.msg("Hixie76 protocol detected")
            if self.allowHixie76:
               version = 0
            else:
               return self.failHandshake("WebSocket connection denied - Hixie76 protocol mode disabled.")
         else:
            if self.debugCodePaths:
               log.msg("Hybi protocol detected")
            if http_headers_cnt["sec-websocket-version"] > 1:
               return self.failHandshake("HTTP Sec-WebSocket-Version header appears more than once in opening handshake request")
            try:
               version = int(self.http_headers["sec-websocket-version"])
            except:
               return self.failHandshake("could not parse HTTP Sec-WebSocket-Version header '%s' in opening handshake request" % self.http_headers["sec-websocket-version"])

         if version not in self.versions:

            ## respond with list of supported versions (descending order)
            ##
            sv = sorted(self.versions)
            sv.reverse()
            svs = ','.join([str(x) for x in sv])
            return self.failHandshake("WebSocket version %d not supported (supported versions: %s)" % (version, svs),
                                      HTTP_STATUS_CODE_BAD_REQUEST[0],
                                      [("Sec-WebSocket-Version", svs)])
         else:
            ## store the protocol version we are supposed to talk
            self.websocket_version = version

         ## Sec-WebSocket-Protocol
         ##
         if self.http_headers.has_key("sec-websocket-protocol"):
            protocols = [str(x.strip()) for x in self.http_headers["sec-websocket-protocol"].split(",")]
            # check for duplicates in protocol header
            pp = {}
            for p in protocols:
               if pp.has_key(p):
                  return self.failHandshake("duplicate protocol '%s' specified in HTTP Sec-WebSocket-Protocol header" % p)
               else:
                  pp[p] = 1
            # ok, no duplicates, save list in order the client sent it
            self.websocket_protocols = protocols
         else:
            self.websocket_protocols = []

         ## Origin / Sec-WebSocket-Origin
         ## http://tools.ietf.org/html/draft-ietf-websec-origin-02
         ##
         if self.websocket_version < 13 and self.websocket_version != 0:
            # Hybi, but only < Hybi-13
            websocket_origin_header_key = 'sec-websocket-origin'
         else:
            # RFC6455, >= Hybi-13 and Hixie
            websocket_origin_header_key = "origin"

         self.websocket_origin = None
         if self.http_headers.has_key(websocket_origin_header_key):
            if http_headers_cnt[websocket_origin_header_key] > 1:
               return self.failHandshake("HTTP Origin header appears more than once in opening handshake request")
            self.websocket_origin = self.http_headers[websocket_origin_header_key].strip()
         else:
            # non-browser clients are allowed to omit this header
            pass

         ## Sec-WebSocket-Extensions
         ##
         ## extensions requested by client
         self.websocket_extensions = []
         ## extensions selected by server
         self.websocket_extensions_in_use = []

         if self.http_headers.has_key("sec-websocket-extensions"):
            if self.websocket_version == 0:
               return self.failHandshake("Sec-WebSocket-Extensions header specified for Hixie-76")
            extensions = [x.strip() for x in self.http_headers["sec-websocket-extensions"].split(',')]
            if len(extensions) > 0:
               self.websocket_extensions = extensions
               if self.debug:
                  log.msg("client requested extensions we don't support (%s)" % str(extensions))

         ## Sec-WebSocket-Key (Hybi) or Sec-WebSocket-Key1/Sec-WebSocket-Key2 (Hixie-76)
         ##
         if self.websocket_version == 0:
            for kk in ['Sec-WebSocket-Key1', 'Sec-WebSocket-Key2']:
               k = kk.lower()
               if not self.http_headers.has_key(k):
                  return self.failHandshake("HTTP %s header missing" % kk)
               if http_headers_cnt[k] > 1:
                  return self.failHandshake("HTTP %s header appears more than once in opening handshake request" % kk)
               try:
                  key1 = self.parseHixie76Key(self.http_headers["sec-websocket-key1"].strip())
                  key2 = self.parseHixie76Key(self.http_headers["sec-websocket-key2"].strip())
               except:
                  return self.failHandshake("could not parse Sec-WebSocket-Key1/2")
         else:
            if not self.http_headers.has_key("sec-websocket-key"):
               return self.failHandshake("HTTP Sec-WebSocket-Key header missing")
            if http_headers_cnt["sec-websocket-key"] > 1:
               return self.failHandshake("HTTP Sec-WebSocket-Key header appears more than once in opening handshake request")
            key = self.http_headers["sec-websocket-key"].strip()
            if len(key) != 24: # 16 bytes => (ceil(128/24)*24)/6 == 24
               return self.failHandshake("bad Sec-WebSocket-Key (length must be 24 ASCII chars) '%s'" % key)
            if key[-2:] != "==": # 24 - ceil(128/6) == 2
               return self.failHandshake("bad Sec-WebSocket-Key (invalid base64 encoding) '%s'" % key)
            for c in key[:-2]:
               if c not in "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/":
                  return self.failHandshake("bad character '%s' in Sec-WebSocket-Key (invalid base64 encoding) '%s'" (c, key))

         ## For Hixie-76, we need 8 octets of HTTP request body to complete HS!
         ##
         if self.websocket_version == 0:
            if len(self.data) < end_of_header + 4 + 8:
               return
            else:
               key3 =  self.data[end_of_header + 4:end_of_header + 4 + 8]
               if self.debug:
                  log.msg("received HTTP request body containing key3 for Hixie-76: %s" % key3)

         ## Ok, got complete HS input, remember rest (if any)
         ##
         if self.websocket_version == 0:
            self.data = self.data[end_of_header + 4 + 8:]
         else:
            self.data = self.data[end_of_header + 4:]

         ## WebSocket handshake validated => produce opening handshake response

         ## Now fire onConnect() on derived class, to give that class a chance to accept or deny
         ## the connection. onConnect() may throw, in which case the connection is denied, or it
         ## may return a protocol from the protocols provided by client or None.
         ##
         try:
            connectionRequest = ConnectionRequest(self.peer,
                                                  self.peerstr,
                                                  self.http_headers,
                                                  self.http_request_host,
                                                  self.http_request_path,
                                                  self.http_request_params,
                                                  self.websocket_version,
                                                  self.websocket_origin,
                                                  self.websocket_protocols,
                                                  self.websocket_extensions)

            ## onConnect() will return the selected subprotocol or None
            ## or raise an HttpException
            ##
            protocol = self.onConnect(connectionRequest)

            if protocol is not None and not (protocol in self.websocket_protocols):
               raise Exception("protocol accepted must be from the list client sent or None")

            self.websocket_protocol_in_use = protocol

         except HttpException, e:
            return self.failHandshake(e.reason, e.code)
            #return self.sendHttpRequestFailure(e.code, e.reason)

         except Exception, e:
            log.msg("Exception raised in onConnect() - %s" % str(e))
            return self.failHandshake("Internal Server Error", HTTP_STATUS_CODE_INTERNAL_SERVER_ERROR[0])


         ## build response to complete WebSocket handshake
         ##
         response  = "HTTP/1.1 %d Switching Protocols\x0d\x0a" % HTTP_STATUS_CODE_SWITCHING_PROTOCOLS[0]

         if self.factory.server is not None and self.factory.server != "":
            response += "Server: %s\x0d\x0a" % self.factory.server.encode("utf-8")

         response += "Upgrade: WebSocket\x0d\x0a"
         response += "Connection: Upgrade\x0d\x0a"

         if self.websocket_protocol_in_use is not None:
            response += "Sec-WebSocket-Protocol: %s\x0d\x0a" % str(self.websocket_protocol_in_use)

         if self.websocket_version == 0:

            if self.websocket_origin:
               ## browser client provide the header, and expect it to be echo'ed
               response += "Sec-WebSocket-Origin: %s\x0d\x0a" % str(self.websocket_origin)

            if self.debugCodePaths:
               log.msg('factory isSecure = %s port = %s' % (self.factory.isSecure, self.factory.externalPort))

            if (self.factory.isSecure and self.factory.externalPort != 443) or ((not self.factory.isSecure) and self.factory.externalPort != 80):
               if self.debugCodePaths:
                  log.msg('factory running on non-default port')
               response_port = ':' + str(self.factory.externalPort)
            else:
               if self.debugCodePaths:
                  log.msg('factory running on default port')
               response_port = ''

            ## FIXME: check this! But see below ..
            if False:
               response_host = str(self.factory.host)
               response_path = str(self.factory.path)
            else:
               response_host = str(self.http_request_host)
               response_path = str(self.http_request_uri)

            location = "%s://%s%s%s" % ('wss' if self.factory.isSecure else 'ws', response_host, response_port, response_path)

            # Safari is very picky about this one
            response += "Sec-WebSocket-Location: %s\x0d\x0a" % location

            ## end of HTTP response headers
            response += "\x0d\x0a"

            ## compute accept body
            ##
            accept_val = struct.pack(">II", key1, key2) + key3
            accept = hashlib.md5(accept_val).digest()
            response_body = str(accept)
         else:
            ## compute Sec-WebSocket-Accept
            ##
            sha1 = hashlib.sha1()
            sha1.update(key + WebSocketProtocol._WS_MAGIC)
            sec_websocket_accept = base64.b64encode(sha1.digest())

            response += "Sec-WebSocket-Accept: %s\x0d\x0a" % sec_websocket_accept

            if len(self.websocket_extensions_in_use) > 0:
               response += "Sec-WebSocket-Extensions: %s\x0d\x0a" % ','.join(self.websocket_extensions_in_use)

            ## end of HTTP response headers
            response += "\x0d\x0a"
            response_body = ''

         if self.debug:
            log.msg("sending HTTP response:\n\n%s%s\n\n" % (response, binascii.b2a_hex(response_body)))

         ## save and send out opening HS data
         ##
         self.http_response_data = response + response_body
         self.sendData(self.http_response_data)

         ## opening handshake completed, move WebSocket connection into OPEN state
         ##
         self.state = WebSocketProtocol.STATE_OPEN

         ## cancel any opening HS timer if present
         ##
         if self.openHandshakeTimeoutCall is not None:
            if self.debugCodePaths:
               log.msg("openHandshakeTimeoutCall.cancel")
            self.openHandshakeTimeoutCall.cancel()
            self.openHandshakeTimeoutCall = None

         ## init state
         ##
         self.inside_message = False
         if self.websocket_version != 0:
            self.current_frame = None

         ## fire handler on derived class
         ##
         if self.trackedTimings:
            self.trackedTimings.track("onOpen")
         self.onOpen()

         ## process rest, if any
         ##
         if len(self.data) > 0:
            self.consumeData()


   def failHandshake(self, reason, code = HTTP_STATUS_CODE_BAD_REQUEST[0], responseHeaders = []):
      """
      During opening handshake the client request was invalid, we send a HTTP
      error response and then drop the connection.
      """
      if self.debug:
         log.msg("failing WebSocket opening handshake ('%s')" % reason)
      self.sendHttpErrorResponse(code, reason, responseHeaders)
      self.dropConnection(abort = False)


   def sendHttpErrorResponse(self, code, reason, responseHeaders = []):
      """
      Send out HTTP error response.
      """
      response  = "HTTP/1.1 %d %s\x0d\x0a" % (code, reason.encode("utf-8"))
      for h in responseHeaders:
         response += "%s: %s\x0d\x0a" % (h[0], h[1].encode("utf-8"))
      response += "\x0d\x0a"
      self.sendData(response)


   def sendHtml(self, html):
      """
      Send HTML page HTTP response.
      """
      raw = html.encode("utf-8")
      response  = "HTTP/1.1 %d %s\x0d\x0a" % (HTTP_STATUS_CODE_OK[0], HTTP_STATUS_CODE_OK[1])
      if self.factory.server is not None and self.factory.server != "":
         response += "Server: %s\x0d\x0a" % self.factory.server.encode("utf-8")
      response += "Content-Type: text/html; charset=UTF-8\x0d\x0a"
      response += "Content-Length: %d\x0d\x0a" % len(raw)
      response += "\x0d\x0a"
      response += raw
      self.sendData(response)


   def sendRedirect(self, url):
      """
      Send HTTP Redirect (303) response.
      """
      response  = "HTTP/1.1 %d\x0d\x0a" % HTTP_STATUS_CODE_SEE_OTHER[0]
      #if self.factory.server is not None and self.factory.server != "":
      #   response += "Server: %s\x0d\x0a" % self.factory.server.encode("utf-8")
      response += "Location: %s\x0d\x0a" % url.encode("utf-8")
      response += "\x0d\x0a"
      self.sendData(response)


   def sendServerStatus(self, redirectUrl = None, redirectAfter = 0):
      """
      Used to send out server status/version upon receiving a HTTP/GET without
      upgrade to WebSocket header (and option serverStatus is True).
      """
      if redirectUrl:
         redirect = """<meta http-equiv="refresh" content="%d;URL='%s'">""" % (redirectAfter, redirectUrl)
      else:
         redirect = ""
      html = """
<!DOCTYPE html>
<html>
   <head>
      %s
      <style>
         body {
            color: #fff;
            background-color: #027eae;
            font-family: "Segoe UI", "Lucida Grande", "Helvetica Neue", Helvetica, Arial, sans-serif;
            font-size: 16px;
         }

         a, a:visited, a:hover {
            color: #fff;
         }
      </style>
   </head>
   <body>
      <h1>AutobahnPython %s</h1>
      <p>
         I am not Web server, but a WebSocket endpoint.
         You can talk to me using the WebSocket <a href="http://tools.ietf.org/html/rfc6455">protocol</a>.
      </p>
      <p>
         For more information, please visit <a href="http://autobahn.ws/python">my homepage</a>.
      </p>
   </body>
</html>
""" % (redirect, __version__)
      self.sendHtml(html)


class WebSocketServerFactory(protocol.ServerFactory, WebSocketFactory):
   """
   A Twisted factory for WebSocket server protocols.
   """

   protocol = WebSocketServerProtocol
   """
   The protocol to be spoken. Must be derived from :class:`autobahn.websocket.WebSocketServerProtocol`.
   """


   def __init__(self, url = None, protocols = [], server = "AutobahnPython/%s" % __version__, debug = False, debugCodePaths = False, externalPort = None):
      """
      Create instance of WebSocket server factory.

      Note that you MUST provide URL either here or using
      :meth:`autobahn.websocket.WebSocketServerFactory.setSessionParameters`
      *before* the factory is started.

      :param url: WebSocket listening URL - ("ws:" | "wss:") "//" host [ ":" port ].
      :type url: str
      :param protocols: List of subprotocols the server supports. The subprotocol used is the first from the list of subprotocols announced by the client that is contained in this list.
      :type protocols: list of strings
      :param server: Server as announced in HTTP response header during opening handshake or None (default: "AutobahnWebSocket/x.x.x").
      :type server: str
      :param debug: Debug mode (default: False).
      :type debug: bool
      :param debugCodePaths: Debug code paths mode (default: False).
      :type debugCodePaths: bool
      :param externalPort: Optionally, the external visible port this server will be reachable under (i.e. when running behind a L2/L3 forwarding device).
      :type externalPort: int
      """
      self.debug = debug
      self.debugCodePaths = debugCodePaths

      self.logOctets = debug
      self.logFrames = debug

      self.trackTimings = False

      self.isServer = True

      ## seed RNG which is used for WS frame masks generation
      random.seed()

      ## default WS session parameters
      ##
      self.setSessionParameters(url, protocols, server, externalPort)

      ## default WebSocket protocol options
      ##
      self.resetProtocolOptions()

      ## number of currently connected clients
      ##
      self.countConnections = 0


   def setSessionParameters(self, url = None, protocols = [], server = None, externalPort = None):
      """
      Set WebSocket session parameters.

      :param url: WebSocket listening URL - ("ws:" | "wss:") "//" host [ ":" port ].
      :type url: str
      :param protocols: List of subprotocols the server supports. The subprotocol used is the first from the list of subprotocols announced by the client that is contained in this list.
      :type protocols: list of strings
      :param server: Server as announced in HTTP response header during opening handshake.
      :type server: str
      :param externalPort: Optionally, the external visible port this server will be reachable under (i.e. when running behind a L2/L3 forwarding device).
      :type externalPort: int
      """
      if url is not None:
         ## parse WebSocket URI into components
         (isSecure, host, port, resource, path, params) = parseWsUrl(url)
         if path != "/":
            raise Exception("path specified for server WebSocket URL")
         if len(params) > 0:
            raise Exception("query parameters specified for server WebSocket URL")
         self.url = url
         self.isSecure = isSecure
         self.host = host
         self.port = port
      else:
         self.url = None
         self.isSecure = None
         self.host = None
         self.port = None

      self.externalPort = externalPort if externalPort is not None else self.port
      self.protocols = protocols
      self.server = server


   def resetProtocolOptions(self):
      """
      Reset all WebSocket protocol options to defaults.
      """
      self.versions = WebSocketProtocol.SUPPORTED_PROTOCOL_VERSIONS
      self.allowHixie76 = WebSocketProtocol.DEFAULT_ALLOW_HIXIE76
      self.webStatus = True
      self.utf8validateIncoming = True
      self.requireMaskedClientFrames = True
      self.maskServerFrames = False
      self.applyMask = True
      self.maxFramePayloadSize = 0
      self.maxMessagePayloadSize = 0
      self.autoFragmentSize = 0
      self.failByDrop = True
      self.echoCloseCodeReason = False
      self.openHandshakeTimeout = 5
      self.closeHandshakeTimeout = 1
      self.tcpNoDelay = True


   def setProtocolOptions(self,
                          versions = None,
                          allowHixie76 = None,
                          webStatus = None,
                          utf8validateIncoming = None,
                          maskServerFrames = None,
                          requireMaskedClientFrames = None,
                          applyMask = None,
                          maxFramePayloadSize = None,
                          maxMessagePayloadSize = None,
                          autoFragmentSize = None,
                          failByDrop = None,
                          echoCloseCodeReason = None,
                          openHandshakeTimeout = None,
                          closeHandshakeTimeout = None,
                          tcpNoDelay = None):
      """
      Set WebSocket protocol options used as defaults for new protocol instances.

      :param versions: The WebSocket protocol versions accepted by the server (default: WebSocketProtocol.SUPPORTED_PROTOCOL_VERSIONS).
      :type versions: list of ints
      :param allowHixie76: Allow to speak Hixie76 protocol version.
      :type allowHixie76: bool
      :param webStatus: Return server status/version on HTTP/GET without WebSocket upgrade header (default: True).
      :type webStatus: bool
      :param utf8validateIncoming: Validate incoming UTF-8 in text message payloads (default: True).
      :type utf8validateIncoming: bool
      :param maskServerFrames: Mask server-to-client frames (default: False).
      :type maskServerFrames: bool
      :param requireMaskedClientFrames: Require client-to-server frames to be masked (default: True).
      :type requireMaskedClientFrames: bool
      :param applyMask: Actually apply mask to payload when mask it present. Applies for outgoing and incoming frames (default: True).
      :type applyMask: bool
      :param maxFramePayloadSize: Maximum frame payload size that will be accepted when receiving or 0 for unlimited (default: 0).
      :type maxFramePayloadSize: int
      :param maxMessagePayloadSize: Maximum message payload size (after reassembly of fragmented messages) that will be accepted when receiving or 0 for unlimited (default: 0).
      :type maxMessagePayloadSize: int
      :param autoFragmentSize: Automatic fragmentation of outgoing data messages (when using the message-based API) into frames with payload length <= this size or 0 for no auto-fragmentation (default: 0).
      :type autoFragmentSize: int
      :param failByDrop: Fail connections by dropping the TCP connection without performaing closing handshake (default: True).
      :type failbyDrop: bool
      :param echoCloseCodeReason: Iff true, when receiving a close, echo back close code/reason. Otherwise reply with code == NORMAL, reason = "" (default: False).
      :type echoCloseCodeReason: bool
      :param openHandshakeTimeout: Opening WebSocket handshake timeout, timeout in seconds or 0 to deactivate (default: 0).
      :type openHandshakeTimeout: float
      :param closeHandshakeTimeout: When we expect to receive a closing handshake reply, timeout in seconds (default: 1).
      :type closeHandshakeTimeout: float
      :param tcpNoDelay: TCP NODELAY ("Nagle") socket option (default: True).
      :type tcpNoDelay: bool
      """
      if allowHixie76 is not None and allowHixie76 != self.allowHixie76:
         self.allowHixie76 = allowHixie76

      if versions is not None:
         for v in versions:
            if v not in WebSocketProtocol.SUPPORTED_PROTOCOL_VERSIONS:
               raise Exception("invalid WebSocket protocol version %s (allowed values: %s)" % (v, str(WebSocketProtocol.SUPPORTED_PROTOCOL_VERSIONS)))
            if v == 0 and not self.allowHixie76:
               raise Exception("use of Hixie-76 requires allowHixie76 == True")
         if set(versions) != set(self.versions):
            self.versions = versions

      if webStatus is not None and webStatus != self.webStatus:
         self.webStatus = webStatus

      if utf8validateIncoming is not None and utf8validateIncoming != self.utf8validateIncoming:
         self.utf8validateIncoming = utf8validateIncoming

      if requireMaskedClientFrames is not None and requireMaskedClientFrames != self.requireMaskedClientFrames:
         self.requireMaskedClientFrames = requireMaskedClientFrames

      if maskServerFrames is not None and maskServerFrames != self.maskServerFrames:
         self.maskServerFrames = maskServerFrames

      if applyMask is not None and applyMask != self.applyMask:
         self.applyMask = applyMask

      if maxFramePayloadSize is not None and maxFramePayloadSize != self.maxFramePayloadSize:
         self.maxFramePayloadSize = maxFramePayloadSize

      if maxMessagePayloadSize is not None and maxMessagePayloadSize != self.maxMessagePayloadSize:
         self.maxMessagePayloadSize = maxMessagePayloadSize

      if autoFragmentSize is not None and autoFragmentSize != self.autoFragmentSize:
         self.autoFragmentSize = autoFragmentSize

      if failByDrop is not None and failByDrop != self.failByDrop:
         self.failByDrop = failByDrop

      if echoCloseCodeReason is not None and echoCloseCodeReason != self.echoCloseCodeReason:
         self.echoCloseCodeReason = echoCloseCodeReason

      if openHandshakeTimeout is not None and openHandshakeTimeout != self.openHandshakeTimeout:
         self.openHandshakeTimeout = openHandshakeTimeout

      if closeHandshakeTimeout is not None and closeHandshakeTimeout != self.closeHandshakeTimeout:
         self.closeHandshakeTimeout = closeHandshakeTimeout

      if tcpNoDelay is not None and tcpNoDelay != self.tcpNoDelay:
         self.tcpNoDelay = tcpNoDelay


   def getConnectionCount(self):
      """
      Get number of currently connected clients.

      :returns: int -- Number of currently connected clients.
      """
      return self.countConnections


   def startFactory(self):
      """
      Called by Twisted before starting to listen on port for incoming connections.
      Default implementation does nothing. Override in derived class when appropriate.
      """
      pass


   def stopFactory(self):
      """
      Called by Twisted before stopping to listen on port for incoming connections.
      Default implementation does nothing. Override in derived class when appropriate.
      """
      pass


class WebSocketClientProtocol(WebSocketProtocol):
   """
   Client protocol for WebSocket.
   """

   def onConnect(self, connectionResponse):
      """
      Callback fired directly after WebSocket opening handshake when new WebSocket server
      connection was established.

      :param connectionResponse: WebSocket connection response information.
      :type connectionResponse: instance of :class:`autobahn.websocket.ConnectionResponse`
      """
      pass


   def connectionMade(self):
      """
      Called by Twisted when new TCP connection to server was established. Default
      implementation will start the initial WebSocket opening handshake.
      When overriding in derived class, make sure to call this base class
      implementation _before_ your code.
      """
      self.isServer = False
      WebSocketProtocol.connectionMade(self)
      if self.debug:
         log.msg("connection to %s established" % self.peerstr)
      self.startHandshake()


   def connectionLost(self, reason):
      """
      Called by Twisted when established TCP connection to server was lost. Default
      implementation will tear down all state properly.
      When overriding in derived class, make sure to call this base class
      implementation _after_ your code.
      """
      WebSocketProtocol.connectionLost(self, reason)
      if self.debug:
         log.msg("connection to %s lost" % self.peerstr)


   def createHixieKey(self):
      """
      Supposed to implement the crack smoker algorithm below. Well, crack
      probably wasn't the stuff they smoked - dog poo?

      http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol-76#page-21
      Items 16 - 22
      """
      spaces1 = random.randint(1, 12)
      max1 = int(4294967295L / spaces1)
      number1 = random.randint(0, max1)
      product1 = number1 * spaces1
      key1 = str(product1)
      rchars = filter(lambda x: (x >= 0x21 and x <= 0x2f) or (x >= 0x3a and x <= 0x7e), range(0,127))
      for i in xrange(random.randint(1, 12)):
         p = random.randint(0, len(key1) - 1)
         key1 = key1[:p] + chr(random.choice(rchars)) + key1[p:]
      for i in xrange(spaces1):
         p = random.randint(1, len(key1) - 2)
         key1 = key1[:p] + ' ' + key1[p:]
      return (key1, number1)


   def startHandshake(self):
      """
      Start WebSocket opening handshake.
      """

      ## construct WS opening handshake HTTP header
      ##
      request  = "GET %s HTTP/1.1\x0d\x0a" % self.factory.resource.encode("utf-8")

      if self.factory.useragent is not None and self.factory.useragent != "":
         request += "User-Agent: %s\x0d\x0a" % self.factory.useragent.encode("utf-8")

      request += "Host: %s:%d\x0d\x0a" % (self.factory.host.encode("utf-8"), self.factory.port)
      request += "Upgrade: WebSocket\x0d\x0a"
      request += "Connection: Upgrade\x0d\x0a"

      ## this seems to prohibit some non-compliant proxies from removing the
      ## connection "Upgrade" header
      ## See also:
      ##   http://www.ietf.org/mail-archive/web/hybi/current/msg09841.html
      ##   http://code.google.com/p/chromium/issues/detail?id=148908
      ##
      request += "Pragma: no-cache\x0d\x0a"
      request += "Cache-Control: no-cache\x0d\x0a"

      ## handshake random key
      ##
      if self.version == 0:
         (self.websocket_key1, number1) = self.createHixieKey()
         (self.websocket_key2, number2) = self.createHixieKey()
         self.websocket_key3 = os.urandom(8)
         accept_val = struct.pack(">II", number1, number2) + self.websocket_key3
         self.websocket_expected_challenge_response = hashlib.md5(accept_val).digest()

         ## Safari does NOT set Content-Length, even though the body is
         ## non-empty, and the request unchunked. We do it.
         ## See also: http://www.ietf.org/mail-archive/web/hybi/current/msg02149.html
         request += "Content-Length: %s\x0d\x0a" % len(self.websocket_key3)

         ## First two keys.
         request += "Sec-WebSocket-Key1: %s\x0d\x0a" % self.websocket_key1
         request += "Sec-WebSocket-Key2: %s\x0d\x0a" % self.websocket_key2
      else:
         self.websocket_key = base64.b64encode(os.urandom(16))
         request += "Sec-WebSocket-Key: %s\x0d\x0a" % self.websocket_key

      ## optional origin announced
      ##
      if self.factory.origin:
         if self.version > 10 or self.version == 0:
            request += "Origin: %d\x0d\x0a" % self.factory.origin.encode("utf-8")
         else:
            request += "Sec-WebSocket-Origin: %d\x0d\x0a" % self.factory.origin.encode("utf-8")

      ## optional list of WS subprotocols announced
      ##
      if len(self.factory.protocols) > 0:
         request += "Sec-WebSocket-Protocol: %s\x0d\x0a" % ','.join(self.factory.protocols)

      ## set WS protocol version depending on WS spec version
      ##
      if self.version != 0:
         request += "Sec-WebSocket-Version: %d\x0d\x0a" % WebSocketProtocol.SPEC_TO_PROTOCOL_VERSION[self.version]

      request += "\x0d\x0a"

      if self.version == 0:
         ## Write HTTP request body for Hixie-76
         request += self.websocket_key3

      self.http_request_data = request

      if self.debug:
         log.msg(self.http_request_data)

      self.sendData(self.http_request_data)


   def processHandshake(self):
      """
      Process WebSocket opening handshake response from server.
      """
      ## only proceed when we have fully received the HTTP request line and all headers
      ##
      end_of_header = self.data.find("\x0d\x0a\x0d\x0a")
      if end_of_header >= 0:

         self.http_response_data = self.data[:end_of_header + 4]
         if self.debug:
            log.msg("received HTTP response:\n\n%s\n\n" % self.http_response_data)

         ## extract HTTP status line and headers
         ##
         (self.http_status_line, self.http_headers, http_headers_cnt) = parseHttpHeader(self.http_response_data)

         ## validate WebSocket opening handshake server response
         ##
         if self.debug:
            log.msg("received HTTP status line in opening handshake : %s" % str(self.http_status_line))
            log.msg("received HTTP headers in opening handshake : %s" % str(self.http_headers))

         ## Response Line
         ##
         sl = self.http_status_line.split()
         if len(sl) < 2:
            return self.failHandshake("Bad HTTP response status line '%s'" % self.http_status_line)

         ## HTTP version
         ##
         http_version = sl[0].strip()
         if http_version != "HTTP/1.1":
            return self.failHandshake("Unsupported HTTP version ('%s')" % http_version)

         ## HTTP status code
         ##
         try:
            status_code = int(sl[1].strip())
         except:
            return self.failHandshake("Bad HTTP status code ('%s')" % sl[1].strip())
         if status_code != HTTP_STATUS_CODE_SWITCHING_PROTOCOLS[0]:

            ## FIXME: handle redirects
            ## FIXME: handle authentication required

            if len(sl) > 2:
               reason = " - %s" % ''.join(sl[2:])
            else:
               reason = ""
            return self.failHandshake("WebSocket connection upgrade failed (%d%s)" % (status_code, reason))

         ## Upgrade
         ##
         if not self.http_headers.has_key("upgrade"):
            return self.failHandshake("HTTP Upgrade header missing")
         if self.http_headers["upgrade"].strip().lower() != "websocket":
            return self.failHandshake("HTTP Upgrade header different from 'websocket' (case-insensitive) : %s" % self.http_headers["upgrade"])

         ## Connection
         ##
         if not self.http_headers.has_key("connection"):
            return self.failHandshake("HTTP Connection header missing")
         connectionUpgrade = False
         for c in self.http_headers["connection"].split(","):
            if c.strip().lower() == "upgrade":
               connectionUpgrade = True
               break
         if not connectionUpgrade:
            return self.failHandshake("HTTP Connection header does not include 'upgrade' value (case-insensitive) : %s" % self.http_headers["connection"])

         ## compute Sec-WebSocket-Accept
         ##
         if self.version != 0:
            if not self.http_headers.has_key("sec-websocket-accept"):
               return self.failHandshake("HTTP Sec-WebSocket-Accept header missing in opening handshake reply")
            else:
               if http_headers_cnt["sec-websocket-accept"] > 1:
                  return self.failHandshake("HTTP Sec-WebSocket-Accept header appears more than once in opening handshake reply")
               sec_websocket_accept_got = self.http_headers["sec-websocket-accept"].strip()

               sha1 = hashlib.sha1()
               sha1.update(self.websocket_key + WebSocketProtocol._WS_MAGIC)
               sec_websocket_accept = base64.b64encode(sha1.digest())

               if sec_websocket_accept_got != sec_websocket_accept:
                  return self.failHandshake("HTTP Sec-WebSocket-Accept bogus value : expected %s / got %s" % (sec_websocket_accept, sec_websocket_accept_got))

         ## handle "extensions in use" - if any
         ##
         self.websocket_extensions_in_use = []
         if self.version != 0:
            if self.http_headers.has_key("sec-websocket-extensions"):
               if http_headers_cnt["sec-websocket-extensions"] > 1:
                  return self.failHandshake("HTTP Sec-WebSocket-Extensions header appears more than once in opening handshake reply")
               exts = self.http_headers["sec-websocket-extensions"].strip()
               ##
               ## we don't support any extension, but if we did, we needed
               ## to set self.websocket_extensions_in_use here, and don't fail the handshake
               ##
               return self.failHandshake("server wants to use extensions (%s), but no extensions implemented" % exts)

         ## handle "subprotocol in use" - if any
         ##
         self.websocket_protocol_in_use = None
         if self.http_headers.has_key("sec-websocket-protocol"):
            if http_headers_cnt["sec-websocket-protocol"] > 1:
               return self.failHandshake("HTTP Sec-WebSocket-Protocol header appears more than once in opening handshake reply")
            sp = str(self.http_headers["sec-websocket-protocol"].strip())
            if sp != "":
               if sp not in self.factory.protocols:
                  return self.failHandshake("subprotocol selected by server (%s) not in subprotocol list requested by client (%s)" % (sp, str(self.factory.protocols)))
               else:
                  ## ok, subprotocol in use
                  ##
                  self.websocket_protocol_in_use = sp


         ## For Hixie-76, we need 16 octets of HTTP request body to complete HS!
         ##
         if self.version == 0:
            if len(self.data) < end_of_header + 4 + 16:
               return
            else:
               challenge_response =  self.data[end_of_header + 4:end_of_header + 4 + 16]
               if challenge_response != self.websocket_expected_challenge_response:
                  return self.failHandshake("invalid challenge response received from server (Hixie-76)")

         ## Ok, got complete HS input, remember rest (if any)
         ##
         if self.version == 0:
            self.data = self.data[end_of_header + 4 + 16:]
         else:
            self.data = self.data[end_of_header + 4:]

         ## opening handshake completed, move WebSocket connection into OPEN state
         ##
         self.state = WebSocketProtocol.STATE_OPEN
         self.inside_message = False
         if self.version != 0:
            self.current_frame = None
         self.websocket_version = self.version

         ## we handle this symmetrical to server-side .. that is, give the
         ## client a chance to bail out .. i.e. on no subprotocol selected
         ## by server
         try:
            connectionResponse = ConnectionResponse(self.peer,
                                                    self.peerstr,
                                                    self.http_headers,
                                                    None, # FIXME
                                                    self.websocket_protocol_in_use,
                                                    self.websocket_extensions_in_use)

            self.onConnect(connectionResponse)

         except Exception, e:
            ## immediately close the WS connection
            ##
            self.failConnection(1000, str(e))
         else:
            ## fire handler on derived class
            ##
            if self.trackedTimings:
               self.trackedTimings.track("onOpen")
            self.onOpen()

         ## process rest, if any
         ##
         if len(self.data) > 0:
            self.consumeData()


   def failHandshake(self, reason):
      """
      During opening handshake the server response is invalid and we drop the
      connection.
      """
      if self.debug:
         log.msg("failing WebSocket opening handshake ('%s')" % reason)
      self.dropConnection(abort = True)


class WebSocketClientFactory(protocol.ClientFactory, WebSocketFactory):
   """
   A Twisted factory for WebSocket client protocols.
   """

   protocol = WebSocketClientProtocol
   """
   The protocol to be spoken. Must be derived from :class:`autobahn.websocket.WebSocketClientProtocol`.
   """


   def __init__(self, url = None, origin = None, protocols = [], useragent = "AutobahnPython/%s" % __version__, debug = False, debugCodePaths = False):
      """
      Create instance of WebSocket client factory.

      Note that you MUST provide URL either here or set using
      :meth:`autobahn.websocket.WebSocketClientFactory.setSessionParameters`
      *before* the factory is started.

      :param url: WebSocket URL to connect to - ("ws:" | "wss:") "//" host [ ":" port ] path [ "?" query ].
      :type url: str
      :param origin: The origin to be sent in WebSocket opening handshake or None (default: None).
      :type origin: str
      :param protocols: List of subprotocols the client should announce in WebSocket opening handshake (default: []).
      :type protocols: list of strings
      :param useragent: User agent as announced in HTTP request header or None (default: "AutobahnWebSocket/x.x.x").
      :type useragent: str
      :param debug: Debug mode (default: False).
      :type debug: bool
      :param debugCodePaths: Debug code paths mode (default: False).
      :type debugCodePaths: bool
      """
      self.debug = debug
      self.debugCodePaths = debugCodePaths

      self.logOctets = debug
      self.logFrames = debug

      self.trackTimings = False

      self.isServer = False

      ## seed RNG which is used for WS opening handshake key and WS frame masks generation
      random.seed()

      ## default WS session parameters
      ##
      self.setSessionParameters(url, origin, protocols, useragent)

      ## default WebSocket protocol options
      ##
      self.resetProtocolOptions()


   def setSessionParameters(self, url = None, origin = None, protocols = [], useragent = None):
      """
      Set WebSocket session parameters.

      :param url: WebSocket URL to connect to - ("ws:" | "wss:") "//" host [ ":" port ] path [ "?" query ].
      :type url: str
      :param origin: The origin to be sent in opening handshake.
      :type origin: str
      :param protocols: List of WebSocket subprotocols the client should announce in opening handshake.
      :type protocols: list of strings
      :param useragent: User agent as announced in HTTP request header during opening handshake.
      :type useragent: str
      """
      if url is not None:
         ## parse WebSocket URI into components
         (isSecure, host, port, resource, path, params) = parseWsUrl(url)
         self.url = url
         self.isSecure = isSecure
         self.host = host
         self.port = port
         self.resource = resource
         self.path = path
         self.params = params
      else:
         self.url = None
         self.isSecure = None
         self.host = None
         self.port = None
         self.resource = None
         self.path = None
         self.params = None

      self.origin = origin
      self.protocols = protocols
      self.useragent = useragent


   def resetProtocolOptions(self):
      """
      Reset all WebSocket protocol options to defaults.
      """
      self.version = WebSocketProtocol.DEFAULT_SPEC_VERSION
      self.allowHixie76 = WebSocketProtocol.DEFAULT_ALLOW_HIXIE76
      self.utf8validateIncoming = True
      self.acceptMaskedServerFrames = False
      self.maskClientFrames = True
      self.applyMask = True
      self.maxFramePayloadSize = 0
      self.maxMessagePayloadSize = 0
      self.autoFragmentSize = 0
      self.failByDrop = True
      self.echoCloseCodeReason = False
      self.serverConnectionDropTimeout = 1
      self.openHandshakeTimeout = 5
      self.closeHandshakeTimeout = 1
      self.tcpNoDelay = True


   def setProtocolOptions(self,
                          version = None,
                          allowHixie76 = None,
                          utf8validateIncoming = None,
                          acceptMaskedServerFrames = None,
                          maskClientFrames = None,
                          applyMask = None,
                          maxFramePayloadSize = None,
                          maxMessagePayloadSize = None,
                          autoFragmentSize = None,
                          failByDrop = None,
                          echoCloseCodeReason = None,
                          serverConnectionDropTimeout = None,
                          openHandshakeTimeout = None,
                          closeHandshakeTimeout = None,
                          tcpNoDelay = None):
      """
      Set WebSocket protocol options used as defaults for _new_ protocol instances.

      :param version: The WebSocket protocol spec (draft) version to be used (default: WebSocketProtocol.DEFAULT_SPEC_VERSION).
      :type version: int
      :param allowHixie76: Allow to speak Hixie76 protocol version.
      :type allowHixie76: bool
      :param utf8validateIncoming: Validate incoming UTF-8 in text message payloads (default: True).
      :type utf8validateIncoming: bool
      :param acceptMaskedServerFrames: Accept masked server-to-client frames (default: False).
      :type acceptMaskedServerFrames: bool
      :param maskClientFrames: Mask client-to-server frames (default: True).
      :type maskClientFrames: bool
      :param applyMask: Actually apply mask to payload when mask it present. Applies for outgoing and incoming frames (default: True).
      :type applyMask: bool
      :param maxFramePayloadSize: Maximum frame payload size that will be accepted when receiving or 0 for unlimited (default: 0).
      :type maxFramePayloadSize: int
      :param maxMessagePayloadSize: Maximum message payload size (after reassembly of fragmented messages) that will be accepted when receiving or 0 for unlimited (default: 0).
      :type maxMessagePayloadSize: int
      :param autoFragmentSize: Automatic fragmentation of outgoing data messages (when using the message-based API) into frames with payload length <= this size or 0 for no auto-fragmentation (default: 0).
      :type autoFragmentSize: int
      :param failByDrop: Fail connections by dropping the TCP connection without performing closing handshake (default: True).
      :type failbyDrop: bool
      :param echoCloseCodeReason: Iff true, when receiving a close, echo back close code/reason. Otherwise reply with code == NORMAL, reason = "" (default: False).
      :type echoCloseCodeReason: bool
      :param serverConnectionDropTimeout: When the client expects the server to drop the TCP, timeout in seconds (default: 1).
      :type serverConnectionDropTimeout: float
      :param openHandshakeTimeout: Opening WebSocket handshake timeout, timeout in seconds or 0 to deactivate (default: 0).
      :type openHandshakeTimeout: float
      :param closeHandshakeTimeout: When we expect to receive a closing handshake reply, timeout in seconds (default: 1).
      :type closeHandshakeTimeout: float
      :param tcpNoDelay: TCP NODELAY ("Nagle") socket option (default: True).
      :type tcpNoDelay: bool
      """
      if allowHixie76 is not None and allowHixie76 != self.allowHixie76:
         self.allowHixie76 = allowHixie76

      if version is not None:
         if version not in WebSocketProtocol.SUPPORTED_SPEC_VERSIONS:
            raise Exception("invalid WebSocket draft version %s (allowed values: %s)" % (version, str(WebSocketProtocol.SUPPORTED_SPEC_VERSIONS)))
         if version == 0 and not self.allowHixie76:
            raise Exception("use of Hixie-76 requires allowHixie76 == True")
         if version != self.version:
            self.version = version

      if utf8validateIncoming is not None and utf8validateIncoming != self.utf8validateIncoming:
         self.utf8validateIncoming = utf8validateIncoming

      if acceptMaskedServerFrames is not None and acceptMaskedServerFrames != self.acceptMaskedServerFrames:
         self.acceptMaskedServerFrames = acceptMaskedServerFrames

      if maskClientFrames is not None and maskClientFrames != self.maskClientFrames:
         self.maskClientFrames = maskClientFrames

      if applyMask is not None and applyMask != self.applyMask:
         self.applyMask = applyMask

      if maxFramePayloadSize is not None and maxFramePayloadSize != self.maxFramePayloadSize:
         self.maxFramePayloadSize = maxFramePayloadSize

      if maxMessagePayloadSize is not None and maxMessagePayloadSize != self.maxMessagePayloadSize:
         self.maxMessagePayloadSize = maxMessagePayloadSize

      if autoFragmentSize is not None and autoFragmentSize != self.autoFragmentSize:
         self.autoFragmentSize = autoFragmentSize

      if failByDrop is not None and failByDrop != self.failByDrop:
         self.failByDrop = failByDrop

      if echoCloseCodeReason is not None and echoCloseCodeReason != self.echoCloseCodeReason:
         self.echoCloseCodeReason = echoCloseCodeReason

      if serverConnectionDropTimeout is not None and serverConnectionDropTimeout != self.serverConnectionDropTimeout:
         self.serverConnectionDropTimeout = serverConnectionDropTimeout

      if openHandshakeTimeout is not None and openHandshakeTimeout != self.openHandshakeTimeout:
         self.openHandshakeTimeout = openHandshakeTimeout

      if closeHandshakeTimeout is not None and closeHandshakeTimeout != self.closeHandshakeTimeout:
         self.closeHandshakeTimeout = closeHandshakeTimeout

      if tcpNoDelay is not None and tcpNoDelay != self.tcpNoDelay:
         self.tcpNoDelay = tcpNoDelay


   def clientConnectionFailed(self, connector, reason):
      """
      Called by Twisted when the connection to server has failed. Default implementation
      does nothing. Override in derived class when appropriate.
      """
      pass


   def clientConnectionLost(self, connector, reason):
      """
      Called by Twisted when the connection to server was lost. Default implementation
      does nothing. Override in derived class when appropriate.
      """
      pass

########NEW FILE########
__FILENAME__ = xormasker
###############################################################################
##
##  Copyright 2012-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################


## use Cython implementation of XorMasker validator if available
##
try:
   from wsaccel.xormask import XorMaskerNull, createXorMasker

except:
   ## fallback to pure Python implementation

   from array import array

   class XorMaskerNull:

      def __init__(self, mask = None):
         self.ptr = 0

      def pointer(self):
         return self.ptr

      def reset(self):
         self.ptr = 0

      def process(self, data):
         self.ptr += len(data)
         return data


   class XorMaskerSimple:

      def __init__(self, mask):
         assert len(mask) == 4
         self.ptr = 0
         self.msk = array('B', mask)

      def pointer(self):
         return self.ptr

      def reset(self):
         self.ptr = 0

      def process(self, data):
         dlen = len(data)
         payload = array('B', data)
         for k in xrange(dlen):
            payload[k] ^= self.msk[self.ptr & 3]
            self.ptr += 1
         return payload.tostring()


   class XorMaskerShifted1:

      def __init__(self, mask):
         assert len(mask) == 4
         self.ptr = 0
         self.mskarray = [array('B'), array('B'), array('B'), array('B')]
         for j in xrange(4):
            self.mskarray[0].append(ord(mask[ j & 3]))
            self.mskarray[1].append(ord(mask[(j + 1) & 3]))
            self.mskarray[2].append(ord(mask[(j + 2) & 3]))
            self.mskarray[3].append(ord(mask[(j + 3) & 3]))

      def pointer(self):
         return self.ptr

      def reset(self):
         self.ptr = 0

      def process(self, data):
         dlen = len(data)
         payload = array('B', data)
         msk = self.mskarray[self.ptr & 3]
         for k in xrange(dlen):
            payload[k] ^= msk[k & 3]
         self.ptr += dlen
         return payload.tostring()


   def createXorMasker(mask, len = None):
      if len is None or len < 128:
         return XorMaskerSimple(mask)
      else:
         return XorMaskerShifted1(mask)

########NEW FILE########
__FILENAME__ = _version
###############################################################################
##
##  Copyright 2011-2013 Tavendo GmbH
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################

__version__ = "0.6.0"

########NEW FILE########
__FILENAME__ = girder
from __future__ import absolute_import

import cherrypy
import os

class TangeloGirder(object):
    exposed = True

    def __init__(self, host, port):
        # The girder module expects these cherrypy config options to be set
        # already by the time it's imported.
        cherrypy.config.update({
            "sessions": {"cookie_lifetime": 180},
            "server": {"mode": "development"},
            "database": {
                "host": host,
                "port": port,
                "user": "",
                "password": "",
                "database": "girder"
                },
            "users": {
                "email_regex": "^[\w\.\-]*@[\w\.\-]*\.\w+$",
                "login_regex": "^[a-z][\da-z\-]{3}[\da-z\-]*$",
                "login_description": "Login be at least 4 characters, start with a letter, and may only contain letters, numbers, or dashes.",
                "password_regex": ".{6}.*",
                "password_description": "Password must be at least 6 characters."
                },
            "auth": {
                "hash_alg": "bcrypt",
                "bcrypt_rounds": 12
                }
            })

        # Now import the girder modules.  If this fails, it's up to the
        # administrator to make sure Girder is installed and on the PYTHONPATH.
        import girder.events
        from girder import constants
        from girder.api import api_main
        from girder import constants
        from girder.utility import plugin_utilities, model_importer

        self.root_dir = constants.ROOT_DIR

        api_main.addApiToNode(self)

        cherrypy.engine.subscribe("start", girder.events.daemon.start)
        cherrypy.engine.subscribe("stop", girder.events.daemon.stop)

        plugins = model_importer.ModelImporter().model('setting').get(
            constants.SettingKey.PLUGINS_ENABLED, default=())
        plugin_utilities.loadPlugins(plugins, self, cherrypy.config)

        self.config = {"/": {"request.dispatch": cherrypy.dispatch.MethodDispatcher(),
                             "tools.staticdir.root": self.root_dir},
                       "/static": {"tools.staticdir.on": "True",
                                   "tools.staticdir.dir": "clients/web/static"}}

    def GET(self):
        return cherrypy.lib.static.serve_file(
            os.path.join(self.root_dir, "clients", "web", "static",
                         "built", "index.html"), content_type="text/html")

########NEW FILE########
__FILENAME__ = minify_json
'''
Created on 20/01/2011

v0.2 (C) Gerald Storer
MIT License

Based on JSON.minify.js:
https://github.com/getify/JSON.minify

Contributers:
 - Pradyun S. Gedam (conditions and variable names changed)
'''


import re

def json_minify(string, strip_space=True):
    tokenizer = re.compile('"|(/\*)|(\*/)|(//)|\n|\r')
    in_string = False
    in_multi = False
    in_single = False

    new_str = []
    index = 0

    for match in re.finditer(tokenizer, string):

        if not (in_multi or in_single):
            tmp = string[index:match.start()]
            if not in_string and strip_space:
                # replace white space as defined in standard
                tmp = re.sub('[ \t\n\r]+', '', tmp)
            new_str.append(tmp)

        index = match.end()
        val = match.group()

        if val == '"' and not (in_multi or in_single):
            escaped = re.search(r'(\\)*$', string[:match.start()])

            # start of string or unescaped quote character to end string
            if not in_string or (escaped is None or len(escaped.group()) % 2 == 0):
                in_string = not in_string
            index -= 1 # include " character in next catch
        elif not (in_string or in_multi or in_single):
            if val == '/*':
                in_multi = True
            elif val == '//':
                in_single = True
        elif val == '*/' and in_multi and not (in_string or in_single):
            in_multi = False
        elif val in '\r\n' and not (in_multi or in_string) and in_single:
            in_single = False
        elif not ((in_multi or in_single) or (val in ' \r\n\t' and strip_space)):
            new_str.append(val)

    new_str.append(string[index:])
    return ''.join(new_str)


if __name__ == '__main__':
    # Python 2.6+ needed to run tests
    import json
    import textwrap
    import unittest

    class JsonMinifyTestCase(unittest.TestCase):
        """Tests for json_minify"""
        def template(self, in_string, expected):
            in_dict = json.loads(json_minify(in_string))
            expected_dict = json.loads(expected)
            self.assertEqual(in_dict, expected_dict)

        def test_1(self):
            self.template(textwrap.dedent('''
                // this is a JSON file with comments
                {
                    "foo": "bar",    // this is cool
                    "bar": [
                        "baz", "bum"
                    ],
                /* the rest of this document is just fluff
                   in case you are interested. */
                    "something": 10,
                    "else": 20
                }

                /* NOTE: You can easily strip the whitespace and comments
                   from such a file with the JSON.minify() project hosted
                   here on github at http://github.com/getify/JSON.minify
                */'''),
                '{"foo":"bar","bar":["baz","bum"],"something":10,"else":20}'
            )

        def test_2(self):
            self.template(textwrap.dedent('''
                {"/*":"*/","//":"",/*"//"*/"/*/"://
                "//"}'''),
                '{"/*":"*/","//":"","/*/":"//"}'
            )

        def test_3(self):
            self.template(textwrap.dedent(r'''
                /*
                this is a
                multi line comment */{

                "foo"
                :
                    "bar/*"// something
                    ,    "b\"az":/*
                something else */"blah"

                }
                '''),
                r'{"foo":"bar/*","b\"az":"blah"}'
            )

        def test_4(self):
            self.template(textwrap.dedent(r'''
                {"foo": "ba\"r//", "bar\\": "b\\\"a/*z",
                "baz\\\\": /* yay */ "fo\\\\\"*/o"
                }
                '''),
                r'{"foo":"ba\"r//","bar\\":"b\\\"a/*z","baz\\\\":"fo\\\\\"*/o"}'
            )

    unittest.main()

########NEW FILE########
__FILENAME__ = plugin
import errno
import os
import os.path
import re
import stat
import string

import tangelo

from cherrypy.process.plugins import SimplePlugin


class StatusFile(SimplePlugin):
    fields = ["cfg_file", "logfile", "webroot", "hostname", "port", "version"]
    tmpdir = "/var/tmp"

    def __init__(self, bus, cfg_file=None, logfile=None,
                 webroot=None, hostname=None, port=None, version=None):
        SimplePlugin.__init__(self, bus)

        self.finalized = False
        self.pid = os.getpid()
        self.filename = StatusFile.status_filename(self.pid)

        self.status = {k: str(v) for k, v in
                       zip(StatusFile.fields, map(eval, StatusFile.fields))}
        self.status["pid"] = str(self.pid)

        for k, v in self.status.iteritems():
            if v is None:
                raise TypeError("argument '%s' cannot be None" % (k))

    def start(self):
        if self.finalized:
            self.bus.log("Status file for %d already written to %s" %
                         (self.pid, self.filename))
            return

        with open(self.filename, "w") as f:
            for k, v in self.status.iteritems():
                print >>f, " ".join([k, v])

        self.finalized = True
    start.priority = 78

    def exit(self):
        try:
            os.remove(self.filename)
            self.bus.log("Status file removed: %s" % (self.filename))
        except (KeyboardInterrupt, SystemExit):
            raise
        except:
            pass

    @staticmethod
    def read_status_file(filename):
        try:
            with open(filename) as f:
                data = f.readlines()
        except IOError as e:
            if e.errno == errno.EACCES:
                raise IOError(errno.EPERM,
                              "insufficient permissions to " +
                              "retrieve status for pid %d" % (pid))
            else:
                raise
        else:
            try:
                status = {k: v for k, v in map(string.split, data)}
            except ValueError as e:
                if "unpack" in e.message:
                    raise ValueError("fatal error: bad formatting in " +
                                     "status file %s" % (filename))

        return status

    @staticmethod
    def status_filename(pid):
        return "/var/tmp/tangelo.%s" % (pid)

########NEW FILE########
__FILENAME__ = server
import cgi
import datetime
import sys
import HTMLParser
import os
import cherrypy
import json
import imp
import traceback
import types

import tangelo
from tangelo.minify_json import json_minify
import tangelo.util


class Tangelo(object):
    # An HTML parser for use in the error_page handler.
    html = HTMLParser.HTMLParser()

    # An in-band signal to treat HTML error messages as literal strings.
    literal = "literal:::"

    def __init__(self, stream=None):
        self.stream = stream

        # A dict containing information about imported modules.
        self.modules = {}

        # Mount a streaming API if requested.
        #
        # TODO(choudhury): make the mounting directory configurable by the
        # user.
        if self.stream:
            cherrypy.tree.mount(stream, "/stream")

    @staticmethod
    def error_page(status, message, traceback, version):
        if message.startswith(Tangelo.literal):
            message = Tangelo.html.unescape(message[len(Tangelo.literal):])
        return """<!doctype html>
<h2>%s</h2>
<p>%s
<hr>
<p><em>Powered by Tangelo</em> <img src=/favicon.ico>""" % (status, message)

    def invoke_service(self, module, *pargs, **kwargs):
        # TODO(choudhury): This method should attempt to load the named module,
        # then invoke it with the given arguments.  However, if the named
        # module is "config" or something similar, the method should instead
        # launch a special "config" app, which lists the available app modules,
        # along with docstrings or similar.  It should also allow the user to
        # add/delete search paths for other modules.
        tangelo.content_type("text/plain")

        # Save the system path (be sure to *make a copy* using the list()
        # function) - it will be modified before invoking the service, and must
        # be restored afterwards.
        origpath = list(sys.path)

        # By default, the result should be an object with error message in if
        # something goes wrong; if nothing goes wrong this will be replaced
        # with some other object.
        result = {}

        # Store the modpath in the thread-local storage (tangelo.paths() makes
        # use of this per-thread data, so this is the way to get the data
        # across the "module boundary" properly).
        modpath = os.path.dirname(module)
        cherrypy.thread_data.modulepath = modpath
        cherrypy.thread_data.modulename = module

        # Extend the system path with the module's home path.
        sys.path.insert(0, modpath)

        # Import the module if not already imported previously (or if the
        # module to import, or its configuration file, has been updated since
        # the last import).
        try:
            stamp = self.modules.get(module)
            mtime = os.path.getmtime(module)

            config_file = module[:-2] + "json"
            config_mtime = None
            if os.path.exists(config_file):
                config_mtime = os.path.getmtime(config_file)

            if (stamp is None or
                    mtime > stamp["mtime"] or
                    (config_mtime is not None and
                     config_mtime > stamp["mtime"])):
                if stamp is None:
                    tangelo.log("loading new module: " + module)
                else:
                    tangelo.log("reloading module: " + module)

                # Load any configuration the module might carry with it.
                if config_mtime is not None:
                    try:
                        with open(config_file) as f:
                            config = json.loads(json_minify(f.read()))
                            if type(config) != dict:
                                msg = ("Service module configuration file " +
                                       "does not contain a key-value store " +
                                       "(i.e., a JSON Object)")
                                tangelo.log(msg)
                                raise TypeError(msg)
                    except IOError:
                        tangelo.log("Could not open config file %s" %
                                    (config_file))
                        raise
                    except ValueError as e:
                        tangelo.log("Error reading config file %s: %s" %
                                    (config_file, e))
                        raise
                else:
                    config = {}

                cherrypy.config["module-config"][module] = config

                # Remove .py to get the module name
                name = module[:-3]

                # Load the module.
                service = imp.load_source(name, module)
                self.modules[module] = {"module": service,
                                        "mtime": max(mtime, config_mtime)}
            else:
                service = stamp["module"]
        except:
            bt = traceback.format_exc()

            tangelo.log("Error importing module %s" % (tangelo.request_path()),
                        "SERVICE")
            tangelo.log(bt, "SERVICE")

            result = tangelo.HTTPStatusCode("501 Error in Python Service",
                                            Tangelo.literal + "There was an error while " +
                                            "trying to import module " +
                                            "%s:<br><pre>%s</pre>" %
                                            (tangelo.request_path(), bt))
        else:
            # Try to run the service - either it's in a function called
            # "run()", or else it's in a REST API consisting of at least one of
            # "get()", "put()", "post()", or "delete()".
            #
            # Collect the result in a variable - depending on its type, it will
            # be transformed in some way below (by default, to JSON, but may
            # also raise a cherrypy exception, log itself in a streaming table,
            # etc.).
            try:
                if 'run' in dir(service):
                    # Call the module's run() method, passing it the positional
                    # and keyword args that came into this method.
                    result = service.run(*pargs, **kwargs)
                else:
                    # Reaching here means it's a REST API.  Check for the
                    # requested method, ensure that it was marked as being part
                    # of the API, and call it; or give a 405 error.
                    method = cherrypy.request.method
                    restfunc = service.__dict__[method.lower()]
                    if (restfunc is not None and
                            hasattr(restfunc, "restful") and
                            restfunc.restful):
                        result = restfunc(*pargs, **kwargs)
                    else:
                        result = tangelo.HTTPStatusCode(405,
                                                        "Method not allowed")
            except Exception as e:
                bt = traceback.format_exc()

                tangelo.log("Caught exception while executing service %s" %
                            (tangelo.request_path()), "SERVICE")
                tangelo.log(bt, "SERVICE")

                result = tangelo.HTTPStatusCode("501 Error in Python Service",
                                                Tangelo.literal + "There was an error " +
                                                "executing service " +
                                                "%s:<br><pre>%s</pre>" %
                                                (tangelo.request_path(), bt))

        # Restore the path to what it was originally.
        sys.path = origpath

        # Check the type of the result to decide what result to finally return:
        #
        # 1. If it is an HTTPStatusCode object, raise a cherrypy HTTPError
        # exception, which will cause the browser to do the right thing.
        #
        # 2. TODO: If it's a Python generator object, log it with the Tangelo
        # streaming API.
        #
        # 3. If it's a Python dictionary, convert it to JSON.
        #
        # 4. If it's a string, don't do anything to it.
        #
        # This allows the services to return a Python object if they wish, or
        # to perform custom serialization (such as for MongoDB results, etc.).
        if isinstance(result, tangelo.HTTPStatusCode):
            if result.msg:
                raise cherrypy.HTTPError(result.code, result.msg)
            else:
                raise cherrypy.HTTPError(result.code)
        elif "next" in dir(result):
            if self.stream:
                return self.stream.add(result)
            else:
                return json.dumps({"error": "Streaming is not supported " +
                                            "in this instance of Tangelo"})
        elif not isinstance(result, types.StringTypes):
            try:
                result = json.dumps(result)
            except TypeError as e:
                msg = Tangelo.literal + "<p>A JSON type error occurred in service " + tangelo.request_path() + ":</p>"
                msg += "<p><pre>" + cgi.escape(e.message) + "</pre></p>"

                raise cherrypy.HTTPError("501 Error in Python Service", msg)

        return result

    @staticmethod
    def dirlisting(dirpath, reqpath):
        if reqpath[-1] == "/":
            reqpath = reqpath[:-1]
        files = filter(lambda x: len(x) > 0 and x[0] != ".",
                       os.listdir(dirpath))
        # filespec = ["Type", "Name", "Last modified", "Size"]
        filespec = []
        for f in files:
            p = dirpath + os.path.sep + f
            try:
                s = os.stat(p)
            except OSError:
                pass
            else:
                mtime = (datetime.datetime
                         .fromtimestamp(s.st_mtime)
                         .strftime("%Y-%m-%d %H:%M:%S"))

                if os.path.isdir(p):
                    f += "/"
                    t = "dir"
                    s = "-"
                else:
                    t = "file"
                    s = s.st_size

                filespec.append([t, "<a href=\"%s/%s\">%s</a>" %
                                    (reqpath, f, f),
                                 mtime, s])

        filespec = "\n".join(
            map(lambda row: "<tr>" +
                            "".join(map(lambda x: "<td>%s</td>" % x,
                                    row)) +
                            "</tr>",
                filespec))

        result = """<!doctype html>
<title>Index of %s</title>
<h1>Index of %s</h1>
<table>
<tr>
    <th>Type</th><th>Name</th><th>Last Modified</th><th>Size</th>
</tr>
%s
</table>
""" % (reqpath, reqpath, filespec)

        return result

    @cherrypy.expose
    def default(self, *path, **args):
        target = cherrypy.thread_data.target
        if target is not None:
            if target["type"] == "file":
                return cherrypy.lib.static.serve_file(target["path"])
            elif target["type"] == "dir":
                return Tangelo.dirlisting(target["path"],
                                          cherrypy.request.path_info)
            elif target["type"] == "service":
                return self.invoke_service(target["path"],
                                           *target["pargs"],
                                           **args)
            elif target["type"] == "404":
                raise cherrypy.lib.static.serve_file(target["path"])
            elif target["type"] == "restricted":
                raise cherrypy.HTTPError("403 Forbidden",
                                         "The path '%s' is forbidden" % (cherrypy.serving.request.path_info))
            else:
                raise RuntimeError("Illegal target type '%s'" %
                                   (target["type"]))

########NEW FILE########
__FILENAME__ = stream
import json
import traceback

import cherrypy

import tangelo


class TangeloStream(object):
    def __init__(self):
        self.streams = {}

    @cherrypy.expose
    def default(self, key=None):
        # Construct a result object.
        result = {}

        # Perform the requested action: GET means to either return a list of
        # stream keys, or to run the keyed stream one step; DELETE means to
        # delete a keyed stream from the registry.
        method = cherrypy.request.method
        if method == "GET":
            if key is None:
                result = self.streams.keys()
            elif key not in self.streams:
                result["error"] = "Unknown key"
            else:
                # Grab the stream in preparation for running it.
                stream = self.streams[key]

                # Attempt to run the stream via its next() method - if this
                # yields a result, then continue; if the next() method raises
                # StopIteration, then there are no more results to retrieve; if
                # any other exception is raised, this is treated as an error.
                try:
                    result["data"] = stream.next()
                    result["finished"] = False
                except StopIteration:
                    result["finished"] = True
                    del self.streams[key]
                except:
                    del self.streams[key]
                    raise cherrypy.HTTPError(
                        "501 Error in Python Service",
                        "Caught exception while executing stream " +
                        "service keyed by %s:<br><pre>%s</pre>" %
                        (key, traceback.format_exc()))

        elif method == "DELETE":
            if key is None:
                result["error"] = "No key specified"
            elif key not in self.streams:
                result["error"] = "Unknown key"
            else:
                del self.streams[key]
                result["key"] = key

        else:
            # All other methods are illegal.
            raise cherrypy.HTTPError(405)

        # JSON-serialize the result and return it.
        try:
            return json.dumps(result)
        except TypeError:
            raise cherrypy.HTTPError(
                "501 Bad Response from Python Service",
                ("The stream keyed by %s returned a non " +
                 "JSON-seriazable result: %s") % (key, result["data"]))

    def add(self, stream):
        # Generate a key corresponding to this object.
        key = tangelo.util.generate_key(self.streams)

        # Log the object in the streaming table.
        self.streams[key] = stream

        # Create an object describing the logging of the generator object.
        result = {"key": key}

        # Serialize it to JSON.
        return json.dumps(result)

########NEW FILE########
__FILENAME__ = tool
import cherrypy
import os

import tangelo
import tangelo.server


# A function to run as a before_handler hook that examines a request path and
# "normalizes" it, either by appending a slash or "index.html", etc.
def treat_url():
    reqpath = cherrypy.request.path_info
    webroot = cherrypy.config.get("webroot")

    # Clear the thread storage.
    cherrypy.thread_data.target = None
    cherrypy.thread_data.do_auth = True

    # If the request path is blank, redirect to /.
    if reqpath == "":
        raise cherrypy.HTTPRedirect("/")

    # Compute "parallel" path component lists based on the web root and the
    # disk root.
    if reqpath == "/":
        reqpathcomp = []
        pathcomp = [webroot]
    else:
        # Split the request path into path components, omitting the leading
        # slash.
        reqpathcomp = reqpath[1:].split("/")

        # Compute the disk path the URL corresponds to.
        #
        # First check to see whether the path is absolute (i.e. rooted at
        # webroot) or in a user home directory.
        if reqpathcomp[0][0] == "~" and len(reqpathcomp[0]) > 1:
            # Only treat this component as a home directory if there is
            # actually text following the tilde (rather than making the server
            # serve files from the home directory of whatever user account it
            # is using to run).
            pathcomp = [os.path.expanduser(reqpathcomp[0]) +
                        os.path.sep +
                        "tangelo_html"] + reqpathcomp[1:]
        else:
            pathcomp = [webroot] + reqpathcomp

    # Save the request path and disk path components in the thread storage,
    # slightly modifying the request path if it refers to an absolute path
    # (indicated by being one element shorter than the disk path).
    if len(reqpathcomp) == len(pathcomp) - 1:
        reqpathcomp_save = [""] + reqpathcomp
    elif len(reqpathcomp) == len(pathcomp):
        reqpathcomp_save = ["/" + reqpathcomp[0]] + reqpathcomp[1:]
    else:
        raise RuntimeError("reqpathcomp and pathcomp lengths are wonky")

    # If the path represents a directory and has a trailing slash, remove it
    # (this will make the auth update step easier).
    if (len(reqpathcomp_save) > 1 and
            reqpathcomp_save[-1] == "" or
            pathcomp[-1] == ""):
        assert reqpathcomp_save[-1] == "" and pathcomp[-1] == ""
        reqpathcomp_save = reqpathcomp_save[:-1]
        pathcomp_save = pathcomp[:-1]
    else:
        pathcomp_save = pathcomp

    cherrypy.thread_data.reqpathcomp = reqpathcomp_save
    cherrypy.thread_data.pathcomp = pathcomp_save

    # If pathcomp has more than one element, fuse the first two together.  This
    # makes the search for a possible service below much simpler.
    if len(pathcomp) > 1:
        pathcomp = [pathcomp[0] + os.path.sep + pathcomp[1]] + pathcomp[2:]

    # Form an actual path string.
    path = os.path.sep.join(pathcomp)

    # If the path is a directory, check for a trailing slash.  If missing,
    # perform a redirect to the path WITH the trailing slash.  Otherwise, check
    # for an index.html file in that directory; if found, perform an internal
    # redirect to that file.  Otherwise, leave the path alone - it now
    # represents a request for a directory listing.
    #
    # If instead the path isn't a directory, check to see if it's a regular
    # file.  If it is, save the path in thread local storage - this will let
    # the handler very quickly serve the file.
    #
    # If it is not a regular file, then check to see if it is a python service.
    #
    # Finally, if it is none of the above, then indicate a 404 error.
    if os.path.isdir(path):
        if reqpath[-1] != "/":
            raise cherrypy.HTTPRedirect(reqpath + "/")
        elif os.path.exists(path + os.path.sep + "index.html"):
            raise cherrypy.InternalRedirect(reqpath + "index.html")
        else:
            cherrypy.thread_data.target = {"type": "dir",
                                           "path": path}
    elif os.path.exists(path):
        # Don't serve Python files (if someone really wants to serve the program
        # text, they can create a symlink with a different file extension and
        # that will be served just fine).
        if len(path) > 3 and path[-3:] == ".py":
            cherrypy.thread_data.target = {"type": "restricted",
                                           "path": path}
        else:
            # Also do not serve config files that match up to Python files.
            if (len(path) > 5 and
                    path[-5:] == ".json" and
                    os.path.exists(path[:-5] + ".py")):
                cherrypy.thread_data.target = {"type": "restricted",
                                               "path": path}
            else:
                cherrypy.thread_data.target = {"type": "file",
                                               "path": path}
    else:
        service_path = None
        pargs = None
        # for i, comp in enumerate(pathcomp):
        for i in range(len(pathcomp)):
            service_path = os.path.sep.join(pathcomp[:(i + 1)]) + ".py"
            if os.path.exists(service_path):
                pargs = pathcomp[(i + 1):]
                break

        if pargs is None:
            cherrypy.thread_data.target = {"type": "404",
                                           "path": path}
            cherrypy.thread_data.do_auth = False
        else:
            cherrypy.thread_data.target = {"type": "service",
                                           "path": service_path,
                                           "pargs": pargs}


class AuthUpdate(cherrypy.Tool):
    # A list of acceptable authentication types.
    allowed_auth_types = ["digest"]

    def __init__(self, point="before_handler", priority=50):
        # cherrypy.Tool attributes.
        self._name = None
        self._point = point
        self._priority = priority

        # A record of installed auth tools.
        self.security = {}

    @staticmethod
    def parse_htaccess(filename):
        result = {"msg": None,
                  "auth_type": None,
                  "user_file": None,
                  "realm": None,
                  "userpass": None}

        # Try to open and parse the file.
        try:
            with open(filename) as f:
                lines = filter(lambda x: len(x) > 0,
                               map(lambda x: x.strip().split(), f.readlines()))
                keys = map(lambda x: x[0], lines)
                values = map(lambda x: " ".join(x[1:]), lines)

                for i, (k, v) in enumerate(zip(keys, values)):
                    if k == "AuthType":
                        if v not in AuthUpdate.allowed_auth_types:
                            allowed = ", ".join(AuthUpdate.allowed_auth_types)
                            result["msg"] = (
                                "%s is not a supported " +
                                "authentication type.  The " +
                                "supported types are: %s") % (v, allowed)
                            return result
                        else:
                            result["auth_type"] = v
                    elif k in ["AuthPasswordFile", "AuthUserFile"]:
                        result["user_file"] = v
                    elif k == "AuthRealm":
                        result["realm"] = v
                    else:
                        result["msg"] = (
                            "Unknown key '%s' on " +
                            "line %d of file '%s'") % (k, i + 1, filename)
                        return result
        except IOError:
            result["msg"] = "Could not open file '%s'" % (filename)
            return result

        # Open the user file and parse out the username/passwords of those
        # users in the correct realm.
        recs = None
        if result["user_file"] is not None:
            try:
                with open(result["user_file"]) as f:
                    recs = filter(lambda x: x[1] == result["realm"],
                                  map(lambda x: x.strip().split(":"),
                                      f.readlines()))
            except IOError:
                result["msg"] = ("Could not open user " +
                                 "password file '%s'") % (result["user_file"])
                return result
            except IndexError:
                result["msg"] = ("Malformed content in user password file " +
                                 "'%s' (some line has too " +
                                 "few fields)") % (result["user_file"])
                return result

        try:
            result["userpass"] = {x[0]: x[2] for x in recs}
        except IndexError:
            result["msg"] = ("Malformed content in user password file " +
                             "'%s' (some line has too " +
                             "few fields)") % (result["user_file"])
            return result

        return result

    def htaccess(self, htfile, reqpath):
        changed = False
        if htfile is None:
            if reqpath in self.security:
                del self.security[reqpath]

                cfg = tangelo.server.cpserver.config[reqpath]
                for a in AuthUpdate.allowed_auth_types:
                    key = "tools.auth_%s.on" % (a)
                    if key in cfg:
                        cfg[key] = False
                    tangelo.server.cpserver.merge({reqpath: cfg})
                    changed = True
        else:
            # Get the mtime of the htfile.
            ht_mtime = os.stat(htfile).st_mtime

            if (reqpath not in self.security or
                    ht_mtime > self.security[reqpath]):
                # We have either a new .htaccess file, or one that has
                # been modified list the last request to this path.
                htspec = AuthUpdate.parse_htaccess(htfile)
                if htspec["msg"] is not None:
                    tangelo.log("[AuthUpdate] Could not register %s: %s" %
                                (reqpath, htspec["msg"]))
                    return changed, htspec["msg"]

                # Create an auth config tool using the values in the htspec.
                toolname = "tools.auth_%s." % (htspec["auth_type"])
                passdict = (
                    lambda realm, username: htspec["userpass"].get(username))
                # TODO(choudhury): replace "deadbeef" with a nonce created
                # randomly in the __init__() method.
                auth_conf = {toolname + "on": True,
                             toolname + "realm": htspec["realm"],
                             toolname + "get_ha1": passdict,
                             toolname + "key": "deadbeef"}

                tangelo.server.cpserver.merge({reqpath: auth_conf})

                # Store the mtime in the security table.
                self.security[reqpath] = ht_mtime

                changed = True

        return changed, None

    def callable(self):
        if not cherrypy.thread_data.do_auth:
            return

        # Grab the saved request and disk path lists.  The first component of
        # both lists should be the "root" directory corresponding to the
        # resource (either the webroot, or ~user/tangelo_html).
        reqpathcomp = cherrypy.thread_data.reqpathcomp
        pathcomp = cherrypy.thread_data.pathcomp

        # The lengths of the lists should be equal.
        assert len(reqpathcomp) == len(pathcomp)

        # Create a list of paths to search, starting with the requested
        # resource and moving towards the root.
        paths = reversed(map(lambda i: ("/".join(reqpathcomp[:(i + 1)]) or "/",
                                        os.path.sep.join(pathcomp[:(i + 1)])),
                             range(len(reqpathcomp))))

        # Check each path that represents a directory for a .htaccess file,
        # then decide what to do based on the current auth state for that path.
        for rpath, dpath in paths:
            if os.path.isdir(dpath):
                htfile = dpath + os.path.sep + ".htaccess"
                if not os.path.exists(htfile):
                    htfile = None

                changed, msg = self.htaccess(htfile, rpath)
                if msg is not None:
                    raise cherrypy.HTTPError(401,
                                             "There was an error in the " +
                                             "HTTP authentication " +
                                             "process: %s" % (msg))

                # TODO(choudhury): I really don't understand why this hack is
                # necessary.  Basically, when the auth_* tool is installed on
                # the path in the htaccess() method, it doesn't seem to take
                # hold until the next time the page is loaded.  So this hack
                # forces a page reload, but it would be better to simply make
                # the new config "take hold" instead.
                if changed:
                    raise cherrypy.HTTPRedirect(cherrypy.request.path_info)

                # Don't bother updating the security table for higher paths -
                # we'll process those later, when they are requested.
                break

########NEW FILE########
__FILENAME__ = util
import errno
import fnmatch
import os
import os.path
import md5
import socket
import threading
import Queue

import tangelo.plugin


def get_free_port():
    # Bind a socket to port 0 (which directs the OS to find an unused port).
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind(("", 0))

    # Get the port number, and release the resources used in binding the port
    # (no need to call shutdown() because we never called listen() or accept()
    # on it).
    port = s.getsockname()[1]
    s.close()

    return port


def expandpath(spec):
    return (os.path.expanduser if spec[0] == "~" else os.path.abspath)(spec)


def live_pid(pid):
    try:
        os.kill(pid, 0)
    except OSError as e:
        # ESRCH means os.kill() couldn't find a valid pid to send the signal
        # to, which means it's not a live PID.  The other possible error value
        # is EPERM, meaning that the pid is live but the user doesn't have the
        # permissions to send it a signal.
        return e.errno != errno.ESRCH
    else:
        return True


def read_pid(pidfile):
    # Open the file and convert the contents to an integer - if this fails for
    # any reason, whatever exception is raised will propagate up to the caller.
    with open(pidfile) as f:
        pid = int(f.read())

    return pid


def generate_key(taken, randbytes=128):
    key = md5.md5(os.urandom(randbytes)).hexdigest()
    while key in taken:
        key = md5.md5(os.urandom(randbytes)).hexdigest()

    return key


def pid_from_port(port):
    # Find the pid of the tangelo process running on the requested port.
    #
    # Start by getting a "blank" status filename.
    filebase = tangelo.plugin.StatusFile.status_filename("*")

    # Split the directory out from the filebase string.
    components = filebase.split(os.path.sep)
    directory = os.path.sep.join(components[:-1])
    pattern = components[-1]

    # Get a list of the status files by using UNIX-style wildcard patterns.
    status_files = [directory + os.path.sep + f
                    for f in os.listdir(directory)
                    if fnmatch.fnmatch(f, pattern)]

    # Find the file for the process running on the specified port.
    for f in status_files:
        pstatus = tangelo.plugin.StatusFile.read_status_file(f)
        if pstatus["port"] == str(port) and live_pid(int(pstatus["pid"])):
            break
        pstatus = None

    if pstatus is None:
        return None

    return int(pstatus["pid"])


class NonBlockingReader(threading.Thread):
    def __init__(self, stream):
        threading.Thread.__init__(self)
        self.daemon = True

        self.stream = stream
        self.queue = Queue.Queue()
        self.pushbuf = []

        self.start()

    def run(self):
        for line in iter(self.stream.readline, ""):
            self.queue.put(line)
        self.stream.close()

    def readline(self):
        if len(self.pushbuf) > 0:
            return self.pushbuf.pop()
        else:
            try:
                line = self.queue.get_nowait()
            except Queue.Empty:
                line = None

            return line

    def readlines(self):
        lines = []
        done = False
        while not done:
            line = self.readline()
            if line is not None:
                lines.append(line)
            else:
                done = True

        return lines

    def pushline(self, line):
        if len(line) == 0 or line[-1] != "\n":
            line.append("\n")

        self.pushbuf.append(line)

    def pushlines(self, lines):
        for line in lines:
            self.pushline(line)

########NEW FILE########
__FILENAME__ = vtkweb
import json
import os
import subprocess
import time

import cherrypy

import tangelo.websocket


class TangeloVtkweb(object):
    def __init__(self, vtkpython=None, weblauncher=None):
        if vtkpython is None:
            raise TypeError("required argument 'vtkpython' missing")
        elif weblauncher is None:
            raise TypeError("required argument 'weblauncher' missing")

        self.vtkpython = vtkpython
        self.weblauncher = weblauncher

        self.processes = {}

    def shutdown_all(self):
        # TODO(choudhury): remove the entries from the table as the processes
        # are shut down.
        #
        # Terminate the VTK web processes.
        for p in self.processes.values():
            p["process"].terminate()
            p["process"].wait()

    @cherrypy.expose
    def default(self, *pargs, **kwargs):
        # Get keyword arguments.
        progpath = kwargs.get("program", None)
        progargs = kwargs.get("args", "")
        timeout = kwargs.get("timeout", 0)

        # Convert the positional args to a list.
        pargs = list(pargs)

        # Dispatch a RESTful action.
        method = cherrypy.request.method
        if method == "GET":
            # If there is no key argument, send back a list of all the keys.
            if len(pargs) == 0:
                response = self.processes.keys()
            else:
                # Extract the key argument.
                key = pargs[0]

                # Check for the key in the process table.
                if key not in self.processes:
                    return json.dumps(
                        {"status": "failed",
                         "reason": "Requested key not in process table"})

                # Retrieve the entry.
                rec = self.processes[key]
                response = {"status": "complete",
                            "process": "running",
                            "port": rec["port"],
                            "stdout": rec["stdout"].readlines(),
                            "stderr": rec["stderr"].readlines()}

                returncode = rec["process"].poll()
                if returncode is not None:
                    # Since the process has ended, delete the process object.
                    del self.processes[key]

                    # Fill out the report response.
                    response["process"] = "terminated"
                    response["returncode"] = returncode

            # Make a report to the user.
            return json.dumps(response)
        elif method == "POST":
            # if len(pargs) == 0:
            if progpath is None or len(progpath) == 0:
                return json.dumps(
                    {"status": "incomplete",
                     "reason": "missing 'program' argument " +
                               "(path to vtkweb script)"})

            # Check the user arguments.
            userargs = progargs.split()
            if "--port" in userargs:
                return json.dumps(
                    {"status": "incomplete",
                     "reason": "You may not specify --port in this interface"})

            # The program path must begin with a slash (it needs to be an
            # absolute path because we can't evaluate relative paths on the
            # serverside, since we don't know the user's current location).
            if progpath[0] != "/":
                return json.dumps(
                    {"status": "incomplete",
                     "reason": "Program path must be an absolute web path"})

            # Verify that the program path is legal (first stripping off the
            # leading slash, since from now on we are considering *disk* paths,
            # while all relative paths are now relative to the web root).

            # Obtain a filesystem path to the requested program.
            progfile = tangelo.abspath(progpath)
            if progfile is None:
                return json.dumps({"status": "incomplete",
                                   "reason": "Illegal program URL"})

            # Obtain an available port.
            port = tangelo.util.get_free_port()

            # Generate a unique key.
            key = tangelo.util.generate_key(self.processes.keys())

            def launch_failure(msg):
                # On launch failure, report the failure to the user.
                return json.dumps({"status": "failed", "reason": msg})

            # Detect http vs. https
            scheme = "ws"
            ssl_key = cherrypy.config.get("server.ssl_private_key")
            ssl_cert = cherrypy.config.get("server.ssl_certificate")

            # Generate command line.
            cmdline = [self.vtkpython,
                       self.weblauncher,
                       progfile,
                       "--port", str(port)] + userargs
            if ssl_key and ssl_cert:
                scheme = "wss"
                cmdline.extend(["--sslKey", ssl_key, "--sslCert", ssl_cert])

            # Launch the requested process.
            tangelo.log("starting a vtkweb process: %s" % (" ".join(cmdline)))
            try:
                process = subprocess.Popen(cmdline,
                                           stdout=subprocess.PIPE,
                                           stderr=subprocess.PIPE)
            except OSError as e:
                return launch_failure(e.strerror)
            except IOError as e:
                return launch_failure(e.strerror)

            # Capture the new process's stdout and stderr streams in
            # non-blocking readers.
            stdout = tangelo.util.NonBlockingReader(process.stdout)
            stderr = tangelo.util.NonBlockingReader(process.stderr)

            # Read from stdout to look for the signal that the process has
            # started properly.
            class FactoryStarted:
                pass

            class Failed:
                pass

            class Timeout:
                pass

            signal = "Starting factory"
            timeout = 10
            sleeptime = 0.5
            wait = 0
            saved_lines = []
            try:
                while True:
                    lines = stdout.readlines()
                    saved_lines += lines
                    for line in lines:
                        if line == "":
                            # This indicates that stdout has closed without
                            # starting the process.
                            raise Failed()
                        elif signal in line:
                            # This means that the server has started.
                            raise FactoryStarted()

                    # If neither failure nor success occurred in the last block
                    # of lines from stdout, either time out, or try again after
                    # a short delay.
                    if wait >= timeout:
                        raise Timeout()

                    wait += sleeptime
                    time.sleep(sleeptime)
            except Timeout:
                return json.dumps({"status": "failed",
                                   "reason": "process startup timed out"})
            except Failed:
                return json.dumps(
                    {"status": "failed",
                     "reason": "process did not start up properly",
                     "stdout": saved_lines,
                     "stderr": stderr.readlines()})
            except FactoryStarted:
                stdout.pushlines(saved_lines)

            # Create a websocket handler path dedicated to this process.
            host = cherrypy.server.socket_host
            if host == "0.0.0.0":
                host = "localhost"
            wshandler = tangelo.websocket.WebSocketRelay(host, port, key)
            cherrypy.tree.mount(
                tangelo.websocket.WebSocketHandler(),
                "/%s" % (key),
                config={"/ws": {"tools.websocket.on": True,
                                "tools.websocket.handler_cls": wshandler,
                                "tools.websocket.protocols": ["wamp"]}})

            # Log the new process in the process table, including non-blocking
            # stdout and stderr readers.
            self.processes[key] = {"port": port,
                                   "process": process,
                                   "stdout": stdout,
                                   "stderr": stderr}

            # Form the websocket URL from the hostname/port used in the
            # request, and the newly generated key.
            url = "%s://%s/%s/ws" % (scheme, cherrypy.request.base.split("//")[1], key)
            return json.dumps({"status": "complete", "key": key, "url": url})
        elif method == "DELETE":
            # TODO(choudhury): shut down a vtkweb process by key after a given
            # timeout.

            # Make sure there's a key.
            if len(pargs) == 0:
                return json.dumps({"status": "incomplete",
                                   "reason": "'key' argument is REQUIRED"})

            # Extract the key.
            key = pargs[0]
            tangelo.log("shutting down %s" % (key))

            # Check for the key in the process table.
            if key not in self.processes:
                tangelo.log("key not found")
                return json.dumps({"status": "failed",
                                   "reason": "no such key in process table"})

            # Terminate the process.
            tangelo.log("terminating process")
            proc = self.processes[key]
            proc["process"].terminate()
            proc["process"].wait()
            tangelo.log("terminated")

            # Remove the process entry from the table.
            del self.processes[key]

            return json.dumps({"status": "complete",
                               "key": key})
        else:
            raise cherrypy.HTTPError(405, "Method not allowed")

########NEW FILE########
__FILENAME__ = websocket
import threading
import cherrypy
from tangelo.ws4py.server.cherrypyserver import WebSocketPlugin
import tangelo.ws4py.websocket
import tangelo.autobahn.websocket as ab_websocket
import tangelo.autobahn.wamp as wamp
import twisted.internet

import tangelo


class WebSocketLowPriorityPlugin(WebSocketPlugin):
    def __init__(self, *pargs, **kwargs):
        WebSocketPlugin.__init__(self, *pargs, **kwargs)

    # This version of start() differs only in that it has an assigned priority.
    # The default priority is 50, which is what the actual WebSocketPlugin's
    # start method gets, which means it runs before the privilege drop gets a
    # chance to (priority 77, slightly lower than the 75 of the engine start
    # itself).  For some reason if this runs before the priv drop, things get
    # screwed up.
    def start(self):
        WebSocketPlugin.start(self)
    start.priority = 80


class WebSocketHandler(object):
    @cherrypy.expose
    def index(self):
        return "OK"

    @cherrypy.expose
    def ws(self):
        pass


def VTKWebSocketAB(url, relay):
    class RegisteringWebSocketClientFactory(wamp.WampClientFactory):
        def register(self, client):
            self.client = client

    class Protocol(wamp.WampClientProtocol):
        def onOpen(self):
            self.factory.register(self)

        def onMessage(self, msg, is_binary):
            relay.send(msg)

    class Connection(threading.Thread):
        def run(self):
            self.factory = RegisteringWebSocketClientFactory(url)
            self.factory.protocol = Protocol
            twisted.internet.reactor.callFromThread(ab_websocket.connectWS,
                                                    self.factory)

        def send(self, data):
            twisted.internet.reactor.callFromThread(Protocol.sendMessage,
                                                    self.factory.client,
                                                    data)

    c = Connection()
    c.start()
    return c


def WebSocketRelay(hostname, port, key):
    class Class(tangelo.ws4py.websocket.WebSocket):
        def __init__(self, *pargs, **kwargs):
            tangelo.ws4py.websocket.WebSocket.__init__(self, *pargs, **kwargs)

            scheme = "ws"
            if cherrypy.config.get("server.ssl_private_key"):
                scheme = "wss"
            url = "%s://%s:%d/ws" % (scheme, hostname, port)

            tangelo.log("websocket created at %s:%d/%s (proxy to %s)" %
                        (hostname, port, key, url))

            self.client = VTKWebSocketAB(url, self)

        def closed(self, code, reason=None):
            # TODO(choudhury): figure out if recovery, etc. is possible if the
            # socket is closed for some reason.
            tangelo.log("websocket at %s:%d/%s closed with code %d (%s)" %
                        (hostname, port, key, code, reason))

        def received_message(self, msg):
            self.client.send(msg.data)

    return Class

########NEW FILE########
__FILENAME__ = geventclient
# -*- coding: utf-8 -*-
import copy

import gevent
from gevent import Greenlet
from gevent.queue import Queue

from ws4py.client import WebSocketBaseClient

__all__ = ['WebSocketClient']

class WebSocketClient(WebSocketBaseClient):
    def __init__(self, url, protocols=None, extensions=None, ssl_options=None, headers=None):
        """
        WebSocket client that executes the
        :meth:`run() <ws4py.websocket.WebSocket.run>` into a gevent greenlet.

        .. code-block:: python

          ws = WebSocketClient('ws://localhost:9000/echo', protocols=['http-only', 'chat'])
          ws.connect()

          ws.send("Hello world")

          def incoming():
            while True:
               m = ws.receive()
               if m is not None:
                  print str(m)
               else:
                  break

          def outgoing():
            for i in range(0, 40, 5):
               ws.send("*" * i)

          greenlets = [
             gevent.spawn(incoming),
             gevent.spawn(outgoing),
          ]
          gevent.joinall(greenlets)
        """
        WebSocketBaseClient.__init__(self, url, protocols, extensions,
                                     ssl_options=ssl_options, headers=headers)
        self._th = Greenlet(self.run)

        self.messages = Queue()
        """
        Queue that will hold received messages.
        """

    def handshake_ok(self):
        """
        Called when the upgrade handshake has completed
        successfully.

        Starts the client's thread.
        """
        self._th.start()

    def received_message(self, message):
        """
        Override the base class to store the incoming message
        in the `messages` queue.
        """
        self.messages.put(copy.deepcopy(message))

    def closed(self, code, reason=None):
        """
        Puts a :exc:`StopIteration` as a message into the
        `messages` queue.
        """
        # When the connection is closed, put a StopIteration
        # on the message queue to signal there's nothing left
        # to wait for
        self.messages.put(StopIteration)

    def receive(self):
        """
        Returns messages that were stored into the
        `messages` queue and returns `None` when the
        websocket is terminated or closed.
        """
        # If the websocket was terminated and there are no messages
        # left in the queue, return None immediately otherwise the client
        # will block forever
        if self.terminated and self.messages.empty():
            return None
        message = self.messages.get()
        if message is StopIteration:
            return None
        return message

########NEW FILE########
__FILENAME__ = threadedclient
# -*- coding: utf-8 -*-
import threading

from ws4py.client import WebSocketBaseClient

__all__ = ['WebSocketClient']

class WebSocketClient(WebSocketBaseClient):
    def __init__(self, url, protocols=None, extensions=None, heartbeat_freq=None,
                 ssl_options=None, headers=None):
        """
        .. code-block:: python

           from ws4py.client.threadedclient import WebSocketClient

           class EchoClient(WebSocketClient):
               def opened(self):
                  for i in range(0, 200, 25):
                     self.send("*" * i)

               def closed(self, code, reason):
                  print(("Closed down", code, reason))

               def received_message(self, m):
                  print("=> %d %s" % (len(m), str(m)))

           try:
               ws = EchoClient('ws://localhost:9000/echo', protocols=['http-only', 'chat'])
               ws.connect()
           except KeyboardInterrupt:
              ws.close()

        """
        WebSocketBaseClient.__init__(self, url, protocols, extensions, heartbeat_freq,
                                     ssl_options, headers=headers)
        self._th = threading.Thread(target=self.run, name='WebSocketClient')
        self._th.daemon = True

    @property
    def daemon(self):
        """
        `True` if the client's thread is set to be a daemon thread.
        """
        return self._th.daemon

    @daemon.setter
    def daemon(self, flag):
        """
        Set to `True` if the client's thread should be a daemon.
        """
        self._th.daemon = flag

    def run_forever(self):
        """
        Simply blocks the thread until the
        websocket has terminated.
        """
        self._th.join()

    def handshake_ok(self):
        """
        Called when the upgrade handshake has completed
        successfully.

        Starts the client's thread.
        """
        self._th.start()

if __name__ == '__main__':
    from ws4py.client.threadedclient import WebSocketClient

    class EchoClient(WebSocketClient):
        def opened(self):
            def data_provider():
                for i in range(0, 200, 25):
                    yield "#" * i

            self.send(data_provider())

            for i in range(0, 200, 25):
                self.send("*" * i)

        def closed(self, code, reason):
            print(("Closed down", code, reason))

        def received_message(self, m):
            print("#%d" % len(m))
            if len(m) == 175:
                self.close(reason='bye bye')

    try:
        ws = EchoClient('ws://localhost:9000/ws', protocols=['http-only', 'chat'],
                        headers=[('X-Test', 'hello there')])
        ws.connect()
        ws.run_forever()
    except KeyboardInterrupt:
        ws.close()

########NEW FILE########
__FILENAME__ = tornadoclient
# -*- coding: utf-8 -*-
import ssl

from tornado import iostream, escape
from ws4py.client import WebSocketBaseClient
from ws4py.exc import HandshakeError

__all__ = ['TornadoWebSocketClient']

class TornadoWebSocketClient(WebSocketBaseClient):
    def __init__(self, url, protocols=None, extensions=None,
                 io_loop=None, ssl_options=None, headers=None):
        """
        .. code-block:: python

            from tornado import ioloop

            class MyClient(TornadoWebSocketClient):
                def opened(self):
                    for i in range(0, 200, 25):
                        self.send("*" * i)

                def received_message(self, m):
                    print((m, len(str(m))))

                def closed(self, code, reason=None):
                    ioloop.IOLoop.instance().stop()

            ws = MyClient('ws://localhost:9000/echo', protocols=['http-only', 'chat'])
            ws.connect()

            ioloop.IOLoop.instance().start()
        """
        WebSocketBaseClient.__init__(self, url, protocols, extensions,
                                     ssl_options=ssl_options, headers=headers)
        self.ssl_options["do_handshake_on_connect"] = False
        if self.scheme == "wss":
            self.sock = ssl.wrap_socket(self.sock, **self.ssl_options)
            self.io = iostream.SSLIOStream(self.sock, io_loop)
        else:
            self.io = iostream.IOStream(self.sock, io_loop)
        self.io_loop = io_loop

    def connect(self):
        """
        Connects the websocket and initiate the upgrade handshake.
        """
        self.io.set_close_callback(self.__connection_refused)
        self.io.connect((self.host, int(self.port)), self.__send_handshake)

    def _write(self, b):
        """
        Trying to prevent a write operation
        on an already closed websocket stream.

        This cannot be bullet proof but hopefully
        will catch almost all use cases.
        """
        if self.terminated:
            raise RuntimeError("Cannot send on a terminated websocket")

        self.io.write(b)

    def __connection_refused(self, *args, **kwargs):
        self.server_terminated = True
        self.closed(1005, 'Connection refused')

    def __send_handshake(self):
        self.io.set_close_callback(self.__connection_closed)
        self.io.write(escape.utf8(self.handshake_request),
                      self.__handshake_sent)

    def __connection_closed(self, *args, **kwargs):
        self.server_terminated = True
        self.closed(1006, 'Connection closed during handshake')

    def __handshake_sent(self):
        self.io.read_until(b"\r\n\r\n", self.__handshake_completed)

    def __handshake_completed(self, data):
        self.io.set_close_callback(None)
        try:
            response_line, _, headers = data.partition(b'\r\n')
            self.process_response_line(response_line)
            protocols, extensions = self.process_handshake_header(headers)
        except HandshakeError:
            self.close_connection()
            raise

        self.opened()
        self.io.set_close_callback(self.__stream_closed)
        self.io.read_bytes(self.reading_buffer_size, self.__fetch_more)

    def __fetch_more(self, bytes):
        try:
            should_continue = self.process(bytes)
        except:
            should_continue = False

        if should_continue:
            self.io.read_bytes(self.reading_buffer_size, self.__fetch_more)
        else:
            self.__gracefully_terminate()

    def __gracefully_terminate(self):
        self.client_terminated = self.server_terminated = True

        try:
            if not self.stream.closing:
                self.closed(1006)
        finally:
            self.close_connection()

    def __stream_closed(self, *args, **kwargs):
        self.io.set_close_callback(None)
        code = 1006
        reason = None
        if self.stream.closing:
            code, reason = self.stream.closing.code, self.stream.closing.reason
        self.closed(code, reason)
        self._cleanup()

    def close_connection(self):
        """
        Close the underlying connection
        """
        self.io.close()

if __name__ == '__main__':
    from tornado import ioloop

    class MyClient(TornadoWebSocketClient):
        def opened(self):
            def data_provider():
                for i in range(0, 200, 25):
                    yield "#" * i

            self.send(data_provider())

            for i in range(0, 200, 25):
                self.send("*" * i)

        def received_message(self, m):
            print("#%d" % len(m))
            if len(m) == 175:
                self.close()

        def closed(self, code, reason=None):
            ioloop.IOLoop.instance().stop()
            print(("Closed down", code, reason))

    ws = MyClient('ws://localhost:9000/ws', protocols=['http-only', 'chat'])
    ws.connect()

    ioloop.IOLoop.instance().start()

########NEW FILE########
__FILENAME__ = compat
# -*- coding: utf-8 -*-
__doc__ = """
This compatibility module is inspired by the one found
in CherryPy. It provides a common entry point for the various
functions and types that are used with ws4py but which
differ from Python 2.x to Python 3.x

There are likely better ways for some of them so feel
free to provide patches.

Note this has been tested against 2.7 and 3.3 only but
should hopefully work fine with other versions too.
"""
import sys

if sys.version_info >= (3, 0):
    py3k = True
    from urllib.parse import urlsplit
    range = range
    unicode = str
    basestring = (bytes, str)
    _ord = ord

    def get_connection(fileobj):
        return fileobj.raw._sock

    def detach_connection(fileobj):
        fileobj.detach()

    def ord(c):
        if isinstance(c, int):
            return c
        return _ord(c)
else:
    py3k = False
    from urlparse import urlsplit
    range = xrange
    unicode = unicode
    basestring = basestring
    ord = ord

    def get_connection(fileobj):
        return fileobj._sock

    def detach_connection(fileobj):
        fileobj._sock = None

########NEW FILE########
__FILENAME__ = exc
# -*- coding: utf-8 -*-

__all__ = ['WebSocketException', 'FrameTooLargeException', 'ProtocolException',
           'UnsupportedFrameTypeException', 'TextFrameEncodingException',
           'UnsupportedFrameTypeException', 'TextFrameEncodingException',
           'StreamClosed', 'HandshakeError', 'InvalidBytesError']

class WebSocketException(Exception): pass

class ProtocolException(WebSocketException): pass

class FrameTooLargeException(WebSocketException): pass

class UnsupportedFrameTypeException(WebSocketException): pass

class TextFrameEncodingException(WebSocketException): pass

class InvalidBytesError(WebSocketException): pass

class StreamClosed(Exception): pass

class HandshakeError(WebSocketException):
    def __init__(self, msg):
        self.msg = msg

    def __str__(self):
        return self.msg

########NEW FILE########
__FILENAME__ = framing
# -*- coding: utf-8 -*-
from struct import pack, unpack

from tangelo.ws4py.exc import FrameTooLargeException, ProtocolException
from tangelo.ws4py.compat import py3k, ord

# Frame opcodes defined in the spec.
OPCODE_CONTINUATION = 0x0
OPCODE_TEXT = 0x1
OPCODE_BINARY = 0x2
OPCODE_CLOSE = 0x8
OPCODE_PING = 0x9
OPCODE_PONG = 0xa

__all__ = ['Frame']

class Frame(object):
    def __init__(self, opcode=None, body=b'', masking_key=None, fin=0, rsv1=0, rsv2=0, rsv3=0):
        """
        Implements the framing protocol as defined by RFC 6455.

        .. code-block:: python
           :linenos:

           >>> test_mask = 'XXXXXX' # perhaps from os.urandom(4)
           >>> f = Frame(OPCODE_TEXT, 'hello world', masking_key=test_mask, fin=1)
           >>> bytes = f.build()
           >>> bytes.encode('hex')
           '818bbe04e66ad6618a06d1249105cc6882'
           >>> f = Frame()
           >>> f.parser.send(bytes[0])
           1
           >>> f.parser.send(bytes[1])
           4

        .. seealso:: Data Framing http://tools.ietf.org/html/rfc6455#section-5.2
        """
        if not isinstance(body, bytes):
            raise TypeError("The body must be properly encoded")

        self.opcode = opcode
        self.body = body
        self.masking_key = masking_key
        self.fin = fin
        self.rsv1 = rsv1
        self.rsv2 = rsv2
        self.rsv3 = rsv3
        self.payload_length = len(body)

        self._parser = None

    @property
    def parser(self):
        if self._parser is None:
            self._parser = self._parsing()
            # Python generators must be initialized once.
            next(self.parser)
        return self._parser

    def _cleanup(self):
        if self._parser:
            self._parser.close()
            self._parser = None

    def build(self):
        """
        Builds a frame from the instance's attributes and returns
        its bytes representation.
        """
        header = b''

        if self.fin > 0x1:
            raise ValueError('FIN bit parameter must be 0 or 1')

        if 0x3 <= self.opcode <= 0x7 or 0xB <= self.opcode:
            raise ValueError('Opcode cannot be a reserved opcode')

        ## +-+-+-+-+-------+
        ## |F|R|R|R| opcode|
        ## |I|S|S|S|  (4)  |
        ## |N|V|V|V|       |
        ## | |1|2|3|       |
        ## +-+-+-+-+-------+
        header = pack('!B', ((self.fin << 7)
                             | (self.rsv1 << 6)
                             | (self.rsv2 << 5)
                             | (self.rsv3 << 4)
                             | self.opcode))

        ##                 +-+-------------+-------------------------------+
        ##                 |M| Payload len |    Extended payload length    |
        ##                 |A|     (7)     |             (16/63)           |
        ##                 |S|             |   (if payload len==126/127)   |
        ##                 |K|             |                               |
        ## +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
        ## |     Extended payload length continued, if payload len == 127  |
        ## + - - - - - - - - - - - - - - - +-------------------------------+
        if self.masking_key: mask_bit = 1 << 7
        else: mask_bit = 0

        length = self.payload_length
        if length < 126:
            header += pack('!B', (mask_bit | length))
        elif length < (1 << 16):
            header += pack('!B', (mask_bit | 126)) + pack('!H', length)
        elif length < (1 << 63):
            header += pack('!B', (mask_bit | 127)) + pack('!Q', length)
        else:
            raise FrameTooLargeException()
        
        ## + - - - - - - - - - - - - - - - +-------------------------------+
        ## |                               |Masking-key, if MASK set to 1  |
        ## +-------------------------------+-------------------------------+
        ## | Masking-key (continued)       |          Payload Data         |
        ## +-------------------------------- - - - - - - - - - - - - - - - +
        ## :                     Payload Data continued ...                :
        ## + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
        ## |                     Payload Data continued ...                |
        ## +---------------------------------------------------------------+
        body = self.body
        if not self.masking_key:
            return bytes(header + body)

        return bytes(header + self.masking_key + self.mask(body))

    def _parsing(self):
        """
        Generator to parse bytes into a frame. Yields until
        enough bytes have been read or an error is met.
        """
        buf = b''
        some_bytes = b''

        # yield until we get the first header's byte
        while not some_bytes:
            some_bytes = (yield 1)

        first_byte = some_bytes[0] if isinstance(some_bytes, bytearray) else ord(some_bytes[0])
        # frame-fin = %x0 ; more frames of this message follow
        #           / %x1 ; final frame of this message
        self.fin = (first_byte >> 7) & 1
        self.rsv1 = (first_byte >> 6) & 1
        self.rsv2 = (first_byte >> 5) & 1
        self.rsv3 = (first_byte >> 4) & 1
        self.opcode = first_byte & 0xf

        # frame-rsv1 = %x0 ; 1 bit, MUST be 0 unless negotiated otherwise
        # frame-rsv2 = %x0 ; 1 bit, MUST be 0 unless negotiated otherwise
        # frame-rsv3 = %x0 ; 1 bit, MUST be 0 unless negotiated otherwise
        if self.rsv1 or self.rsv2 or self.rsv3:
            raise ProtocolException()

        # control frames between 3 and 7 as well as above 0xA are currently reserved
        if 2 < self.opcode < 8 or self.opcode > 0xA:
            raise ProtocolException()

        # control frames cannot be fragmented
        if self.opcode > 0x7 and self.fin == 0:
            raise ProtocolException()

        # do we already have enough some_bytes to continue?
        some_bytes = some_bytes[1:] if some_bytes and len(some_bytes) > 1 else b''

        # Yield until we get the second header's byte
        while not some_bytes:
            some_bytes = (yield 1)

        second_byte = some_bytes[0] if isinstance(some_bytes, bytearray) else ord(some_bytes[0])
        mask = (second_byte >> 7) & 1
        self.payload_length = second_byte & 0x7f

        # All control frames MUST have a payload length of 125 some_bytes or less
        if self.opcode > 0x7 and self.payload_length > 125:
            raise FrameTooLargeException()

        if some_bytes and len(some_bytes) > 1:
            buf = some_bytes[1:]
            some_bytes = buf
        else:
            buf = b''
            some_bytes = b''

        if self.payload_length == 127:
            if len(buf) < 8:
                nxt_buf_size = 8 - len(buf)
                some_bytes = (yield nxt_buf_size)
                some_bytes = buf + (some_bytes or b'')
                while len(some_bytes) < 8:
                    b = (yield 8 - len(some_bytes))
                    if b is not None:
                        some_bytes = some_bytes + b
                if len(some_bytes) > 8:
                    buf = some_bytes[8:]
            else:
                some_bytes = buf[:8]
                buf = buf[8:]
            extended_payload_length = some_bytes
            self.payload_length = unpack(
                '!Q', extended_payload_length)[0]
            if self.payload_length > 0x7FFFFFFFFFFFFFFF:
                raise FrameTooLargeException()
        elif self.payload_length == 126:
            if len(buf) < 2:
                nxt_buf_size = 2 - len(buf)
                some_bytes = (yield nxt_buf_size)
                some_bytes = buf + (some_bytes or b'')
                while len(some_bytes) < 2:
                    b = (yield 2 - len(some_bytes))
                    if b is not None:
                        some_bytes = some_bytes + b
                if len(some_bytes) > 2:
                    buf = some_bytes[2:]
            else:
                some_bytes = buf[:2]
                buf = buf[2:]
            extended_payload_length = some_bytes
            self.payload_length = unpack(
                '!H', extended_payload_length)[0]

        if mask:
            if len(buf) < 4:
                nxt_buf_size = 4 - len(buf)
                some_bytes = (yield nxt_buf_size)
                some_bytes = buf + (some_bytes or b'')
                while not some_bytes or len(some_bytes) < 4:
                    b = (yield 4 - len(some_bytes))
                    if b is not None:
                        some_bytes = some_bytes + b
                if len(some_bytes) > 4:
                    buf = some_bytes[4:]
            else:
                some_bytes = buf[:4]
                buf = buf[4:]
            self.masking_key = some_bytes

        if len(buf) < self.payload_length:
            nxt_buf_size = self.payload_length - len(buf)
            some_bytes = (yield nxt_buf_size)
            some_bytes = buf + (some_bytes or b'')
            while len(some_bytes) < self.payload_length:
                l = self.payload_length - len(some_bytes)
                b = (yield l)
                if b is not None:
                    some_bytes = some_bytes + b
        else:
            if self.payload_length == len(buf):
                some_bytes = buf
            else:
                some_bytes = buf[:self.payload_length]

        self.body = some_bytes
        yield

    def mask(self, data):
        """
        Performs the masking or unmasking operation on data
        using the simple masking algorithm:

        ..
           j                   = i MOD 4
           transformed-octet-i = original-octet-i XOR masking-key-octet-j

        """
        masked = bytearray(data)
        if py3k: key = self.masking_key
        else: key = map(ord, self.masking_key)
        for i in range(len(data)):
            masked[i] = masked[i] ^ key[i%4]
        return masked
    unmask = mask

########NEW FILE########
__FILENAME__ = manager
# -*- coding: utf-8 -*-
__doc__ = """
The manager module provides a selected classes to
handle websocket's execution.

Initially the rationale was to:

- Externalize the way the CherryPy server had been setup
  as its websocket management was too tightly coupled with
  the plugin implementation.
- Offer a management that could be used by other
  server or client implementations.
- Move away from the threaded model to the event-based
  model by relying on `select` or `epoll` (when available).


A simple usage for handling websocket clients:

.. code-block:: python

    from ws4py.client import WebSocketBaseClient
    from ws4py.manager import WebSocketManager

    m = WebSocketManager()

    class EchoClient(WebSocketBaseClient):
        def handshake_ok(self):
            m.add(self)  # register the client once the handshake is done

        def received_message(self, msg):
            print str(msg)

    m.start()

    client = EchoClient('ws://localhost:9000/ws')
    client.connect()

    m.join()  # blocks forever

Managers are not compulsory but hopefully will help your
workflow. For clients, you can still rely on threaded, gevent or
tornado based implementations of course.
"""
import logging
import select
import threading
import time

from tangelo.ws4py import format_addresses
from tangelo.ws4py.compat import py3k

logger = logging.getLogger('ws4py')

class SelectPoller(object):
    def __init__(self, timeout=0.1):
        """
        A socket poller that uses the `select`
        implementation to determines which
        file descriptors have data available to read.

        It is available on all platforms.
        """
        self._fds = []
        self.timeout = timeout

    def release(self):
        """
        Cleanup resources.
        """
        self._fds = []

    def register(self, fd):
        """
        Register a new file descriptor to be
        part of the select polling next time around.
        """
        if fd not in self._fds:
            self._fds.append(fd)

    def unregister(self, fd):
        """
        Unregister the given file descriptor.
        """
        if fd in self._fds:
            self._fds.remove(fd)

    def poll(self):
        """
        Polls once and returns a list of
        ready-to-be-read file descriptors.
        """
        if not self._fds:
            time.sleep(self.timeout)
            return []

        r, w, x = select.select(self._fds, [], [], self.timeout)
        return r

class EPollPoller(object):
    def __init__(self, timeout=0.1):
        """
        An epoll poller that uses the ``epoll``
        implementation to determines which
        file descriptors have data available to read.

        Available on Unix flavors mostly.
        """
        self.poller = select.epoll()
        self.timeout = timeout

    def release(self):
        """
        Cleanup resources.
        """
        self.poller.close()

    def register(self, fd):
        """
        Register a new file descriptor to be
        part of the select polling next time around.
        """
        try:
            self.poller.register(fd, select.EPOLLIN | select.EPOLLPRI)
        except IOError:
            pass

    def unregister(self, fd):
        """
        Unregister the given file descriptor.
        """
        self.poller.unregister(fd)

    def poll(self):
        """
        Polls once and yields each ready-to-be-read
        file-descriptor
        """
        events = self.poller.poll(timeout=self.timeout)
        for fd, event in events:
            if event | select.EPOLLIN | select.EPOLLPRI:
                yield fd

class WebSocketManager(threading.Thread):
    def __init__(self, poller=None):
        """
        An event-based websocket manager. By event-based, we mean
        that the websockets will be called when their
        sockets have data to be read from.

        The manager itself runs in its own thread as not to
        be the blocking mainloop of your application.

        The poller's implementation is automatically chosen
        with ``epoll`` if available else ``select`` unless you
        provide your own ``poller``.
        """
        threading.Thread.__init__(self)
        self.lock = threading.Lock()
        self.websockets = {}

        if poller:
            self.poller = poller
        else:
            if hasattr(select, "epoll"):
                self.poller = EPollPoller()
                logger.info("Using epoll")
            else:
                self.poller = SelectPoller()
                logger.info("Using select as epoll is not available")

    def __len__(self):
        return len(self.websockets)

    def __iter__(self):
        if py3k:
            return iter(self.websockets.values())
        else:
            return self.websockets.itervalues()

    def __contains__(self, ws):
        fd = ws.sock.fileno()
        # just in case the file descriptor was reused
        # we actually check the instance (well, this might
        # also have been reused...)
        return self.websockets.get(fd) is ws

    def add(self, websocket):
        """
        Manage a new websocket.

        First calls its :meth:`opened() <ws4py.websocket.WebSocket.opened>`
        method and register its socket against the poller
        for reading events.
        """
        logger.info("Managing websocket %s" % format_addresses(websocket))
        websocket.opened()
        with self.lock:
            fd = websocket.sock.fileno()
            self.websockets[fd] = websocket
            self.poller.register(fd)

    def remove(self, websocket):
        """
        Remove the given ``websocket`` from the manager.

        This does not call its :meth:`closed() <ws4py.websocket.WebSocket.closed>`
        method as it's out-of-band by your application
        or from within the manager's run loop.
        """
        logger.info("Removing websocket %s" % format_addresses(websocket))
        with self.lock:
            fd = websocket.sock.fileno()
            self.websockets.pop(fd, None)
            self.poller.unregister(fd)

    def stop(self):
        """
        Mark the manager as terminated and
        releases its resources.
        """
        self.running = False
        with self.lock:
            self.websockets.clear()
            self.poller.release()

    def run(self):
        """
        Manager's mainloop executed from within a thread.

        Constantly poll for read events and, when available,
        call related websockets' `once` method to
        read and process the incoming data.

        If the :meth:`once() <ws4py.websocket.WebSocket.once>`
        method returns a `False` value, its :meth:`terminate() <ws4py.websocket.WebSocket.terminate>`
        method is also applied to properly close
        the websocket and its socket is unregistered from the poller.

        Note that websocket shouldn't take long to process
        their data or they will block the remaining
        websockets with data to be handled. As for what long means,
        it's up to your requirements.
        """
        self.running = True
        while self.running:
            with self.lock:
                polled = self.poller.poll()

            if not self.running:
                break

            # This fixes an error in the ws4py package - not yet in the upstream
            # package. --Kitware
            #
            # workaround wss + cherrypy bug
            import itertools
            for ws in self.websockets.itervalues():
                if hasattr(ws.sock, 'pending') and ws.sock.pending() != 0:
                    polled = itertools.chain(polled, [ws.sock.fileno()])

            for fd in polled:
                if not self.running:
                    break

                ws = self.websockets.get(fd)

                if ws and not ws.terminated:
                    if not ws.once():
                        with self.lock:
                            fd = ws.sock.fileno()
                            self.websockets.pop(fd, None)
                            self.poller.unregister(fd)

                        if not ws.terminated:
                            logger.info("Terminating websocket %s" % format_addresses(ws))
                            ws.terminate()

    def close_all(self, code=1001, message='Server is shutting down'):
        """
        Execute the :meth:`close() <ws4py.websocket.WebSocket.close>`
        method of each registered websockets to initiate the closing handshake.
        It doesn't wait for the handshake to complete properly.
        """
        with self.lock:
            logger.info("Closing all websockets with [%d] '%s'" % (code, message))
            for ws in iter(self):
                ws.close(code=1001, reason=message)

    def broadcast(self, message, binary=False):
        """
        Broadcasts the given message to all registered
        websockets, at the time of the call.

        Broadcast may fail on a given registered peer
        but this is silent as it's not the method's
        purpose to handle websocket's failures.
        """
        with self.lock:
            websockets = self.websockets.copy()
            if py3k:
                ws_iter = iter(websockets.values())
            else:
                ws_iter = websockets.itervalues()

        for ws in ws_iter:
            if not ws.terminated:
                try:
                    ws.send(message, binary)
                except:
                    pass

########NEW FILE########
__FILENAME__ = messaging
# -*- coding: utf-8 -*-
import os
import struct

from tangelo.ws4py.framing import Frame, OPCODE_CONTINUATION, OPCODE_TEXT, \
     OPCODE_BINARY, OPCODE_CLOSE, OPCODE_PING, OPCODE_PONG
from tangelo.ws4py.compat import unicode, py3k

__all__ = ['Message', 'TextMessage', 'BinaryMessage', 'CloseControlMessage',
           'PingControlMessage', 'PongControlMessage']

class Message(object):
    def __init__(self, opcode, data=b'', encoding='utf-8'):
        """
        A message is a application level entity. It's usually built
        from one or many frames. The protocol defines several kind
        of messages which are grouped into two sets:

        * data messages which can be text or binary typed
        * control messages which provide a mechanism to perform
          in-band control communication between peers

        The ``opcode`` indicates the message type and ``data`` is
        the possible message payload.

        The payload is held internally as a a :func:`bytearray` as they are
        faster than pure strings for append operations.

        Unicode data will be encoded using the provided ``encoding``.
        """
        self.opcode = opcode
        self._completed = False
        self.encoding = encoding

        if isinstance(data, unicode):
            if not encoding:
                raise TypeError("unicode data without an encoding")
            data = data.encode(encoding)
        elif isinstance(data, bytearray):
            data = bytes(data)
        elif not isinstance(data, bytes):
            raise TypeError("%s is not a supported data type" % type(data))

        self.data = data

    def single(self, mask=False):
        """
        Returns a frame bytes with the fin bit set and a random mask.

        If ``mask`` is set, automatically mask the frame
        using a generated 4-byte token.
        """
        mask = os.urandom(4) if mask else None
        return Frame(body=self.data, opcode=self.opcode,
                     masking_key=mask, fin=1).build()

    def fragment(self, first=False, last=False, mask=False):
        """
        Returns a :class:`ws4py.framing.Frame` bytes.

        The behavior depends on the given flags:

        * ``first``: the frame uses ``self.opcode`` else a continuation opcode
        * ``last``: the frame has its ``fin`` bit set
        * ``mask``: the frame is masked using a automatically generated 4-byte token
        """
        fin = 1 if last is True else 0
        opcode = self.opcode if first is True else OPCODE_CONTINUATION
        mask = os.urandom(4) if mask else None
        return Frame(body=self.data,
                     opcode=opcode, masking_key=mask,
                     fin=fin).build()

    @property
    def completed(self):
        """
        Indicates the the message is complete, meaning
        the frame's ``fin`` bit was set.
        """
        return self._completed

    @completed.setter
    def completed(self, state):
        """
        Sets the state for this message. Usually
        set by the stream's parser.
        """
        self._completed = state

    def extend(self, data):
        """
        Add more ``data`` to the message.
        """
        if isinstance(data, bytes):
            self.data += data
        elif isinstance(data, bytearray):
            self.data += bytes(data)
        elif isinstance(data, unicode):
            self.data += data.encode(self.encoding)
        else:
            raise TypeError("%s is not a supported data type" % type(data))

    def __len__(self):
        return len(self.__unicode__())

    def __str__(self):
        return self.data

    def __unicode__(self):
        return self.data.decode(self.encoding)

class TextMessage(Message):
    def __init__(self, text=None):
        Message.__init__(self, OPCODE_TEXT, text)

    @property
    def is_binary(self):
        return False

    @property
    def is_text(self):
        return True

class BinaryMessage(Message):
    def __init__(self, bytes=None):
        Message.__init__(self, OPCODE_BINARY, bytes, encoding=None)

    @property
    def is_binary(self):
        return True

    @property
    def is_text(self):
        return False

    def __len__(self):
        return len(self.data)

class CloseControlMessage(Message):
    def __init__(self, code=1000, reason=''):
        data = b""
        if code:
            data += struct.pack("!H", code)
        if reason is not None:
            if isinstance(reason, unicode):
                reason = reason.encode('utf-8')
            data += reason

        Message.__init__(self, OPCODE_CLOSE, data, 'utf-8')
        self.code = code
        self.reason = reason

    def __str__(self):
        return self.reason

    def __unicode__(self):
        return self.reason.decode(self.encoding)

class PingControlMessage(Message):
    def __init__(self, data=None):
        Message.__init__(self, OPCODE_PING, data)

class PongControlMessage(Message):
    def __init__(self, data):
        Message.__init__(self, OPCODE_PONG, data)

########NEW FILE########
__FILENAME__ = cherrypyserver
# -*- coding: utf-8 -*-
__doc__ = """
WebSocket within CherryPy is a tricky bit since CherryPy is
a threaded server which would choke quickly if each thread
of the server were kept attached to a long living connection
that WebSocket expects.

In order to work around this constraint, we take some advantage
of some internals of CherryPy as well as the introspection
Python provides.

Basically, when the WebSocket handshake is complete, we take over
the socket and let CherryPy take back the thread that was
associated with the upgrade request.

These operations require a bit of work at various levels of
the CherryPy framework but this module takes care of them
and from your application's perspective, this is abstracted.

Here are the various utilities provided by this module:

 * WebSocketTool: The tool is in charge to perform the
                  HTTP upgrade and detach the socket from
                  CherryPy. It runs at various hook points of the
                  request's processing. Enable that tool at
                  any path you wish to handle as a WebSocket
                  handler.

 * WebSocketPlugin: The plugin tracks the instanciated web socket handlers.
                    It also cleans out websocket handler which connection
                    have been closed down. The websocket connection then
                    runs in its own thread that this plugin manages.

Simple usage example:

.. code-block:: python
    :linenos:

    import cherrypy
    from ws4py.server.cherrypyserver import WebSocketPlugin, WebSocketTool
    from ws4py.websocket import EchoWebSocket

    cherrypy.config.update({'server.socket_port': 9000})
    WebSocketPlugin(cherrypy.engine).subscribe()
    cherrypy.tools.websocket = WebSocketTool()

    class Root(object):
        @cherrypy.expose
        def index(self):
            return 'some HTML with a websocket javascript connection'

        @cherrypy.expose
        def ws(self):
            pass

    cherrypy.quickstart(Root(), '/', config={'/ws': {'tools.websocket.on': True,
                                                     'tools.websocket.handler_cls': EchoWebSocket}})


Note that you can set the handler class on per-path basis,
meaning you could also dynamically change the class based
on other envrionmental settings (is the user authenticated for ex).
"""
import base64
from hashlib import sha1
import inspect
import threading

import cherrypy
from cherrypy import Tool
from cherrypy.process import plugins
from cherrypy.wsgiserver import HTTPConnection, HTTPRequest

from tangelo.ws4py import WS_KEY, WS_VERSION
from tangelo.ws4py.exc import HandshakeError
from tangelo.ws4py.websocket import WebSocket
from tangelo.ws4py.compat import py3k, get_connection, detach_connection
from tangelo.ws4py.manager import WebSocketManager

__all__ = ['WebSocketTool', 'WebSocketPlugin']

class WebSocketTool(Tool):
    def __init__(self):
        Tool.__init__(self, 'before_request_body', self.upgrade)

    def _setup(self):
        conf = self._merged_args()
        hooks = cherrypy.serving.request.hooks
        p = conf.pop("priority", getattr(self.callable, "priority",
                                         self._priority))
        hooks.attach(self._point, self.callable, priority=p, **conf)
        hooks.attach('before_finalize', self.complete,
                     priority=p)
        hooks.attach('on_end_resource', self.cleanup_headers,
                     priority=70)
        hooks.attach('on_end_request', self.start_handler,
                     priority=70)

    def upgrade(self, protocols=None, extensions=None, version=WS_VERSION,
                handler_cls=WebSocket, heartbeat_freq=None):
        """
        Performs the upgrade of the connection to the WebSocket
        protocol.

        The provided protocols may be a list of WebSocket
        protocols supported by the instance of the tool.

        When no list is provided and no protocol is either
        during the upgrade, then the protocol parameter is
        not taken into account. On the other hand,
        if the protocol from the handshake isn't part
        of the provided list, the upgrade fails immediatly.
        """
        request = cherrypy.serving.request
        request.process_request_body = False

        ws_protocols = None
        ws_location = None
        ws_version = version
        ws_key = None
        ws_extensions = []

        if request.method != 'GET':
            raise HandshakeError('HTTP method must be a GET')

        for key, expected_value in [('Upgrade', 'websocket'),
                                     ('Connection', 'upgrade')]:
            actual_value = request.headers.get(key, '').lower()
            if not actual_value:
                raise HandshakeError('Header %s is not defined' % key)
            if expected_value not in actual_value:
                raise HandshakeError('Illegal value for header %s: %s' %
                                     (key, actual_value))

        version = request.headers.get('Sec-WebSocket-Version')
        supported_versions = ', '.join([str(v) for v in ws_version])
        version_is_valid = False
        if version:
            try: version = int(version)
            except: pass
            else: version_is_valid = version in ws_version

        if not version_is_valid:
            cherrypy.response.headers['Sec-WebSocket-Version'] = supported_versions
            raise HandshakeError('Unhandled or missing WebSocket version')

        key = request.headers.get('Sec-WebSocket-Key')
        if key:
            ws_key = base64.b64decode(key.encode('utf-8'))
            if len(ws_key) != 16:
                raise HandshakeError("WebSocket key's length is invalid")

        protocols = protocols or []
        subprotocols = request.headers.get('Sec-WebSocket-Protocol')
        if subprotocols:
            ws_protocols = []
            for s in subprotocols.split(','):
                s = s.strip()
                if s in protocols:
                    ws_protocols.append(s)

        exts = extensions or []
        extensions = request.headers.get('Sec-WebSocket-Extensions')
        if extensions:
            for ext in extensions.split(','):
                ext = ext.strip()
                if ext in exts:
                    ws_extensions.append(ext)

        location = []
        include_port = False
        if request.scheme == "https":
            location.append("wss://")
            include_port = request.local.port != 443
        else:
            location.append("ws://")
            include_port = request.local.port != 80
        location.append('localhost')
        if include_port:
            location.append(":%d" % request.local.port)
        location.append(request.path_info)
        if request.query_string != "":
            location.append("?%s" % request.query_string)
        ws_location = ''.join(location)

        response = cherrypy.serving.response
        response.stream = True
        response.status = '101 Switching Protocols'
        response.headers['Content-Type'] = 'text/plain'
        response.headers['Upgrade'] = 'websocket'
        response.headers['Connection'] = 'Upgrade'
        response.headers['Sec-WebSocket-Version'] = str(version)
        response.headers['Sec-WebSocket-Accept'] = base64.b64encode(sha1(key.encode('utf-8') + WS_KEY).digest())
        if ws_protocols:
            response.headers['Sec-WebSocket-Protocol'] = ', '.join(ws_protocols)
        if ws_extensions:
            response.headers['Sec-WebSocket-Extensions'] = ','.join(ws_extensions)

        addr = (request.remote.ip, request.remote.port)
        ws_conn = get_connection(request.rfile.rfile)
        request.ws_handler = handler_cls(ws_conn, ws_protocols, ws_extensions,
                                         request.wsgi_environ.copy(),
                                         heartbeat_freq=heartbeat_freq)

    def complete(self):
        """
        Sets some internal flags of CherryPy so that it
        doesn't close the socket down.
        """
        self._set_internal_flags()

    def cleanup_headers(self):
        """
        Some clients aren't that smart when it comes to
        headers lookup.
        """
        response = cherrypy.response
        if not response.header_list:
            return

        headers = response.header_list[:]
        for (k, v) in headers:
            if k[:7] == 'Sec-Web':
                response.header_list.remove((k, v))
                response.header_list.append((k.replace('Sec-Websocket', 'Sec-WebSocket'), v))

    def start_handler(self):
        """
        Runs at the end of the request processing by calling
        the opened method of the handler.
        """
        request = cherrypy.request
        if not hasattr(request, 'ws_handler'):
            return

        addr = (request.remote.ip, request.remote.port)
        ws_handler = request.ws_handler
        request.ws_handler = None
        delattr(request, 'ws_handler')

        # By doing this we detach the socket from
        # the CherryPy stack avoiding memory leaks
        detach_connection(request.rfile.rfile)

        cherrypy.engine.publish('handle-websocket', ws_handler, addr)

    def _set_internal_flags(self):
        """
        CherryPy has two internal flags that we are interested in
        to enable WebSocket within the server. They can't be set via
        a public API and considering I'd want to make this extension
        as compatible as possible whilst refraining in exposing more
        than should be within CherryPy, I prefer performing a bit
        of introspection to set those flags. Even by Python standards
        such introspection isn't the cleanest but it works well
        enough in this case.

        This also means that we do that only on WebSocket
        connections rather than globally and therefore we do not
        harm the rest of the HTTP server.
        """
        current = inspect.currentframe()
        while True:
            if not current:
                break
            _locals = current.f_locals
            if 'self' in _locals:
               if type(_locals['self']) == HTTPRequest:
                   _locals['self'].close_connection = True
               if type(_locals['self']) == HTTPConnection:
                   _locals['self'].linger = True
                   # HTTPConnection is more inner than
                   # HTTPRequest so we can leave once
                   # we're done here
                   return
            _locals = None
            current = current.f_back

class WebSocketPlugin(plugins.SimplePlugin):
    def __init__(self, bus):
        plugins.SimplePlugin.__init__(self, bus)
        self.manager = WebSocketManager()

    def start(self):
        cherrypy.log("Starting WebSocket processing")
        self.bus.subscribe('stop', self.cleanup)
        self.bus.subscribe('handle-websocket', self.handle)
        self.bus.subscribe('websocket-broadcast', self.broadcast)
        self.manager.start()

    def stop(self):
        cherrypy.log("Terminating WebSocket processing")
        self.bus.unsubscribe('stop', self.cleanup)
        self.bus.unsubscribe('handle-websocket', self.handle)
        self.bus.unsubscribe('websocket-broadcast', self.broadcast)

    def handle(self, ws_handler, peer_addr):
        """
        Tracks the provided handler.

        :param ws_handler: websocket handler instance
        :param peer_addr: remote peer address for tracing purpose
        """
        self.manager.add(ws_handler)

    def cleanup(self):
        """
        Terminate all connections and clear the pool. Executed when the engine stops.
        """
        self.manager.close_all()
        self.manager.stop()
        self.manager.join()

    def broadcast(self, message, binary=False):
        """
        Broadcasts a message to all connected clients known to
        the server.

        :param message: a message suitable to pass to the send() method
          of the connected handler.
        :param binary: whether or not the message is a binary one
        """
        self.manager.broadcast(message, binary)

if __name__ == '__main__':
    import random
    cherrypy.config.update({'server.socket_host': '127.0.0.1',
                            'server.socket_port': 9000})
    WebSocketPlugin(cherrypy.engine).subscribe()
    cherrypy.tools.websocket = WebSocketTool()

    class Root(object):
        @cherrypy.expose
        @cherrypy.tools.websocket(on=False)
        def ws(self):
            return """<html>
        <head>
          <script type='application/javascript' src='https://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js'> </script>
          <script type='application/javascript'>
            $(document).ready(function() {
              var ws = new WebSocket('ws://192.168.0.10:9000/');
              ws.onmessage = function (evt) {
                 $('#chat').val($('#chat').val() + evt.data + '\\n');
              };
              ws.onopen = function() {
                 ws.send("Hello there");
              };
              ws.onclose = function(evt) {
                $('#chat').val($('#chat').val() + 'Connection closed by server: ' + evt.code + ' \"' + evt.reason + '\"\\n');
              };
              $('#chatform').submit(function() {
                 ws.send('%(username)s: ' + $('#message').val());
                 $('#message').val("");
                 return false;
              });
            });
          </script>
        </head>
        <body>
        <form action='/echo' id='chatform' method='get'>
          <textarea id='chat' cols='35' rows='10'></textarea>
          <br />
          <label for='message'>%(username)s: </label><input type='text' id='message' />
          <input type='submit' value='Send' />
          </form>
        </body>
        </html>
        """ % {'username': "User%d" % random.randint(0, 100)}

        @cherrypy.expose
        def index(self):
            cherrypy.log("Handler created: %s" % repr(cherrypy.request.ws_handler))

    cherrypy.quickstart(Root(), '/', config={'/': {'tools.websocket.on': True,
                                                   'tools.websocket.handler_cls': EchoWebSocketHandler}})

########NEW FILE########
__FILENAME__ = geventserver
# -*- coding: utf-8 -*-
__doc__ = """
WSGI entities to support WebSocket from within gevent.

Its usage is rather simple:

.. code-block: python

    from gevent import monkey; monkey.patch_all()
    from ws4py.websocket import EchoWebSocket
    from ws4py.server.geventserver import WSGIServer
    from ws4py.server.wsgiutils import WebSocketWSGIApplication

    server = WSGIServer(('localhost', 9000), WebSocketWSGIApplication(handler_cls=EchoWebSocket))
    server.serve_forever()

"""
import logging
import sys

import gevent
from gevent.pywsgi import WSGIHandler, WSGIServer as _WSGIServer
from gevent.pool import Group

from ws4py import format_addresses
from ws4py.server.wsgiutils import WebSocketWSGIApplication

logger = logging.getLogger('ws4py')

__all__ = ['WebSocketWSGIHandler', 'WSGIServer',
           'GEventWebSocketPool']

class WebSocketWSGIHandler(WSGIHandler):
    """
    A WSGI handler that will perform the :rfc:`6455`
    upgrade and handshake before calling the WSGI application.

    If the incoming request doesn't have a `'Upgrade'` header,
    the handler will simply fallback to the gevent builtin's handler
    and process it as per usual.
    """

    def run_application(self):
        upgrade_header = self.environ.get('HTTP_UPGRADE', '').lower()
        if upgrade_header:
            try:
                # Build and start the HTTP response
                self.environ['ws4py.socket'] = self.socket or self.environ['wsgi.input'].rfile._sock
                self.result = self.application(self.environ, self.start_response) or []
                self.process_result()
            except:
                raise
            else:
                del self.environ['ws4py.socket']
                self.socket = None
                self.rfile.close()

                ws = self.environ.pop('ws4py.websocket')
                if ws:
                    self.server.pool.track(ws)
        else:
            gevent.pywsgi.WSGIHandler.run_application(self)

class GEventWebSocketPool(Group):
    """
    Simple pool of bound websockets.
    Internally it uses a gevent group to track
    the websockets. The server should call the ``clear``
    method to initiate the closing handshake when the
    server is shutdown.
    """

    def track(self, websocket):
        logger.info("Managing websocket %s" % format_addresses(websocket))
        return self.spawn(websocket.run)

    def clear(self):
        logger.info("Terminating server and all connected websockets")
        for greenlet in self:
            try:
                websocket = greenlet._run.im_self
                if websocket:
                    websocket.close(1001, 'Server is shutting down')
            except:
                pass
            finally:
                self.discard(greenlet)
                
class WSGIServer(_WSGIServer):
    handler_class = WebSocketWSGIHandler

    def __init__(self, *args, **kwargs):
        """
        WSGI server that simply tracks websockets
        and send them a proper closing handshake
        when the server terminates.

        Other than that, the server is the same
        as its :class:`gevent.pywsgi.WSGIServer`
        base.
        """
        _WSGIServer.__init__(self, *args, **kwargs)
        self.pool = GEventWebSocketPool()

    def stop(self, *args, **kwargs):
        self.pool.clear()
        _WSGIServer.stop(self, *args, **kwargs)

if __name__ == '__main__':
    import os

    from ws4py import configure_logger
    configure_logger()

    from ws4py.websocket import EchoWebSocket
    server = WSGIServer(('127.0.0.1', 9000),
                        WebSocketWSGIApplication(handler_cls=EchoWebSocket))
    server.serve_forever()

########NEW FILE########
__FILENAME__ = wsgirefserver
# -*- coding: utf-8 -*-
__doc__ = """
Add WebSocket support to the built-in WSGI server
provided by the :py:mod:`wsgiref`. This is clearly not
meant to be a production server so please consider this
only for testing purpose.

Mostly, this module overrides bits and pieces of
the built-in classes so that it supports the WebSocket
workflow.

.. code-block:: python

    from wsgiref.simple_server import make_server
    from ws4py.websocket import EchoWebSocket
    from ws4py.server.wsgirefserver import WSGIServer, WebSocketWSGIRequestHandler
    from ws4py.server.wsgiutils import WebSocketWSGIApplication

    server = make_server('', 9000, server_class=WSGIServer,
                         handler_class=WebSocketWSGIRequestHandler,
                         app=WebSocketWSGIApplication(handler_cls=EchoWebSocket))
    server.initialize_websockets_manager()
    server.serve_forever()

.. note::
   For some reason this server may fail against autobahntestsuite.
"""
import logging
import sys
from wsgiref.handlers import SimpleHandler
from wsgiref.simple_server import WSGIRequestHandler, WSGIServer as _WSGIServer
from wsgiref import util

util._hoppish = {}.__contains__

from ws4py.manager import WebSocketManager
from ws4py import format_addresses
from ws4py.server.wsgiutils import WebSocketWSGIApplication
from ws4py.compat import get_connection

__all__ = ['WebSocketWSGIHandler', 'WebSocketWSGIRequestHandler',
           'WSGIServer']

logger = logging.getLogger('ws4py')

class WebSocketWSGIHandler(SimpleHandler):
    def setup_environ(self):
        """
        Setup the environ dictionary and add the
        `'ws4py.socket'` key. Its associated value
        is the real socket underlying socket.
        """
        SimpleHandler.setup_environ(self)
        self.environ['ws4py.socket'] = get_connection(self.environ['wsgi.input'])

    def finish_response(self):
        """
        Completes the response and performs the following tasks:

        - Remove the `'ws4py.socket'` and `'ws4py.websocket'`
          environ keys.
        - Attach the returned websocket, if any, to the WSGI server
          using its ``link_websocket_to_server`` method.
        """
        ws = None
        if self.environ:
            self.environ.pop('ws4py.socket', None)
            ws = self.environ.pop('ws4py.websocket', None)

        try:
            SimpleHandler.finish_response(self)
        except:
            if ws:
                ws.close(1011, reason='Something broke')
            raise
        else:
            if ws:
                self.request_handler.server.link_websocket_to_server(ws)

class WebSocketWSGIRequestHandler(WSGIRequestHandler):
    def handle(self):
        """
        Unfortunately the base class forces us
        to override the whole method to actually provide our wsgi handler.
        """
        self.raw_requestline = self.rfile.readline()
        if not self.parse_request(): # An error code has been sent, just exit
            return

        # next line is where we'd have expect a configuration key somehow
        handler = WebSocketWSGIHandler(
            self.rfile, self.wfile, self.get_stderr(), self.get_environ()
        )
        handler.request_handler = self      # backpointer for logging
        handler.run(self.server.get_app())

class WSGIServer(_WSGIServer):
    def initialize_websockets_manager(self):
        """
        Call thos to start the underlying websockets
        manager. Make sure to call it once your server
        is created.
        """
        self.manager = WebSocketManager()
        self.manager.start()

    def shutdown_request(self, request):
        """
        The base class would close our socket
        if we didn't override it.
        """
        pass

    def link_websocket_to_server(self, ws):
        """
        Call this from your WSGI handler when a websocket
        has been created.
        """
        self.manager.add(ws)

    def server_close(self):
        """
        Properly initiate closing handshakes on
        all websockets when the WSGI server terminates.
        """
        if hasattr(self, 'manager'):
            self.manager.close_all()
            self.manager.stop()
            self.manager.join()
            delattr(self, 'manager')
        _WSGIServer.server_close(self)

if __name__ == '__main__':
    from ws4py import configure_logger
    configure_logger()

    from wsgiref.simple_server import make_server
    from ws4py.websocket import EchoWebSocket

    server = make_server('', 9000, server_class=WSGIServer,
                         handler_class=WebSocketWSGIRequestHandler,
                         app=WebSocketWSGIApplication(handler_cls=EchoWebSocket))
    server.initialize_websockets_manager()
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        server.server_close()

########NEW FILE########
__FILENAME__ = wsgiutils
# -*- coding: utf-8 -*-
__doc__ = """
This module provides a WSGI application suitable
for a WSGI server such as gevent or wsgiref for instance.

:pep:`333` couldn't foresee a protocol such as
WebSockets but luckily the way the initial
protocol upgrade was designed means that we can
fit the handshake in a WSGI flow.

The handshake validates the request against
some internal or user-provided values and
fails the request if the validation doesn't
complete.

On success, the provided WebSocket subclass
is instanciated and stored into the
`'ws4py.websocket'` environ key so that
the WSGI server can handle it.

The WSGI application returns an empty iterable
since there is little value to return some
content within the response to the handshake.

A server wishing to support WebSocket via ws4py
should:

- Provide the real socket object to ws4py through the
  `'ws4py.socket'` environ key. We can't use `'wsgi.input'`
  as it may be wrapper to the socket we wouldn't know
  how to extract the socket from.
- Look for the `'ws4py.websocket'` key in the environ
  when the application has returned and probably attach
  it to a :class:`ws4py.manager.WebSocketManager` instance
  so that the websocket runs its life.
- Remove the `'ws4py.websocket'` and `'ws4py.socket'`
  environ keys once the application has returned.
  No need for these keys to persist.
- Not close the underlying socket otherwise, well,
  your websocket will also shutdown.

.. warning::

  The WSGI application sets the `'Upgrade'` header response
  as specified by :rfc:`6455`. This is not tolerated by
  :pep:`333` since it's a hop-by-hop header.
  We expect most servers won't mind.
"""
import base64
from hashlib import sha1
import logging
import sys

from ws4py.websocket import WebSocket
from ws4py.exc import HandshakeError
from ws4py.compat import unicode, py3k
from ws4py import WS_VERSION, WS_KEY, format_addresses

logger = logging.getLogger('ws4py')

__all__ = ['WebSocketWSGIApplication']

class WebSocketWSGIApplication(object):
    def __init__(self, protocols=None, extensions=None, handler_cls=WebSocket):
        """
        WSGI application usable to complete the upgrade handshake
        by validating the requested protocols and extensions as
        well as the websocket version.

        If the upgrade validates, the `handler_cls` class
        is instanciated and stored inside the WSGI `environ`
        under the `'ws4py.websocket'` key to make it
        available to the WSGI handler.
        """
        self.protocols = protocols
        self.extensions = extensions
        self.handler_cls = handler_cls

    def make_websocket(self, sock, protocols, extensions, environ):
        """
        Initialize the `handler_cls` instance with the given
        negociated sets of protocols and extensions as well as
        the `environ` and `sock`.

        Stores then the instance in the `environ` dict
        under the `'ws4py.websocket'` key.
        """
        websocket = self.handler_cls(sock, protocols, extensions,
                                     environ.copy())
        environ['ws4py.websocket'] = websocket
        return websocket

    def __call__(self, environ, start_response):
        if environ.get('REQUEST_METHOD') != 'GET':
            raise HandshakeError('HTTP method must be a GET')

        for key, expected_value in [('HTTP_UPGRADE', 'websocket'),
                                    ('HTTP_CONNECTION', 'upgrade')]:
            actual_value = environ.get(key, '').lower()
            if not actual_value:
                raise HandshakeError('Header %s is not defined' % key)
            if expected_value not in actual_value:
                raise HandshakeError('Illegal value for header %s: %s' %
                                     (key, actual_value))

        key = environ.get('HTTP_SEC_WEBSOCKET_KEY')
        if key:
            ws_key = base64.b64decode(key.encode('utf-8'))
            if len(ws_key) != 16:
                raise HandshakeError("WebSocket key's length is invalid")

        version = environ.get('HTTP_SEC_WEBSOCKET_VERSION')
        supported_versions = b', '.join([unicode(v).encode('utf-8') for v in WS_VERSION])
        version_is_valid = False
        if version:
            try: version = int(version)
            except: pass
            else: version_is_valid = version in WS_VERSION

        if not version_is_valid:
            environ['websocket.version'] = unicode(version).encode('utf-8')
            raise HandshakeError('Unhandled or missing WebSocket version')

        ws_protocols = []
        protocols = self.protocols or []
        subprotocols = environ.get('HTTP_SEC_WEBSOCKET_PROTOCOL')
        if subprotocols:
            for s in subprotocols.split(','):
                s = s.strip()
                if s in protocols:
                    ws_protocols.append(s)

        ws_extensions = []
        exts = self.extensions or []
        extensions = environ.get('HTTP_SEC_WEBSOCKET_EXTENSIONS')
        if extensions:
            for ext in extensions.split(','):
                ext = ext.strip()
                if ext in exts:
                    ws_extensions.append(ext)

        accept_value = base64.b64encode(sha1(key.encode('utf-8') + WS_KEY).digest())
        if py3k: accept_value = accept_value.decode('utf-8')
        upgrade_headers = [
            ('Upgrade', 'websocket'),
            ('Connection', 'Upgrade'),
            ('Sec-WebSocket-Version', '%s' % version),
            ('Sec-WebSocket-Accept', accept_value),
            ]
        if ws_protocols:
            upgrade_headers.append(('Sec-WebSocket-Protocol', ', '.join(ws_protocols)))
        if ws_extensions:
            upgrade_headers.append(('Sec-WebSocket-Extensions', ','.join(ws_extensions)))

        start_response("101 Switching Protocols", upgrade_headers)

        self.make_websocket(environ['ws4py.socket'],
                            ws_protocols,
                            ws_extensions,
                            environ)

        return []

########NEW FILE########
__FILENAME__ = streaming
# -*- coding: utf-8 -*-
import struct
from struct import unpack

from tangelo.ws4py.utf8validator import Utf8Validator
from tangelo.ws4py.messaging import TextMessage, BinaryMessage, CloseControlMessage,\
     PingControlMessage, PongControlMessage
from tangelo.ws4py.framing import Frame, OPCODE_CONTINUATION, OPCODE_TEXT, \
     OPCODE_BINARY, OPCODE_CLOSE, OPCODE_PING, OPCODE_PONG
from tangelo.ws4py.exc import FrameTooLargeException, ProtocolException, InvalidBytesError,\
     TextFrameEncodingException, UnsupportedFrameTypeException, StreamClosed
from tangelo.ws4py.compat import py3k

VALID_CLOSING_CODES = [1000, 1001, 1002, 1003, 1007, 1008, 1009, 1010, 1011]

class Stream(object):
    def __init__(self, always_mask=False, expect_masking=True):
        """ Represents a websocket stream of bytes flowing in and out.

        The stream doesn't know about the data provider itself and
        doesn't even know about sockets. Instead the stream simply
        yields for more bytes whenever it requires them. The stream owner
        is responsible to provide the stream with those bytes until
        a frame can be interpreted.

        .. code-block:: python
           :linenos:

           >>> s = Stream()
           >>> s.parser.send(BYTES)
           >>> s.has_messages
           False
           >>> s.parser.send(MORE_BYTES)
           >>> s.has_messages
           True
           >>> s.message
           <TextMessage ... >

        Set ``always_mask`` to mask all frames built.

        Set ``expect_masking`` to indicate masking will be
        checked on all parsed frames.
        """

        self.message = None
        """
        Parsed test or binary messages. Whenever the parser
        reads more bytes from a fragment message, those bytes
        are appended to the most recent message.
        """

        self.pings = []
        """
        Parsed ping control messages. They are instances of
        :class:`ws4py.messaging.PingControlMessage`
        """

        self.pongs = []
        """
        Parsed pong control messages. They are instances of
        :class:`ws4py.messaging.PongControlMessage`
        """

        self.closing = None
        """
        Parsed close control messsage. Instance of
        :class:`ws4py.messaging.CloseControlMessage`
        """

        self.errors = []
        """
        Detected errors while parsing. Instances of
        :class:`ws4py.messaging.CloseControlMessage`
        """

        self._parser = None
        """
        Parser in charge to process bytes it is fed with.
        """

        self.always_mask = always_mask
        self.expect_masking = expect_masking

    @property
    def parser(self):
        if self._parser is None:
            self._parser = self.receiver()
            # Python generators must be initialized once.
            next(self.parser)
        return self._parser

    def _cleanup(self):
        """
        Frees the stream's resources rendering it unusable.
        """
        self.message = None
        if self._parser is not None:
            if not self._parser.gi_running:
                self._parser.close()
            self._parser = None
        self.errors = None
        self.pings = None
        self.pongs = None
        self.closing = None

    def text_message(self, text):
        """
        Returns a :class:`ws4py.messaging.TextMessage` instance
        ready to be built. Convenience method so
        that the caller doesn't need to import the
        :class:`ws4py.messaging.TextMessage` class itself.
        """
        return TextMessage(text=text)

    def binary_message(self, bytes):
        """
        Returns a :class:`ws4py.messaging.BinaryMessage` instance
        ready to be built. Convenience method so
        that the caller doesn't need to import the
        :class:`ws4py.messaging.BinaryMessage` class itself.
        """
        return BinaryMessage(bytes)

    @property
    def has_message(self):
        """
        Checks if the stream has received any message
        which, if fragmented, is now completed.
        """
        if self.message is not None:
            return self.message.completed

        return False

    def close(self, code=1000, reason=''):
        """
        Returns a close control message built from
        a :class:`ws4py.messaging.CloseControlMessage` instance,
        using the given status ``code`` and ``reason`` message.
        """
        return CloseControlMessage(code=code, reason=reason)

    def ping(self, data=''):
        """
        Returns a ping control message built from
        a :class:`ws4py.messaging.PingControlMessage` instance.
        """
        return PingControlMessage(data).single(mask=self.always_mask)

    def pong(self, data=''):
        """
        Returns a ping control message built from
        a :class:`ws4py.messaging.PongControlMessage` instance.
        """
        return PongControlMessage(data).single(mask=self.always_mask)

    def receiver(self):
        """
        Parser that keeps trying to interpret bytes it is fed with as
        incoming frames part of a message.

        Control message are single frames only while data messages, like text
        and binary, may be fragmented accross frames.

        The way it works is by instanciating a :class:`wspy.framing.Frame` object,
        then running its parser generator which yields how much bytes
        it requires to performs its task. The stream parser yields this value
        to its caller and feeds the frame parser.

        When the frame parser raises :exc:`StopIteration`, the stream parser
        tries to make sense of the parsed frame. It dispatches the frame's bytes
        to the most appropriate message type based on the frame's opcode.

        Overall this makes the stream parser totally agonstic to
        the data provider.
        """
        utf8validator = Utf8Validator()
        running = True
        frame = None
        while running:
            frame = Frame()
            while 1:
                try:
                    some_bytes = (yield next(frame.parser))
                    frame.parser.send(some_bytes)
                except GeneratorExit:
                    running = False
                    break
                except StopIteration:
                    frame._cleanup()
                    some_bytes = frame.body

                    # Let's avoid unmasking when there is no payload
                    if some_bytes:
                        if frame.masking_key and self.expect_masking:
                            some_bytes = frame.unmask(some_bytes)
                        elif not frame.masking_key and self.expect_masking:
                            msg = CloseControlMessage(code=1002, reason='Missing masking when expected')
                            self.errors.append(msg)
                            break
                        elif frame.masking_key and not self.expect_masking:
                            msg = CloseControlMessage(code=1002, reason='Masked when not expected')
                            self.errors.append(msg)
                            break
                        else:
                            # If we reach this stage, it's because
                            # the frame wasn't masked and we didn't expect
                            # it anyway. Therefore, on py2k, the bytes
                            # are actually a str object and can't be used
                            # in the utf8 validator as we need integers
                            # when we get each byte one by one.
                            # Our only solution here is to convert our
                            # string to a bytearray.
                            some_bytes = bytearray(some_bytes)

                    if frame.opcode == OPCODE_TEXT:
                        if self.message and not self.message.completed:
                            # We got a text frame before we completed the previous one
                            msg = CloseControlMessage(code=1002, reason='Received a new message before completing previous')
                            self.errors.append(msg)
                            break

                        m = TextMessage(some_bytes)
                        m.completed = (frame.fin == 1)
                        self.message = m

                        if some_bytes:
                            is_valid, end_on_code_point, _, _ = utf8validator.validate(some_bytes)

                            if not is_valid or (m.completed and not end_on_code_point):
                                self.errors.append(CloseControlMessage(code=1007, reason='Invalid UTF-8 bytes'))
                                break

                    elif frame.opcode == OPCODE_BINARY:
                        if self.message and not self.message.completed:
                            # We got a text frame before we completed the previous one
                            msg = CloseControlMessage(code=1002, reason='Received a new message before completing previous')
                            self.errors.append(msg)
                            break

                        m = BinaryMessage(some_bytes)
                        m.completed = (frame.fin == 1)
                        self.message = m

                    elif frame.opcode == OPCODE_CONTINUATION:
                        m = self.message
                        if m is None:
                            self.errors.append(CloseControlMessage(code=1002, reason='Message not started yet'))
                            break

                        m.extend(some_bytes)
                        m.completed = (frame.fin == 1)
                        if m.opcode == OPCODE_TEXT:
                            if some_bytes:
                                is_valid, end_on_code_point, _, _ = utf8validator.validate(some_bytes)

                                if not is_valid or (m.completed and not end_on_code_point):
                                    self.errors.append(CloseControlMessage(code=1007, reason='Invalid UTF-8 bytes'))
                                    break

                    elif frame.opcode == OPCODE_CLOSE:
                        code = 1000
                        reason = ""
                        if frame.payload_length == 0:
                            self.closing = CloseControlMessage(code=1000)
                        elif frame.payload_length == 1:
                            self.closing = CloseControlMessage(code=1002, reason='Payload has invalid length')
                        else:
                            try:
                                # at this stage, some_bytes have been unmasked
                                # so actually are held in a bytearray
                                code = int(unpack("!H", bytes(some_bytes[0:2]))[0])
                            except struct.error:
                                code = 1002
                                reason = 'Failed at decoding closing code'
                            else:
                                # Those codes are reserved or plainly forbidden
                                if code not in VALID_CLOSING_CODES and not (2999 < code < 5000):
                                    reason = 'Invalid Closing Frame Code: %d' % code
                                    code = 1002
                                elif frame.payload_length > 1:
                                    reason = some_bytes[2:] if frame.masking_key else frame.body[2:]

                                    if not py3k: reason = bytearray(reason)
                                    is_valid, end_on_code_point, _, _ = utf8validator.validate(reason)
                                    if not is_valid or not end_on_code_point:
                                        self.errors.append(CloseControlMessage(code=1007, reason='Invalid UTF-8 bytes'))
                                        break
                                    reason = bytes(reason)
                            self.closing = CloseControlMessage(code=code, reason=reason)

                    elif frame.opcode == OPCODE_PING:
                        self.pings.append(PingControlMessage(some_bytes))

                    elif frame.opcode == OPCODE_PONG:
                        self.pongs.append(PongControlMessage(some_bytes))

                    else:
                        self.errors.append(CloseControlMessage(code=1003))

                    break

                except ProtocolException:
                    self.errors.append(CloseControlMessage(code=1002))
                    break
                except FrameTooLargeException:
                    self.errors.append(CloseControlMessage(code=1002, reason="Frame was too large"))
                    break

            frame._cleanup()
            frame.body = None
            frame = None

            if self.message is not None and self.message.completed:
                utf8validator.reset()

        utf8validator.reset()
        utf8validator = None

        self._cleanup()

########NEW FILE########
__FILENAME__ = utf8validator
# coding=utf-8

###############################################################################
##
##  Copyright 2011 Tavendo GmbH
##
##  Note:
##
##  This code is a Python implementation of the algorithm
##
##            "Flexible and Economical UTF-8 Decoder"
##
##  by Bjoern Hoehrmann
##
##       bjoern@hoehrmann.de
##       http://bjoern.hoehrmann.de/utf-8/decoder/dfa/
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################


class Utf8Validator(object):
    """
    Incremental UTF-8 validator with constant memory consumption (minimal state).

    Implements the algorithm "Flexible and Economical UTF-8 Decoder" by
    Bjoern Hoehrmann (http://bjoern.hoehrmann.de/utf-8/decoder/dfa/).
    """

    ## DFA transitions
    UTF8VALIDATOR_DFA = [
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, # 00..1f
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, # 20..3f
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, # 40..5f
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, # 60..7f
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, # 80..9f
        7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, # a0..bf
        8,8,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, # c0..df
        0xa,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x4,0x3,0x3, # e0..ef
        0xb,0x6,0x6,0x6,0x5,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8, # f0..ff
        0x0,0x1,0x2,0x3,0x5,0x8,0x7,0x1,0x1,0x1,0x4,0x6,0x1,0x1,0x1,0x1, # s0..s0
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1, # s1..s2
        1,2,1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1, # s3..s4
        1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,3,1,1,1,1,1,1, # s5..s6
        1,3,1,1,1,1,1,3,1,3,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1, # s7..s8
    ]

    UTF8_ACCEPT = 0
    UTF8_REJECT = 1

    def __init__(self):
        self.reset()

    def decode(self, b):
        """
        Eat one UTF-8 octet, and validate on the fly.

        Returns UTF8_ACCEPT when enough octets have been consumed, in which case
        self.codepoint contains the decoded Unicode code point.

        Returns UTF8_REJECT when invalid UTF-8 was encountered.

        Returns some other positive integer when more octets need to be eaten.
        """
        type = Utf8Validator.UTF8VALIDATOR_DFA[b]
        if self.state != Utf8Validator.UTF8_ACCEPT:
            self.codepoint = (b & 0x3f) | (self.codepoint << 6)
        else:
            self.codepoint = (0xff >> type) & b
        self.state = Utf8Validator.UTF8VALIDATOR_DFA[256 + self.state * 16 + type]
        return self.state

    def reset(self):
        """
        Reset validator to start new incremental UTF-8 decode/validation.
        """
        self.state = Utf8Validator.UTF8_ACCEPT
        self.codepoint = 0
        self.i = 0

    def validate(self, ba):
        """
        Incrementally validate a chunk of bytes provided as bytearray.

        Will return a quad (valid?, endsOnCodePoint?, currentIndex, totalIndex).

        As soon as an octet is encountered which renders the octet sequence
        invalid, a quad with valid? == False is returned. currentIndex returns
        the index within the currently consumed chunk, and totalIndex the
        index within the total consumed sequence that was the point of bail out.
        When valid? == True, currentIndex will be len(ba) and totalIndex the
        total amount of consumed bytes.
        """
        state = self.state
        DFA = Utf8Validator.UTF8VALIDATOR_DFA
        i = 0  # make sure 'i' is set if when 'ba' is empty
        for i, b in enumerate(ba):
            ## optimized version of decode(), since we are not interested in actual code points
            state = DFA[256 + (state << 4) + DFA[b]]
            if state == Utf8Validator.UTF8_REJECT:
                self.i += i
                self.state = state
                return False, False, i, self.i
        self.i += i
        self.state = state
        return True, state == Utf8Validator.UTF8_ACCEPT, i, self.i

########NEW FILE########
__FILENAME__ = websocket
# -*- coding: utf-8 -*-
import logging
import socket
import time
import threading
import types

from tangelo.ws4py import WS_KEY, WS_VERSION
from tangelo.ws4py.exc import HandshakeError, StreamClosed
from tangelo.ws4py.streaming import Stream
from tangelo.ws4py.messaging import Message, PongControlMessage
from tangelo.ws4py.compat import basestring, unicode

DEFAULT_READING_SIZE = 2

logger = logging.getLogger('ws4py')

__all__ = ['WebSocket', 'EchoWebSocket', 'Heartbeat']

class Heartbeat(threading.Thread):
    def __init__(self, websocket, frequency=2.0):
        """
        Runs at a periodic interval specified by
        `frequency` by sending an unsolicitated pong
        message to the connected peer.

        If the message fails to be sent and a socket
        error is raised, we close the websocket
        socket automatically, triggering the `closed`
        handler.
        """
        threading.Thread.__init__(self)
        self.websocket = websocket
        self.frequency = frequency

    def __enter__(self):
        if self.frequency:
            self.start()
        return self

    def __exit__(self, exc_type, exc_value, exc_tb):
        self.stop()

    def stop(self):
        self.running = False

    def run(self):
        self.running = True
        while self.running:
            time.sleep(self.frequency)
            if self.websocket.terminated:
                break

            try:
                self.websocket.send(PongControlMessage(data='beep'))
            except socket.error:
                logger.info("Heartbeat failed")
                self.websocket.server_terminated = True
                self.websocket.close_connection()
                break

class WebSocket(object):
    """ Represents a websocket endpoint and provides a high level interface to drive the endpoint. """

    def __init__(self, sock, protocols=None, extensions=None, environ=None, heartbeat_freq=None):
        """ The ``sock`` is an opened connection
        resulting from the websocket handshake.

        If ``protocols`` is provided, it is a list of protocols
        negotiated during the handshake as is ``extensions``.

        If ``environ`` is provided, it is a copy of the WSGI environ
        dictionnary from the underlying WSGI server.
        """

        self.stream = Stream(always_mask=False)
        """
        Underlying websocket stream that performs the websocket
        parsing to high level objects. By default this stream
        never masks its messages. Clients using this class should
        set the ``stream.always_mask`` fields to ``True``
        and ``stream.expect_masking`` fields to ``False``.
        """

        self.protocols = protocols
        """
        List of protocols supported by this endpoint.
        Unused for now.
        """

        self.extensions = extensions
        """
        List of extensions supported by this endpoint.
        Unused for now.
        """

        self.sock = sock
        """
        Underlying connection.
        """

        self.client_terminated = False
        """
        Indicates if the client has been marked as terminated.
        """

        self.server_terminated = False
        """
        Indicates if the server has been marked as terminated.
        """

        self.reading_buffer_size = DEFAULT_READING_SIZE
        """
        Current connection reading buffer size.
        """

        self.environ = environ
        """
        WSGI environ dictionary.
        """

        self.heartbeat_freq = heartbeat_freq
        """
        At which interval the heartbeat will be running.
        Set this to `0` or `None` to disable it entirely.
        """

        self._local_address = None
        self._peer_address = None

    @property
    def local_address(self):
        """
        Local endpoint address as a tuple
        """
        if not self._local_address:
            self._local_address = self.sock.getsockname()
            if len(self._local_address) == 4:
                self._local_address = self._local_address[:2]
        return self._local_address

    @property
    def peer_address(self):
        """
        Peer endpoint address as a tuple
        """
        if not self._peer_address:
            self._peer_address = self.sock.getpeername()
            if len(self._peer_address) == 4:
                self._peer_address = self._peer_address[:2]
        return self._peer_address

    def opened(self):
        """
        Called by the server when the upgrade handshake
        has succeeeded.
        """
        pass

    def close(self, code=1000, reason=''):
        """
        Call this method to initiate the websocket connection
        closing by sending a close frame to the connected peer.
        The ``code`` is the status code representing the
        termination's reason.

        Once this method is called, the ``server_terminated``
        attribute is set. Calling this method several times is
        safe as the closing frame will be sent only the first
        time.

        .. seealso:: Defined Status Codes http://tools.ietf.org/html/rfc6455#section-7.4.1
        """
        if not self.server_terminated:
            self.server_terminated = True
            self._write(self.stream.close(code=code, reason=reason).single(mask=self.stream.always_mask))

    def closed(self, code, reason=None):
        """
        Called  when the websocket stream and connection are finally closed.
        The provided ``code`` is status set by the other point and
        ``reason`` is a human readable message.

        .. seealso:: Defined Status Codes http://tools.ietf.org/html/rfc6455#section-7.4.1
        """
        pass

    @property
    def terminated(self):
        """
        Returns ``True`` if both the client and server have been
        marked as terminated.
        """
        return self.client_terminated is True and self.server_terminated is True

    @property
    def connection(self):
        return self.sock

    def close_connection(self):
        """
        Shutdowns then closes the underlying connection.
        """
        if self.sock:
            try:
                self.sock.shutdown(socket.SHUT_RDWR)
                self.sock.close()
            except:
                pass
            finally:
                self.sock = None

    def ponged(self, pong):
        """
        Pong message, as a :class:`messaging.PongControlMessage` instance,
        received on the stream.
        """
        pass

    def received_message(self, message):
        """
        Called whenever a complete ``message``, binary or text,
        is received and ready for application's processing.

        The passed message is an instance of :class:`messaging.TextMessage`
        or :class:`messaging.BinaryMessage`.

        .. note:: You should override this method in your subclass.
        """
        pass

    def _write(self, b):
        """
        Trying to prevent a write operation
        on an already closed websocket stream.

        This cannot be bullet proof but hopefully
        will catch almost all use cases.
        """
        if self.terminated or self.sock is None:
            raise RuntimeError("Cannot send on a terminated websocket")

        # This fixes an error in the ws4py package - not yet in the upstream
        # package. --Kitware
        #
        # blocking mode, never throw WantWriteError
        self.sock.setblocking(1)

        self.sock.sendall(b)

    def send(self, payload, binary=False):
        """
        Sends the given ``payload`` out.

        If ``payload`` is some bytes or a bytearray,
        then it is sent as a single message not fragmented.

        If ``payload`` is a generator, each chunk is sent as part of
        fragmented message.

        If ``binary`` is set, handles the payload as a binary message.
        """
        message_sender = self.stream.binary_message if binary else self.stream.text_message

        if isinstance(payload, basestring) or isinstance(payload, bytearray):
            m = message_sender(payload).single(mask=self.stream.always_mask)
            self._write(m)

        elif isinstance(payload, Message):
            data = payload.single(mask=self.stream.always_mask)
            self._write(data)

        elif type(payload) == types.GeneratorType:
            bytes = next(payload)
            first = True
            for chunk in payload:
                self._write(message_sender(bytes).fragment(first=first, mask=self.stream.always_mask))
                bytes = chunk
                first = False

            self._write(message_sender(bytes).fragment(last=True, mask=self.stream.always_mask))

        else:
            raise ValueError("Unsupported type '%s' passed to send()" % type(payload))

    def once(self):
        """
        Performs the operation of reading from the underlying
        connection in order to feed the stream of bytes.

        We start with a small size of two bytes to be read
        from the connection so that we can quickly parse an
        incoming frame header. Then the stream indicates
        whatever size must be read from the connection since
        it knows the frame payload length.

        It returns `False` if an error occurred at the
        socket level or during the bytes processing. Otherwise,
        it returns `True`.
        """
        if self.terminated:
            logger.debug("WebSocket is already terminated")
            return False

        try:
            b = self.sock.recv(self.reading_buffer_size)
        except socket.error:
            logger.exception("Failed to receive data")
            return False
        else:
            if not self.process(b):
                return False

        return True

    def terminate(self):
        """
        Completes the websocket by calling the `closed`
        method either using the received closing code
        and reason, or when none was received, using
        the special `1006` code.

        Finally close the underlying connection for
        good and cleanup resources by unsetting
        the `environ` and `stream` attributes.
        """
        s = self.stream

        self.client_terminated = self.server_terminated = True

        try:
            if not s.closing:
                self.closed(1006, "Going away")
            else:
                self.closed(s.closing.code, s.closing.reason)
        finally:
            self.close_connection()

            # Cleaning up resources
            s._cleanup()
            self.stream = None
            self.environ = None

    def process(self, bytes):
        """ Takes some bytes and process them through the
        internal stream's parser. If a message of any kind is
        found, performs one of these actions:

        * A closing message will initiate the closing handshake
        * Errors will initiate a closing handshake
        * A message will be passed to the ``received_message`` method
        * Pings will see pongs be sent automatically
        * Pongs will be passed to the ``ponged`` method

        The process should be terminated when this method
        returns ``False``.
        """
        s = self.stream

        if not bytes and self.reading_buffer_size > 0:
            return False
        
        self.reading_buffer_size = s.parser.send(bytes) or DEFAULT_READING_SIZE

        if s.closing is not None:
            logger.debug("Closing message received (%d) '%s'" % (s.closing.code, s.closing.reason))
            if not self.server_terminated:
                self.close(s.closing.code, s.closing.reason)
            else:
                self.client_terminated = True
            s = None
            return False

        if s.errors:
            for error in s.errors:
                logger.debug("Error message received (%d) '%s'" % (error.code, error.reason))
                self.close(error.code, error.reason)
            s.errors = []
            s = None
            return False

        if s.has_message:
            self.received_message(s.message)
            if s.message is not None:
                s.message.data = None
                s.message = None
            s = None
            return True

        if s.pings:
            for ping in s.pings:
                self._write(s.pong(ping.data))
            s.pings = []

        if s.pongs:
            for pong in s.pongs:
                self.ponged(pong)
            s.pongs = []

        s = None
        return True

    def run(self):
        """
        Performs the operation of reading from the underlying
        connection in order to feed the stream of bytes.

        We start with a small size of two bytes to be read
        from the connection so that we can quickly parse an
        incoming frame header. Then the stream indicates
        whatever size must be read from the connection since
        it knows the frame payload length.

        Note that we perform some automatic opererations:

        * On a closing message, we respond with a closing
          message and finally close the connection
        * We respond to pings with pong messages.
        * Whenever an error is raised by the stream parsing,
          we initiate the closing of the connection with the
          appropiate error code.

        This method is blocking and should likely be run
        in a thread.
        """
        self.sock.setblocking(True)
        with Heartbeat(self, frequency=self.heartbeat_freq):
            s = self.stream

            try:
                self.opened()
                while not self.terminated:
                    if not self.once():
                        break
            finally:
                self.terminate()

class EchoWebSocket(WebSocket):
    def received_message(self, message):
        """
        Automatically sends back the provided ``message`` to
        its originating endpoint.
        """
        self.send(message.data, message.is_binary)

########NEW FILE########
__FILENAME__ = myservice
def run(*pargs, **kwargs):
    return "Hello from <b>myservice.py</b>!"

########NEW FILE########
__FILENAME__ = calc
import tangelo

allowed = ["add", "subtract", "multiply", "divide"]

@tangelo.types(a=float, b=float)
def run(operation, a=None, b=None):
    if a is None:
        return "Parameter 'a' is missing!"
    elif b is None:
        return "Parameter 'b' is missing!"

    try:
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            return "Unsupported operation: %s\nAllowed operations are: %s" % (operation, ", ".join(allowed))
    except ValueError:
        return "Could not %s '%s' and '%s'" % (operation, a, b)
    except ZeroDivisionError:
        return "Can't divide by zero!"

########NEW FILE########
__FILENAME__ = emailers
import datetime
import itertools
import pymongo
import tangelo


def run(host, database, collection, start_time=None,
        end_time=None, center=None, degree=None):
    response = {}

    # Bail with error if any of the required arguments is missing.
    missing = map(lambda x: x[0], filter(lambda x: x[1] is None,
                                         zip(["start_time", "end_time",
                                              "center", "degree"],
                                             [start_time, end_time,
                                              center, degree])))
    if len(missing) > 0:
        response["error"] = ("missing required arguments: " +
                             "%s" % (", ".join(missing)))
        return response

    # Cast the arguments to the right types.
    #
    # The degree is the degree of separation between the center element and the
    # retrieved nodes - an integer.
    try:
        degree = int(degree)
    except ValueError:
        response["error"] = "argument 'degree' must be an integer"
        return response

    # The start time is the number of milliseconds since the epoch (which is
    # how JavaScript dates are constructed, and therefore how dates are stored
    # in MongoDB) - an integer.
    try:
        start_time = datetime.datetime.strptime(start_time, "%Y-%m-%d")
    except ValueError:
        response["error"] = ("argument 'start_time' " +
                             "must be in YYYY-MM-DD format")
        return response

    # The end time is another date - an integer.
    try:
        end_time = datetime.datetime.strptime(end_time, "%Y-%m-%d")
    except ValueError:
        response["error"] = "argument 'end_time' must be in YYYY-MM-DD format"
        return response

    # Get a handle to the database collection.
    ex = None
    try:
        c = pymongo.Connection(host)[database][collection]
    except (pymongo.errors.AutoReconnect,
            pymongo.errors.ConnectionFailure) as e:
        ex = e

    # Bail out with an error message if there was an exception.
    if ex is not None:
        response["error"] = "database error: %s" % (e.message)
        return response

    if c.find({}).count() == 0:
        response["error"] = "no database found"
        return response

    # Start a set of all interlocutors we're interested in - that includes the
    # center emailer.
    talkers = set([center])

    # Also start a table of distances from the center.
    distance = {center: 0}

    current_talkers = list(talkers)
    all_results = []
    for i in range(degree):
        # Construct and send a query to retrieve all records involving the
        # current talkers, occurring within the time bounds specified, and
        # involving two known addresses.
        query = {"$and": [{"date": {"$gte": start_time}},
                          {"date": {"$lt": end_time}},
                          {"source": {"$ne": ""}},
                          {"target": {"$ne": ""}},
                          {"$or": [{"source": {"$in": current_talkers}},
                                   {"target": {"$in": current_talkers}}]}]}
        results = c.find(query, fields=["target", "source"])

        # Collect the names.
        current_talkers = list(
            itertools.chain(*map(lambda x: [x["target"], x["source"]],
                                 results)))
        talkers = talkers.union(current_talkers)

        # Compute updates to everyone's distance from center.
        for t in current_talkers:
            if t not in distance:
                distance[t] = i + 1

        # Rewind and save the cursor.
        results.rewind()
        all_results.append(results)

    # Construct a canonical graph structure from the set of talkers and the
    # list of emails.
    #
    # Start with an index map of the talkers.
    talkers = list(talkers)
    talker_index = {name: index for (index, name) in enumerate(talkers)}

    # Create a chained iterable from all the rewound partial results.
    all_results = itertools.chain(*all_results)

    # Create a list of graph edges suitable for use by D3 - replace each record
    # in the data with one that carries an index into the emailers list.
    edges = []
    for result in all_results:
        source = result["source"]
        target = result["target"]
        ident = str(result["_id"])

        rec = {"source": talker_index[source],
               "target": talker_index[target],
               "id": ident}

        edges.append(rec)

    talkers = [{"email": n, "distance": distance[n]} for n in talkers]

    # Stuff the graph data into the response object, and return it.
    response["result"] = {"nodes": talkers,
                          "edges": edges}
    return response

########NEW FILE########
__FILENAME__ = ner
# This service performs named entity recognition on input text.
def run(text=""):
    try:
        import nltk
        import nltk.chunk.named_entity
    except ImportError:
        return {"error": "NLTK not installed"}

    # Create an empty result container.
    response = {"result": []}

    # If nothing passed in, return an empty result.
    if text == "":
        return response

    # Otherwise, perform named entity recognition.
    sentences = nltk.sent_tokenize(text)
    chunks = [nltk.ne_chunk(nltk.pos_tag(nltk.word_tokenize(s)))
              for s in sentences]

    # Now find all tagged chunks that are not whole sentences - gather the
    # leaves of such chunks into strings, and place them in the list of named
    # entities.
    for c in chunks:
        for subtree in filter(lambda x: x.node != 'S', c.subtrees()):
            response['result'].append((subtree.node,
                                       ' '.join(map(lambda x: x[0],
                                                    subtree.leaves()))))

    return response

########NEW FILE########
__FILENAME__ = nermongo
import bson.json_util
import pymongo
import json

import tangelo


def run(servername, dbname, collname, file_hash=None, data=None):
    # Construct an empty response object.
    response = {}

    # If no schema was passed in, give an error.
    #
    # TODO(choudhury): see comment below about error codes, etc.
    if file_hash is None:
        response["error"] = "no file hash"
        return bson.json_util.dumps(response)

    # Establish a connection to the MongoDB server.
    try:
        conn = pymongo.Connection(servername)
    except (pymongo.errors.AutoReconnect,
            pymongo.errors.ConnectionFailure) as e:
        response["error"] = "error: %s" % (e.message)
        return bson.json_util.dumps(response)

    # Extract the requested database and collection.
    db = conn[dbname]
    coll = db[collname]

    # If no data field was specified, treat this as a read request;
    # otherwise, write the data to the database.
    if data is None:
        # Create a search schema for finding the record with the appropriate
        # hash.
        schema = {"file_hash": file_hash}

        # Apply the schema to retrieve documents.
        response["result"] = [d for d in coll.find(schema)]
    else:
        # Convert the JSON object "data" to a Python object.
        try:
            pydata = bson.json_util.loads(data)
        except ValueError as e:
            response["error"] = e.message
            return bson.json_util.dumps(response)

        # Apply the schema to an insert request.
        coll.insert({"file_hash": file_hash, "data": data})

        # Return a success code.
        response["result"] = "ok"

    # Convert to JSON and return the result.
    return bson.json_util.dumps(response)

########NEW FILE########
__FILENAME__ = primes
import itertools
import math


def is_prime(v):
    for i in range(2, int(math.ceil(math.sqrt(v)) + 1)):
        if v % i == 0:
            return False
    return True


def primes():
    yield 2
    yield 3

    for i in itertools.count(start=5, step=2):
        if is_prime(i):
            yield i


def run():
    return primes()

########NEW FILE########
__FILENAME__ = vtkweb_cone
import vtk

def initialize(self, VTKWebApp, args):
    if not VTKWebApp.view:
        # VTK specific code
        renderer = vtk.vtkRenderer()
        renderWindow = vtk.vtkRenderWindow()
        renderWindow.AddRenderer(renderer)

        renderWindowInteractor = vtk.vtkRenderWindowInteractor()
        renderWindowInteractor.SetRenderWindow(renderWindow)
        renderWindowInteractor.GetInteractorStyle().SetCurrentStyleToTrackballCamera()

        cone = vtk.vtkConeSource()
        mapper = vtk.vtkPolyDataMapper()
        actor = vtk.vtkActor()

        mapper.SetInputConnection(cone.GetOutputPort())
        actor.SetMapper(mapper)

        renderer.AddActor(actor)
        renderer.ResetCamera()
        renderWindow.Render()

        # VTK Web application specific
        VTKWebApp.view = renderWindow
        self.Application.GetObjectIdMap().SetActiveObject("VIEW", renderWindow)

########NEW FILE########
__FILENAME__ = celery
import tangelo
import cherrypy
import sys
import json
#
# RESTful service used to create, monitor and terminate celery
# tasks.
#

# Remove current directory from search path so we don't hide the really
# celery module.
sys.path = sys.path[1:]

from celery import Celery
from celery import task, current_task
from celery.result import AsyncResult
from celery import states

celery = Celery()
config = tangelo.config()
celery.conf.update(**config)


@tangelo.restful
def get(job_id, operation, **kwargs):
    job = AsyncResult(job_id, backend=celery.backend)
    if operation == 'status':
        response = {'status': job.state}
        if job.state == states.FAILURE:
            response['message'] = str(job.result)
        elif job.state == 'PROGRESS':
            response['meta'] = str(job.result)

        return response
    elif operation == 'result':
        response = {'result': job.result}
        return response
    else:
        return tangelo.HTTPStatusCode(400, "Invalid request")


@tangelo.restful
def post(*pargs, **kwargs):
    input = cherrypy.request.body.read()

    if not pargs:
        return tangelo.HTTPStatusCode(400, "No task module specified")

    pargs = filter(None, pargs)
    task_module = '.'.join(pargs)
    async_result = celery.send_task('%s.run' % task_module, [input])

    return {'id': async_result.task_id}


@tangelo.restful
def delete(job_id, **kwargs):
    task = AsyncResult(job_id, backend=celery.backend)
    task.revoke(celery.broker_connection(), terminate=True)

########NEW FILE########
__FILENAME__ = config
import tangelo

import json


def run(path=""):
    if len(path) == 0:
        return {"error": "missing required argument 'path'"}

    path = tangelo.abspath(path)
    if path is None:
        return {"error": "illegal web path"}

    try:
        with open(path) as f:
            spec = json.loads(f.read())
    except (OSError, IOError):
        return {"status": "could not open file",
                "result": {}}
    except ValueError as e:
        return {"error": "could not parse JSON - %s" % (e.message)}

    return {"status": "OK",
            "result": spec}

########NEW FILE########
__FILENAME__ = impala-json
import impala
import json


def convert(value, type):
    if type == "tinyint":
        return int(value)
    elif type == "int":
        return int(value)
    elif type == "double":
        return float(value)
    elif type == "string":
        return value
    elif type == "boolean":
        return True if value == "true" else False
    return None


def convert_results(results, fields=False):
    schema = results.schema.fieldSchemas
    converted = []
    for d in results.data:
        parts = d.split("\t")
        if fields:
            row = {}
            for i in range(len(parts)):
                row[schema[i].name] = convert(parts[i], schema[i].type)
        else:
            row = []
            for i in range(len(parts)):
                row.append(convert(parts[i], schema[i].type))
        converted.append(row)
    return converted


def run(q="select 1 as testing", host="localhost",
        port="21000", fields="true"):
    client = impala.ImpalaBeeswaxClient(host + ':' + port)
    client.connect()
    results = client.execute(q)
    return convert_results(results, fields=(fields == "true"))

########NEW FILE########
__FILENAME__ = mongo
import bson.json_util
import pymongo

import tangelo


def decode(s, argname, resp):
    try:
        return bson.json_util.loads(s)
    except ValueError as e:
        resp['error'] = e.message + " (argument '%s' was '%s')" % (argname, s)
        raise


def run(server, db, coll, method='find', query=None, limit=1000,
        skip=0, fields=None, sort=None, fill=None):
    # Create an empty response object.
    response = {}

    # Check the requested method.
    if method not in ['find', 'insert']:
        response['error'] = "Unsupported MongoDB operation '%s'" % (method)
        return bson.json_util.dumps(response)

    # Decode the query strings into Python objects.
    try:
        if query is not None:
            query = decode(query, 'query', response)
        if fields is not None:
            fields = decode(fields, 'fields', response)
        if sort is not None:
            sort = decode(sort, 'sort', response)
        if fill is not None:
            fill = decode(fill, 'fill', response)
        else:
            fill = True
    except ValueError:
        return bson.json_util.dumps(response)

    # Cast the limit value to an int.
    try:
        limit = int(limit)
    except ValueError:
        response['error'] = ("Argument 'limit' ('%s') could " +
                             "not be converted to int.") % (limit)
        return bson.json_util.dumps(response)

    # Cast the skip value to an int.
    try:
        skip = int(skip)
    except ValueError:
        response['error'] = ("Argument 'skip' ('%s') could " +
                             "not be converted to int.") % (skip)
        return bson.json_util.dumps(response)

    # Create database connection.
    try:
        c = pymongo.Connection(server)[db][coll]
    except (pymongo.errors.AutoReconnect, pymongo.errors.ConnectionFailure):
        response['error'] = ("Could not connect to " +
                             "MongoDB server '%s'") % (server)
        return bson.json_util.dumps(response)

    # Perform the requested action.
    if method == 'find':
        # Do a find operation with the passed arguments.
        it = c.find(spec=query, fields=fields, skip=skip,
                    limit=limit, sort=sort)

        # Create a list of the results.
        if fill:
            results = [x for x in it]
        else:
            results = []

        # Create an object to structure the results.
        retobj = {}
        retobj['count'] = it.count()
        retobj['data'] = results

        # Pack the results into the response object, and return it.
        response['result'] = retobj
    else:
        raise RuntimeError("illegal method '%s' in module 'mongo'")

    # Return the response object.
    tangelo.log(str(response))
    return bson.json_util.dumps(response)

########NEW FILE########
__FILENAME__ = svg2pdf
from svglib.svglib import svg2rlg
from reportlab.graphics import renderPDF
import StringIO
import tangelo
import tempfile
import random

converted = {}


@tangelo.restful
def post():
    # drawing = svg2rlg(StringIO.StringIO(tangelo.request_body()))
    body = tangelo.request_body().read()
    f = tempfile.NamedTemporaryFile(delete=False)
    f.write(body)
    f.close()
    # return open(f.name).read()
    drawing = svg2rlg(f.name)
    # drawing.renderScale = 1
    id = '%030x' % random.randrange(16 ** 30)
    converted[id] = renderPDF.drawToString(drawing)
    return {"result": id, "error": None}


@tangelo.restful
def get(id=None):
    tangelo.content_type("application/pdf")
    tangelo.header("Content-disposition", "attachment; filename=figure.pdf")
    return converted[id]

########NEW FILE########
__FILENAME__ = 404
import tangelo


def run():
    return tangelo.HTTPStatusCode(404, "uh oh where is it?")

########NEW FILE########
__FILENAME__ = abspath
import tangelo


def run():
    return [["pass", tangelo.abspath("/blah/yay.html")],
            ["fail", tangelo.abspath("blah/yay.html")],
            ["fail", tangelo.abspath("/../blah/yay.html")],
            ["pass", tangelo.abspath("/~roni/blah")],
            ["fail", tangelo.abspath("/~roni/..")],
            ["fail", tangelo.abspath("~roni/blah")]]

########NEW FILE########
__FILENAME__ = broken
# This module, which contains no run() function, is meant for testing the error
# handling capabilities of Tangelo's web service module loader system.


def start():
    raise RuntimeError("this method is for testing only")

########NEW FILE########
__FILENAME__ = configured
import tangelo

def run():
    cfg = tangelo.config()
    return cfg["secret"]

########NEW FILE########
__FILENAME__ = echo
# This service simply echoes back the URL-encoded arguments passed to it.
def run(*pargs, **kwargs):
    response = ""

    # Dump the positional arguments.
    if len(pargs) > 0:
        response += "[" + ", ".join(pargs) + "]"

    # Dump the keyword arguments.
    for k in kwargs:
        response += "\n%s -> %s" % (k, kwargs[k])

    # Send the response back.
    if response != "":
        return response
    else:
        return "(No arguments passed)"

########NEW FILE########
__FILENAME__ = exceptional
# This module, which contains a Handler class whose go() method raises an
# exception, is meant for testing the error handling of Tangelo's web service
# module loader system.


def run():
    raise RuntimeError("this is an example error, " +
                       "from web service 'exceptional'")

########NEW FILE########
__FILENAME__ = restful
import tangelo

# This example demonstrates how to create a RESTful service for Tangelo.  You
# can try this out by starting Tangelo then using the curl program as follows:
#
# $ curl -X PUT -d foo=bar localhost:8080/service/restful/foo/baz/quark
#
# This will demonstrate the service's response to a PUT request, but you can
# change that verb out for any of the others.  Because the "delete" method has
# not been exposed via the tangelo.restful decorator, attempting the DELETE
# action will result in HTTP error 405.
#
# Also note that you can create non-standard verbs, simply by writing the
# function and exposing it via the decorator.


@tangelo.restful
def get(*pargs, **kwargs):
    return "GET: " + " ".join(pargs) + " %s" % (kwargs)


@tangelo.restful
def post(*pargs, **kwargs):
    return "POST: " + " ".join(pargs) + " %s" % (kwargs)


@tangelo.restful
def put(*pargs, **kwargs):
    return "PUT: " + " ".join(pargs) + " %s" % (kwargs)


# This function has not been decorated as the above three, so it will not be
# part of this service's RESTful API.
def delete(*pargs, **kwargs):
    return "DELETE: " + " ".join(pargs) + "  %s" % (kwargs)


# And here is an example of an unusual HTTP method.
@tangelo.restful
def propfind(*pargs, **kwargs):
    return "PROPFIND: " + " ".join(pargs) + "  %s" % (kwargs)


# And one that isn't even a valid HTTP method.
@tangelo.restful
def dukat(*pargs, **kwargs):
    return "DUKAT: " + " ".join(pargs) + "  %s" % (kwargs)

########NEW FILE########
__FILENAME__ = testapp
# A test Tangelo application.


def run(year, month, day, **kwargs):
    # Create a response dictionary.
    response = {}

    # Fill it with the positional arguments (i.e. URL path components),
    # which are supposed to be a date.
    try:
        response['year'] = int(year)
    except ValueError:
        response['year'] = 'bad year given'

    try:
        response['month'] = int(month)
    except ValueError:
        response['year'] = 'bad month given'

    try:
        response['day'] = int(day)
    except ValueError:
        response['year'] = 'bad day given'

    # Fill it with the remainder of the arguments, which must be sent in as
    # keyword arguments (i.e. as URL-encoded parameters).
    for k in kwargs:
        response[k] = kwargs[k]

    return str(response)

########NEW FILE########
__FILENAME__ = get_free_port
import tangelo.util


class Tester(unittest.TestCase):
    def test_get_free_port(self):
        result = True

        for i in xrange(100):
            port = tangelo.util.get_free_port()
            # TODO: detect whether port is really free?
            print "Got free port: %d" % (port)

            result = result and (port > 1024)

        self.assertTrue(result)

########NEW FILE########
__FILENAME__ = tangelo-types
import bson.json_util
import json

import tangelo


class Tester(unittest.TestCase):
    def test_tangelo_types_numeric(self):
        """
        Demonstrate the correct usage of @tangelo.types.
        """

        def op(a, b, c=None, d=None):
            return a + b + c + d

        @tangelo.types(int, float, c=int, d=float)
        def op_typed(a, b, c=None, d=None):
            return op(a, b, c, d)

        self.assertEqual(op("1", "2", c="3", d="4"), "1234")
        self.assertEqual(op_typed("1", "2", c="3", d="4"), 10.0)

    def test_tangelo_types_json(self):
        """
        Demonstrate that @tangelo.types works with any non-base-type conversion functions.
        """

        @tangelo.types(json.loads)
        def extract_foo(data):
            return data["foo"]

        json_text = json.dumps({"foo": "bar",
                                "baz": "quux"})

        self.assertEqual(extract_foo(json_text), "bar")

    def test_tangelo_types_bson(self):
        """
        Demonstrate that @tangelo.types works with functions in modules not
        imported by Tangelo itself.
        """

        @tangelo.types(bson.json_util.loads)
        def extract_foo(data):
            return data["foo"]

        json_text = json.dumps({"foo": "bar",
                                "baz": "quux"})

        self.assertEqual(extract_foo(json_text), "bar")

    def test_tangelo_types_bad_conversion(self):
        """
        Demonstrate the failure mode when a value cannot be converted.
        """

        @tangelo.types(int)
        def identity(x):
            return x

        result = identity("3.2")

        self.assertTrue(isinstance(result, tangelo.HTTPStatusCode))
        self.assertEqual(result.code, "400 Input Value Conversion Failed")
        self.assertEqual(result.msg, "invalid literal for int() with base 10: '3.2'")

    def test_return_type(self):
        """
        Demonstrate the use of the tangelo.return_type() decorator.
        """

        def excite(data):
            return json.dumps(data) + "!!!"

        @tangelo.return_type(excite)
        def dump(data):
            data["foo"] = "bar"
            return data

        test_data = {"bar": "baz"}
        result = dump(test_data)

        self.assertEqual(result, json.dumps(test_data) + "!!!")

    def test_return_type_bad_conversion(self):
        msg = "this is a bad converter function"

        def bad_converter(x):
            raise ValueError(msg)

        @tangelo.return_type(bad_converter)
        def dump(data):
            return data

        result = dump({})

        self.assertTrue(isinstance(result, tangelo.HTTPStatusCode))
        self.assertEqual(result.code, "500 Return Value Conversion Failed")
        self.assertEqual(result.msg, msg)

########NEW FILE########
