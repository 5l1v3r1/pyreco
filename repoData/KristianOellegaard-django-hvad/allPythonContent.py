__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Project 何 documentation build configuration file, created by
# sphinx-quickstart on Tue Feb 15 11:19:28 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.

sys.path.extend((
    os.path.abspath(os.path.join(os.path.dirname(__file__), '_ext')),
))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.intersphinx', 'djangodocs']
intersphinx_mapping = {
    'python': ('http://docs.python.org/2.7', None),
    'django': ('http://readthedocs.org/docs/django/en/latest/', None),
}

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'django-hvad'
copyright = u'2011-2014, Kristian Øllegaard, Jonas Obrist & contributors'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.5.0'
# The full version, including alpha/beta/rc tags.
release = '0.5.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'trac'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
html_theme_options = {
    'externalrefs': True,
}

html_style = 'stylesheet.css'

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
html_sidebars = {'**': ['globaltoc.html', 'relations.html', 'sourcelink.html', 'searchbox.html']}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
html_show_sourcelink = False

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Projectdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Project.tex', u'Django Hvad Documentation',
   u'Jonas Obrist & contributors', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'project', u'Django Hvad Documentation',
     [u'Kristian Øllegaard, Jonas Obrist & contributors'], 1)
]

########NEW FILE########
__FILENAME__ = djangodocs
# Sphinx helper for Django-specific references

def setup(app):
    app.add_crossref_type(
        directivename = "label",
        rolename = "djterm",
        indextemplate = "pair: %s; label",
    )
    app.add_crossref_type(
        directivename = "setting",
        rolename = "setting",
        indextemplate = "pair: %s; setting",
    )
    app.add_crossref_type(
        directivename = "templatetag",
        rolename = "ttag",
        indextemplate = "pair: %s; template tag",
    )
    app.add_crossref_type(
        directivename = "templatefilter",
        rolename = "tfilter",
        indextemplate = "pair: %s; template filter",
    )
    app.add_crossref_type(
        directivename = "fieldlookup",
        rolename = "lookup",
        indextemplate = "pair: %s; field lookup type",
    )

########NEW FILE########
__FILENAME__ = admin
import functools
import django
from django.conf import settings
from django.contrib.admin.options import ModelAdmin, csrf_protect_m, InlineModelAdmin
if django.VERSION >= (1, 7):
    from django.contrib.admin.utils import (flatten_fieldsets, unquote,
        get_deleted_objects)
else:
    from django.contrib.admin.util import (flatten_fieldsets, unquote,
        get_deleted_objects)
from django.contrib.contenttypes.models import ContentType
from django.core.exceptions import PermissionDenied
from django.core.urlresolvers import reverse
from django.db import router, transaction
from django.forms.models import model_to_dict
if django.VERSION >= (1, 7):
    from django.forms.utils import ErrorList
else:
    from django.forms.util import ErrorList
from django.http import Http404, HttpResponseRedirect
from django.shortcuts import render_to_response
from django.template import TemplateDoesNotExist
from django.template.context import RequestContext
from django.template.loader import find_template
from django.utils.encoding import iri_to_uri
from django.utils.functional import curry
from django.utils.translation import ugettext_lazy as _, get_language
from functools import update_wrapper
from hvad.compat.force_unicode import force_unicode
from hvad.compat.urls import urlencode
from hvad.forms import TranslatableModelForm, translatable_inlineformset_factory, translatable_modelform_factory
from hvad.utils import get_cached_translation, get_translation
from hvad.manager import FALLBACK_LANGUAGES


atomic = (transaction.atomic if django.VERSION >= (1, 6) else
          transaction.commit_on_success)


def get_language_name(language_code):
    return dict(settings.LANGUAGES).get(language_code, language_code)

class InlineModelForm(TranslatableModelForm):
    def __init__(self, data=None, files=None, auto_id='id_%s', prefix=None,
                 initial=None, error_class=ErrorList, label_suffix=':',
                 empty_permitted=False, instance=None):
        """

        """
        opts = self._meta
        model_opts = opts.model._meta
        object_data = {}
        language = getattr(self, 'language', get_language())
        if instance is not None:
            trans = get_cached_translation(instance)
            if not trans or trans.language_code != language:
                try:
                    trans = get_translation(instance, language)
                except model_opts.translations_model.DoesNotExist:
                    trans = None
            if trans:
                object_data = model_to_dict(trans, opts.fields, opts.exclude)
                # Dirty hack that swaps the id from the translation id, to the master id
                # This is necessary, because we in this case get the untranslated instance,
                # and thereafter get the correct translation on save.
                if "id" in object_data:
                    object_data["id"] = trans.master.id
        if initial is not None:
            object_data.update(initial)
        initial = object_data
        super(TranslatableModelForm, self).__init__(data, files, auto_id,
                                                     prefix, initial,
                                                     error_class, label_suffix,
                                                     empty_permitted, instance)


class TranslatableModelAdminMixin(object):
    query_language_key = 'language'

    def all_translations(self, obj):
        """
        use this to display all languages the object has been translated to
        in the changelist view:

        class MyAdmin(admin.ModelAdmin):
            list_display = ('__str__', 'all_translations',)

        """
        if obj and obj.pk:
            languages = []
            current_language = get_language()
            for language in obj.get_available_languages():
                entry = '<a href="%s">%s</a>' % (self.get_url(obj, lang=language), language)
                if language == current_language:
                    entry = u'<strong>%s</strong>' % entry
                languages.append(entry)
            return u', '.join(languages)
        else:
            return ''
    all_translations.allow_tags = True
    all_translations.short_description = _('all translations')

    def get_available_languages(self, obj):
        if obj:
            return obj.get_available_languages()
        else:
            return []

    def get_language_tabs(self, request, available_languages):
        tabs = []
        get = dict(request.GET)
        language = self._language(request)
        for key, name in settings.LANGUAGES:
            get.update({'language': key})
            url = '%s?%s' % (request.path, urlencode(get))
            if language == key:
                status = 'current'
            elif key in available_languages:
                status = 'available'
            else:
                status = 'empty'
            tabs.append((url, name, key, status))
        return tabs

    def _language(self, request):
        return request.GET.get(self.query_language_key, get_language())


class TranslatableAdmin(ModelAdmin, TranslatableModelAdminMixin):
    form = TranslatableModelForm
    
    change_form_template = 'admin/hvad/change_form.html'
    
    deletion_not_allowed_template = 'admin/hvad/deletion_not_allowed.html'
    
    def __init__(self, *args, **kwargs):
        super(TranslatableAdmin, self).__init__(*args, **kwargs)
        self.reverse = functools.partial(reverse, current_app=self.admin_site.name)


    def get_url(self, obj, lang=None, get={}):
        ct = ContentType.objects.get_for_model(self.model)
        info = ct.app_label, ct.model
        if lang:
            get.update({self.query_language_key: lang})
        url = '%s?%s' % (self.reverse('admin:%s_%s_change' % info, args=(obj.id,)), urlencode(get))
        return url


    def get_urls(self):
        try:
            from django.conf.urls import patterns, url
        except ImportError:
            from django.conf.urls.defaults import patterns, url            
        
        urlpatterns = super(TranslatableAdmin, self).get_urls()

        def wrap(view):
            def wrapper(*args, **kwargs):
                return self.admin_site.admin_view(view)(*args, **kwargs)
            return update_wrapper(wrapper, view)

        if django.VERSION >= (1, 6):
            info = self.model._meta.app_label, self.model._meta.model_name
        else:
            info = self.model._meta.app_label, self.model._meta.module_name

        urlpatterns = patterns('',
            url(r'^(.+)/delete-translation/(.+)/$',
                wrap(self.delete_translation),
                name='%s_%s_delete_translation' % info),
        ) + urlpatterns
        return urlpatterns
    
    def get_form(self, request, obj=None, **kwargs):
        """
        Returns a Form class for use in the admin add view. This is used by
        add_view and change_view.
        """
        
        if django.VERSION >= (1, 6):
            # From v1.6 on, using get_fieldsets is ok, as long as no 'fields'
            # argument was given. It allows dynamic fieldsets on admin form.
            if 'fields' in kwargs:
                fields = kwargs.pop('fields')
            else:
                fields = flatten_fieldsets(self.get_fieldsets(request, obj))
        else:
            # On previous versions, calling get_fieldsets triggers infinite recursion
            # and we should stick to statically declared fieldsets
            if self.declared_fieldsets:
                fields = flatten_fieldsets(self.declared_fieldsets)
            else:
                fields = None
        if self.exclude is None:
            exclude = []
        else:
            exclude = list(self.exclude)
        exclude.extend(kwargs.get("exclude", []))
        exclude.extend(self.get_readonly_fields(request, obj))
        # Exclude language_code, adding it again to the instance is done by
        # the LanguageAwareCleanMixin (see translatable_modelform_factory)
        exclude.append('language_code')
        old_formfield_callback = curry(self.formfield_for_dbfield, 
                                       request=request)
        defaults = {
            "form": self.form,
            "fields": fields,
            "exclude": exclude,
            "formfield_callback": old_formfield_callback,
        }
        defaults.update(kwargs)
        language = self._language(request)
        return translatable_modelform_factory(language, self.model, **defaults)
    

    
    def render_change_form(self, request, context, add=False, change=False,
                           form_url='', obj=None):
        lang_code = self._language(request)
        lang = get_language_name(lang_code)
        available_languages = self.get_available_languages(obj)
        context['title'] = '%s (%s)' % (context['title'], lang)
        context['current_is_translated'] = lang_code in available_languages
        context['allow_deletion'] = len(available_languages) > 1
        context['language_tabs'] = self.get_language_tabs(request, available_languages)
        context['base_template'] = self.get_change_form_base_template()
        return super(TranslatableAdmin, self).render_change_form(request,
                                                                  context,
                                                                  add, change,
                                                                  form_url, obj)
        
    def response_change(self, request, obj):
        redirect = super(TranslatableAdmin, self).response_change(request, obj)
        uri = iri_to_uri(request.path)
        if django.VERSION >= (1, 6):
            app_label, model_name = self.model._meta.app_label, self.model._meta.model_name
        else:
            app_label, model_name = self.model._meta.app_label, self.model._meta.module_name
        if redirect['Location'] in (uri, "../add/", self.reverse('admin:%s_%s_add' % (app_label, model_name))):
            if self.query_language_key in request.GET:
                redirect['Location'] = '%s?%s=%s' % (redirect['Location'],
                    self.query_language_key, request.GET[self.query_language_key])
        return redirect
    
    @csrf_protect_m
    @atomic
    def delete_translation(self, request, object_id, language_code):
        "The 'delete translation' admin view for this model."
        opts = self.model._meta
        app_label = opts.app_label
        translations_model = opts.translations_model
        
        try:
            obj = translations_model.objects.select_related('maser').get(
                                                master__pk=unquote(object_id),
                                                language_code=language_code)
        except translations_model.DoesNotExist:
            raise Http404

        if not self.has_delete_permission(request, obj):
            raise PermissionDenied
        
        if len(self.get_available_languages(obj.master)) <= 1:
            return self.deletion_not_allowed(request, obj, language_code)

        using = router.db_for_write(translations_model)

        # Populate deleted_objects, a data structure of all related objects that
        # will also be deleted.
        
        protected = False
        deleted_objects, perms_needed, protected = get_deleted_objects(
            [obj], translations_model._meta, request.user, self.admin_site, using)
        
        lang = get_language_name(language_code) 
            

        if request.POST: # The user has already confirmed the deletion.
            if perms_needed:
                raise PermissionDenied
            obj_display = '%s translation of %s' % (lang, force_unicode(obj.master))
            self.log_deletion(request, obj, obj_display)
            self.delete_model_translation(request, obj)

            self.message_user(request,
                _('The %(name)s "%(obj)s" was deleted successfully.') % {
                    'name': force_unicode(opts.verbose_name),
                    'obj': force_unicode(obj_display)
                }
            )

            if not self.has_change_permission(request, None):
                return HttpResponseRedirect(self.reverse('admin:index'))
            model_name = opts.model_name if django.VERSION >= (1, 6) else opts.module_name
            return HttpResponseRedirect(self.reverse('admin:%s_%s_changelist' % (opts.app_label, model_name)))

        object_name = '%s Translation' % force_unicode(opts.verbose_name)

        if perms_needed or protected:
            title = _("Cannot delete %(name)s") % {"name": object_name}
        else:
            title = _("Are you sure?")

        context = {
            "title": title,
            "object_name": object_name,
            "object": obj,
            "deleted_objects": deleted_objects,
            "perms_lacking": perms_needed,
            "protected": protected,
            "opts": opts,
            "app_label": app_label,
        }

        # in django > 1.4 root_path is removed
        if hasattr(self.admin_site, 'root_path'):
            context.update({"root_path": self.admin_site.root_path})

        return render_to_response(self.delete_confirmation_template or [
            "admin/%s/%s/delete_confirmation.html" % (app_label, opts.object_name.lower()),
            "admin/%s/delete_confirmation.html" % app_label,
            "admin/delete_confirmation.html"
        ], context, RequestContext(request))
    
    def deletion_not_allowed(self, request, obj, language_code):
        opts = self.model._meta
        app_label = opts.app_label
        object_name = force_unicode(opts.verbose_name)
        
        context = RequestContext(request)
        context['object'] = obj.master
        context['language_code'] = language_code
        context['opts'] = opts
        context['app_label'] = app_label
        context['language_name'] = get_language_name(language_code)
        context['object_name'] = object_name
        return render_to_response(self.deletion_not_allowed_template, context)
        
    def delete_model_translation(self, request, obj):
        obj.delete()
    
    def get_object(self, request, object_id):
        obj = super(TranslatableAdmin, self).get_object(request, object_id)
        if obj is None: # object was not in queryset, bail out
            return None

        # object was in queryset - need to make sure we got the right translation
        # we use getattr to trigger a load if instance exists but translation was
        # not cached yet. Should not happen with current code, but is correct,
        # future-proof behavior.
        language_code = getattr(obj, 'language_code', None)
        request_lang = self._language(request)
        if language_code is None or language_code != request_lang:
            # if language does not match that of request, we know request_lang
            # does not exist, because it was the first language in the use_fallbacks
            # list. We prepare it as a new translation.
            obj.translate(request_lang)
        return obj

    def get_queryset(self, request):
        language = self._language(request)
        languages = [language,]
        for lang in FALLBACK_LANGUAGES:
            if not lang in languages:
                languages.append(lang)
        qs = self.model._default_manager.untranslated().use_fallbacks(*languages)
        # TODO: this should be handled by some parameter to the ChangeList.
        ordering = getattr(self, 'ordering', None) or () # otherwise we might try to *None, which is bad ;)
        if ordering:
            qs = qs.order_by(*ordering)
        return qs
    if django.VERSION < (1, 8):
        queryset = get_queryset

    def get_change_form_base_template(self):
        opts = self.model._meta
        app_label = opts.app_label
        search_templates = [
            "admin/%s/%s/change_form.html" % (app_label, opts.object_name.lower()),
            "admin/%s/change_form.html" % app_label,
            "admin/change_form.html"
        ]
        for template in search_templates:
            try:
                find_template(template)
                return template
            except TemplateDoesNotExist:
                pass
        else: # pragma: no cover
            pass

class TranslatableInlineModelAdmin(InlineModelAdmin, TranslatableModelAdminMixin):
    form = InlineModelForm

    change_form_template = 'admin/hvad/change_form.html'

    deletion_not_allowed_template = 'admin/hvad/deletion_not_allowed.html'

    def get_formset(self, request, obj=None, **kwargs):
        """Returns a BaseInlineFormSet class for use in admin add/change views."""
        if django.VERSION >= (1, 6):
            # From v1.6 on, using get_fieldsets is ok, as long as no 'fields'
            # argument was given. It allows dynamic fieldsets on admin form.
            if 'fields' in kwargs:
                fields = kwargs.pop('fields')
            else:
                fields = flatten_fieldsets(self.get_fieldsets(request, obj))
        else:
            # On previous versions, calling get_fieldsets triggers infinite recursion
            # and we should stick to statically declared fieldsets
            if self.declared_fieldsets:
                fields = flatten_fieldsets(self.declared_fieldsets)
            else:
                fields = None
        if self.exclude is None:
            exclude = []
        else:
            exclude = list(self.exclude)
        exclude.extend(kwargs.get("exclude", []))
        exclude.extend(self.get_readonly_fields(request, obj))
        # if exclude is an empty list we use None, since that's the actual
        # default
        exclude = exclude or None
        defaults = {
            "form": self.get_form(request, obj, fields=fields),
            #"formset": self.formset,
            "fk_name": self.fk_name,
            "fields": fields,
            "exclude": exclude,
            "formfield_callback": curry(self.formfield_for_dbfield, request=request),
            "extra": self.extra,
            "max_num": self.max_num,
            "can_delete": self.can_delete,
        }
        defaults.update(kwargs)
        language = self._language(request)
        return translatable_inlineformset_factory(language, self.parent_model, self.model, **defaults)

    def get_urls(self):
        from django.conf.urls.defaults import patterns, url

        urlpatterns = super(InlineModelAdmin, self).get_urls()

        def wrap(view):
            def wrapper(*args, **kwargs):
                return self.admin_site.admin_view(view)(*args, **kwargs)
            return update_wrapper(wrapper, view)

        info = self.model._meta.app_label, self.model._meta.module_name

        urlpatterns = patterns('',
            url(r'^(.+)/delete-translation/(.+)/$',
                wrap(self.delete_translation),
                name='%s_%s_delete_translation' % info),
        ) + urlpatterns
        return urlpatterns

    def get_form(self, request, obj=None, **kwargs):
        """
        Returns a Form class for use in the admin add view. This is used by
        add_view and change_view.
        """
        if django.VERSION >= (1, 6):
            # From v1.6 on, using get_fieldsets is ok, as long as no 'fields'
            # argument was given. It allows dynamic fieldsets on admin form.
            if 'fields' in kwargs:
                fields = kwargs.pop('fields')
            else:
                fields = flatten_fieldsets(self.get_fieldsets(request, obj))
        else:
            # On previous versions, calling get_fieldsets triggers infinite recursion
            # and we should stick to statically declared fieldsets
            if self.declared_fieldsets:
                fields = flatten_fieldsets(self.declared_fieldsets)
            else:
                fields = None
        if self.exclude is None:
            exclude = []
        else:
            exclude = list(self.exclude)
        exclude.extend(kwargs.get("exclude", []))
        exclude.extend(self.get_readonly_fields(request, obj))
        # Exclude language_code, adding it again to the instance is done by
        # the LanguageAwareCleanMixin (see translatable_modelform_factory)
        exclude.append('language_code')
        old_formfield_callback = curry(self.formfield_for_dbfield,
                                       request=request)
        defaults = {
            "form": self.form,
            "fields": fields,
            "exclude": exclude,
            "formfield_callback": old_formfield_callback,
        }
        defaults.update(kwargs)
        language = self._language(request)
        return translatable_modelform_factory(language, self.model, **defaults)

    def response_change(self, request, obj):
        redirect = super(TranslatableAdmin, self).response_change(request, obj)
        uri = iri_to_uri(request.path)
        if redirect['Location'] in (uri, "../add/"):
            if self.query_language_key in request.GET:
                redirect['Location'] = '%s?%s=%s' % (redirect['Location'],
                    self.query_language_key, request.GET[self.query_language_key])
        return redirect

    """
# Should be added
    @csrf_protect_m
    @atomic
    def delete_translation(self, request, object_id, language_code):
        "The 'delete translation' admin view for this model."
        opts = self.model._meta
        app_label = opts.app_label
        translations_model = opts.translations_model

        try:
            obj = translations_model.objects.select_related('maser').get(
                                                master__pk=unquote(object_id),
                                                language_code=language_code)
        except translations_model.DoesNotExist:
            raise Http404

        if not self.has_delete_permission(request, obj):
            raise PermissionDenied

        if len(self.get_available_languages(obj.master)) <= 1:
            return self.deletion_not_allowed(request, obj, language_code)

        using = router.db_for_write(translations_model)

        # Populate deleted_objects, a data structure of all related objects that
        # will also be deleted.

        protected = False
        if NEW_GET_DELETE_OBJECTS:
            (deleted_objects, perms_needed, protected) = get_deleted_objects(
                [obj], translations_model._meta, request.user, self.admin_site, using)
        else: # pragma: no cover
            (deleted_objects, perms_needed) = get_deleted_objects(
                [obj], translations_model._meta, request.user, self.admin_site)


        lang = get_language_name(language_code)


        if request.POST: # The user has already confirmed the deletion.
            if perms_needed:
                raise PermissionDenied
            obj_display = '%s translation of %s' % (lang, force_unicode(obj.master))
            self.log_deletion(request, obj, obj_display)
            self.delete_model_translation(request, obj)

            self.message_user(request,
                _('The %(name)s "%(obj)s" was deleted successfully.') % {
                    'name': force_unicode(opts.verbose_name),
                    'obj': force_unicode(obj_display)
                }
            )

            if not self.has_change_permission(request, None):
                return HttpResponseRedirect(reverse('admin:index'))
            return HttpResponseRedirect(reverse('admin:%s_%s_changelist' % (opts.app_label, opts.module_name)))

        object_name = '%s Translation' % force_unicode(opts.verbose_name)

        if perms_needed or protected:
            title = _("Cannot delete %(name)s") % {"name": object_name}
        else:
            title = _("Are you sure?")

        context = {
            "title": title,
            "object_name": object_name,
            "object": obj,
            "deleted_objects": deleted_objects,
            "perms_lacking": perms_needed,
            "protected": protected,
            "opts": opts,
            "root_path": self.admin_site.root_path,
            "app_label": app_label,
        }

        return render_to_response(self.delete_confirmation_template or [
            "admin/%s/%s/delete_confirmation.html" % (app_label, opts.object_name.lower()),
            "admin/%s/delete_confirmation.html" % app_label,
            "admin/delete_confirmation.html"
        ], context, RequestContext(request))

    def deletion_not_allowed(self, request, obj, language_code):
        opts = self.model._meta
        app_label = opts.app_label
        object_name = force_unicode(opts.verbose_name)

        context = RequestContext(request)
        context['object'] = obj.master
        context['language_code'] = language_code
        context['opts'] = opts
        context['app_label'] = app_label
        context['language_name'] = get_language_name(language_code)
        context['object_name'] = object_name
        return render_to_response(self.deletion_not_allowed_template, context)

    def delete_model_translation(self, request, obj):
        obj.delete()
    """
    def get_queryset(self, request):
        language = self._language(request)
        qs = self.model._default_manager.all()#.language(language)
        # TODO: this should be handled by some parameter to the ChangeList.
        ordering = getattr(self, 'ordering', None) or () # otherwise we might try to *None, which is bad ;)
        if ordering:
            qs = qs.order_by(*ordering)
        return qs
    if django.VERSION < (1, 8):
        queryset = get_queryset

class TranslatableStackedInline(TranslatableInlineModelAdmin):
    template = 'admin/hvad/edit_inline/stacked.html'

class TranslatableTabularInline(TranslatableInlineModelAdmin):
    template = 'admin/hvad/edit_inline/tabular.html'

########NEW FILE########
__FILENAME__ = force_unicode
# -*- coding: utf-8 -*-
try:
    from django.utils.encoding import force_unicode
except ImportError:
    def force_unicode(s):
        return str(s)

########NEW FILE########
__FILENAME__ = metaclasses
# -*- coding: utf-8 -*-

def with_metaclass(meta, *bases):
    class metaclass(meta):
        __call__ = type.__call__
        __init__ = type.__init__
        def __new__(cls, name, this_bases, d):
            if this_bases is None:
                return type.__new__(cls, name, (), d)
            return meta(name, bases, d)
    return metaclass('temporary_class', None, {})

########NEW FILE########
__FILENAME__ = method_type
# -*- coding: utf-8 -*-
import sys
from types import MethodType as OriginalMethodType

if sys.version_info[0] == 2:
    def MethodType(function, instance):
        return OriginalMethodType(function, instance, instance.__class__)
else:
    MethodType = OriginalMethodType

########NEW FILE########
__FILENAME__ = settings
import django
if django.VERSION >= (1, 4):
    from django.test.signals import setting_changed
    def settings_updater(func):
        func()
        setting_changed.connect(func, dispatch_uid=id(func))
        return func

else:
    def settings_updater(func):
        func()
        return func

########NEW FILE########
__FILENAME__ = string_io
# -*- coding: utf-8 -*-
try:
    from io import StringIO # python 3
except ImportError:
    from StringIO import StringIO # python 2

########NEW FILE########
__FILENAME__ = string_types
# -*- coding: utf-8 -*-
import sys
PY2 = sys.version_info[0] == 2

if not PY2:
    string_types = (str,)
else:
    string_types = (str, unicode)

########NEW FILE########
__FILENAME__ = urls
# -*- coding: utf-8 -*-
try:
    from urllib import urlencode
    from urlparse import urlparse
    from urllib import unquote
except ImportError:
    from urllib.parse import urlencode, urlparse, unquote

########NEW FILE########
__FILENAME__ = descriptors
import django
from django.utils.translation import get_language
from hvad.utils import get_translation
if django.VERSION >= (1, 7):
    from django.apps import registry

class BaseDescriptor(object):
    """
    Base descriptor class with a helper to get the translations instance.
    """
    def __init__(self, opts):
        self.opts = opts
        self._NoTranslationError = type('NoTranslationError',
                                        (AttributeError, opts.translations_model.DoesNotExist),
                                        {})
    
    def translation(self, instance):
        cached = getattr(instance, self.opts.translations_cache, None)
        if cached is None:
            try:
                cached = get_translation(instance)
            except self.opts.translations_model.DoesNotExist:
                raise self._NoTranslationError('Accessing a translated field requires that '
                                               'the instance has a translation loaded, or a '
                                               'valid translation in current language (%s) '
                                               'loadable from the database' % get_language())
            setattr(instance, self.opts.translations_cache, cached)
        return cached


class TranslatedAttribute(BaseDescriptor):
    """
    Basic translated attribute descriptor.
    
    Proxies attributes from the shared instance to the translated instance.
    """
    def __init__(self, opts, name):
        self.name = name
        super(TranslatedAttribute, self).__init__(opts)
        
    def __get__(self, instance, instance_type=None):
        if not instance:
            if django.VERSION >= (1, 7) and not registry.apps.ready:
                raise AttributeError('Attribute not available until registry is ready.')
            # Don't raise an attribute error so we can use it in admin.
            return self.opts.translations_model._meta.get_field_by_name(
                                                    self.name)[0].default
        return getattr(self.translation(instance), self.name)
    
    def __set__(self, instance, value):
        setattr(self.translation(instance), self.name, value)
    
    def __delete__(self, instance):
        delattr(self.translation(instance), self.name)


class LanguageCodeAttribute(TranslatedAttribute):
    """
    The language_code attribute is different from other attribtues as it cannot
    be deleted. Trying to do so will always cause an attribute error.
    
    """
    def __init__(self, opts):
        super(LanguageCodeAttribute, self).__init__(opts, 'language_code')
    
    def __set__(self, instance, value):
        raise AttributeError("The 'language_code' attribute cannot be " +\
                    "changed directly! Use the translate() method instead.")
    
    def __delete__(self, instance):
        raise AttributeError("The 'language_code' attribute cannot be deleted!")
########NEW FILE########
__FILENAME__ = exceptions
from django.db.models.fields import FieldDoesNotExist

class WrongManager(Exception): pass
########NEW FILE########
__FILENAME__ = fieldtranslator
from django.db.models.sql.constants import QUERY_TERMS

TRANSLATIONS = 1
TRANSLATED = 2
NORMAL = 3


MODEL_INFO = {}


def _build_model_info(model):
    """
    Builds the model information dictinary for get_model_info
    """
    from hvad.models import BaseTranslationModel, TranslatableModel
    info = {}
    if issubclass(model, BaseTranslationModel):
        info['type'] = TRANSLATIONS
        info['shared'] = model._meta.shared_model._meta.get_all_field_names() + ['pk']
        info['translated'] = model._meta.get_all_field_names()
    elif issubclass(model, TranslatableModel):
        info['type'] = TRANSLATED
        info['shared'] = model._meta.get_all_field_names() + ['pk']
        info['translated'] = model._meta.translations_model._meta.get_all_field_names()
    else:
        info['type'] = NORMAL
        info['shared'] = model._meta.get_all_field_names() + ['pk']
        info['translated'] = []
    if 'id' in info['translated']:
        info['translated'].remove('id')
    return info

def get_model_info(model):
    """
    Returns a dictionary with 'translated' and 'shared' as keys, and a list of
    respective field names as values. Also has a key 'type' which is either 
    TRANSLATIONS, TRANSLATED or NORMAL
    """
    if model not in MODEL_INFO:
        MODEL_INFO[model] = _build_model_info(model)
    return MODEL_INFO[model]

def _get_model_from_field(starting_model, fieldname):
    field, model, direct, _ = starting_model._meta.get_field_by_name(fieldname)
    if direct and field.rel:        # field is on model, and is a relationship, follow it
        return field.rel.to
    elif direct and not field.rel:  # field is on model, and is not a relationship, stay there
        return starting_model
    else:                           # field it not on model, it is a related model pointing here, go there
        return field.model

def translate(querykey, starting_model):
    """
    Translates a querykey starting from a given model to be 'translation aware'.
    """
    bits = querykey.split('__')
    translated_bits = []
    model = starting_model
    language_joins = []
    max_index = len(bits) - 1
    # iterate over the bits
    for index, bit in enumerate(bits):
        model_info = get_model_info(model)
        # if the bit is a QUERY_TERM, just append it to the translated_bits
        if bit in QUERY_TERMS:
            translated_bits.append(bit)
        # same goes for 'normal model' bits
        elif model_info['type'] == NORMAL:
            translated_bits.append(bit)
        # if the bit is on a translated model, check if it's in translated
        # translated or untranslated fields. If it's in translated, inject a
        # lookup via the translations accessor. Also add a language join on this
        # table.
        elif model_info['type'] == TRANSLATED:
            if bit in model_info['translated']:
                translated_bits.append(model._meta.translations_accessor)
                path = '__'.join(translated_bits)
                # ignore the first model, since it should already enforce a
                # language
                if index != 0:
                    language_joins.append('%s__language_code' % path)
                translated_bits.append(bit)
            else:
                path = '__'.join(translated_bits + [model._meta.translations_accessor])
                # ignore the first model, since it should already enforce a
                # language
                if index != 0:
                    language_joins.append('%s__language_code' % path)
                translated_bits.append(bit)
        # else (if it's a translations table), inject a 'master' if the field is
        # untranslated and add language joins.
        else:
            if bit in model_info['translated']:
                translated_bits.append(bit)
            else:
                path = '__'.join(translated_bits)
                # ignore the first model, since it should already enforce a
                # language
                if index != 0:
                    language_joins.append('%s__language_code' % path)
                translated_bits.append('master')
                translated_bits.append(bit)
        # do we really want to get the next model? Is there a next model?
        if index < max_index:
            next = bits[index + 1]
            if next not in QUERY_TERMS:
                model = _get_model_from_field(model, bit)
    return '__'.join(translated_bits), language_joins

########NEW FILE########
__FILENAME__ = forms
import django
from django.conf import settings
from django.core.exceptions import FieldError, ValidationError
from django.forms.fields import CharField
from django.forms.forms import get_declared_fields
from django.forms.formsets import formset_factory
from django.forms.models import (ModelForm, ModelFormMetaclass, ModelFormOptions, 
    fields_for_model, model_to_dict, construct_instance, BaseInlineFormSet, BaseModelFormSet,
    inlineformset_factory)
if django.VERSION >= (1, 7):
    from django.forms.utils import ErrorList
else:
    from django.forms.util import ErrorList
from django.forms.widgets import Select, media_property
from django.utils.translation import get_language, ugettext as _
from hvad.compat.metaclasses import with_metaclass
from hvad.models import TranslatableModel, BaseTranslationModel
from hvad.utils import get_cached_translation, get_translation, combine


class TranslatableModelFormMetaclass(ModelFormMetaclass):
    def __new__(cls, name, bases, attrs):
        
        """
        Django 1.3 fix, that removes all Meta.fields and Meta.exclude
        fieldnames that are in the translatable model. This ensures
        that the superclass' init method doesnt throw a validation
        error
        """
        fields = []
        exclude = []
        fieldsets = []
        if "Meta" in attrs:
            meta = attrs["Meta"]
            if getattr(meta, "fieldsets", False):
                fieldsets = meta.fieldsets
                meta.fieldsets = []
            if getattr(meta, "fields", False):
                fields = meta.fields
                meta.fields = []
            if getattr(meta, "exclude", False):
                exclude = meta.exclude
                meta.exclude = []
        # End 1.3 fix
        
        super_new = super(TranslatableModelFormMetaclass, cls).__new__
        
        formfield_callback = attrs.pop('formfield_callback', None)
        declared_fields = get_declared_fields(bases, attrs, False)
        new_class = super_new(cls, name, bases, attrs)
        
        # Start 1.3 fix
        if fields:
            new_class.Meta.fields = fields
        if exclude:
            new_class.Meta.exclude = exclude
        if fieldsets:
            new_class.Meta.fieldsets = fieldsets
        # End 1.3 fix

        if not getattr(new_class, "Meta", None):
            class Meta:
                exclude = ['language_code']
            new_class.Meta = Meta
        elif not getattr(new_class.Meta, 'exclude', None):
            new_class.Meta.exclude = ['language_code']
        elif getattr(new_class.Meta, 'exclude', False):
            if 'language_code' not in new_class.Meta.exclude:
                new_class.Meta.exclude.append("language_code")

        if 'Media' not in attrs:
            new_class.media = media_property(new_class)
        opts = new_class._meta = ModelFormOptions(getattr(new_class, 'Meta', attrs.get('Meta', None)))
        if opts.model:
            # bail out if a wrong model uses this form class
            if not issubclass(opts.model, TranslatableModel):
                raise TypeError(
                    "Only TranslatableModel subclasses may use TranslatableModelForm"
                )
            mopts = opts.model._meta
            
            shared_fields = mopts.get_all_field_names()
            
            # split exclude and include fieldnames into shared and translated
            sfieldnames = [field for field in opts.fields or [] if field in shared_fields]
            tfieldnames = [field for field in opts.fields or [] if field not in shared_fields]
            sexclude = [field for field in opts.exclude or [] if field in shared_fields]
            texclude = [field for field in opts.exclude or [] if field not in shared_fields]
            
            # required by fields_for_model
            if not sfieldnames :
                sfieldnames = None if not fields else []
            if not tfieldnames:
                tfieldnames = None if not fields else []
            
            # If a model is defined, extract form fields from it.
            sfields = fields_for_model(opts.model, sfieldnames, sexclude,
                                       opts.widgets, formfield_callback)
            tfields = fields_for_model(mopts.translations_model, tfieldnames,
                                       texclude, opts.widgets, formfield_callback)
            
            fields = sfields
            fields.update(tfields)
            
            # make sure opts.fields doesn't specify an invalid field
            none_model_fields = [k for k, v in fields.items() if not v]
            missing_fields = set(none_model_fields) - \
                             set(declared_fields.keys())
            if missing_fields:
                message = 'Unknown field(s) (%s) specified for %s'
                message = message % (', '.join(missing_fields),
                                     opts.model.__name__)
                raise FieldError(message)
            # Override default model fields with any custom declared ones
            # (plus, include all the other declared fields).
            fields.update(declared_fields)
            
            if new_class._meta.exclude:
                new_class._meta.exclude = list(new_class._meta.exclude)
            else:
                new_class._meta.exclude = []
                
            for field in (mopts.translations_accessor, 'master'):
                if not field in new_class._meta.exclude:
                    new_class._meta.exclude.append(field)
        else:
            fields = declared_fields
        new_class.declared_fields = declared_fields
        new_class.base_fields = fields
        # always exclude the FKs
        return new_class


class TranslatableModelForm(with_metaclass(TranslatableModelFormMetaclass, ModelForm)):
    def __init__(self, data=None, files=None, auto_id='id_%s', prefix=None,
                 initial=None, error_class=ErrorList, label_suffix=':',
                 empty_permitted=False, instance=None):
        opts = self._meta
        model_opts = opts.model._meta
        object_data = {}
        language = getattr(self, 'language', get_language())
        if instance is not None:
            trans = get_cached_translation(instance)
            if not trans:
                try:
                    trans = get_translation(instance, language)
                except model_opts.translations_model.DoesNotExist:
                    trans = None
            if trans:
                object_data = model_to_dict(trans, opts.fields, opts.exclude)
        if initial is not None:
            object_data.update(initial)
        initial = object_data
        super(TranslatableModelForm, self).__init__(data, files, auto_id,
                                                     prefix, object_data,
                                                     error_class, label_suffix,
                                                     empty_permitted, instance)

    def save(self, commit=True):
        if self.instance.pk is None:
            fail_message = 'created'
            new = True
        else:
            fail_message = 'changed'
            new = False

        if self.errors:
            opts = self.instance._meta
            raise ValueError("The %s could not be %s because the data didn't"
                             " validate." % (opts.object_name, fail_message))

        trans_model = self.instance._meta.translations_model
        language_code = self.cleaned_data.get('language_code', get_language())

        if not new:
            trans = get_cached_translation(self.instance)
            if not trans or trans.language_code != language_code:
                try:
                    trans = get_translation(self.instance, language_code)
                except trans_model.DoesNotExist:
                    trans = trans_model()
        else:
            trans = trans_model()

        trans = construct_instance(self, trans, self._meta.fields)
        trans.language_code = language_code
        trans.master = self.instance
        self.instance = combine(trans, self.Meta.model)

        super(TranslatableModelForm, self).save(commit=commit)
        return self.instance
        
    def _post_clean(self):
        if self.instance.pk:
            try:
                # Don't use self.instance.language_code here! That will fail if
                # the instance is not translated into the current language. If
                # it succeeded, then the instance would already be translated,
                # and there'd be no point combining it with the same
                # translation again.
                trans = get_translation(self.instance, self.language)
                trans.master = self.instance
                self.instance = combine(trans, self.Meta.model)
            except self.instance._meta.translations_model.DoesNotExist:
                self.instance = self.instance.translate(self.language)
        return super(TranslatableModelForm, self)._post_clean()



class CleanMixin(object):
    def clean(self):
        data = super(CleanMixin, self).clean()
        data['language_code'] = self.language
        return data


def LanguageAwareCleanMixin(language):
    return type('BoundCleanMixin', (CleanMixin,), {'language': language})


def translatable_modelform_factory(language, model, form=TranslatableModelForm,
                                   fields=None, exclude=None,
                                   formfield_callback=None):
    # Create the inner Meta class. FIXME: ideally, we should be able to
    # construct a ModelForm without creating and passing in a temporary
    # inner class.

    # Build up a list of attributes that the Meta object will have.
    attrs = {'model': model}
    if fields is not None:
        attrs['fields'] = fields
    if exclude is not None:
        attrs['exclude'] = exclude

    # If parent form class already has an inner Meta, the Meta we're
    # creating needs to inherit from the parent's inner meta.
    parent = (object,)
    if hasattr(form, 'Meta'):
        parent = (form.Meta, object)
    Meta = type('Meta', parent, attrs)

    # Give this new form class a reasonable name.
    class_name = model.__name__ + 'Form'

    # Class attributes for the new form class.
    form_class_attrs = {
        'Meta': Meta,
        'formfield_callback': formfield_callback
    }
    clean_mixin = LanguageAwareCleanMixin(language)
    return type(class_name, (clean_mixin, form,), form_class_attrs)

def translatable_modelformset_factory(language, model, form=TranslatableModelForm, formfield_callback=None,
                         formset=BaseModelFormSet,
                         extra=1, can_delete=False, can_order=False,
                         max_num=None, fields=None, exclude=None):
    """
    Returns a FormSet class for the given Django model class.
    """
    form = translatable_modelform_factory(language, model, form=form, fields=fields, exclude=exclude,
                             formfield_callback=formfield_callback)
    FormSet = formset_factory(form, formset, extra=extra, max_num=max_num,
                              can_order=can_order, can_delete=can_delete)
    FormSet.model = model
    return FormSet

def translatable_inlineformset_factory(language, parent_model, model, form=TranslatableModelForm,
                          formset=BaseInlineFormSet, fk_name=None,
                          fields=None, exclude=None,
                          extra=3, can_order=False, can_delete=True, max_num=None,
                          formfield_callback=None):
    """
    Returns an ``InlineFormSet`` for the given kwargs.

    You must provide ``fk_name`` if ``model`` has more than one ``ForeignKey``
    to ``parent_model``.
    """
    from django.forms.models import _get_foreign_key
    fk = _get_foreign_key(parent_model, model, fk_name=fk_name)
    # enforce a max_num=1 when the foreign key to the parent model is unique.
    if fk.unique:
        max_num = 1
    kwargs = {
        'form': form,
        'formfield_callback': formfield_callback,
        'formset': formset,
        'extra': extra,
        'can_delete': can_delete,
        'can_order': can_order,
        'fields': fields,
        'exclude': exclude,
        'max_num': max_num,
    }
    FormSet = translatable_modelformset_factory(language, model, **kwargs)
    FormSet.fk = fk
    return FormSet


class BaseTranslationFormSet(BaseInlineFormSet):
    """A kind of inline formset for working with an instance's translations.
    It keeps track of the real object and combine()s it to the translations
    for validation and saving purposes.
    It can delete translations, but will refuse to delete the last one.
    """
    def __init__(self, *args, **kwargs):
        super(BaseTranslationFormSet, self).__init__(*args, **kwargs)
        self.queryset = self.order_translations(self.queryset)

    def order_translations(self, qs):
        return qs.order_by('language_code')

    def clean(self):
        super(BaseTranslationFormSet, self).clean()

        # Trigger combined instance validation
        master = self.instance
        stashed = get_cached_translation(master)

        for form in self.forms:
            form.instance.master = master
            combined = combine(form.instance, master.__class__)
            try:
                if django.VERSION >= (1, 6):
                    combined.full_clean(exclude=form._get_validation_exclusions(),
                                        validate_unique=form._validate_unique)
                else:
                    combined.full_clean(exclude=form._get_validation_exclusions())
            except ValidationError as e:
                form._update_errors(e)

        if stashed is None:
            delattr(master, master._meta.translations_cache)
        else:
            setattr(master, master._meta.translations_cache, stashed)

        # Validate that at least one translation exists
        forms_to_delete = self.deleted_forms
        valid = [((form.instance and form.instance.pk is not None) or
                  (form.is_valid() and form.has_changed()))
                 and not form in forms_to_delete for form in self.forms]
        if valid.count(True) < 1:
            raise ValidationError(_('At least one translation must be provided'),
                                  code='notranslation')

    def _save_translation(self, form, commit=True):
        obj = form.save(commit=False)
        assert isinstance(obj, BaseTranslationModel)

        if commit:
            # We need to trigger custom save actions on the combined model
            master = self.instance
            stashed = get_cached_translation(master)
            obj.master = master
            combined = combine(obj, master.__class__)
            combined.save()
            if hasattr(combined, 'save_m2m'):   # cannot happen, but feature
                combined.save_m2m()             # could be added, be ready
            if stashed is None:
                delattr(master, master._meta.translations_cache)
            else:
                setattr(master, master._meta.translations_cache, stashed)
        return obj

    def save_new(self, form, commit=True):
        return self._save_translation(form, commit)

    def save_existing(self, form, instance, commit=True):
        return self._save_translation(form, commit)

    def add_fields(self, form, index):
        super(BaseTranslationFormSet, self).add_fields(form, index)
        # Add the language code automagically
        if not 'language_code' in form.fields:
            form.fields['language_code'] = CharField(
                required=True, initial=form.instance.language_code,
                widget=Select(choices=(('', '--'),)+settings.LANGUAGES)
            )
            # Add language_code to self._meta.fields so it is included in validation stage
            try:
                form._meta.fields.append('language_code')
            except AttributeError:
                form._meta.fields += ('language_code',)

        # Remove the master foreignkey, we have this from self.instance already
        if 'master' in form.fields:
            del form.fields['master']

def translationformset_factory(model, **kwargs):
    """ Works as a regular inlineformset_factory except for:
    - it is set up to work on the given model's translations table
    - it uses a BaseTranslationFormSet to handle combine() and language_code

    Basic use: MyModelTranslationsFormSet = translationformset_factory(MyModel)
    """
    defaults = {
        'formset': BaseTranslationFormSet,
        'fk_name': 'master',
    }
    defaults.update(kwargs)
    return inlineformset_factory(model, model._meta.translations_model, **defaults)


########NEW FILE########
__FILENAME__ = manager
from collections import defaultdict
import django
from django.conf import settings
from django.db import models, transaction, IntegrityError
from django.db.models.query import QuerySet, ValuesQuerySet, DateQuerySet
if django.VERSION >= (1, 6):
    from django.db.models.query import DateTimeQuerySet
try:
    from django.db.models.query import CHUNK_SIZE
except ImportError:
    CHUNK_SIZE = 100
from django.db.models import Q
from django.utils.translation import get_language
from hvad.fieldtranslator import translate
from hvad.utils import combine
from hvad.compat.settings import settings_updater
import logging
import sys
import warnings

logger = logging.getLogger(__name__)
warned_for_select_related_keys = set()

@settings_updater
def update_settings(*args, **kwargs):
    global FALLBACK_LANGUAGES, LEGACY_FALLBACKS
    FALLBACK_LANGUAGES = tuple( code for code, name in settings.LANGUAGES )
    LEGACY_FALLBACKS = bool(getattr(settings, 'HVAD_LEGACY_FALLBACKS', django.VERSION < (1, 6)))


class FieldTranslator(dict):
    """
    Translates *shared* field names from '<shared_field>' to
    'master__<shared_field>' and caches those names.
    """
    def __init__(self, manager):
        self.manager = manager
        self.shared_fields = tuple(self.manager.shared_model._meta.get_all_field_names()) + ('pk',)
        self.translated_fields  = tuple(self.manager.model._meta.get_all_field_names())
        super(FieldTranslator, self).__init__()
        
    def get(self, key):
        if not key in self:
            self[key] = self.build(key)
        return self[key]
    
    def build(self, key):
        """
        Checks if the selected field is a shared field
        and in that case, prefixes it with master___
        It also handles - and ? in case its called by
        order_by()
        """
        if key == "?":
            return key
        if key.startswith("-"):
            prefix = "-"
            key = key[1:]
        else:
            prefix = ""
        if key.startswith(self.shared_fields):
            return '%smaster__%s' % (prefix, key)
        else:
            return '%s%s' % (prefix, key)


class ValuesMixin(object):
    _skip_master_select = True

    def _strip_master(self, key):
        if key.startswith('master__'):
            return key[8:]
        return key
       
    def iterator(self):
        qs = self._clone()._add_language_filter()
        for row in super(ValuesMixin, qs).iterator():
            if isinstance(row, dict):
                yield dict((qs._strip_master(k), v) for k,v in row.items())
            else:
                yield row

class SkipMasterSelectMixin(object):
    _skip_master_select = True

#===============================================================================
# Field for language joins
#===============================================================================

class RawConstraint(object):
    def __init__(self, sql, aliases):
        self.sql = sql
        self.aliases = aliases

    def as_sql(self, qn, connection):
        aliases = tuple(qn(alias) for alias in self.aliases)
        return (self.sql % aliases, [])

class BetterTranslationsField(object):
    def __init__(self, translation_fallbacks):
        self._fallbacks = translation_fallbacks
        self._langcase = ('(CASE %s.language_code ' +
                          ' '.join('WHEN \'%s\' THEN %d' % (lang, i)
                                   for i, lang in enumerate(self._fallbacks)) +
                          ' ELSE %d END)' % len(self._fallbacks))

    def get_extra_restriction(self, where_class, alias, related_alias):
        return RawConstraint(
                sql=' '.join((self._langcase, '<', self._langcase, 'OR ('
                              '%s.language_code = %s.language_code AND '
                              '%s.id < %s.id)')),
                aliases=(alias, related_alias,
                         alias, related_alias,
                         alias, related_alias)
            )


#===============================================================================
# Default 
#===============================================================================

        
class TranslationQueryset(QuerySet):
    """
    This is where things happen.
    
    To fully understand this project, you have to understand this class.
    
    Go through each method individually, maybe start with 'get', 'create' and
    'iterator'.
    
    IMPORTANT: the `model` attribute on this class is the *translated* Model,
    despite this being used as the queryset for the *shared* Model!
    """
    override_classes = {
        ValuesQuerySet: ValuesMixin,
        DateQuerySet: SkipMasterSelectMixin,
    }
    if django.VERSION >= (1, 6):
        override_classes[DateTimeQuerySet] = SkipMasterSelectMixin

    def __init__(self, model, *args, **kwargs):
        if hasattr(model._meta, 'translations_model'):
            # normal creation gets a shared model that we must flip around
            model, self.shared_model = model._meta.translations_model, model
        elif not hasattr(model._meta, 'shared_model'):
            raise TypeError('TranslationQueryset only works on translatable models')
        self._local_field_names = None
        self._field_translator = None
        self._language_code = None
        self._related_model_extra_filters = [] # Used for select_related
        self._forced_unique_fields = []  # Used for select_related
        super(TranslationQueryset, self).__init__(model, *args, **kwargs)

        # After super(), make sure we retrieve the shared model:
        if not getattr(self, '_skip_master_select', False) and not self.query.select_related:
            self.query.add_select_related(('master',))


    #===========================================================================
    # Helpers and properties (INTERNAL!)
    #===========================================================================

    @property
    def field_translator(self):
        """
        Field translator for this manager
        """
        if self._field_translator is None:
            self._field_translator = FieldTranslator(self)
        return self._field_translator
        
    @property
    def shared_local_field_names(self):
        if self._local_field_names is None:
            self._local_field_names = self.shared_model._meta.get_all_field_names()
        return self._local_field_names
    
    def _translate_args_kwargs(self, *args, **kwargs):
        # Translated kwargs from '<shared_field>' to 'master__<shared_field>'
        # where necessary.
        newkwargs = {}
        for key, value in kwargs.items():
            newkwargs[self.field_translator.get(key)] = value
        # Translate args (Q objects) from '<shared_field>' to
        # 'master__<shared_field>' where necessary.
        newargs = []
        for q in args:
            newargs.append(self._recurse_q(q))
        return newargs, newkwargs
    
    def _translate_fieldnames(self, fieldnames):
        newnames = []
        for name in fieldnames:
            newnames.append(self.field_translator.get(name))
        return newnames

    def _reverse_translate_fieldnames_dict(self, fieldname_dict):
        """
        Helper function to make sure the user doesnt get "bothered"
        with the construction of shared/translated model

        Translates e.g.
        {'master__number_avg': 10} to {'number__avg': 10}

        """
        newdict = {}
        for key, value in fieldname_dict.items():
            if key.startswith("master__"):
                key = key.replace("master__", "")
            newdict[key] = value
        return newdict

    def _recurse_q(self, q):
        """
        Recursively translate fieldnames in a Q object.
        
        TODO: What happens if we span multiple relations?
        """
        newchildren =  []
        for child in q.children:
            if isinstance(child, Q):
                newq = self._recurse_q(child)
                newchildren.append(newq)
            else:
                key, value = child
                newchildren.append((self.field_translator.get(key), value))
        q.children = newchildren
        return q
    
    def _find_language_code(self, q):
        """
        Checks if it finds a language code in a Q object (and it's children).
        """
        language_code = None
        for child in q.children:
            if isinstance(child, Q):
                language_code = self._find_language_code(child)
            elif isinstance(child, tuple):
                key, value = child
                if key == 'language_code':
                    language_code = value
            if language_code:
                break
        return language_code
    
    def _split_kwargs(self, **kwargs):
        """
        Split kwargs into shared and translated fields
        """
        shared = {}
        translated = {}
        for key, value in kwargs.items():
            if key in self.shared_local_field_names:
                shared[key] = value
            else:
                translated[key] = value
        return shared, translated
    
    def _get_class(self, klass):
        for key, value in self.override_classes.items():
            if issubclass(klass, key):
                return type(value.__name__, (value, klass, TranslationQueryset,), {})
        return klass
    
    def _get_shared_queryset(self):
        qs = super(TranslationQueryset, self)._clone()
        qs.__class__ = QuerySet
        # un-select-related the 'master' relation
        del qs.query.select_related['master']
        accessor = self.shared_model._meta.translations_accessor
        # update using the real manager
        return QuerySet(self.shared_model, using=self.db).filter(**{'%s__in' % accessor:qs})

    def _scan_for_language_where_node(self, children):
        found = False
        for node in children:
            try:
                if django.VERSION >= (1, 7):
                    field_name = node.lhs.target.name
                else:
                    field_name = node[0].field.name
            except (TypeError, AttributeError):
                if node.children:
                    found = self._scan_for_language_where_node(node.children)
            else:
                found = field_name == 'language_code'

            if found:
                # No need to continue
                return True

    def _add_language_filter(self):
        if self._language_code == 'all':
            if self._related_model_extra_filters:
                raise NotImplementedError('Using select_related along with '
                                          'language(\'all\') is not supported')
        else:
            language_code = self._language_code or get_language()
            if not self._scan_for_language_where_node(self.query.where.children):
                self.query.add_filter(('language_code', language_code))

            for f in self._related_model_extra_filters:
                f1 = {f: language_code}
                f2 = {f: None}  # Allow select_related() to fetch objects with a relation set to NULL
                self.query.add_q( Q(**f1) | Q(**f2) )
        return self

    #===========================================================================
    # Queryset/Manager API 
    #===========================================================================

    def language(self, language_code=None):
        self._language_code = language_code
        return self
    
    def __getitem__(self, k):
        """
        Handle getitem special since self.iterator is called *after* the
        slicing happens, when it's no longer possible to filter a queryest.
        Therefore the check for _language_code must be done here.
        """
        if self._result_cache is None:
            qs = self._clone()._add_language_filter()
            return super(TranslationQueryset, qs).__getitem__(k)
        return super(TranslationQueryset, self).__getitem__(k)

    def create(self, **kwargs):
        if 'language_code' not in kwargs:
            kwargs['language_code'] = self._language_code or get_language()
        if kwargs['language_code'] == 'all':
            raise ValueError('Cannot create an object with language \'all\'')
        obj = self.shared_model(**kwargs)
        self._for_write = True
        obj.save(force_insert=True, using=self.db)
        return obj

    def count(self):
        if self._result_cache is None:
            qs = self._clone()._add_language_filter()
            return super(TranslationQueryset, qs).count()
        else:
            return len(self._result_cache)

    def exists(self):
        if self._result_cache is None:
            qs = self._clone()._add_language_filter()
            return super(TranslationQueryset, qs).exists()
        else:
            return bool(self._result_cache)

    def get(self, *args, **kwargs):
        """
        Get an object by querying the translations model and returning a 
        combined instance.
        """
        qs = self._clone()
        newargs, newkwargs = qs._translate_args_kwargs(*args, **kwargs)

        if 'language_code' in newkwargs:
            language_code = newkwargs.pop('language_code')
            if language_code == 'all': # it would work, but make future evolutions hard
                raise ValueError('Special value \'all\' can only be passed through '
                                 'the language() method.')
            qs.language(language_code)
            qs._add_language_filter()
        elif any(qs._find_language_code(arg) for arg in args if isinstance(arg, Q)):
            assert not self._related_model_extra_filters, (
                   'Cannot use select_related along with language_code field in Q objects')
            # language code in *args, no related fields, do not call _add_language_filter
        else:
            qs._add_language_filter()

        # self.iterator already combines! Isn't that nice?
        return QuerySet.get(qs, *newargs, **newkwargs)

    def get_or_create(self, **kwargs):
        """
        Looks up an object with the given kwargs, creating one if necessary.
        Returns a tuple of (object, created), where created is a boolean
        specifying whether an object was created.
        """
        assert kwargs, \
                'get_or_create() must be passed at least one keyword argument'
        defaults = kwargs.pop('defaults', {})
        lookup = kwargs.copy()
        for f in self.model._meta.fields:
            if f.attname in lookup:
                lookup[f.name] = lookup.pop(f.attname)
        try:
            self._for_write = True
            return self.get(**lookup), False
        except self.model.DoesNotExist:
            try:
                params = dict([(k, v) for k, v in kwargs.items() if '__' not in k])
                params.update(defaults)
                # START PATCH
                if 'language_code' not in params:
                    params['language_code'] = self._language_code or get_language()
                if params['language_code'] == 'all':
                    raise ValueError('Cannot create an object with language \'all\'')
                obj = self.shared_model(**params)
                # END PATCH
                sid = transaction.savepoint(using=self.db)
                obj.save(force_insert=True, using=self.db)
                transaction.savepoint_commit(sid, using=self.db)
                return obj, True
            except IntegrityError:
                transaction.savepoint_rollback(sid, using=self.db)
                exc_info = sys.exc_info()
                try:
                    return self.get(**lookup), False
                except self.model.DoesNotExist:
                    # Re-raise the IntegrityError with its original traceback.
                    raise exc_info[1]

    if django.VERSION >= (1, 7):
        def update_or_create(self, defaults=None, **kwargs):
            raise NotImplementedError()

    def bulk_create(self, objs, batch_size=None):
        raise NotImplementedError()

    def filter(self, *args, **kwargs):
        newargs, newkwargs = self._translate_args_kwargs(*args, **kwargs)
        return super(TranslationQueryset, self).filter(*newargs, **newkwargs)

    def aggregate(self, *args, **kwargs):
        """
        Loops over all the passed aggregates and translates the fieldnames
        """
        qs = self._clone()._add_language_filter()
        newargs, newkwargs = [], {}
        for arg in args:
            arg.lookup = qs._translate_fieldnames([arg.lookup])[0]
            newargs.append(arg)
        for key in kwargs:
            value = kwargs[key]
            value.lookup = qs._translate_fieldnames([value.lookup])[0]
            newkwargs[key] = value
        response = super(TranslationQueryset, qs).aggregate(*newargs, **newkwargs)
        return qs._reverse_translate_fieldnames_dict(response)

    def latest(self, field_name=None):
        qs = self._clone()._add_language_filter()
        field_name = qs.field_translator.get(field_name or self.shared_model._meta.get_latest_by)
        return super(TranslationQueryset, qs).latest(field_name)

    if django.VERSION >= (1, 6):
        def earliest(self, field_name=None):
            qs = self._clone()._add_language_filter()
            field_name = qs.field_translator.get(field_name or self.shared_model._meta.get_latest_by)
            return super(TranslationQueryset, qs).earliest(field_name)

    def in_bulk(self, id_list):
        if not id_list:
            return {}
        if self._language_code == 'all':
            raise ValueError('Cannot use in_bulk along with language(\'all\').')
        qs = self.filter(pk__in=id_list)
        qs.query.clear_ordering(force_empty=True)
        return dict((obj._get_pk_val(), obj) for obj in qs.iterator())

    def delete(self):
        qs = self._get_shared_queryset()
        qs.delete()
    delete.alters_data = True
    delete.queryset_only = True
    
    def delete_translations(self):
        self.update(master=None)
        self.model.objects.filter(master__isnull=True).delete()
    delete_translations.alters_data = True
        
    def update(self, **kwargs):
        qs = self._clone()._add_language_filter()
        shared, translated = qs._split_kwargs(**kwargs)
        count = 0
        if translated:
            count += super(TranslationQueryset, qs).update(**translated)
        if shared:
            shared_qs = qs._get_shared_queryset()
            count += shared_qs.update(**shared)
        return count
    update.alters_data = True

    def values(self, *fields):
        fields = self._translate_fieldnames(fields)
        return super(TranslationQueryset, self).values(*fields)

    def values_list(self, *fields, **kwargs):
        fields = self._translate_fieldnames(fields)
        return super(TranslationQueryset, self).values_list(*fields, **kwargs)

    def dates(self, field_name, kind=None, order='ASC'):
        field_name = self.field_translator.get(field_name)
        return super(TranslationQueryset, self).dates(field_name, kind=kind, order=order)

    if django.VERSION >= (1, 6):
        def datetimes(self, field, *args, **kwargs):
            field = self.field_translator.get(field)
            return super(TranslationQueryset, self).datetimes(field, *args, **kwargs)

    def exclude(self, *args, **kwargs):
        newargs, newkwargs = self._translate_args_kwargs(*args, **kwargs)
        return super(TranslationQueryset, self).exclude(*newargs, **newkwargs)

    def select_related(self, *fields):
        """
        Include other models in this query.
        This is complex but allows retreiving related models and their
        translations with a single query.
        """
        if not fields:
            raise NotImplementedError("To use select_related on a translated model, you must provide a list of fields.")
        related_model_keys = ['master']
        related_model_explicit_joins = []
        forced_unique_fields = []
        for query_key in fields:
            bits = query_key.split('__')
            try:
                field, model, direct, _ = self.shared_model._meta.get_field_by_name.real(bits[0])
                query_key, translated = 'master__%s' % query_key, False
            except models.FieldDoesNotExist:
                field, model, direct, _ = self.model._meta.get_field_by_name(bits[0])
                translated = True

            if direct:  # field is on model
                if field.rel:    # field is a foreign key, follow it
                    model = field.rel.to
                else:            # field is a regular field
                    raise AssertionError('Cannot select_related: %s is a regular field' % query_key)
            else:       # field is a m2m or reverse fk, follow it
                model = field.model

            if hasattr(model._meta, 'translations_accessor'):  # if issubclass(model, TranslatableModel):
                # This is a relation to a translated model,
                # so we need to select_related both the model and its translation model
                if len(bits) > 1:
                    if query_key not in warned_for_select_related_keys:
                        warned_for_select_related_keys.add(query_key)
                        caller = '%s:%d, in %s()' % logger.findCaller()
                        logger.warning('From %s: deep select_related with translated '
                                       'models it not supported, truncating %s',
                                       caller, query_key)
                    del bits[1:]
                    query_key = '__'.join(bits if translated else ['master'] + bits)
                related_model_keys.append(query_key)  # Select the related model
                related_model_keys.append('%s__%s' % (query_key, model._meta.translations_accessor))  # and its translation model

                # We need to force this to be a LEFT OUTER join, so we explicitly add the join.
                # Django 1.6 changes the footprint of the Query.join method. See https://code.djangoproject.com/ticket/19385
                if django.VERSION < (1, 6):
                    join_data = (field.model._meta.db_table, model._meta.db_table, bits[0] + "_id", 'id')
                else:
                    join_data = (field, (field.model._meta.db_table, model._meta.db_table, ((bits[0] + "_id", 'id'),)))
                related_model_explicit_joins.append(join_data)
                # And we are going to force the query to treat the language join as one-to-one,
                # so we need to filter for the desired language:
                self._related_model_extra_filters.append(
                    '%s__%s__language_code' % (query_key, model._meta.translations_accessor),
                )
                rel_field_to_force = getattr(model, model._meta.translations_accessor).related.field
                if not rel_field_to_force._unique:
                    # The filter that we set up above essentially makes the related translations table
                    # a one-to-one join with the related shared table, so we need to use a hack that
                    # forces the query compiler to treat the join as one-to-one:
                    # The following will defer "model.translations.related.field._unique = True"
                    forced_unique_fields.append(rel_field_to_force)
            else:
                related_model_keys.append(query_key)
        obj = self._clone()
        obj.query.get_compiler(obj.db).fill_related_selections()  # seems to be necessary; not sure why
        for j in related_model_explicit_joins:
            if django.VERSION >= (1, 6):
                kwargs = {'join_field': j[0]}
                j = j[1]
            else:
                kwargs = {}
            obj.query.join(j, nullable=True, **kwargs)
        obj._forced_unique_fields.extend(forced_unique_fields)
        obj.query.add_select_related(related_model_keys)

        return obj

    def complex_filter(self, filter_obj):
        # Don't know how to handle Q object yet, but it is probably doable...
        # An unknown type object that supports 'add_to_query' is a different story :)
        if isinstance(filter_obj, models.Q) or hasattr(filter_obj, 'add_to_query'):
            raise NotImplementedError()
        
        newargs, newkwargs = self._translate_args_kwargs(**filter_obj)
        return super(TranslationQueryset, self)._filter_or_exclude(None, *newargs, **newkwargs)

    def annotate(self, *args, **kwargs):
        raise NotImplementedError()

    def order_by(self, *field_names):
        """
        Returns a new QuerySet instance with the ordering changed.
        """
        fieldnames = self._translate_fieldnames(field_names)
        return super(TranslationQueryset, self).order_by(*fieldnames)
    
    def reverse(self):
        return super(TranslationQueryset, self).reverse()

    def defer(self, *fields):
        raise NotImplementedError()

    def only(self, *fields):
        raise NotImplementedError()
    
    def _clone(self, klass=None, setup=False, **kwargs):
        kwargs.update({
            'shared_model': self.shared_model,
            '_local_field_names': self._local_field_names,
            '_field_translator': self._field_translator,
            '_language_code': self._language_code,
            '_related_model_extra_filters': list(self._related_model_extra_filters),
            '_forced_unique_fields': list(self._forced_unique_fields),
        })
        if klass:
            klass = self._get_class(klass)
        else:
            klass = self.__class__
        return super(TranslationQueryset, self)._clone(klass, setup, **kwargs)
    
    def iterator(self):
        """
        If this queryset is not filtered by a language code yet, it should be
        filtered first by calling self.language.
        
        If someone doesn't want a queryset filtered by language, they should use
        Model.objects.untranslated()
        """
        qs = self._clone()._add_language_filter()

        if qs._forced_unique_fields:
            # In order for select_related to properly load data from
            # translated models, we have to force django to treat
            # certain fields as one-to-one relations
            # before this queryset calls get_cached_row()
            # We change it back so that things get reset to normal
            # before execution returns to user code.
            # It would be more direct and robust if we could wrap
            # django.db.models.query.get_cached_row() instead, but that's not a class
            # method, sadly, so we cannot override it just for this query

            # Enable temporary forced "unique" attribute for related translated models:
            for field in qs._forced_unique_fields:
                field._unique = True
            # Pre-fetch all objects:
            objects = list(super(TranslationQueryset, qs).iterator())
            # Disable temporary forced attribute:
            for field in qs._forced_unique_fields:
                field._unique = False

            if type(qs.query.select_related) == dict:
                for obj in objects:
                    qs._use_related_translations(obj, qs.query.select_related)
        else:
            objects = super(TranslationQueryset, qs).iterator()
        for obj in objects:
            # non-cascade-deletion hack:
            if not obj.master:
                yield obj
            else:
                yield combine(obj, qs.shared_model)

    def _use_related_translations(self, obj, relations_dict, follow_relations=True):
        """
        Ensure that we use cached translations brought in via select_related if
        available. Necessary since the database select_related query caches the
        related translation models in a different place than hvad expects it.
        """
        for related_field_name in relations_dict:
            if related_field_name == "master" and follow_relations:
                self._use_related_translations(obj.master, relations_dict[related_field_name], follow_relations=False)
            else:
                related_obj = getattr(obj, related_field_name)
                if related_obj and hasattr(related_obj._meta, 'translations_cache'):
                    # This is a related translated model included using select_related:
                    # The following is a generic version of
                    # "related_obj.translations_cache = related_obj._translations_cache"
                    trans_rel = getattr(related_obj.__class__, related_obj._meta.translations_accessor)
                    new_cache = getattr(related_obj, trans_rel.related.get_cache_name(), None)
                    setattr(related_obj, related_obj._meta.translations_cache, new_cache)


#===============================================================================
# Fallbacks
#===============================================================================

class _SharedFallbackQueryset(QuerySet):
    translation_fallbacks = None

    def use_fallbacks(self, *fallbacks):
        self.translation_fallbacks = fallbacks or (None,)+FALLBACK_LANGUAGES
        return self

    def _clone(self, klass=None, setup=False, **kwargs):
        kwargs.update({
            'translation_fallbacks': self.translation_fallbacks,
        })
        return super(_SharedFallbackQueryset, self)._clone(klass, setup, **kwargs)

    def aggregate(self, *args, **kwargs):
        raise NotImplementedError()

    def annotate(self, *args, **kwargs):
        raise NotImplementedError()

    def defer(self, *args, **kwargs):
        raise NotImplementedError()

    def only(self, *args, **kwargs):
        raise NotImplementedError()


class LegacyFallbackQueryset(_SharedFallbackQueryset):
    '''
    Queryset that tries to load a translated version using fallbacks on a per
    instance basis.
    BEWARE: creates a lot of queries!
    '''
    def _get_real_instances(self, base_results):
        """
        The logic for this method was taken from django-polymorphic by Bert
        Constantin (https://github.com/bconstantin/django_polymorphic) and was
        slightly altered to fit the needs of django-hvad.
        """
        # get the primary keys of the shared model results
        base_ids = [obj.pk for obj in base_results]
        fallbacks = [get_language() if lang is None else lang
                     for lang in self.translation_fallbacks]
        # get all translations for the fallbacks chosen for those shared models,
        # note that this query is *BIG* and might return a lot of data, but it's
        # arguably faster than running one query for each result or even worse
        # one query per result per language until we find something
        translations_manager = self.model._meta.translations_model.objects
        baseqs = translations_manager.select_related('master')
        translations = baseqs.filter(language_code__in=fallbacks,
                                     master__pk__in=base_ids)
        fallback_objects = defaultdict(dict)
        # turn the results into a dict of dicts with shared model primary key as
        # keys for the first dict and language codes for the second dict
        for obj in translations:
            fallback_objects[obj.master.pk][obj.language_code] = obj
        # iterate over the share dmodel results
        for instance in base_results:
            translation = None
            # find the translation
            for fallback in fallbacks:
                translation = fallback_objects[instance.pk].get(fallback, None)
                if translation is not None:
                    break
            # if we found a translation, yield the combined result
            if translation:
                yield combine(translation, self.model)
            else:
                # otherwise yield the shared instance only
                logger.error("no translation for %s.%s (pk=%s)" % (instance._meta.app_label, instance.__class__.__name__, str(instance.pk)))
                yield instance

    def iterator(self):
        """
        The logic for this method was taken from django-polymorphic by Bert
        Constantin (https://github.com/bconstantin/django_polymorphic) and was
        slightly altered to fit the needs of django-hvad.
        """
        base_iter = super(LegacyFallbackQueryset, self).iterator()

        # only do special stuff when we actually want fallbacks
        if self.translation_fallbacks:
            while True:
                base_result_objects = []
                reached_end = False

                # get the next "chunk" of results
                for i in range(CHUNK_SIZE):
                    try:
                        instance = next(base_iter)
                        base_result_objects.append(instance)
                    except StopIteration:
                        reached_end = True
                        break

                # "combine" the results with their fallbacks
                real_results = self._get_real_instances(base_result_objects)

                # yield em!
                for instance in real_results:
                    yield instance

                # get out of the while loop if we're at the end, since this is
                # an iterator, we need to raise StopIteration, not "return".
                if reached_end:
                    raise StopIteration
        else:
            # just iterate over it
            for instance in base_iter:
                yield instance

class SelfJoinFallbackQueryset(_SharedFallbackQueryset):
    def iterator(self):
        # only do special stuff when we actually want fallbacks
        if self.translation_fallbacks:
            fallbacks = [get_language() if lang is None else lang
                         for lang in self.translation_fallbacks]
            tmodel = self.model._meta.translations_model
            taccessor = self.model._meta.translations_accessor
            taccessorcache = getattr(self.model, taccessor).related.get_cache_name()
            tcache = self.model._meta.translations_cache
            masteratt = tmodel._meta.get_field('master').attname
            field = BetterTranslationsField(fallbacks)

            qs = self._clone()

            qs.query.add_select_related((taccessor,))
            # This join will be reused by the select_related. We must provide it
            # anyway because the order matters and add_select_related does not
            # populate joins right away.
            nullable = ({'nullable': True} if django.VERSION >= (1, 7) else
                        {'nullable': True, 'outer_if_first': True})
            alias1 = qs.query.join((qs.query.get_initial_alias(), tmodel._meta.db_table,
                                ((qs.model._meta.pk.attname, masteratt),)),
                                join_field=getattr(qs.model, taccessor).related.field.rel,
                                **nullable)
            alias2 = qs.query.join((tmodel._meta.db_table, tmodel._meta.db_table,
                                ((masteratt, masteratt),)),
                                join_field=field, **nullable)
            qs.query.add_extra(None, None, ('%s.id IS NULL'%alias2,), None, None, None)

            # We must force the _unique field so get_cached_row populates the cache
            # Unfortunately, this means we must load everything in one go
            getattr(qs.model, taccessor).related.field._unique = True
            objects = []
            for instance in super(SelfJoinFallbackQueryset, qs).iterator():
                try:
                    translation = getattr(instance, taccessorcache)
                except AttributeError:
                    logger.error("no translation for %s.%s (pk=%s)" % (instance._meta.app_label, instance.__class__.__name__, str(instance.pk)))
                else:
                    setattr(instance, tcache, translation)
                    delattr(instance, taccessorcache)
                objects.append(instance)
            getattr(qs.model, taccessor).related.field._unique = False
            return iter(objects)
        else:
            return super(SelfJoinFallbackQueryset, self).iterator()


FallbackQueryset = LegacyFallbackQueryset if LEGACY_FALLBACKS else SelfJoinFallbackQueryset


class TranslationFallbackManager(models.Manager):
    """
    Manager class for the shared model, without specific translations. Allows
    using `use_fallbacks()` to enable per object language fallback.
    """
    def __init__(self, *args, **kwargs):
        warnings.warn('TranslationFallbackManager is deprecated. Please use '
                      'TranslationManager\'s untranslated() method.',
                      DeprecationWarning, stacklevel=2)
        super(TranslationFallbackManager, self).__init__(*args, **kwargs)

    def use_fallbacks(self, *fallbacks):
        if django.VERSION >= (1, 6):
            return self.get_queryset().use_fallbacks(*fallbacks)
        else:
            return self.get_query_set().use_fallbacks(*fallbacks)

    def get_queryset(self):
        return FallbackQueryset(self.model, using=self.db)
    get_query_set = get_queryset        # old name for Django < 1.6


#===============================================================================
# TranslationManager
#===============================================================================


class TranslationManager(models.Manager):
    """
    Manager class for models with translated fields
    """
    #===========================================================================
    # API
    #===========================================================================
    use_for_related_fields = True

    queryset_class = TranslationQueryset
    fallback_class = FallbackQueryset
    default_class = QuerySet

    def __init__(self, *args, **kwargs):
        self.queryset_class = kwargs.pop('queryset_class', self.queryset_class)
        self.fallback_class = kwargs.pop('fallback_class', self.fallback_class)
        self.default_class = kwargs.pop('default_class', self.default_class)
        super(TranslationManager, self).__init__(*args, **kwargs)

    def using_translations(self):
        warnings.warn('using_translations() is deprecated, use language() instead', DeprecationWarning, stacklevel=2)
        qs = self.queryset_class(self.model, using=self.db)
        if hasattr(self, 'core_filters'):
            qs = qs._next_is_sticky().filter(**(self.core_filters))
        return qs

    def _make_queryset(self, klass):
        if django.VERSION >= (1, 7):
            qs = klass(self.model, using=self.db, hints=self._hints)
        else:
            qs = klass(self.model, using=self.db)
        if hasattr(self, 'core_filters'):
            qs = qs._next_is_sticky().filter(**(self.core_filters))
        return qs

    def language(self, language_code=None):
        return self._make_queryset(self.queryset_class).language(language_code)

    def untranslated(self):
        return self._make_queryset(self.fallback_class)

    def get_queryset(self):
        return self._make_queryset(self.default_class)

    #===========================================================================
    # Internals
    #===========================================================================

    @property
    def translations_model(self):
        return self.model._meta.translations_model


#===============================================================================
# TranslationAware
#===============================================================================


class TranslationAwareQueryset(QuerySet):
    def __init__(self, *args, **kwargs):
        super(TranslationAwareQueryset, self).__init__(*args, **kwargs)
        self._language_code = None
        
    def _translate_args_kwargs(self, *args, **kwargs):
        self.language(self._language_code)
        language_joins = []
        newkwargs = {}
        extra_filters = Q()
        for key, value in kwargs.items():
            newkey, langjoins = translate(key, self.model)
            for langjoin in langjoins:
                if langjoin not in language_joins:
                    language_joins.append(langjoin)
            newkwargs[newkey] = value
        newargs = []
        for q in args:
            new_q, langjoins = self._recurse_q(q)
            newargs.append(new_q)
            for langjoin in langjoins:
                if langjoin not in language_joins:
                    language_joins.append(langjoin)
        for langjoin in language_joins:
            extra_filters &= Q(**{langjoin: self._language_code})
        return newargs, newkwargs, extra_filters

    def _recurse_q(self, q):
        newchildren =  []
        language_joins = []
        for child in q.children:
            if isinstance(child, Q):
                newq, langjoins = self._recurse_q(child)
                newchildren.append(newq)
            else:
                key, value = child
                newkey, langjoins =translate(key, self.model)
                newchildren.append((newkey, value))
            for langjoin in langjoins:
                if langjoin not in language_joins:
                    language_joins.append(langjoin)
        q.children = newchildren
        return q, language_joins
    
    def _translate_fieldnames(self, fields):
        self.language(self._language_code)
        newfields = []
        extra_filters = Q()
        language_joins = []
        for field in fields:
            newfield, langjoins = translate(field, self.model)
            newfields.append(newfield)
            for langjoin in langjoins:
                if langjoin not in language_joins:
                    language_joins.append(langjoin)
        for langjoin in language_joins:
            extra_filters &= Q(**{langjoin: self._language_code})
        return newfields, extra_filters
    
    #===========================================================================
    # Queryset/Manager API 
    #===========================================================================
        
    def language(self, language_code=None):
        if not language_code:
            language_code = get_language()
        self._language_code = language_code
        return self
    
    def get(self, *args, **kwargs):
        newargs, newkwargs, extra_filters = self._translate_args_kwargs(*args, **kwargs)
        return self._filter_extra(extra_filters).get(*newargs, **newkwargs)

    def filter(self, *args, **kwargs):
        newargs, newkwargs, extra_filters = self._translate_args_kwargs(*args, **kwargs)
        return self._filter_extra(extra_filters).filter(*newargs, **newkwargs)

    def aggregate(self, *args, **kwargs):
        raise NotImplementedError()

    def latest(self, field_name=None):
        extra_filters = Q()
        if field_name:
            field_name, extra_filters = translate(self, field_name)
        return self._filter_extra(extra_filters).latest(field_name)

    def in_bulk(self, id_list):
        if not id_list:
            return {}
        qs = self.filter(pk__in=id_list)
        qs.query.clear_ordering(force_empty=True)
        return dict([(obj._get_pk_val(), obj) for obj in qs.iterator()])

    def values(self, *fields):
        fields, extra_filters = self._translate_fieldnames(fields)
        return self._filter_extra(extra_filters).values(*fields)

    def values_list(self, *fields, **kwargs):
        fields, extra_filters = self._translate_fieldnames(fields)
        return self._filter_extra(extra_filters).values_list(*fields, **kwargs)

    def dates(self, field_name, kind, order='ASC'):
        raise NotImplementedError()

    def exclude(self, *args, **kwargs):
        newargs, newkwargs, extra_filters = self._translate_args_kwargs(*args, **kwargs)
        return self._exclude_extra(extra_filters).exclude(*newargs, **newkwargs)

    def complex_filter(self, filter_obj):
        # admin calls this with an empy filter_obj sometimes
        if filter_obj == {}:
            return self
        raise NotImplementedError()

    def annotate(self, *args, **kwargs):
        raise NotImplementedError()

    def order_by(self, *field_names):
        """
        Returns a new QuerySet instance with the ordering changed.
        """
        fieldnames, extra_filters = self._translate_fieldnames(field_names)
        return self._filter_extra(extra_filters).order_by(*fieldnames)
    
    def reverse(self):
        raise NotImplementedError()

    def defer(self, *fields):
        raise NotImplementedError()

    def only(self, *fields):
        raise NotImplementedError()
    
    def _clone(self, klass=None, setup=False, **kwargs):
        kwargs.update({
            '_language_code': self._language_code,
        })
        return super(TranslationAwareQueryset, self)._clone(klass, setup, **kwargs)
    
    def _filter_extra(self, extra_filters):
        qs = super(TranslationAwareQueryset, self).filter(extra_filters)
        return super(TranslationAwareQueryset, qs)

    def _exclude_extra(self, extra_filters):
        qs = super(TranslationAwareQueryset, self).exclude(extra_filters)
        return super(TranslationAwareQueryset, qs)
    

class TranslationAwareManager(models.Manager):
    def language(self, language_code=None):
        if django.VERSION >= (1, 6):
            return self.get_queryset().language(language_code)
        else:
            return self.get_query_set().language(language_code)

    def get_queryset(self):
        qs = TranslationAwareQueryset(self.model, using=self.db)
        return qs
    get_query_set = get_queryset        # old name for Django < 1.6


#===============================================================================
# Translations Model Manager
#===============================================================================


class TranslationsModelManager(models.Manager):
    def get_language(self, language):
        return self.get(language_code=language)

########NEW FILE########
__FILENAME__ = models
from django.core.exceptions import ImproperlyConfigured
from django.conf import settings
from django.db import models
from django.db.models.base import ModelBase
from django.db.models.signals import post_save
from django.utils.translation import get_language
from hvad.compat.metaclasses import with_metaclass
from hvad.descriptors import LanguageCodeAttribute, TranslatedAttribute
from hvad.manager import TranslationManager, TranslationsModelManager
from hvad.utils import SmartGetFieldByName
from hvad.compat.method_type import MethodType
from hvad.compat.settings import settings_updater
import sys
import warnings

@settings_updater
def update_settings(*args, **kwargs):
    global FALLBACK_LANGUAGES, TABLE_NAME_SEPARATOR
    FALLBACK_LANGUAGES = tuple( code for code, name in settings.LANGUAGES )
    try:
        TABLE_NAME_SEPARATOR = getattr(settings, 'NANI_TABLE_NAME_SEPARATOR')
    except AttributeError:
        TABLE_NAME_SEPARATOR = getattr(settings, 'HVAD_TABLE_NAME_SEPARATOR', '_')
    else:
        warnings.warn('NANI_TABLE_NAME_SEPARATOR setting is deprecated and will '
                      'be removed. Please rename it to HVAD_TABLE_NAME_SEPARATOR.',
                      DeprecationWarning)


def create_translations_model(model, related_name, meta, **fields):
    """
    Create the translations model for the shared model 'model'.
    'related_name' is the related name for the reverse FK from the translations
    model.
    'meta' is a (optional) dictionary of attributes for the translations model's
    inner Meta class.
    'fields' is a dictionary of fields to put on the translations model.
    
    Two fields are enforced on the translations model:
    
        language_code: A 15 char, db indexed field.
        master: A ForeignKey back to the shared model.
        
    Those two fields are unique together, this get's enforced in the inner Meta
    class of the translations table
    """
    meta = meta or {}

    # Build a list of translation models from base classes. Depth-first scan.
    abstract = model._meta.abstract
    translation_bases = []
    scan_bases = list(reversed(model.__bases__)) # backwards so we can use pop/extend
    while scan_bases:
        base = scan_bases.pop()
        if not issubclass(base, TranslatableModel) or base is TranslatableModel:
            continue
        try:
            # The base may have translations model, then just inherit that
            translation_bases.append(base._meta.translations_model)
        except AttributeError:
            # But it may not, and simply inherit other abstract bases, scan them
            scan_bases.extend(reversed(base.__bases__))
    translation_bases.append(BaseTranslationModel)

    # Create translation model Meta
    meta['abstract'] = abstract
    if not abstract:
        unique = [('language_code', 'master')]
        meta['unique_together'] = list(meta.get('unique_together', [])) + unique
    Meta = type('Meta', (object,), meta)

    if not hasattr(Meta, 'db_table'):
        Meta.db_table = model._meta.db_table + '%stranslation' % TABLE_NAME_SEPARATOR
    Meta.app_label = model._meta.app_label
    name = '%sTranslation' % model.__name__

    # Create translation model
    attrs = {}
    attrs.update(fields)
    attrs['Meta'] = Meta
    attrs['__module__'] = model.__module__

    if not abstract:
        # If this class is abstract, we must not contribute management fields
        attrs['objects'] = TranslationsModelManager()
        attrs['language_code'] = models.CharField(max_length=15, db_index=True)
        # null=True is so we can prevent cascade deletion
        attrs['master'] = models.ForeignKey(model, related_name=related_name,
                                            editable=False, null=True)
    # Create and return the new model
    translations_model = ModelBase(name, tuple(translation_bases), attrs)
    if not abstract:
        # Abstract models do not have a DNE class
        bases = (model.DoesNotExist, translations_model.DoesNotExist,)
        DNE = type('DoesNotExist', bases, {})
        translations_model.DoesNotExist = DNE
    opts = translations_model._meta
    opts.shared_model = model

    # We need to set it here so it is available when we scan subclasses
    model._meta.translations_model = translations_model

    # Register it as a global in the shared model's module.
    # This is needed so that Translation model instances, and objects which
    # refer to them, can be properly pickled and unpickled. The Django session
    # and caching frameworks, in particular, depend on this behaviour.
    mod = sys.modules[model.__module__]
    setattr(mod, name, translations_model)

    return translations_model


class TranslatedFields(object):
    """
    Wrapper class to define translated fields on a model.
    """
    def __init__(self, meta=None, **fields):
        self.fields = fields
        self.meta = meta

    def contribute_to_class(self, cls, name):
        """
        Called from django.db.models.base.ModelBase.__new__
        """
        create_translations_model(cls, name, self.meta, **self.fields)


class BaseTranslationModel(models.Model):
    """
    Needed for detection of translation models. Due to the way dynamic classes
    are created, we cannot put the 'language_code' field on here.
    """
    def __init__(self, *args, **kwargs):
        super(BaseTranslationModel, self).__init__(*args, **kwargs)
        
    class Meta:
        abstract = True
        

class TranslatableModelBase(ModelBase):
    """
    Metaclass for models with translated fields (TranslatableModel)
    """
    def __new__(cls, name, bases, attrs):
        super_new = super(TranslatableModelBase, cls).__new__
        parents = [b for b in bases if isinstance(b, TranslatableModelBase)]
        if not parents:
            # If this isn't a subclass of TranslatableModel, don't do anything special.
            return super_new(cls, name, bases, attrs)
        new_model = super_new(cls, name, bases, attrs)
        opts = new_model._meta
        if not opts.abstract and not isinstance(new_model._default_manager, TranslationManager):
            raise ImproperlyConfigured(
                "The default manager on a TranslatableModel must be a "
                "TranslationManager instance or an instance of a subclass of "
                "TranslationManager, the default manager of %r is not." %
                new_model)
        
        if opts.abstract:
            return new_model
        
        concrete_model = new_model

        # Check if it's a proxy model
        if new_model._meta.proxy:
            if hasattr(new_model._meta, 'concrete_model'):
                concrete_model = new_model._meta.concrete_model
            else:
                # We need this prior to Django 1.4
                while concrete_model._meta.proxy:
                    concrete_model = concrete_model._meta.proxy_for_model

        found = False
        for relation in list(concrete_model.__dict__.keys()):
            try:
                obj = getattr(new_model, relation)
            except AttributeError:
                continue
            if not hasattr(obj, 'related'):
                continue
            if not hasattr(obj.related, 'model'):
                continue
            if getattr(obj.related.model._meta, 'shared_model', None) is concrete_model:
                if found:
                    raise ImproperlyConfigured(
                        "A TranslatableModel can only define one set of "
                        "TranslatedFields, %r defines more than one: %r to %r "
                        "and %r to %r and possibly more" % (new_model, obj,
                        obj.related.model, found, found.related.model))
                else:
                    new_model.contribute_translations(obj.related)
                    found = obj

        if not found:
            raise ImproperlyConfigured(
                "No TranslatedFields found on %r, subclasses of "
                "TranslatableModel must define TranslatedFields." % new_model
            )
        
        post_save.connect(new_model.save_translations, sender=new_model, weak=False)
        
        if not isinstance(opts.get_field_by_name, SmartGetFieldByName):
            smart_get_field_by_name = SmartGetFieldByName(opts.get_field_by_name)
            opts.get_field_by_name = MethodType(smart_get_field_by_name , opts)
        
        return new_model
    

class NoTranslation(object):
    pass


class TranslatableModel(with_metaclass(TranslatableModelBase, models.Model)):
    """
    Base model for all models supporting translated fields (via TranslatedFields).
    """
    # change the default manager to the translation manager
    objects = TranslationManager()
    
    class Meta:
        abstract = True
    
    def __init__(self, *args, **kwargs):
        tkwargs = {} # translated fields
        skwargs = {} # shared fields
        
        if 'master' in kwargs.keys():
            raise RuntimeError(
                    "Cannot init  %s class with a 'master' argument" % \
                    self.__class__.__name__
            )
        
        # filter out all the translated fields (including 'master' and 'language_code')
        primary_key_names = ('pk', self._meta.pk.name)
        for key in list(kwargs.keys()):
            if key in self._translated_field_names:
                if not key in primary_key_names:
                    # we exclude the pk of the shared model
                    tkwargs[key] = kwargs.pop(key)
        if not tkwargs.keys():
            # if there where no translated options, then we assume this is a
            # regular init and don't want to do any funky stuff
            super(TranslatableModel, self).__init__(*args, **kwargs)
            return
        
        # there was at least one of the translated fields (or a language_code) 
        # in kwargs. We need to do magic.
        # extract all the shared fields (including the pk)
        for key in list(kwargs.keys()):
            if key in self._shared_field_names:
                skwargs[key] = kwargs.pop(key)
        # do the regular init minus the translated fields
        super(TranslatableModel, self).__init__(*args, **skwargs)
        # prepopulate the translations model cache with an translation model
        tkwargs['language_code'] = tkwargs.get('language_code', get_language())
        tkwargs['master'] = self
        translated = self._meta.translations_model(*args, **tkwargs)
        setattr(self, self._meta.translations_cache, translated)
    
    @classmethod
    def contribute_translations(cls, rel):
        """
        Contribute translations options to the inner Meta class and set the
        descriptors.
        
        This get's called from TranslatableModelBase.__new__
        """
        opts = cls._meta
        opts.translations_accessor = rel.get_accessor_name()
        opts.translations_model = rel.model
        opts.translations_cache = '%s_cache' % rel.get_accessor_name()
        trans_opts = opts.translations_model._meta
        
        # Set descriptors
        ignore_fields = [
            'pk',
            'master',
            opts.translations_model._meta.pk.name,
        ]
        for field in trans_opts.fields:
            if field.name in ignore_fields:
                continue
            if field.name == 'language_code':
                attr = LanguageCodeAttribute(opts)
            else:
                attr = TranslatedAttribute(opts, field.name)
            setattr(cls, field.name, attr)
    
    @classmethod
    def save_translations(cls, instance, **kwargs):
        """
        When this instance is saved, also save the (cached) translation
        """
        opts = cls._meta
        if hasattr(instance, opts.translations_cache):
            trans = getattr(instance, opts.translations_cache)
            if not trans.master_id:
                trans.master = instance
            trans.save()
    
    def translate(self, language_code):
        """
        Returns an Model instance in the specified language.
        Does NOT check if the translation already exists!
        Does NOT interact with the database.
        
        This will refresh the translations cache attribute on the instance.
        """
        tkwargs = {
            'language_code': language_code,
            'master': self,
        }
        translated = self._meta.translations_model(**tkwargs)
        setattr(self, self._meta.translations_cache, translated)
        return self
    
    def safe_translation_getter(self, name, default=None):
        cache = getattr(self, self._meta.translations_cache, None)
        if not cache:
            return default
        return getattr(cache, name, default)

    def lazy_translation_getter(self, name, default=None):
        """
        Lazy translation getter that fetches translations from DB in case the instance is currently untranslated and
        saves the translation instance in the translation cache
        """
        stuff = self.safe_translation_getter(name, NoTranslation)
        if stuff is not NoTranslation:
            return stuff

        # get all translations
        translations = getattr(self, self._meta.translations_accessor).all()

        # if no translation exists, bail out now
        if len(translations) == 0:
            return default

        # organize translations into a nice dict
        translation_dict = dict((t.language_code, t) for t in translations)

        # see if we have the right language, or any language in fallbacks
        for code in (get_language(), settings.LANGUAGE_CODE) + FALLBACK_LANGUAGES:
            try:
                translation = translation_dict[code]
            except KeyError:
                continue
            break
        else:
            # none of the fallbacks was found, pick an arbitrary translation
            translation = translation_dict.popitem()[1]

        setattr(self, self._meta.translations_cache, translation)
        return getattr(translation, name, default)

    def get_available_languages(self):
        qs = getattr(self, self._meta.translations_accessor).all()
        if qs._result_cache is not None:
            return [obj.language_code for obj in qs]
        return qs.values_list('language_code', flat=True)
    
    #===========================================================================
    # Internals
    #===========================================================================
    
    @property
    def _shared_field_names(self):
        if getattr(self, '_shared_field_names_cache', None) is None:
            self._shared_field_names_cache = self._meta.get_all_field_names()
        return self._shared_field_names_cache
    @property
    def _translated_field_names(self):
        if getattr(self, '_translated_field_names_cache', None) is None:
            self._translated_field_names_cache = self._meta.translations_model._meta.get_all_field_names()
        return self._translated_field_names_cache

########NEW FILE########
__FILENAME__ = abstract
# -*- coding: utf-8 -*-
from hvad.test_utils.context_managers import LanguageOverride
from hvad.test_utils.testcase import HvadTestCase
from hvad.test_utils.project.app.models import (Normal, ConcreteAB, ConcreteABProxy)
from hvad.test_utils.fixtures import TwoTranslatedConcreteABMixin
from hvad.test_utils.data import DOUBLE_NORMAL

class AbstractTests(HvadTestCase, TwoTranslatedConcreteABMixin):
    def setUp(self):
        super(AbstractTests, self).setUp()
        self.normal1 = Normal.objects.language('en').get(shared_field=DOUBLE_NORMAL[1]['shared_field'])
        self.normal2 = Normal.objects.language('en').get(shared_field=DOUBLE_NORMAL[2]['shared_field'])

    def test_filter_and_iter(self):
        with LanguageOverride('en'):
            with self.assertNumQueries(1):
                qs = (ConcreteAB.objects.language()
                                        .filter(shared_field_a__startswith='Shared')
                                        .order_by('shared_field_a'))
                self.assertEqual(len(qs), 2)
            with self.assertNumQueries(0):
                self.assertEqual([obj.shared_field_b_id for obj in qs],
                                 [self.normal1.pk, self.normal2.pk])
                self.assertEqual([obj.shared_field_ab for obj in qs],
                                 [DOUBLE_NORMAL[1]['shared_field'], DOUBLE_NORMAL[2]['shared_field']])
                self.assertEqual([obj.translated_field_b for obj in qs],
                                 [DOUBLE_NORMAL[1]['translated_field_en'],
                                  DOUBLE_NORMAL[2]['translated_field_en']])
                self.assertEqual([obj.translated_field_ab for obj in qs],
                                 [DOUBLE_NORMAL[1]['translated_field_en'],
                                  DOUBLE_NORMAL[2]['translated_field_en']])
            with self.assertNumQueries(2): # this was not prefetched
                self.assertEqual([obj.translated_field_a.pk for obj in qs],
                                 [self.normal1.pk, self.normal1.pk])

        qs = qs.all()   # discard cached results
        with LanguageOverride('ja'):
            with self.assertNumQueries(1):
                self.assertEqual(len(qs), 2)
            with self.assertNumQueries(0):
                self.assertEqual([obj.translated_field_b for obj in qs],
                                 [DOUBLE_NORMAL[1]['translated_field_ja'],
                                  DOUBLE_NORMAL[2]['translated_field_ja']])
                self.assertEqual([obj.translated_field_ab for obj in qs],
                                 [DOUBLE_NORMAL[1]['translated_field_ja'],
                                  DOUBLE_NORMAL[2]['translated_field_ja']])
            with self.assertNumQueries(2): # this was not prefetched
                self.assertEqual([obj.translated_field_a.pk for obj in qs],
                                 [self.normal2.pk, self.normal2.pk])

    def test_select_related(self):
        with LanguageOverride('en'):
            qs = (ConcreteAB.objects.language()
                                    .select_related('shared_field_b', 'translated_field_a')
                                    .filter(shared_field_ab=DOUBLE_NORMAL[2]['shared_field']))
            # does it work?
            with self.assertNumQueries(1):
                self.assertEqual(qs.count(), 1)
            with self.assertNumQueries(1):
                self.assertEqual(len(qs), 1)
                obj = qs[0]
            # does it actually cache stuff?
            with self.assertNumQueries(0):
                self.assertEqual(obj.shared_field_b.translated_field, DOUBLE_NORMAL[2]['translated_field_en'])
                self.assertEqual(obj.translated_field_a.translated_field, DOUBLE_NORMAL[1]['translated_field_en'])

    def test_proxy(self):
        obj = (ConcreteABProxy.objects.language('en')
                                      .get(shared_field_a=DOUBLE_NORMAL[1]['shared_field']))
        self.assertTrue(isinstance(obj, ConcreteABProxy))
        self.assertTrue(str(obj).startswith('proxied'))

########NEW FILE########
__FILENAME__ = admin
# -*- coding: utf-8 -*-
import django
from django.conf import settings
from django.contrib import admin
from django.contrib.auth.models import User
from django.core.urlresolvers import reverse
from django.http import HttpResponseForbidden, HttpResponseRedirect
from hvad.admin import InlineModelForm
from hvad.admin import translatable_modelform_factory
from hvad.forms import TranslatableModelForm
from hvad.test_utils.context_managers import LanguageOverride
from hvad.test_utils.fixtures import (TwoTranslatedNormalMixin, SuperuserMixin, 
    OneSingleTranslatedNormalMixin)
from hvad.test_utils.request_factory import RequestFactory
from hvad.test_utils.testcase import HvadTestCase, minimumDjangoVersion
from hvad.test_utils.project.app.models import Normal, SimpleRelated, Other, AutoPopulated

PREFETCH_RELATED = (django.VERSION >= (1, 4))

class BaseAdminTests(object):
    def _get_admin(self, model):
        return admin.site._registry[model]


class NormalAdminTests(HvadTestCase, BaseAdminTests, SuperuserMixin):

    def test_lazy_translation_getter(self):
        danish_string = u"rød grød med fløde"
        slovenian_string = u'pozdravčki čćžđš'
        normal = Normal.objects.language("da").create(
            shared_field = "shared field",
            translated_field = danish_string,
        )
        normal_si = Normal.objects.get(pk=normal.pk).translate('sl')
        normal_si.translated_field = slovenian_string
        normal_si.save()
        
        english_string = u'English test string'
        Normal.objects.language("en").create(
            shared_field = "shared field",
            translated_field = english_string,
        )
        default_si = Normal.objects.get(pk=normal.pk).translate('us-en')
        default_si.translated_field = english_string
        default_si.save()

        Other.objects.create(normal=normal)
        self.assertEqual(normal.lazy_translation_getter("translated_field"), danish_string)

        with LanguageOverride('da'):
            n2 =  Normal.objects.get(pk=normal.pk)
            self.assertEqual(n2.safe_translation_getter("translated_field"), None)
            self.assertEqual(n2.lazy_translation_getter("translated_field"), danish_string)
            self.assertEqual(n2.safe_translation_getter("translated_field"), danish_string)

        with LanguageOverride('sl'):
            n2 =  Normal.objects.get(pk=normal.pk)
            self.assertEqual(n2.safe_translation_getter("translated_field"), None)
            self.assertEqual(n2.lazy_translation_getter("translated_field"), slovenian_string)
            self.assertEqual(n2.safe_translation_getter("translated_field"), slovenian_string)
        
        # This tests a langauge that we do not currently have, so don't add Japanese translations, please.
        with LanguageOverride('jp'):
            n2 = Normal.objects.get(pk=normal.pk)
            self.assertEqual(n2.safe_translation_getter("translated_field"), None)
            value = n2.lazy_translation_getter("translated_field")
            # since we didn't configure fallbacks, this could be any of th above.
            possible_values = [english_string, slovenian_string, danish_string]
            self.assertTrue(value in possible_values, "%s not in %r" % (value, possible_values))
            # This should work because when 'jp' isn't found, it will then try
            # the default language, which is en, in this case.
            self.assertEqual(n2.safe_translation_getter("translated_field"), value)

    def test_all_translations(self):
        # Create an unstranslated model and get the translations
        myadmin = self._get_admin(Normal)
        obj = Normal.objects.untranslated().create(
            shared_field="shared",
        )
        self.assertEqual(myadmin.all_translations(obj), "")
        
        # Create a english translated model and make sure the active language
        # is highlighted in admin with <strong></strong>
        obj = Normal.objects.language("en").create(
            shared_field="shared",
        )

        # Get the object back from db to test the use of prefetch_related
        qs = Normal.objects.language('en')
        if PREFETCH_RELATED:
            qs = qs.prefetch_related('translations')
        obj = qs.get(pk=obj.pk)
        with LanguageOverride('en'):
            with self.assertNumQueries(0 if PREFETCH_RELATED else 2):
                self.assertTrue(myadmin.all_translations(obj).find("<strong>") != -1)
                # Entries should be linked to the corresponding translation page
                self.assertTrue(myadmin.all_translations(obj).find("?language=en") != -1)

        with LanguageOverride('ja'):
            with self.assertNumQueries(0 if PREFETCH_RELATED else 1):
                self.assertTrue(myadmin.all_translations(obj).find("<strong>") == -1)

        # An unsaved object, shouldn't have any translations
        
        obj = Normal()
        self.assertEqual(myadmin.all_translations(obj), "")

    def test_get_available_languages(self):
        en = Normal.objects.language('en').create(shared_field='shared',
                                                  translated_field='english')
        admin = self._get_admin(Normal)
        self.assertEqual(list(admin.get_available_languages(en)), ['en'])
        self.assertEqual(list(admin.get_available_languages(None)), [])
            
    def test_get_object(self):
        # Check if it returns a model, if there is at least one translation
        myadmin = self._get_admin(Normal)
        rf = RequestFactory()
        get_request = rf.get('/admin/app/normal/')
        
        obj = Normal.objects.language("en").create(
            shared_field="shared",
            translated_field="translated_en",
        )
        with LanguageOverride('en'):
            self.assertEqual(myadmin.get_object(get_request, obj.pk).pk, obj.pk)
            self.assertEqual(myadmin.get_object(get_request, obj.pk).shared_field, obj.shared_field)
            self.assertEqual(myadmin.get_object(get_request, obj.pk).language_code, 'en')
            self.assertEqual(myadmin.get_object(get_request, obj.pk).translated_field, obj.translated_field)

        with LanguageOverride('ja'):
            self.assertEqual(myadmin.get_object(get_request, obj.pk).pk, obj.pk)
            self.assertEqual(myadmin.get_object(get_request, obj.pk).shared_field, obj.shared_field)
            self.assertEqual(myadmin.get_object(get_request, obj.pk).language_code, 'ja')
            self.assertEqual(myadmin.get_object(get_request, obj.pk).translated_field, '')

        # Check what happens if there is no translations at all
        obj = Normal.objects.untranslated().create(
            shared_field="shared",
        )
        with LanguageOverride('ja'):
            self.assertEqual(myadmin.get_object(get_request, obj.pk).pk, obj.pk)
            self.assertEqual(myadmin.get_object(get_request, obj.pk).shared_field, obj.shared_field)
            self.assertEqual(myadmin.get_object(get_request, obj.pk).language_code, 'ja')
            self.assertEqual(myadmin.get_object(get_request, obj.pk).translated_field, '')

            
    def test_get_object_nonexisting(self):
        # In case the object doesnt exist, it should return None
        myadmin = self._get_admin(Normal)
        rf = RequestFactory()
        get_request = rf.get('/admin/app/normal/')
        
        self.assertEqual(myadmin.get_object(get_request, 1231), None)
            
    def test_admin_simple(self):
        with LanguageOverride('en'):
            with self.login_user_context(username='admin', password='admin'):
                SHARED = 'shared'
                TRANS = 'trans'
                url = reverse('admin:app_normal_add')
                data = {
                    'shared_field': SHARED,
                    'translated_field': TRANS,
                    'simplerel-TOTAL_FORMS': '0',
                    'simplerel-INITIAL_FORMS': '0',
                    'simplerel-MAX_NUM_FORMS': '0',
                }
                response = self.client.post(url, data)
                self.assertEqual(response.status_code, 302)
                self.assertEqual(Normal.objects.count(), 1)
                obj = Normal.objects.language('en')[0]
                self.assertEqual(obj.shared_field, SHARED)
                self.assertEqual(obj.translated_field, TRANS)

    def test_admin_auto_populated(self):
        """
        This only works if we create the translation attribute before saving
        the instance. Otherwise the overridden save() method can't access the
        translated field during the initial save(), and it crashes.
        """

        with LanguageOverride('en'):
            with self.login_user_context(username='admin', password='admin'):
                danish_string = u"rød grød med fløde"
                url = reverse('admin:app_autopopulated_add')
                data = {
                    'translated_name': danish_string,
                }
                response = self.client.post(url, data)
                if response.status_code != 302:
                    self.assertEqual(response.status_code, 302,
                        "Response was unexpectedly not a redirect: %s" %
                        response.context['adminform'].form.errors)
                self.assertEqual(AutoPopulated.objects.count(), 1)
                obj = AutoPopulated.objects.language('en')[0]
                self.assertEqual(obj.translated_name, danish_string)
                self.assertEqual(obj.slug, "rd-grd-med-flde")
    
    def test_admin_change_form_title(self):
        with LanguageOverride('en'):
            with self.login_user_context(username='admin', password='admin'):
                obj = Normal.objects.language('en').create(
                    shared_field="shared",
                    translated_field='English',
                )
                url = reverse('admin:app_normal_change', args=(obj.pk,))
                response = self.client.get(url)
                self.assertEqual(response.status_code, 200)
                self.assertTrue('en' in response.content.decode('utf-8'))

    def test_admin_change_form_language_tabs_urls(self):
        with LanguageOverride('en'):
            with self.login_user_context(username='admin', password='admin'):
                obj = Normal.objects.language('en').create(
                    shared_field="shared",
                    translated_field='English',
                )
                get_url = reverse('admin:app_normal_change', args=(obj.pk,))
                response = self.client.get(get_url)
                self.assertEqual(response.status_code, 200)
                tabs = response.context['language_tabs']

                from hvad.compat.urls import urlencode
                for actual_tab_url, name, key, status in tabs:
                    expected_tab_url = '%s?%s' % (get_url,
                        urlencode({'language': key}))
                    self.assertEqual(expected_tab_url, actual_tab_url)
    
    def test_admin_change_form_redirect_add_another(self):
        lang = 'en'
        with LanguageOverride('ja'):
            with self.login_user_context(username='admin', password='admin'):
                obj = Normal.objects.language(lang).create(
                    shared_field="shared",
                    translated_field='English',
                )
                url = '%s?language=%s' % (reverse('admin:app_normal_change', args=(obj.pk,)), lang)
                data = {
                    'translated_field': 'English NEW',
                    'shared_field': obj.shared_field,
                    '_addanother': '1',
                    
                    'simplerel-TOTAL_FORMS': '0',
                    'simplerel-INITIAL_FORMS': '0',
                    'simplerel-MAX_NUM_FORMS': '0',
                }

                response = self.client.post(url, data)
                self.assertEqual(response.status_code, 302, response.content)
                expected_url = '%s?language=%s' % (reverse('admin:app_normal_add'), lang)
                self.assertTrue(response['Location'].endswith(expected_url))
                obj = Normal.objects.language('en').get(pk=obj.pk)
                self.assertEqual(obj.translated_field, "English NEW")
    
    def test_admin_change_form_redirect_continue_edit(self):
        lang = 'en'
        with LanguageOverride('ja'):
            with self.login_user_context(username='admin', password='admin'):
                obj = Normal.objects.language(lang).create(
                    shared_field="shared",
                    translated_field='English',
                )
                url = '%s?language=%s' % (reverse('admin:app_normal_change', args=(obj.pk,)), lang)
                data = {
                    'translated_field': 'English NEW',
                    'shared_field': obj.shared_field,
                    '_continue': '1',
                    'simplerel-TOTAL_FORMS': '0',
                    'simplerel-INITIAL_FORMS': '0',
                    'simplerel-MAX_NUM_FORMS': '0',
                }
                response = self.client.post(url, data)
                self.assertEqual(response.status_code, 302, response.content)
                self.assertTrue(response['Location'].endswith(url))
                obj = Normal.objects.language('en').get(pk=obj.pk)
                self.assertEqual(obj.translated_field, "English NEW")
                url2 = reverse('admin:app_normal_change', args=(obj.pk,))
                data = {
                    'translated_field': 'Japanese',
                    'shared_field': obj.shared_field,
                    '_continue': '1',
                    'simplerel-TOTAL_FORMS': '0',
                    'simplerel-INITIAL_FORMS': '0',
                    'simplerel-MAX_NUM_FORMS': '0',
                }
                response = self.client.post(url2, data)
                self.assertEqual(response.status_code, 302, response.content)
                self.assertTrue(response['Location'].endswith(url2))
                obj = Normal.objects.language('ja').get(pk=obj.pk)
                self.assertEqual(obj.translated_field, "Japanese")
                obj = Normal.objects.language('en').get(pk=obj.pk)
                self.assertEqual(obj.translated_field, "English NEW")
    
    def test_admin_change_form(self):
        lang = 'en'
        with LanguageOverride(lang):
            with self.login_user_context(username='admin', password='admin'):
                obj = Normal.objects.language(lang).create(
                    shared_field="shared",
                    translated_field='English',
                )
                url = reverse('admin:app_normal_change', args=(obj.pk,))
                data = {
                    'translated_field': 'English NEW',
                    'shared_field': obj.shared_field,
                    'simplerel-TOTAL_FORMS': '0',
                    'simplerel-INITIAL_FORMS': '0',
                    'simplerel-MAX_NUM_FORMS': '0',
                }
                response = self.client.post(url, data)
                expected_url = reverse('admin:app_normal_changelist')
                self.assertEqual(response.status_code, 302, response.content)
                self.assertTrue(response['Location'].endswith(expected_url))
                obj = Normal.objects.language('en').get(pk=obj.pk)
                self.assertEqual(obj.translated_field, "English NEW")
    
    def test_admin_dual(self):
        SHARED = 'shared'
        TRANS_EN = 'English'
        TRANS_JA = u'日本語'
        with self.login_user_context(username='admin', password='admin'):
            url = reverse('admin:app_normal_add')
            data_en = {
                'shared_field': SHARED,
                'translated_field': TRANS_EN,
                'simplerel-TOTAL_FORMS': '0',
                'simplerel-INITIAL_FORMS': '0',
                'simplerel-MAX_NUM_FORMS': '0',
            }
            data_ja = {
                'shared_field': SHARED,
                'translated_field': TRANS_JA,
                'simplerel-TOTAL_FORMS': '0',
                'simplerel-INITIAL_FORMS': '0',
                'simplerel-MAX_NUM_FORMS': '0',
            }
            with LanguageOverride('en'):
                response = self.client.post(url, data_en)
                self.assertEqual(response.status_code, 302)
                self.assertEqual(Normal.objects.count(), 1)
            with LanguageOverride('ja'):
                response = self.client.post(url, data_ja)
                self.assertEqual(response.status_code, 302)
                self.assertEqual(Normal.objects.count(), 2)
            en = Normal.objects.language('en').get()
            self.assertEqual(en.shared_field, SHARED)
            self.assertEqual(en.translated_field, TRANS_EN)
            ja = Normal.objects.language('ja').get()
            self.assertEqual(ja.shared_field, SHARED)
            self.assertEqual(ja.translated_field, TRANS_JA)
    
    def test_admin_with_param(self):
        with LanguageOverride('ja'):
            with self.login_user_context(username='admin', password='admin'):
                SHARED = 'shared'
                TRANS = 'trans'
                url = reverse('admin:app_normal_add')
                data = {
                    'shared_field': SHARED,
                    'translated_field': TRANS,
                    'simplerel-TOTAL_FORMS': '0',
                    'simplerel-INITIAL_FORMS': '0',
                    'simplerel-MAX_NUM_FORMS': '0',
                }
                response = self.client.post("%s?language=en" % url, data)
                self.assertEqual(response.status_code, 302)
                self.assertEqual(Normal.objects.count(), 1)
                obj = Normal.objects.language('en')[0]
                self.assertEqual(obj.shared_field, SHARED)
                self.assertEqual(obj.translated_field, TRANS)
    

class AdminEditTests(HvadTestCase, BaseAdminTests, TwoTranslatedNormalMixin,
                     SuperuserMixin):
    def test_changelist(self):
        url = reverse('admin:app_normal_changelist')
        request = self.request_factory.get(url)
        normaladmin = self._get_admin(Normal)
        with LanguageOverride('en'):
            if django.VERSION >= (1, 6):
                queryset = normaladmin.get_queryset(request)
            else:
                queryset = normaladmin.queryset(request)
            self.assertEqual(queryset.count(), 2)


class AdminDeleteTranslationsTests(HvadTestCase, BaseAdminTests, SuperuserMixin):
    def test_delete_last_translation(self):
        en = Normal.objects.language('en').create(shared_field='shared',
                                                  translated_field='english')
        url = reverse('admin:app_normal_delete_translation', args=(en.pk, 'en'))
        with self.login_user_context(username='admin', password='admin'):
            response = self.client.get(url)
            self.assertEqual(response.status_code, 200)
            self.assertTemplateUsed(response, 'admin/hvad/deletion_not_allowed.html')
        self.assertTrue(Normal.objects.language('en').get(pk=en.pk))
            
    def test_delete_translation_get(self):
        en = Normal.objects.language('en').create(shared_field='shared',
                                                  translated_field='english')
        ja = en.translate('ja')
        ja.translated_field = 'japanese'
        ja.save()
        url = reverse('admin:app_normal_delete_translation', args=(en.pk, 'en'))
        
        with self.login_user_context(username='admin', password='admin'):
            response = self.client.get(url)
            self.assertEqual(response.status_code, 200)
            self.assertTemplateUsed(response, 'admin/delete_confirmation.html')
        self.assertTrue(Normal.objects.language('en').get(pk=en.pk))
        self.assertTrue(Normal.objects.language('ja').get(pk=ja.pk))
    
    def test_delete_translation_post(self):
        en = Normal.objects.language('en').create(shared_field='shared',
                                                  translated_field='english')
        ja = en.translate('ja')
        ja.translated_field = 'japanese'
        ja.save()
        url = reverse('admin:app_normal_delete_translation', args=(en.pk, 'en'))
        
        with self.login_user_context(username='admin', password='admin'):
            response = self.client.post(url, {'post': 'yes'})
            self.assertEqual(response.status_code, HttpResponseRedirect.status_code)
        self.assertRaises(Normal.DoesNotExist, Normal.objects.language('en').get, pk=en.pk)
        self.assertTrue(Normal.objects.language('ja').get(pk=ja.pk))
    
    def test_delete_translation_no_obj(self):
        url = reverse('admin:app_normal_delete_translation', args=(1, 'en'))
        
        with self.login_user_context(username='admin', password='admin'):
            response = self.client.get(url)
            self.assertEqual(response.status_code, 404)
    
    def test_delete_no_perms(self):
        user = User(username='staff', is_active=True, is_staff=True)
        user.set_password('staff')
        user.save()
        
        en = Normal.objects.language('en').create(shared_field='shared',
                                                  translated_field='english')
        ja = en.translate('ja')
        ja.translated_field = 'japanese'
        ja.save()
        url = reverse('admin:app_normal_delete_translation', args=(en.pk, 'en'))
        
        with self.login_user_context(username='staff', password='staff'):
            response = self.client.get(url)
            self.assertEqual(response.status_code, HttpResponseForbidden.status_code)


class AdminNoFixturesTests(HvadTestCase, BaseAdminTests):
    def test_language_tabs(self):
        obj = Normal.objects.language("en").create(shared_field="shared",
                                                   translated_field="english")
        url = reverse('admin:app_normal_change', args=(1,))
        request = self.request_factory.get(url)
        normaladmin = self._get_admin(Normal)
        available_languages = []
        if obj:
            available_languages = obj.get_available_languages()
        tabs = normaladmin.get_language_tabs(request, available_languages)
        languages = settings.LANGUAGES
        self.assertEqual(len(languages), len(tabs))
        for tab, lang in zip(tabs, languages):
            _, tab_name, _, status = tab
            _, lang_name = lang
            self.assertEqual(tab_name, lang_name)
            if lang == "en":
                self.assertEqual(status, 'current')
            elif lang == "ja":
                self.assertEqual(status, 'available')
                
        with self.assertNumQueries(0):
            with LanguageOverride('en'):
                normaladmin.get_language_tabs(request, [])

    def test_get_change_form_base_template(self):
        normaladmin = self._get_admin(Normal)
        template = normaladmin.get_change_form_base_template()
        self.assertEqual(template, 'admin/change_form.html')
        
    def test_translatable_modelform_factory(self):
        t = translatable_modelform_factory('en', Normal, fields=['shared_field'], exclude=['id'])
        self.assertEqual(t.Meta.fields, ['shared_field'])
        self.assertEqual(t.Meta.exclude, ['id', 'language_code'])
        
        t = translatable_modelform_factory('en', Normal, fields=['shared_field'], exclude=['id'])
        self.assertEqual(t.Meta.fields, ['shared_field'])
        self.assertEqual(t.Meta.exclude, ['id', 'language_code'])
        
        class TestForm(TranslatableModelForm):
            class Meta:
                fields = ['shared_field'] 
                exclude = ['id']
               
        t = translatable_modelform_factory('en', Normal, form=TestForm)
        self.assertEqual(t.Meta.fields, ['shared_field'])
        self.assertEqual(t.Meta.exclude, ['id', 'language_code'])
        

class AdminRelationTests(HvadTestCase, BaseAdminTests, SuperuserMixin,
                         OneSingleTranslatedNormalMixin):
    def test_adding_related_object(self):
        url = reverse('admin:app_simplerelated_add')
        expected_url = reverse('admin:app_simplerelated_change', args=(1,))
        TRANS_FIELD = "English Content" 
        with LanguageOverride('en'):
            en = Normal.objects.all()[0]
            with self.login_user_context(username='admin', password='admin'):
                data = {
                    'normal': en.pk,
                    'translated_field': TRANS_FIELD,
                    '_continue': '1',
                }
                response = self.client.post(url, data)
                self.assertRedirects(response, expected_url)
            
            simplerel = SimpleRelated.objects.all()[0]
            self.assertEqual(simplerel.normal.pk, en.pk)
            self.assertEqual(simplerel.translated_field, TRANS_FIELD)


@minimumDjangoVersion(1, 4)
class TranslatableInlineAdminTests(HvadTestCase, BaseAdminTests, SuperuserMixin):
    def test_correct_id_in_inline(self):
        LANGUAGES = (
            ('en', u'English'),
            ('fr', u'Français'),
            ('da', u'Dansk'),
            ('ja', u'日本語'),
        )
        with self.settings(LANGUAGES=LANGUAGES):
            with LanguageOverride('en'):
                normal = Normal.objects.language().create(shared_field="whatever1", translated_field="whatever in another language1")
                normal2 = Normal.objects.language().create(shared_field="whatever2", translated_field="whatever in another language2")
                normal3 = Normal.objects.language().create(shared_field="whatever3", translated_field="whatever in another language3")

            simple1 = SimpleRelated.objects.language("en").create(normal=normal3, translated_field="inline whatever translated")

            simple1.translate("ja")
            simple1.translated_field ="japanese stuff"
            simple1.save()

            simple1.translate("fr")
            simple1.translated_field ="french stuff"
            simple1.save()

            simple1.translate("da")
            simple1.translated_field ="danish stuff"
            simple1.save()


            with LanguageOverride('da'):
                instance = SimpleRelated.objects.get(pk=simple1.pk)
                class ExampleInlineForm(InlineModelForm):
                    class Meta:
                        model = SimpleRelated
                        exclude = []
                form = ExampleInlineForm(instance=instance)

                self.assertTrue(form.initial["id"] == instance.id)

########NEW FILE########
__FILENAME__ = basic
# -*- coding: utf-8 -*-
from __future__ import with_statement
import django
from django.core.exceptions import ImproperlyConfigured
from django.db.models.manager import Manager
from django.db.models.query_utils import Q
from hvad.manager import TranslationManager
from hvad.models import TranslatableModelBase, TranslatableModel
from hvad.test_utils.context_managers import LanguageOverride
from hvad.test_utils.data import DOUBLE_NORMAL
from hvad.test_utils.fixtures import (OneSingleTranslatedNormalMixin, 
    TwoTranslatedNormalMixin)
from hvad.test_utils.testcase import HvadTestCase, minimumDjangoVersion
from hvad.test_utils.project.app.models import Normal, MultipleFields, Boolean
from hvad.test_utils.project.alternate_models_app.models import NormalAlternate


class InvalidModel2(object):
    objects = TranslationManager()


class DefinitionTests(HvadTestCase):
    def test_invalid_manager(self):
        attrs = {
            'objects': Manager(),
            '__module__': 'hvad.test_utils.project.app',
        }
        self.assertRaises(ImproperlyConfigured, TranslatableModelBase,
                          'InvalidModel', (TranslatableModel,), attrs)
    
    def test_no_translated_fields(self):
        attrs = dict(InvalidModel2.__dict__)
        del attrs['__dict__']
        del attrs['__weakref__']
        bases = (TranslatableModel,InvalidModel2,)
        self.assertRaises(ImproperlyConfigured, TranslatableModelBase,
                          'InvalidModel2', bases, attrs)
    
    def test_abstract_base_model(self):
        class Meta:
            abstract = True
        attrs = {
            'Meta': Meta,
            '__module__': 'hvad.test_utils.project.app',
        }
        model = TranslatableModelBase('MyBaseModel', (TranslatableModel,), attrs)
        self.assertTrue(model._meta.abstract)


class OptionsTest(HvadTestCase):
    def test_options(self):
        opts = Normal._meta
        self.assertTrue(hasattr(opts, 'translations_model'))
        self.assertTrue(hasattr(opts, 'translations_accessor'))
        relmodel = Normal._meta.get_field_by_name(opts.translations_accessor)[0].model
        self.assertEqual(relmodel, opts.translations_model)


class AlternateCreateTest(HvadTestCase):
    def test_create_instance_simple(self):
        obj = NormalAlternate(language_code='en')
        obj.shared_field = "shared"
        obj.translated_field = "English"
        obj.save()
        en = NormalAlternate.objects.language('en').get(pk=obj.pk)
        self.assertEqual(en.shared_field, "shared")
        self.assertEqual(en.translated_field, "English")
        self.assertEqual(en.language_code, "en")
    

class CreateTest(HvadTestCase):
    def test_create(self):
        with self.assertNumQueries(2):
            en = Normal.objects.language('en').create(
                shared_field="shared",
                translated_field='English',
            )
        self.assertEqual(en.shared_field, "shared")
        self.assertEqual(en.translated_field, "English")
        self.assertEqual(en.language_code, "en")
    
    def test_invalid_instantiation(self):
        self.assertRaises(RuntimeError, Normal, master=None)
    
    def test_create_nolang(self):
        with self.assertNumQueries(2):
            with LanguageOverride('en'):
                en = Normal.objects.create(
                    shared_field="shared",
                    translated_field='English',
                )
        self.assertEqual(en.shared_field, "shared")
        self.assertEqual(en.translated_field, "English")
        self.assertEqual(en.language_code, "en")
    
    def test_create_instance_simple(self):
        obj = Normal(language_code='en')
        obj.shared_field = "shared"
        obj.translated_field = "English"
        obj.save()
        en = Normal.objects.language('en').get(pk=obj.pk)
        self.assertEqual(en.shared_field, "shared")
        self.assertEqual(en.translated_field, "English")
        self.assertEqual(en.language_code, "en")
        
    def test_create_instance_shared(self):
        obj = Normal(language_code='en', shared_field = "shared")
        obj.save()
        en = Normal.objects.language('en').get(pk=obj.pk)
        self.assertEqual(en.shared_field, "shared")
        self.assertEqual(en.language_code, "en")
        
    def test_create_instance_translated(self):
        obj = Normal(language_code='en', translated_field = "English")
        obj.save()
        en = Normal.objects.language('en').get(pk=obj.pk)
        self.assertEqual(en.translated_field, "English")
        self.assertEqual(en.language_code, "en")
    
    def test_create_instance_both(self):
        obj = Normal(language_code='en', shared_field = "shared",
                     translated_field = "English")
        obj.save()
        en = Normal.objects.language('en').get(pk=obj.pk)
        self.assertEqual(en.shared_field, "shared")
        self.assertEqual(en.translated_field, "English")
        self.assertEqual(en.language_code, "en")
        
    def test_create_instance_simple_nolang(self):
        with LanguageOverride('en'):
            obj = Normal(language_code='en')
            obj.shared_field = "shared"
            obj.translated_field = "English"
            obj.save()
            en = Normal.objects.language('en').get(pk=obj.pk)
            self.assertEqual(en.shared_field, "shared")
            self.assertEqual(en.translated_field, "English")
            self.assertEqual(en.language_code, "en")
        
    def test_create_instance_shared_nolang(self):
        with LanguageOverride('en'):
            obj = Normal(language_code='en', shared_field = "shared")
            obj.save()
            en = Normal.objects.language('en').get(pk=obj.pk)
            self.assertEqual(en.shared_field, "shared")
            self.assertEqual(en.language_code, "en")
        
    def test_create_instance_translated_nolang(self):
        with LanguageOverride('en'):
            obj = Normal(language_code='en', translated_field = "English")
            obj.save()
            en = Normal.objects.language('en').get(pk=obj.pk)
            self.assertEqual(en.translated_field, "English")
            self.assertEqual(en.language_code, "en")
    
    def test_create_instance_both_nolang(self):
        with LanguageOverride('en'):
            obj = Normal(language_code='en', shared_field = "shared",
                         translated_field = "English")
            obj.save()
            en = Normal.objects.language('en').get(pk=obj.pk)
            self.assertEqual(en.shared_field, "shared")
            self.assertEqual(en.translated_field, "English")
            self.assertEqual(en.language_code, "en")

    def test_create_instance_untranslated(self):
        with self.assertNumQueries(1):
            with LanguageOverride('en'):
                ut = Normal.objects.create(
                    shared_field="shared",
                )
        self.assertEqual(ut.shared_field, "shared")
        with self.assertNumQueries(1):
            with self.assertRaises(AttributeError):
                ut.translated_field
        with self.assertNumQueries(1):
            with self.assertRaises(AttributeError):
                ut.language_code


class TranslatedTest(HvadTestCase, OneSingleTranslatedNormalMixin):
    def test_translate(self):
        SHARED_EN = 'shared'
        TRANS_EN = 'English'
        SHARED_JA = 'shared'
        TRANS_JA = u'日本語'
        en = Normal.objects.language('en').get(pk=1)
        self.assertEqual(Normal._meta.translations_model.objects.count(), 1)
        self.assertEqual(en.shared_field, SHARED_EN)
        self.assertEqual(en.translated_field, TRANS_EN)
        ja = en
        ja.translate('ja')
        ja.save()
        self.assertEqual(Normal._meta.translations_model.objects.count(), 2)
        self.assertEqual(ja.shared_field, SHARED_JA)
        self.assertEqual(ja.translated_field, '')
        ja.translated_field = TRANS_JA
        ja.save()
        self.assertEqual(Normal._meta.translations_model.objects.count(), 2)
        self.assertEqual(ja.shared_field, SHARED_JA)
        self.assertEqual(ja.translated_field, TRANS_JA)
        with LanguageOverride('en'):
            obj = self.reload(ja)
            self.assertEqual(obj.shared_field, SHARED_EN)
            self.assertEqual(obj.translated_field, TRANS_EN)
        with LanguageOverride('ja'):
            obj = self.reload(en)
            self.assertEqual(obj.shared_field, SHARED_JA)
            self.assertEqual(obj.translated_field, TRANS_JA)
        

class GetTest(HvadTestCase, OneSingleTranslatedNormalMixin):
    def test_get(self):
        en = Normal.objects.language('en').get(pk=1)
        with self.assertNumQueries(1):
            got = Normal.objects.language('en').get(pk=en.pk)
        with self.assertNumQueries(0):
            self.assertEqual(got.shared_field, "shared")
            self.assertEqual(got.translated_field, "English")
            self.assertEqual(got.language_code, "en")

    def test_filtered_get(self):
        obj = Normal(shared_field='field_1')
        obj.translate('en')
        obj.translated_field = 'field_2'
        obj.save()
        qs = Normal.objects.language('en') | Normal.objects.language('de')
        found = qs.filter(shared_field='field_1').get(pk=obj.pk)
        self.assertEqual(found.pk, obj.pk)
    
    def test_safe_translation_getter(self):
        untranslated = Normal.objects.untranslated().get(pk=1)
        with LanguageOverride('en'):
            self.assertEqual(untranslated.safe_translation_getter('translated_field', None), None)
            Normal.objects.untranslated().get(pk=1)
            self.assertEqual(untranslated.safe_translation_getter('translated_field', "English"), "English")
        with LanguageOverride('ja'):
            self.assertEqual(untranslated.safe_translation_getter('translated_field', None), None)
            self.assertEqual(untranslated.safe_translation_getter('translated_field', "Test"), "Test")
        


class GetByLanguageTest(HvadTestCase, TwoTranslatedNormalMixin):
    
    def test_args(self):
        with LanguageOverride('en'):
            q = Q(language_code='ja', pk=1)
            obj = Normal.objects.using_translations().get(q)
            self.assertEqual(obj.shared_field, DOUBLE_NORMAL[1]['shared_field'])
            self.assertEqual(obj.translated_field, DOUBLE_NORMAL[1]['translated_field_ja'])
    
    def test_kwargs(self):
        with LanguageOverride('en'):
            kwargs = {'language_code':'ja', 'pk':1}
            obj = Normal.objects.using_translations().get(**kwargs)
            self.assertEqual(obj.shared_field, DOUBLE_NORMAL[1]['shared_field'])
            self.assertEqual(obj.translated_field, DOUBLE_NORMAL[1]['translated_field_ja'])
        
    def test_language(self):
        with LanguageOverride('en'):
            obj = Normal.objects.language('ja').get(pk=1)
            self.assertEqual(obj.shared_field, DOUBLE_NORMAL[1]['shared_field'])
            self.assertEqual(obj.translated_field, DOUBLE_NORMAL[1]['translated_field_ja'])


class GetAllLanguagesTest(HvadTestCase, TwoTranslatedNormalMixin):
    def test_args(self):
        with LanguageOverride('en'):
            q = Q(pk=1)
            with self.assertNumQueries(1):
                objs = Normal.objects.language('all').filter(q)
                self.assertEqual(len(objs), 2)
                self.assertCountEqual((1, 1), (objs[0].pk, objs[1].pk))
                self.assertCountEqual(('en', 'ja'), (objs[0].language_code, objs[1].language_code))

    def test_kwargs(self):
        with LanguageOverride('en'):
            kwargs = {'pk':1}
            with self.assertNumQueries(1):
                objs = Normal.objects.language('all').filter(**kwargs)
                self.assertEqual(len(objs), 2)
                self.assertCountEqual((1, 1), (objs[0].pk, objs[1].pk))
                self.assertCountEqual(('en', 'ja'), (objs[0].language_code, objs[1].language_code))

    def test_translated_unique(self):
        with LanguageOverride('en'):
            with self.assertNumQueries(1):
                obj = Normal.objects.language('all').get(translated_field=DOUBLE_NORMAL[1]['translated_field_ja'])
                self.assertEqual(obj.pk, 1)
                self.assertEqual(obj.language_code, 'ja')
                self.assertEqual(obj.shared_field, DOUBLE_NORMAL[1]['shared_field'])
                self.assertEqual(obj.translated_field, DOUBLE_NORMAL[1]['translated_field_ja'])

    def test_get_all_raises(self):
        with self.assertRaises(ValueError):
            Normal.objects.language('en').get(pk=1, language_code='all')


class BasicQueryTest(HvadTestCase, OneSingleTranslatedNormalMixin):
    def test_basic(self):
        en = Normal.objects.language('en').get(pk=1)
        with self.assertNumQueries(1):
            queried = Normal.objects.language('en').get(pk=en.pk)
            self.assertEqual(queried.shared_field, en.shared_field)
            self.assertEqual(queried.translated_field, en.translated_field)
            self.assertEqual(queried.language_code, en.language_code)


class DeleteLanguageCodeTest(HvadTestCase, OneSingleTranslatedNormalMixin):
    def test_delete_language_code(self):
        en = Normal.objects.language('en').get(pk=1)
        self.assertRaises(AttributeError, delattr, en, 'language_code')

                              
class DescriptorTests(HvadTestCase):
    def test_translated_attribute_set(self):
        # 'MyDescriptorTestModel' should return the default field value, in case there is no translation
        from hvad.models import TranslatedFields
        from django.db import models
        
        DEFAULT = 'world'
        class MyDescriptorTestModel(TranslatableModel):
            translations = TranslatedFields(
                hello = models.CharField(default=DEFAULT, max_length=128)
            )
        self.assertEqual(MyDescriptorTestModel.hello, DEFAULT)
    
    def test_translated_attribute_delete(self):    
        # Its not possible to delete the charfield, which should result in an AttributeError
        obj = Normal.objects.language("en").create(shared_field="test", translated_field="en")
        obj.save()
        self.assertEqual(obj.translated_field, "en")
        delattr(obj, 'translated_field')
        self.assertRaises(AttributeError, getattr, obj, 'translated_field')
    
    def test_languagecodeattribute(self):
        # Its not possible to set/delete a language code
        self.assertRaises(AttributeError, setattr, Normal(), 'language_code', "en")
        self.assertRaises(AttributeError, delattr, Normal(), 'language_code')


class TableNameTest(HvadTestCase):
    def test_table_name_separator(self):
        from hvad.models import TranslatedFields
        from django.db import models
        from django.conf import settings
        sep = getattr(settings, 'HVAD_TABLE_NAME_SEPARATOR', '_')
        class MyTableNameTestModel(TranslatableModel):
            translations = TranslatedFields(
                hello = models.CharField(max_length=128)
            )
        self.assertTrue(MyTableNameTestModel.translations.related.model._meta.db_table.endswith('_mytablenametestmodel%stranslation' % sep))

    @minimumDjangoVersion(1, 4)
    def test_table_name_override(self):
        from hvad.models import TranslatedFields
        from django.db import models
        with self.settings(HVAD_TABLE_NAME_SEPARATOR='O_O'):
            class MyOtherTableNameTestModel(TranslatableModel):
                translations = TranslatedFields(
                    hello = models.CharField(max_length=128)
                )
            self.assertTrue(MyOtherTableNameTestModel.translations.related.model._meta.db_table.endswith('_myothertablenametestmodelO_Otranslation'))

    @minimumDjangoVersion(1, 4)
    def test_table_name_override_rename(self):
        with self.assertThrowsWarning(DeprecationWarning, 1):
            with self.settings(NANI_TABLE_NAME_SEPARATOR='O_O'):
                pass

    def test_table_name_from_meta(self):
        from hvad.models import TranslatedFields
        from django.db import models
        class MyTableNameTestNamedModel(TranslatableModel):
            translations = TranslatedFields(
                hello = models.CharField(max_length=128),
                meta = {'db_table': 'tests_mymodel_i18n'},
            )
        self.assertEqual(MyTableNameTestNamedModel.translations.related.model._meta.db_table, 'tests_mymodel_i18n')


class GetOrCreateTest(HvadTestCase):
    def test_create_new_translatable_instance(self):
        with self.assertNumQueries(3 if django.VERSION < (1, 6) else 5):
            """
            1: get
            2a: savepoint (django >= 1.6)
            2b: create shared
            3a: create translation
            3b: release savepoint (django >= 1.6)
            """
            en, created = Normal.objects.language('en').get_or_create(
                shared_field="shared",
                defaults={'translated_field': 'English',},
            )
        self.assertTrue(created)
        self.assertEqual(en.shared_field, "shared")
        self.assertEqual(en.translated_field, "English")
        self.assertEqual(en.language_code, "en")

    def test_create_new_language(self):
        en = Normal.objects.language('en').create(
            shared_field="shared",
            translated_field='English',
        )
        with self.assertNumQueries(3 if django.VERSION < (1, 6) else 5):
            """
            1: get
            2a: savepoint (django >= 1.6)
            2b: create shared
            3a: create translation
            3b: release savepoint (django >= 1.6)
            """
            ja, created = Normal.objects.language('ja').get_or_create(
                shared_field="shared",
                defaults={'translated_field': u'日本語',},
            )
        self.assertTrue(created)
        self.assertEqual(ja.shared_field, "shared")
        self.assertEqual(ja.translated_field, u'日本語')
        self.assertEqual(ja.language_code, "ja")
        self.assertNotEqual(en.pk, ja.pk)

    def test_get_existing_language(self):
        Normal.objects.language('en').create(
            shared_field="shared",
            translated_field='English',
        )
        with self.assertNumQueries(1):
            """
            1: get
            """
            en, created = Normal.objects.language('en').get_or_create(
                shared_field="shared",
                defaults={'translated_field': 'x-English',},
            )
        self.assertFalse(created)
        self.assertEqual(en.shared_field, "shared")
        self.assertEqual(en.translated_field, "English")
        self.assertEqual(en.language_code, "en")

    # Evil starts here

    def test_split_params(self):
        en, created = Normal.objects.language('en').get_or_create(
            shared_field="shared",
            translated_field="English",
        )
        self.assertTrue(created)
        self.assertEqual(en.shared_field, "shared")
        self.assertEqual(en.translated_field, "English")
        self.assertEqual(en.language_code, "en")

    def test_split_params_shared_already_exists(self):
        Normal.objects.language('en').create(
            shared_field="shared",
            translated_field="English",
        )
        en, created = Normal.objects.language('en').get_or_create(
            shared_field="shared",
            translated_field="x-English"
        )
        self.assertTrue(created)

    def test_new_language_split_params(self):
        en = Normal.objects.language('en').create(
            shared_field="shared",
            translated_field="English",
        )
        ja, created = Normal.objects.language('ja').get_or_create(
            shared_field="shared",
            translated_field=u'日本語',
        )
        self.assertTrue(created)
        self.assertEqual(ja.shared_field, "shared")
        self.assertEqual(ja.translated_field, u'日本語')
        self.assertEqual(ja.language_code, "ja")
        self.assertNotEqual(en.pk, ja.pk)

    def test_split_defaults(self):
        en, created = MultipleFields.objects.language('en').get_or_create(
            first_shared_field="shared-one",
            first_translated_field='English-one',
            defaults={
                'second_shared_field': 'shared-two',
                'second_translated_field': 'English-two',
            }
        )
        self.assertTrue(created)
        self.assertEqual(en.first_shared_field, "shared-one")
        self.assertEqual(en.second_shared_field, "shared-two")
        self.assertEqual(en.first_translated_field, "English-one")
        self.assertEqual(en.second_translated_field, "English-two")
        self.assertEqual(en.language_code, "en")

    def test_new_language_split_defaults(self):
        en = MultipleFields.objects.language('en').create(
            first_shared_field="shared-one",
            second_shared_field='shared-two',
            first_translated_field='English-one',
            second_translated_field='English-two',
        )
        ja, created = MultipleFields.objects.language('ja').get_or_create(
            first_shared_field="shared-one",
            first_translated_field=u'日本語-一',
            defaults={
                'second_shared_field': 'x-shared-two',
                'second_translated_field': u'日本語-二',
            }
        )
        self.assertTrue(created)
        self.assertEqual(ja.first_shared_field, "shared-one")
        #self.assertEqual(ja.second_shared_field, "shared-two")
        self.assertEqual(ja.first_translated_field, u'日本語-一')
        self.assertEqual(ja.second_translated_field,  u'日本語-二')
        self.assertEqual(ja.language_code, "ja")
        self.assertNotEqual(en.pk, ja.pk)


class BooleanTests(HvadTestCase):
    def test_boolean_on_shared(self):
        Boolean.objects.language('en').create(shared_flag=True, translated_flag=False)
        en = Boolean.objects.language('en').get()
        self.assertEqual(en.shared_flag, True)
        self.assertEqual(en.translated_flag, False)

########NEW FILE########
__FILENAME__ = dates
import django
from hvad.test_utils.data import DATES_REVERSED, D1, D3
from hvad.test_utils.fixtures import DatesMixin
from hvad.test_utils.testcase import HvadTestCase, minimumDjangoVersion
from hvad.test_utils.project.app.models import Date
import datetime

class LatestTests(HvadTestCase, DatesMixin):
    def test_shared_latest(self):
        latest = Date.objects.language('en').latest('shared_date')
        self.assertEqual(latest.pk, DATES_REVERSED[D3]['shared_date'])

    def test_translated_latest(self):
        latest = Date.objects.language('en').latest('translated_date')
        self.assertEqual(latest.pk, DATES_REVERSED[D3]['translated_date_en'])
        latest = Date.objects.language('ja').latest('translated_date')
        self.assertEqual(latest.pk, DATES_REVERSED[D3]['translated_date_ja'])

    def test_default_latest(self):
        latest = Date.objects.language('en').latest()
        self.assertEqual(latest.pk, DATES_REVERSED[D3]['shared_date'])


@minimumDjangoVersion(1, 6)
class EarliestTests(HvadTestCase, DatesMixin):
    def test_shared_earliest(self):
        earliest = Date.objects.language('en').earliest('shared_date')
        self.assertEqual(earliest.pk, DATES_REVERSED[D1]['shared_date'])

    def test_translated_earliest(self):
        earliest = Date.objects.language('en').earliest('translated_date')
        self.assertEqual(earliest.pk, DATES_REVERSED[D1]['translated_date_en'])
        earliest = Date.objects.language('ja').earliest('translated_date')
        self.assertEqual(earliest.pk, DATES_REVERSED[D1]['translated_date_ja'])

    def test_default_earliest(self):
        earliest = Date.objects.language('en').earliest()
        self.assertEqual(earliest.pk, DATES_REVERSED[D1]['shared_date'])


class DatesTests(HvadTestCase, DatesMixin):
    def test_objects_dates(self):
        d2011 = datetime.date(year=2011, month=1, day=1)
        self.assertEqual(len(Date.objects.language('en').dates("shared_date", "year")), 2)
        self.assertEqual(len(Date.objects.language('en').dates("shared_date", "year").all()), 2)
        self.assertEqual(len(Date.objects.language('en').dates("shared_date", "month")), 3)
        self.assertEqual(len(Date.objects.language('en').dates("shared_date", "day")), 3)
        self.assertEqual(len(Date.objects.language('en').dates("shared_date", "day").filter(shared_date__gt=d2011)), 2)

class DatetimeTests(HvadTestCase, DatesMixin):
    if django.VERSION >= (1, 6):
        def test_object_datetimes(self):
            d2011 = datetime.date(year=2011, month=1, day=1)
            self.assertEqual(len(Date.objects.language('en').datetimes("shared_date", "year")), 2)
            self.assertEqual(len(Date.objects.language('en').datetimes("shared_date", "month")), 3)
            self.assertEqual(len(Date.objects.language('en').datetimes("shared_date", "day")), 3)
            self.assertEqual(len(Date.objects.language('en').datetimes("shared_date", "day").filter(shared_date__gt=d2011)), 2)


########NEW FILE########
__FILENAME__ = docs
# -*- coding: utf-8 -*-
from __future__ import with_statement
import sys
from django.test.testcases import TestCase
from shutil import rmtree
from tempfile import template, mkdtemp, _exists
import os


ROOT_DIR = os.path.join(os.path.dirname(__file__), '..', '..')
DOCS_DIR = os.path.abspath(os.path.join(ROOT_DIR, 'docs'))

class TemporaryDirectory:
    """Create and return a temporary directory.  This has the same
    behavior as mkdtemp but can be used as a context manager.  For
    example:

        with TemporaryDirectory() as tmpdir:
            ...

    Upon exiting the context, the directory and everything contained
    in it are removed.
    """

    def __init__(self, suffix="", prefix=template, dir=None):
        self.name = mkdtemp(suffix, prefix, dir)

    def __enter__(self):
        return self.name

    def cleanup(self):
        if _exists(self.name):
            rmtree(self.name)

    def __exit__(self, exc, value, tb):
        self.cleanup()


class DocumentationTests(TestCase):
    """
    Can be mixed in with a unittest.TestCase class to ensure documentation
    builds properly.
    """
    def test_docs_build(self):
        from sphinx.application import Sphinx
        with TemporaryDirectory() as OUT_DIR:
            with open(os.path.join(OUT_DIR, 'log'), 'w+') as fobj:
                app = Sphinx(
                    DOCS_DIR,
                    DOCS_DIR,
                    OUT_DIR,
                    OUT_DIR,
                    'html',
                    warningiserror=True,
                    status=fobj,
                )
                try:
                    app.build()
                except Exception:
                    e = sys.exc_info()[1]
                    fobj.seek(0)
                    self.fail('%s\n%s' % (e, fobj.read()))

########NEW FILE########
__FILENAME__ = fallbacks
# -*- coding: utf-8 -*-
from hvad.test_utils.context_managers import LanguageOverride
from hvad.test_utils.data import DOUBLE_NORMAL
from hvad.test_utils.testcase import HvadTestCase
from hvad.test_utils.project.app.models import Normal
from hvad.test_utils.fixtures import TwoTranslatedNormalMixin
from hvad.exceptions import WrongManager
from hvad.manager import LEGACY_FALLBACKS

class FallbackTests(HvadTestCase, TwoTranslatedNormalMixin):
    def test_single_instance_fallback(self):
        # fetch an object in a language that does not exist
        with LanguageOverride('de'):
            with self.assertNumQueries(2 if LEGACY_FALLBACKS else 1):
                obj = Normal.objects.untranslated().use_fallbacks('en', 'ja').get(pk=1)
                self.assertEqual(obj.language_code, 'en')
                self.assertEqual(obj.translated_field, 'English1')

    def test_deferred_fallbacks(self):
        with LanguageOverride('de'):
            qs = Normal.objects.untranslated().use_fallbacks('ru', None, 'en')
        with LanguageOverride('ja'):
            with self.assertNumQueries(2 if LEGACY_FALLBACKS else 1):
                obj = qs.get(pk=1)
                self.assertEqual(obj.language_code, 'ja')
                self.assertEqual(obj.translated_field, DOUBLE_NORMAL[1]['translated_field_ja'])
        with LanguageOverride('en'):
            with self.assertNumQueries(2 if LEGACY_FALLBACKS else 1):
                obj = qs.get(pk=1)
                self.assertEqual(obj.language_code, 'en')
                self.assertEqual(obj.translated_field, DOUBLE_NORMAL[1]['translated_field_en'])

    def test_shared_only(self):
        with LanguageOverride('de'):
            with self.assertNumQueries(1):
                obj = Normal.objects.untranslated().get(pk=1)
                self.assertEqual(obj.shared_field, 'Shared1')
            with self.assertNumQueries(1):
                self.assertRaises(AttributeError, getattr, obj, 'translated_field')

    def test_mixed_fallback(self):
        with LanguageOverride('de'):
            pk = Normal.objects.language('ja').create(
                shared_field='shared3',
                translated_field=u'日本語三',
            ).pk
            with self.assertNumQueries(2 if LEGACY_FALLBACKS else 1):
                objs = list(Normal.objects.untranslated().use_fallbacks('en', 'ja'))
                self.assertEqual(len(objs), 3)
                obj = dict([(obj.pk, obj) for obj in objs])[pk]
                self.assertEqual(obj.language_code, 'ja')
            with self.assertNumQueries(2 if LEGACY_FALLBACKS else 1):
                objs = list(Normal.objects.untranslated().use_fallbacks('en'))
                self.assertEqual(len(objs), 3)


class FallbackFilterTests(HvadTestCase, TwoTranslatedNormalMixin):
    def test_simple_filter_untranslated(self):
        with LanguageOverride('en'):
            qs = Normal.objects.untranslated() .filter(shared_field__contains='2')
            with self.assertNumQueries(1):
                self.assertEqual(qs.count(), 1)
            with self.assertNumQueries(1):
                obj = qs[0]
                self.assertEqual(obj.shared_field, DOUBLE_NORMAL[2]['shared_field'])
            with self.assertNumQueries(1):
                self.assertEqual(obj.translated_field, DOUBLE_NORMAL[2]['translated_field_en'])

    def test_simple_filter_fallbacks(self):
        qs = (Normal.objects.untranslated()
                            .use_fallbacks('en', 'ja')
                            .filter(shared_field__contains='2'))
        with self.assertNumQueries(1):
            self.assertEqual(qs.count(), 1)
        with self.assertNumQueries(2 if LEGACY_FALLBACKS else 1):
            obj = qs[0]
        with self.assertNumQueries(0):
            self.assertEqual(obj.shared_field, DOUBLE_NORMAL[2]['shared_field'])
            self.assertEqual(obj.translated_field, DOUBLE_NORMAL[2]['translated_field_en'])

        qs = (Normal.objects.untranslated()
                            .use_fallbacks('ja', 'en')
                            .filter(shared_field__contains='1'))
        with self.assertNumQueries(1):
            self.assertEqual(qs.count(), 1)
        with self.assertNumQueries(2 if LEGACY_FALLBACKS else 1):
            obj = qs[0]
        with self.assertNumQueries(0):
            self.assertEqual(obj.shared_field, DOUBLE_NORMAL[1]['shared_field'])
            self.assertEqual(obj.translated_field, DOUBLE_NORMAL[1]['translated_field_ja'])

    def test_translated_filter(self):
        with self.assertRaises(WrongManager):
            qs = Normal.objects.untranslated().filter(translated_field__contains='English')


class FallbackCachingTests(HvadTestCase, TwoTranslatedNormalMixin):
    def _try_all_cache_using_methods(self, qs, length):
        with self.assertNumQueries(0):
            x = 0
            for obj in qs: x += 1
            self.assertEqual(x, length)
        with self.assertNumQueries(0):
            qs[0]
        with self.assertNumQueries(0):
            self.assertEqual(qs.exists(), length != 0)
        with self.assertNumQueries(0):
            self.assertEqual(qs.count(), length)
        with self.assertNumQueries(0):
            self.assertEqual(len(qs), length)
        with self.assertNumQueries(0):
            self.assertEqual(bool(qs), length != 0)

    def test_iter_caches(self):
        index = 0
        qs = Normal.objects.untranslated().use_fallbacks().filter(pk=1)
        for obj in qs:
            index += 1
        self.assertEqual(index, 1)
        self._try_all_cache_using_methods(qs, 1)

    def test_pickling_caches(self):
        import pickle
        qs = Normal.objects.untranslated().use_fallbacks().filter(pk=1)
        pickle.dumps(qs)
        self._try_all_cache_using_methods(qs, 1)

    def test_len_caches(self):
        qs = Normal.objects.untranslated().use_fallbacks().filter(pk=1)
        self.assertEqual(len(qs), 1)
        self._try_all_cache_using_methods(qs, 1)

    def test_bool_caches(self):
        qs = Normal.objects.untranslated().use_fallbacks().filter(pk=1)
        self.assertTrue(qs)
        self._try_all_cache_using_methods(qs, 1)


class FallbackIterTests(HvadTestCase, TwoTranslatedNormalMixin):
    def test_simple_iter_fallbacks(self):
        with LanguageOverride('en'):
            with self.assertNumQueries(1):
                index = 0
                for obj in Normal.objects.untranslated():
                    index += 1
                    self.assertEqual(obj.shared_field, DOUBLE_NORMAL[index]['shared_field'])
                    with self.assertNumQueries(1):
                        self.assertEqual(obj.translated_field, DOUBLE_NORMAL[index]['translated_field_en'])

    def test_simple_iter_fallbacks(self):
        with self.assertNumQueries(2 if LEGACY_FALLBACKS else 1):
            index = 0
            for obj in Normal.objects.untranslated().use_fallbacks('en', 'ja'):
                index += 1
                self.assertEqual(obj.shared_field, DOUBLE_NORMAL[index]['shared_field'])
                self.assertEqual(obj.translated_field, DOUBLE_NORMAL[index]['translated_field_en'])

        with self.assertNumQueries(2 if LEGACY_FALLBACKS else 1):
            index = 0
            for obj in Normal.objects.untranslated().use_fallbacks('ja', 'en'):
                index += 1
                self.assertEqual(obj.shared_field, DOUBLE_NORMAL[index]['shared_field'])
                self.assertEqual(obj.translated_field, DOUBLE_NORMAL[index]['translated_field_ja'])

    def test_iter_unique_reply(self):
        # Make sure .all() only returns unique rows
        self.assertEqual(len(Normal.objects.untranslated().use_fallbacks('en', 'ja').all()),
                         len(Normal.objects.untranslated()))



class FallbackValuesListTests(HvadTestCase, TwoTranslatedNormalMixin):
    def test_values_list_shared(self):
        values = (Normal.objects.untranslated()
                                .use_fallbacks('en', 'ja')
                                .values_list('shared_field', flat=True))
        with self.assertNumQueries(1):
            values_list = list(values)
            self.assertCountEqual(values_list, [DOUBLE_NORMAL[1]['shared_field'], DOUBLE_NORMAL[2]['shared_field']])

    def test_values_list_translated(self):
        with self.assertRaises(WrongManager):
            values = Normal.objects.untranslated().values_list('translated_field', flat=True)


class FallbackValuesTests(HvadTestCase, TwoTranslatedNormalMixin):
    def test_values_shared(self):
        values = (Normal.objects.untranslated()
                                .use_fallbacks('en', 'ja')
                                .values('shared_field'))
        with self.assertNumQueries(1):
            values_list = list(values)
            check = [
                {'shared_field': DOUBLE_NORMAL[1]['shared_field']},
                {'shared_field': DOUBLE_NORMAL[2]['shared_field']},
            ]
            self.assertCountEqual(values_list, check)

    def test_values_translated(self):
        with self.assertRaises(WrongManager):
            values = Normal.objects.untranslated().values('translated_field')


class FallbackInBulkTests(HvadTestCase, TwoTranslatedNormalMixin):
    def test_in_bulk_untranslated(self):
        with LanguageOverride('en'):
            with self.assertNumQueries(1):
                result = Normal.objects.untranslated().in_bulk([1, 2])
            with self.assertNumQueries(0):
                self.assertCountEqual((1, 2), result)
                self.assertEqual(result[1].shared_field, DOUBLE_NORMAL[1]['shared_field'])
            with self.assertNumQueries(1):
                self.assertEqual(result[1].translated_field, DOUBLE_NORMAL[1]['translated_field_en'])
            with self.assertNumQueries(0):
                self.assertEqual(result[1].language_code, 'en')
        with LanguageOverride('ja'):
            with self.assertNumQueries(0):
                self.assertEqual(result[2].shared_field, DOUBLE_NORMAL[2]['shared_field'])
            with self.assertNumQueries(1):
                self.assertEqual(result[2].translated_field, DOUBLE_NORMAL[2]['translated_field_ja'])
            with self.assertNumQueries(0):
                self.assertEqual(result[2].language_code, 'ja')

    def test_in_bulk_fallbacks(self):
        with self.assertNumQueries(2 if LEGACY_FALLBACKS else 1):
            result = Normal.objects.untranslated().use_fallbacks('en', 'ja').in_bulk([1, 2])
        with self.assertNumQueries(0):
            self.assertCountEqual((1, 2), result)
            self.assertEqual(result[1].shared_field, DOUBLE_NORMAL[1]['shared_field'])
            self.assertEqual(result[1].translated_field, DOUBLE_NORMAL[1]['translated_field_en'])
            self.assertEqual(result[1].language_code, 'en')
            self.assertEqual(result[2].shared_field, DOUBLE_NORMAL[2]['shared_field'])
            self.assertEqual(result[2].translated_field, DOUBLE_NORMAL[2]['translated_field_en'])
            self.assertEqual(result[2].language_code, 'en')


class FallbackNotImplementedTests(HvadTestCase):
    def test_defer(self):
        baseqs = Normal.objects.untranslated()
        self.assertRaises(NotImplementedError, baseqs.defer, 'shared_field')
        self.assertRaises(NotImplementedError, baseqs.only)
        self.assertRaises(NotImplementedError, baseqs.aggregate)
        self.assertRaises(NotImplementedError, baseqs.annotate)

########NEW FILE########
__FILENAME__ = fieldtranslator
# -*- coding: utf-8 -*-
from hvad.fieldtranslator import translate
from hvad.test_utils.testcase import HvadTestCase
from hvad.test_utils.project.app.models import Related


class FieldtranslatorTests(HvadTestCase):
    def test_simple(self):
        INPUT = 'normal__shared_field'
        query_string, joins = translate(INPUT, Related)
        self.assertEqual(query_string, INPUT)
        self.assertEqual(joins, ['normal__translations__language_code'])
        
    def test_query_bit(self):
        INPUT = 'normal__shared_field__exact'
        query_string, joins = translate(INPUT, Related)
        self.assertEqual(query_string, INPUT)
        self.assertEqual(joins, ['normal__translations__language_code'])
        INPUT = 'normal__translated_field__exact'
        query_string, joins = translate(INPUT, Related)
        self.assertEqual(query_string, 'normal__translations__translated_field__exact')
        self.assertEqual(joins, ['normal__translations__language_code'])

########NEW FILE########
__FILENAME__ = forms
# -*- coding: utf-8 -*-
from django.core.exceptions import FieldError
from hvad.forms import TranslatableModelForm, TranslatableModelFormMetaclass
from hvad.test_utils.context_managers import LanguageOverride
from hvad.test_utils.testcase import HvadTestCase
from hvad.test_utils.project.app.models import Normal, SimpleRelated
from hvad.test_utils.data import DOUBLE_NORMAL
from hvad.test_utils.fixtures import TwoTranslatedNormalMixin
from django.db import models
from django import forms

class NormalForm(TranslatableModelForm):
    class Meta:
        model = Normal
        fields = ['shared_field', 'translated_field']

class NormalMediaForm(TranslatableModelForm):
    class Meta:
        model = Normal
        exclude = []
    class Media:
        css = {
            'all': ('layout.css',)
        }

class NormalFormExclude(TranslatableModelForm):
    class Meta:
        model = Normal
        exclude = ['shared_field']

class SimpleRelatedForm(TranslatableModelForm):
    normal = forms.ModelChoiceField(queryset=Normal.objects.language())
    class Meta:
        model = SimpleRelated
        fields = ['normal', 'translated_field']

class FormTests(HvadTestCase, TwoTranslatedNormalMixin):
    
    def test_nontranslatablemodelform(self):
        # Make sure that TranslatableModelForm won't accept a regular model
        
        # "Fake" model to use for the TranslatableModelForm
        class NonTranslatableModel(models.Model):
            field = models.CharField(max_length=128)
        # Meta class for use below
        class Meta:
            model = NonTranslatableModel
            exclude = []
        # Make sure we do indeed get an exception, if we try to initialise it
        self.assertRaises(TypeError,
            TranslatableModelFormMetaclass,
            'NonTranslatableModelForm', (TranslatableModelForm,),
            {'Meta': Meta}
        )
    
    def test_normal_model_form_instantiation(self):
        # Basic example and checking it gives us all the fields needed
        form = NormalForm()
        self.assertTrue("translated_field" in form.fields)
        self.assertTrue("shared_field" in form.fields)
        self.assertTrue("translated_field" in form.base_fields)
        self.assertTrue("shared_field" in form.base_fields)
        self.assertFalse(form.is_valid())
        
        # Check if it works with media argument too
        form = NormalMediaForm()
        self.assertFalse(form.is_valid())
        self.assertTrue("layout.css" in str(form.media))
        
        # Check if it works with an instance of Normal
        form = NormalForm(instance=Normal())
        self.assertFalse(form.is_valid())
        
        
    def test_normal_model_form_valid(self):
        SHARED = 'Shared'
        TRANSLATED = 'English'
        data = {
            'shared_field': SHARED,
            'translated_field': TRANSLATED,
            'language_code': 'en'
        }
        form = NormalForm(data)
        self.assertTrue(form.is_valid(), form.errors.as_text())
        self.assertTrue("translated_field" in form.fields)
        self.assertTrue("shared_field" in form.fields)
        self.assertTrue(TRANSLATED in form.clean()["translated_field"])
        self.assertTrue(SHARED in form.clean()["shared_field"])
        
    def test_normal_model_form_initaldata_instance(self):
        # Check if it accepts inital data and instance
        SHARED = 'Shared'
        TRANSLATED = 'English'
        data = {
            'shared_field': SHARED,
            'translated_field': TRANSLATED,
            'language_code': 'en'
        }
        form = NormalForm(data, instance=Normal(), initial=data)
        self.assertTrue(form.is_valid(), form.errors.as_text())
        
    def test_normal_model_form_existing_instance(self):
        # Check if it works with an existing instance of Normal
        SHARED = 'Shared'
        TRANSLATED = 'English'
        instance = Normal.objects.language("en").create(shared_field=SHARED, translated_field=TRANSLATED)
        form = NormalForm(instance=instance)
        self.assertFalse(form.is_valid())
        self.assertTrue(SHARED in form.as_p())
        self.assertTrue(TRANSLATED in form.as_p())
        
    
    def test_normal_model_form_save(self):
        with LanguageOverride('en'):
            SHARED = 'Shared'
            TRANSLATED = 'English'
            data = {
                'shared_field': SHARED,
                'translated_field': TRANSLATED,
                'language_code': 'en'
            }
            form = NormalForm(data)
            # tested a non-translated ModelForm, and that takes 7 queries.
            with self.assertNumQueries(2):
                obj = form.save()
            with self.assertNumQueries(0):
                self.assertEqual(obj.shared_field, SHARED)
                self.assertEqual(obj.translated_field, TRANSLATED)
                self.assertNotEqual(obj.pk, None)

    def test_normal_model_form_save_nocommit(self):
        with LanguageOverride('en'):
            SHARED = 'Shared'
            TRANSLATED = 'English'
            data = {
                'shared_field': SHARED,
                'translated_field': TRANSLATED,
                'language_code': 'en'
            }
            form = NormalForm(data)
            # tested a non-translated ModelForm, and that takes 7 queries.
            with self.assertNumQueries(0):
                obj = form.save(commit=False)
                self.assertEqual(obj.shared_field, SHARED)
                self.assertEqual(obj.translated_field, TRANSLATED)
                self.assertEqual(obj.pk, None)
            with self.assertNumQueries(2):
                obj.save()
                self.assertEqual(obj.shared_field, SHARED)
                self.assertEqual(obj.translated_field, TRANSLATED)
                self.assertNotEqual(obj.pk, None)

    def test_no_language_code_in_fields(self):
        with LanguageOverride("en"):
            form = NormalForm()
            self.assertFalse("language_code" in form.fields)

            form = NormalMediaForm()
            self.assertFalse("language_code" in form.fields)

            form = NormalFormExclude()
            self.assertFalse("language_code" in form.fields)

    def test_form_wrong_field_in_class(self):
        with LanguageOverride("en"):            
            def create_wrong_form():
                class WrongForm(TranslatableModelForm):
                    class Meta:
                        model = Normal
                        fields = ['a_field_that_doesnt_exist']
            self.assertRaises(FieldError, create_wrong_form)

    def test_simple_related_form(self):
        with LanguageOverride('en'):
            form = SimpleRelatedForm()
            rendered = form['normal'].as_widget()
            self.assertIn(DOUBLE_NORMAL[1]['translated_field_en'], rendered)
            self.assertIn(DOUBLE_NORMAL[2]['translated_field_en'], rendered)

        with LanguageOverride('ja'):
            form = SimpleRelatedForm()
            rendered = form['normal'].as_widget()
            self.assertIn(DOUBLE_NORMAL[1]['translated_field_ja'], rendered)
            self.assertIn(DOUBLE_NORMAL[2]['translated_field_ja'], rendered)

########NEW FILE########
__FILENAME__ = forms_inline
# -*- coding: utf-8 -*-
from django.forms import ModelForm
from hvad.admin import TranslatableModelAdminMixin
from hvad.forms import translatable_inlineformset_factory, translationformset_factory
from hvad.test_utils.context_managers import LanguageOverride
from hvad.test_utils.testcase import HvadTestCase
from hvad.test_utils.request_factory import RequestFactory
from hvad.test_utils.project.app.models import Normal, Related
from hvad.test_utils.forms import FormData


class TestBasicInline(HvadTestCase):
    def setUp(self):
        with LanguageOverride("en"):
            self.object = Normal.objects.language().create(shared_field="test", translated_field="translated test")
            rf = RequestFactory()
            self.request = rf.post('/url/')

    def test_create_fields_inline(self):
        with LanguageOverride("en"):
            # Fixtures (should eventually be shared with other tests)

            translate_mixin = TranslatableModelAdminMixin()
            formset = translatable_inlineformset_factory(translate_mixin._language(self.request),
                                                         Normal, Related)(#self.request.POST,
                                                                          instance=self.object)

            self.assertTrue("normal" in formset.forms[0].fields)
            self.assertTrue("translated" in formset.forms[0].fields)
            self.assertTrue("translated_to_translated" in formset.forms[0].fields)
            self.assertFalse("language_code" in formset.forms[0].fields)

class TestTranslationsInline(HvadTestCase):
    def setUp(self):
        with LanguageOverride('en'):
            self.object = Normal.objects.language().create(
                shared_field='test',
                translated_field='translated_test_en'
            )
            self.object.translate('fr')
            self.object.translated_field='translated_test_fr'
            self.object.save()

    def test_render_formset(self):
        with self.assertNumQueries(1):
            Formset = translationformset_factory(Normal, extra=1)
            formset = Formset(instance=self.object)
            self.assertEqual(len(formset.forms), 3)
            self.assertIn('translated_field', formset.forms[0].fields)
            self.assertIn('language_code', formset.forms[0].fields)
            self.assertIn('DELETE', formset.forms[0].fields)
            self.assertIn('id', formset.forms[0].fields)
            self.assertNotIn('master', formset.forms[0].fields)
            self.assertEqual(formset.forms[0].initial['language_code'], 'en')
            self.assertEqual(formset.forms[0].initial['translated_field'], 'translated_test_en')
            self.assertEqual(formset.forms[1].initial['language_code'], 'fr')
            self.assertEqual(formset.forms[1].initial['translated_field'], 'translated_test_fr')
            self.assertEqual(formset.forms[2].initial, {})

        with self.assertNumQueries(1):
            class Form(ModelForm):
                class Meta:
                    fields = ('translated_field',)
            Formset = translationformset_factory(Normal, form=Form, extra=1)
            formset = Formset(instance=self.object)
            self.assertIn('translated_field', formset.forms[0].fields)
            self.assertIn('language_code', formset.forms[0].fields)
            self.assertIn('DELETE', formset.forms[0].fields)
            self.assertIn('id', formset.forms[0].fields)
            self.assertNotIn('master', formset.forms[0].fields)

    def test_create_translations(self):
        Formset = translationformset_factory(Normal, extra=1)

        initial = Formset(instance=self.object)
        data = FormData(initial)
        data.set_formset_field(initial, 2, 'language_code', 'de')
        data.set_formset_field(initial, 2, 'translated_field', 'translated_test_de')

        formset = Formset(data=data, instance=self.object)
        formset.save()

        obj = Normal.objects.language('de').get(pk=self.object.pk)
        self.assertEqual(obj.translated_field, 'translated_test_de')
        self.assertEqual(obj.translations.count(), 3)


    def test_delete_translations(self):
        Formset = translationformset_factory(Normal, extra=1)

        # Delete one of the two translations
        initial = Formset(instance=self.object)
        data = FormData(initial)
        data.set_formset_field(initial, 0, 'DELETE', 'DELETE')

        formset = Formset(data=data, instance=self.object)
        self.assertTrue(formset.is_valid())
        formset.save()

        self.assertCountEqual(self.object.get_available_languages(), ('fr',))

        # Try to delete the other translation - should fail
        initial = Formset(instance=self.object)
        data = FormData(initial)
        data.set_formset_field(initial, 0, 'DELETE', 'DELETE')

        formset = Formset(data=data, instance=self.object)
        self.assertFalse(formset.is_valid())


    def test_mixed_update_translations(self):
        Formset = translationformset_factory(Normal, extra=1)

        initial = Formset(instance=self.object)
        data = FormData(initial)
        data.set_formset_field(initial, 0, 'DELETE', 'DELETE')
        data.set_formset_field(initial, 1, 'translated_field', 'updated_fr')
        data.set_formset_field(initial, 2, 'language_code', 'de')
        data.set_formset_field(initial, 2, 'translated_field', 'translated_test_de')

        formset = Formset(data=data, instance=self.object)
        self.assertTrue(formset.is_valid())
        formset.save()

        self.assertCountEqual(self.object.get_available_languages(), ('fr', 'de'))

        obj = Normal.objects.language('fr').get(pk=self.object.pk)
        self.assertEqual(obj.shared_field, 'test')
        self.assertEqual(obj.translated_field, 'updated_fr')

        obj = Normal.objects.language('de').get(pk=self.object.pk)
        self.assertEqual(obj.shared_field, 'test')
        self.assertEqual(obj.translated_field, 'translated_test_de')


########NEW FILE########
__FILENAME__ = limit_choices_to
# -*- coding: utf-8 -*-
from django.contrib import admin
from django.contrib.auth.models import User

from hvad.test_utils.testcase import HvadTestCase
from hvad.test_utils.fixtures import TwoTranslatedNormalMixin

from hvad.test_utils.project.app.models import LimitedChoice


class LimitChoicesToTests(HvadTestCase, TwoTranslatedNormalMixin):
    def create_fixtures(self):
        su = User(
            email='admin@admin.com',
            is_staff=True,
            is_superuser=True,
            is_active=True,
            username='admin',
        )
        su.set_password('admin')
        su.save()
        self.user = su
        super(LimitChoicesToTests, self).create_fixtures()

    def test_limit_choices_to(self):
        """
        Checks if limit_choices_to works on ForeignKey and ManyToManyField.
        """

        limited_choice_admin = admin.site._registry[LimitedChoice]
        
        with self.login_user_context(
            username='admin',
            password='admin'
        ):
            rf = self.request_factory
            get_request = rf.get('/admin/app/limitedchoice/add')
            
            # We need to attach the client's session to the request,
            # otherwise admin won't let us in 
            get_request.session = self.client.session 

            # in django 1.4 request.user is required
            get_request.user = self.user

            # Let's construct the relevant admin form...
            Form = limited_choice_admin.get_form(get_request)
            form = Form()

            # ...and see if the ForeignKey field's queryset contains valid
            # choices only.
            qs_fk = form.fields['choice_fk'].queryset
            self.assertTrue(qs_fk.filter(shared_field='Shared1').exists())
            self.assertFalse(qs_fk.filter(shared_field='Shared2').exists())


            # Now do the same for the ManyToManyField.
            qs_mm = form.fields['choice_mm'].queryset
            self.assertTrue(qs_mm.filter(shared_field='Shared2').exists())
            self.assertFalse(qs_mm.filter(shared_field='Shared1').exists())


########NEW FILE########
__FILENAME__ = ordering
# -*- coding: utf-8 -*-
from hvad.test_utils.testcase import HvadTestCase
from hvad.test_utils.project.app.models import Normal

class OrderingTest(HvadTestCase):
    def test_minus_order_by(self):
        a = Normal.objects.language('en').create(translated_field = "English",
                                                 shared_field="A")
        b = Normal.objects.language('en').create(translated_field = "English",
                                                 shared_field="B")
        qs = Normal.objects.language('en').order_by('-shared_field')
        self.assertEqual(qs.count(), 2)
        self.assertEqual(qs[0].pk, b.pk)
        self.assertEqual(qs[1].pk, a.pk)
        
    def test_order_by(self):
        a = Normal.objects.language('en').create(translated_field = "English",
                                                 shared_field="A")
        b = Normal.objects.language('en').create(translated_field = "English",
                                                 shared_field="B")
        qs = Normal.objects.language('en').order_by('shared_field')
        self.assertEqual(qs.count(), 2)
        self.assertEqual(qs[0].pk, a.pk)
        self.assertEqual(qs[1].pk, b.pk)
    
    def test_random_order(self):
        a = Normal.objects.language('en').create(translated_field = "English",
                                                 shared_field="A")
        b = Normal.objects.language('en').create(translated_field = "English",
                                                 shared_field="B")
        qs = Normal.objects.language('en').order_by('?')
        self.assertEqual(qs.count(), 2)
        pks = [obj.pk for obj in qs]
        self.assertTrue(a.pk in pks)
        self.assertTrue(b.pk in pks)
        
    def test_reverse(self):
        a = Normal.objects.language('en').create(translated_field = "English",
                                                 shared_field="A")
        b = Normal.objects.language('en').create(translated_field = "English",
                                                 shared_field="B")
        qs = Normal.objects.language('en').order_by('shared_field').reverse()
        self.assertEqual(qs.count(), 2)
        self.assertEqual(qs[0].pk, b.pk)
        self.assertEqual(qs[1].pk, a.pk)

########NEW FILE########
__FILENAME__ = proxy
# -*- coding: utf-8 -*-
from hvad.test_utils.testcase import HvadTestCase
from hvad.test_utils.project.app.models import Normal, NormalProxy, NormalProxyProxy, RelatedProxy, SimpleRelatedProxy


class ProxyTests(HvadTestCase):
    def test_proxy(self):
        self.assertEqual(NormalProxy.objects.count(), 0)
        self.assertEqual(NormalProxy.objects.language('en').count(), 0)

        # creation
        normal = Normal.objects.language('en').create(shared_field='SHARED', translated_field='English')
        self.assertEqual(NormalProxy.objects.language('en').count(), 1)

        NormalProxy.objects.language('en').create(shared_field='SHARED2', translated_field='English2')
        self.assertEqual(NormalProxy.objects.language('en').count(), 2)

        NormalProxy.objects.language('jp').create(shared_field='JPSHARED3', translated_field='Japanese')
        self.assertEqual(NormalProxy.objects.language('jp').count(), 1)

        # filter
        self.assertEqual(NormalProxy.objects.filter(shared_field__startswith='SHARED').count(), 2)
        self.assertEqual(NormalProxy.objects.language('en').filter(translated_field__startswith='English').count(), 2)
        self.assertEqual(NormalProxy.objects.language('en').filter(translated_field='English').count(), 1)

        # select_related
        RelatedProxy.objects.language('en').create(normal=normal)
            # does it work?
        self.assertEqual(RelatedProxy.objects.language('en').select_related('normal').count(), 1)
            # does it actually cache stuff?
        normal_cache = RelatedProxy._meta.get_field('normal').get_cache_name()
        self.assertTrue(isinstance(getattr(RelatedProxy.objects.language('en').select_related('normal').get(), normal_cache), Normal))

    def test_proxy_proxy(self):
        self.assertEqual(NormalProxyProxy.objects.language('en').count(), 0)

        # creation
        NormalProxyProxy.objects.language('en').create(shared_field='SHARED', translated_field='English')
        self.assertEqual(NormalProxyProxy.objects.language('en').count(), 1)

    def test_proxy_simple_relation(self):
        self.assertEqual(NormalProxy.objects.count(), 0)
        self.assertEqual(NormalProxy.objects.language('en').count(), 0)

        NormalProxy.objects.language('en').create(shared_field='SHARED', translated_field='English')
        normal = NormalProxy.objects.get(shared_field='SHARED')
        SimpleRelatedProxy.objects.language('en').create(normal=normal, translated_field='RelatedEnglish')

        from hvad.utils import get_translation_aware_manager
        srp_manager = get_translation_aware_manager(SimpleRelatedProxy)
        qs = srp_manager.language('en').filter(normal__translated_field='English')
        self.assertEqual(qs.count(), 1)
        np_manager = get_translation_aware_manager(NormalProxy)
        qs = np_manager.language('en').filter(simplerel__translated_field='RelatedEnglish')
        self.assertEqual(qs.count(), 1)

    def test_translation_queryset(self):
        NormalProxy.objects.language('en').create(shared_field='SHARED2', translated_field='English2')
        self.assertTrue(isinstance(Normal.objects.language('en').get(), Normal))
        self.assertFalse(isinstance(Normal.objects.language('en').get(), NormalProxy))
        self.assertTrue(isinstance(NormalProxy.objects.language('en').get(), NormalProxy))
        self.assertFalse(isinstance(NormalProxy.objects.language('en').get(), NormalProxyProxy))
        self.assertTrue(isinstance(NormalProxyProxy.objects.language('en').get(), NormalProxyProxy))

    def test_fallback_queryset(self):
        NormalProxyProxy.objects.language('en').create(shared_field='SHARED2', translated_field='English2')
        self.assertTrue(isinstance(Normal.objects.untranslated().use_fallbacks().get(), Normal))
        self.assertFalse(isinstance(Normal.objects.untranslated().use_fallbacks().get(), NormalProxy))
        self.assertTrue(isinstance(NormalProxy.objects.untranslated().use_fallbacks().get(), NormalProxy))
        self.assertFalse(isinstance(NormalProxy.objects.untranslated().use_fallbacks().get(), NormalProxyProxy))
        self.assertTrue(isinstance(NormalProxyProxy.objects.untranslated().use_fallbacks().get(), NormalProxyProxy))

########NEW FILE########
__FILENAME__ = query
# -*- coding: utf-8 -*-
import django
from django.db.models.query_utils import Q
from hvad.test_utils.context_managers import LanguageOverride
from hvad.test_utils.data import DOUBLE_NORMAL
from hvad.test_utils.testcase import HvadTestCase
from hvad.test_utils.project.app.models import Normal, AggregateModel, Standard, SimpleRelated
from hvad.test_utils.fixtures import TwoTranslatedNormalMixin

class FilterTests(HvadTestCase, TwoTranslatedNormalMixin):
    def test_simple_filter(self):
        qs = Normal.objects.language('en').filter(shared_field__contains='2')
        self.assertEqual(qs.count(), 1)
        obj = qs[0]
        self.assertEqual(obj.shared_field, DOUBLE_NORMAL[2]['shared_field'])
        self.assertEqual(obj.translated_field, DOUBLE_NORMAL[2]['translated_field_en'])
        qs = Normal.objects.language('ja').filter(shared_field__contains='1')
        self.assertEqual(qs.count(), 1)
        obj = qs[0]
        self.assertEqual(obj.shared_field, DOUBLE_NORMAL[1]['shared_field'])
        self.assertEqual(obj.translated_field, DOUBLE_NORMAL[1]['translated_field_ja'])
        
    def test_translated_filter(self):
        qs = Normal.objects.language('en').filter(translated_field__contains='English')
        self.assertEqual(qs.count(), 2)
        obj1, obj2 = qs
        self.assertEqual(obj1.shared_field, DOUBLE_NORMAL[1]['shared_field'])
        self.assertEqual(obj1.translated_field, DOUBLE_NORMAL[1]['translated_field_en'])
        self.assertEqual(obj2.shared_field, DOUBLE_NORMAL[2]['shared_field'])
        self.assertEqual(obj2.translated_field, DOUBLE_NORMAL[2]['translated_field_en'])

    def test_all_languages_filter(self):
        with self.assertNumQueries(2):
            qs = Normal.objects.language('all').filter(shared_field__contains='Shared')
            self.assertEqual(qs.count(), 4)
            self.assertCountEqual((obj.shared_field for obj in qs),
                                  (DOUBLE_NORMAL[1]['shared_field'],
                                   DOUBLE_NORMAL[2]['shared_field']) * 2)
            self.assertCountEqual((obj.translated_field for obj in qs),
                                  (DOUBLE_NORMAL[1]['translated_field_en'],
                                   DOUBLE_NORMAL[1]['translated_field_ja'],
                                   DOUBLE_NORMAL[2]['translated_field_en'],
                                   DOUBLE_NORMAL[2]['translated_field_ja']))

        with self.assertNumQueries(2):
            qs = Normal.objects.language('all').filter(translated_field__contains='English')
            self.assertEqual(qs.count(), 2)
            self.assertCountEqual((obj.shared_field for obj in qs),
                                  (DOUBLE_NORMAL[1]['shared_field'],
                                   DOUBLE_NORMAL[2]['shared_field']))
            self.assertCountEqual((obj.translated_field for obj in qs),
                                  (DOUBLE_NORMAL[1]['translated_field_en'],
                                   DOUBLE_NORMAL[2]['translated_field_en']))

        with self.assertNumQueries(2):
            qs = Normal.objects.language('all').filter(translated_field__contains='1')
            self.assertEqual(qs.count(), 1)
            obj = qs[0]
            self.assertEqual(obj.shared_field, DOUBLE_NORMAL[1]['shared_field'])
            self.assertEqual(obj.translated_field, DOUBLE_NORMAL[1]['translated_field_en'])

    def test_deferred_language_filter(self):
        with LanguageOverride('ja'):
            qs = Normal.objects.language().filter(translated_field__contains='English')
        with LanguageOverride('en'):
            self.assertEqual(qs.count(), 2)
            obj1, obj2 = qs
            self.assertEqual(obj1.shared_field, DOUBLE_NORMAL[1]['shared_field'])
            self.assertEqual(obj1.translated_field, DOUBLE_NORMAL[1]['translated_field_en'])
            self.assertEqual(obj2.shared_field, DOUBLE_NORMAL[2]['shared_field'])
            self.assertEqual(obj2.translated_field, DOUBLE_NORMAL[2]['translated_field_en'])

class QueryCachingTests(HvadTestCase, TwoTranslatedNormalMixin):
    def _try_all_cache_using_methods(self, qs, length):
        with self.assertNumQueries(0):
            x = 0
            for obj in qs: x += 1
            self.assertEqual(x, length)
        with self.assertNumQueries(0):
            qs[0]
        with self.assertNumQueries(0):
            self.assertEqual(qs.exists(), length != 0)
        with self.assertNumQueries(0):
            self.assertEqual(qs.count(), length)
        with self.assertNumQueries(0):
            self.assertEqual(len(qs), length)
        with self.assertNumQueries(0):
            self.assertEqual(bool(qs), length != 0)

    def test_iter_caches(self):
        with LanguageOverride('en'):
            index = 0
            qs = Normal.objects.language().filter(pk=1)
            for obj in qs:
                index += 1
            self.assertEqual(index, 1)
            self._try_all_cache_using_methods(qs, 1)

    def test_pickling_caches(self):
        import pickle
        with LanguageOverride('en'):
            qs = Normal.objects.language().filter(pk=1)
            pickle.dumps(qs)
            self._try_all_cache_using_methods(qs, 1)

    def test_len_caches(self):
        with LanguageOverride('en'):
            qs = Normal.objects.language().filter(pk=1)
            self.assertEqual(len(qs), 1)
            self._try_all_cache_using_methods(qs, 1)

    def test_bool_caches(self):
        with LanguageOverride('en'):
            qs = Normal.objects.language().filter(pk=1)
            self.assertTrue(qs)
            self._try_all_cache_using_methods(qs, 1)


class IterTests(HvadTestCase, TwoTranslatedNormalMixin):
    def test_simple_iter(self):
        with LanguageOverride('en'):
            with self.assertNumQueries(1):
                index = 0
                for obj in Normal.objects.language():
                    index += 1
                    self.assertEqual(obj.shared_field, DOUBLE_NORMAL[index]['shared_field'])
                    self.assertEqual(obj.translated_field, DOUBLE_NORMAL[index]['translated_field_en'])
        with LanguageOverride('ja'):
            with self.assertNumQueries(1):
                index = 0
                for obj in Normal.objects.language():
                    index += 1
                    self.assertEqual(obj.shared_field, DOUBLE_NORMAL[index]['shared_field'])
                    self.assertEqual(obj.translated_field, DOUBLE_NORMAL[index]['translated_field_ja'])
    def test_iter_unique_reply(self):
        # Make sure .all() only returns unique rows
        with LanguageOverride('en'):
            self.assertEqual(len(Normal.objects.all()), len(Normal.objects.untranslated()))

    def test_iter_deferred_language(self):
        with LanguageOverride('en'):
            qs = Normal.objects.language()
        with LanguageOverride('ja'):
            index = 0
            for obj in qs:
                index += 1
                self.assertEqual(obj.shared_field, DOUBLE_NORMAL[index]['shared_field'])
                self.assertEqual(obj.translated_field, DOUBLE_NORMAL[index]['translated_field_ja'])


class UpdateTests(HvadTestCase, TwoTranslatedNormalMixin):
    def test_update_shared(self):
        NEW_SHARED = 'new shared'
        n1 = Normal.objects.language('en').get(pk=1)
        n2 = Normal.objects.language('en').get(pk=2)
        ja1 = Normal.objects.language('ja').get(pk=1)
        ja2 = Normal.objects.language('ja').get(pk=2)
        with self.assertNumQueries(1):
            Normal.objects.language('en').update(shared_field=NEW_SHARED)
        new1 = Normal.objects.language('en').get(pk=1)
        new2 = Normal.objects.language('en').get(pk=2)
        self.assertEqual(new1.shared_field, NEW_SHARED)
        self.assertEqual(new1.translated_field, n1.translated_field)
        self.assertEqual(new2.shared_field, NEW_SHARED)
        self.assertEqual(new2.translated_field, n2.translated_field)
        newja1 = Normal.objects.language('ja').get(pk=1)
        newja2 = Normal.objects.language('ja').get(pk=2)
        self.assertEqual(newja1.shared_field, NEW_SHARED)
        self.assertEqual(newja2.shared_field, NEW_SHARED)
        self.assertEqual(newja1.translated_field, ja1.translated_field)
        self.assertEqual(newja2.translated_field, ja2.translated_field)
        
    def test_update_translated(self):
        NEW_TRANSLATED = 'new translated'
        n1 = Normal.objects.language('en').get(pk=1)
        n2 = Normal.objects.language('en').get(pk=2)
        ja1 = Normal.objects.language('ja').get(pk=1)
        ja2 = Normal.objects.language('ja').get(pk=2)
        with self.assertNumQueries(1):
            Normal.objects.language('en').update(translated_field=NEW_TRANSLATED)
        new1 = Normal.objects.language('en').get(pk=1)
        new2 = Normal.objects.language('en').get(pk=2)
        self.assertEqual(new1.shared_field, n1.shared_field)
        self.assertEqual(new2.shared_field, n2.shared_field)
        self.assertEqual(new1.translated_field, NEW_TRANSLATED)
        self.assertEqual(new2.translated_field, NEW_TRANSLATED)
        # check it didn't touch japanese
        newja1 = Normal.objects.language('ja').get(pk=1)
        newja2 = Normal.objects.language('ja').get(pk=2)
        self.assertEqual(newja1.shared_field, ja1.shared_field)
        self.assertEqual(newja2.shared_field, ja2.shared_field)
        self.assertEqual(newja1.translated_field, ja1.translated_field)
        self.assertEqual(newja2.translated_field, ja2.translated_field)
        
    def test_update_mixed(self):
        NEW_SHARED = 'new shared'
        NEW_TRANSLATED = 'new translated'
        ja1 = Normal.objects.language('ja').get(pk=1)
        ja2 = Normal.objects.language('ja').get(pk=2)
        with self.assertNumQueries(2):
            Normal.objects.language('en').update(shared_field=NEW_SHARED, translated_field=NEW_TRANSLATED)
        new1 = Normal.objects.language('en').get(pk=1)
        new2 = Normal.objects.language('en').get(pk=2)
        self.assertEqual(new1.shared_field, NEW_SHARED)
        self.assertEqual(new1.translated_field, NEW_TRANSLATED)
        self.assertEqual(new2.shared_field, NEW_SHARED)
        self.assertEqual(new2.translated_field, NEW_TRANSLATED)
        newja1 = Normal.objects.language('ja').get(pk=1)
        newja2 = Normal.objects.language('ja').get(pk=2)
        self.assertEqual(newja1.shared_field, NEW_SHARED)
        self.assertEqual(newja2.shared_field, NEW_SHARED)
        # check it didn't touch japanese translated fields
        self.assertEqual(newja1.translated_field, ja1.translated_field)
        self.assertEqual(newja2.translated_field, ja2.translated_field)

    def test_update_deferred_language(self):
        NEW_TRANSLATED = 'new translated'
        n1 = Normal.objects.language('en').get(pk=1)
        n2 = Normal.objects.language('en').get(pk=2)
        ja1 = Normal.objects.language('ja').get(pk=1)
        ja2 = Normal.objects.language('ja').get(pk=2)
        with LanguageOverride('ja'):
            qs = Normal.objects.language()
        with LanguageOverride('en'):
            with self.assertNumQueries(1):
                qs.update(translated_field=NEW_TRANSLATED)
        new1 = Normal.objects.language('en').get(pk=1)
        new2 = Normal.objects.language('en').get(pk=2)
        self.assertEqual(new1.shared_field, n1.shared_field)
        self.assertEqual(new2.shared_field, n2.shared_field)
        self.assertEqual(new1.translated_field, NEW_TRANSLATED)
        self.assertEqual(new2.translated_field, NEW_TRANSLATED)
        # check it didn't touch japanese
        newja1 = Normal.objects.language('ja').get(pk=1)
        newja2 = Normal.objects.language('ja').get(pk=2)
        self.assertEqual(newja1.shared_field, ja1.shared_field)
        self.assertEqual(newja2.shared_field, ja2.shared_field)
        self.assertEqual(newja1.translated_field, ja1.translated_field)
        self.assertEqual(newja2.translated_field, ja2.translated_field)

class ValuesListTests(HvadTestCase, TwoTranslatedNormalMixin):
    def test_values_list_translated(self):
        values = Normal.objects.language('en').values_list('translated_field', flat=True)
        values_list = list(values)
        self.assertEqual(values_list, [DOUBLE_NORMAL[1]['translated_field_en'], DOUBLE_NORMAL[2]['translated_field_en']])
        
    def test_values_list_shared(self):
        values = Normal.objects.language('en').values_list('shared_field', flat=True)
        values_list = list(values)
        self.assertEqual(values_list, [DOUBLE_NORMAL[1]['shared_field'], DOUBLE_NORMAL[2]['shared_field']])
    
    def test_values_list_mixed(self):
        values = Normal.objects.language('en').values_list('shared_field', 'translated_field')
        values_list = list(values)
        check = [
            (DOUBLE_NORMAL[1]['shared_field'], DOUBLE_NORMAL[1]['translated_field_en']),
            (DOUBLE_NORMAL[2]['shared_field'], DOUBLE_NORMAL[2]['translated_field_en']),
        ]
        self.assertEqual(values_list, check)

    def test_values_list_deferred_language(self):
        with LanguageOverride('ja'):
            qs = Normal.objects.language()
        with LanguageOverride('en'):
            values = qs.values_list('shared_field', 'translated_field')
            values_list = list(values)
        check = [
            (DOUBLE_NORMAL[1]['shared_field'], DOUBLE_NORMAL[1]['translated_field_en']),
            (DOUBLE_NORMAL[2]['shared_field'], DOUBLE_NORMAL[2]['translated_field_en']),
        ]
        self.assertEqual(values_list, check)

class ValuesTests(HvadTestCase, TwoTranslatedNormalMixin):
    def test_values_shared(self):
        values = Normal.objects.language('en').values('shared_field')
        values_list = list(values)
        check = [
            {'shared_field': DOUBLE_NORMAL[1]['shared_field']},
            {'shared_field': DOUBLE_NORMAL[2]['shared_field']},
        ]
        self.assertEqual(values_list, check)
    
    def test_values_translated(self):
        values = Normal.objects.language('en').values('translated_field')
        values_list = list(values)
        check = [
            {'translated_field': DOUBLE_NORMAL[1]['translated_field_en']},
            {'translated_field': DOUBLE_NORMAL[2]['translated_field_en']},
        ]
        self.assertEqual(values_list, check)
        
    def test_values_mixed(self):
        values = Normal.objects.language('en').values('translated_field', 'shared_field')
        values_list = list(values)
        check = [
            {'translated_field': DOUBLE_NORMAL[1]['translated_field_en'],
             'shared_field': DOUBLE_NORMAL[1]['shared_field']},
            {'translated_field': DOUBLE_NORMAL[2]['translated_field_en'],
             'shared_field': DOUBLE_NORMAL[2]['shared_field']},
        ]
        self.assertEqual(values_list, check)
        
    def test_values_post_language(self):
        values = Normal.objects.using_translations().values('shared_field').language('en')
        values_list = list(values)
        check = [
            {'shared_field': DOUBLE_NORMAL[1]['shared_field']},
            {'shared_field': DOUBLE_NORMAL[2]['shared_field']},
        ]
        self.assertEqual(values_list, check)
        
    def test_values_post_filter(self):
        qs = Normal.objects.language('en').values('shared_field')
        values = qs.filter(shared_field=DOUBLE_NORMAL[1]['shared_field'])
        values_list = list(values)
        check = [
            {'shared_field': DOUBLE_NORMAL[1]['shared_field']},
        ]
        self.assertEqual(values_list, check)

    def test_values_deferred_language(self):
        with LanguageOverride('ja'):
            qs = Normal.objects.language()
        with LanguageOverride('en'):
            values = qs.values('translated_field')
            values_list = list(values)
        check = [
            {'translated_field': DOUBLE_NORMAL[1]['translated_field_en']},
            {'translated_field': DOUBLE_NORMAL[2]['translated_field_en']},
        ]
        self.assertEqual(values_list, check)

class InBulkTests(HvadTestCase, TwoTranslatedNormalMixin):
    def setUp(self):
        super(InBulkTests, self).setUp()
        if hasattr(self, 'assertItemsEqual'):
            # method was renamed in Python 3
            self.assertCountEqual = self.assertItemsEqual

    def test_in_bulk(self):
        with self.assertNumQueries(1):
            result = Normal.objects.language('en').in_bulk([1, 2])
            self.assertCountEqual((1, 2), result)
            self.assertEqual(result[1].shared_field, DOUBLE_NORMAL[1]['shared_field'])
            self.assertEqual(result[1].translated_field, DOUBLE_NORMAL[1]['translated_field_en'])
            self.assertEqual(result[1].language_code, 'en')
            self.assertEqual(result[2].shared_field, DOUBLE_NORMAL[2]['shared_field'])
            self.assertEqual(result[2].translated_field, DOUBLE_NORMAL[2]['translated_field_en'])
            self.assertEqual(result[2].language_code, 'en')

    def test_untranslated_in_bulk(self):
        with LanguageOverride('ja'):
            with self.assertNumQueries(2):
                result = Normal.objects.untranslated().in_bulk([1])
                self.assertCountEqual((1,), result)
                self.assertEqual(result[1].shared_field, DOUBLE_NORMAL[1]['shared_field'])
                self.assertEqual(result[1].translated_field, DOUBLE_NORMAL[1]['translated_field_ja'])
                self.assertEqual(result[1].language_code, 'ja')

    def test_all_languages_in_bulk(self):
        with self.assertRaises(ValueError):
            Normal.objects.language('all').in_bulk([1])

    def test_in_bulk_deferred_language(self):
        with LanguageOverride('ja'):
            qs = Normal.objects.language()
        with LanguageOverride('en'):
            result = qs.in_bulk([1])
            self.assertCountEqual((1,), result)
            self.assertEqual(result[1].shared_field, DOUBLE_NORMAL[1]['shared_field'])
            self.assertEqual(result[1].translated_field, DOUBLE_NORMAL[1]['translated_field_en'])
            self.assertEqual(result[1].language_code, 'en')


class DeleteTests(HvadTestCase, TwoTranslatedNormalMixin):
    def test_delete_all(self):
        Normal.objects.all().delete()
        self.assertEqual(Normal.objects.count(), 0)
        self.assertEqual(Normal._meta.translations_model.objects.count(), 0)
        
    def test_delete_translation(self):
        self.assertEqual(Normal._meta.translations_model.objects.count(), 4)
        Normal.objects.language('en').delete_translations()
        self.assertEqual(Normal.objects.untranslated().count(), 2)
        self.assertEqual(Normal._meta.translations_model.objects.count(), 2)
        Normal.objects.language('ja').delete_translations()
        self.assertEqual(Normal.objects.untranslated().count(), 2)
        self.assertEqual(Normal._meta.translations_model.objects.count(), 0)

    def test_filtered_delete_translation(self):
        self.assertEqual(Normal._meta.translations_model.objects.count(), 4)
        (Normal.objects.language('en')
                       .filter(shared_field=DOUBLE_NORMAL[1]['shared_field'])
                       .delete_translations())
        self.assertEqual(Normal.objects.untranslated().count(), 2)
        self.assertEqual(Normal._meta.translations_model.objects.count(), 3)
        (Normal.objects.language('ja')
                       .filter(translated_field=DOUBLE_NORMAL[2]['translated_field_ja'])
                       .delete_translations())
        self.assertEqual(Normal.objects.untranslated().count(), 2)
        self.assertEqual(Normal._meta.translations_model.objects.count(), 2)

    def test_delete_translation_deferred_language(self):
        self.assertEqual(Normal._meta.translations_model.objects.count(), 4)
        with LanguageOverride('ja'):
            qs = Normal.objects.language()
        with LanguageOverride('en'):
            qs.delete_translations()

        self.assertEqual(Normal.objects.language('ja').count(), 2)
        self.assertEqual(Normal.objects.language('en').count(), 0)


class GetTranslationFromInstanceTests(HvadTestCase):
    def test_simple(self):
        # Create the instances
        SHARED = 'shared'
        TRANS_EN = 'English'
        TRANS_JA = u'日本語'
        en = Normal.objects.language('en').create(
            shared_field=SHARED,
            translated_field=TRANS_EN,
        )
        ja = en
        ja.translate('ja')
        ja.translated_field = TRANS_JA
        ja.save()
        
        # get the english instance
        en = Normal.objects.language('en').get()
        
        # get the japanese *translations*
        ja_trans = en.translations.get_language('ja')
        
        # get the japanese *combined*
        
        ja = Normal.objects.language('ja').get(pk=en.pk)
        
        self.assertEqual(en.shared_field, SHARED)
        self.assertEqual(en.translated_field, TRANS_EN)
        self.assertRaises(AttributeError, getattr, ja_trans, 'shared_field')
        self.assertEqual(ja_trans.translated_field, TRANS_JA)
        self.assertEqual(ja.shared_field, SHARED)
        self.assertEqual(ja.translated_field, TRANS_JA)


class AggregateTests(HvadTestCase):
    def test_aggregate(self):
        from django.db.models import Avg

        # Initial data
        AggregateModel.objects.language("en").create(number=10, translated_number=20)
        AggregateModel.objects.language("en").create(number=0, translated_number=0)

        # Check both the translated and the shared aggregates as arguments
        self.assertEqual(AggregateModel.objects.language("en").aggregate(Avg("number")), {'number__avg': 5})
        self.assertEqual(AggregateModel.objects.language("en").aggregate(Avg("translated_number")), {'translated_number__avg': 10})

        # Check the same calculation, but with keyword arguments
        self.assertEqual(AggregateModel.objects.language("en").aggregate(num=Avg("number")), {'num': 5})
        self.assertEqual(AggregateModel.objects.language("en").aggregate(tnum=Avg("translated_number")), {'tnum': 10})


class NotImplementedTests(HvadTestCase):
    def test_defer(self):
        baseqs = SimpleRelated.objects.language('en')
        
        self.assertRaises(NotImplementedError, baseqs.defer, 'shared_field')
        self.assertRaises(NotImplementedError, baseqs.annotate)
        self.assertRaises(NotImplementedError, baseqs.only)
        self.assertRaises(NotImplementedError, baseqs.bulk_create, [])
        # select_related with no field is not implemented
        self.assertRaises(NotImplementedError, baseqs.select_related)
        # select_related with language('all') is not implemented
        self.assertRaises(NotImplementedError, len, baseqs.language('all').select_related('normal'))
        if django.VERSION >= (1, 7):
            self.assertRaises(NotImplementedError, baseqs.update_or_create)


class ExcludeTests(HvadTestCase):
    SHARED = 'shared'
    TRANS_EN = 'English'
    TRANS_JA = u'日本語'

    def setUp(self):
        super(ExcludeTests, self).setUp()
        en = Normal.objects.language('en').create(
            shared_field=self.SHARED,
            translated_field=self.TRANS_EN,
        )
        ja = en
        ja.translate('ja')
        ja.translated_field = self.TRANS_JA
        ja.save()

    def test_defer(self):
        qs = Normal.objects.language('en').exclude(translated_field=self.TRANS_EN)
        self.assertEqual(qs.count(), 0)

    def test_all_languages_exclude(self):
        qs = Normal.objects.language('all').exclude(translated_field=self.TRANS_EN)
        self.assertEqual(qs.count(), 1)
        self.assertEqual(qs[0].translated_field, self.TRANS_JA)


class ComplexFilterTests(HvadTestCase, TwoTranslatedNormalMixin):
    def test_qobject_filter(self):
        shared_contains_one = Q(shared_field__contains='1')
        shared_contains_two = Q(shared_field__contains='2')

        qs = Normal.objects.language('en').filter(shared_contains_two)
        self.assertEqual(qs.count(), 1)
        obj = qs[0]
        self.assertEqual(obj.shared_field, DOUBLE_NORMAL[2]['shared_field'])
        self.assertEqual(obj.translated_field, DOUBLE_NORMAL[2]['translated_field_en'])

        qs = (Normal.objects.language('ja').filter(Q(shared_contains_one | shared_contains_two))
                                           .order_by('shared_field'))
        self.assertEqual(qs.count(), 2)
        obj = qs[0]
        self.assertEqual(obj.shared_field, DOUBLE_NORMAL[1]['shared_field'])
        self.assertEqual(obj.translated_field, DOUBLE_NORMAL[1]['translated_field_ja'])
        obj = qs[1]
        self.assertEqual(obj.shared_field, DOUBLE_NORMAL[2]['shared_field'])
        self.assertEqual(obj.translated_field, DOUBLE_NORMAL[2]['translated_field_ja'])

    def test_aware_qobject_filter(self):
        STANDARD={1: u'normal1', 2: u'normal2'}
        Standard.objects.create(
            normal_field=STANDARD[1],
            normal=Normal.objects.untranslated().get(
                shared_field=DOUBLE_NORMAL[1]['shared_field']
            )
        )
        Standard.objects.create(
            normal_field=STANDARD[2],
            normal=Normal.objects.untranslated().get(
                shared_field=DOUBLE_NORMAL[2]['shared_field']
            )
        )

        from hvad.utils import get_translation_aware_manager
        manager = get_translation_aware_manager(Standard)

        normal_one = Q(normal_field=STANDARD[1])
        normal_two = Q(normal_field=STANDARD[2])
        shared_one = Q(normal__shared_field=DOUBLE_NORMAL[1]['shared_field'])
        translated_one_en = Q(normal__translated_field=DOUBLE_NORMAL[1]['translated_field_en'])
        translated_two_en = Q(normal__translated_field=DOUBLE_NORMAL[2]['translated_field_en'])

        # control group test
        with LanguageOverride('en'):
            qs = manager.filter(shared_one)
            self.assertEqual(qs.count(), 1)
            obj = qs[0]
            self.assertEqual(obj.normal_field, STANDARD[1])

            # basic Q object test
            qs = manager.filter(translated_one_en)
            self.assertEqual(qs.count(), 1)
            obj = qs[0]
            self.assertEqual(obj.normal_field, STANDARD[1])

            # test various intersection combinations
            # use a spurious Q to test the logic of recursion along the way
            qs = manager.filter(Q(normal_one & shared_one & translated_one_en))
            self.assertEqual(qs.count(), 1)
            obj = qs[0]
            self.assertEqual(obj.normal_field, STANDARD[1])

            qs = manager.filter(Q(normal_one & translated_two_en))
            self.assertEqual(qs.count(), 0)
            qs = manager.filter(Q(shared_one & translated_two_en))
            self.assertEqual(qs.count(), 0)
            qs = manager.filter(Q(translated_one_en & translated_two_en))
            self.assertEqual(qs.count(), 0)

            # test various union combinations
            qs = manager.filter(Q(normal_one | translated_one_en))
            self.assertEqual(qs.count(), 2)
            qs = manager.filter(Q(shared_one | translated_one_en))
            self.assertEqual(qs.count(), 2)

            qs = manager.filter(Q(normal_one | translated_two_en))
            self.assertEqual(qs.count(), 3)
            qs = manager.filter(Q(shared_one | translated_two_en))
            self.assertEqual(qs.count(), 3)

            qs = manager.filter(Q(translated_one_en | translated_two_en))
            self.assertEqual(qs.count(), 2)

            # misc more complex combinations
            qs = manager.filter(Q(normal_one & (translated_one_en | translated_two_en)))
            self.assertEqual(qs.count(), 1)
            qs = manager.filter(Q(normal_two & (translated_one_en | translated_two_en)))
            self.assertEqual(qs.count(), 1)
            qs = manager.filter(shared_one & ~translated_one_en)
            self.assertEqual(qs.count(), 0)
            qs = manager.filter(shared_one & ~translated_two_en)
            self.assertEqual(qs.count(), 1)

    def test_defer(self):
        qs = Normal.objects.language('en').complex_filter({})
        self.assertEqual(qs.count(), 2)
        self.assertRaises(NotImplementedError, Normal.objects.language('en').complex_filter, Q(shared_field=DOUBLE_NORMAL[1]['shared_field']))

########NEW FILE########
__FILENAME__ = related
# -*- coding: utf-8 -*-
import django
from django.core.exceptions import FieldError
from django.db import models
from django.db.models.query_utils import Q
from hvad.exceptions import WrongManager
from hvad.models import (TranslatedFields, TranslatableModel)
from hvad.test_utils.context_managers import LanguageOverride
from hvad.test_utils.fixtures import (OneSingleTranslatedNormalMixin, 
    TwoNormalOneStandardMixin, TwoTranslatedNormalMixin)
from hvad.test_utils.testcase import HvadTestCase
from hvad.utils import get_translation_aware_manager
from hvad.test_utils.project.app.models import Normal, Related, SimpleRelated, Standard, Other


class NormalToNormalFKTest(HvadTestCase, OneSingleTranslatedNormalMixin):
    def test_relation(self):
        """
        'normal' (aka 'shared') relations are relations from the shared (or
        normal) model to another shared (or normal) model.

        They should behave like normal foreign keys in Django
        """
        normal = Normal.objects.language('en').get(pk=1)
        related = Related.objects.create(normal=normal)
        self.assertEqual(related.normal.pk, normal.pk)
        self.assertEqual(related.normal.shared_field, normal.shared_field)
        self.assertEqual(related.normal.translated_field, normal.translated_field)
        self.assertTrue(related in normal.rel1.all())
    
    def test_failed_relation(self):
        related = Related.objects.create()
        related.normal_id = 999
        related.save()
        self.assertRaises(Normal.DoesNotExist, getattr, related, 'normal')
        


class StandardToTransFKTest(HvadTestCase, TwoNormalOneStandardMixin):
    def test_relation(self):
        en = Normal.objects.language('en').get(pk=1)
        ja = Normal.objects.language('ja').get(pk=1)
        related = Standard.objects.get(pk=1)
        with LanguageOverride('en'):
            related = self.reload(related)
            self.assertEqual(related.normal.pk, en.pk)
            self.assertEqual(related.normal.shared_field, en.shared_field)
            self.assertEqual(related.normal.translated_field, en.translated_field)
            self.assertTrue(related in en.standards.all())
        with LanguageOverride('ja'):
            related = self.reload(related)
            self.assertEqual(related.normal.pk, ja.pk)
            self.assertEqual(related.normal.shared_field, ja.shared_field)
            self.assertEqual(related.normal.translated_field, ja.translated_field)
            self.assertTrue(related in ja.standards.all())

    def test_num_queries(self):
        with LanguageOverride('en'):
            en = Normal.objects.language('en').get(pk=1)
            with self.assertNumQueries(1):
                related = Standard.objects.select_related('normal').get(pk=1)
                self.assertEqual(related.normal.pk, en.pk)
            with self.assertNumQueries(0):
                self.assertEqual(related.normal.shared_field, en.shared_field)
            with self.assertNumQueries(1):
                self.assertEqual(related.normal.translated_field, en.translated_field)

    def test_lookup_by_pk(self):
        en = Normal.objects.language('en').get(pk=1)
        by_pk = Standard.objects.get(normal__pk=en.pk)
        with LanguageOverride('en'):
            self.assertEqual(by_pk.normal.pk, en.pk)
            self.assertEqual(by_pk.normal.shared_field, en.shared_field)
            self.assertEqual(by_pk.normal.translated_field, en.translated_field)
            self.assertTrue(by_pk in en.standards.all())

    def test_lookup_by_shared_field(self):
        en = Normal.objects.language('en').get(pk=1)
        by_shared_field = Standard.objects.get(normal__shared_field=en.shared_field)
        with LanguageOverride('en'):
            self.assertEqual(by_shared_field.normal.pk, en.pk)
            self.assertEqual(by_shared_field.normal.shared_field, en.shared_field)
            self.assertEqual(by_shared_field.normal.translated_field, en.translated_field)
            self.assertTrue(by_shared_field in en.standards.all())

    def test_lookup_by_translated_field(self):
        en = Normal.objects.language('en').get(pk=1)
        translation_aware_manager = get_translation_aware_manager(Standard)
        with LanguageOverride('en'):
            by_translated_field = translation_aware_manager.get(normal__translated_field=en.translated_field)
            self.assertEqual(by_translated_field.normal.pk, en.pk)
            self.assertEqual(by_translated_field.normal.shared_field, en.shared_field)
            self.assertEqual(by_translated_field.normal.translated_field, en.translated_field)
            self.assertTrue(by_translated_field in en.standards.all())

    def test_lookup_by_translated_field_requires_translation_aware_manager(self):
        en = Normal.objects.language('en').get(pk=1)
        with LanguageOverride('en'):
            self.assertRaises(WrongManager, Standard.objects.get,
                              normal__translated_field=en.translated_field)
    
    def test_lookup_by_non_existing_field(self):
        with LanguageOverride('en'):
            if django.VERSION >= (1, 7):
                self.assertRaises(TypeError, Standard.objects.get,
                                normal__non_existing_field=1)
            else:
                self.assertRaises(FieldError, Standard.objects.get,
                                normal__non_existing_field=1)
        

    def test_lookup_by_translated_field_using_q_objects(self):
        en = Normal.objects.language('en').get(pk=1)
        translation_aware_manager = get_translation_aware_manager(Standard)
        with LanguageOverride('en'):
            q = Q(normal__translated_field=en.translated_field)
            by_translated_field = translation_aware_manager.get(q)
            self.assertEqual(by_translated_field.normal.pk, en.pk)
            self.assertEqual(by_translated_field.normal.shared_field, en.shared_field)
            self.assertEqual(by_translated_field.normal.translated_field, en.translated_field)
            self.assertTrue(by_translated_field in en.standards.all())

    def test_filter_by_shared_field(self):
        en = Normal.objects.language('en').get(pk=1)
        with LanguageOverride('en'):
            by_shared_field = Standard.objects.filter(normal__shared_field=en.shared_field)
            normals = [obj.normal.pk for obj in by_shared_field]
            expected = [en.pk]
            self.assertEqual(normals, expected)
            shared_fields = [obj.normal.shared_field for obj in by_shared_field]
            expected_fields = [en.shared_field]
            self.assertEqual(shared_fields, expected_fields)
            translated_fields = [obj.normal.translated_field for obj in by_shared_field]
            expected_fields = [en.translated_field]
            self.assertEqual(translated_fields, expected_fields)
            for obj in by_shared_field:
                self.assertTrue(obj in en.standards.all())

    def test_filter_by_translated_field(self):
        en = Normal.objects.language('en').get(pk=1)
        translation_aware_manager = get_translation_aware_manager(Standard)
        with LanguageOverride('en'):
            by_translated_field = translation_aware_manager.filter(normal__translated_field=en.translated_field)
            normals = [obj.normal.pk for obj in by_translated_field]
            expected = [en.pk]
            self.assertEqual(normals, expected)
            shared_fields = [obj.normal.shared_field for obj in by_translated_field]
            expected_fields = [en.shared_field]
            self.assertEqual(shared_fields, expected_fields)
            translated_fields = [obj.normal.translated_field for obj in by_translated_field]
            expected_fields = [en.translated_field]
            self.assertEqual(translated_fields, expected_fields)
            for obj in by_translated_field:
                self.assertTrue(obj in en.standards.all())

    def test_filter_by_translated_field_requires_translation_aware_manager(self):
        en = Normal.objects.language('en').get(pk=1)
        with LanguageOverride('en'):
            self.assertRaises(WrongManager, Standard.objects.filter,
                              normal__translated_field=en.translated_field)

    def test_filter_by_translated_field_using_q_objects(self):
        en = Normal.objects.language('en').get(pk=1)
        translation_aware_manager = get_translation_aware_manager(Standard)
        with LanguageOverride('en'):
            q = Q(normal__translated_field=en.translated_field)
            by_translated_field = translation_aware_manager.filter(q)
            normals = [obj.normal.pk for obj in by_translated_field]
            expected = [en.pk]
            self.assertEqual(normals, expected)
            shared_fields = [obj.normal.shared_field for obj in by_translated_field]
            expected_fields = [en.shared_field]
            self.assertEqual(shared_fields, expected_fields)
            translated_fields = [obj.normal.translated_field for obj in by_translated_field]
            expected_fields = [en.translated_field]
            self.assertEqual(translated_fields, expected_fields)
            for obj in by_translated_field:
                self.assertTrue(obj in en.standards.all())


class TripleRelationTests(HvadTestCase):
    def test_triple(self):
        normal = Normal.objects.language('en').create(shared_field='SHARED', translated_field='English')
        other = Other.objects.create(normal=normal)
        standard = Standard.objects.create(normal=normal, normal_field='NORMAL FIELD')

        obj = Normal.objects.language('en').get(standards__pk=standard.pk)
        self.assertEqual(obj.pk, normal.pk)

        obj = Normal.objects.language('en').get(others__pk=other.pk)
        self.assertEqual(obj.pk, normal.pk)

        # We created an english Normal object, so we want to make sure that we use 'en'
        with LanguageOverride('en'):
            obj = get_translation_aware_manager(Standard).get(normal__others__pk=other.pk)
            self.assertEqual(obj.pk, standard.pk)

        # If we don't use language 'en', it should give DoesNotExist, when using the
        # translation aware manager
        with LanguageOverride('ja'):
            manager = get_translation_aware_manager(Standard)
            self.assertRaises(Standard.DoesNotExist, manager.get, normal__others__pk=other.pk)

        # However, if we don't use the translation aware manager, we can query any
        # the shared fields in any language, and it should return the object,
        # even though there is no translated Normal objects
        with LanguageOverride('ja'):
            obj = Standard.objects.get(normal__others__pk=other.pk)
            self.assertEqual(obj.pk, standard.pk)


class ManyToManyTest(HvadTestCase, TwoTranslatedNormalMixin):
    def test_triple(self):
        normal1 = Normal.objects.language('en').get(pk=1)
        many = normal1.manyrels.create(name="many1")
        
        with LanguageOverride('en'):
            # Get the Normal objects associated with the Many object "many1":
            normals = Normal.objects.language().filter(manyrels__id=many.pk).order_by("translated_field")
            self.assertEqual([n.pk for n in normals], [normal1.pk])
            
            # Same thing, another way:
            normals = many.normals.language() # This query is fetching Normal objects that are not associated with the Many object "many" !
            normals_plain = many.normals.all()
            # The two queries above should return the same objects, since all normals are translated
            self.assertEqual([n.pk for n in normals], [n.pk for n in normals_plain])


class ForwardDeclaringForeignKeyTests(HvadTestCase):
    def test_issue_22(self):
        class ForwardRelated(TranslatableModel):
            shared_field = models.CharField(max_length=255)
            translations = TranslatedFields(
                translated = models.ForeignKey("ReverseRelated", related_name='rel', null=True),
            )
        
        
        class ReverseRelated(TranslatableModel):
            shared_field = models.CharField(max_length=255)
        
            translated_fields = TranslatedFields(
                translated = models.CharField(max_length=1)
            )
    def test_issue_22_non_translatable_model(self):
        class ForwardRelated2(models.Model):
            shared_field = models.CharField(max_length=255)
            fk = models.ForeignKey("ReverseRelated2", related_name='rel', null=True)
        
        
        class ReverseRelated2(TranslatableModel):
            shared_field = models.CharField(max_length=255)
        
            translated_fields = TranslatedFields(
                translated = models.CharField(max_length=1)
            )


class SelectRelatedTests(HvadTestCase, TwoTranslatedNormalMixin):
    def create_fixtures(self):
        super(SelectRelatedTests, self).create_fixtures()
        with LanguageOverride('en'):
            self.normal1 = Normal.objects.language().get(pk=1)
            SimpleRelated.objects.language().create(normal=self.normal1, translated_field="test1")
        
    def test_select_related(self):
        with LanguageOverride('en'):  
            self.normal2 = Normal.objects.language().get(pk=2)
            SimpleRelated.objects.language().create(normal=self.normal2, translated_field="test2")
            
            with self.assertNumQueries(1):
                rel_objects = SimpleRelated.objects.language().select_related('normal')
                for r in rel_objects:
                    if r.normal_id == 1:
                        self.assertEqual(self.normal1.shared_field, r.normal.shared_field)
                        self.assertEqual(self.normal1.translated_field, r.normal.translated_field)
                    else:
                        self.assertEqual(self.normal2.shared_field, r.normal.shared_field)
                        self.assertEqual(self.normal2.translated_field, r.normal.translated_field)

    def test_select_related_using_get(self):
        with LanguageOverride('en'):  
            with self.assertNumQueries(1):
                r = SimpleRelated.objects.language().select_related('normal').get(translated_field="test1")
                self.assertEqual(r.normal.pk, 1)
                self.assertEqual(self.normal1.shared_field, r.normal.shared_field)
                self.assertEqual(self.normal1.translated_field, r.normal.translated_field)
                
    def test_select_related_from_translated_field(self):
        with LanguageOverride('en'):
            Related.objects.language().create(pk=1, translated=self.normal1).save()
            with self.assertNumQueries(1):
                r = Related.objects.language().select_related('translated').get(translated=self.normal1)
                self.assertEqual(r.translated.pk, 1)
                self.assertEqual(self.normal1.shared_field, r.translated.shared_field)
                self.assertEqual(self.normal1.translated_field, r.translated.translated_field)

    def test_select_related_with_null_relation(self):
        with LanguageOverride('en'):
            # First, two Normal objects are created by TwoTranslatedNormalMixin (in English and Japanese)
            related1 = Related.objects.language().create(normal=self.normal1, translated=self.normal1)
            # Now we create another, but with relations set to None:
            related2 = Related.objects.language().create(normal=None, translated=None)

            with self.assertNumQueries(1):
                rel_objects = Related.objects.language().select_related('normal', 'translated')
                #print(rel_objects.query) # Note: uncommenting this line causes the test to fail, which shouldn't happen :-()
                self.assertEqual(len(rel_objects), 2)
                for r in rel_objects:
                    if (r.id == related1.id):
                        self.assertEqual(self.normal1.translated_field, r.normal.translated_field)
                        self.assertEqual(self.normal1.translated_field, r.translated.translated_field)
                    elif (r.id == related2.id):
                        self.assertEqual(r.normal, None)
                        self.assertEqual(r.translated, None)
                    else:
                        self.fail("Invalid Related object; ID is %s" % r.id)

########NEW FILE########
__FILENAME__ = serialization
import pickle
from hvad.test_utils.testcase import HvadTestCase
from hvad.test_utils.context_managers import LanguageOverride
from hvad.test_utils.project.app.models import Normal

class PicklingTest(HvadTestCase):
    def test_untranslated_new_object_can_be_pickled(self):
        normal = Normal(shared_field="Shared")
        serialized_repr = pickle.dumps(normal)

        unpickled = pickle.loads(serialized_repr)
        self.assertEqual(normal.shared_field, unpickled.shared_field)

    def test_translated_new_object_can_be_pickled(self):
        normal = Normal(shared_field="Shared")
        normal.translate("en")
        normal.translated_field = "English"
        serialized_repr = pickle.dumps(normal)

        unpickled = pickle.loads(serialized_repr)
        self.assertEqual(normal.shared_field, unpickled.shared_field)
        self.assertEqual(normal.language_code, unpickled.language_code)
        self.assertEqual(normal.translated_field, unpickled.translated_field)
        
    def test_untranslated_object_can_be_pickled(self):
        normal = Normal.objects.create(
            shared_field="Shared",
        )
        serialized_repr = pickle.dumps(normal)

        unpickled = pickle.loads(serialized_repr)
        self.assertEqual(normal.shared_field, unpickled.shared_field)

    def test_translated_object_can_be_pickled(self):
        with LanguageOverride('en'):
            normal = Normal.objects.create(
                shared_field="Shared",
                translated_field = "English",
            )
        serialized_repr = pickle.dumps(normal)

        unpickled = pickle.loads(serialized_repr)
        self.assertEqual(normal.shared_field, unpickled.shared_field)
        self.assertEqual(normal.language_code, unpickled.language_code)
        self.assertEqual(normal.translated_field, unpickled.translated_field)

    def test_queryset_can_be_pickled(self):
        normal = Normal.objects.create(
            shared_field="Shared",
        )
        qs = Normal.objects.all()
        serialized_repr = pickle.dumps(qs)

        unpickled = pickle.loads(serialized_repr)
        self.assertEqual(unpickled.model, qs.model)
        self.assertEqual(unpickled.get(pk=normal.pk), normal)

    def test_queryset_with_translated_objects_can_be_pickled(self):
        with LanguageOverride('en'):
            normal = Normal.objects.create(
                shared_field="Shared",
                translated_field = "English",
            )
        qs = Normal.objects.all()
        serialized_repr = pickle.dumps(qs)

        unpickled = pickle.loads(serialized_repr)
        self.assertEqual(unpickled.model, qs.model)
        self.assertEqual(unpickled.get(pk=normal.pk), normal)

    def test_translated_queryset_with_translated_objects_can_be_pickled(self):
        with LanguageOverride('en'):
            normal = Normal.objects.create(
                shared_field="Shared",
                translated_field = "English",
            )
        qs = Normal.objects.language('en').all()
        serialized_repr = pickle.dumps(qs)

        unpickled = pickle.loads(serialized_repr)
        self.assertEqual(unpickled.model, qs.model)
        self.assertEqual(unpickled.get(pk=normal.pk), normal)

########NEW FILE########
__FILENAME__ = views
# -*- coding: utf-8 -*-
from django.core.urlresolvers import reverse
from hvad.test_utils.context_managers import LanguageOverride
from hvad.test_utils.testcase import HvadTestCase
from hvad.test_utils.request_factory import RequestFactory
from hvad.test_utils.project.app.models import Normal
from hvad.views import TranslatableUpdateView

class ViewsTest(HvadTestCase):
    def setUp(self):
        with LanguageOverride("en"):
            self.object = Normal.objects.language().create(shared_field="test", translated_field="translated test")

            self.rf = RequestFactory()
            self.request = self.rf.post('/url/')

    def test_update_view_get(self):
        with LanguageOverride("en"):
            response = self.client.get(reverse('update_normal', args=[self.object.id]))
            self.assertEqual(response.status_code, 200)

            response = self.client.get(reverse('update_normal_slug', kwargs={'slug': self.object.shared_field}))
            self.assertEqual(response.status_code, 200)

            response = self.client.get(reverse('update_normal', args=[self.object.id]) + "?%s=da" % TranslatableUpdateView.query_language_key)
            self.assertEqual(response.status_code, 200)

            response = self.client.get(reverse('update_normal', args=[self.object.id * 100]) + "?%s=da" % TranslatableUpdateView.query_language_key)
            self.assertEqual(response.status_code, 404)

    def test_update_view_post(self):
        with LanguageOverride("en"):
            translated_string = u"some english translation"
            url = reverse('update_normal', args=[self.object.id])
            response = self.client.post(url,
                data={
                    'shared_field': 'some value',
                    'translated_field': translated_string,
                })
            self.assertEqual(response.status_code, 302)
            obj = Normal.objects.language().filter(pk=self.object.id).get()
            self.assertEqual(obj.translated_field, translated_string)

            translated_string = u"svenne banan æøå"
            response = self.client.post(
                url + "?%s=da" % TranslatableUpdateView.query_language_key,
                data={
                    'shared_field': 'some value',
                    'translated_field': translated_string,
                })
            self.assertEqual(response.status_code, 302)
            obj = Normal.objects.language("da").filter(pk=self.object.id).get()
            self.assertEqual(obj.translated_field, translated_string)


########NEW FILE########
__FILENAME__ = cli
# -*- coding: utf-8 -*-
import sys
import django
from hvad.test_utils.dj_database_url import config
import os

gettext = lambda s: s

PYTHON_VERSION = '%s.%s' % sys.version_info[:2]
DJANGO_VERSION = django.get_version()


def configure(**extra):
    from django.conf import settings
    os.environ['DJANGO_SETTINGS_MODULE'] = 'hvad.test_utils.cli'
    defaults = dict(
        CACHE_BACKEND = 'locmem:///',
        DEBUG = True,
        TEMPLATE_DEBUG = True,
        DATABASE_SUPPORTS_TRANSACTIONS = True,
        DATABASES = {'default': config(default='sqlite://localhost/hvad.db')},
        TEST_DATABASE_CHARSET = "utf8",
        TEST_DATABASE_COLLATION = "utf8_general_ci",
        SITE_ID = 1,
        USE_I18N = True,
        MEDIA_ROOT = '/media/',
        STATIC_ROOT = '/static/',
        MEDIA_URL = '/media/',
        STATIC_URL = '/static/',
        ADMIN_MEDIA_PREFIX = '/static/admin/',
        EMAIL_BACKEND = 'django.core.mail.backends.locmem.EmailBackend',
        SECRET_KEY = 'key',
        TEMPLATE_LOADERS = (
            'django.template.loaders.filesystem.Loader',
            'django.template.loaders.app_directories.Loader',
            'django.template.loaders.eggs.Loader',
        ),
        TEMPLATE_DIRS = [
            os.path.abspath(os.path.join(os.path.dirname(__file__), 'project', 'templates'))
        ],
        MIDDLEWARE_CLASSES = [
            'django.contrib.sessions.middleware.SessionMiddleware',
            'django.contrib.auth.middleware.AuthenticationMiddleware',
            'django.contrib.messages.middleware.MessageMiddleware',
            'django.middleware.common.CommonMiddleware',
            ('django.contrib.admindocs.middleware.XViewMiddleware'
             if django.VERSION >= (1, 7) else 'django.middleware.doc.XViewMiddleware'),
            'django.middleware.csrf.CsrfViewMiddleware',
        ],
        INSTALLED_APPS = [
            'django.contrib.auth',
            'django.contrib.contenttypes',
            'django.contrib.sessions',
            'django.contrib.admin',
            'django.contrib.sites',
            'django.contrib.staticfiles',
            'hvad',
            'hvad.test_utils.project.app',
            'hvad.test_utils.project.alternate_models_app',
        ],
        LANGUAGE_CODE = "en",
        LANGUAGES = (
            ('en', 'English'),
            ('ja', u'日本語'),
        ),
        JUNIT_OUTPUT_DIR = 'junit-dj%s-py%s' % (DJANGO_VERSION, PYTHON_VERSION),
        ROOT_URLCONF = 'hvad.test_utils.project.urls',
        PASSWORD_HASHERS = (
            'django.contrib.auth.hashers.MD5PasswordHasher',
        )
    )
    defaults.update(extra)
    settings.configure(**defaults)
    from django.contrib import admin
    if django.VERSION >= (1, 7):
        django.setup()
    admin.autodiscover()

########NEW FILE########
__FILENAME__ = context_managers
# -*- coding: utf-8 -*-
"""
This code was mostly taken from the django-cms
(https://github.com/divio/django-cms) with permission by it's lead developer.
"""
from django.utils.translation import get_language, activate
from shutil import rmtree as _rmtree
from tempfile import template, mkdtemp, _exists


class LanguageOverride(object):
    def __init__(self, language):
        self.newlang = language
        
    def __enter__(self):
        self.oldlang = get_language()
        activate(self.newlang)
        
    def __exit__(self, type, value, traceback):
        activate(self.oldlang)


class TemporaryDirectory:
    """Create and return a temporary directory.  This has the same
    behavior as mkdtemp but can be used as a context manager.  For
    example:

        with TemporaryDirectory() as tmpdir:
            ...

    Upon exiting the context, the directory and everthing contained
    in it are removed.
    """

    def __init__(self, suffix="", prefix=template, dir=None):
        self.name = mkdtemp(suffix, prefix, dir)

    def __enter__(self):
        return self.name

    def cleanup(self):
        if _exists(self.name):
            _rmtree(self.name)

    def __exit__(self, exc, value, tb):
        self.cleanup()


class UserLoginContext(object):
    def __init__(self, testcase, **kwargs):
        self.testcase = testcase
        self.kwargs = kwargs
        
    def __enter__(self):
        self.testcase.assertTrue(self.testcase.client.login(**self.kwargs))
        
    def __exit__(self, exc, value, tb):
        self.testcase.client.logout()

########NEW FILE########
__FILENAME__ = data
# -*- coding: utf-8 -*-
from datetime import datetime
    
DOUBLE_NORMAL = {
    1: {
        'shared_field': u'Shared1',
        'translated_field_en': u'English1',
        'translated_field_ja': u'日本語一',
    },
    2: {
        'shared_field': u'Shared2',
        'translated_field_en': u'English2',
        'translated_field_ja': u'日本語二',
    },
}

D1 = datetime(year=1988, month=7, day=4)
D2 = datetime(year=2011, month=1, day=26)
D3 = datetime(year=2011, month=2, day=16, hour=5, minute=1, second=14)

DATES = {
    1: {
        'shared_date': D1, 
        'translated_date_en': D3,
        'translated_date_ja': D2,
    },
    2: {
        'shared_date': D3, 
        'translated_date_en': D2,
        'translated_date_ja': D1,
    },
    3: {
        'shared_date': D2, 
        'translated_date_en': D1,
        'translated_date_ja': D3,
    },
}

DATES_REVERSED = {}
for pk, data in DATES.items():
    for key, value in data.items():
        if value not in DATES_REVERSED:
            DATES_REVERSED[value] = {}
        DATES_REVERSED[value][key] = pk
########NEW FILE########
__FILENAME__ = dj_database_url
# -*- coding: utf-8 -*-
"""
Copyright (c) 2012, Kenneth Reitz
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"""

import os

try:
    import urlparse
except ImportError:
    import urllib.parse as urlparse



# Register database schemes in URLs.
urlparse.uses_netloc.append('postgres')
urlparse.uses_netloc.append('postgresql')
urlparse.uses_netloc.append('postgis')
urlparse.uses_netloc.append('mysql')
urlparse.uses_netloc.append('mysql2')
urlparse.uses_netloc.append('sqlite')

DEFAULT_ENV = 'DATABASE_URL'

SCHEMES = {
    'postgres': 'django.db.backends.postgresql_psycopg2',
    'postgresql': 'django.db.backends.postgresql_psycopg2',
    'postgis': 'django.contrib.gis.db.backends.postgis',
    'mysql': 'django.db.backends.mysql',
    'mysql2': 'django.db.backends.mysql',
    'sqlite': 'django.db.backends.sqlite3'
}


def config(env=DEFAULT_ENV, default=None):
    """Returns configured DATABASE dictionary from DATABASE_URL."""

    config = {}

    s = os.environ.get(env, default)

    if s:
        config = parse(s)

    return config


def parse(url):
    """Parses a database URL."""

    config = {}

    url = urlparse.urlparse(url)

    # Remove query strings.
    path = url.path[1:]
    path = path.split('?', 2)[0]

    # Update with environment configuration.
    config.update({
        'NAME': path,
        'USER': url.username,
        'PASSWORD': url.password,
        'HOST': url.hostname,
        'PORT': url.port,
        })

    if url.scheme in SCHEMES:
        config['ENGINE'] = SCHEMES[url.scheme]

    return config

########NEW FILE########
__FILENAME__ = fixtures
# -*- coding: utf-8 -*-
from django.contrib.auth.models import User
from hvad.test_utils.data import DOUBLE_NORMAL, D1, D3, D2
from hvad.test_utils.project.app.models import Normal, Date, Standard, ConcreteAB


class Fixture(object):
    def create_fixtures(self):
        pass


class OneSingleTranslatedNormalMixin(Fixture):
    def create_fixtures(self):
        Normal.objects.language('en').create(
            shared_field='shared',
            translated_field='English'
        )
        super(OneSingleTranslatedNormalMixin, self).create_fixtures()


class TwoTranslatedNormalMixin(Fixture):
    def create_fixtures(self):
        en1 = Normal.objects.language('en').create(
            shared_field = 'Shared1',
            translated_field = 'English1',
        )
        ja1 = en1.translate('ja')
        ja1.translated_field = u'日本語一'
        ja1.save()
        
        en2 = Normal.objects.language('en').create(
            shared_field = 'Shared2',
            translated_field = 'English2',
        )
        ja2 = en2.translate('ja')
        ja2.translated_field = u'日本語二'
        ja2.save()
        super(TwoTranslatedNormalMixin, self).create_fixtures()


class TwoTranslatedConcreteABMixin(TwoTranslatedNormalMixin):
    def create_fixtures(self):
        super(TwoTranslatedConcreteABMixin, self).create_fixtures()
        normal1 = Normal.objects.language('en').get(shared_field='Shared1')
        normal2 = Normal.objects.language('en').get(shared_field='Shared2')

        ab1 = ConcreteAB.objects.language('en').create(
            shared_field_a = DOUBLE_NORMAL[1]['shared_field'],
            shared_field_b = normal1,
            shared_field_ab = DOUBLE_NORMAL[1]['shared_field'],
            translated_field_a = normal1,
            translated_field_b = DOUBLE_NORMAL[1]['translated_field_en'],
            translated_field_ab = DOUBLE_NORMAL[1]['translated_field_en'],
        )
        ab1.translate('ja')
        ab1.translated_field_a = normal2
        ab1.translated_field_b = DOUBLE_NORMAL[1]['translated_field_ja']
        ab1.translated_field_ab = DOUBLE_NORMAL[1]['translated_field_ja']
        ab1.save()

        ab2 = ConcreteAB.objects.language('ja').create(
            shared_field_a = DOUBLE_NORMAL[2]['shared_field'],
            shared_field_b = normal2,
            shared_field_ab = DOUBLE_NORMAL[2]['shared_field'],
            translated_field_a = normal2,
            translated_field_b = DOUBLE_NORMAL[2]['translated_field_ja'],
            translated_field_ab = DOUBLE_NORMAL[2]['translated_field_ja'],
        )
        ab2.translate('en')
        ab2.translated_field_a = normal1
        ab2.translated_field_b = DOUBLE_NORMAL[2]['translated_field_en']
        ab2.translated_field_ab = DOUBLE_NORMAL[2]['translated_field_en']
        ab2.save()

class SuperuserMixin(Fixture):
    def create_fixtures(self):
        su = User(
            email='admin@admin.com',
            is_staff=True,
            is_superuser=True,
            is_active=True,
            username='admin',
        )
        su.set_password('admin')
        su.save()
        super(SuperuserMixin, self).create_fixtures()


class DatesMixin(Fixture):
    def create_fixtures(self):
        en1 = Date.objects.language('en').create(shared_date=D1,
                                                translated_date=D3)
        ja1 = en1.translate('ja')
        ja1.translated_date = D2
        ja1.save()
        en2 = Date.objects.language('en').create(shared_date=D3,
                                                translated_date=D2)
        ja2 = en2.translate('ja')
        ja2.translated_date = D1
        ja2.save()
        en3 = Date.objects.language('en').create(shared_date=D2,
                                                translated_date=D1)
        ja3 = en3.translate('ja')
        ja3.translated_date = D3
        ja3.save()
        super(DatesMixin, self).create_fixtures()

class TwoNormalOneStandardMixin(Fixture):
    def create_fixtures(self):
        en = Normal.objects.language('en').create(
            shared_field='shared',
            translated_field='English'
        )
        ja = en.translate('ja')
        ja.translated_field = u'日本語'
        ja.save()
        Standard.objects.create(normal_field="normal", normal=en) 
        super(TwoNormalOneStandardMixin, self).create_fixtures()

########NEW FILE########
__FILENAME__ = forms

class FormData(dict):
    ''' A dict that can be built from a form or formset instance, and will fill
    itself with request.POST-like data, allowing easier testing of form submissions.

    See forms_inline.TestTranslationsInline for example uses.
    '''
    def __init__(self, form_or_set):
        if hasattr(form_or_set, 'forms'):
            # It is a formset
            self.update(FormData(form_or_set.management_form))
            for form in form_or_set:
                self.update(FormData(form))
        else:
            # It is a form
            for field in form_or_set:
                value = field.value()
                initial = form_or_set.initial.get(field.name, field.field.initial)
                if value is not None:
                    self[field.html_name] = value
                if initial is not None:
                    self[field.html_initial_name] = initial

    def set_form_field(self, form, name, value):
        key = form[name].html_name
        if value is None:
            self.pop(key, None)
        else:
            self[key] = value

    def set_formset_field(self, formset, index, name, value):
        key = formset[index][name].html_name
        if value is None:
            self.pop(key, None)
        else:
            self[key] = value

########NEW FILE########
__FILENAME__ = normal
from django.db import models
from hvad.models import TranslatableModel, TranslatedFields


class NormalAlternate(TranslatableModel):
    shared_field = models.CharField(max_length=255)
    translations = TranslatedFields(
        translated_field = models.CharField(max_length=255)
    )
    
    def __unicode__(self):
        return self.safe_translation_getter('translated_field', self.shared_field)
    
    class Meta:
        app_label = "alternate_models_app"

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from hvad.test_utils.project.app.models import Normal, SimpleRelated, LimitedChoice, AutoPopulated
from hvad.admin import TranslatableAdmin, TranslatableTabularInline

class SimpleRelatedInline(TranslatableTabularInline):
    model = SimpleRelated

class NormalAdmin(TranslatableAdmin):
    inlines = [SimpleRelatedInline,]

admin.site.register(Normal, NormalAdmin)
admin.site.register(SimpleRelated, TranslatableAdmin)
admin.site.register(LimitedChoice)
admin.site.register(AutoPopulated, TranslatableAdmin)


########NEW FILE########
__FILENAME__ = models
import django
from django.db import models
from django.template.defaultfilters import slugify
from hvad.models import TranslatableModel, TranslatedFields
if django.VERSION >= (1, 4, 2):
    from django.utils.encoding import python_2_unicode_compatible
else: # older versions do not run on py3, so we know we are running py2
    def python_2_unicode_compatible(klass):
        klass.__unicode__ = klass.__str__
        klass.__str__ = lambda self: self.__unicode__().encode('utf-8')
        return klass

@python_2_unicode_compatible
class Normal(TranslatableModel):
    shared_field = models.CharField(max_length=255)
    translations = TranslatedFields(
        translated_field = models.CharField(max_length=255)
    )

    def __str__(self):
        return self.safe_translation_getter('translated_field', self.shared_field)

@python_2_unicode_compatible
class NormalProxy(Normal):

    def __str__(self):
        return u'proxied %s' % self.safe_translation_getter('translated_field', self.shared_field)

    class Meta:
        proxy = True


@python_2_unicode_compatible
class NormalProxyProxy(NormalProxy):

    def __str__(self):
        return u'proxied^2 %s' % self.safe_translation_getter('translated_field', self.shared_field)

    class Meta:
        proxy = True

    
class Related(TranslatableModel):
    normal = models.ForeignKey(Normal, related_name='rel1', null=True)
    
    translated_fields = TranslatedFields(
        translated = models.ForeignKey(Normal, related_name='rel3', null=True),
        translated_to_translated = models.ForeignKey(Normal, related_name='rel4', null=True),
    )

class RelatedProxy(Related):
    class Meta:
        proxy = True

class SimpleRelated(TranslatableModel):
    normal = models.ForeignKey(Normal, related_name='simplerel')
    
    translated_fields = TranslatedFields(
        translated_field = models.CharField(max_length=255),
    )


class SimpleRelatedProxy(SimpleRelated):
    class Meta:
        proxy = True


class AbstractA(TranslatableModel):
    translations = TranslatedFields(
        translated_field_a = models.ForeignKey(Normal, related_name='%(class)s_set'),
    )
    class Meta:
        abstract = True

class AbstractAA(AbstractA):
    shared_field_a = models.CharField(max_length=255)
    class Meta:
        abstract = True

class AbstractB(TranslatableModel):
    shared_field_b = models.ForeignKey(Normal, related_name='%(class)s_set')
    translations = TranslatedFields(
        translated_field_b = models.CharField(max_length=255),
    )
    class Meta:
        abstract = True

@python_2_unicode_compatible
class ConcreteAB(AbstractAA, AbstractB):
    shared_field_ab = models.CharField(max_length=255)
    translations = TranslatedFields(
        translated_field_ab = models.CharField(max_length=255),
    )

    def __str__(self):
        return '%s, %s, %s' % (
            str(self.safe_translation_getter('translated_field_a', self.shared_field_a)),
            self.safe_translation_getter('translated_field_b', str(self.shared_field_b)),
            self.safe_translation_getter('translated_field_ab', self.shared_field_ab),
        )

@python_2_unicode_compatible
class ConcreteABProxy(ConcreteAB):
    def __str__(self):
        return 'proxied %s, %s, %s' % (
            str(self.safe_translation_getter('translated_field_a', self.shared_field_a)),
            self.safe_translation_getter('translated_field_b', str(self.shared_field_b)),
            self.safe_translation_getter('translated_field_ab', self.shared_field_ab),
        )
    class Meta:
        proxy = True


class Many(models.Model):
    name = models.CharField(max_length=128)
    normals = models.ManyToManyField(Normal, related_name="manyrels")

class Standard(models.Model):
    normal_field = models.CharField(max_length=255)
    normal = models.ForeignKey(Normal, related_name='standards')

class Other(models.Model):
    normal = models.ForeignKey(Normal, related_name='others')
    

class LimitedChoice(models.Model):
    choice_fk = models.ForeignKey(
        Normal,
        limit_choices_to={
            'shared_field__startswith': 'Shared1',
        },
        related_name='limitedchoices_fk'
    )

    choice_mm = models.ManyToManyField(
        Normal,
        limit_choices_to={
            'shared_field__startswith': 'Shared2'
        },
        related_name='limitedchoices_mm'
    )

class Date(TranslatableModel):
    shared_date = models.DateTimeField()
    
    translated_fields = TranslatedFields(
        translated_date = models.DateTimeField()
    )

    class Meta:
        get_latest_by = 'shared_date'

class AggregateModel(TranslatableModel):
    number = models.IntegerField()
    translated_fields = TranslatedFields(
        translated_number = models.IntegerField(),
    )


class MultipleFields(TranslatableModel):
    first_shared_field = models.CharField(max_length=255)
    second_shared_field = models.CharField(max_length=255)
    translations = TranslatedFields(
        first_translated_field = models.CharField(max_length=255),
        second_translated_field = models.CharField(max_length=255)
    )


class Boolean(TranslatableModel):
    shared_flag = models.BooleanField(default=False)
    translations = TranslatedFields(
        translated_flag = models.BooleanField(default=False)
    )


class AutoPopulated(TranslatableModel):
    slug = models.SlugField(max_length=255, blank=True)
    translations = TranslatedFields(
        translated_name = models.CharField(max_length=255)
    )

    def save(self, *args, **kwargs):
        if not self.slug:
            self.slug = slugify(self.translated_name[:125])
        super(AutoPopulated, self).save(*args, **kwargs)



########NEW FILE########
__FILENAME__ = views
from django.core.urlresolvers import reverse
from hvad.views import TranslatableUpdateView
from hvad.test_utils.project.app.models import Normal

class NormalUpdateView(TranslatableUpdateView):
    model = Normal
    slug_field = 'shared_field'

    def get_success_url(self):
        return reverse('update_normal', args=[self.object.id])

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
from django.core.management import execute_from_command_line
import sys
import os

BASEDIR = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
sys.path.insert(0, BASEDIR)

if __name__ == "__main__":
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "hvad.test_utils.project.settings")
    execute_from_command_line(sys.argv)

########NEW FILE########
__FILENAME__ = urls
try:
    # Django 1.3
    from django.conf.urls.defaults import patterns, include, url
except:
    from django.conf.urls import patterns, include, url
from django.contrib import admin
from hvad.test_utils.project.app.views import NormalUpdateView

admin.autodiscover()

urlpatterns = patterns('',
    (r'^admin/', include(admin.site.urls)),
    url(r'update/normal/(?P<object_id>\d+)/', NormalUpdateView.as_view(), name="update_normal"),
    url(r'update/normal/(?P<slug>\w+)/slug/', NormalUpdateView.as_view(), name="update_normal_slug"),
)

########NEW FILE########
__FILENAME__ = request_factory
from hvad.compat.string_io import StringIO
from hvad.compat.string_types import string_types
from hvad.compat.urls import urlencode, urlparse, unquote
from django.conf import settings
from django.core.handlers.wsgi import WSGIRequest
from django.http import SimpleCookie
from django.test.client import (FakePayload, MULTIPART_CONTENT, encode_multipart, 
    BOUNDARY, CONTENT_TYPE_RE)
from django.utils.encoding import smart_str


class RequestFactory(object):
    """
    Class that lets you create mock Request objects for use in testing.

    Usage:

    rf = RequestFactory()
    get_request = rf.get('/hello/')
    post_request = rf.post('/submit/', {'foo': 'bar'})

    Once you have a request object you can pass it to any view function,
    just as if that view had been hooked up using a URLconf.
    """
    def __init__(self, **defaults):
        self.defaults = defaults
        self.cookies = SimpleCookie()
        self.errors = StringIO()

    def _base_environ(self, **request):
        """
        The base environment for a request.
        """
        environ = {
            'HTTP_COOKIE':       self.cookies.output(header='', sep='; '),
            'PATH_INFO':         '/',
            'QUERY_STRING':      '',
            'REMOTE_ADDR':       '127.0.0.1',
            'REQUEST_METHOD':    'GET',
            'SCRIPT_NAME':       '',
            'SERVER_NAME':       'testserver',
            'SERVER_PORT':       '80',
            'SERVER_PROTOCOL':   'HTTP/1.1',
            'wsgi.version':      (1,0),
            'wsgi.url_scheme':   'http',
            'wsgi.errors':       self.errors,
            'wsgi.multiprocess': True,
            'wsgi.multithread':  False,
            'wsgi.run_once':     False,
        }
        environ.update(self.defaults)
        environ.update(request)
        return environ

    def request(self, **request):
        "Construct a generic request object."
        return WSGIRequest(self._base_environ(**request))

    def _get_path(self, parsed):
        # If there are parameters, add them
        if parsed[3]:
            return unquote(parsed[2] + ";" + parsed[3])
        else:
            return unquote(parsed[2])

    def get(self, path, data={}, **extra):
        "Construct a GET request"

        parsed = urlparse(path)
        r = {
            'CONTENT_TYPE':    'text/html; charset=utf-8',
            'PATH_INFO':       self._get_path(parsed),
            'QUERY_STRING':    urlencode(data, doseq=True) or parsed[4],
            'REQUEST_METHOD': 'GET',
            'wsgi.input':      FakePayload('')
        }
        r.update(extra)
        return self.request(**r)

    def post(self, path, data={}, content_type=MULTIPART_CONTENT,
             **extra):
        "Construct a POST request."

        if content_type is MULTIPART_CONTENT:
            post_data = encode_multipart(BOUNDARY, data)
        else:
            # Encode the content so that the byte representation is correct.
            match = CONTENT_TYPE_RE.match(content_type)
            if match:
                charset = match.group(1)
            else:
                charset = settings.DEFAULT_CHARSET
            post_data = smart_str(data, encoding=charset)

        parsed = urlparse(path)
        r = {
            'CONTENT_LENGTH': len(post_data),
            'CONTENT_TYPE':   content_type,
            'PATH_INFO':      self._get_path(parsed),
            'QUERY_STRING':   parsed[4],
            'REQUEST_METHOD': 'POST',
            'wsgi.input':     FakePayload(post_data),
        }
        r.update(extra)
        return self.request(**r)

    def head(self, path, data={}, **extra):
        "Construct a HEAD request."

        parsed = urlparse(path)
        r = {
            'CONTENT_TYPE':    'text/html; charset=utf-8',
            'PATH_INFO':       self._get_path(parsed),
            'QUERY_STRING':    urlencode(data, doseq=True) or parsed[4],
            'REQUEST_METHOD': 'HEAD',
            'wsgi.input':      FakePayload('')
        }
        r.update(extra)
        return self.request(**r)

    def options(self, path, data={}, **extra):
        "Constrict an OPTIONS request"

        parsed = urlparse(path)
        r = {
            'PATH_INFO':       self._get_path(parsed),
            'QUERY_STRING':    urlencode(data, doseq=True) or parsed[4],
            'REQUEST_METHOD': 'OPTIONS',
            'wsgi.input':      FakePayload('')
        }
        r.update(extra)
        return self.request(**r)

    def put(self, path, data={}, content_type=MULTIPART_CONTENT,
            **extra):
        "Construct a PUT request."

        if content_type is MULTIPART_CONTENT:
            post_data = encode_multipart(BOUNDARY, data)
        else:
            post_data = data

        # Make `data` into a querystring only if it's not already a string. If
        # it is a string, we'll assume that the caller has already encoded it.
        query_string = None
        if not isinstance(data, string_types):
            query_string = urlencode(data, doseq=True)

        parsed = urlparse(path)
        r = {
            'CONTENT_LENGTH': len(post_data),
            'CONTENT_TYPE':   content_type,
            'PATH_INFO':      self._get_path(parsed),
            'QUERY_STRING':   query_string or parsed[4],
            'REQUEST_METHOD': 'PUT',
            'wsgi.input':     FakePayload(post_data),
        }
        r.update(extra)
        return self.request(**r)

    def delete(self, path, data={}, **extra):
        "Construct a DELETE request."

        parsed = urlparse(path)
        r = {
            'PATH_INFO':       self._get_path(parsed),
            'QUERY_STRING':    urlencode(data, doseq=True) or parsed[4],
            'REQUEST_METHOD': 'DELETE',
            'wsgi.input':      FakePayload('')
        }
        r.update(extra)
        return self.request(**r)

########NEW FILE########
__FILENAME__ = runners
import django
from django.conf import settings
import operator
import time

if django.VERSION >= (1, 6):
    from django.test.runner import DiscoverRunner as DjangoRunner
    try:
        from unittest2 import TestSuite
    except ImportError:
        from unittest import TestSuite
else:
    from django.test.simple import DjangoTestSuiteRunner as DjangoRunner
    from django.utils.unittest import TestSuite

TIMINGS = {}

def time_it(func):
    def _inner(*args, **kwargs):
        start = time.time()
        func(*args, **kwargs)
        end = time.time()

        TIMINGS[unicode(func)] = end - start
    return _inner


class TimingSuite(TestSuite):
    def addTest(self, test):
        test = time_it(test)
        super(TimingSuite, self).addTest(test)


class JenkinsTestRunner(DjangoRunner):
    def run_suite(self, suite, **kwargs):
        from xmlrunner import XMLTestRunner
        return XMLTestRunner(output=settings.JUNIT_OUTPUT_DIR).run(suite)



class NormalTestRunner(DjangoRunner):
    def build_suite(self, test_labels, extra_tests=None, **kwargs):
        suite = super(NormalTestRunner, self).build_suite(test_labels, extra_tests, **kwargs)
        if settings.TIME_TESTS:
            return TimingSuite(suite)
        else:
            return suite

    def teardown_test_environment(self, **kwargs):
        super(NormalTestRunner, self).teardown_test_environment(**kwargs)
        if settings.TIME_TESTS:
            by_time = sorted(
                TIMINGS.iteritems(),
                key=operator.itemgetter(1),
                reverse=True)[:10]
            print("Ten slowest tests:")
            for func_name, timing in by_time:
                print("{t:.2f}s {f}".format(f=func_name, t=timing))

########NEW FILE########
__FILENAME__ = testcase
import django
from django.test.testcases import TestCase
from hvad.test_utils.context_managers import UserLoginContext
from hvad.test_utils.request_factory import RequestFactory
import warnings


def minimumDjangoVersion(*args):
    return (lambda x: x) if django.VERSION >= args else (lambda x: 'disabled')
def maximumDjangoVersion(*args):
    return (lambda x: x) if django.VERSION < args else (lambda x: 'disabled')


class _AssertThrowsWarningContext(object):
    def __init__(self, test_case, klass, number):
        self.test_case = test_case
        self.klass = klass
        self.number = number
        self.ctx = warnings.catch_warnings(record=True)

    def __enter__(self):
        self.warnings = self.ctx.__enter__()
        warnings.simplefilter('always')

    def __exit__(self, type, value, traceback):
        self.ctx.__exit__(type, value, traceback)
        self.test_case.assertEqual(
            len(self.warnings), self.number, "%d warnings thrown, %d expected" % (
                len(self.warnings), self.number
            )
        )
        for warning in self.warnings:
            self.test_case.assertTrue(issubclass(warning.category, self.klass),
                                      '%s warning thrown, %s expected' %
                                      (warning.category.__name__, self.klass.__name__))


class HvadTestCase(TestCase):
    def setUp(self):
        if callable(getattr(self, 'create_fixtures', None)):
            self.create_fixtures()

    @property
    def request_factory(self):
        if not hasattr(self, '_request_factory'):
            self._request_factory = RequestFactory()
        return self._request_factory
    
    def reload(self, obj):
        model = obj.__class__
        qs = model.objects
        if callable(getattr(qs, 'language', None)):
            qs = qs.language()
        return qs.get(**{obj._meta.pk.name: obj.pk})

    def login_user_context(self, **kwargs):
        return UserLoginContext(self, **kwargs)

    def assertThrowsWarning(self, klass, number=1):
        return _AssertThrowsWarningContext(self, klass, number)

# method was renamed from assertItemsEqual in Python 3
if not hasattr(HvadTestCase, 'assertCountEqual'):
    HvadTestCase.assertCountEqual = HvadTestCase.assertItemsEqual

########NEW FILE########
__FILENAME__ = tmpdir
# -*- coding: utf-8 -*-
from contextlib import contextmanager
from tempfile import mkdtemp
import os
import random
import shutil
import stat


@contextmanager
def temp_dir():
    name = make_temp_dir()
    yield name
    shutil.rmtree(name)

def make_temp_dir():
    if os.path.exists('/dev/shm/'):
        if os.stat('/dev/shm').st_mode & stat.S_IWGRP:
            dirname = 'django-cms-tests-%s' % random.randint(1,1000000)
            path = os.path.join('/dev/shm', dirname)
            while os.path.exists(path):
                dirname = 'django-cms-tests-%s' % random.randint(1,1000000)
                path = os.path.join('/dev/shm', dirname)
                os.mkdir(path)
                return path
    return mkdtemp()

########NEW FILE########
__FILENAME__ = utils
from django.db.models.fields import FieldDoesNotExist
from django.utils.translation import get_language
from hvad.exceptions import WrongManager

def combine(trans, klass):
    """
    'Combine' the shared and translated instances by setting the translation
    on the 'translations_cache' attribute of the shared instance and returning
    the shared instance.

    The result is casted to klass (needed for proxy models).
    """
    combined = trans.master
    if klass._meta.proxy:
        combined.__class__ = klass
    opts = combined._meta
    setattr(combined, opts.translations_cache, trans)
    return combined

def get_cached_translation(instance):
    return getattr(instance, instance._meta.translations_cache, None)

def get_translation(instance, language_code=None):
    opts = instance._meta
    if not language_code:
        language_code = get_language()
    accessor = getattr(instance, opts.translations_accessor)
    return accessor.get(language_code=language_code)

def get_translation_aware_manager(model):
    from hvad.manager import TranslationAwareManager
    manager = TranslationAwareManager()
    manager.model = model
    return manager

class SmartGetFieldByName(object):
    """
    Get field by name from a shared model or raise a smart exception to help the
    developer.
    """
    def __init__(self, real):
        self.real = real
    
    def __call__(self, meta, name):
        assert not isinstance(self.real, SmartGetFieldByName)
        try:
            return self.real(name)
        except FieldDoesNotExist:
            if name in meta.translations_model._meta.get_all_field_names():
                raise WrongManager("To access translated fields like %r from "
                                   "an untranslated model, you must use a "
                                   "translation aware manager. For non-translatable "
                                   "models, you can get one using "
                                   "hvad.utils.get_translation_aware_manager.\n"
                                   "For translatable models, use the language() "
                                   "method."%
                                   name)
            raise


def collect_context_modifiers(instance, include=None, exclude=None, extra_kwargs=None):
    """
    helper method that updates the context with any instance methods that start
    with `context_modifier_`. `include` is an optional list of method names
    that also should be called. Any method names in `exclude` will not be
    added to the context.

    This helper is most useful when called from get_context_data()::

        def get_context_data(self, **kwargs):
            context = super(MyViewClass, self).get_context_data(**kwargs)
            context.update(collect_context_modifiers(self, extra_kwargs=kwargs))
            return context
    """
    include = include or []
    exclude = exclude or []
    extra_kwargs = extra_kwargs or {}
    context = {}

    for thing in dir(instance):
        if (thing.startswith('context_modifier_') or thing in include) and \
            not thing in exclude:
            context.update(getattr(instance, thing, lambda x:x)(**extra_kwargs))
    return context

########NEW FILE########
__FILENAME__ = views
from django.http import Http404
try:
    from django.views.generic.edit import UpdateView
except ImportError:
    from cbv.views.edit import UpdateView
from .admin import TranslatableModelAdminMixin
from .forms import translatable_modelform_factory, TranslatableModelForm
from .utils import collect_context_modifiers

class TranslatableBaseView(UpdateView, TranslatableModelAdminMixin):
    form_class = TranslatableModelForm


    def filter_kwargs(self):
        """
        ORM Lookup kwargs from URL pattern
        Default {'pk': 'object_id'}

        Syntax:
        - {'model_attr': 'url_block_name'}
        """
        if "slug" in self.kwargs:
            return {self.slug_field: self.kwargs["slug"]}
        return {'pk': self.kwargs['object_id']}

    def get_form_class(self):
        language = self._language(self.request)
        return translatable_modelform_factory(language, self.model, form=self.form_class)

    def get_queryset(self):
        if self.queryset is None:
            if self.model:
                language = self._language(self.request)
                return self.model._default_manager.language(language)

    def _get_object(self, queryset=None):
        if queryset is None:
            queryset = self.get_queryset()
        model = self.model
        try:
            obj = queryset.get(**self.filter_kwargs())
        except self.model.DoesNotExist:
            obj = None
        if obj:
            return obj
        queryset = self.model._default_manager.untranslated()
        try:
            obj = queryset.get(**self.filter_kwargs())
        except model.DoesNotExist:
            return None
        new_translation = model._meta.translations_model()
        new_translation.language_code = self._language(self.request)
        new_translation.master = obj
        setattr(obj, model._meta.translations_cache, new_translation)
        return obj

    def context_modifier_languages_available(self, **kwargs):
        context = {
            'language_tabs': self.get_language_tabs(self.request, self.get_available_languages(self.object))
        }
        return context

    def get_context_data(self, **kwargs):
        context = super(TranslatableBaseView, self).get_context_data(**kwargs)
        context.update(collect_context_modifiers(self, extra_kwargs=kwargs))
        return context

class TranslatableCreateView(TranslatableBaseView, TranslatableModelAdminMixin):
    """
    Untested, use with caution - or write tests if you see this :-)
    """
    pass

class TranslatableUpdateView(TranslatableBaseView, TranslatableModelAdminMixin):
    """
    A generic class based update view for translatable models.
    """
    def get_object(self, queryset=None):
        obj = self._get_object(queryset)
        if not obj:
            raise Http404("%s instance with arguments %s does not exist" % (self.model, self.filter_kwargs()))
        return obj


########NEW FILE########
__FILENAME__ = runtests
#!/usr/bin/env python
from __future__ import with_statement
from hvad.test_utils.cli import configure
from hvad.test_utils.tmpdir import temp_dir
import argparse
import sys


def main(test_runner='hvad.test_utils.runners.NormalTestRunner', junit_output_dir='.',
         time_tests=False, verbosity=1, failfast=False, test_labels=None):
    if not test_labels:
        test_labels = ['hvad']
    with temp_dir() as STATIC_ROOT:
        with temp_dir() as MEDIA_ROOT:
            configure(LANGAUGE_CODE='en', TEST_RUNNER=test_runner, JUNIT_OUTPUT_DIR=junit_output_dir,
                TIME_TESTS=time_tests, STATIC_ROOT=STATIC_ROOT, MEDIA_ROOT=MEDIA_ROOT)
            from django.conf import settings
            from django.test.utils import get_runner
            TestRunner = get_runner(settings)
        
            test_runner = TestRunner(pattern='*.py', verbosity=verbosity, interactive=False, failfast=failfast)
            failures = test_runner.run_tests(test_labels)
    sys.exit(failures)


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--jenkins', action='store_true', default=False,
            dest='jenkins')
    parser.add_argument('--jenkins-data-dir', default='.', dest='jenkins_data_dir')
    parser.add_argument('--coverage', action='store_true', default=False,
            dest='coverage')
    parser.add_argument('--failfast', action='store_true', default=False,
            dest='failfast')
    parser.add_argument('--verbosity', default=1)
    parser.add_argument('--time-tests', action='store_true', default=False,
            dest='time_tests')
    parser.add_argument('test_labels', nargs='*')
    args = parser.parse_args()
    if getattr(args, 'jenkins', False):
        test_runner = 'hvad.test_utils.runners.JenkinsTestRunner'
    else:
        test_runner = 'hvad.test_utils.runners.NormalTestRunner'
    junit_output_dir = getattr(args, 'jenkins_data_dir', '.')
    time_tests = getattr(args, 'time_tests', False)
    test_labels = ['hvad.%s' % label for label in args.test_labels]
    main(test_runner=test_runner, junit_output_dir=junit_output_dir, time_tests=time_tests,
         verbosity=args.verbosity, failfast=args.failfast, test_labels=test_labels)
    

########NEW FILE########
