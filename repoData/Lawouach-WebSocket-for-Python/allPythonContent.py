__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# ws4py documentation build configuration file, created by
# sphinx-quickstart on Sat Feb 18 19:54:37 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath(os.path.join(
    os.path.dirname(__file__), '..')))

from ws4py import __version__


# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc',
              'sphinx.ext.autosummary',
              'sphinx.ext.coverage',
              'sphinx.ext.viewcode',
              'sphinx.ext.intersphinx',
              'sphinxcontrib.seqdiag']
autoclass_content = 'init'
autodoc_member_order = 'bysource'
intersphinx_mapping = {'python': ('http://docs.python.org/2.7', None)}

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'ws4py'
copyright = u'2011 - 2014, Sylvain Hellegouarch'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = __version__
# The full version, including alpha/beta/rc tags.
release = __version__

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
add_function_parentheses = False

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
show_authors = True

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'
highlight_language = 'python'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
if os.environ.get('READTHEDOCS', None) == 'True':
    html_theme = 'default'
else:
    html_theme = 'sphinxdoc'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'ws4pydoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'ws4py.tex', u'ws4py Documentation',
   u'Author', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'ws4py', u'ws4py Documentation',
     [u'Author'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'ws4py', u'ws4py Documentation',
   u'Author', 'ws4py', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'


# -- Options for Epub output ---------------------------------------------------

# Bibliographic Dublin Core info.
epub_title = u'ws4py'
epub_author = u'Sylvain Hellegouarch'
epub_publisher = u'Sylvain Hellegouarch'
epub_copyright = u'2011 - 2013, Sylvain Hellegouarch'

# The language of the text. It defaults to the language option
# or en if the language is not set.
#epub_language = ''

# The scheme of the identifier. Typical schemes are ISBN or URL.
#epub_scheme = ''

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
#epub_identifier = ''

# A unique identification for the text.
#epub_uid = ''

# A tuple containing the cover image and cover page html template filenames.
#epub_cover = ()

# HTML files that should be inserted before the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_pre_files = []

# HTML files shat should be inserted after the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_post_files = []

# A list of files that should not be packed into the epub file.
#epub_exclude_files = []

# The depth of the table of contents in toc.ncx.
#epub_tocdepth = 3

# Allow duplicate toc entries.
#epub_tocdup = True

########NEW FILE########
__FILENAME__ = app
# -*- coding: utf-8 -*-
__doc__ = """
A simple chat example using a CherryPy webserver.

$ pip install cherrypy

Then run it as follow:

$ python app.py

You will want to edit this file to change the
ws_addr variable used by the websocket object to connect
to your endpoint. Probably using the actual IP
address of your machine.
"""
import random
import os

import cherrypy

from ws4py.server.cherrypyserver import WebSocketPlugin, WebSocketTool
from ws4py.websocket import WebSocket
from ws4py.messaging import TextMessage

cur_dir = os.path.normpath(os.path.abspath(os.path.dirname(__file__)))
index_path = os.path.join(cur_dir, 'index.html')
index_page = file(index_path, 'r').read()

class ChatWebSocketHandler(WebSocket):
    def received_message(self, m):
        cherrypy.engine.publish('websocket-broadcast', m)

    def closed(self, code, reason="A client left the room without a proper explanation."):
        cherrypy.engine.publish('websocket-broadcast', TextMessage(reason))

class ChatWebApp(object):
    @cherrypy.expose
    def index(self):
        return index_page % {'username': "User%d" % random.randint(50, 1000),
                             'ws_addr': 'ws://localhost:9000/ws'}

    @cherrypy.expose
    def ws(self):
        cherrypy.log("Handler created: %s" % repr(cherrypy.request.ws_handler))

if __name__ == '__main__':
    cherrypy.config.update({
        'server.socket_host': '0.0.0.0',
        'server.socket_port': 9000
    })
    
    WebSocketPlugin(cherrypy.engine).subscribe()
    cherrypy.tools.websocket = WebSocketTool()

    cherrypy.quickstart(ChatWebApp(), '',
                        config={
                            '/': {
                                'tools.response_headers.on': True,
                                'tools.response_headers.headers': [
                                    ('X-Frame-options', 'deny'),
                                    ('X-XSS-Protection', '1; mode=block'),
                                    ('X-Content-Type-Options', 'nosniff')
                                ]
                            },
                            '/ws': {
                                'tools.websocket.on': True,
                                'tools.websocket.handler_cls': ChatWebSocketHandler
                            },
                        })

########NEW FILE########
__FILENAME__ = droid_sensor
# -*- coding: utf-8 -*-
__doc__ = """
WebSocket client that pushes Android sensor metrics to the
websocket server it is connected to.

In order to set this up:

 1. Install SL4A http://code.google.com/p/android-scripting/
 2. Install the Python package for SL4A
 3. Build ws4py and copy the package built into a directory
    called com.googlecode.pythonforandroid/extras/python on
    your Android device.
 4. a. Either copy the droid_sensor.py module into the directory
       called sl4a/scripts on your Android device.
    b. Or set up the remote control so that you can run the
       module from your computer directly on your device:
       http://code.google.com/p/android-scripting/wiki/RemoteControl
 5. Setup the device so that it has an IP address on the same
    network as the computer running the server.
    
Run the example:

 1. Start the echo_cherrypy_server module:
    $ python example/droid_sensor_cherrypy_server.py
 2. From a local browser, go to:
    http://localhost:9000/
 3. Edit the droid_sensor module to set the appropriate
    IP address where your server is running.
 4. Run the droid_sensor module (from the device or
    your computer depending on your setup):
    $ python example/droid_sensor.py
 5. If your device isn't idled, just move ir around
    for the metrics to be sent to the server which
    will dispatch them to the browser's client.
 6. Profit???
 
"""
import time
import math

import android
from ws4py.client.threadedclient import WebSocketClient

class AirPongSensor(object):
    def __init__(self, host):
        self.droid = android.Android()
        #self.droid.startSensingThreshold(1, 0, 7)
        #self.droid.startSensingThreshold(2, 1, 2)
        self.droid.startSensingTimed(1, 100)

        self.running = False

        self.client = AirPongWebSocketClient(host)
        self.client.connect()
        
    def run(self):
        try:
            self.running = True
            last = [None, None, None]
            while self.running:
                azimuth, pitch, roll = self.droid.sensorsReadOrientation().result
                accel = x, y, z = self.droid.sensorsReadAccelerometer().result
                if azimuth is None:
                    continue
                
                c = lambda rad: rad * 360.0 / math.pi
                print c(azimuth), c(pitch), c(roll), x, y, z

                if self.client.terminated:
                    break

                if accel != [None, None, None] and accel != last:
                    last = accel
                    self.client.send("%s %s %s %s %s %s" % (c(azimuth), c(pitch), c(roll), x, y, z))

                time.sleep(0.15)
        finally:
            self.terminate()
            
    def terminate(self):
        if not self.droid:
            return
        
        self.running = False
        self.droid.stopSensing()
        self.droid = None
        
        if not self.client.terminated:
            self.client.close()
            self.client._th.join()
            self.client = None
        
class AirPongWebSocketClient(WebSocketClient):
        def received_message(self, m):
            pass

if __name__ == '__main__':
    aps = AirPongSensor(host='http://192.168.0.10:9000/ws')
    try:
        aps.run()
    except KeyboardInterrupt:
        aps.terminate()

########NEW FILE########
__FILENAME__ = droid_sensor_cherrypy_server
# -*- coding: utf-8 -*-
import os.path
import cherrypy

from ws4py.server.cherrypyserver import WebSocketPlugin, WebSocketTool
from ws4py.websocket import WebSocket

class BroadcastWebSocketHandler(WebSocket):
    def received_message(self, m):
        cherrypy.engine.publish('websocket-broadcast', str(m))
        
class Root(object):
    @cherrypy.expose
    def display(self):
        return """<!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="utf-8" />
      <title>WebSocket example displaying Android device sensors</title>
      <link rel="stylesheet" href="/css/style.css" type="text/css" />

      <script type='application/javascript' src='http://code.jquery.com/jquery-1.9.1.min.js'></script>
      <script type="application/javascript" src="http://calebevans.me/projects/jcanvas/resources/jcanvas/jcanvas.min.js"> </script>
      <script type="application/javascript" src="/js/droidsensor.js"> </script>
      <script type="application/javascript">
        $(document).ready(function() {
          initWebSocket();
          drawAll();
        });
      </script>
    </head>
    <body>
    <section id="content" class="body">
    <canvas id="canvas" width="900" height="620"></canvas>
    </section>
    </body>
    </html>
    """

    @cherrypy.expose
    def ws(self):
        cherrypy.log("Handler created: %s" % repr(cherrypy.request.ws_handler))

    @cherrypy.expose
    def index(self):
        return """<!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="utf-8" />
      <title>WebSocket example displaying Android device sensors</title>

      <script type='application/javascript' src='http://code.jquery.com/jquery-1.9.1.min.js'></script>
      <script type="application/javascript" src="/js/droidsensor.js"> </script>
      <script type="application/javascript">
        $(document).ready(function() {
          initWebSocketAndSensors();
        });
      </script>
    </head>
    <body>
    </body>
    </html>
    """
        
if __name__ == '__main__':
    cherrypy.config.update({
        'server.socket_host': '0.0.0.0',
        'server.socket_port': 9000,
        'tools.staticdir.root': os.path.abspath(os.path.join(os.path.dirname(__file__), 'static'))
        }
    )
    print os.path.abspath(os.path.join(__file__, 'static'))
    WebSocketPlugin(cherrypy.engine).subscribe()
    cherrypy.tools.websocket = WebSocketTool()

    cherrypy.quickstart(Root(), '', config={
        '/js': {
            'tools.staticdir.on': True,
            'tools.staticdir.dir': 'js'
            },
        '/css': {
            'tools.staticdir.on': True,
            'tools.staticdir.dir': 'css'
            },
        '/images': {
            'tools.staticdir.on': True,
            'tools.staticdir.dir': 'images'
            },
        '/ws': {
            'tools.websocket.on': True,
            'tools.websocket.handler_cls': BroadcastWebSocketHandler
            }
        }
    )

########NEW FILE########
__FILENAME__ = echo_chaussette_server
# -*- coding: utf-8 -*-
import logging

from gevent import monkey; monkey.patch_all()
import gevent
from ws4py.server.geventserver import WebSocketWSGIApplication, \
     WebSocketWSGIHandler, GEventWebSocketPool
from ws4py.websocket import EchoWebSocket

from chaussette.backend._gevent import Server as GeventServer

class ws4pyServer(GeventServer):
    handler_class = WebSocketWSGIHandler

    def __init__(self, *args, **kwargs):
        GeventServer.__init__(self, *args, **kwargs)
        self.pool = GEventWebSocketPool()

    def stop(self, *args, **kwargs):
        self.pool.clear()
        self.pool = None
        GeventServer.stop(self, *args, **kwargs)

if __name__ == '__main__':
    import os, socket, sys
    from ws4py import configure_logger
    logger = configure_logger()

    from chaussette.backend import register
    register('ws4py', ws4pyServer)

    from chaussette.server import make_server
    server = make_server(app=WebSocketWSGIApplication(handler_cls=EchoWebSocket),
                         host='unix:///%s/ws.sock' % os.getcwd(),
                         address_family=socket.AF_UNIX,
                         backend='ws4py',
                         logger=logger)
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        sys.exit(0)

########NEW FILE########
__FILENAME__ = echo_cherrypy_server
# -*- coding: utf-8 -*-
import argparse
import random
import os

import cherrypy

from ws4py.server.cherrypyserver import WebSocketPlugin, WebSocketTool
from ws4py.websocket import WebSocket
from ws4py.messaging import TextMessage

class ChatWebSocketHandler(WebSocket):
    def received_message(self, m):
        cherrypy.engine.publish('websocket-broadcast', m)

    def closed(self, code, reason="A client left the room without a proper explanation."):
        cherrypy.engine.publish('websocket-broadcast', TextMessage(reason))

class Root(object):
    def __init__(self, host, port, ssl=False):
        self.host = host
        self.port = port
        self.scheme = 'wss' if ssl else 'ws'

    @cherrypy.expose
    def index(self):
        return """<html>
    <head>
      <script type='application/javascript' src='https://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js'></script>
      <script type='application/javascript'>
        $(document).ready(function() {

          websocket = '%(scheme)s://%(host)s:%(port)s/ws';
          if (window.WebSocket) {
            ws = new WebSocket(websocket);
          }
          else if (window.MozWebSocket) {
            ws = MozWebSocket(websocket);
          }
          else {
            console.log('WebSocket Not Supported');
            return;
          }

          window.onbeforeunload = function(e) {
            $('#chat').val($('#chat').val() + 'Bye bye...\\n');
            ws.close(1000, '%(username)s left the room');

            if(!e) e = window.event;
            e.stopPropagation();
            e.preventDefault();
          };
          ws.onmessage = function (evt) {
             $('#chat').val($('#chat').val() + evt.data + '\\n');
          };
          ws.onopen = function() {
             ws.send("%(username)s entered the room");
          };
          ws.onclose = function(evt) {
             $('#chat').val($('#chat').val() + 'Connection closed by server: ' + evt.code + ' \"' + evt.reason + '\"\\n');
          };

          $('#send').click(function() {
             console.log($('#message').val());
             ws.send('%(username)s: ' + $('#message').val());
             $('#message').val("");
             return false;
          });
        });
      </script>
    </head>
    <body>
    <form action='#' id='chatform' method='get'>
      <textarea id='chat' cols='35' rows='10'></textarea>
      <br />
      <label for='message'>%(username)s: </label><input type='text' id='message' />
      <input id='send' type='submit' value='Send' />
      </form>
    </body>
    </html>
    """ % {'username': "User%d" % random.randint(0, 100), 'host': self.host, 'port': self.port, 'scheme': self.scheme}

    @cherrypy.expose
    def ws(self):
        cherrypy.log("Handler created: %s" % repr(cherrypy.request.ws_handler))

if __name__ == '__main__':
    import logging
    from ws4py import configure_logger
    configure_logger(level=logging.DEBUG)

    parser = argparse.ArgumentParser(description='Echo CherryPy Server')
    parser.add_argument('--host', default='127.0.0.1')
    parser.add_argument('-p', '--port', default=9000, type=int)
    parser.add_argument('--ssl', action='store_true')
    args = parser.parse_args()

    cherrypy.config.update({'server.socket_host': args.host,
                            'server.socket_port': args.port,
                            'tools.staticdir.root': os.path.abspath(os.path.join(os.path.dirname(__file__), 'static'))})

    if args.ssl:
        cherrypy.config.update({'server.ssl_certificate': './server.crt',
                                'server.ssl_private_key': './server.key'})

    WebSocketPlugin(cherrypy.engine).subscribe()
    cherrypy.tools.websocket = WebSocketTool()

    cherrypy.quickstart(Root(args.host, args.port, args.ssl), '', config={
        '/ws': {
            'tools.websocket.on': True,
            'tools.websocket.handler_cls': ChatWebSocketHandler
            },
        '/js': {
              'tools.staticdir.on': True,
              'tools.staticdir.dir': 'js'
            }
        }
    )

########NEW FILE########
__FILENAME__ = echo_client
# -*- coding: utf-8 -*-
from ws4py.client.threadedclient import WebSocketClient

class EchoClient(WebSocketClient):
    def opened(self):
        def data_provider():
            for i in range(1, 200, 25):
                yield "#" * i
                
        self.send(data_provider())

        for i in range(0, 200, 25):
            print(i)
            self.send("*" * i)

    def closed(self, code, reason):
        print(("Closed down", code, reason))

    def received_message(self, m):
        print("=> %d %s" % (len(m), str(m)))
        if len(m) == 175:
            self.close(reason='Bye bye')

if __name__ == '__main__':
    try:
        ws = EchoClient('ws://localhost:9000/ws', protocols=['http-only', 'chat'])
        ws.daemon = False
        ws.connect()
    except KeyboardInterrupt:
        ws.close()

########NEW FILE########
__FILENAME__ = echo_gevent_client
# -*- coding: utf-8 -*-
from gevent import monkey; monkey.patch_all()

import gevent
from ws4py.client.geventclient import WebSocketClient

if __name__ == '__main__':
    ws = WebSocketClient('ws://localhost:9000/ws', protocols=['http-only', 'chat'])
    ws.connect()

    ws.send("Hello world")
    print((ws.receive(),))

    ws.send("Hello world again")
    print((ws.receive(),))

    def incoming():
        while True:
            m = ws.receive()
            if m is not None:
                m = str(m)
                print((m, len(m)))
                if len(m) == 35:
                    ws.close()
                    break
            else:
                break
        print(("Connection closed!",))

    def outgoing():
        for i in range(0, 40, 5):
            ws.send("*" * i)

        # We won't get this back
        ws.send("Foobar")

    greenlets = [
        gevent.spawn(incoming),
        gevent.spawn(outgoing),
    ]
    gevent.joinall(greenlets)

########NEW FILE########
__FILENAME__ = echo_gevent_server
# -*- coding: utf-8 -*-
from gevent import monkey; monkey.patch_all()

import argparse
import random
import os

import gevent
import gevent.pywsgi

from ws4py.server.geventserver import WebSocketWSGIApplication, \
     WebSocketWSGIHandler, WSGIServer
from ws4py.websocket import EchoWebSocket

class BroadcastWebSocket(EchoWebSocket):
    def opened(self):
        app = self.environ['ws4py.app']
        app.clients.append(self)

    def received_message(self, m):
        # self.clients is set from within the server
        # and holds the list of all connected servers
        # we can dispatch to
        app = self.environ['ws4py.app']
        for client in app.clients:
            client.send(m)

    def closed(self, code, reason="A client left the room without a proper explanation."):
        app = self.environ.pop('ws4py.app')
        if self in app.clients:
            app.clients.remove(self)
            for client in app.clients:
                try:
                    client.send(reason)
                except:
                    pass

class EchoWebSocketApplication(object):
    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.ws = WebSocketWSGIApplication(handler_cls=BroadcastWebSocket)

        # keep track of connected websocket clients
        # so that we can brodcasts messages sent by one
        # to all of them. Aren't we cool?
        self.clients = []

    def __call__(self, environ, start_response):
        """
        Good ol' WSGI application. This is a simple demo
        so I tried to stay away from dependencies.
        """
        if environ['PATH_INFO'] == '/favicon.ico':
            return self.favicon(environ, start_response)

        if environ['PATH_INFO'] == '/ws':
            environ['ws4py.app'] = self
            return self.ws(environ, start_response)

        return self.webapp(environ, start_response)

    def favicon(self, environ, start_response):
        """
        Don't care about favicon, let's send nothing.
        """
        status = '200 OK'
        headers = [('Content-type', 'text/plain')]
        start_response(status, headers)
        return ""

    def webapp(self, environ, start_response):
        """
        Our main webapp that'll display the chat form
        """
        status = '200 OK'
        headers = [('Content-type', 'text/html')]

        start_response(status, headers)

        return """<html>
        <head>
        <script type='application/javascript' src='https://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js'></script>
          <script type='application/javascript'>
            $(document).ready(function() {

              websocket = 'ws://%(host)s:%(port)s/ws';
              if (window.WebSocket) {
                ws = new WebSocket(websocket);
              }
              else if (window.MozWebSocket) {
                ws = MozWebSocket(websocket);
              }
              else {
                console.log('WebSocket Not Supported');
                return;
              }

              window.onbeforeunload = function(e) {
                 $('#chat').val($('#chat').val() + 'Bye bye...\\n');
                 ws.close(1000, '%(username)s left the room');

                 if(!e) e = window.event;
                 e.stopPropagation();
                 e.preventDefault();
              };
              ws.onmessage = function (evt) {
                 $('#chat').val($('#chat').val() + evt.data + '\\n');
              };
              ws.onopen = function() {
                 ws.send("%(username)s entered the room");
              };
              ws.onclose = function(evt) {
                 $('#chat').val($('#chat').val() + 'Connection closed by server: ' + evt.code + ' \"' + evt.reason + '\"\\n');
              };

              $('#send').click(function() {
                 console.log($('#message').val());
                 ws.send('%(username)s: ' + $('#message').val());
                 $('#message').val("");
                 return false;
              });
            });
          </script>
        </head>
        <body>
        <form action='#' id='chatform' method='get'>
          <textarea id='chat' cols='35' rows='10'></textarea>
          <br />
          <label for='message'>%(username)s: </label><input type='text' id='message' />
          <input id='send' type='submit' value='Send' />
          </form>
        </body>
        </html>
        """ % {'username': "User%d" % random.randint(0, 100),
               'host': self.host,
               'port': self.port}

if __name__ == '__main__':
    from ws4py import configure_logger
    configure_logger()

    parser = argparse.ArgumentParser(description='Echo gevent Server')
    parser.add_argument('--host', default='127.0.0.1')
    parser.add_argument('-p', '--port', default=9000, type=int)
    args = parser.parse_args()

    server = WSGIServer((args.host, args.port), EchoWebSocketApplication(args.host, args.port))
    server.serve_forever()

########NEW FILE########
__FILENAME__ = mocking_data_source
from ws4py import configure_logger
from ws4py.websocket import WebSocket
from ws4py.messaging import Message, TextMessage

logger = configure_logger(stdout=True)

class DataSource(object):
    def __init__(self):
        self.frames = set()
        self.frame = None
        self.remaining_bytes = None

    def setblocking(self, flag):
        pass

    def feed(self, message):
        if isinstance(message, Message):
            message = message.single(mask=True)
        else:
            message = TextMessage(message).single(mask=True)
        self.frames.add(message)

    def recv(self, size):
        if not self.frame:
            if not self.frames:
                return b''
            self.frame = self.frames.pop()
            self.remaining_bytes = self.frame

        current_bytes = self.remaining_bytes[:size]
        self.remaining_bytes = self.remaining_bytes[size:]

        if self.remaining_bytes is b'':
            self.frame = None
            self.remaining_bytes = None

        return current_bytes

class LogWebSocket(WebSocket):
    def opened(self):
        logger.info("WebSocket now ready")

    def closed(self, code=1000, reason="Burp, done!"):
        logger.info("Terminated with reason '%s'" % reason)

    def received_message(self, m):
        logger.info("Received message: %s" % m)

if __name__ == '__main__':
    source = DataSource()
    ws = LogWebSocket(sock=source)

    source.feed(u'hello there')
    source.feed(u'a bit more')

    ws.run()

########NEW FILE########
__FILENAME__ = app
# -*- coding: utf-8 -*-
"""
WebSocket demo with a twist.

The idea of this little demo is to demonstrate
how it can enable interesting functions when coupled with
other HTML5 features, such as Canvas.

In this scenario, we create a canvas that we call a drawing
board. You can draw circles with various colors. A board
has a unique URL, every client connecting to that URL
can see whatever is drawn by other participants. All events
from one client are sent to other clients through
websockets. All other clients then draw on their view
events they receive.

This ought to work well with any HTML5 capable browser such
as Chrome, Firefox, Opera. It even works well on Android using
Chrome. Internet Explorer users... well it may work as well.

This demo uses:

* CherryPy 3.2.5+
* Mako
* jcanvas
* jquery
* HTML5boilerplate (via http://www.initializr.com/)

Once you have installed those dependencies, simply run the
application as follow:

  $ python app.py --baseurl https://myhost/ --host 0.0.0.0 --port 8080

You can specify the base url which will be used to build the
URL to the board. For instance, a board's url will be:

 https://myhost/board/c866

"""
import json
import os.path
import tempfile
import time
import uuid

try:
    import wsaccel
    wsaccel.patch_ws4py()
except ImportError:
    pass

from ws4py.server.cherrypyserver import WebSocketPlugin, WebSocketTool
from ws4py.websocket import WebSocket

import cherrypy
from cherrypy.process import plugins
from mako.lookup import TemplateLookup
from mako.template import Template

BASE_URL = None

cwd_dir = os.path.normpath(os.path.abspath(os.path.dirname(__file__)))
bus = cherrypy.engine
lookup = TemplateLookup(directories=os.path.join(cwd_dir, 'templates'),
                        module_directory=os.path.join(cwd_dir, 'templates', '.cache'),
                        input_encoding='utf-8',
                        output_encoding='utf-8',
                        collection_size=20)

class DrawingBoardWebSocketHandler(WebSocket):
    """
    WebSocket handler that will dispatch drawing events
    from this client to all other registered clients
    on this board.

    An instance of this class is automatically created
    when a client is connected. The `board_id` and
    `participant_id` attributes are set outside of this
    class, when the client is registered to the board.
    """
    
    def closed(self, code, reason):
        """
        Called whenever the websocket connection is terminated,
        whether abruptly or normally.
        """
        bus.websockets.unregister_participant(self.board_id,
                                              self.participant_id)
        
    def received_message(self, m):
        """
        Received messages contain events from the
        user interface, like coordinates. They are
        dispatched to all registered participants on this
        board.
        """
        bus.websockets.broadcast_state(self.board_id,
                                       self.participant_id,
                                       m)

class DrawingBoardWebSocketPlugin(WebSocketPlugin):
    def __init__(self, bus):
        """
        This plugin is the board controller. It keeps
        track of all boards and their registered participants.

        You may access the global instance of this plugin
        through the `bus.websockets` attribute.
        """
        WebSocketPlugin.__init__(self, bus)

        # every 30s, we check if we have dead boards
        # and we clean them
        plugins.Monitor(bus, self.drop_dead_boards, 30).subscribe()
    
        # board index to quickly retrieve
        # clients of a given board
        self.boards = {}

    def drop_dead_boards(self):
        """
        Iterate over all boards and unregister any
        that seem to be unused anymore (because it doesn't
        have any connected client anymore), or that
        have been created for too long (no more than than 5mn
        are allowed).
        """
        for board_id in self.boards.copy():
            board = self.boards[board_id]
            if not board['handlers']:
                self.unregister_board(board_id)
            elif (time.time() - board['created']) > 300:
                for ws in board['handlers'].itervalues():
                    if not ws.terminated:
                        ws.close(1001, "Board can't exist for more than 5mn")
                self.unregister_board(board_id)
        
    def register_board(self, board_id):
        """
        Register a board and initialize it
        so that it'll accept participants.
        """
        if board_id not in self.boards:
            self.bus.log("Registering board %s" % board_id)
            self.boards[board_id] = {'handlers': {}, 'created': time.time()}
            
    def unregister_board(self, board_id):
        """
        Unregister a board and make it unusable.
        """
        self.boards.pop(board_id, None)

    def register_participant(self, board_id, participant_id, ws_handler):
        """
        Register a participant to the given board.
        We also set the `board_id` and `participant_id`
        attributes on the websocket handler instance.
        """
        if board_id in self.boards:
            self.bus.log("Registering participant %s to board %s" % (participant_id, board_id))
            ws_handler.board_id = board_id
            ws_handler.participant_id = participant_id
            self.boards[board_id]['handlers'][participant_id] = ws_handler
        
    def unregister_participant(self, board_id, participant_id):
        """
        Unregister a participant from this board.

        Usually this is called automatically when the client
        has closed its connection.
        """
        if board_id in self.boards:
            board = self.boards[board_id]
            if participant_id in self.boards[board_id]:
                board['handlers'].pop(participant_id, None)
                self.bus.log("Unregistering participant %s from board %s" % (participant_id, board_id))

    def broadcast_state(self, board_id, from_participant_id, state):
        """
        Dispatch the given `state` to all registered participants
        of the board (except the sender itself of course).
        """
        if board_id not in self.boards:
            return

        board = self.boards[board_id]
        
        for (participant_id, ws) in board['handlers'].iteritems():
            if from_participant_id != participant_id:
                if not ws.terminated:
                    ws.send(state)


def render_template(template):
    """
    Renders a mako template to HTML and
    sets the CherryPy response's body with it.
    """
    if cherrypy.response.status > 399:
        return

    data = cherrypy.response.body or {}
    template = lookup.get_template(template)

    if template and isinstance(data, dict):
        cherrypy.response.body = template.render(**data)

# Creating our tool so that they can be
# used below in the CherryPy applications
cherrypy.tools.render = cherrypy.Tool('before_finalize', render_template)
cherrypy.tools.websocket = WebSocketTool()

        
# Web Application
class SharedDrawingBoardApp(object):
    @cherrypy.expose
    @cherrypy.tools.render(template='index.html')
    def index(self):
        return {'boardid': str(uuid.uuid4())[:4],
                'baseurl': BASE_URL}

    @cherrypy.expose
    @cherrypy.tools.render(template='board.html')
    def board(self, board_id):
        bus.websockets.register_board(board_id)
        return {'boardid': board_id,
                'participantid': str(uuid.uuid4())[:6],
                'baseurl': BASE_URL,
                'basewsurl': BASE_URL.replace('http', 'ws')}

# WebSocket endpoint
class SharedDrawingBoarWebSocketApp(object):
    @cherrypy.expose
    @cherrypy.tools.websocket(handler_cls=DrawingBoardWebSocketHandler)
    def index(self, board_id, participant_id):
        bus.websockets.register_participant(board_id, participant_id,
                                            cherrypy.request.ws_handler)
        
if __name__ == '__main__':
    import argparse
    from urlparse import urlparse

    parser = argparse.ArgumentParser()
    parser.add_argument('--baseurl', default='http://0.0.0.0:8080')
    parser.add_argument('--host')
    parser.add_argument('-p', '--port', type=int)
    parser.add_argument('--verbose', action="store_true")
    args = parser.parse_args()

    BASE_URL = args.baseurl
    BASE_URL = BASE_URL.rstrip('/')
    url = urlparse(BASE_URL)
    
    bus.websockets = DrawingBoardWebSocketPlugin(bus)
    bus.websockets.subscribe()

    cherrypy.config.update({
        'server.socket_host': args.host or url.hostname,
        'server.socket_port': args.port or url.port,
        'server.thread_pool': 30,
        'log.screen': args.verbose,
        'log.access_file': os.path.join(cwd_dir, 'access.log'),
        'log.error_file': os.path.join(cwd_dir, 'error.log'),
        'tools.staticfile.root': cwd_dir,
        'tools.staticdir.root': cwd_dir,
        'tools.proxy.on': True,
        'tools.proxy.base': '%s://%s' % (url.scheme, url.netloc),
        'error_page.404': os.path.join(cwd_dir, "templates", "404.html")
    })

    app = SharedDrawingBoardApp()
    app.ws = SharedDrawingBoarWebSocketApp()
    
    cherrypy.tree.mount(app, '/', {
        '/': {
            'tools.encode.on': False,
            'tools.response_headers.on': True,
            'tools.response_headers.headers': [
                ('X-Frame-options', 'deny'),
                ('X-XSS-Protection', '1; mode=block'),
                ('X-Content-Type-Options', 'nosniff')
            ]
        },
        '/robots.txt': {
            'tools.staticfile.on': True,
            'tools.staticfile.filename': 'static/robots.txt'
        },
        '/static/demos/drawing': {
            'tools.staticdir.on': True,
            'tools.staticdir.dir': 'static'
        }
    })

    bus.signals.subscribe()
    bus.start()
    bus.block()
    
    
    
    

########NEW FILE########
__FILENAME__ = board.html
# -*- coding:utf-8 -*-
from mako import runtime, filters, cache
UNDEFINED = runtime.UNDEFINED
__M_dict_builtin = dict
__M_locals_builtin = locals
_magic_number = 9
_modified_time = 1396804512.086294
_enable_loop = True
_template_filename = '/home/sylvain/Dev/projects/WebSocket-for-Python/example/websensors/templates/board.html'
_template_uri = 'board.html'
_source_encoding = 'utf-8'
_exports = []


def render_body(context,**pageargs):
    __M_caller = context.caller_stack._push_frame()
    try:
        __M_locals = __M_dict_builtin(pageargs=pageargs)
        boardid = context.get('boardid', UNDEFINED)
        participantid = context.get('participantid', UNDEFINED)
        __M_writer = context.writer()
        # SOURCE LINE 1
        __M_writer(u'<!DOCTYPE html>\n<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->\n<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->\n<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->\n<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->\n    <head>\n        <meta charset="utf-8">\n        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">\n        <title>Mobile remote control</title>\n        <meta name="description" content="Remote control your webapp with your mobile device">\n        <meta name="viewport" content="width=device-width, initial-scale=1">\n        <meta name="twitter:card" content="Sylvain Hellegouarch\'s twitter account">\n        <meta name="twitter:site" content="@lawouach">\n        <meta name="twitter:url" content="http://www.defuze.org">\n\n        <link rel="stylesheet" href="/static/vendors/initializr/css/normalize.min.css">\n        <link rel="stylesheet" href="/static/vendors/initializr/css/main.css">\n        <link rel="stylesheet" href="/static/css/style.css">\n\n        <script src="/static/vendors/initializr/js/vendor/modernizr-2.6.2-respond-1.1.0.min.js"></script>\n    </head>\n    <body>\n        <!--[if lt IE 7]>\n            <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>\n        <![endif]-->\n\n        <div class="main-container" id="arena">\n\t    <canvas id="tools" width="70" height="600"></canvas>\n\t    <canvas id="board" width="150" height="600"></canvas>\n        </div>\n\n        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>\n\t<script type="application/javascript" src="/static/vendors/jcanvas/jcanvas.min.js"></script>\n        <script type="application/javascript" src="/static/vendors/initializr/js/plugins.js"></script>\n        <script type="application/javascript" src="/static/js/drawingboard.js"></script>\n        <script type="application/javascript">\n\t   $(document).ready(function() {\n\t      $.board({board: "')
        # SOURCE LINE 38
        __M_writer(unicode(boardid))
        __M_writer(u'", participant: "')
        __M_writer(unicode(participantid))
        __M_writer(u'"});\n\t   });\n        </script>\n    </body>\n</html>\n')
        return ''
    finally:
        context.caller_stack._pop_frame()



########NEW FILE########
__FILENAME__ = index.html
# -*- coding:utf-8 -*-
from mako import runtime, filters, cache
UNDEFINED = runtime.UNDEFINED
__M_dict_builtin = dict
__M_locals_builtin = locals
_magic_number = 9
_modified_time = 1396804510.682649
_enable_loop = True
_template_filename = '/home/sylvain/Dev/projects/WebSocket-for-Python/example/websensors/templates/index.html'
_template_uri = 'index.html'
_source_encoding = 'utf-8'
_exports = []


def render_body(context,**pageargs):
    __M_caller = context.caller_stack._push_frame()
    try:
        __M_locals = __M_dict_builtin(pageargs=pageargs)
        boardid = context.get('boardid', UNDEFINED)
        __M_writer = context.writer()
        # SOURCE LINE 1
        __M_writer(u'<!DOCTYPE html>\n<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->\n<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->\n<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->\n<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->\n    <head>\n        <meta charset="utf-8">\n        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">\n        <title>Shared drawing board</title>\n        <meta name="description" content="Remote control your webapp with your mobile device">\n        <meta name="viewport" content="width=device-width, initial-scale=1">\n        <meta name="twitter:card" content="Sylvain Hellegouarch\'s twitter account">\n        <meta name="twitter:site" content="@lawouach">\n        <meta name="twitter:url" content="http://www.defuze.org">\n\n        <link rel="stylesheet" href="/static/vendors/initializr/css/normalize.min.css">\n        <link rel="stylesheet" href="/static/vendors/initializr/css/main.css">\n\n        <script src="/static/vendors/initializr/js/vendor/modernizr-2.6.2-respond-1.1.0.min.js"></script>\n    </head>\n    <body>\n        <!--[if lt IE 7]>\n            <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>\n        <![endif]-->\n\n        <div class="header-container">\n            <header class="wrapper clearfix">\n                <h1 class="title">shared drawing board</h1>\n            </header>\n        </div>\n\n        <div class="main-container">\n            <div class="main wrapper clearfix">\n\n                <article>\n                    <section>\n\t                <p>This demo will demonstrate a fun usage of WebSocket and Canvases.\n\t                   The idea is that you will share a drawing board with other\n\t                   users or devices and each time someone will draw something onto\n\t                   the canvas, all other participants will see the drawing in near real-time\n\t                   on their side too.\n\t                </p>\n\t                <p>Please use the link below to share a drawing board:</p>\n\t                <p><a href="http://192.168.1.13:8080/board/')
        # SOURCE LINE 44
        __M_writer(unicode(boardid))
        __M_writer(u'">http://192.168.1.13:8080/board/')
        __M_writer(unicode(boardid))
        __M_writer(u'</a></p>\n                    </section>\n                </article>\n\n            </div> <!-- #main -->\n        </div> <!-- #main-container -->\n\n        <div class="footer-container">\n            <footer class="wrapper">\n                <p>&copy; 2014 | <a href="http://www.defuze.org/">Sylvain Hellegouarch</a></p>\n            </footer>\n        </div>\n\n        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>\n        <script type="application/javascript" src="/static/vendors/initializr/js/plugins.js"></script>\n    </body>\n</html>\n')
        return ''
    finally:
        context.caller_stack._pop_frame()



########NEW FILE########
__FILENAME__ = autobahn_test_servers
# -*- coding: utf-8 -*-
import logging

def run_cherrypy_server(host="127.0.0.1", port=9008):
    """
    Runs a CherryPy server on Python 2.x.
    """
    import cherrypy

    from ws4py.server.cherrypyserver import WebSocketPlugin, WebSocketTool
    from ws4py.websocket import EchoWebSocket

    cherrypy.config.update({'server.socket_host': host,
                            'server.socket_port': port,
                            'engine.autoreload.on': False,
                            'log.screen': False})
    WebSocketPlugin(cherrypy.engine).subscribe()
    cherrypy.tools.websocket = WebSocketTool()

    class Root(object):
        @cherrypy.expose
        def index(self):
            pass

    config = {
        '/': {
            'tools.encode.on': False,
            'tools.websocket.on': True,
            'tools.websocket.handler_cls': EchoWebSocket
            }
        }
    logger = logging.getLogger('autobahn_testsuite')
    logger.warning("Serving CherryPy server on %s:%s" % (host, port))

    cherrypy.quickstart(Root(), '/', config)

def run_cherrypy_server_with_wsaccel(host="127.0.0.1", port=9006):
    """
    Runs a CherryPy server on Python 2.x with
    a cython driver for some internal operations.
    """
    import wsaccel
    wsaccel.patch_ws4py()
    run_cherrypy_server(host, port)


def run_cherrypy_server_with_python3(host="127.0.0.1", port=9004):
    """
    Runs a CherryPy server on Python 3.x
    """
    import wsaccel
    wsaccel.patch_ws4py()
    run_cherrypy_server(host, port)


def run_cherrypy_server_with_pypy(host="127.0.0.1", port=9005):
    """
    Runs a CherryPy server on PyPy
    """
    run_cherrypy_server(host, port)


def run_gevent_server(host="127.0.0.1", port=9001):
    """
    Runs a gevent server on Python 2.x
    """
    from gevent import monkey; monkey.patch_all()
    import wsaccel
    wsaccel.patch_ws4py()
    from ws4py.websocket import EchoWebSocket
    from ws4py.server.geventserver import WebSocketWSGIApplication, WSGIServer

    server = WSGIServer((host, port), WebSocketWSGIApplication(handler_cls=EchoWebSocket))
    logger = logging.getLogger('autobahn_testsuite')
    logger.warning("Serving gevent server on %s:%s" % (host, port))
    server.serve_forever()


def run_python3_asyncio(host="127.0.0.1", port=9009):
    """
    Runs a server using asyncio and Python 3.3+
    """
    import asyncio
    import wsaccel
    wsaccel.patch_ws4py()
    from ws4py.async_websocket import EchoWebSocket
    from ws4py.server.tulipserver import WebSocketProtocol
    
    loop = asyncio.get_event_loop()

    def start_server():
        proto_factory = lambda: WebSocketProtocol(EchoWebSocket)
        return loop.create_server(proto_factory, host, port)

    s = loop.run_until_complete(start_server())
    logger = logging.getLogger('asyncio_testsuite')
    logger.warning("Serving asyncio server on %s:%s" % s.sockets[0].getsockname())
    loop.run_forever()



def run_tornado_server(host="127.0.0.1", port=9007):
    """
    Runs a Tornado server on Python 2.x
    """
    from tornado import ioloop, web, websocket
    class EchoWebSocket(websocket.WebSocketHandler):
        def on_message(self, message):
            self.write_message(message)

    app = web.Application([(r"/", EchoWebSocket)])
    app.listen(port, address=host)
    logger = logging.getLogger('autobahn_testsuite')
    logger.warning("Serving Tornado server on %s:%s" % (host, port))
    ioloop.IOLoop.instance().start()

def run_autobahn_server(host="127.0.0.1", port=9003):
    """
    Runs a Autobahn server on Python 2.x
    """
    from twisted.internet import reactor
    from autobahn.twisted.websocket import WebSocketServerProtocol, \
        WebSocketServerFactory
        
    class MyServerProtocol(WebSocketServerProtocol):
        def onMessage(self, payload, isBinary):
            self.sendMessage(payload, isBinary)

    logger = logging.getLogger('autobahn_testsuite')
    logger.warning("Serving Autobahn server on %s:%s" % (host, port))
    
    factory = WebSocketServerFactory("ws://%s:%d" % (host, port))
    factory.protocol = MyServerProtocol

    reactor.listenTCP(port, factory)
    reactor.run()
   
if __name__ == '__main__':
    import argparse
    from multiprocessing import Process

    logging.basicConfig(format='%(asctime)s %(message)s')
    logger = logging.getLogger('autobahn_testsuite')
    logger.setLevel(logging.WARNING)

    parser = argparse.ArgumentParser()
    parser.add_argument('--run-all', dest='run_all', action='store_true',
                        help='Run all servers backend')
    parser.add_argument('--run-cherrypy-server', dest='run_cherrypy', action='store_true',
                        help='Run the CherryPy server backend')
    parser.add_argument('--run-cherrypy-server-wsaccel', dest='run_cherrypy_wsaccel', action='store_true',
                        help='Run the CherryPy server backend and wsaccel driver')
    parser.add_argument('--run-cherrypy-server-pypy', dest='run_cherrypy_pypy', action='store_true',
                        help='Run the CherryPy server backend with PyPy')
    parser.add_argument('--run-cherrypy-server-py3k', dest='run_cherrypy_py3k', action='store_true',
                        help='Run the CherryPy server backend with Python 3')
    parser.add_argument('--run-gevent-server', dest='run_gevent', action='store_true',
                        help='Run the gevent server backend')
    parser.add_argument('--run-tornado-server', dest='run_tornado', action='store_true',
                        help='Run the Tornado server backend')
    parser.add_argument('--run-autobahn-server', dest='run_autobahn', action='store_true',
                        help='Run the Autobahn server backend')
    parser.add_argument('--run-asyncio-server', dest='run_asyncio', action='store_true',
                        help='Run the asyncio server backend')
    args = parser.parse_args()

    if args.run_all:
        args.run_cherrypy = True
        args.run_cherrypy_wsaccel = True
        args.run_gevent = True
        args.run_tornado = True
        args.run_autobahn = True
        args.run_asyncio = True

    procs = []
    logger.warning("CherryPy server: %s" % args.run_cherrypy)
    if args.run_cherrypy:
        p0 = Process(target=run_cherrypy_server)
        p0.daemon = True
        procs.append(p0)

    logger.warning("Gevent server: %s" % args.run_gevent)
    if args.run_gevent:
        p1 = Process(target=run_gevent_server)
        p1.daemon = True
        procs.append(p1)

    logger.warning("Tornado server: %s" % args.run_tornado)
    if args.run_tornado:
        p2 = Process(target=run_tornado_server)
        p2.daemon = True
        procs.append(p2)

    logger.warning("Autobahn server: %s" % args.run_autobahn)
    if args.run_autobahn:
        p3 = Process(target=run_autobahn_server)
        p3.daemon = True
        procs.append(p3)

    logger.warning("CherryPy server on PyPy: %s" % args.run_cherrypy_pypy)
    if args.run_cherrypy_pypy:
        p4 = Process(target=run_cherrypy_server_with_pypy)
        p4.daemon = True
        procs.append(p4)

    logger.warning("CherryPy server on Python 3: %s" % args.run_cherrypy_py3k)
    if args.run_cherrypy_py3k:
        p5 = Process(target=run_cherrypy_server_with_python3)
        p5.daemon = True
        procs.append(p5)

    logger.warning("CherryPy server on Python 2/wsaccel: %s" % args.run_cherrypy_wsaccel)
    if args.run_cherrypy_wsaccel:
        p6 = Process(target=run_cherrypy_server_with_wsaccel)
        p6.daemon = True
        procs.append(p6)

    logger.warning("asyncio server on Python 3: %s" % args.run_asyncio)
    if args.run_asyncio:
        p7 = Process(target=run_python3_asyncio)
        p7.daemon = True
        procs.append(p7)

    for p in procs:
        p.start()
        logging.info("Starting process... %d" % p.pid)

    for p in procs:
        p.join()


########NEW FILE########
__FILENAME__ = test_cherrypy
# -*- coding: utf-8 -*-
import os
import time
import unittest

from mock import MagicMock, call

import cherrypy
from ws4py.server.cherrypyserver import WebSocketPlugin, WebSocketTool
from ws4py.websocket import EchoWebSocket
from ws4py.framing import Frame, OPCODE_TEXT, OPCODE_CLOSE

class FakePoller(object):
    def __init__(self, timeout=0.1):
        self._fds = []

    def release(self):
        self._fds = []

    def register(self, fd):
        if fd not in self._fds:
            self._fds.append(fd)

    def unregister(self, fd):
        if fd in self._fds:
            self._fds.remove(fd)

    def poll(self):
        return self._fds

class App(object):
    @cherrypy.expose
    def ws(self):
        assert cherrypy.request.ws_handler != None

def setup_engine():
    # we don't need a HTTP server for this test
    cherrypy.server.unsubscribe()

    cherrypy.config.update({'log.screen': False})

    cherrypy.engine.websocket = WebSocketPlugin(cherrypy.engine)
    cherrypy.engine.websocket.subscribe()

    cherrypy.engine.websocket.manager.poller = FakePoller()

    cherrypy.tools.websocket = WebSocketTool()

    config={'/ws': {'tools.websocket.on': True,
                    'tools.websocket.handler_cls': EchoWebSocket}}
    cherrypy.tree.mount(App(), '/', config)
    cherrypy.engine.start()

def teardown_engine():
    cherrypy.engine.exit()

class CherryPyTest(unittest.TestCase):
    def setUp(self):
        setup_engine()

    def tearDown(self):
        teardown_engine()

    def test_plugin(self):
        manager = cherrypy.engine.websocket.manager
        self.assertEqual(len(manager), 0)

        s = MagicMock()
        s.recv.return_value = Frame(opcode=OPCODE_TEXT, body=b'hello',
                                    fin=1, masking_key=os.urandom(4)).build()
        h = EchoWebSocket(s, [], [])
        cherrypy.engine.publish('handle-websocket', h, ('127.0.0.1', 0))
        self.assertEqual(len(manager), 1)
        self.assertTrue(h in manager)

        # the following call to .close() on the
        # websocket object will initiate
        # the closing handshake
        # This next line mocks the response
        # from the client to actually
        # complete the handshake.
        # The manager will then remove the websocket
        # from its pool
        s.recv.return_value = Frame(opcode=OPCODE_CLOSE, body=b"ok we're done",
                                    fin=1, masking_key=os.urandom(4)).build()
        h.close()

        # the poller runs a thread, give it time to get there
        time.sleep(1)

        # TODO: Implement a fake poller so that works...
        self.assertEqual(len(manager), 0)

if __name__ == '__main__':
    suite = unittest.TestSuite()
    loader = unittest.TestLoader()
    for testcase in [CherryPyTest]:
        tests = loader.loadTestsFromTestCase(testcase)
        suite.addTests(tests)
    unittest.TextTestRunner(verbosity=2).run(suite)

########NEW FILE########
__FILENAME__ = test_client
# -*- coding: utf-8 -*-
import time
import unittest

from mock import MagicMock, call, patch

from ws4py.manager import WebSocketManager
from ws4py.websocket import WebSocket
from ws4py.client import WebSocketBaseClient
           
class BasicClientTest(unittest.TestCase):
    def test_invalid_hostname_in_url(self):
        self.assertRaises(ValueError, WebSocketBaseClient, url="qsdfqsd65qsd354")
        
    def test_invalid_scheme_in_url(self):
        self.assertRaises(ValueError, WebSocketBaseClient, url="ftp://localhost")
    
    
if __name__ == '__main__':
    suite = unittest.TestSuite()
    loader = unittest.TestLoader()
    for testcase in [BasicClientTest]:
        tests = loader.loadTestsFromTestCase(testcase)
        suite.addTests(tests)
    unittest.TextTestRunner(verbosity=2).run(suite)

########NEW FILE########
__FILENAME__ = test_frame
# -*- coding: utf-8 -*-
import os
import unittest
import types
import random

from ws4py.framing import Frame, \
     OPCODE_CONTINUATION, OPCODE_TEXT, \
     OPCODE_BINARY, OPCODE_CLOSE, OPCODE_PING, OPCODE_PONG
from ws4py.exc import FrameTooLargeException, ProtocolException
from ws4py.compat import *

def map_on_bytes(f, bytes):
    for index, byte in enumerate(bytes):
        f(bytes[index:index+1])

class WSFrameBuilderTest(unittest.TestCase):
    def test_7_bit_length(self):
        f = Frame(opcode=OPCODE_TEXT,
                  body=b'', fin=1)
        self.assertEqual(len(f.build()), 2)

        f = Frame(opcode=OPCODE_TEXT,
                  body=b'*' * 125, fin=1)
        self.assertEqual(len(f.build()), 127)

        mask = os.urandom(4)
        f = Frame(opcode=OPCODE_TEXT,
                  body=b'', masking_key=mask, fin=1)
        self.assertEqual(len(f.build()), 6)

        f = Frame(opcode=OPCODE_TEXT,
                  body=b'*' * 125, masking_key=mask, fin=1)
        self.assertEqual(len(f.build()), 131)

    def test_16_bit_length(self):
        f = Frame(opcode=OPCODE_TEXT,
                  body=b'*' * 126, fin=1)
        self.assertEqual(len(f.build()), 130)

        f = Frame(opcode=OPCODE_TEXT,
                  body=b'*' * 65535, fin=1)
        self.assertEqual(len(f.build()), 65539)

        mask = os.urandom(4)
        f = Frame(opcode=OPCODE_TEXT,
                  body=b'*' * 126, masking_key=mask, fin=1)
        self.assertEqual(len(f.build()), 134)

        f = Frame(opcode=OPCODE_TEXT,
                  body=b'*' * 65535, masking_key=mask, fin=1)
        self.assertEqual(len(f.build()), 65543)

    def test_63_bit_length(self):
        f = Frame(opcode=OPCODE_TEXT,
                  body=b'*' * 65536, fin=1)
        self.assertEqual(len(f.build()), 65546)

        mask = os.urandom(4)
        f = Frame(opcode=OPCODE_TEXT,
                  body=b'*' * 65536, masking_key=mask, fin=1)
        self.assertEqual(len(f.build()), 65550)

    def test_non_zero_nor_one_fin(self):
        f = Frame(opcode=OPCODE_TEXT,
                  body=b'', fin=2)
        self.assertRaises(ValueError, f.build)

    def test_opcodes(self):
        for opcode in [OPCODE_CONTINUATION, OPCODE_TEXT,
                       OPCODE_BINARY, OPCODE_CLOSE,
                       OPCODE_PING, OPCODE_PONG]:
            f = Frame(opcode=opcode, body=b'', fin=1)
            byte = ord(f.build()[0])
            self.assertTrue(byte & opcode == opcode)

        f = Frame(opcode=0x3, body=b'', fin=1)
        self.assertRaises(ValueError, f.build)

    def test_masking(self):
        if py3k: mask = b"7\xfa!="
        else: mask = "7\xfa!="
        f = Frame(opcode=OPCODE_TEXT,
                  body=b'Hello',
                  masking_key=mask, fin=1)

        if py3k: spec_says = b'\x81\x857\xfa!=\x7f\x9fMQX'
        else: spec_says = '\x81\x857\xfa!=\x7f\x9fMQX'
        self.assertEqual(f.build(), spec_says)

    def test_frame_too_large(self):
        f = Frame(opcode=OPCODE_TEXT, body=b'', fin=1)
        # fake huge length
        f.payload_length = 1 << 63
        self.assertRaises(FrameTooLargeException, f.build)

    def test_passing_encoded_string(self):
        # once encoded the u'\xe9' character will be of length 2
        f = Frame(opcode=OPCODE_TEXT, body=u'\xe9trange'.encode('utf-8'), fin=1)
        self.assertEqual(len(f.build()), 10)

    def test_passing_unencoded_string_raises_type_error(self):
        self.assertRaises(TypeError, Frame, opcode=OPCODE_TEXT, body=u'\xe9', fin=1)

class WSFrameParserTest(unittest.TestCase):
    def test_frame_parser_is_a_generator(self):
        f = Frame()
        self.assertEqual(type(f.parser), types.GeneratorType)
        f.parser.close()
        self.assertRaises(StopIteration, next, f.parser)

    def test_frame_header_parsing(self):
        bytes = Frame(opcode=OPCODE_TEXT, body=b'hello', fin=1).build()

        f = Frame()
        self.assertEqual(f.parser.send(bytes[0:1]), 1)
        self.assertEqual(f.fin, 1)
        self.assertEqual(f.rsv1, 0)
        self.assertEqual(f.rsv2, 0)
        self.assertEqual(f.rsv3, 0)
        self.assertEqual(f.parser.send(bytes[1:2]), 5)
        self.assertTrue(f.masking_key is None)
        self.assertEqual(f.payload_length, 5)
        f.parser.close()

    def test_frame_payload_parsing(self):
        bytes = Frame(opcode=OPCODE_TEXT, body=b'hello', fin=1).build()

        f = Frame()
        self.assertEqual(f.parser.send(bytes[0:1]), 1)
        self.assertEqual(f.parser.send(bytes[1:2]), 5)
        f.parser.send(bytes[2:])
        self.assertEqual(f.body, b'hello')

        f = Frame()
        f.parser.send(bytes)
        self.assertRaises(StopIteration, next, f.parser)
        self.assertEqual(f.body, b'hello')

    def test_incremental_parsing_small_7_bit_length(self):
        bytes = Frame(opcode=OPCODE_TEXT, body=b'hello', fin=1).build()

        f = Frame()
        map_on_bytes(f.parser.send, bytes)
        self.assertTrue(f.masking_key is None)
        self.assertEqual(f.payload_length, 5)

    def test_incremental_parsing_16_bit_length(self):
        bytes = Frame(opcode=OPCODE_TEXT, body=b'*' * 126, fin=1).build()

        f = Frame()
        map_on_bytes(f.parser.send, bytes)
        self.assertTrue(f.masking_key is None)
        self.assertEqual(f.payload_length, 126)

    def test_incremental_parsing_63_bit_length(self):
        bytes = Frame(opcode=OPCODE_TEXT, body=b'*' * 65536, fin=1).build()

        f = Frame()
        map_on_bytes(f.parser.send, bytes)
        self.assertTrue(f.masking_key is None)
        self.assertEqual(f.payload_length, 65536)

    def test_rsv1_bits_set(self):
        f = Frame()
        self.assertRaises(ProtocolException, f.parser.send, b'\x40')

    def test_rsv2_bits_set(self):
        f = Frame()
        self.assertRaises(ProtocolException, f.parser.send, b'\x20')

    def test_rsv3_bits_set(self):
        f = Frame()
        self.assertRaises(ProtocolException, f.parser.send, b'\x10')

    def test_invalid_opcode(self):
        for opcode in range(3, 9):
            f = Frame()
            self.assertRaises(ProtocolException, f.parser.send, chr(opcode))

        f = Frame()
        self.assertRaises(ProtocolException, f.parser.send, chr(10))

    def test_fragmented_control_frame_is_invalid(self):
        f = Frame()
        self.assertRaises(ProtocolException, f.parser.send, b'0x9')

    def test_fragmented_control_frame_is_too_large(self):
        bytes = Frame(opcode=OPCODE_PING, body=b'*'*65536, fin=1).build()
        f = Frame()
        self.assertRaises(FrameTooLargeException, f.parser.send, bytes)

    def test_frame_sized_127(self):
        body = b'*'*65536
        bytes = Frame(opcode=OPCODE_TEXT, body=body, fin=1).build()

        f = Frame()
        # determine how the size is stored
        f.parser.send(bytes[:3])
        self.assertTrue(f.masking_key is None)
        # that's a large frame indeed
        self.assertEqual(f.payload_length, 127)

        # this will compute the actual application data size
        # it will also read the first byte of data
        # indeed the length is found from byte 3 to 10
        f.parser.send(bytes[3:11])
        self.assertEqual(f.payload_length, 65536)
        
        # parse the rest of our data
        f.parser.send(bytes[11:])
        self.assertEqual(f.body, body)

        
        # The same but this time we provide enough
        # bytes so that the application's data length
        # can be computed from the first generator's send call
        f = Frame()
        f.parser.send(bytes[:10])
        self.assertTrue(f.masking_key is None)
        self.assertEqual(f.payload_length, 65536)
        
        # parse the rest of our data
        f.parser.send(bytes[10:])
        self.assertEqual(f.body, body)
        
        
        # The same with masking given out gradually
        mask = os.urandom(4)
        bytes = Frame(opcode=OPCODE_TEXT, body=body, fin=1, masking_key=mask).build()
        f = Frame()
        f.parser.send(bytes[:10])
        self.assertTrue(f.masking_key is None)
        self.assertEqual(f.payload_length, 65536)
        
        # parse the mask gradually
        f.parser.send(bytes[10:12])
        f.parser.send(bytes[12:])
        self.assertEqual(f.unmask(f.body), body)
        
    def test_frame_sized_126(self):
        body = b'*'*256
        bytes = Frame(opcode=OPCODE_TEXT, body=body, fin=1).build()

        f = Frame()
        # determine how the size is stored
        f.parser.send(bytes[:3])
        self.assertTrue(f.masking_key is None)
        # that's a large frame indeed
        self.assertEqual(f.payload_length, 126)

        # this will compute the actual application data size
        # it will also read the first byte of data
        # indeed the length is found from byte 3 to 10
        f.parser.send(bytes[3:11])
        self.assertEqual(f.payload_length, 256)
        
        # parse the rest of our data
        f.parser.send(bytes[11:])
        self.assertEqual(f.body, body)
        
        
        # The same but this time we provide enough
        # bytes so that the application's data length
        # can be computed from the first generator's send call
        f = Frame()
        f.parser.send(bytes[:10])
        self.assertTrue(f.masking_key is None)
        self.assertEqual(f.payload_length, 256)
        
        # parse the rest of our data
        f.parser.send(bytes[10:])
        self.assertEqual(f.body, body)
        
if __name__ == '__main__':
    suite = unittest.TestSuite()
    loader = unittest.TestLoader()
    for testcase in (WSFrameBuilderTest, WSFrameParserTest,):
        tests = loader.loadTestsFromTestCase(testcase)
        suite.addTests(tests)
    unittest.TextTestRunner(verbosity=2).run(suite)

########NEW FILE########
__FILENAME__ = test_manager
# -*- coding: utf-8 -*-
import time
import unittest

from mock import MagicMock, call, patch

from ws4py.manager import WebSocketManager
from ws4py.websocket import WebSocket

class WSManagerTest(unittest.TestCase):
    @patch('ws4py.manager.SelectPoller')
    def test_add_and_remove_websocket(self, MockSelectPoller):
        m = WebSocketManager(poller=MockSelectPoller())

        ws = MagicMock()
        ws.sock.fileno.return_value = 1
        
        m.add(ws)
        m.poller.register.assert_call_once_with(ws)

        m.remove(ws)
        m.poller.unregister.assert_call_once_with(ws)
        
    @patch('ws4py.manager.SelectPoller')
    def test_cannot_add_websocket_more_than_once(self, MockSelectPoller):
        m = WebSocketManager(poller=MockSelectPoller())

        ws = MagicMock()
        ws.sock.fileno.return_value = 1
        
        m.add(ws)
        self.assertEqual(len(m), 1)
        
        m.add(ws)
        self.assertEqual(len(m), 1)
        
    @patch('ws4py.manager.SelectPoller')
    def test_cannot_remove_unregistered_websocket(self, MockSelectPoller):
        m = WebSocketManager(poller=MockSelectPoller())

        ws = MagicMock()
        ws.sock.fileno.return_value = 1
        
        m.remove(ws)
        self.assertEqual(len(m), 0)
        self.assertFalse(m.poller.unregister.called)
        
        m.add(ws)
        self.assertEqual(len(m), 1)
        m.remove(ws)
        self.assertEqual(len(m), 0)
        m.poller.unregister.assert_call_once_with(ws)
        m.poller.reset_mock()
        
        m.remove(ws)
        self.assertEqual(len(m), 0)
        self.assertFalse(m.poller.unregister.called)

    @patch('ws4py.manager.SelectPoller')
    def test_mainloop_can_be_stopped_when_no_websocket_were_registered(self, MockSelectPoller):
        m = WebSocketManager(poller=MockSelectPoller())
        self.assertFalse(m.running)
        
        m.start()
        self.assertTrue(m.running)

        m.stop()
        self.assertFalse(m.running)
        
    @patch('ws4py.manager.SelectPoller')
    def test_mainloop_can_be_stopped(self, MockSelectPoller):
        m = WebSocketManager(poller=MockSelectPoller())
        
        def poll():
            yield 1
            m.stop()
            yield 2
            
        m.poller.poll.return_value = poll()
        self.assertFalse(m.running)
        
        m.start()
        # just make sure it had the time to finish
        time.sleep(0.1)
        self.assertFalse(m.running)
        
    @patch('ws4py.manager.SelectPoller')
    def test_websocket_terminated_from_mainloop(self, MockSelectPoller):
        m = WebSocketManager(poller=MockSelectPoller())
        m.poller.poll.return_value = [1]

        ws = MagicMock()
        
        ws.terminated = False
        ws.sock.fileno.return_value = 1
        ws.once.return_value = False
        
        m.add(ws)
        m.start()
        
        ws.terminate.assert_call_once_with()
        
        m.stop()
    
    @patch('ws4py.manager.SelectPoller')
    def test_websocket_close_all(self, MockSelectPoller):
        m = WebSocketManager(poller=MockSelectPoller())

        ws = MagicMock()
        m.add(ws)
        m.close_all()
        ws.terminate.assert_call_once_with(1001, 'Server is shutting down')
        
    @patch('ws4py.manager.SelectPoller')
    def test_broadcast(self, MockSelectPoller):
        m = WebSocketManager(poller=MockSelectPoller())

        ws = MagicMock()
        ws.terminated = False
        m.add(ws)

        m.broadcast(b'hello there')
        ws.send.assert_call_once_with(b'hello there')
        
    @patch('ws4py.manager.SelectPoller')
    def test_broadcast_failure_must_not_break_caller(self, MockSelectPoller):
        m = WebSocketManager(poller=MockSelectPoller())

        ws = MagicMock()
        ws.terminated = False
        ws.send.side_effect = RuntimeError
        m.add(ws)

        try:
                m.broadcast(b'hello there')
        except:
                self.fail("Broadcasting shouldn't have failed")
                
if __name__ == '__main__':
    suite = unittest.TestSuite()
    loader = unittest.TestLoader()
    for testcase in [WSManagerTest]:
        tests = loader.loadTestsFromTestCase(testcase)
        suite.addTests(tests)
    unittest.TextTestRunner(verbosity=2).run(suite)

########NEW FILE########
__FILENAME__ = test_messaging
# -*- coding: utf-8 -*-
import os
import unittest

from ws4py.framing import Frame, \
     OPCODE_CONTINUATION, OPCODE_TEXT, \
     OPCODE_BINARY, OPCODE_CLOSE, OPCODE_PING, OPCODE_PONG
from ws4py.messaging import *
from ws4py.compat import *

class WSMessagingTest(unittest.TestCase):
    def test_bytearray_text_message(self):
        m = TextMessage(bytearray(u'\xe9trange', 'utf-8'))
        self.assertFalse(m.is_binary)
        self.assertTrue(m.is_text)
        self.assertEqual(m.opcode, OPCODE_TEXT)
        self.assertEqual(m.encoding, 'utf-8')
        self.assertIsInstance(m.data, bytes)
        # length is compted on the unicode representation
        self.assertEqual(len(m), 7)
        # but once encoded it's actually taking 8 bytes in UTF-8
        self.assertEqual(len(m.data), 8)
        self.assertEqual(m.data, u'\xe9trange'.encode('utf-8'))

        f = m.single()
        self.assertIsInstance(f, bytes)
        self.assertEqual(len(f), 10)  # no masking

        f = m.single(mask=True)
        self.assertIsInstance(f, bytes)
        self.assertEqual(len(f), 14)  # mask takes 4 bytes

        self.assertEqual(m.fragment(first=True, last=True), m.single())

        m.extend(bytearray(' oui', 'utf-8'))
        self.assertEqual(m.data, u'\xe9trange oui'.encode('utf-8'))

    def test_bytes_text_message(self):
        m = TextMessage(u'\xe9trange'.encode('utf-8'))
        self.assertEqual(m.opcode, OPCODE_TEXT)
        self.assertEqual(m.encoding, 'utf-8')
        self.assertIsInstance(m.data, bytes)
        self.assertFalse(m.is_binary)
        self.assertTrue(m.is_text)
        # length is compted on the unicode representation
        self.assertEqual(len(m), 7)
        # but once encoded it's actually taking 8 bytes in UTF-8
        self.assertEqual(len(m.data), 8)
        self.assertEqual(m.data, u'\xe9trange'.encode('utf-8'))

        f = m.single()
        self.assertIsInstance(f, bytes)
        self.assertEqual(len(f), 10)  # no masking

        f = m.single(mask=True)
        self.assertIsInstance(f, bytes)
        self.assertEqual(len(f), 14)  # mask takes 4 bytes

        self.assertEqual(m.fragment(first=True, last=True), m.single())

        m.extend(b' oui')
        self.assertEqual(m.data, u'\xe9trange oui'.encode('utf-8'))

    def test_unicode_text_message(self):
        m = TextMessage(u'\xe9trange')
        self.assertEqual(m.opcode, OPCODE_TEXT)
        self.assertEqual(m.encoding, 'utf-8')
        self.assertIsInstance(m.data, bytes)
        self.assertFalse(m.is_binary)
        self.assertTrue(m.is_text)
        # length is compted on the unicode representation
        self.assertEqual(len(m), 7)
        # but once encoded it's actually taking 8 bytes in UTF-8
        self.assertEqual(len(m.data), 8)
        self.assertEqual(m.data, u'\xe9trange'.encode('utf-8'))

        f = m.single()
        self.assertIsInstance(f, bytes)
        self.assertEqual(len(f), 10)  # no masking

        f = m.single(mask=True)
        self.assertIsInstance(f, bytes)
        self.assertEqual(len(f), 14)  # mask takes 4 bytes

        self.assertEqual(m.fragment(first=True, last=True), m.single())

        m.extend(u' oui')
        self.assertEqual(m.data, u'\xe9trange oui'.encode('utf-8'))

    def test_unicode_text_message_with_no_encoding(self):
        self.assertRaises(TypeError, Message, OPCODE_TEXT, u'\xe9trange', encoding=None)

    def test_invalid_text_message_data_type(self):
        self.assertRaises(TypeError, TextMessage, ['something else'])
        m = TextMessage(u'\xe9trange')
        self.assertRaises(TypeError, m.extend, ["list aren't supported types"])

    def test_close_control_message(self):
        m = CloseControlMessage(reason=u'bye bye')
        self.assertEqual(m.opcode, OPCODE_CLOSE)
        self.assertEqual(m.encoding, 'utf-8')
        self.assertIsInstance(m.reason, bytes)
        self.assertEqual(len(m), 7)
        self.assertEqual(m.code, 1000)
        self.assertEqual(m.reason, b'bye bye')
        
    def test_ping_control_message(self):
        m = PingControlMessage(data=u'are you there?')
        self.assertEqual(m.opcode, OPCODE_PING)
        self.assertEqual(m.encoding, 'utf-8')
        self.assertIsInstance(m.data, bytes)
        self.assertEqual(len(m), 14)
        
    def test_pong_control_message(self):
        m = PongControlMessage(data=u'yes, I am')
        self.assertEqual(m.opcode, OPCODE_PONG)
        self.assertEqual(m.encoding, 'utf-8')
        self.assertIsInstance(m.data, bytes)
        self.assertEqual(len(m), 9)
        

if __name__ == '__main__':
    suite = unittest.TestSuite()
    loader = unittest.TestLoader()
    for testcase in [WSMessagingTest]:
        tests = loader.loadTestsFromTestCase(testcase)
        suite.addTests(tests)
    unittest.TextTestRunner(verbosity=2).run(suite)

########NEW FILE########
__FILENAME__ = test_stream
# -*- coding: utf-8 -*-
import unittest
import os
import struct

from ws4py.framing import Frame, \
     OPCODE_CONTINUATION, OPCODE_TEXT, \
     OPCODE_BINARY, OPCODE_CLOSE, OPCODE_PING, OPCODE_PONG
from ws4py.streaming import Stream
from ws4py.messaging import TextMessage, BinaryMessage, \
     CloseControlMessage, PingControlMessage, PongControlMessage
from ws4py.compat import *

class WSStreamTest(unittest.TestCase):
    def test_empty_close_message(self):
        f = Frame(opcode=OPCODE_CLOSE, body=b'', fin=1, masking_key=os.urandom(4)).build()
        s = Stream()
        self.assertEqual(s.closing, None)
        s.parser.send(f)
        self.assertEqual(type(s.closing), CloseControlMessage)

    def test_missing_masking_key_when_expected(self):
        f = Frame(opcode=OPCODE_TEXT, body=b'hello', fin=1, masking_key=None).build()
        s = Stream(expect_masking=True)
        s.parser.send(f)
        next(s.parser)
        self.assertNotEqual(s.errors, [])
        self.assertIsInstance(s.errors[0], CloseControlMessage)
        self.assertEqual(s.errors[0].code, 1002)

    def test_using_masking_key_when_unexpected(self):
        f = Frame(opcode=OPCODE_TEXT, body=b'hello', fin=1, masking_key=os.urandom(4)).build()
        s = Stream(expect_masking=False)
        s.parser.send(f)
        next(s.parser)
        self.assertNotEqual(s.errors, [])
        self.assertIsInstance(s.errors[0], CloseControlMessage)
        self.assertEqual(s.errors[0].code, 1002)

    def test_text_messages_cannot_interleave(self):
        s = Stream()

        f = Frame(opcode=OPCODE_TEXT, body=b'hello',
                  fin=0, masking_key=os.urandom(4)).build()
        s.parser.send(f)
        next(s.parser)

        f = Frame(opcode=OPCODE_TEXT, body=b'there',
                  fin=1, masking_key=os.urandom(4)).build()
        s.parser.send(f)
        next(s.parser)

        self.assertNotEqual(s.errors, [])
        self.assertIsInstance(s.errors[0], CloseControlMessage)
        self.assertEqual(s.errors[0].code, 1002)

    def test_binary_messages_cannot_interleave(self):
        s = Stream()

        f = Frame(opcode=OPCODE_BINARY, body=os.urandom(2),
                  fin=0, masking_key=os.urandom(4)).build()
        s.parser.send(f)
        next(s.parser)

        f = Frame(opcode=OPCODE_BINARY, body=os.urandom(7),
                  fin=1, masking_key=os.urandom(4)).build()
        s.parser.send(f)
        next(s.parser)

        self.assertNotEqual(s.errors, [])
        self.assertIsInstance(s.errors[0], CloseControlMessage)
        self.assertEqual(s.errors[0].code, 1002)

    def test_binary_and_text_messages_cannot_interleave(self):
        s = Stream()

        f = Frame(opcode=OPCODE_TEXT, body=b'hello',
                  fin=0, masking_key=os.urandom(4)).build()
        s.parser.send(f)
        next(s.parser)

        f = Frame(opcode=OPCODE_BINARY, body=os.urandom(7),
                  fin=1, masking_key=os.urandom(4)).build()
        s.parser.send(f)
        next(s.parser)

        self.assertNotEqual(s.errors, [])
        self.assertIsInstance(s.errors[0], CloseControlMessage)
        self.assertEqual(s.errors[0].code, 1002)

    def test_continuation_frame_before_message_started_is_invalid(self):
        f = Frame(opcode=OPCODE_CONTINUATION, body=b'hello',
                  fin=1, masking_key=os.urandom(4)).build()
        s = Stream()
        s.parser.send(f)
        next(s.parser)
        self.assertNotEqual(s.errors, [])
        self.assertIsInstance(s.errors[0], CloseControlMessage)
        self.assertEqual(s.errors[0].code, 1002)

    def test_invalid_encoded_bytes(self):
        f = Frame(opcode=OPCODE_TEXT, body=b'h\xc3llo',
                  fin=1, masking_key=os.urandom(4)).build()
        s = Stream()
        s.parser.send(f)
        next(s.parser)
        self.assertNotEqual(s.errors, [])
        self.assertIsInstance(s.errors[0], CloseControlMessage)
        self.assertEqual(s.errors[0].code, 1007)

    def test_invalid_encoded_bytes_on_continuation(self):
        s = Stream()

        f = Frame(opcode=OPCODE_TEXT, body=b'hello',
                  fin=0, masking_key=os.urandom(4)).build()
        s.parser.send(f)
        next(s.parser)

        f = Frame(opcode=OPCODE_CONTINUATION, body=b'h\xc3llo',
                  fin=1, masking_key=os.urandom(4)).build()
        s.parser.send(f)
        next(s.parser)

        self.assertNotEqual(s.errors, [])
        self.assertIsInstance(s.errors[0], CloseControlMessage)
        self.assertEqual(s.errors[0].code, 1007)

    def test_too_large_close_message(self):
        payload = struct.pack("!H", 1000) + b'*' * 330
        f = Frame(opcode=OPCODE_CLOSE, body=payload,
                  fin=1, masking_key=os.urandom(4)).build()
        s = Stream()
        self.assertEqual(len(s.errors), 0)
        self.assertEqual(s.closing, None)
        s.parser.send(f)
        self.assertEqual(s.closing, None)

        self.assertEqual(len(s.errors), 1)
        self.assertEqual(type(s.errors[0]), CloseControlMessage)
        self.assertEqual(s.errors[0].code, 1002)

    def test_invalid_sized_close_message(self):
        payload = b'boom'
        f = Frame(opcode=OPCODE_CLOSE, body=payload,
                  fin=1, masking_key=os.urandom(4)).build()
        s = Stream()
        self.assertEqual(len(s.errors), 0)
        self.assertEqual(s.closing, None)
        s.parser.send(f)
        self.assertEqual(type(s.closing), CloseControlMessage)
        self.assertEqual(s.closing.code, 1002)

    def test_close_message_of_size_one_are_invalid(self):
        payload = b'*'
        f = Frame(opcode=OPCODE_CLOSE, body=payload,
                  fin=1, masking_key=os.urandom(4)).build()
        s = Stream()
        self.assertEqual(len(s.errors), 0)
        self.assertEqual(s.closing, None)
        s.parser.send(f)
        self.assertEqual(type(s.closing), CloseControlMessage)
        self.assertEqual(s.closing.code, 1002)

    def test_invalid_close_message_type(self):
        payload = struct.pack("!H", 1500) + b'hello'
        f = Frame(opcode=OPCODE_CLOSE, body=payload,
                  fin=1, masking_key=os.urandom(4)).build()
        s = Stream()
        self.assertEqual(len(s.errors), 0)
        self.assertEqual(s.closing, None)
        s.parser.send(f)
        self.assertEqual(type(s.closing), CloseControlMessage)
        self.assertEqual(s.closing.code, 1002)

    def test_invalid_close_message_reason_encoding(self):
        payload = struct.pack("!H", 1000) + b'h\xc3llo'
        f = Frame(opcode=OPCODE_CLOSE, body=payload,
                  fin=1, masking_key=os.urandom(4)).build()
        s = Stream()
        self.assertEqual(len(s.errors), 0)
        self.assertEqual(s.closing, None)
        s.parser.send(f)
        self.assertEqual(s.closing, None)
        self.assertEqual(type(s.errors[0]), CloseControlMessage)
        self.assertEqual(s.errors[0].code, 1007)

    def test_protocol_exception_from_frame_parsing(self):
        payload = struct.pack("!H", 1000) + b'hello'
        f = Frame(opcode=OPCODE_CLOSE, body=payload,
                  fin=1, masking_key=os.urandom(4))
        f.rsv1 = 1
        f = f.build()
        s = Stream()
        self.assertEqual(len(s.errors), 0)
        self.assertEqual(s.closing, None)
        s.parser.send(f)
        self.assertEqual(s.closing, None)
        self.assertEqual(type(s.errors[0]), CloseControlMessage)
        self.assertEqual(s.errors[0].code, 1002)

    def test_close_message_received(self):
        payload = struct.pack("!H", 1000) + b'hello'
        f = Frame(opcode=OPCODE_CLOSE, body=payload,
                  fin=1, masking_key=os.urandom(4)).build()
        s = Stream()
        self.assertEqual(s.closing, None)
        s.parser.send(f)
        self.assertEqual(type(s.closing), CloseControlMessage)
        self.assertEqual(s.closing.code, 1000)
        self.assertEqual(s.closing.reason, b'hello')

    def test_ping_message_received(self):
        msg = b'ping me'
        f = Frame(opcode=OPCODE_PING, body=msg, fin=1, masking_key=os.urandom(4)).build()
        s = Stream()
        self.assertEqual(len(s.pings), 0)
        s.parser.send(f)
        self.assertEqual(len(s.pings), 1)

    def test_pong_message_received(self):
        msg = b'pong!'
        f = Frame(opcode=OPCODE_PONG, body=msg, fin=1, masking_key=os.urandom(4)).build()
        s = Stream()
        self.assertEqual(len(s.pongs), 0)
        s.parser.send(f)
        self.assertEqual(len(s.pongs), 1)

    def test_text_message_received(self):
        msg = b'hello there'
        f = Frame(opcode=OPCODE_TEXT, body=msg, fin=1, masking_key=os.urandom(4)).build()
        s = Stream()
        self.assertEqual(len(s.messages), 0)
        s.parser.send(f)
        self.assertEqual(len(s.messages), 1)

    def test_incremental_text_message_received(self):
        msg = b'hello there'
        f = Frame(opcode=OPCODE_TEXT, body=msg, fin=1, masking_key=os.urandom(4)).build()
        s = Stream()
        self.assertEqual(s.has_message, False)
        bytes = f
        for index, byte in enumerate(bytes):
            s.parser.send(bytes[index:index+1])
        self.assertEqual(s.has_message, True)

    def test_text_message_received(self):
        msg = b'hello there'
        f = Frame(opcode=OPCODE_TEXT, body=msg, fin=1, masking_key=os.urandom(4)).build()
        s = Stream()
        self.assertEqual(s.has_message, False)
        s.parser.send(f)
        self.assertEqual(s.message.completed, True)

    def test_text_message_with_continuation_received(self):
        msg = b'hello there'
        f = Frame(opcode=OPCODE_TEXT, body=msg, fin=0, masking_key=os.urandom(4)).build()
        s = Stream()
        self.assertEqual(s.has_message, False)
        s.parser.send(f)
        self.assertEqual(s.message.completed, False)

        for i in range(3):
            f = Frame(opcode=OPCODE_CONTINUATION, body=msg, fin=0, masking_key=os.urandom(4)).build()
            s.parser.send(f)
            self.assertEqual(s.has_message, False)
            self.assertEqual(s.message.completed, False)
            self.assertEqual(s.message.opcode, OPCODE_TEXT)

        f = Frame(opcode=OPCODE_CONTINUATION, body=msg, fin=1, masking_key=os.urandom(4)).build()
        s.parser.send(f)
        self.assertEqual(s.has_message, True)
        self.assertEqual(s.message.completed, True)
        self.assertEqual(s.message.opcode, OPCODE_TEXT)

    def test_text_message_with_continuation_and_ping_in_between(self):
        msg = b'hello there'
        key = os.urandom(4)
        f = Frame(opcode=OPCODE_TEXT, body=msg, fin=0, masking_key=os.urandom(4)).build()
        s = Stream()
        self.assertEqual(s.has_message, False)
        s.parser.send(f)
        self.assertEqual(s.message.completed, False)

        for i in range(3):
            f = Frame(opcode=OPCODE_CONTINUATION, body=msg, fin=0, masking_key=os.urandom(4)).build()
            s.parser.send(f)
            self.assertEqual(s.has_message, False)
            self.assertEqual(s.message.completed, False)
            self.assertEqual(s.message.opcode, OPCODE_TEXT)

            f = Frame(opcode=OPCODE_PING, body=b'ping me', fin=1, masking_key=os.urandom(4)).build()
            self.assertEqual(len(s.pings), i)
            s.parser.send(f)
            self.assertEqual(len(s.pings), i+1)

        f = Frame(opcode=OPCODE_CONTINUATION, body=msg, fin=1, masking_key=os.urandom(4)).build()
        s.parser.send(f)
        self.assertEqual(s.has_message, True)
        self.assertEqual(s.message.opcode, OPCODE_TEXT)
        self.assertEqual(s.message.completed, True)

    def test_binary_message_received(self):
        msg = os.urandom(16)
        f = Frame(opcode=OPCODE_BINARY, body=msg, fin=1, masking_key=os.urandom(4)).build()
        s = Stream()
        self.assertEqual(s.has_message, False)
        s.parser.send(f)
        self.assertEqual(s.message.completed, True)

    def test_binary_message_with_continuation_received(self):
        msg = os.urandom(16)
        key = os.urandom(4)
        f = Frame(opcode=OPCODE_BINARY, body=msg, fin=0, masking_key=key).build()
        s = Stream()
        self.assertEqual(s.has_message, False)
        s.parser.send(f)
        self.assertEqual(s.has_message, False)

        for i in range(3):
            f = Frame(opcode=OPCODE_CONTINUATION, body=msg, fin=0, masking_key=key).build()
            s.parser.send(f)
            self.assertEqual(s.has_message, False)
            self.assertEqual(s.message.completed, False)
            self.assertEqual(s.message.opcode, OPCODE_BINARY)

        f = Frame(opcode=OPCODE_CONTINUATION, body=msg, fin=1, masking_key=key).build()
        s.parser.send(f)
        self.assertEqual(s.has_message, True)
        self.assertEqual(s.message.completed, True)
        self.assertEqual(s.message.opcode, OPCODE_BINARY)

    def test_helper_with_unicode_text_message(self):
        s = Stream()
        m = s.text_message(u'hello there!')
        self.assertIsInstance(m, TextMessage)
        self.assertFalse(m.is_binary)
        self.assertTrue(m.is_text)
        self.assertEqual(m.opcode, OPCODE_TEXT)
        self.assertEqual(m.encoding, 'utf-8')
        self.assertIsInstance(m.data, bytes)
        self.assertEqual(len(m), 12)
        self.assertEqual(len(m.data), 12)
        self.assertEqual(m.data, b'hello there!')

    def test_helper_with_bytes_text_message(self):
        s = Stream()
        m = s.text_message('hello there!')
        self.assertIsInstance(m, TextMessage)
        self.assertFalse(m.is_binary)
        self.assertTrue(m.is_text)
        self.assertEqual(m.opcode, OPCODE_TEXT)
        self.assertEqual(m.encoding, 'utf-8')
        self.assertIsInstance(m.data, bytes)
        self.assertEqual(len(m), 12)
        self.assertEqual(len(m.data), 12)
        self.assertEqual(m.data, b'hello there!')

    def test_helper_with_binary_message(self):
        msg = os.urandom(16)
        s = Stream()
        m = s.binary_message(msg)
        self.assertIsInstance(m, BinaryMessage)
        self.assertTrue(m.is_binary)
        self.assertFalse(m.is_text)
        self.assertEqual(m.opcode, OPCODE_BINARY)
        self.assertIsInstance(m.data, bytes)
        self.assertEqual(len(m), 16)
        self.assertEqual(len(m.data), 16)
        self.assertEqual(m.data, msg)

    def test_helper_ping_message(self):
        s = Stream()
        m = s.ping('sos')
        self.assertIsInstance(m, bytes)
        self.assertEqual(len(m), 5)

    def test_helper_masked_ping_message(self):
        s = Stream(always_mask=True)
        m = s.ping('sos')
        self.assertIsInstance(m, bytes)
        self.assertEqual(len(m), 9)

    def test_helper_pong_message(self):
        s = Stream()
        m = s.pong('sos')
        self.assertIsInstance(m, bytes)
        self.assertEqual(len(m), 5)

    def test_helper_masked_pong_message(self):
        s = Stream(always_mask=True)
        m = s.pong('sos')
        self.assertIsInstance(m, bytes)
        self.assertEqual(len(m), 9)

    def test_closing_parser_should_release_resources(self):
        f = Frame(opcode=OPCODE_TEXT, body=b'hello',
                  fin=1, masking_key=os.urandom(4)).build()
        s = Stream()
        s.parser.send(f)
        s.parser.close()


if __name__ == '__main__':
    suite = unittest.TestSuite()
    loader = unittest.TestLoader()
    for testcase in [WSStreamTest]:
        tests = loader.loadTestsFromTestCase(testcase)
        suite.addTests(tests)
    unittest.TextTestRunner(verbosity=2).run(suite)

########NEW FILE########
__FILENAME__ = test_websocket
# -*- coding: utf-8 -*-
import unittest
import os
import socket
import struct

from mock import MagicMock, call, patch

from ws4py.framing import Frame, \
     OPCODE_CONTINUATION, OPCODE_TEXT, \
     OPCODE_BINARY, OPCODE_CLOSE, OPCODE_PING, OPCODE_PONG
from ws4py.websocket import WebSocket
from ws4py.messaging import TextMessage, BinaryMessage, \
     CloseControlMessage, PingControlMessage, PongControlMessage
from ws4py.compat import *

class WSWebSocketTest(unittest.TestCase):
    def test_get_ipv4_addresses(self):
        m = MagicMock()
        m.getsockname.return_value = ('127.0.0.1', 52300)
        m.getpeername.return_value = ('127.0.0.1', 4800)
        ws = WebSocket(sock=m)
        self.assertEqual(ws.local_address, ('127.0.0.1', 52300))
        self.assertEqual(ws.peer_address, ('127.0.0.1', 4800))

    def test_get_ipv6_addresses(self):
        m = MagicMock()
        m.getsockname.return_value = ('127.0.0.1', 52300, None, None)
        m.getpeername.return_value = ('127.0.0.1', 4800, None, None)
        ws = WebSocket(sock=m)
        self.assertEqual(ws.local_address, ('127.0.0.1', 52300))
        self.assertEqual(ws.peer_address, ('127.0.0.1', 4800))

    def test_get_underlying_connection(self):
        m = MagicMock()
        ws = WebSocket(sock=m)
        self.assertEqual(ws.connection, m)

    def test_close_connection(self):
        m = MagicMock()
        ws = WebSocket(sock=m)
        ws.close_connection()
        m.shutdown.assert_called_once_with(socket.SHUT_RDWR)
        m.close.assert_called_once_with()
        self.assertIsNone(ws.connection)

        m = MagicMock()
        m.close = MagicMock(side_effect=RuntimeError)
        ws = WebSocket(sock=m)
        ws.close_connection()
        self.assertIsNone(ws.connection)

    def test_terminate_with_closing(self):
        m = MagicMock()
        s = MagicMock()
        c = MagicMock()
        cc = MagicMock()
        
        ws = WebSocket(sock=m)
        with patch.multiple(ws, closed=c, close_connection=cc):
            ws.stream = s
            ws.stream.closing = CloseControlMessage(code=1000, reason='test closing')
            ws.terminate()
            self.assertTrue(ws.client_terminated)
            self.assertTrue(ws.server_terminated)
            self.assertTrue(ws.terminated)
            c.assert_called_once_with(1000, b'test closing')
            cc.assert_called_once_with()
            self.assertIsNone(ws.stream)
            self.assertIsNone(ws.environ)
        
    def test_terminate_without_closing(self):
        m = MagicMock()
        s = MagicMock()
        c = MagicMock()
        cc = MagicMock()
        
        ws = WebSocket(sock=m)
        with patch.multiple(ws, closed=c, close_connection=cc):
            ws.stream = s
            ws.stream.closing = None
            ws.terminate()
            self.assertTrue(ws.client_terminated)
            self.assertTrue(ws.server_terminated)
            self.assertTrue(ws.terminated)
            c.assert_called_once_with(1006, "Going away")
            cc.assert_called_once_with()
            self.assertIsNone(ws.stream)
            self.assertIsNone(ws.environ)
        
    def test_cannot_process_more_data_when_stream_is_terminated(self):
        m = MagicMock()
        ws = WebSocket(sock=m)
        ws.client_terminated = True
        ws.server_terminated = True

        self.assertFalse(ws.once())

    def test_socket_error_on_receiving_more_bytes(self):
        m = MagicMock()
        m.recv = MagicMock(side_effect=socket.error)
        ws = WebSocket(sock=m)
        self.assertFalse(ws.once())
        
    def test_no_bytes_were_read(self):
        m = MagicMock()
        m.recv.return_value = b''
        ws = WebSocket(sock=m)
        self.assertFalse(ws.once())

    def test_send_bytes_without_masking(self):
        tm = TextMessage(b'hello world').single()
        
        m = MagicMock()
        ws = WebSocket(sock=m)
        ws.send(b'hello world')
        m.sendall.assert_called_once_with(tm)
        
    def test_send_bytes_with_masking(self):
        tm = TextMessage(b'hello world').single(mask=True)
        
        m = MagicMock()
        ws = WebSocket(sock=m)
        ws.stream = MagicMock()
        ws.stream.always_mask = True
        ws.stream.text_message.return_value.single.return_value = tm
        
        ws.send(b'hello world')
        m.sendall.assert_called_once_with(tm)
        
    def test_send_message_without_masking(self):
        tm = TextMessage(b'hello world')
        
        m = MagicMock()
        ws = WebSocket(sock=m)
        ws.send(tm)
        m.sendall.assert_called_once_with(tm.single())
        
    def test_send_generator_without_masking(self):
        tm0 = b'hello'
        tm1 = b'world'
        
        def datasource():
            yield tm0
            yield tm1

        gen = datasource()
        
        m = MagicMock()
        ws = WebSocket(sock=m)
        ws.send(gen)
        self.assertEqual(m.sendall.call_count, 2)
        self.assertRaises(StopIteration, next, gen)
        
    def test_sending_unknown_datetype(self):
        m = MagicMock()
        ws = WebSocket(sock=m)
        self.assertRaises(ValueError, ws.send, 123)

    def test_closing_message_received(self):
        s = MagicMock()
        m = MagicMock()
        c = MagicMock()
        
        ws = WebSocket(sock=m)
        with patch.multiple(ws, close=c):
            ws.stream = s
            ws.stream.closing = CloseControlMessage(code=1000, reason='test closing')
            ws.process(b'unused for this test')
            c.assert_called_once_with(1000, b'test closing')
            

if __name__ == '__main__':
    suite = unittest.TestSuite()
    loader = unittest.TestLoader()
    for testcase in [WSWebSocketTest]:
        tests = loader.loadTestsFromTestCase(testcase)
        suite.addTests(tests)
    unittest.TextTestRunner(verbosity=2).run(suite)

########NEW FILE########
__FILENAME__ = async_websocket
# -*- coding: utf-8 -*-
__doc__ = """
WebSocket implementation that relies on two new Python
features:

* asyncio to provide the high-level interface above transports
* yield from to delegate to the reading stream whenever more
  bytes are required

You can use these implementations in that context
and benefit from those features whilst using ws4py.

Strictly speaking this module probably doesn't have to
be called async_websocket but it feels this will be its typical
usage and is probably more readable than
delegated_generator_websocket_on_top_of_asyncio.py
"""
import asyncio
import types

from ws4py.websocket import WebSocket as _WebSocket
from ws4py.messaging import Message

__all__ = ['WebSocket', 'EchoWebSocket']

class WebSocket(_WebSocket):
    def __init__(self, proto):
        """
        A :pep:`3156` ready websocket handler that works
        well in a coroutine-aware loop such as the one provided
        by the asyncio module.

        The provided `proto` instance is a
        :class:`asyncio.Protocol` subclass instance that will
        be used internally to read and write from the
        underlying transport.

        Because the base :class:`ws4py.websocket.WebSocket`
        class is still coupled a bit to the socket interface,
        we have to override a little more than necessary
        to play nice with the :pep:`3156` interface. Hopefully,
        some day this will be cleaned out.
        """
        _WebSocket.__init__(self, None)
        self.started = False
        self.proto = proto

    @property
    def local_address(self):
        """
        Local endpoint address as a tuple
        """
        if not self._local_address:
            self._local_address = self.proto.reader.transport.get_extra_info('sockname')
            if len(self._local_address) == 4:
                self._local_address = self._local_address[:2]
        return self._local_address

    @property
    def peer_address(self):
        """
        Peer endpoint address as a tuple
        """
        if not self._peer_address:
            self._peer_address = self.proto.reader.transport.get_extra_info('peername')
            if len(self._peer_address) == 4:
                self._peer_address = self._peer_address[:2]
        return self._peer_address

    def once(self):
        """
        The base class directly is used in conjunction with
        the :class:`ws4py.manager.WebSocketManager` which is
        not actually used with the asyncio implementation
        of ws4py. So let's make it clear it shan't be used.
        """
        raise NotImplemented()

    def close_connection(self):
        """
        Close the underlying transport
        """
        @asyncio.coroutine
        def closeit():
            yield from self.proto.writer.drain()
            self.proto.writer.close()
        asyncio.async(closeit())

    def _write(self, data):
        """
        Write to the underlying transport
        """
        @asyncio.coroutine
        def sendit(data):
            self.proto.writer.write(data)
            yield from self.proto.writer.drain()
        asyncio.async(sendit(data))

    @asyncio.coroutine
    def run(self):
        """
        Coroutine that runs until the websocket
        exchange is terminated. It also calls the
        `opened()` method to indicate the exchange
        has started.
        """
        self.started = True
        try:
            self.opened()
            reader = self.proto.reader
            while True:
                data = yield from reader.read(self.reading_buffer_size)
                if not self.process(data):
                    return False
        finally:
            self.terminate()

        return True

class EchoWebSocket(WebSocket):
    def received_message(self, message):
        """
        Automatically sends back the provided ``message`` to
        its originating endpoint.
        """
        self.send(message.data, message.is_binary)

########NEW FILE########
__FILENAME__ = geventclient
# -*- coding: utf-8 -*-
import copy

import gevent
from gevent import Greenlet
from gevent.queue import Queue

from ws4py.client import WebSocketBaseClient

__all__ = ['WebSocketClient']

class WebSocketClient(WebSocketBaseClient):
    def __init__(self, url, protocols=None, extensions=None, ssl_options=None, headers=None):
        """
        WebSocket client that executes the
        :meth:`run() <ws4py.websocket.WebSocket.run>` into a gevent greenlet.

        .. code-block:: python

          ws = WebSocketClient('ws://localhost:9000/echo', protocols=['http-only', 'chat'])
          ws.connect()

          ws.send("Hello world")

          def incoming():
            while True:
               m = ws.receive()
               if m is not None:
                  print str(m)
               else:
                  break

          def outgoing():
            for i in range(0, 40, 5):
               ws.send("*" * i)

          greenlets = [
             gevent.spawn(incoming),
             gevent.spawn(outgoing),
          ]
          gevent.joinall(greenlets)
        """
        WebSocketBaseClient.__init__(self, url, protocols, extensions,
                                     ssl_options=ssl_options, headers=headers)
        self._th = Greenlet(self.run)

        self.messages = Queue()
        """
        Queue that will hold received messages.
        """

    def handshake_ok(self):
        """
        Called when the upgrade handshake has completed
        successfully.

        Starts the client's thread.
        """
        self._th.start()

    def received_message(self, message):
        """
        Override the base class to store the incoming message
        in the `messages` queue.
        """
        self.messages.put(copy.deepcopy(message))

    def closed(self, code, reason=None):
        """
        Puts a :exc:`StopIteration` as a message into the
        `messages` queue.
        """
        # When the connection is closed, put a StopIteration
        # on the message queue to signal there's nothing left
        # to wait for
        self.messages.put(StopIteration)

    def receive(self):
        """
        Returns messages that were stored into the
        `messages` queue and returns `None` when the
        websocket is terminated or closed.
        """
        # If the websocket was terminated and there are no messages
        # left in the queue, return None immediately otherwise the client
        # will block forever
        if self.terminated and self.messages.empty():
            return None
        message = self.messages.get()
        if message is StopIteration:
            return None
        return message

########NEW FILE########
__FILENAME__ = threadedclient
# -*- coding: utf-8 -*-
import threading

from ws4py.client import WebSocketBaseClient

__all__ = ['WebSocketClient']

class WebSocketClient(WebSocketBaseClient):
    def __init__(self, url, protocols=None, extensions=None, heartbeat_freq=None,
                 ssl_options=None, headers=None):
        """
        .. code-block:: python

           from ws4py.client.threadedclient import WebSocketClient

           class EchoClient(WebSocketClient):
               def opened(self):
                  for i in range(0, 200, 25):
                     self.send("*" * i)

               def closed(self, code, reason):
                  print(("Closed down", code, reason))

               def received_message(self, m):
                  print("=> %d %s" % (len(m), str(m)))

           try:
               ws = EchoClient('ws://localhost:9000/echo', protocols=['http-only', 'chat'])
               ws.connect()
           except KeyboardInterrupt:
              ws.close()

        """
        WebSocketBaseClient.__init__(self, url, protocols, extensions, heartbeat_freq,
                                     ssl_options, headers=headers)
        self._th = threading.Thread(target=self.run, name='WebSocketClient')
        self._th.daemon = True

    @property
    def daemon(self):
        """
        `True` if the client's thread is set to be a daemon thread.
        """
        return self._th.daemon

    @daemon.setter
    def daemon(self, flag):
        """
        Set to `True` if the client's thread should be a daemon.
        """
        self._th.daemon = flag

    def run_forever(self):
        """
        Simply blocks the thread until the
        websocket has terminated.
        """
        while not self.terminated:
            self._th.join(timeout=0.1)

    def handshake_ok(self):
        """
        Called when the upgrade handshake has completed
        successfully.

        Starts the client's thread.
        """
        self._th.start()

if __name__ == '__main__':
    from ws4py.client.threadedclient import WebSocketClient

    class EchoClient(WebSocketClient):
        def opened(self):
            def data_provider():
                for i in range(0, 200, 25):
                    yield "#" * i

            self.send(data_provider())

            for i in range(0, 200, 25):
                self.send("*" * i)

        def closed(self, code, reason):
            print(("Closed down", code, reason))

        def received_message(self, m):
            print("#%d" % len(m))
            if len(m) == 175:
                self.close(reason='bye bye')

    try:
        ws = EchoClient('ws://localhost:9000/ws', protocols=['http-only', 'chat'],
                        headers=[('X-Test', 'hello there')])
        ws.connect()
        ws.run_forever()
    except KeyboardInterrupt:
        ws.close()

########NEW FILE########
__FILENAME__ = tornadoclient
# -*- coding: utf-8 -*-
import ssl

from tornado import iostream, escape
from ws4py.client import WebSocketBaseClient
from ws4py.exc import HandshakeError

__all__ = ['TornadoWebSocketClient']

class TornadoWebSocketClient(WebSocketBaseClient):
    def __init__(self, url, protocols=None, extensions=None,
                 io_loop=None, ssl_options=None, headers=None):
        """
        .. code-block:: python

            from tornado import ioloop

            class MyClient(TornadoWebSocketClient):
                def opened(self):
                    for i in range(0, 200, 25):
                        self.send("*" * i)

                def received_message(self, m):
                    print((m, len(str(m))))

                def closed(self, code, reason=None):
                    ioloop.IOLoop.instance().stop()

            ws = MyClient('ws://localhost:9000/echo', protocols=['http-only', 'chat'])
            ws.connect()

            ioloop.IOLoop.instance().start()
        """
        WebSocketBaseClient.__init__(self, url, protocols, extensions,
                                     ssl_options=ssl_options, headers=headers)
        self.ssl_options["do_handshake_on_connect"] = False
        if self.scheme == "wss":
            self.sock = ssl.wrap_socket(self.sock, **self.ssl_options)
            self.io = iostream.SSLIOStream(self.sock, io_loop)
        else:
            self.io = iostream.IOStream(self.sock, io_loop)
        self.io_loop = io_loop

    def connect(self):
        """
        Connects the websocket and initiate the upgrade handshake.
        """
        self.io.set_close_callback(self.__connection_refused)
        self.io.connect((self.host, int(self.port)), self.__send_handshake)

    def _write(self, b):
        """
        Trying to prevent a write operation
        on an already closed websocket stream.

        This cannot be bullet proof but hopefully
        will catch almost all use cases.
        """
        if self.terminated:
            raise RuntimeError("Cannot send on a terminated websocket")

        self.io.write(b)

    def __connection_refused(self, *args, **kwargs):
        self.server_terminated = True
        self.closed(1005, 'Connection refused')

    def __send_handshake(self):
        self.io.set_close_callback(self.__connection_closed)
        self.io.write(escape.utf8(self.handshake_request),
                      self.__handshake_sent)

    def __connection_closed(self, *args, **kwargs):
        self.server_terminated = True
        self.closed(1006, 'Connection closed during handshake')

    def __handshake_sent(self):
        self.io.read_until(b"\r\n\r\n", self.__handshake_completed)

    def __handshake_completed(self, data):
        self.io.set_close_callback(None)
        try:
            response_line, _, headers = data.partition(b'\r\n')
            self.process_response_line(response_line)
            protocols, extensions = self.process_handshake_header(headers)
        except HandshakeError:
            self.close_connection()
            raise

        self.opened()
        self.io.set_close_callback(self.__stream_closed)
        self.io.read_bytes(self.reading_buffer_size, self.__fetch_more)

    def __fetch_more(self, bytes):
        try:
            should_continue = self.process(bytes)
        except:
            should_continue = False

        if should_continue:
            self.io.read_bytes(self.reading_buffer_size, self.__fetch_more)
        else:
            self.__gracefully_terminate()

    def __gracefully_terminate(self):
        self.client_terminated = self.server_terminated = True

        try:
            if not self.stream.closing:
                self.closed(1006)
        finally:
            self.close_connection()

    def __stream_closed(self, *args, **kwargs):
        self.io.set_close_callback(None)
        code = 1006
        reason = None
        if self.stream.closing:
            code, reason = self.stream.closing.code, self.stream.closing.reason
        self.closed(code, reason)
        self.stream._cleanup()

    def close_connection(self):
        """
        Close the underlying connection
        """
        self.io.close()

if __name__ == '__main__':
    from tornado import ioloop

    class MyClient(TornadoWebSocketClient):
        def opened(self):
            def data_provider():
                for i in range(0, 200, 25):
                    yield "#" * i

            self.send(data_provider())

            for i in range(0, 200, 25):
                self.send("*" * i)

        def received_message(self, m):
            print("#%d" % len(m))
            if len(m) == 175:
                self.close()

        def closed(self, code, reason=None):
            ioloop.IOLoop.instance().stop()
            print(("Closed down", code, reason))

    ws = MyClient('ws://localhost:9000/ws', protocols=['http-only', 'chat'])
    ws.connect()

    ioloop.IOLoop.instance().start()

########NEW FILE########
__FILENAME__ = compat
# -*- coding: utf-8 -*-
__doc__ = """
This compatibility module is inspired by the one found
in CherryPy. It provides a common entry point for the various
functions and types that are used with ws4py but which
differ from Python 2.x to Python 3.x

There are likely better ways for some of them so feel
free to provide patches.

Note this has been tested against 2.7 and 3.3 only but
should hopefully work fine with other versions too.
"""
import sys

if sys.version_info >= (3, 0):
    py3k = True
    from urllib.parse import urlsplit
    range = range
    unicode = str
    basestring = (bytes, str)
    _ord = ord

    def get_connection(fileobj):
        return fileobj.raw._sock

    def detach_connection(fileobj):
        fileobj.detach()

    def ord(c):
        if isinstance(c, int):
            return c
        return _ord(c)
else:
    py3k = False
    from urlparse import urlsplit
    range = xrange
    unicode = unicode
    basestring = basestring
    ord = ord

    def get_connection(fileobj):
        return fileobj._sock

    def detach_connection(fileobj):
        fileobj._sock = None

########NEW FILE########
__FILENAME__ = exc
# -*- coding: utf-8 -*-

__all__ = ['WebSocketException', 'FrameTooLargeException', 'ProtocolException',
           'UnsupportedFrameTypeException', 'TextFrameEncodingException',
           'UnsupportedFrameTypeException', 'TextFrameEncodingException',
           'StreamClosed', 'HandshakeError', 'InvalidBytesError']

class WebSocketException(Exception): pass

class ProtocolException(WebSocketException): pass

class FrameTooLargeException(WebSocketException): pass

class UnsupportedFrameTypeException(WebSocketException): pass

class TextFrameEncodingException(WebSocketException): pass

class InvalidBytesError(WebSocketException): pass

class StreamClosed(Exception): pass

class HandshakeError(WebSocketException):
    def __init__(self, msg):
        self.msg = msg

    def __str__(self):
        return self.msg

########NEW FILE########
__FILENAME__ = framing
# -*- coding: utf-8 -*-
from struct import pack, unpack

from ws4py.exc import FrameTooLargeException, ProtocolException
from ws4py.compat import py3k, ord, range

# Frame opcodes defined in the spec.
OPCODE_CONTINUATION = 0x0
OPCODE_TEXT = 0x1
OPCODE_BINARY = 0x2
OPCODE_CLOSE = 0x8
OPCODE_PING = 0x9
OPCODE_PONG = 0xa

__all__ = ['Frame']

class Frame(object):
    def __init__(self, opcode=None, body=b'', masking_key=None, fin=0, rsv1=0, rsv2=0, rsv3=0):
        """
        Implements the framing protocol as defined by RFC 6455.

        .. code-block:: python
           :linenos:

           >>> test_mask = 'XXXXXX' # perhaps from os.urandom(4)
           >>> f = Frame(OPCODE_TEXT, 'hello world', masking_key=test_mask, fin=1)
           >>> bytes = f.build()
           >>> bytes.encode('hex')
           '818bbe04e66ad6618a06d1249105cc6882'
           >>> f = Frame()
           >>> f.parser.send(bytes[0])
           1
           >>> f.parser.send(bytes[1])
           4

        .. seealso:: Data Framing http://tools.ietf.org/html/rfc6455#section-5.2
        """
        if not isinstance(body, bytes):
            raise TypeError("The body must be properly encoded")

        self.opcode = opcode
        self.body = body
        self.masking_key = masking_key
        self.fin = fin
        self.rsv1 = rsv1
        self.rsv2 = rsv2
        self.rsv3 = rsv3
        self.payload_length = len(body)

        self._parser = None

    @property
    def parser(self):
        if self._parser is None:
            self._parser = self._parsing()
            # Python generators must be initialized once.
            next(self.parser)
        return self._parser

    def _cleanup(self):
        if self._parser:
            self._parser.close()
            self._parser = None

    def build(self):
        """
        Builds a frame from the instance's attributes and returns
        its bytes representation.
        """
        header = b''

        if self.fin > 0x1:
            raise ValueError('FIN bit parameter must be 0 or 1')

        if 0x3 <= self.opcode <= 0x7 or 0xB <= self.opcode:
            raise ValueError('Opcode cannot be a reserved opcode')

        ## +-+-+-+-+-------+
        ## |F|R|R|R| opcode|
        ## |I|S|S|S|  (4)  |
        ## |N|V|V|V|       |
        ## | |1|2|3|       |
        ## +-+-+-+-+-------+
        header = pack('!B', ((self.fin << 7)
                             | (self.rsv1 << 6)
                             | (self.rsv2 << 5)
                             | (self.rsv3 << 4)
                             | self.opcode))

        ##                 +-+-------------+-------------------------------+
        ##                 |M| Payload len |    Extended payload length    |
        ##                 |A|     (7)     |             (16/63)           |
        ##                 |S|             |   (if payload len==126/127)   |
        ##                 |K|             |                               |
        ## +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
        ## |     Extended payload length continued, if payload len == 127  |
        ## + - - - - - - - - - - - - - - - +-------------------------------+
        if self.masking_key: mask_bit = 1 << 7
        else: mask_bit = 0

        length = self.payload_length
        if length < 126:
            header += pack('!B', (mask_bit | length))
        elif length < (1 << 16):
            header += pack('!B', (mask_bit | 126)) + pack('!H', length)
        elif length < (1 << 63):
            header += pack('!B', (mask_bit | 127)) + pack('!Q', length)
        else:
            raise FrameTooLargeException()
        
        ## + - - - - - - - - - - - - - - - +-------------------------------+
        ## |                               |Masking-key, if MASK set to 1  |
        ## +-------------------------------+-------------------------------+
        ## | Masking-key (continued)       |          Payload Data         |
        ## +-------------------------------- - - - - - - - - - - - - - - - +
        ## :                     Payload Data continued ...                :
        ## + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
        ## |                     Payload Data continued ...                |
        ## +---------------------------------------------------------------+
        body = self.body
        if not self.masking_key:
            return bytes(header + body)

        return bytes(header + self.masking_key + self.mask(body))

    def _parsing(self):
        """
        Generator to parse bytes into a frame. Yields until
        enough bytes have been read or an error is met.
        """
        buf = b''
        some_bytes = b''

        # yield until we get the first header's byte
        while not some_bytes:
            some_bytes = (yield 1)

        first_byte = some_bytes[0] if isinstance(some_bytes, bytearray) else ord(some_bytes[0])
        # frame-fin = %x0 ; more frames of this message follow
        #           / %x1 ; final frame of this message
        self.fin = (first_byte >> 7) & 1
        self.rsv1 = (first_byte >> 6) & 1
        self.rsv2 = (first_byte >> 5) & 1
        self.rsv3 = (first_byte >> 4) & 1
        self.opcode = first_byte & 0xf

        # frame-rsv1 = %x0 ; 1 bit, MUST be 0 unless negotiated otherwise
        # frame-rsv2 = %x0 ; 1 bit, MUST be 0 unless negotiated otherwise
        # frame-rsv3 = %x0 ; 1 bit, MUST be 0 unless negotiated otherwise
        if self.rsv1 or self.rsv2 or self.rsv3:
            raise ProtocolException()

        # control frames between 3 and 7 as well as above 0xA are currently reserved
        if 2 < self.opcode < 8 or self.opcode > 0xA:
            raise ProtocolException()

        # control frames cannot be fragmented
        if self.opcode > 0x7 and self.fin == 0:
            raise ProtocolException()

        # do we already have enough some_bytes to continue?
        some_bytes = some_bytes[1:] if some_bytes and len(some_bytes) > 1 else b''

        # Yield until we get the second header's byte
        while not some_bytes:
            some_bytes = (yield 1)

        second_byte = some_bytes[0] if isinstance(some_bytes, bytearray) else ord(some_bytes[0])
        mask = (second_byte >> 7) & 1
        self.payload_length = second_byte & 0x7f

        # All control frames MUST have a payload length of 125 some_bytes or less
        if self.opcode > 0x7 and self.payload_length > 125:
            raise FrameTooLargeException()

        if some_bytes and len(some_bytes) > 1:
            buf = some_bytes[1:]
            some_bytes = buf
        else:
            buf = b''
            some_bytes = b''

        if self.payload_length == 127:
            # This will compute the actual application data size
            if len(buf) < 8:
                nxt_buf_size = 8 - len(buf)
                some_bytes = (yield nxt_buf_size)
                some_bytes = buf + (some_bytes or b'')
                while len(some_bytes) < 8:
                    b = (yield 8 - len(some_bytes))
                    if b is not None:
                        some_bytes = some_bytes + b
                if len(some_bytes) > 8:
                    buf = some_bytes[8:]
                    some_bytes = some_bytes[:8]
            else:
                some_bytes = buf[:8]
                buf = buf[8:]
            extended_payload_length = some_bytes
            self.payload_length = unpack(
                '!Q', extended_payload_length)[0]
            if self.payload_length > 0x7FFFFFFFFFFFFFFF:
                raise FrameTooLargeException()
        elif self.payload_length == 126:
            if len(buf) < 2:
                nxt_buf_size = 2 - len(buf)
                some_bytes = (yield nxt_buf_size)
                some_bytes = buf + (some_bytes or b'')
                while len(some_bytes) < 2:
                    b = (yield 2 - len(some_bytes))
                    if b is not None:
                        some_bytes = some_bytes + b
                if len(some_bytes) > 2:
                    buf = some_bytes[2:]
                    some_bytes = some_bytes[:2]
            else:
                some_bytes = buf[:2]
                buf = buf[2:]
            extended_payload_length = some_bytes
            self.payload_length = unpack(
                '!H', extended_payload_length)[0]

        if mask:
            if len(buf) < 4:
                nxt_buf_size = 4 - len(buf)
                some_bytes = (yield nxt_buf_size)
                some_bytes = buf + (some_bytes or b'')
                while not some_bytes or len(some_bytes) < 4:
                    b = (yield 4 - len(some_bytes))
                    if b is not None:
                        some_bytes = some_bytes + b
                if len(some_bytes) > 4:
                    buf = some_bytes[4:]
            else:
                some_bytes = buf[:4]
                buf = buf[4:]
            self.masking_key = some_bytes

        if len(buf) < self.payload_length:
            nxt_buf_size = self.payload_length - len(buf)
            some_bytes = (yield nxt_buf_size)
            some_bytes = buf + (some_bytes or b'')
            while len(some_bytes) < self.payload_length:
                l = self.payload_length - len(some_bytes)
                b = (yield l)
                if b is not None:
                    some_bytes = some_bytes + b
        else:
            if self.payload_length == len(buf):
                some_bytes = buf
            else:
                some_bytes = buf[:self.payload_length]

        self.body = some_bytes
        yield

    def mask(self, data):
        """
        Performs the masking or unmasking operation on data
        using the simple masking algorithm:

        ..
           j                   = i MOD 4
           transformed-octet-i = original-octet-i XOR masking-key-octet-j

        """
        masked = bytearray(data)
        if py3k: key = self.masking_key
        else: key = map(ord, self.masking_key)
        for i in range(len(data)):
            masked[i] = masked[i] ^ key[i%4]
        return masked
    unmask = mask

########NEW FILE########
__FILENAME__ = manager
# -*- coding: utf-8 -*-
__doc__ = """
The manager module provides a selected classes to
handle websocket's execution.

Initially the rationale was to:

- Externalize the way the CherryPy server had been setup
  as its websocket management was too tightly coupled with
  the plugin implementation.
- Offer a management that could be used by other
  server or client implementations.
- Move away from the threaded model to the event-based
  model by relying on `select` or `epoll` (when available).


A simple usage for handling websocket clients:

.. code-block:: python

    from ws4py.client import WebSocketBaseClient
    from ws4py.manager import WebSocketManager

    m = WebSocketManager()

    class EchoClient(WebSocketBaseClient):
        def handshake_ok(self):
            m.add(self)  # register the client once the handshake is done

        def received_message(self, msg):
            print str(msg)

    m.start()

    client = EchoClient('ws://localhost:9000/ws')
    client.connect()

    m.join()  # blocks forever

Managers are not compulsory but hopefully will help your
workflow. For clients, you can still rely on threaded, gevent or
tornado based implementations of course.
"""
import logging
import select
import threading
import time

from ws4py import format_addresses
from ws4py.compat import py3k

logger = logging.getLogger('ws4py')

class SelectPoller(object):
    def __init__(self, timeout=0.1):
        """
        A socket poller that uses the `select`
        implementation to determines which
        file descriptors have data available to read.

        It is available on all platforms.
        """
        self._fds = []
        self.timeout = timeout

    def release(self):
        """
        Cleanup resources.
        """
        self._fds = []

    def register(self, fd):
        """
        Register a new file descriptor to be
        part of the select polling next time around.
        """
        if fd not in self._fds:
            self._fds.append(fd)

    def unregister(self, fd):
        """
        Unregister the given file descriptor.
        """
        if fd in self._fds:
            self._fds.remove(fd)

    def poll(self):
        """
        Polls once and returns a list of
        ready-to-be-read file descriptors.
        """
        if not self._fds:
            time.sleep(self.timeout)
            return []

        r, w, x = select.select(self._fds, [], [], self.timeout)
        return r

class EPollPoller(object):
    def __init__(self, timeout=0.1):
        """
        An epoll poller that uses the ``epoll``
        implementation to determines which
        file descriptors have data available to read.

        Available on Unix flavors mostly.
        """
        self.poller = select.epoll()
        self.timeout = timeout

    def release(self):
        """
        Cleanup resources.
        """
        self.poller.close()

    def register(self, fd):
        """
        Register a new file descriptor to be
        part of the select polling next time around.
        """
        try:
            self.poller.register(fd, select.EPOLLIN | select.EPOLLPRI)
        except IOError:
            pass

    def unregister(self, fd):
        """
        Unregister the given file descriptor.
        """
        self.poller.unregister(fd)

    def poll(self):
        """
        Polls once and yields each ready-to-be-read
        file-descriptor
        """
        events = self.poller.poll(timeout=self.timeout)
        for fd, event in events:
            if event | select.EPOLLIN | select.EPOLLPRI:
                yield fd

class KQueuePoller(object):
    def __init__(self, timeout=0.1):
        """
        An epoll poller that uses the ``epoll``
        implementation to determines which
        file descriptors have data available to read.

        Available on Unix flavors mostly.
        """
        self.poller = select.epoll()
        self.timeout = timeout

    def release(self):
        """
        Cleanup resources.
        """
        self.poller.close()

    def register(self, fd):
        """
        Register a new file descriptor to be
        part of the select polling next time around.
        """
        try:
            self.poller.register(fd, select.EPOLLIN | select.EPOLLPRI)
        except IOError:
            pass

    def unregister(self, fd):
        """
        Unregister the given file descriptor.
        """
        self.poller.unregister(fd)

    def poll(self):
        """
        Polls once and yields each ready-to-be-read
        file-descriptor
        """
        events = self.poller.poll(timeout=self.timeout)
        for fd, event in events:
            if event | select.EPOLLIN | select.EPOLLPRI:
                yield fd

class WebSocketManager(threading.Thread):
    def __init__(self, poller=None):
        """
        An event-based websocket manager. By event-based, we mean
        that the websockets will be called when their
        sockets have data to be read from.

        The manager itself runs in its own thread as not to
        be the blocking mainloop of your application.

        The poller's implementation is automatically chosen
        with ``epoll`` if available else ``select`` unless you
        provide your own ``poller``.
        """
        threading.Thread.__init__(self)
        self.lock = threading.Lock()
        self.websockets = {}
        self.running = False

        if poller:
            self.poller = poller
        else:
            if hasattr(select, "epoll"):
                self.poller = EPollPoller()
                logger.info("Using epoll")
            else:
                self.poller = SelectPoller()
                logger.info("Using select as epoll is not available")

    def __len__(self):
        return len(self.websockets)

    def __iter__(self):
        if py3k:
            return iter(self.websockets.values())
        else:
            return self.websockets.itervalues()

    def __contains__(self, ws):
        fd = ws.sock.fileno()
        # just in case the file descriptor was reused
        # we actually check the instance (well, this might
        # also have been reused...)
        return self.websockets.get(fd) is ws

    def add(self, websocket):
        """
        Manage a new websocket.

        First calls its :meth:`opened() <ws4py.websocket.WebSocket.opened>`
        method and register its socket against the poller
        for reading events.
        """
        if websocket in self:
            return
        
        logger.info("Managing websocket %s" % format_addresses(websocket))
        websocket.opened()
        with self.lock:
            fd = websocket.sock.fileno()
            self.websockets[fd] = websocket
            self.poller.register(fd)

    def remove(self, websocket):
        """
        Remove the given ``websocket`` from the manager.

        This does not call its :meth:`closed() <ws4py.websocket.WebSocket.closed>`
        method as it's out-of-band by your application
        or from within the manager's run loop.
        """
        if websocket not in self:
            return
        
        logger.info("Removing websocket %s" % format_addresses(websocket))
        with self.lock:
            fd = websocket.sock.fileno()
            self.websockets.pop(fd, None)
            self.poller.unregister(fd)

    def stop(self):
        """
        Mark the manager as terminated and
        releases its resources.
        """
        self.running = False
        with self.lock:
            self.websockets.clear()
            self.poller.release()

    def run(self):
        """
        Manager's mainloop executed from within a thread.

        Constantly poll for read events and, when available,
        call related websockets' `once` method to
        read and process the incoming data.

        If the :meth:`once() <ws4py.websocket.WebSocket.once>`
        method returns a `False` value, its :meth:`terminate() <ws4py.websocket.WebSocket.terminate>`
        method is also applied to properly close
        the websocket and its socket is unregistered from the poller.

        Note that websocket shouldn't take long to process
        their data or they will block the remaining
        websockets with data to be handled. As for what long means,
        it's up to your requirements.
        """
        self.running = True
        while self.running:
            with self.lock:
                polled = self.poller.poll()

            if not self.running:
                break

            for fd in polled:
                if not self.running:
                    break
                
                ws = self.websockets.get(fd)
                
                if ws and not ws.terminated:
                    if not ws.once():
                        with self.lock:
                            fd = ws.sock.fileno()
                            self.websockets.pop(fd, None)
                            self.poller.unregister(fd)

                        if not ws.terminated:
                            logger.info("Terminating websocket %s" % format_addresses(ws))
                            ws.terminate()

    def close_all(self, code=1001, message='Server is shutting down'):
        """
        Execute the :meth:`close() <ws4py.websocket.WebSocket.close>`
        method of each registered websockets to initiate the closing handshake.
        It doesn't wait for the handshake to complete properly.
        """
        with self.lock:
            logger.info("Closing all websockets with [%d] '%s'" % (code, message))
            for ws in iter(self):
                ws.close(code=code, reason=message)

    def broadcast(self, message, binary=False):
        """
        Broadcasts the given message to all registered
        websockets, at the time of the call.

        Broadcast may fail on a given registered peer
        but this is silent as it's not the method's
        purpose to handle websocket's failures.
        """
        with self.lock:
            websockets = self.websockets.copy()
            if py3k:
                ws_iter = iter(websockets.values())
            else:
                ws_iter = websockets.itervalues()

        for ws in ws_iter:
            if not ws.terminated:
                try:
                    ws.send(message, binary)
                except:
                    pass

########NEW FILE########
__FILENAME__ = messaging
# -*- coding: utf-8 -*-
import os
import struct

from ws4py.framing import Frame, OPCODE_CONTINUATION, OPCODE_TEXT, \
     OPCODE_BINARY, OPCODE_CLOSE, OPCODE_PING, OPCODE_PONG
from ws4py.compat import unicode, py3k

__all__ = ['Message', 'TextMessage', 'BinaryMessage', 'CloseControlMessage',
           'PingControlMessage', 'PongControlMessage']

class Message(object):
    def __init__(self, opcode, data=b'', encoding='utf-8'):
        """
        A message is a application level entity. It's usually built
        from one or many frames. The protocol defines several kind
        of messages which are grouped into two sets:

        * data messages which can be text or binary typed
        * control messages which provide a mechanism to perform
          in-band control communication between peers

        The ``opcode`` indicates the message type and ``data`` is
        the possible message payload.

        The payload is held internally as a a :func:`bytearray` as they are
        faster than pure strings for append operations.

        Unicode data will be encoded using the provided ``encoding``.
        """
        self.opcode = opcode
        self._completed = False
        self.encoding = encoding

        if isinstance(data, unicode):
            if not encoding:
                raise TypeError("unicode data without an encoding")
            data = data.encode(encoding)
        elif isinstance(data, bytearray):
            data = bytes(data)
        elif not isinstance(data, bytes):
            raise TypeError("%s is not a supported data type" % type(data))

        self.data = data

    def single(self, mask=False):
        """
        Returns a frame bytes with the fin bit set and a random mask.

        If ``mask`` is set, automatically mask the frame
        using a generated 4-byte token.
        """
        mask = os.urandom(4) if mask else None
        return Frame(body=self.data, opcode=self.opcode,
                     masking_key=mask, fin=1).build()

    def fragment(self, first=False, last=False, mask=False):
        """
        Returns a :class:`ws4py.framing.Frame` bytes.

        The behavior depends on the given flags:

        * ``first``: the frame uses ``self.opcode`` else a continuation opcode
        * ``last``: the frame has its ``fin`` bit set
        * ``mask``: the frame is masked using a automatically generated 4-byte token
        """
        fin = 1 if last is True else 0
        opcode = self.opcode if first is True else OPCODE_CONTINUATION
        mask = os.urandom(4) if mask else None
        return Frame(body=self.data,
                     opcode=opcode, masking_key=mask,
                     fin=fin).build()

    @property
    def completed(self):
        """
        Indicates the the message is complete, meaning
        the frame's ``fin`` bit was set.
        """
        return self._completed

    @completed.setter
    def completed(self, state):
        """
        Sets the state for this message. Usually
        set by the stream's parser.
        """
        self._completed = state

    def extend(self, data):
        """
        Add more ``data`` to the message.
        """
        if isinstance(data, bytes):
            self.data += data
        elif isinstance(data, bytearray):
            self.data += bytes(data)
        elif isinstance(data, unicode):
            self.data += data.encode(self.encoding)
        else:
            raise TypeError("%s is not a supported data type" % type(data))

    def __len__(self):
        return len(self.__unicode__())

    def __str__(self):
        if py3k:
            return self.data.decode(self.encoding)
        return self.data

    def __unicode__(self):
        return self.data.decode(self.encoding)

class TextMessage(Message):
    def __init__(self, text=None):
        Message.__init__(self, OPCODE_TEXT, text)

    @property
    def is_binary(self):
        return False

    @property
    def is_text(self):
        return True

class BinaryMessage(Message):
    def __init__(self, bytes=None):
        Message.__init__(self, OPCODE_BINARY, bytes, encoding=None)

    @property
    def is_binary(self):
        return True

    @property
    def is_text(self):
        return False

    def __len__(self):
        return len(self.data)

class CloseControlMessage(Message):
    def __init__(self, code=1000, reason=''):
        data = b""
        if code:
            data += struct.pack("!H", code)
        if reason is not None:
            if isinstance(reason, unicode):
                reason = reason.encode('utf-8')
            data += reason

        Message.__init__(self, OPCODE_CLOSE, data, 'utf-8')
        self.code = code
        self.reason = reason

    def __str__(self):
        if py3k:
            return self.reason.decode('utf-8')
        return self.reason

    def __unicode__(self):
        return self.reason.decode(self.encoding)

class PingControlMessage(Message):
    def __init__(self, data=None):
        Message.__init__(self, OPCODE_PING, data)

class PongControlMessage(Message):
    def __init__(self, data):
        Message.__init__(self, OPCODE_PONG, data)

########NEW FILE########
__FILENAME__ = cherrypyserver
# -*- coding: utf-8 -*-
__doc__ = """
WebSocket within CherryPy is a tricky bit since CherryPy is
a threaded server which would choke quickly if each thread
of the server were kept attached to a long living connection
that WebSocket expects.

In order to work around this constraint, we take some advantage
of some internals of CherryPy as well as the introspection
Python provides.

Basically, when the WebSocket handshake is complete, we take over
the socket and let CherryPy take back the thread that was
associated with the upgrade request.

These operations require a bit of work at various levels of
the CherryPy framework but this module takes care of them
and from your application's perspective, this is abstracted.

Here are the various utilities provided by this module:

 * WebSocketTool: The tool is in charge to perform the
                  HTTP upgrade and detach the socket from
                  CherryPy. It runs at various hook points of the
                  request's processing. Enable that tool at
                  any path you wish to handle as a WebSocket
                  handler.

 * WebSocketPlugin: The plugin tracks the instanciated web socket handlers.
                    It also cleans out websocket handler which connection
                    have been closed down. The websocket connection then
                    runs in its own thread that this plugin manages.

Simple usage example:

.. code-block:: python
    :linenos:

    import cherrypy
    from ws4py.server.cherrypyserver import WebSocketPlugin, WebSocketTool
    from ws4py.websocket import EchoWebSocket

    cherrypy.config.update({'server.socket_port': 9000})
    WebSocketPlugin(cherrypy.engine).subscribe()
    cherrypy.tools.websocket = WebSocketTool()

    class Root(object):
        @cherrypy.expose
        def index(self):
            return 'some HTML with a websocket javascript connection'

        @cherrypy.expose
        def ws(self):
            pass

    cherrypy.quickstart(Root(), '/', config={'/ws': {'tools.websocket.on': True,
                                                     'tools.websocket.handler_cls': EchoWebSocket}})


Note that you can set the handler class on per-path basis,
meaning you could also dynamically change the class based
on other envrionmental settings (is the user authenticated for ex).
"""
import base64
from hashlib import sha1
import inspect
import threading

import cherrypy
from cherrypy import Tool
from cherrypy.process import plugins
from cherrypy.wsgiserver import HTTPConnection, HTTPRequest

from ws4py import WS_KEY, WS_VERSION
from ws4py.exc import HandshakeError
from ws4py.websocket import WebSocket
from ws4py.compat import py3k, get_connection, detach_connection
from ws4py.manager import WebSocketManager

__all__ = ['WebSocketTool', 'WebSocketPlugin']

class WebSocketTool(Tool):
    def __init__(self):
        Tool.__init__(self, 'before_request_body', self.upgrade)

    def _setup(self):
        conf = self._merged_args()
        hooks = cherrypy.serving.request.hooks
        p = conf.pop("priority", getattr(self.callable, "priority",
                                         self._priority))
        hooks.attach(self._point, self.callable, priority=p, **conf)
        hooks.attach('before_finalize', self.complete,
                     priority=p)
        hooks.attach('on_end_resource', self.cleanup_headers,
                     priority=70)
        hooks.attach('on_end_request', self.start_handler,
                     priority=70)

    def upgrade(self, protocols=None, extensions=None, version=WS_VERSION,
                handler_cls=WebSocket, heartbeat_freq=None):
        """
        Performs the upgrade of the connection to the WebSocket
        protocol.

        The provided protocols may be a list of WebSocket
        protocols supported by the instance of the tool.

        When no list is provided and no protocol is either
        during the upgrade, then the protocol parameter is
        not taken into account. On the other hand,
        if the protocol from the handshake isn't part
        of the provided list, the upgrade fails immediatly.
        """
        request = cherrypy.serving.request
        request.process_request_body = False

        ws_protocols = None
        ws_location = None
        ws_version = version
        ws_key = None
        ws_extensions = []

        if request.method != 'GET':
            raise HandshakeError('HTTP method must be a GET')

        for key, expected_value in [('Upgrade', 'websocket'),
                                     ('Connection', 'upgrade')]:
            actual_value = request.headers.get(key, '').lower()
            if not actual_value:
                raise HandshakeError('Header %s is not defined' % key)
            if expected_value not in actual_value:
                raise HandshakeError('Illegal value for header %s: %s' %
                                     (key, actual_value))

        version = request.headers.get('Sec-WebSocket-Version')
        supported_versions = ', '.join([str(v) for v in ws_version])
        version_is_valid = False
        if version:
            try: version = int(version)
            except: pass
            else: version_is_valid = version in ws_version

        if not version_is_valid:
            cherrypy.response.headers['Sec-WebSocket-Version'] = supported_versions
            raise HandshakeError('Unhandled or missing WebSocket version')

        key = request.headers.get('Sec-WebSocket-Key')
        if key:
            ws_key = base64.b64decode(key.encode('utf-8'))
            if len(ws_key) != 16:
                raise HandshakeError("WebSocket key's length is invalid")

        protocols = protocols or []
        subprotocols = request.headers.get('Sec-WebSocket-Protocol')
        if subprotocols:
            ws_protocols = []
            for s in subprotocols.split(','):
                s = s.strip()
                if s in protocols:
                    ws_protocols.append(s)

        exts = extensions or []
        extensions = request.headers.get('Sec-WebSocket-Extensions')
        if extensions:
            for ext in extensions.split(','):
                ext = ext.strip()
                if ext in exts:
                    ws_extensions.append(ext)

        location = []
        include_port = False
        if request.scheme == "https":
            location.append("wss://")
            include_port = request.local.port != 443
        else:
            location.append("ws://")
            include_port = request.local.port != 80
        location.append('localhost')
        if include_port:
            location.append(":%d" % request.local.port)
        location.append(request.path_info)
        if request.query_string != "":
            location.append("?%s" % request.query_string)
        ws_location = ''.join(location)

        response = cherrypy.serving.response
        response.stream = True
        response.status = '101 Switching Protocols'
        response.headers['Content-Type'] = 'text/plain'
        response.headers['Upgrade'] = 'websocket'
        response.headers['Connection'] = 'Upgrade'
        response.headers['Sec-WebSocket-Version'] = str(version)
        response.headers['Sec-WebSocket-Accept'] = base64.b64encode(sha1(key.encode('utf-8') + WS_KEY).digest())
        if ws_protocols:
            response.headers['Sec-WebSocket-Protocol'] = ', '.join(ws_protocols)
        if ws_extensions:
            response.headers['Sec-WebSocket-Extensions'] = ','.join(ws_extensions)

        addr = (request.remote.ip, request.remote.port)
        ws_conn = get_connection(request.rfile.rfile)
        request.ws_handler = handler_cls(ws_conn, ws_protocols, ws_extensions,
                                         request.wsgi_environ.copy(),
                                         heartbeat_freq=heartbeat_freq)

    def complete(self):
        """
        Sets some internal flags of CherryPy so that it
        doesn't close the socket down.
        """
        self._set_internal_flags()

    def cleanup_headers(self):
        """
        Some clients aren't that smart when it comes to
        headers lookup.
        """
        response = cherrypy.response
        if not response.header_list:
            return

        headers = response.header_list[:]
        for (k, v) in headers:
            if k[:7] == 'Sec-Web':
                response.header_list.remove((k, v))
                response.header_list.append((k.replace('Sec-Websocket', 'Sec-WebSocket'), v))

    def start_handler(self):
        """
        Runs at the end of the request processing by calling
        the opened method of the handler.
        """
        request = cherrypy.request
        if not hasattr(request, 'ws_handler'):
            return

        addr = (request.remote.ip, request.remote.port)
        ws_handler = request.ws_handler
        request.ws_handler = None
        delattr(request, 'ws_handler')

        # By doing this we detach the socket from
        # the CherryPy stack avoiding memory leaks
        detach_connection(request.rfile.rfile)

        cherrypy.engine.publish('handle-websocket', ws_handler, addr)

    def _set_internal_flags(self):
        """
        CherryPy has two internal flags that we are interested in
        to enable WebSocket within the server. They can't be set via
        a public API and considering I'd want to make this extension
        as compatible as possible whilst refraining in exposing more
        than should be within CherryPy, I prefer performing a bit
        of introspection to set those flags. Even by Python standards
        such introspection isn't the cleanest but it works well
        enough in this case.

        This also means that we do that only on WebSocket
        connections rather than globally and therefore we do not
        harm the rest of the HTTP server.
        """
        current = inspect.currentframe()
        while True:
            if not current:
                break
            _locals = current.f_locals
            if 'self' in _locals:
               if type(_locals['self']) == HTTPRequest:
                   _locals['self'].close_connection = True
               if type(_locals['self']) == HTTPConnection:
                   _locals['self'].linger = True
                   # HTTPConnection is more inner than
                   # HTTPRequest so we can leave once
                   # we're done here
                   return
            _locals = None
            current = current.f_back

class WebSocketPlugin(plugins.SimplePlugin):
    def __init__(self, bus):
        plugins.SimplePlugin.__init__(self, bus)
        self.manager = WebSocketManager()

    def start(self):
        self.bus.log("Starting WebSocket processing")
        self.bus.subscribe('stop', self.cleanup)
        self.bus.subscribe('handle-websocket', self.handle)
        self.bus.subscribe('websocket-broadcast', self.broadcast)
        self.manager.start()

    def stop(self):
        self.bus.log("Terminating WebSocket processing")
        self.bus.unsubscribe('stop', self.cleanup)
        self.bus.unsubscribe('handle-websocket', self.handle)
        self.bus.unsubscribe('websocket-broadcast', self.broadcast)

    def handle(self, ws_handler, peer_addr):
        """
        Tracks the provided handler.

        :param ws_handler: websocket handler instance
        :param peer_addr: remote peer address for tracing purpose
        """
        self.manager.add(ws_handler)

    def cleanup(self):
        """
        Terminate all connections and clear the pool. Executed when the engine stops.
        """
        self.manager.close_all()
        self.manager.stop()
        self.manager.join()

    def broadcast(self, message, binary=False):
        """
        Broadcasts a message to all connected clients known to
        the server.

        :param message: a message suitable to pass to the send() method
          of the connected handler.
        :param binary: whether or not the message is a binary one
        """
        self.manager.broadcast(message, binary)

if __name__ == '__main__':
    import random
    cherrypy.config.update({'server.socket_host': '127.0.0.1',
                            'server.socket_port': 9000})
    WebSocketPlugin(cherrypy.engine).subscribe()
    cherrypy.tools.websocket = WebSocketTool()

    class Root(object):
        @cherrypy.expose
        @cherrypy.tools.websocket(on=False)
        def ws(self):
            return """<html>
        <head>
          <script type='application/javascript' src='https://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js'> </script>
          <script type='application/javascript'>
            $(document).ready(function() {
              var ws = new WebSocket('ws://192.168.0.10:9000/');
              ws.onmessage = function (evt) {
                 $('#chat').val($('#chat').val() + evt.data + '\\n');
              };
              ws.onopen = function() {
                 ws.send("Hello there");
              };
              ws.onclose = function(evt) {
                $('#chat').val($('#chat').val() + 'Connection closed by server: ' + evt.code + ' \"' + evt.reason + '\"\\n');
              };
              $('#chatform').submit(function() {
                 ws.send('%(username)s: ' + $('#message').val());
                 $('#message').val("");
                 return false;
              });
            });
          </script>
        </head>
        <body>
        <form action='/echo' id='chatform' method='get'>
          <textarea id='chat' cols='35' rows='10'></textarea>
          <br />
          <label for='message'>%(username)s: </label><input type='text' id='message' />
          <input type='submit' value='Send' />
          </form>
        </body>
        </html>
        """ % {'username': "User%d" % random.randint(0, 100)}

        @cherrypy.expose
        def index(self):
            cherrypy.log("Handler created: %s" % repr(cherrypy.request.ws_handler))

    cherrypy.quickstart(Root(), '/', config={'/': {'tools.websocket.on': True,
                                                   'tools.websocket.handler_cls': EchoWebSocketHandler}})

########NEW FILE########
__FILENAME__ = geventserver
# -*- coding: utf-8 -*-
__doc__ = """
WSGI entities to support WebSocket from within gevent.

Its usage is rather simple:

.. code-block: python

    from gevent import monkey; monkey.patch_all()
    from ws4py.websocket import EchoWebSocket
    from ws4py.server.geventserver import WSGIServer
    from ws4py.server.wsgiutils import WebSocketWSGIApplication

    server = WSGIServer(('localhost', 9000), WebSocketWSGIApplication(handler_cls=EchoWebSocket))
    server.serve_forever()

"""
import logging
import sys

import gevent
from gevent.pywsgi import WSGIHandler, WSGIServer as _WSGIServer
from gevent.pool import Pool

from ws4py import format_addresses
from ws4py.server.wsgiutils import WebSocketWSGIApplication

logger = logging.getLogger('ws4py')

__all__ = ['WebSocketWSGIHandler', 'WSGIServer',
           'GEventWebSocketPool']

class WebSocketWSGIHandler(WSGIHandler):
    """
    A WSGI handler that will perform the :rfc:`6455`
    upgrade and handshake before calling the WSGI application.

    If the incoming request doesn't have a `'Upgrade'` header,
    the handler will simply fallback to the gevent builtin's handler
    and process it as per usual.
    """

    def run_application(self):
        upgrade_header = self.environ.get('HTTP_UPGRADE', '').lower()
        if upgrade_header:
            try:
                # Build and start the HTTP response
                self.environ['ws4py.socket'] = self.socket or self.environ['wsgi.input'].rfile._sock
                self.result = self.application(self.environ, self.start_response) or []
                self.process_result()
            except:
                raise
            else:
                del self.environ['ws4py.socket']
                self.socket = None
                self.rfile.close()

                ws = self.environ.pop('ws4py.websocket')
                if ws:
                    self.server.pool.track(ws)
        else:
            gevent.pywsgi.WSGIHandler.run_application(self)

class GEventWebSocketPool(Pool):
    """
    Simple pool of bound websockets.
    Internally it uses a gevent group to track
    the websockets. The server should call the ``clear``
    method to initiate the closing handshake when the
    server is shutdown.
    """

    def track(self, websocket):
        logger.info("Managing websocket %s" % format_addresses(websocket))
        return self.spawn(websocket.run)

    def clear(self):
        logger.info("Terminating server and all connected websockets")
        for greenlet in self:
            try:
                websocket = greenlet._run.im_self
                if websocket:
                    websocket.close(1001, 'Server is shutting down')
            except:
                pass
            finally:
                self.discard(greenlet)
                
class WSGIServer(_WSGIServer):
    handler_class = WebSocketWSGIHandler

    def __init__(self, *args, **kwargs):
        """
        WSGI server that simply tracks websockets
        and send them a proper closing handshake
        when the server terminates.

        Other than that, the server is the same
        as its :class:`gevent.pywsgi.WSGIServer`
        base.
        """
        _WSGIServer.__init__(self, *args, **kwargs)
        self.pool = GEventWebSocketPool()

    def stop(self, *args, **kwargs):
        self.pool.clear()
        _WSGIServer.stop(self, *args, **kwargs)

if __name__ == '__main__':
    import os

    from ws4py import configure_logger
    configure_logger()

    from ws4py.websocket import EchoWebSocket
    server = WSGIServer(('127.0.0.1', 9000),
                        WebSocketWSGIApplication(handler_cls=EchoWebSocket))
    server.serve_forever()

########NEW FILE########
__FILENAME__ = tulipserver
# -*- coding: utf-8 -*-
import base64
from hashlib import sha1
from email.parser import BytesHeaderParser
import io

import asyncio

from ws4py import WS_KEY, WS_VERSION
from ws4py.exc import HandshakeError
from ws4py.websocket import WebSocket

LF = b'\n'
CRLF = b'\r\n'
SPACE = b' '
EMPTY = b''

__all__ = ['WebSocketProtocol']

class WebSocketProtocol(asyncio.StreamReaderProtocol):
    def __init__(self, handler_cls):
        asyncio.StreamReaderProtocol.__init__(self, asyncio.StreamReader(),
                                              self._pseudo_connected)
        self.ws = handler_cls(self)

    def _pseudo_connected(self, reader, writer):
        pass
        
    def connection_made(self, transport):
        """
        A peer is now connected and we receive an instance
        of the underlying :class:`asyncio.Transport`.

        We :class:`asyncio.StreamReader` is created
        and the transport is associated before the
        initial HTTP handshake is undertaken.
        """
        #self.transport = transport
        #self.stream = asyncio.StreamReader()
        #self.stream.set_transport(transport)
        asyncio.StreamReaderProtocol.connection_made(self, transport)
        # Let make it concurrent for others to tag along
        f = asyncio.async(self.handle_initial_handshake())
        f.add_done_callback(self.terminated)

    @property
    def writer(self):
        return self._stream_writer
        
    @property
    def reader(self):
        return self._stream_reader
        
    def terminated(self, f):
        if f.done() and not f.cancelled():
            ex = f.exception()
            if ex:
                response = [b'HTTP/1.0 400 Bad Request']
                response.append(b'Content-Length: 0')
                response.append(b'Connection: close')
                response.append(b'')
                response.append(b'')
                self.writer.write(CRLF.join(response))
                self.ws.close_connection()

    def close(self):
        """
        Initiate the websocket closing handshake
        which will eventuall lead to the underlying
        transport.
        """
        self.ws.close()
        
    def timeout(self):
        self.ws.close_connection()
        if self.ws.started:
            self.ws.closed(1002, "Peer connection timed-out")
        
    def connection_lost(self, exc):
        """
        The peer connection is now, the closing
        handshake won't work so let's not even try.
        However let's make the websocket handler
        be aware of it by calling its `closed`
        method.
        """
        if exc is not None:
            self.ws.close_connection()
            if self.ws.started:
                self.ws.closed(1002, "Peer connection was lost")
            
    @asyncio.coroutine
    def handle_initial_handshake(self):
        """
        Performs the HTTP handshake described in :rfc:`6455`. Note that
        this implementation is really basic and it is strongly advised
        against using it in production. It would probably break for
        most clients. If you want a better support for HTTP, please
        use a more reliable HTTP server implemented using asyncio.
        """
        request_line = yield from self.next_line()
        method, uri, req_protocol = request_line.strip().split(SPACE, 2)
        
        # GET required
        if method.upper() != b'GET':
            raise HandshakeError('HTTP method must be a GET')
        
        headers = yield from self.read_headers()
        if req_protocol == b'HTTP/1.1' and 'Host' not in headers:
            raise ValueError("Missing host header")
        
        for key, expected_value in [('Upgrade', 'websocket'),
                                     ('Connection', 'upgrade')]:
            actual_value = headers.get(key, '').lower()
            if not actual_value:
                raise HandshakeError('Header %s is not defined' % str(key))
            if expected_value not in actual_value:
                raise HandshakeError('Illegal value for header %s: %s' %
                                     (key, actual_value))

        response_headers = {}

        ws_version = WS_VERSION
        version = headers.get('Sec-WebSocket-Version')
        supported_versions = ', '.join([str(v) for v in ws_version])
        version_is_valid = False
        if version:
            try: version = int(version)
            except: pass
            else: version_is_valid = version in ws_version

        if not version_is_valid:
            response_headers['Sec-WebSocket-Version'] = supported_versions
            raise HandshakeError('Unhandled or missing WebSocket version')

        key = headers.get('Sec-WebSocket-Key')
        if key:
            ws_key = base64.b64decode(key.encode('utf-8'))
            if len(ws_key) != 16:
                raise HandshakeError("WebSocket key's length is invalid")

        protocols = []
        ws_protocols = []
        subprotocols = headers.get('Sec-WebSocket-Protocol')
        if subprotocols:
            for s in subprotocols.split(','):
                s = s.strip()
                if s in protocols:
                    ws_protocols.append(s)

        exts = []
        ws_extensions = []
        extensions = headers.get('Sec-WebSocket-Extensions')
        if extensions:
            for ext in extensions.split(','):
                ext = ext.strip()
                if ext in exts:
                    ws_extensions.append(ext)

        response = [req_protocol + b' 101 Switching Protocols']
        response.append(b'Upgrade: websocket')
        response.append(b'Content-Type: text/plain')
        response.append(b'Content-Length: 0')
        response.append(b'Connection: Upgrade')
        response.append(b'Sec-WebSocket-Version:' + bytes(str(version), 'utf-8'))
        response.append(b'Sec-WebSocket-Accept:' + base64.b64encode(sha1(key.encode('utf-8') + WS_KEY).digest()))
        if ws_protocols:
            response.append(b'Sec-WebSocket-Protocol:' + b', '.join(ws_protocols))
        if ws_extensions:
            response.append(b'Sec-WebSocket-Extensions:' + b','.join(ws_extensions))
        response.append(b'')
        response.append(b'')
        self.writer.write(CRLF.join(response))
        yield from self.handle_websocket()

    @asyncio.coroutine
    def handle_websocket(self):
        """
        Starts the websocket process until the
        exchange is completed and terminated.
        """
        yield from self.ws.run()
        
    @asyncio.coroutine
    def read_headers(self):
        """
        Read all HTTP headers from the HTTP request
        and returns a dictionary of them.
        """
        headers = b''
        while True:
            line = yield from self.next_line()
            headers += line
            if line == CRLF:
                break
        return BytesHeaderParser().parsebytes(headers)
        
    @asyncio.coroutine
    def next_line(self):
        """
        Reads data until \r\n is met and then return all read
        bytes. 
        """
        line = yield from self.reader.readline()
        if not line.endswith(CRLF):
            raise ValueError("Missing mandatory trailing CRLF")
        return line
        
if __name__ == '__main__':
    from ws4py.async_websocket import EchoWebSocket
    
    loop = asyncio.get_event_loop()

    def start_server():
        proto_factory = lambda: WebSocketProtocol(EchoWebSocket)
        return loop.create_server(proto_factory, '', 9007)

    s = loop.run_until_complete(start_server())
    print('serving on', s.sockets[0].getsockname())
    loop.run_forever()

########NEW FILE########
__FILENAME__ = wsgirefserver
# -*- coding: utf-8 -*-
__doc__ = """
Add WebSocket support to the built-in WSGI server
provided by the :py:mod:`wsgiref`. This is clearly not
meant to be a production server so please consider this
only for testing purpose.

Mostly, this module overrides bits and pieces of
the built-in classes so that it supports the WebSocket
workflow.

.. code-block:: python

    from wsgiref.simple_server import make_server
    from ws4py.websocket import EchoWebSocket
    from ws4py.server.wsgirefserver import WSGIServer, WebSocketWSGIRequestHandler
    from ws4py.server.wsgiutils import WebSocketWSGIApplication

    server = make_server('', 9000, server_class=WSGIServer,
                         handler_class=WebSocketWSGIRequestHandler,
                         app=WebSocketWSGIApplication(handler_cls=EchoWebSocket))
    server.initialize_websockets_manager()
    server.serve_forever()

.. note::
   For some reason this server may fail against autobahntestsuite.
"""
import logging
import sys
from wsgiref.handlers import SimpleHandler
from wsgiref.simple_server import WSGIRequestHandler, WSGIServer as _WSGIServer
from wsgiref import util

util._hoppish = {}.__contains__

from ws4py.manager import WebSocketManager
from ws4py import format_addresses
from ws4py.server.wsgiutils import WebSocketWSGIApplication
from ws4py.compat import get_connection

__all__ = ['WebSocketWSGIHandler', 'WebSocketWSGIRequestHandler',
           'WSGIServer']

logger = logging.getLogger('ws4py')

class WebSocketWSGIHandler(SimpleHandler):
    def setup_environ(self):
        """
        Setup the environ dictionary and add the
        `'ws4py.socket'` key. Its associated value
        is the real socket underlying socket.
        """
        SimpleHandler.setup_environ(self)
        self.environ['ws4py.socket'] = get_connection(self.environ['wsgi.input'])
        self.http_version = self.environ['SERVER_PROTOCOL'].rsplit('/')[-1]

    def finish_response(self):
        """
        Completes the response and performs the following tasks:

        - Remove the `'ws4py.socket'` and `'ws4py.websocket'`
          environ keys.
        - Attach the returned websocket, if any, to the WSGI server
          using its ``link_websocket_to_server`` method.
        """
        ws = None
        if self.environ:
            self.environ.pop('ws4py.socket', None)
            ws = self.environ.pop('ws4py.websocket', None)

        try:
            SimpleHandler.finish_response(self)
        except:
            if ws:
                ws.close(1011, reason='Something broke')
            raise
        else:
            if ws:
                self.request_handler.server.link_websocket_to_server(ws)

class WebSocketWSGIRequestHandler(WSGIRequestHandler):
    def handle(self):
        """
        Unfortunately the base class forces us
        to override the whole method to actually provide our wsgi handler.
        """
        self.raw_requestline = self.rfile.readline()
        if not self.parse_request(): # An error code has been sent, just exit
            return

        # next line is where we'd have expect a configuration key somehow
        handler = WebSocketWSGIHandler(
            self.rfile, self.wfile, self.get_stderr(), self.get_environ()
        )
        handler.request_handler = self      # backpointer for logging
        handler.run(self.server.get_app())

class WSGIServer(_WSGIServer):
    def initialize_websockets_manager(self):
        """
        Call thos to start the underlying websockets
        manager. Make sure to call it once your server
        is created.
        """
        self.manager = WebSocketManager()
        self.manager.start()

    def shutdown_request(self, request):
        """
        The base class would close our socket
        if we didn't override it.
        """
        pass

    def link_websocket_to_server(self, ws):
        """
        Call this from your WSGI handler when a websocket
        has been created.
        """
        self.manager.add(ws)

    def server_close(self):
        """
        Properly initiate closing handshakes on
        all websockets when the WSGI server terminates.
        """
        if hasattr(self, 'manager'):
            self.manager.close_all()
            self.manager.stop()
            self.manager.join()
            delattr(self, 'manager')
        _WSGIServer.server_close(self)

if __name__ == '__main__':
    from ws4py import configure_logger
    configure_logger()

    from wsgiref.simple_server import make_server
    from ws4py.websocket import EchoWebSocket

    server = make_server('', 9000, server_class=WSGIServer,
                         handler_class=WebSocketWSGIRequestHandler,
                         app=WebSocketWSGIApplication(handler_cls=EchoWebSocket))
    server.initialize_websockets_manager()
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        server.server_close()

########NEW FILE########
__FILENAME__ = wsgiutils
# -*- coding: utf-8 -*-
__doc__ = """
This module provides a WSGI application suitable
for a WSGI server such as gevent or wsgiref for instance.

:pep:`333` couldn't foresee a protocol such as
WebSockets but luckily the way the initial
protocol upgrade was designed means that we can
fit the handshake in a WSGI flow.

The handshake validates the request against
some internal or user-provided values and
fails the request if the validation doesn't
complete.

On success, the provided WebSocket subclass
is instanciated and stored into the
`'ws4py.websocket'` environ key so that
the WSGI server can handle it.

The WSGI application returns an empty iterable
since there is little value to return some
content within the response to the handshake.

A server wishing to support WebSocket via ws4py
should:

- Provide the real socket object to ws4py through the
  `'ws4py.socket'` environ key. We can't use `'wsgi.input'`
  as it may be wrapper to the socket we wouldn't know
  how to extract the socket from.
- Look for the `'ws4py.websocket'` key in the environ
  when the application has returned and probably attach
  it to a :class:`ws4py.manager.WebSocketManager` instance
  so that the websocket runs its life.
- Remove the `'ws4py.websocket'` and `'ws4py.socket'`
  environ keys once the application has returned.
  No need for these keys to persist.
- Not close the underlying socket otherwise, well,
  your websocket will also shutdown.

.. warning::

  The WSGI application sets the `'Upgrade'` header response
  as specified by :rfc:`6455`. This is not tolerated by
  :pep:`333` since it's a hop-by-hop header.
  We expect most servers won't mind.
"""
import base64
from hashlib import sha1
import logging
import sys

from ws4py.websocket import WebSocket
from ws4py.exc import HandshakeError
from ws4py.compat import unicode, py3k
from ws4py import WS_VERSION, WS_KEY, format_addresses

logger = logging.getLogger('ws4py')

__all__ = ['WebSocketWSGIApplication']

class WebSocketWSGIApplication(object):
    def __init__(self, protocols=None, extensions=None, handler_cls=WebSocket):
        """
        WSGI application usable to complete the upgrade handshake
        by validating the requested protocols and extensions as
        well as the websocket version.

        If the upgrade validates, the `handler_cls` class
        is instanciated and stored inside the WSGI `environ`
        under the `'ws4py.websocket'` key to make it
        available to the WSGI handler.
        """
        self.protocols = protocols
        self.extensions = extensions
        self.handler_cls = handler_cls

    def make_websocket(self, sock, protocols, extensions, environ):
        """
        Initialize the `handler_cls` instance with the given
        negociated sets of protocols and extensions as well as
        the `environ` and `sock`.

        Stores then the instance in the `environ` dict
        under the `'ws4py.websocket'` key.
        """
        websocket = self.handler_cls(sock, protocols, extensions,
                                     environ.copy())
        environ['ws4py.websocket'] = websocket
        return websocket

    def __call__(self, environ, start_response):
        if environ.get('REQUEST_METHOD') != 'GET':
            raise HandshakeError('HTTP method must be a GET')

        for key, expected_value in [('HTTP_UPGRADE', 'websocket'),
                                    ('HTTP_CONNECTION', 'upgrade')]:
            actual_value = environ.get(key, '').lower()
            if not actual_value:
                raise HandshakeError('Header %s is not defined' % key)
            if expected_value not in actual_value:
                raise HandshakeError('Illegal value for header %s: %s' %
                                     (key, actual_value))

        key = environ.get('HTTP_SEC_WEBSOCKET_KEY')
        if key:
            ws_key = base64.b64decode(key.encode('utf-8'))
            if len(ws_key) != 16:
                raise HandshakeError("WebSocket key's length is invalid")

        version = environ.get('HTTP_SEC_WEBSOCKET_VERSION')
        supported_versions = b', '.join([unicode(v).encode('utf-8') for v in WS_VERSION])
        version_is_valid = False
        if version:
            try: version = int(version)
            except: pass
            else: version_is_valid = version in WS_VERSION

        if not version_is_valid:
            environ['websocket.version'] = unicode(version).encode('utf-8')
            raise HandshakeError('Unhandled or missing WebSocket version')

        ws_protocols = []
        protocols = self.protocols or []
        subprotocols = environ.get('HTTP_SEC_WEBSOCKET_PROTOCOL')
        if subprotocols:
            for s in subprotocols.split(','):
                s = s.strip()
                if s in protocols:
                    ws_protocols.append(s)

        ws_extensions = []
        exts = self.extensions or []
        extensions = environ.get('HTTP_SEC_WEBSOCKET_EXTENSIONS')
        if extensions:
            for ext in extensions.split(','):
                ext = ext.strip()
                if ext in exts:
                    ws_extensions.append(ext)

        accept_value = base64.b64encode(sha1(key.encode('utf-8') + WS_KEY).digest())
        if py3k: accept_value = accept_value.decode('utf-8')
        upgrade_headers = [
            ('Upgrade', 'websocket'),
            ('Connection', 'Upgrade'),
            ('Sec-WebSocket-Version', '%s' % version),
            ('Sec-WebSocket-Accept', accept_value),
            ]
        if ws_protocols:
            upgrade_headers.append(('Sec-WebSocket-Protocol', ', '.join(ws_protocols)))
        if ws_extensions:
            upgrade_headers.append(('Sec-WebSocket-Extensions', ','.join(ws_extensions)))

        start_response("101 Switching Protocols", upgrade_headers)

        self.make_websocket(environ['ws4py.socket'],
                            ws_protocols,
                            ws_extensions,
                            environ)

        return []

########NEW FILE########
__FILENAME__ = streaming
# -*- coding: utf-8 -*-
import struct
from struct import unpack

from ws4py.utf8validator import Utf8Validator
from ws4py.messaging import TextMessage, BinaryMessage, CloseControlMessage,\
     PingControlMessage, PongControlMessage
from ws4py.framing import Frame, OPCODE_CONTINUATION, OPCODE_TEXT, \
     OPCODE_BINARY, OPCODE_CLOSE, OPCODE_PING, OPCODE_PONG
from ws4py.exc import FrameTooLargeException, ProtocolException, InvalidBytesError,\
     TextFrameEncodingException, UnsupportedFrameTypeException, StreamClosed
from ws4py.compat import py3k

VALID_CLOSING_CODES = [1000, 1001, 1002, 1003, 1007, 1008, 1009, 1010, 1011]

class Stream(object):
    def __init__(self, always_mask=False, expect_masking=True):
        """ Represents a websocket stream of bytes flowing in and out.

        The stream doesn't know about the data provider itself and
        doesn't even know about sockets. Instead the stream simply
        yields for more bytes whenever it requires them. The stream owner
        is responsible to provide the stream with those bytes until
        a frame can be interpreted.

        .. code-block:: python
           :linenos:

           >>> s = Stream()
           >>> s.parser.send(BYTES)
           >>> s.has_messages
           False
           >>> s.parser.send(MORE_BYTES)
           >>> s.has_messages
           True
           >>> s.message
           <TextMessage ... >

        Set ``always_mask`` to mask all frames built.

        Set ``expect_masking`` to indicate masking will be
        checked on all parsed frames.
        """

        self.message = None
        """
        Parsed test or binary messages. Whenever the parser
        reads more bytes from a fragment message, those bytes
        are appended to the most recent message.
        """

        self.pings = []
        """
        Parsed ping control messages. They are instances of
        :class:`ws4py.messaging.PingControlMessage`
        """

        self.pongs = []
        """
        Parsed pong control messages. They are instances of
        :class:`ws4py.messaging.PongControlMessage`
        """

        self.closing = None
        """
        Parsed close control messsage. Instance of
        :class:`ws4py.messaging.CloseControlMessage`
        """

        self.errors = []
        """
        Detected errors while parsing. Instances of
        :class:`ws4py.messaging.CloseControlMessage`
        """

        self._parser = None
        """
        Parser in charge to process bytes it is fed with.
        """

        self.always_mask = always_mask
        self.expect_masking = expect_masking

    @property
    def parser(self):
        if self._parser is None:
            self._parser = self.receiver()
            # Python generators must be initialized once.
            next(self.parser)
        return self._parser

    def _cleanup(self):
        """
        Frees the stream's resources rendering it unusable.
        """
        self.message = None
        if self._parser is not None:
            if not self._parser.gi_running:
                self._parser.close()
            self._parser = None
        self.errors = None
        self.pings = None
        self.pongs = None
        self.closing = None

    def text_message(self, text):
        """
        Returns a :class:`ws4py.messaging.TextMessage` instance
        ready to be built. Convenience method so
        that the caller doesn't need to import the
        :class:`ws4py.messaging.TextMessage` class itself.
        """
        return TextMessage(text=text)

    def binary_message(self, bytes):
        """
        Returns a :class:`ws4py.messaging.BinaryMessage` instance
        ready to be built. Convenience method so
        that the caller doesn't need to import the
        :class:`ws4py.messaging.BinaryMessage` class itself.
        """
        return BinaryMessage(bytes)

    @property
    def has_message(self):
        """
        Checks if the stream has received any message
        which, if fragmented, is now completed.
        """
        if self.message is not None:
            return self.message.completed

        return False

    def close(self, code=1000, reason=''):
        """
        Returns a close control message built from
        a :class:`ws4py.messaging.CloseControlMessage` instance,
        using the given status ``code`` and ``reason`` message.
        """
        return CloseControlMessage(code=code, reason=reason)

    def ping(self, data=''):
        """
        Returns a ping control message built from
        a :class:`ws4py.messaging.PingControlMessage` instance.
        """
        return PingControlMessage(data).single(mask=self.always_mask)

    def pong(self, data=''):
        """
        Returns a ping control message built from
        a :class:`ws4py.messaging.PongControlMessage` instance.
        """
        return PongControlMessage(data).single(mask=self.always_mask)

    def receiver(self):
        """
        Parser that keeps trying to interpret bytes it is fed with as
        incoming frames part of a message.

        Control message are single frames only while data messages, like text
        and binary, may be fragmented accross frames.

        The way it works is by instanciating a :class:`wspy.framing.Frame` object,
        then running its parser generator which yields how much bytes
        it requires to performs its task. The stream parser yields this value
        to its caller and feeds the frame parser.

        When the frame parser raises :exc:`StopIteration`, the stream parser
        tries to make sense of the parsed frame. It dispatches the frame's bytes
        to the most appropriate message type based on the frame's opcode.

        Overall this makes the stream parser totally agonstic to
        the data provider.
        """
        utf8validator = Utf8Validator()
        running = True
        frame = None
        while running:
            frame = Frame()
            while 1:
                try:
                    some_bytes = (yield next(frame.parser))
                    frame.parser.send(some_bytes)
                except GeneratorExit:
                    running = False
                    break
                except StopIteration:
                    frame._cleanup()
                    some_bytes = frame.body

                    # Let's avoid unmasking when there is no payload
                    if some_bytes:
                        if frame.masking_key and self.expect_masking:
                            some_bytes = frame.unmask(some_bytes)
                        elif not frame.masking_key and self.expect_masking:
                            msg = CloseControlMessage(code=1002, reason='Missing masking when expected')
                            self.errors.append(msg)
                            break
                        elif frame.masking_key and not self.expect_masking:
                            msg = CloseControlMessage(code=1002, reason='Masked when not expected')
                            self.errors.append(msg)
                            break
                        else:
                            # If we reach this stage, it's because
                            # the frame wasn't masked and we didn't expect
                            # it anyway. Therefore, on py2k, the bytes
                            # are actually a str object and can't be used
                            # in the utf8 validator as we need integers
                            # when we get each byte one by one.
                            # Our only solution here is to convert our
                            # string to a bytearray.
                            some_bytes = bytearray(some_bytes)

                    if frame.opcode == OPCODE_TEXT:
                        if self.message and not self.message.completed:
                            # We got a text frame before we completed the previous one
                            msg = CloseControlMessage(code=1002, reason='Received a new message before completing previous')
                            self.errors.append(msg)
                            break

                        m = TextMessage(some_bytes)
                        m.completed = (frame.fin == 1)
                        self.message = m

                        if some_bytes:
                            is_valid, end_on_code_point, _, _ = utf8validator.validate(some_bytes)

                            if not is_valid or (m.completed and not end_on_code_point):
                                self.errors.append(CloseControlMessage(code=1007, reason='Invalid UTF-8 bytes'))
                                break

                    elif frame.opcode == OPCODE_BINARY:
                        if self.message and not self.message.completed:
                            # We got a text frame before we completed the previous one
                            msg = CloseControlMessage(code=1002, reason='Received a new message before completing previous')
                            self.errors.append(msg)
                            break

                        m = BinaryMessage(some_bytes)
                        m.completed = (frame.fin == 1)
                        self.message = m

                    elif frame.opcode == OPCODE_CONTINUATION:
                        m = self.message
                        if m is None:
                            self.errors.append(CloseControlMessage(code=1002, reason='Message not started yet'))
                            break

                        m.extend(some_bytes)
                        m.completed = (frame.fin == 1)
                        if m.opcode == OPCODE_TEXT:
                            if some_bytes:
                                is_valid, end_on_code_point, _, _ = utf8validator.validate(some_bytes)

                                if not is_valid or (m.completed and not end_on_code_point):
                                    self.errors.append(CloseControlMessage(code=1007, reason='Invalid UTF-8 bytes'))
                                    break

                    elif frame.opcode == OPCODE_CLOSE:
                        code = 1000
                        reason = ""
                        if frame.payload_length == 0:
                            self.closing = CloseControlMessage(code=1000)
                        elif frame.payload_length == 1:
                            self.closing = CloseControlMessage(code=1002, reason='Payload has invalid length')
                        else:
                            try:
                                # at this stage, some_bytes have been unmasked
                                # so actually are held in a bytearray
                                code = int(unpack("!H", bytes(some_bytes[0:2]))[0])
                            except struct.error:
                                code = 1002
                                reason = 'Failed at decoding closing code'
                            else:
                                # Those codes are reserved or plainly forbidden
                                if code not in VALID_CLOSING_CODES and not (2999 < code < 5000):
                                    reason = 'Invalid Closing Frame Code: %d' % code
                                    code = 1002
                                elif frame.payload_length > 1:
                                    reason = some_bytes[2:] if frame.masking_key else frame.body[2:]

                                    if not py3k: reason = bytearray(reason)
                                    is_valid, end_on_code_point, _, _ = utf8validator.validate(reason)
                                    if not is_valid or not end_on_code_point:
                                        self.errors.append(CloseControlMessage(code=1007, reason='Invalid UTF-8 bytes'))
                                        break
                                    reason = bytes(reason)
                            self.closing = CloseControlMessage(code=code, reason=reason)

                    elif frame.opcode == OPCODE_PING:
                        self.pings.append(PingControlMessage(some_bytes))

                    elif frame.opcode == OPCODE_PONG:
                        self.pongs.append(PongControlMessage(some_bytes))

                    else:
                        self.errors.append(CloseControlMessage(code=1003))

                    break

                except ProtocolException:
                    self.errors.append(CloseControlMessage(code=1002))
                    break
                except FrameTooLargeException:
                    self.errors.append(CloseControlMessage(code=1002, reason="Frame was too large"))
                    break

            frame._cleanup()
            frame.body = None
            frame = None

            if self.message is not None and self.message.completed:
                utf8validator.reset()

        utf8validator.reset()
        utf8validator = None

        self._cleanup()

########NEW FILE########
__FILENAME__ = utf8validator
# coding=utf-8

###############################################################################
##
##  Copyright 2011 Tavendo GmbH
##
##  Note:
##
##  This code is a Python implementation of the algorithm
##
##            "Flexible and Economical UTF-8 Decoder"
##
##  by Bjoern Hoehrmann
##
##       bjoern@hoehrmann.de
##       http://bjoern.hoehrmann.de/utf-8/decoder/dfa/
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
###############################################################################


class Utf8Validator(object):
    """
    Incremental UTF-8 validator with constant memory consumption (minimal state).

    Implements the algorithm "Flexible and Economical UTF-8 Decoder" by
    Bjoern Hoehrmann (http://bjoern.hoehrmann.de/utf-8/decoder/dfa/).
    """

    ## DFA transitions
    UTF8VALIDATOR_DFA = [
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, # 00..1f
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, # 20..3f
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, # 40..5f
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, # 60..7f
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, # 80..9f
        7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, # a0..bf
        8,8,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, # c0..df
        0xa,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x4,0x3,0x3, # e0..ef
        0xb,0x6,0x6,0x6,0x5,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8, # f0..ff
        0x0,0x1,0x2,0x3,0x5,0x8,0x7,0x1,0x1,0x1,0x4,0x6,0x1,0x1,0x1,0x1, # s0..s0
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1, # s1..s2
        1,2,1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1, # s3..s4
        1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,3,1,1,1,1,1,1, # s5..s6
        1,3,1,1,1,1,1,3,1,3,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1, # s7..s8
    ]

    UTF8_ACCEPT = 0
    UTF8_REJECT = 1

    def __init__(self):
        self.reset()

    def decode(self, b):
        """
        Eat one UTF-8 octet, and validate on the fly.

        Returns UTF8_ACCEPT when enough octets have been consumed, in which case
        self.codepoint contains the decoded Unicode code point.

        Returns UTF8_REJECT when invalid UTF-8 was encountered.

        Returns some other positive integer when more octets need to be eaten.
        """
        type = Utf8Validator.UTF8VALIDATOR_DFA[b]
        if self.state != Utf8Validator.UTF8_ACCEPT:
            self.codepoint = (b & 0x3f) | (self.codepoint << 6)
        else:
            self.codepoint = (0xff >> type) & b
        self.state = Utf8Validator.UTF8VALIDATOR_DFA[256 + self.state * 16 + type]
        return self.state

    def reset(self):
        """
        Reset validator to start new incremental UTF-8 decode/validation.
        """
        self.state = Utf8Validator.UTF8_ACCEPT
        self.codepoint = 0
        self.i = 0

    def validate(self, ba):
        """
        Incrementally validate a chunk of bytes provided as bytearray.

        Will return a quad (valid?, endsOnCodePoint?, currentIndex, totalIndex).

        As soon as an octet is encountered which renders the octet sequence
        invalid, a quad with valid? == False is returned. currentIndex returns
        the index within the currently consumed chunk, and totalIndex the
        index within the total consumed sequence that was the point of bail out.
        When valid? == True, currentIndex will be len(ba) and totalIndex the
        total amount of consumed bytes.
        """
        state = self.state
        DFA = Utf8Validator.UTF8VALIDATOR_DFA
        i = 0  # make sure 'i' is set if when 'ba' is empty
        for i, b in enumerate(ba):
            ## optimized version of decode(), since we are not interested in actual code points
            state = DFA[256 + (state << 4) + DFA[b]]
            if state == Utf8Validator.UTF8_REJECT:
                self.i += i
                self.state = state
                return False, False, i, self.i
        self.i += i
        self.state = state
        return True, state == Utf8Validator.UTF8_ACCEPT, i, self.i

########NEW FILE########
__FILENAME__ = websocket
# -*- coding: utf-8 -*-
import logging
import socket
import time
import threading
import types

from ws4py import WS_KEY, WS_VERSION
from ws4py.exc import HandshakeError, StreamClosed
from ws4py.streaming import Stream
from ws4py.messaging import Message, PongControlMessage
from ws4py.compat import basestring, unicode

DEFAULT_READING_SIZE = 2

logger = logging.getLogger('ws4py')

__all__ = ['WebSocket', 'EchoWebSocket', 'Heartbeat']

class Heartbeat(threading.Thread):
    def __init__(self, websocket, frequency=2.0):
        """
        Runs at a periodic interval specified by
        `frequency` by sending an unsolicitated pong
        message to the connected peer.

        If the message fails to be sent and a socket
        error is raised, we close the websocket
        socket automatically, triggering the `closed`
        handler.
        """
        threading.Thread.__init__(self)
        self.websocket = websocket
        self.frequency = frequency

    def __enter__(self):
        if self.frequency:
            self.start()
        return self

    def __exit__(self, exc_type, exc_value, exc_tb):
        self.stop()

    def stop(self):
        self.running = False

    def run(self):
        self.running = True
        while self.running:
            time.sleep(self.frequency)
            if self.websocket.terminated:
                break

            try:
                self.websocket.send(PongControlMessage(data='beep'))
            except socket.error:
                logger.info("Heartbeat failed")
                self.websocket.server_terminated = True
                self.websocket.close_connection()
                break

class WebSocket(object):
    """ Represents a websocket endpoint and provides a high level interface to drive the endpoint. """

    def __init__(self, sock, protocols=None, extensions=None, environ=None, heartbeat_freq=None):
        """ The ``sock`` is an opened connection
        resulting from the websocket handshake.

        If ``protocols`` is provided, it is a list of protocols
        negotiated during the handshake as is ``extensions``.

        If ``environ`` is provided, it is a copy of the WSGI environ
        dictionnary from the underlying WSGI server.
        """

        self.stream = Stream(always_mask=False)
        """
        Underlying websocket stream that performs the websocket
        parsing to high level objects. By default this stream
        never masks its messages. Clients using this class should
        set the ``stream.always_mask`` fields to ``True``
        and ``stream.expect_masking`` fields to ``False``.
        """

        self.protocols = protocols
        """
        List of protocols supported by this endpoint.
        Unused for now.
        """

        self.extensions = extensions
        """
        List of extensions supported by this endpoint.
        Unused for now.
        """

        self.sock = sock
        """
        Underlying connection.
        """

        self.client_terminated = False
        """
        Indicates if the client has been marked as terminated.
        """

        self.server_terminated = False
        """
        Indicates if the server has been marked as terminated.
        """

        self.reading_buffer_size = DEFAULT_READING_SIZE
        """
        Current connection reading buffer size.
        """

        self.environ = environ
        """
        WSGI environ dictionary.
        """

        self.heartbeat_freq = heartbeat_freq
        """
        At which interval the heartbeat will be running.
        Set this to `0` or `None` to disable it entirely.
        """

        self._local_address = None
        self._peer_address = None

    @property
    def local_address(self):
        """
        Local endpoint address as a tuple
        """
        if not self._local_address:
            self._local_address = self.sock.getsockname()
            if len(self._local_address) == 4:
                self._local_address = self._local_address[:2]
        return self._local_address

    @property
    def peer_address(self):
        """
        Peer endpoint address as a tuple
        """
        if not self._peer_address:
            self._peer_address = self.sock.getpeername()
            if len(self._peer_address) == 4:
                self._peer_address = self._peer_address[:2]
        return self._peer_address

    def opened(self):
        """
        Called by the server when the upgrade handshake
        has succeeeded.
        """
        pass

    def close(self, code=1000, reason=''):
        """
        Call this method to initiate the websocket connection
        closing by sending a close frame to the connected peer.
        The ``code`` is the status code representing the
        termination's reason.

        Once this method is called, the ``server_terminated``
        attribute is set. Calling this method several times is
        safe as the closing frame will be sent only the first
        time.

        .. seealso:: Defined Status Codes http://tools.ietf.org/html/rfc6455#section-7.4.1
        """
        if not self.server_terminated:
            self.server_terminated = True
            self._write(self.stream.close(code=code, reason=reason).single(mask=self.stream.always_mask))

    def closed(self, code, reason=None):
        """
        Called  when the websocket stream and connection are finally closed.
        The provided ``code`` is status set by the other point and
        ``reason`` is a human readable message.

        .. seealso:: Defined Status Codes http://tools.ietf.org/html/rfc6455#section-7.4.1
        """
        pass

    @property
    def terminated(self):
        """
        Returns ``True`` if both the client and server have been
        marked as terminated.
        """
        return self.client_terminated is True and self.server_terminated is True

    @property
    def connection(self):
        return self.sock

    def close_connection(self):
        """
        Shutdowns then closes the underlying connection.
        """
        if self.sock:
            try:
                self.sock.shutdown(socket.SHUT_RDWR)
                self.sock.close()
            except:
                pass
            finally:
                self.sock = None

    def ponged(self, pong):
        """
        Pong message, as a :class:`messaging.PongControlMessage` instance,
        received on the stream.
        """
        pass

    def received_message(self, message):
        """
        Called whenever a complete ``message``, binary or text,
        is received and ready for application's processing.

        The passed message is an instance of :class:`messaging.TextMessage`
        or :class:`messaging.BinaryMessage`.

        .. note:: You should override this method in your subclass.
        """
        pass

    def _write(self, b):
        """
        Trying to prevent a write operation
        on an already closed websocket stream.

        This cannot be bullet proof but hopefully
        will catch almost all use cases.
        """
        if self.terminated or self.sock is None:
            raise RuntimeError("Cannot send on a terminated websocket")

        self.sock.sendall(b)

    def send(self, payload, binary=False):
        """
        Sends the given ``payload`` out.

        If ``payload`` is some bytes or a bytearray,
        then it is sent as a single message not fragmented.

        If ``payload`` is a generator, each chunk is sent as part of
        fragmented message.

        If ``binary`` is set, handles the payload as a binary message.
        """
        message_sender = self.stream.binary_message if binary else self.stream.text_message

        if isinstance(payload, basestring) or isinstance(payload, bytearray):
            m = message_sender(payload).single(mask=self.stream.always_mask)
            self._write(m)

        elif isinstance(payload, Message):
            data = payload.single(mask=self.stream.always_mask)
            self._write(data)

        elif type(payload) == types.GeneratorType:
            bytes = next(payload)
            first = True
            for chunk in payload:
                self._write(message_sender(bytes).fragment(first=first, mask=self.stream.always_mask))
                bytes = chunk
                first = False

            self._write(message_sender(bytes).fragment(last=True, mask=self.stream.always_mask))

        else:
            raise ValueError("Unsupported type '%s' passed to send()" % type(payload))

    def once(self):
        """
        Performs the operation of reading from the underlying
        connection in order to feed the stream of bytes.

        We start with a small size of two bytes to be read
        from the connection so that we can quickly parse an
        incoming frame header. Then the stream indicates
        whatever size must be read from the connection since
        it knows the frame payload length.

        It returns `False` if an error occurred at the
        socket level or during the bytes processing. Otherwise,
        it returns `True`.
        """
        if self.terminated:
            logger.debug("WebSocket is already terminated")
            return False

        try:
            b = self.sock.recv(self.reading_buffer_size)
        except socket.error:
            logger.exception("Failed to receive data")
            return False
        else:
            if not self.process(b):
                return False

        return True

    def terminate(self):
        """
        Completes the websocket by calling the `closed`
        method either using the received closing code
        and reason, or when none was received, using
        the special `1006` code.

        Finally close the underlying connection for
        good and cleanup resources by unsetting
        the `environ` and `stream` attributes.
        """
        s = self.stream

        self.client_terminated = self.server_terminated = True

        try:
            if not s.closing:
                self.closed(1006, "Going away")
            else:
                self.closed(s.closing.code, s.closing.reason)
        finally:
            self.close_connection()

            # Cleaning up resources
            s._cleanup()
            self.stream = None
            self.environ = None

    def process(self, bytes):
        """ Takes some bytes and process them through the
        internal stream's parser. If a message of any kind is
        found, performs one of these actions:

        * A closing message will initiate the closing handshake
        * Errors will initiate a closing handshake
        * A message will be passed to the ``received_message`` method
        * Pings will see pongs be sent automatically
        * Pongs will be passed to the ``ponged`` method

        The process should be terminated when this method
        returns ``False``.
        """
        s = self.stream

        if not bytes and self.reading_buffer_size > 0:
            return False
        
        self.reading_buffer_size = s.parser.send(bytes) or DEFAULT_READING_SIZE

        if s.closing is not None:
            logger.debug("Closing message received (%d) '%s'" % (s.closing.code, s.closing.reason))
            if not self.server_terminated:
                self.close(s.closing.code, s.closing.reason)
            else:
                self.client_terminated = True
            s = None
            return False

        if s.errors:
            for error in s.errors:
                logger.debug("Error message received (%d) '%s'" % (error.code, error.reason))
                self.close(error.code, error.reason)
            s.errors = []
            s = None
            return False

        if s.has_message:
            self.received_message(s.message)
            if s.message is not None:
                s.message.data = None
                s.message = None
            s = None
            return True

        if s.pings:
            for ping in s.pings:
                self._write(s.pong(ping.data))
            s.pings = []

        if s.pongs:
            for pong in s.pongs:
                self.ponged(pong)
            s.pongs = []

        s = None
        return True

    def run(self):
        """
        Performs the operation of reading from the underlying
        connection in order to feed the stream of bytes.

        We start with a small size of two bytes to be read
        from the connection so that we can quickly parse an
        incoming frame header. Then the stream indicates
        whatever size must be read from the connection since
        it knows the frame payload length.

        Note that we perform some automatic opererations:

        * On a closing message, we respond with a closing
          message and finally close the connection
        * We respond to pings with pong messages.
        * Whenever an error is raised by the stream parsing,
          we initiate the closing of the connection with the
          appropiate error code.

        This method is blocking and should likely be run
        in a thread.
        """
        self.sock.setblocking(True)
        with Heartbeat(self, frequency=self.heartbeat_freq):
            s = self.stream

            try:
                self.opened()
                while not self.terminated:
                    if not self.once():
                        break
            finally:
                self.terminate()

class EchoWebSocket(WebSocket):
    def received_message(self, message):
        """
        Automatically sends back the provided ``message`` to
        its originating endpoint.
        """
        self.send(message.data, message.is_binary)

########NEW FILE########
