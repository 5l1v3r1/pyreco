__FILENAME__ = admin
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.contrib import admin
from accounts.models import Profile, UserFlag

from forum.models import Post, Thread
from comments.models import Comment
from sounds.models import Sound,DeletedSound
from accounts.models import User
import settings


from django.contrib.auth.models import User
from django.contrib.auth.admin import UserAdmin

def delete_active_user(modeladmin, request, queryset):
    deleted_user = User.objects.get(id=settings.DELETED_USER_ID)     
    for user in queryset:
        for post in Post.objects.filter(author=user):
            post.author = deleted_user
            post.save()
                
        for thread in Thread.objects.filter(author=user):
            thread.author = deleted_user
            thread.save()
                    
        for comment in Comment.objects.filter(user=user):
            comment.user = deleted_user
            comment.save()

        for sound in DeletedSound.objects.filter(user=user):
            sound.user = deleted_user
            sound.save()
        user.delete()
        
delete_active_user.description="Delete user(s), not posts etc"  

UserAdmin.actions.append(delete_active_user)
admin.site.unregister(User)
admin.site.register(User, UserAdmin)

class ProfileAdmin(admin.ModelAdmin):
    raw_id_fields = ('user', 'geotag') 
    list_display = ('user', 'home_page', 'signature', 'is_whitelisted')
    ordering = ('id', )
    list_filter = ('is_whitelisted', 'wants_newsletter', )
    search_fields = ('=user__username', )

admin.site.register(Profile, ProfileAdmin)


class UserFlagAdmin(admin.ModelAdmin):
    raw_id_fields = ('user', 'reporting_user', 'content_type')
    list_display = ('user', 'reporting_user', 'content_type')
admin.site.register(UserFlag, UserFlagAdmin)

########NEW FILE########
__FILENAME__ = forms
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django import forms
from django.contrib.auth.models import User
from django.utils.translation import ugettext as _
from accounts.models import Profile
from utils.forms import RecaptchaForm, HtmlCleaningCharField
from utils.spam import is_spam

class UploadFileForm(forms.Form):
    file = forms.FileField()

class  TermsOfServiceForm(forms.Form):
    accepted_tos  = forms.BooleanField(label='',
                                       help_text='Check this box to accept the <a href="/help/tos_web/" target="_blank">terms of use</a> of the Freesound website',
                                       required=True,
                                       error_messages={'required': 'You must accept the terms of use in order to continue using Freesound.'})

class AvatarForm(forms.Form):
    file = forms.FileField(required=False)
    remove = forms.BooleanField(label="Remove avatar", required=False)
    
    def clean(self):
        cleaned_data = self.cleaned_data
        file_cleaned = cleaned_data.get("file", None)
        remove_cleaned = cleaned_data.get("remove", False)

        if remove_cleaned and file_cleaned:
            raise forms.ValidationError("Either remove or select a new avatar, you can't do both at the same time.")
        elif not remove_cleaned and not file_cleaned:
            raise forms.ValidationError("You forgot to select a file.")

        # Always return the full collection of cleaned data.
        return cleaned_data
    

class FileChoiceForm(forms.Form):
    files = forms.MultipleChoiceField()
    
    def __init__(self, files, *args, **kwargs):
        super(FileChoiceForm, self).__init__(*args, **kwargs)
        choices = files.items()
        self.fields['files'].choices = choices


class RegistrationForm(RecaptchaForm):
    username = forms.RegexField(label=_("Username"), min_length=3, max_length=30, regex=r'^\w+$',
        help_text = _("Required. 30 characters or fewer. Alphanumeric characters only (letters, digits and underscores)."),
        error_message = _("This value must contain only letters, numbers and underscores."))
    first_name = forms.CharField(help_text = _("Optional."), required=False)
    last_name = forms.CharField(help_text=_("Optional."), required=False)
    email1 = forms.EmailField(label=_("Email"), help_text = _("We will send you a confirmation/activation email, so make sure this is correct!."))
    email2 = forms.EmailField(label=_("Email confirmation"))
    password1 = forms.CharField(label=_("Password"), widget=forms.PasswordInput)
    password2 = forms.CharField(label=_("Password confirmation"), widget=forms.PasswordInput)
    newsletter = forms.BooleanField(label=_(""),
                                    required=False,
                                    initial=True,
                                    help_text=_("Sign up for the newsletter (only once every 4 months or so)?"))
    accepted_tos = forms.BooleanField(label='',
                                       help_text=_('Check this box to accept the <a href="/help/tos_web/" target="_blank">terms of use</a> of the Freesound website'),
                                       required=True,
                                       error_messages={'required': _('You must accept the terms of use in order to register to Freesound.')})


    def clean_username(self):
        username = self.cleaned_data["username"]
        try:
            User.objects.get(username__iexact=username)
        except User.DoesNotExist: #@UndefinedVariable
            return username
        raise forms.ValidationError(_("A user with that username already exists."))

    def clean_password2(self):
        password1 = self.cleaned_data.get("password1", "")
        password2 = self.cleaned_data["password2"]
        if password1 != password2:
            raise forms.ValidationError(_("The two password fields didn't match."))
        return password2

    def clean_email2(self):
        email1 = self.cleaned_data.get("email1", "")
        email2 = self.cleaned_data["email2"]
        if email1 != email2:
            raise forms.ValidationError(_("The two email fields didn't match."))
        try:
            User.objects.get(email__iexact=email2)
            raise forms.ValidationError(_("A user using that email address already exists."))
        except User.DoesNotExist: #@UndefinedVariable
            pass
        
        if email2.lower().endswith("@aol.com"):
            raise forms.ValidationError(_("We are sorry, but aol.com deletes all our emails before they reach you, please use a different provider."))
        
        return email2

    def save(self):
        username = self.cleaned_data["username"]
        email = self.cleaned_data["email2"]
        password = self.cleaned_data["password2"]
        first_name = self.cleaned_data.get("first_name", "")
        last_name = self.cleaned_data.get("last_name", "")
        newsletter = self.cleaned_data.get("newsletter", False)
        accepted_tos = self.cleaned_data.get("accepted_tos", False)

        user = User(username=username, first_name=first_name, last_name=last_name, email=email, password=password,is_staff=False, is_active=False, is_superuser=False)
        user.set_password(password)
        user.save()
        
        profile = Profile(user=user, wants_newsletter=newsletter, accepted_tos=accepted_tos)
        profile.save()

        return user


class ReactivationForm(forms.Form):
    user = forms.CharField(label="The username or email you signed up with")
    
    def clean_user(self):
        username_or_email = self.cleaned_data["user"]
        
        try:
            return User.objects.get(email__iexact=username_or_email, is_active=False)
        except User.DoesNotExist: #@UndefinedVariable
            pass
        
        try:
            return User.objects.get(username__iexact=username_or_email, is_active=False)
        except User.DoesNotExist: #@UndefinedVariable
            pass
        
        raise forms.ValidationError(_("No non-active user with such email or username exists."))


class UsernameReminderForm(forms.Form):
    user = forms.EmailField(label="The email address you signed up with")
    
    def clean_user(self):
        email = self.cleaned_data["user"]
        
        try:
            return User.objects.get(email__iexact=email)
        except User.DoesNotExist: #@UndefinedVariable
            raise forms.ValidationError(_("No user with such an email exists."))

class ProfileForm(forms.ModelForm):
    about = HtmlCleaningCharField(widget=forms.Textarea(attrs=dict(rows=20, cols=70)), required=False)
    signature = HtmlCleaningCharField(label="Forum signature", widget=forms.Textarea(attrs=dict(rows=20, cols=70)), required=False)
    wants_newsletter = forms.BooleanField(label="Subscribed to newsletter", required=False)
    not_shown_in_online_users_list = forms.BooleanField(label="Hide from \"users currently online\" list in the People page", required=False)
    
    def __init__(self, request, *args, **kwargs):
        self.request = request
        super(ProfileForm, self).__init__(*args, **kwargs)

    def clean_about(self):
        about = self.cleaned_data['about']
        if is_spam(self.request, about):
            raise forms.ValidationError("Your 'about' text was considered spam, please edit and resubmit. If it keeps failing please contact the admins.")
        return about

    def clean_signature(self):
        signature = self.cleaned_data['signature']
        if is_spam(self.request, signature):
            raise forms.ValidationError("Your signature was considered spam, please edit and resubmit. If it keeps failing please contact the admins.")
        return signature

    class Meta:
        model = Profile
        fields = ('home_page', 'wants_newsletter', 'about', 'signature', 'not_shown_in_online_users_list')
        

class EmailResetForm(forms.Form):   
    email = forms.EmailField(label=_("New e-mail address"), max_length=75)
    password = forms.CharField(label=_("Your password"), widget=forms.PasswordInput)
    
    # Using init function to pass user variable so later we can perform check_password in clean_password function
    def __init__(self, *args, **kwargs):    
        self.user = kwargs.pop('user', None)
        super(EmailResetForm, self).__init__(*args, **kwargs)
 
    def clean_password(self):
        if not self.user.check_password(self.cleaned_data["password"]) :
            raise forms.ValidationError(_("Incorrect password."))    
        
    
########NEW FILE########
__FILENAME__ = management
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from accounts import models as auth_models
from django.contrib.auth.models import User
from accounts.models import Profile
from south.signals import post_migrate
import logging

logger = logging.getLogger("web")


def create_super_profile(**kwargs):
    for user in User.objects.filter(profile=None): # create profiles for all users that don't have profiles yet
        logger.info("\tcreating profile for super user: %s",  user)
        profile = Profile(user=user)
        profile.save()

post_migrate.connect(create_super_profile, sender=auth_models)
########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'ResetEmailRequest'
        db.create_table('accounts_resetemailrequest', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('email', self.gf('django.db.models.fields.EmailField')(max_length=75)),
            ('user', self.gf('django.db.models.fields.related.OneToOneField')(to=orm['auth.User'], unique=True)),
        ))
        db.send_create_signal('accounts', ['ResetEmailRequest'])

        # Adding model 'Profile'
        db.create_table('accounts_profile', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('user', self.gf('django.db.models.fields.related.OneToOneField')(related_name='profile', unique=True, to=orm['auth.User'])),
            ('about', self.gf('django.db.models.fields.TextField')(default=None, null=True, blank=True)),
            ('home_page', self.gf('django.db.models.fields.URLField')(default=None, max_length=200, null=True, blank=True)),
            ('signature', self.gf('django.db.models.fields.TextField')(max_length=256, null=True, blank=True)),
            ('geotag', self.gf('django.db.models.fields.related.ForeignKey')(default=None, to=orm['geotags.GeoTag'], null=True, blank=True)),
            ('has_avatar', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('wants_newsletter', self.gf('django.db.models.fields.BooleanField')(default=True, db_index=True)),
            ('is_whitelisted', self.gf('django.db.models.fields.BooleanField')(default=False, db_index=True)),
            ('last_action_time', self.gf('django.db.models.fields.DateTimeField')(default=None, null=True, blank=True)),
            ('num_sounds', self.gf('django.db.models.fields.PositiveIntegerField')(default=0)),
            ('num_posts', self.gf('django.db.models.fields.PositiveIntegerField')(default=0)),
            ('has_old_license', self.gf('django.db.models.fields.BooleanField')(default=True)),
            ('not_shown_in_online_users_list', self.gf('django.db.models.fields.BooleanField')(default=False)),
        ))
        db.send_create_signal('accounts', ['Profile'])


    def backwards(self, orm):
        
        # Deleting model 'ResetEmailRequest'
        db.delete_table('accounts_resetemailrequest')

        # Deleting model 'Profile'
        db.delete_table('accounts_profile')


    models = {
        'accounts.profile': {
            'Meta': {'ordering': "('-user__date_joined',)", 'object_name': 'Profile'},
            'about': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'geotag': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['geotags.GeoTag']", 'null': 'True', 'blank': 'True'}),
            'has_avatar': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'has_old_license': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'home_page': ('django.db.models.fields.URLField', [], {'default': 'None', 'max_length': '200', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_whitelisted': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'last_action_time': ('django.db.models.fields.DateTimeField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'not_shown_in_online_users_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'num_posts': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'num_sounds': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'signature': ('django.db.models.fields.TextField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'user': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'profile'", 'unique': 'True', 'to': "orm['auth.User']"}),
            'wants_newsletter': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'db_index': 'True'})
        },
        'accounts.resetemailrequest': {
            'Meta': {'object_name': 'ResetEmailRequest'},
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['auth.User']", 'unique': 'True'})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'comments.comment': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Comment'},
            'comment': ('django.db.models.fields.TextField', [], {}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'related_name': "'replies'", 'null': 'True', 'blank': 'True', 'to': "orm['comments.Comment']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'favorites.favorite': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'Favorite'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'geotags.geotag': {
            'Meta': {'object_name': 'GeoTag'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lat': ('django.db.models.fields.FloatField', [], {'db_index': 'True'}),
            'lon': ('django.db.models.fields.FloatField', [], {'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'zoom': ('django.db.models.fields.IntegerField', [], {})
        },
        'ratings.rating': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'Rating'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'rating': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'tags.tag': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '100', 'db_index': 'True'})
        },
        'tags.taggeditem': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('tag', 'content_type', 'object_id'),)", 'object_name': 'TaggedItem'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'tag': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['tags.Tag']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        }
    }

    complete_apps = ['accounts']

########NEW FILE########
__FILENAME__ = 0002_auto__del_field_profile_last_action_time
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Deleting field 'Profile.last_action_time'
        db.delete_column('accounts_profile', 'last_action_time')


    def backwards(self, orm):
        
        # Adding field 'Profile.last_action_time'
        db.add_column('accounts_profile', 'last_action_time', self.gf('django.db.models.fields.DateTimeField')(default=None, null=True, blank=True), keep_default=False)


    models = {
        'accounts.profile': {
            'Meta': {'ordering': "('-user__date_joined',)", 'object_name': 'Profile'},
            'about': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'geotag': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['geotags.GeoTag']", 'null': 'True', 'blank': 'True'}),
            'has_avatar': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'has_old_license': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'home_page': ('django.db.models.fields.URLField', [], {'default': 'None', 'max_length': '200', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_whitelisted': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'not_shown_in_online_users_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'num_posts': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'num_sounds': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'signature': ('django.db.models.fields.TextField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'user': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'profile'", 'unique': 'True', 'to': "orm['auth.User']"}),
            'wants_newsletter': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'db_index': 'True'})
        },
        'accounts.resetemailrequest': {
            'Meta': {'object_name': 'ResetEmailRequest'},
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['auth.User']", 'unique': 'True'})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'comments.comment': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Comment'},
            'comment': ('django.db.models.fields.TextField', [], {}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'related_name': "'replies'", 'null': 'True', 'blank': 'True', 'to': "orm['comments.Comment']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'favorites.favorite': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'Favorite'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'geotags.geotag': {
            'Meta': {'object_name': 'GeoTag'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lat': ('django.db.models.fields.FloatField', [], {'db_index': 'True'}),
            'lon': ('django.db.models.fields.FloatField', [], {'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'zoom': ('django.db.models.fields.IntegerField', [], {})
        },
        'ratings.rating': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'Rating'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'rating': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'tags.tag': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '100', 'db_index': 'True'})
        },
        'tags.taggeditem': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('tag', 'content_type', 'object_id'),)", 'object_name': 'TaggedItem'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'tag': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['tags.Tag']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        }
    }

    complete_apps = ['accounts']

########NEW FILE########
__FILENAME__ = 0003_auto__add_userflag
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'UserFlag'
        db.create_table('accounts_userflag', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(related_name='flags', to=orm['auth.User'])),
            ('reporting_user', self.gf('django.db.models.fields.related.ForeignKey')(default=None, to=orm['auth.User'], null=True, blank=True)),
            ('content_type', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['contenttypes.ContentType'], null=True)),
            ('object_id', self.gf('django.db.models.fields.PositiveIntegerField')(null=True)),
            ('created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, db_index=True, blank=True)),
        ))
        db.send_create_signal('accounts', ['UserFlag'])


    def backwards(self, orm):
        
        # Deleting model 'UserFlag'
        db.delete_table('accounts_userflag')


    models = {
        'accounts.profile': {
            'Meta': {'ordering': "('-user__date_joined',)", 'object_name': 'Profile'},
            'about': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'geotag': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['geotags.GeoTag']", 'null': 'True', 'blank': 'True'}),
            'has_avatar': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'has_old_license': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'home_page': ('django.db.models.fields.URLField', [], {'default': 'None', 'max_length': '200', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_whitelisted': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'not_shown_in_online_users_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'num_posts': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'num_sounds': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'signature': ('django.db.models.fields.TextField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'user': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'profile'", 'unique': 'True', 'to': "orm['auth.User']"}),
            'wants_newsletter': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'db_index': 'True'})
        },
        'accounts.resetemailrequest': {
            'Meta': {'object_name': 'ResetEmailRequest'},
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['auth.User']", 'unique': 'True'})
        },
        'accounts.userflag': {
            'Meta': {'ordering': "('-user__username',)", 'object_name': 'UserFlag'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']", 'null': 'True'}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True'}),
            'reporting_user': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['auth.User']", 'null': 'True', 'blank': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'flags'", 'to': "orm['auth.User']"})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'comments.comment': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Comment'},
            'comment': ('django.db.models.fields.TextField', [], {}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'related_name': "'replies'", 'null': 'True', 'blank': 'True', 'to': "orm['comments.Comment']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'favorites.favorite': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'Favorite'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'geotags.geotag': {
            'Meta': {'object_name': 'GeoTag'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lat': ('django.db.models.fields.FloatField', [], {'db_index': 'True'}),
            'lon': ('django.db.models.fields.FloatField', [], {'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'zoom': ('django.db.models.fields.IntegerField', [], {})
        },
        'ratings.rating': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'Rating'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'rating': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'tags.tag': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '100', 'db_index': 'True'})
        },
        'tags.taggeditem': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('tag', 'content_type', 'object_id'),)", 'object_name': 'TaggedItem'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'tag': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['tags.Tag']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        }
    }

    complete_apps = ['accounts']

########NEW FILE########
__FILENAME__ = 0004_auto__add_field_profile_accepted_tos
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'Profile.accepted_tos'
        db.add_column('accounts_profile', 'accepted_tos', self.gf('django.db.models.fields.BooleanField')(default=False), keep_default=False)


    def backwards(self, orm):
        
        # Deleting field 'Profile.accepted_tos'
        db.delete_column('accounts_profile', 'accepted_tos')


    models = {
        'accounts.profile': {
            'Meta': {'ordering': "('-user__date_joined',)", 'object_name': 'Profile'},
            'about': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'accepted_tos': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'geotag': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['geotags.GeoTag']", 'null': 'True', 'blank': 'True'}),
            'has_avatar': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'has_old_license': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'home_page': ('django.db.models.fields.URLField', [], {'default': 'None', 'max_length': '200', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_whitelisted': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'not_shown_in_online_users_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'num_posts': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'num_sounds': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'signature': ('django.db.models.fields.TextField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'user': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'profile'", 'unique': 'True', 'to': "orm['auth.User']"}),
            'wants_newsletter': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'db_index': 'True'})
        },
        'accounts.resetemailrequest': {
            'Meta': {'object_name': 'ResetEmailRequest'},
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['auth.User']", 'unique': 'True'})
        },
        'accounts.userflag': {
            'Meta': {'ordering': "('-user__username',)", 'object_name': 'UserFlag'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']", 'null': 'True'}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True'}),
            'reporting_user': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['auth.User']", 'null': 'True', 'blank': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'flags'", 'to': "orm['auth.User']"})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'comments.comment': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Comment'},
            'comment': ('django.db.models.fields.TextField', [], {}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'related_name': "'replies'", 'null': 'True', 'blank': 'True', 'to': "orm['comments.Comment']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'favorites.favorite': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'Favorite'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'geotags.geotag': {
            'Meta': {'object_name': 'GeoTag'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lat': ('django.db.models.fields.FloatField', [], {'db_index': 'True'}),
            'lon': ('django.db.models.fields.FloatField', [], {'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'zoom': ('django.db.models.fields.IntegerField', [], {})
        },
        'ratings.rating': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'Rating'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'rating': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'tags.tag': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '100', 'db_index': 'True'})
        },
        'tags.taggeditem': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('tag', 'content_type', 'object_id'),)", 'object_name': 'TaggedItem'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'tag': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['tags.Tag']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        }
    }

    complete_apps = ['accounts']

########NEW FILE########
__FILENAME__ = 0005_email_index
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        db.execute("CREATE INDEX auth_user_email_upper ON auth_user (upper(email))")
        print "Created UPPER index on auth_user"

    def backwards(self, orm):
        db.execute("DROP INDEX auth_user_email_upper")
        print "Deleted UPPER index on auth_user"


    models = {
        'accounts.profile': {
            'Meta': {'ordering': "('-user__date_joined',)", 'object_name': 'Profile'},
            'about': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'accepted_tos': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'geotag': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['geotags.GeoTag']", 'null': 'True', 'blank': 'True'}),
            'has_avatar': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'has_old_license': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'home_page': ('django.db.models.fields.URLField', [], {'default': 'None', 'max_length': '200', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_whitelisted': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'not_shown_in_online_users_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'num_posts': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'num_sounds': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'signature': ('django.db.models.fields.TextField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'user': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'profile'", 'unique': 'True', 'to': "orm['auth.User']"}),
            'wants_newsletter': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'db_index': 'True'})
        },
        'accounts.resetemailrequest': {
            'Meta': {'object_name': 'ResetEmailRequest'},
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['auth.User']", 'unique': 'True'})
        },
        'accounts.userflag': {
            'Meta': {'ordering': "('-user__username',)", 'object_name': 'UserFlag'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']", 'null': 'True'}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True'}),
            'reporting_user': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['auth.User']", 'null': 'True', 'blank': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'flags'", 'to': "orm['auth.User']"})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'comments.comment': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Comment'},
            'comment': ('django.db.models.fields.TextField', [], {}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'related_name': "'replies'", 'null': 'True', 'blank': 'True', 'to': "orm['comments.Comment']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'favorites.favorite': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'Favorite'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'geotags.geotag': {
            'Meta': {'object_name': 'GeoTag'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lat': ('django.db.models.fields.FloatField', [], {'db_index': 'True'}),
            'lon': ('django.db.models.fields.FloatField', [], {'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'zoom': ('django.db.models.fields.IntegerField', [], {})
        },
        'ratings.rating': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'Rating'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'rating': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'tags.tag': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '100', 'db_index': 'True'})
        },
        'tags.taggeditem': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('tag', 'content_type', 'object_id'),)", 'object_name': 'TaggedItem'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'tag': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['tags.Tag']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        }
    }

    complete_apps = ['accounts']

########NEW FILE########
__FILENAME__ = 0006_add_index_username
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding index on 'User', fields ['username']
        db.create_unique('auth_user', ['username'])


    def backwards(self, orm):
        
        # Removing index on 'User', fields ['username']
        db.delete_unique('auth_user', ['username'])


    models = {
        'accounts.profile': {
            'Meta': {'ordering': "('-user__date_joined',)", 'object_name': 'Profile'},
            'about': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'accepted_tos': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'geotag': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['geotags.GeoTag']", 'null': 'True', 'blank': 'True'}),
            'has_avatar': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'has_old_license': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'home_page': ('django.db.models.fields.URLField', [], {'default': 'None', 'max_length': '200', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_whitelisted': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'not_shown_in_online_users_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'num_posts': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'num_sounds': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'signature': ('django.db.models.fields.TextField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'user': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'profile'", 'unique': 'True', 'to': "orm['auth.User']"}),
            'wants_newsletter': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'db_index': 'True'})
        },
        'accounts.resetemailrequest': {
            'Meta': {'object_name': 'ResetEmailRequest'},
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['auth.User']", 'unique': 'True'})
        },
        'accounts.userflag': {
            'Meta': {'ordering': "('-user__username',)", 'object_name': 'UserFlag'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']", 'null': 'True'}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True'}),
            'reporting_user': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['auth.User']", 'null': 'True', 'blank': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'flags'", 'to': "orm['auth.User']"})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'comments.comment': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Comment'},
            'comment': ('django.db.models.fields.TextField', [], {}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'related_name': "'replies'", 'null': 'True', 'blank': 'True', 'to': "orm['comments.Comment']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'favorites.favorite': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'Favorite'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'geotags.geotag': {
            'Meta': {'object_name': 'GeoTag'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lat': ('django.db.models.fields.FloatField', [], {'db_index': 'True'}),
            'lon': ('django.db.models.fields.FloatField', [], {'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'zoom': ('django.db.models.fields.IntegerField', [], {})
        },
        'ratings.rating': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'Rating'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'rating': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'tags.tag': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '100', 'db_index': 'True'})
        },
        'tags.taggeditem': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('tag', 'content_type', 'object_id'),)", 'object_name': 'TaggedItem'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'tag': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['tags.Tag']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        }
    }

    complete_apps = ['accounts']

########NEW FILE########
__FILENAME__ = modelbackend
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.contrib.auth.models import User
from django.contrib.auth.backends import ModelBackend

class CustomModelBackend(ModelBackend):
    def authenticate(self, username=None, password=None):
        """ authenticate against case insensitive username """
        try:
            user = User.objects.get(username__iexact=username)
            if user.check_password(password):
                return user
        except User.DoesNotExist: #@UndefinedVariable
            return None
########NEW FILE########
__FILENAME__ = models
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.contrib.auth.models import User
from django.db import models
from django.utils.encoding import smart_unicode
from general.models import SocialModel
from geotags.models import GeoTag
from utils.sql import DelayedQueryExecuter
from django.conf import settings
from utils.locations import locations_decorator
import datetime
import os
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes import generic
from tickets.views import get_pending_sounds


class ResetEmailRequest(models.Model):
    email = models.EmailField()
    user = models.OneToOneField(User, db_index=True)
    
    
class ProfileManager(models.Manager):
    def random_uploader(self):
        import random

        user_count = User.objects.filter(profile__num_sounds__gte=1).count()

        if user_count:
            offset = random.randint(0, user_count - 1)
            return User.objects.filter(profile__num_sounds__gte=1)[offset:offset+1][0]
        else:
            return None

class Profile(SocialModel):
    user = models.OneToOneField(User, related_name="profile")

    about = models.TextField(null=True, blank=True, default=None)
    home_page = models.URLField(null=True, blank=True, default=None)
    signature = models.TextField(max_length=256, null=True, blank=True)
    geotag = models.ForeignKey(GeoTag, null=True, blank=True, default=None)
    has_avatar = models.BooleanField(default=False)

    wants_newsletter = models.BooleanField(default=True, db_index=True)
    is_whitelisted = models.BooleanField(default=False, db_index=True)

    num_sounds = models.PositiveIntegerField(editable=False, default=0)
    num_posts = models.PositiveIntegerField(editable=False, default=0)

    has_old_license = models.BooleanField(null=False, default=False)
    not_shown_in_online_users_list = models.BooleanField(null=False, default=False)

    accepted_tos = models.BooleanField(default=False)

    objects = ProfileManager()

    def __unicode__(self):
        return self.user.username

    @models.permalink
    def get_absolute_url(self):
        return ('account', (smart_unicode(self.user.username),))

    @locations_decorator(cache=False)
    def locations(self):
        id_folder = str(self.user_id/1000)
        if self.has_avatar:
            s_avatar = settings.AVATARS_URL + "%s/%d_S.jpg" % (id_folder, self.user_id)
            m_avatar = settings.AVATARS_URL + "%s/%d_M.jpg" % (id_folder, self.user_id)
            l_avatar = settings.AVATARS_URL + "%s/%d_L.jpg" % (id_folder, self.user_id)
        else:
            s_avatar = settings.MEDIA_URL + "images/32x32_avatar.png"
            m_avatar = settings.MEDIA_URL + "images/40x40_avatar.png"
            l_avatar = settings.MEDIA_URL + "images/70x70_avatar.png"
        return dict(
            avatar = dict(
                S = dict(
                    path = os.path.join(settings.AVATARS_PATH, id_folder, "%d_S.jpg" % self.user_id),
                    url = s_avatar
                ),
                M = dict(
                    path = os.path.join(settings.AVATARS_PATH, id_folder, "%d_M.jpg" % self.user_id),
                    url = m_avatar
                ),
                L = dict(
                    path = os.path.join(settings.AVATARS_PATH, id_folder, "%d_L.jpg" % self.user_id),
                    url = l_avatar
                )
            )
        )

    def get_tagcloud(self):
        return DelayedQueryExecuter("""
            select
                tags_tag.name as name,
                X.c as count
            from (
                select
                    tag_id,
                    count(*) as c
                from tags_taggeditem
                left join sounds_sound on
                    object_id=sounds_sound.id
                where
                    tags_taggeditem.user_id=%d and
                    sounds_sound.moderation_state='OK' and
                    sounds_sound.processing_state='OK'
                group by tag_id
                order by c
                desc limit 10
            ) as X
            left join tags_tag on tags_tag.id=X.tag_id
            order by tags_tag.name;""" % self.user_id)

    def can_post_in_forum(self):

        # POSTS PENDING TO MODERATE: Do not allow new posts if there are others pending to moderate
        user_has_posts_pending_to_moderate = self.user.post_set.filter(moderation_state="NM").count() > 0
        if user_has_posts_pending_to_moderate:
            return False, "We're sorry but you can't post to the forum because you have previous posts still pending to moderate"

        # THROTTLING
        if self.user.post_set.all().count() >= 1 and self.user.sounds.all().count() == 0:
            today = datetime.datetime.today()
            reference_date = self.user.post_set.all()[0].created # or since registration date: reference_date = self.user.date_joined

            # Do not allow posts if last post is not older than 5 minutes
            seconds_per_post = 60*5
            if (today - self.user.post_set.all().reverse()[0].created).seconds < seconds_per_post:
                return False, "We're sorry but you can't post to the forum because your last post was less than 5 minutes ago"

            # Do not allow posts if user has already posyted N posts that day
            # (every day users can post as many posts as twice the number of days since the reference date (registration or first post date))
            max_posts_per_day = 5 + pow((today - reference_date).days,2)
            if self.user.post_set.filter(created__range=(today-datetime.timedelta(days=1),today)).count() > max_posts_per_day:
                return False, "We're sorry but you can't post to the forum because you exceeded your maximum number of posts per day"

        return True, ""

    def is_blocked_for_spam_reports(self):
        reports_count = UserFlag.objects.filter(user__username = self.user.username).values('reporting_user').distinct().count()
        if reports_count < settings.USERFLAG_THRESHOLD_FOR_AUTOMATIC_BLOCKING or self.user.sounds.all().count() > 0:
            return False
        else:
            return True

    def num_sounds_pending_moderation(self):
        return len(get_pending_sounds(self.user))

    class Meta(SocialModel.Meta):
        ordering = ('-user__date_joined', )


class UserFlag(models.Model):
    user = models.ForeignKey(User, related_name="flags")
    reporting_user = models.ForeignKey(User, null=True, blank=True, default=None)
    content_type = models.ForeignKey(ContentType, null=True)
    object_id = models.PositiveIntegerField(null=True)
    content_object = generic.GenericForeignKey('content_type', 'object_id')


    created = models.DateTimeField(db_index=True, auto_now_add=True)

    def __unicode__(self):
        return u"Flag %s: %s" % (self.content_type, self.object_id)

    class Meta:
        ordering = ("-user__username",)

########NEW FILE########
__FILENAME__ = active_user_content
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django import template
from sounds.models import Sound
from comments.models import Comment
from forum.models import Post

register = template.Library()

@register.inclusion_tag("accounts/active_user_content.html", takes_context=True)
def active_user_content(context,user_obj, content_type):
    content = None
    if content_type == "sound":
        content = Sound.public.select_related().filter(user=user_obj).order_by("-created")[0]
    elif  content_type == "post":
        content = Post.objects.select_related().filter(author=user_obj).order_by("-created")[0]
    elif content_type == "comment":
        content = Comment.objects.select_related().filter(user=user_obj).order_by("-created")[0]
    return {'content_type':content_type,'content':content,'user':user_obj,'media_url': context['media_url']}

########NEW FILE########
__FILENAME__ = filefunctions
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django import template

register = template.Library()

@register.inclusion_tag('accounts/recursive_file.html')
def show_file(file_structure):
    return {'file': file_structure}
########NEW FILE########
__FILENAME__ = flag_user
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django import template
from comments.models import Comment
from forum.models import Post
from messages.models import Message
from accounts.models import UserFlag
register = template.Library()

@register.inclusion_tag("accounts/flag_user.html", takes_context=True)
def flag_user(context, flag_type, username, content_id, text = None, user_sounds = None):

    no_show = False
    link_text = "Report spam"

    if not context['request'].user.is_authenticated():
        no_show = True
        flagged = []
    else:
        flagged = UserFlag.objects.filter(user__username = username, reporting_user = context['request'].user, object_id = content_id).values('reporting_user').distinct()
        if text:
            link_text = text

    return {'user_sounds':user_sounds,'done_text':"Marked as spam", 'flagged':len(flagged),'flag_type':flag_type,'username':username, 'content_obj_id':content_id, 'media_url': context['media_url'], 'link_text':link_text, 'no_show':no_show}

########NEW FILE########
__FILENAME__ = tests
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.test import TestCase, Client
from django.contrib.auth.models import User
from django.core.urlresolvers import reverse

# Test old user links redirect
class OldUserLinksRedirectTestCase(TestCase):
    
    fixtures = ['users.json']
    
    def setUp(self):
        self.client = Client()
        self.user = User.objects.all()[0]
        
    def test_old_user_link_redirect_ok(self):
        # 301 permanent redirect, result exists
        response = self.client.get(reverse('old-account-page'), data={'id' : self.user.id})
        self.assertEqual(response.status_code, 301)
        
    def test_old_user_link_redirect_not_exists_id(self):
        # 404 id does not exist
        response = self.client.get(reverse('old-account-page'), data={'id' : 0}, follow=True)
        self.assertEqual(response.status_code, 404)
        
    def test_old_user_link_redirect_invalid_id(self):
        # 404 invalid id
        response = self.client.get(reverse('old-account-page'), data={'id' : 'invalid_id'}, follow=True)
        self.assertEqual(response.status_code, 404)    

########NEW FILE########
__FILENAME__ = urls
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.conf.urls.defaults import patterns, url
import django.contrib.auth.views as authviews
import messages.views as messages
import accounts.views as accounts
import bookmarks.views as bookmarks
import apiv2.views as api

urlpatterns = patterns('accounts.views',

    url(r'^login/$',
        accounts.login_wrapper,
        name="accounts-login"),

    url(r'^logout/$',
        authviews.logout,
        {'template_name': 'accounts/logout.html'},
        name="accounts-logout"),

    url(r'^reactivate/$',
        accounts.resend_activation,
        name="accounts-resend-activation"),

    url(r'^username/$',
        accounts.username_reminder,
        name="accounts-username-reminder"),

    url(r'^activate/(?P<activation_key>[^//]+)/(?P<username>\w+)/$',
        accounts.activate_user,
        name="accounts-activate"),

    url(r'^activate2/(?P<username>[^\/]+)/(?P<hash>[^\/]+)/.*$', # old pattern: url(r'^activate2/(?P<username>[^\/]+)/(?P<hash>[^\/]+)/$',
        accounts.activate_user2,
        name="accounts-activate2"),
                       
    url(r'^register/$',
        accounts.registration,
        name="accounts-register"),

    url(r'^resetpassword/$',
        authviews.password_reset,
        {'template_name':'accounts/password_reset_form.html',
         'email_template_name':'accounts/password_reset_email.html'},
         name="accounts-password-reset"),

    url(r'^resetpassword/sent/$',
        authviews.password_reset_done,
        {'template_name':'accounts/password_reset_done.html'}),

    url(r'^resetpassword/confirm/(?P<uidb36>[0-9A-Za-z]+)-(?P<token>.+)/$',
        authviews.password_reset_confirm,
        {'template_name':'accounts/password_reset_confirm.html'}),

    url(r'^resetpassword/complete/$',
        authviews.password_reset_complete,
        {'template_name':'accounts/password_reset_complete.html'}),

    url(r'^resetemail/$',
        accounts.email_reset,
        name="accounts-email-reset"),

    url(r'^resetemail/sent/$',
        accounts.email_reset_done),

    url(r'^resetemail/complete/(?P<uidb36>[0-9A-Za-z]+)-(?P<token>.+)/$',
        accounts.email_reset_complete),
 
    url(r'^bulklicensechange/$',
        accounts.bulk_license_change,
        name="bulk-license-change"),

    url(r'^tosacceptance/$',
        accounts.tos_acceptance,
        name="tos-acceptance"),

    url(r'^$', accounts.home, name="accounts-home"),
    url(r'^edit/$', accounts.edit, name="accounts-edit"),
    url(r'^delete/$', accounts.delete, name="accounts-delete"),

    url(r'^pending/$', accounts.pending, name="accounts-pending"),

    url(r'^upload/file/$', accounts.upload_file, name="accounts-upload-file"),
    url(r'^upload/$', accounts.upload, name="accounts-upload"),
    url(r'^upload/html/$', accounts.upload, name="accounts-upload-html", kwargs=dict(no_flash=True)),    
    url(r'^describe/$', accounts.describe, name="accounts-describe"),
    url(r'^describe/license/$', accounts.describe_license, name="accounts-describe-license"),
    url(r'^describe/pack/', accounts.describe_pack, name="accounts-describe-pack"),
    url(r'^describe/sounds/', accounts.describe_sounds, name="accounts-describe-sounds"),
    url(r'^attribution/$', accounts.attribution, name="accounts-attribution"),
    url(r'^bookmarks/add/(?P<sound_id>\d+)/$', bookmarks.add_bookmark, name="add-bookmark"),
    url(r'^bookmarks/get_form_for_sound/(?P<sound_id>\d+)/$', bookmarks.get_form_for_sound, name="bookmarks-add-form-for-sound"),
    url(r'^bookmarks/category/(?P<category_id>\d+)/delete/$', bookmarks.delete_bookmark_category, name="delete-bookmark-category"),    
    url(r'^bookmarks/(?P<bookmark_id>\d+)/delete/$', bookmarks.delete_bookmark, name="delete-bookmark"),


    url(r'^messages/$', messages.inbox, name='messages'),
    url(r'^messages/sent/$', messages.sent_messages, name='messages-sent'),
    url(r'^messages/archived/$', messages.archived_messages, name='messages-archived'),
    url(r'^messages/changestate/$', messages.messages_change_state, name='messages-change-state'),
    url(r'^messages/(?P<message_id>\d+)/$', messages.message, name='message'),
    url(r'^messages/(?P<message_id>\d+)/reply/$', messages.new_message, name='message-reply', kwargs=dict(username=None)),
    url(r'^messages/new/$', messages.new_message, name='messages-new'),
    url(r'^messages/new/(?P<username>[^//]+)/$', messages.new_message, name='messages-new', kwargs=dict(message_id=None)),
    url(r'^messages/new/username_lookup$', messages.username_lookup, name='messages-username_lookup'),

    url(r'^app_permissions/$', api.granted_permissions, name='access-tokens'),
    url(r'^app_permissions/revoke_permission/(?P<client_id>[^//]+)/$', api.revoke_permission, name='revoke-permission'),
    url(r'^app_permissions/permission_granted/$', api.permission_granted, name='permission-granted'),
)

########NEW FILE########
__FILENAME__ = views
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

import datetime, logging, os, tempfile, uuid, shutil, hashlib, base64, settings
from accounts.forms import UploadFileForm, FileChoiceForm, RegistrationForm, \
    ReactivationForm, UsernameReminderForm, ProfileForm, AvatarForm, TermsOfServiceForm
from accounts.models import Profile, ResetEmailRequest, UserFlag
from comments.models import Comment
from django.conf import settings
from django.contrib.auth.decorators import login_required
from django.contrib.auth.models import User
from django.core.exceptions import PermissionDenied
from django.core.urlresolvers import reverse
from django.db.models import Count, Max
from django.http import HttpResponseRedirect, HttpResponse, \
    HttpResponseBadRequest, HttpResponseNotFound, Http404, \
    HttpResponsePermanentRedirect, HttpResponseServerError, HttpRequest
from django.shortcuts import render_to_response, get_object_or_404
from django.template import RequestContext
from django.views.decorators.csrf import csrf_exempt
from forum.models import Post
from operator import itemgetter
from sounds.models import Sound, Pack, Download, License
from sounds.forms import NewLicenseForm, PackForm, SoundDescriptionForm, GeotaggingForm, RemixForm
from utils.cache import invalidate_template_cache
from utils.dbtime import DBTime
from utils.onlineusers import get_online_users
from utils.encryption import decrypt, encrypt, create_hash
from utils.filesystem import generate_tree, md5file
from utils.functional import combine_dicts
from utils.images import extract_square
from utils.pagination import paginate
from utils.text import slugify, remove_control_chars
from geotags.models import GeoTag
from django.contrib import messages
from settings import SOUNDS_PER_DESCRIBE_ROUND
from tickets.models import Ticket, Queue, LinkedContent, TicketComment
from tickets import QUEUE_SOUND_MODERATION, TICKET_SOURCE_NEW_SOUND, \
    TICKET_STATUS_NEW, TICKET_STATUS_ACCEPTED
from utils.audioprocessing import get_sound_type
from django.core.cache import cache
import django.contrib.auth.views as authviews
from django.contrib.auth.forms import AuthenticationForm
from tickets.views import new_sound_tickets_count, new_support_tickets_count
from django.contrib.auth.tokens import default_token_generator
from accounts.forms import EmailResetForm
from django.views.decorators.cache import never_cache
from django.utils.http import base36_to_int
from django.template import loader
from django.utils.http import int_to_base36
from django.contrib.sites.models import get_current_site
from utils.mail import send_mail, send_mail_template
from django.db import transaction
from bookmarks.models import Bookmark
from django.contrib.auth.decorators import user_passes_test
import json
from utils.tagrecommendation_utilities import get_recommended_tags
from messages.models import Message
from django.contrib.contenttypes.models import ContentType
import tickets.views as TicketViews
from django.contrib.auth.models import Group
from provider.oauth2.models import AccessToken


audio_logger = logging.getLogger('audio')
# TAGRECOMMENDATION CODE
research_logger = logging.getLogger('tagrecommendation_research')

@login_required
@user_passes_test(lambda u: u.is_staff, login_url = "/")
def crash_me(request):
    raise Exception


@login_required
def bulk_license_change(request):
    if request.method == 'POST':
        form = NewLicenseForm(request.POST)
        if form.is_valid():
            license = form.cleaned_data['license']
            Sound.objects.filter(user=request.user).update(license=license, is_index_dirty=True)
            
            # update old license flag
            Profile.objects.filter(user=request.user).update(has_old_license=False)
            # update cache
            cache.set("has-old-license-%s" % request.user.id, [False,Sound.objects.filter(user=request.user).exists()], 2592000)
            return HttpResponseRedirect(reverse('accounts-home'))
    else:
        form = NewLicenseForm()
    return render_to_response('accounts/choose_new_license.html', locals(), context_instance=RequestContext(request))

@login_required
def tos_acceptance(request):
    if request.method == 'POST':
        form = TermsOfServiceForm(request.POST)
        if form.is_valid():
            # update accepted tos field in user profile
            Profile.objects.filter(user=request.user).update(accepted_tos=True)
            # update cache
            cache.set("has-accepted-tos-%s" % request.user.id, 'yes', 2592000)
            return HttpResponseRedirect(reverse('accounts-home'))
    else:
        form = TermsOfServiceForm()
    return render_to_response('accounts/accept_terms_of_service.html', locals(), context_instance=RequestContext(request))



def activate_user(request, activation_key, username):
    if request.user.is_authenticated():
        return HttpResponseRedirect(reverse("accounts-home"))

    try:
        user_id = decrypt(activation_key)
        user = User.objects.get(id=int(user_id))
        user.is_active = True
        user.save()
        return render_to_response('accounts/activate.html', { 'all_ok': True }, context_instance=RequestContext(request))
    except User.DoesNotExist: #@UndefinedVariable
        return render_to_response('accounts/activate.html', { 'user_does_not_exist': True }, context_instance=RequestContext(request))
    except TypeError, ValueError:
        return render_to_response('accounts/activate.html', { 'decode_error': True }, context_instance=RequestContext(request))

def activate_user2(request, username, hash):
    if request.user.is_authenticated():
        return HttpResponseRedirect(reverse("accounts-home"))

    try:
        user = User.objects.get(username__iexact=username)
    except User.DoesNotExist: #@UndefinedVariable
        return render_to_response('accounts/activate.html', { 'user_does_not_exist': True }, context_instance=RequestContext(request))

    new_hash = create_hash(user.id)
    if new_hash != hash:
        return render_to_response('accounts/activate.html', { 'decode_error': True }, context_instance=RequestContext(request))
    user.is_active = True
    user.save()
    
    return render_to_response('accounts/activate.html', { 'all_ok': True }, context_instance=RequestContext(request))

def send_activation(user):
    encrypted_user_id = encrypt(str(user.id))
    username = user.username
    send_mail_template(u'activation link.', 'accounts/email_activation.txt', locals(), None, user.email)

def send_activation2(user):
    hash = create_hash(user.id)
    username = user.username
    send_mail_template(u'activation link.', 'accounts/email_activation2.txt', locals(), None, user.email)

def registration(request):
    if request.user.is_authenticated():
        return HttpResponseRedirect(reverse("accounts-home"))

    if request.method == "POST":
        form = RegistrationForm(request, request.POST)
        if form.is_valid():
            user = form.save()
            send_activation2(user)
            return render_to_response('accounts/registration_done.html', locals(), context_instance=RequestContext(request))
    else:
        form = RegistrationForm(request)

    return render_to_response('accounts/registration.html', locals(), context_instance=RequestContext(request))


def resend_activation(request):
    if request.user.is_authenticated():
        return HttpResponseRedirect(reverse("accounts-home"))

    if request.method == "POST":
        form = ReactivationForm(request.POST)
        if form.is_valid():
            user = form.cleaned_data["user"]
            send_activation2(user)
            return render_to_response('accounts/registration_done.html', locals(), context_instance=RequestContext(request))
    else:
        form = ReactivationForm()

    return render_to_response('accounts/resend_activation.html', locals(), context_instance=RequestContext(request))


def username_reminder(request):
    if request.user.is_authenticated():
        return HttpResponseRedirect(reverse("accounts-home"))

    if request.method == "POST":
        form = UsernameReminderForm(request.POST)
        if form.is_valid():
            user = form.cleaned_data["user"]
            send_mail_template(u'username reminder.', 'accounts/email_username_reminder.txt', dict(user=user), None, user.email)

            return render_to_response('accounts/username_reminder.html', dict(form=form, sent=True), context_instance=RequestContext(request))
    else:
        form = UsernameReminderForm()

    return render_to_response('accounts/username_reminder.html', dict(form=form, sent=False), context_instance=RequestContext(request))


@login_required
def home(request):
    user = request.user
    # expand tags because we will definitely be executing, and otherwise tags is called multiple times
    tags = list(user.profile.get_tagcloud())
    latest_sounds = Sound.objects.select_related().filter(user=user,processing_state="OK",moderation_state="OK")[0:5]
    unprocessed_sounds = Sound.objects.select_related().filter(user=user).exclude(processing_state="OK")
    #unmoderated_sounds = Sound.objects.select_related().filter(user=user,processing_state="OK").exclude(moderation_state="OK")
    unmoderated_sounds = TicketViews.get_pending_sounds(request.user)
    unmoderated_sounds_count = len(unmoderated_sounds)
    unmoderated_sounds = unmoderated_sounds[:settings.MAX_UNMODERATED_SOUNDS_IN_HOME_PAGE]
    num_more_unmoderated_sounds = unmoderated_sounds_count - settings.MAX_UNMODERATED_SOUNDS_IN_HOME_PAGE

    latest_packs = Pack.objects.select_related().filter(user=user).filter(num_sounds__gt=0).order_by("-last_updated")[0:5]

    # TODO: This might show a pack each time for each sound in it
    unmoderated_packs = Pack.objects.select_related().filter(user=user).exclude(sound__moderation_state="OK", sound__processing_state="OK").filter(num_sounds__gt=0).order_by("-last_updated")[0:5]
    packs_without_sounds = Pack.objects.select_related().filter(user=user).filter(num_sounds=0)
    
    # TODO: refactor: This list of geotags is only used to determine if we need to show the geotag map or not
    latest_geotags = Sound.public.filter(user=user).exclude(geotag=None)[0:10].exists()
    google_api_key = settings.GOOGLE_API_KEY
    home = True
    if home and request.user.has_perm('tickets.can_moderate'):
        new_sounds = new_sound_tickets_count()
        new_support = new_support_tickets_count()
    if home and request.user.has_perm('forum.can_moderate_forum'):
        new_posts = Post.objects.filter(moderation_state='NM').count()

    return render_to_response('accounts/account.html', locals(), context_instance=RequestContext(request))


def handle_uploaded_image(profile, f):
    # handle a file uploaded to the app. Basically act as if this file was uploaded through FTP
    logger.info("\thandling profile image upload")
    try:
        os.mkdir(os.path.dirname(profile.locations("avatar.L.path")))
    except:
        logger.info("\tfailed creating directory, probably already exist")
        pass

    ext = os.path.splitext(os.path.basename(f.name))[1]
    tmp_image_path = tempfile.mktemp(suffix=ext, prefix=str(profile.user.id))

    try:
        logger.info("\topening file: %s", tmp_image_path)
        destination = open(tmp_image_path, 'wb')
        for chunk in f.chunks():
            destination.write(chunk)
        destination.close()
        logger.info("\tfile upload done")
    except Exception, e:
        logger.error("\tfailed writing file error: %s", str(e))

    path_s = profile.locations("avatar.S.path")
    path_m = profile.locations("avatar.M.path")
    path_l = profile.locations("avatar.L.path")

    logger.info("\tcreating thumbnails")
    try:
        extract_square(tmp_image_path, path_s, 32)
        profile.has_avatar = True
        profile.save()
    except Exception, e:
        logger.error("\tfailed creating small thumbnails: " + str(e))

    logger.info("\tcreated small thumbnail")

    try:
        extract_square(tmp_image_path, path_m, 40)
    except Exception, e:
        logger.error("\tfailed creating medium thumbnails: " + str(e))

    try:
        extract_square(tmp_image_path, path_l, 70)
    except Exception, e:
        logger.error("\tfailed creating large thumbnails: " + str(e))

    logger.info("\tcreated medium thumbnail")

    os.unlink(tmp_image_path)


@login_required
def edit(request):
    profile = request.user.profile

    def is_selected(prefix):
        if request.method == "POST":
            for name in request.POST.keys():
                if name.startswith(prefix + '-'):
                    return True
            if request.FILES:
                for name in request.FILES.keys():
                    if name.startswith(prefix + '-'):
                        return True
        return False

    if is_selected("profile"):
        profile_form = ProfileForm(request, request.POST, instance=profile, prefix="profile")
        if profile_form.is_valid():
            profile_form.save()
            return HttpResponseRedirect(reverse("accounts-home"))
    else:
        profile_form = ProfileForm(request,instance=profile, prefix="profile")

    if is_selected("image"):
        image_form = AvatarForm(request.POST, request.FILES, prefix="image")
        if image_form.is_valid():
            if image_form.cleaned_data["remove"]:
                profile.has_avatar = False
                profile.save()
            else:
                handle_uploaded_image(profile, image_form.cleaned_data["file"])
                profile.has_avatar = True
                profile.save()
            return HttpResponseRedirect(reverse("accounts-home"))
    else:
        image_form = AvatarForm(prefix="image")


    has_granted_permissions = AccessToken.objects.filter(user=request.user).count()

    return render_to_response('accounts/edit.html', dict(profile=profile,
                                                         profile_form=profile_form,
                                                         image_form=image_form,
                                                         has_granted_permissions=has_granted_permissions),
                              context_instance=RequestContext(request))


@login_required
def describe(request):

    file_structure, files = generate_tree(os.path.join(settings.UPLOADS_PATH, str(request.user.id)))
    file_structure.name = 'Your uploaded files'

    if request.method == 'POST':
        form = FileChoiceForm(files, request.POST)
        
        if form.is_valid():
            if "delete" in request.POST: # If delete button is pressed
                filenames = [files[x].name for x in form.cleaned_data["files"]]
                return render_to_response('accounts/confirm_delete_undescribed_files.html', locals(), context_instance=RequestContext(request))
            elif "delete_confirm" in request.POST: # If confirmation delete button is pressed
                for file in form.cleaned_data["files"]:
                    os.remove(files[file].full_path)
                return HttpResponseRedirect(reverse('accounts-describe'))
            elif "describe" in request.POST: # If describe button is pressed
                # If only one file is choosen, go straight to the last step of the describe process, otherwise go to license selection step
                if len(form.cleaned_data["files"]) > 1 :
                    request.session['describe_sounds'] = [files[x] for x in form.cleaned_data["files"]]
                    return HttpResponseRedirect(reverse('accounts-describe-license'))
                else :
                    request.session['describe_sounds'] = [files[x] for x in form.cleaned_data["files"]]
                    return HttpResponseRedirect(reverse('accounts-describe-sounds'))
            else:
                form = FileChoiceForm(files) # Reset form
                return render_to_response('accounts/describe.html', locals(), context_instance=RequestContext(request))
    else:
        form = FileChoiceForm(files)
    return render_to_response('accounts/describe.html', locals(), context_instance=RequestContext(request))

@login_required
def describe_license(request):
    if request.method == 'POST':
        form = NewLicenseForm(request.POST)
        if form.is_valid():
            request.session['describe_license'] = form.cleaned_data['license']
            return HttpResponseRedirect(reverse('accounts-describe-pack'))
    else:
        form = NewLicenseForm({'license': License.objects.get(name='Attribution')})
    return render_to_response('accounts/describe_license.html', locals(), context_instance=RequestContext(request))

@login_required
def describe_pack(request):
    packs = Pack.objects.filter(user=request.user)
    if request.method == 'POST':
        form = PackForm(packs, request.POST, prefix="pack")
        if form.is_valid():
            data = form.cleaned_data
            if data['new_pack']:
                pack, created = Pack.objects.get_or_create(user=request.user, name=data['new_pack'])
                request.session['describe_pack'] = pack
            elif data['pack']:
                request.session['describe_pack'] = data['pack']
            else:
                request.session['describe_pack'] = False
            return HttpResponseRedirect(reverse('accounts-describe-sounds'))
    else:
        form = PackForm(packs, prefix="pack")
    return render_to_response('accounts/describe_pack.html', locals(), context_instance=RequestContext(request))


@login_required
@transaction.autocommit
def describe_sounds(request):
    # Tag recommendation research code (can be deleted in future)
    ONLY_RECOMMEND_TAGS_TO_HALF_OF_UPLOADS = settings.ONLY_RECOMMEND_TAGS_TO_HALF_OF_UPLOADS

    sounds_to_process = []
    sounds = request.session.get('describe_sounds', False)
    selected_license = request.session.get('describe_license', False)
    selected_pack = request.session.get('describe_pack', False)

    # This is to prevent people browsing to the /home/describe/sounds page
    # without going through the necessary steps.
    # selected_pack can be False, but license and sounds have to be picked at least
    if not (sounds):
        msg = 'Please pick at least one sound.'
        messages.add_message(request, messages.WARNING, msg)
        return HttpResponseRedirect(reverse('accounts-describe'))

    # So SOUNDS_PER_DESCRIBE_ROUND is available in the template
    sounds_per_round = SOUNDS_PER_DESCRIBE_ROUND
    sounds_to_describe = sounds[0:sounds_per_round]
    forms = []
    request.session['describe_sounds_number'] = len(request.session.get('describe_sounds'))

    # If there are no files in the session redirect to the first describe page
    if len(sounds_to_describe) <= 0:
        # Check if there is at least one message which is not saying that the sound was already part of freesound
        msg = 'You have finished describing your sounds.'
        messages.add_message(request, messages.WARNING, msg)
        return HttpResponseRedirect(reverse('accounts-describe'))

    if request.method == 'POST':

        # this is for tag recommendation logging purposes. can be deleted in a future
        # TAGRECOMMENDATION CODE
        try:
            tag_recommendation_random_session_id = int(request.POST['random_session_id'])
        except:
            tag_recommendation_random_session_id = False

        # first get all the data
        n_sounds_already_part_of_freesound = 0
        for i in range(len(sounds_to_describe)):
            prefix = str(i)
            forms.append({})
            forms[i]['sound'] = sounds_to_describe[i]
            forms[i]['description'] = SoundDescriptionForm(request.POST, prefix=prefix)
            forms[i]['geotag'] = GeotaggingForm(request.POST, prefix=prefix)
            forms[i]['pack'] = PackForm(Pack.objects.filter(user=request.user),
                                        request.POST,
                                        prefix=prefix)
            forms[i]['license'] = NewLicenseForm(request.POST, prefix=prefix)
        # validate each form
        for i in range(len(sounds_to_describe)):
            for f in ['license', 'geotag', 'pack', 'description']:
                if not forms[i][f].is_valid():
                    return render_to_response('accounts/describe_sounds.html',
                                              locals(),
                                              context_instance=RequestContext(request))

        # all valid, then create sounds and moderation tickets
        dirty_packs = []
        # TAGRECOMMENDATION CODE
        tag_recommendation_session_sound_id_links = []

        for i in range(len(sounds_to_describe)):
            sound = Sound()
            sound.user = request.user
            sound.original_filename = forms[i]['description'].cleaned_data['name']
            sound.original_path = forms[i]['sound'].full_path
            sound.filesize = os.path.getsize(sound.original_path)

            try:
                sound.md5 = md5file(forms[i]['sound'].full_path)
            except IOError:
                messages.add_message(request, messages.ERROR, 'Something went wrong with accessing the file %s.' % sound.original_path)
                continue
            sound.type = get_sound_type(sound.original_path)
            # check if file exists or not
            try:
                existing_sound = Sound.objects.get(md5=sound.md5)
                n_sounds_already_part_of_freesound += 1
                msg = 'The file %s is already part of freesound and has been discarded, see <a href="%s">here</a>' % \
                    (forms[i]['sound'].name, reverse('sound', args=[existing_sound.user.username, existing_sound.id]))
                messages.add_message(request, messages.WARNING, msg)
                os.remove(forms[i]['sound'].full_path)
                continue
            except Sound.DoesNotExist, e:
                pass

            # set the license
            sound.license = forms[i]['license'].cleaned_data['license']
            sound.save()
            # now move the original
            orig = os.path.splitext(os.path.basename(sound.original_filename))[0]
            sound.base_filename_slug = "%d__%s__%s" % (sound.id, slugify(sound.user.username), slugify(orig))
            new_original_path = sound.locations("path")
            if sound.original_path != new_original_path:
                try:
                    os.makedirs(os.path.dirname(new_original_path))
                except OSError:
                    pass
                try:
                    shutil.move(sound.original_path, new_original_path)
                    #shutil.copy(sound.original_path, new_original_path)
                except IOError, e:
                    logger.info("failed to move file from %s to %s" % (sound.original_path, new_original_path), e)
                logger.info("moved original file from %s to %s" % (sound.original_path, new_original_path))
                sound.original_path = new_original_path
                sound.save()

            # set the pack (optional)
            pack = forms[i]['pack'].cleaned_data.get('pack', False)
            new_pack = forms[i]['pack'].cleaned_data.get('new_pack', False)
            if not pack and new_pack:
                pack, created = Pack.objects.get_or_create(user=request.user, name=new_pack)
            if pack:
                sound.pack = pack
                dirty_packs.append(sound.pack)
            # set the geotag (if 'lat' is there, all fields are)
            data = forms[i]['geotag'].cleaned_data
            if not data.get('remove_geotag') and data.get('lat'):
                geotag = GeoTag(user=request.user,
                                lat=data.get('lat'),
                                lon=data.get('lon'),
                                zoom=data.get('zoom'))
                geotag.save()
                sound.geotag = geotag

            # set the tags and descriptions
            data = forms[i]['description'].cleaned_data
            sound.description = remove_control_chars(data.get('description', ''))
            sound.set_tags(data.get('tags'))
            sound.save()

            # add sound info in tagrecommendation log
            # TAGRECOMMENDATION CODE
            tag_recommendation_session_sound_id_links.append((forms[i]['description'].auto_id % i, sound.id))

            # remember to process the file
            sounds_to_process.append(sound)
            if request.user.profile.is_whitelisted:
                sound.moderation_state = 'OK'
                sound.save()
                messages.add_message(request, messages.INFO,
                                     'File <a href="%s">%s</a> has been described and has been added to freesound.' % \
                                     (sound.get_absolute_url(), forms[i]['sound'].name))
            else:
                # create moderation ticket!
                ticket = Ticket()
                ticket.title = 'Moderate sound %s' % sound.original_filename
                ticket.source = TICKET_SOURCE_NEW_SOUND
                ticket.status = TICKET_STATUS_NEW
                ticket.queue = Queue.objects.get(name='sound moderation')
                ticket.sender = request.user
                lc = LinkedContent()
                lc.content_object = sound
                lc.save()
                ticket.content = lc
                ticket.save()
                tc = TicketComment()
                tc.sender = request.user
                tc.text = "I've uploaded %s. Please moderate!" % sound.original_filename
                tc.ticket = ticket
                tc.save()
                # add notification that the file was described successfully
                messages.add_message(request, messages.INFO,
                                     'File <a href="%s">%s</a> has been described and is now awaiting processing and moderation.' % \
                                     (sound.get_absolute_url(), forms[i]['sound'].name))

                # TODO: comment here
                invalidate_template_cache("user_header", ticket.sender.id)
                moderators = Group.objects.get(name='moderators').user_set.all()
                for moderator in moderators:
                    invalidate_template_cache("user_header", moderator.id)


            # compute crc
            # TEMPORARY
            try:
                sound.compute_crc()
            except:
                pass

        # Save tag recommendation info in tagrecommendationresearch log
        # TAGRECOMMENDATION CODE
        if tag_recommendation_session_sound_id_links:
            research_logger.info('%s000#describing#%s#%i#-#SoundsSaved:%s' % (datetime.datetime.today().strftime('%s'),
                                                               tag_recommendation_random_session_id,
                                                               sound.user.id,
                                                               ','.join(['%s|%i' % (div_id, sound_id)  for div_id, sound_id in tag_recommendation_session_sound_id_links])))


        # remove the files we described from the session and redirect to this page
        request.session['describe_sounds'] = request.session['describe_sounds'][len(sounds_to_describe):]
        # Process the sound
        # N.B. we do this at the end to avoid conflicts between django-web and django-workers
        # If we're not careful django's save() functions will overwrite any processing we
        # do on the workers.
        try:
            for sound in sounds_to_process:
                sound.process()
        except Exception, e:
            audio_logger.error('Sound with id %s could not be scheduled. (%s)' % (sound.id, str(e)))
        for p in dirty_packs:
            p.process()
                            
        if len(request.session['describe_sounds']) <= 0:
            if len(sounds_to_describe) != n_sounds_already_part_of_freesound:
                msg = 'You have described all the selected files and are now awaiting processing and moderation. ' \
                      'You can check the status of your uploaded sounds in your <a href="%s">home page</a>. ' \
                      'Once your sounds have been processed, you can also get information about the moderation ' \
                      'status in the <a href="%s">uploaded sounds awaiting moderation</a> page.' % (reverse('accounts-home'), reverse('accounts-pending'))
                messages.add_message(request, messages.WARNING, msg)
            return HttpResponseRedirect(reverse('accounts-describe'))
        else:
            return HttpResponseRedirect(reverse('accounts-describe-sounds'))
    else:
        for i in range(len(sounds_to_describe)):
            prefix = str(i)
            forms.append({})
            forms[i]['sound'] = sounds_to_describe[i]
            forms[i]['description'] = SoundDescriptionForm(initial={'name': forms[i]['sound'].name}, prefix=prefix)
            forms[i]['geotag'] = GeotaggingForm(prefix=prefix)
            if selected_pack:
                forms[i]['pack'] = PackForm(Pack.objects.filter(user=request.user),
                                            prefix=prefix,
                                            initial={'pack': selected_pack.id})
            else:
                forms[i]['pack'] = PackForm(Pack.objects.filter(user=request.user),
                                            prefix=prefix)
            if selected_license:
                forms[i]['license'] = NewLicenseForm(initial={'license': selected_license},
                                                     prefix=prefix)
            else:
                forms[i]['license'] = NewLicenseForm(prefix=prefix)
            # cannot include this right now because the remix sources form needs a sound object
            #forms[prefix]['remix'] = RemixForm(prefix=prefix)
        #request.session['describe_sounds'] = request.session['describe_sounds'][5:]
    return render_to_response('accounts/describe_sounds.html', locals(), context_instance=RequestContext(request))


@login_required
def attribution(request):
    qs = Download.objects.filter(user=request.user)
    format = request.GET.get("format", "regular")
    return render_to_response('accounts/attribution.html', combine_dicts(paginate(request, qs, 40), locals()), context_instance=RequestContext(request))


def downloaded_sounds(request, username):
    user=get_object_or_404(User, username__iexact=username)
    qs = Download.objects.filter(user=user.id, sound__isnull=False)
    return render_to_response('accounts/downloaded_sounds.html', combine_dicts(paginate(request, qs, settings.SOUNDS_PER_PAGE), locals()), context_instance=RequestContext(request))

def downloaded_packs(request, username):
    user=get_object_or_404(User, username__iexact=username)
    qs = Download.objects.filter(user=user.id, pack__isnull=False)
    return render_to_response('accounts/downloaded_packs.html', combine_dicts(paginate(request, qs, settings.PACKS_PER_PAGE), locals()), context_instance=RequestContext(request))


def latest_content_type(scores):
        if  scores['uploads']>=scores['posts']and scores['uploads']>=scores['comments']:
            return 'sound'
        elif scores['posts']>=scores['uploads'] and scores['posts']>scores['comments']:
            return 'post'
        elif scores['comments']>=scores['uploads'] and scores['comments']>scores['posts']:
            return 'comment'

def create_user_rank(uploaders, posters, commenters):
    upload_weight = 1
    post_weight = 0.7
    comment_weight = 0.0

    user_rank = {}
    for user in uploaders:
        user_rank[user['user']] = {'uploads':user['id__count'], 'posts':0, 'comments':0, 'score':0}
    for user in posters:
        if user['author_id'] in user_rank.keys():
            user_rank[user['author_id']]['posts'] = user['id__count']
        else:
             user_rank[user['author_id']] = {'uploads':0, 'posts':user['id__count'], 'comments':0, 'score':0}
    for user in commenters:
        if user['user_id'] in user_rank.keys():
            user_rank[user['user_id']]['comments'] = user['id__count']
        else:
             user_rank[user['user_id']] = {'uploads':0, 'posts':0, 'comments':user['id__count'], 'score':0}
    sort_list = []
    for user in user_rank.keys():
        user_rank[user]['score'] =  user_rank[user]['uploads'] * upload_weight + \
            user_rank[user]['posts'] * post_weight + user_rank[user]['comments'] * comment_weight
        sort_list.append([user_rank[user]['score'],user])
    return user_rank, sort_list

def accounts(request):
    num_days = 14
    num_active_users = 10
    num_all_time_active_users = 10
    last_time = DBTime.get_last_time() - datetime.timedelta(num_days)

    # select active users last num_days
    latest_uploaders = Sound.public.filter(created__gte=last_time).values("user").annotate(Count('id')).order_by("-id__count")
    latest_posters = Post.objects.filter(created__gte=last_time).values("author_id").annotate(Count('id')).order_by("-id__count")
    latest_commenters = Comment.objects.filter(created__gte=last_time).values("user_id").annotate(Count('id')).order_by("-id__count")
    # rank
    user_rank,sort_list = create_user_rank(latest_uploaders,latest_posters,latest_commenters)

    #retrieve users lists
    most_active_users = User.objects.select_related("profile").filter(id__in=[u[1] for u in sorted(sort_list,reverse=True)[:num_active_users]])
    new_users = User.objects.select_related("profile").filter(date_joined__gte=last_time).filter(id__in=user_rank.keys()).order_by('-date_joined')[:num_active_users+5]
    logged_users = User.objects.select_related("profile").filter(id__in=get_online_users())

    # prepare for view
    most_active_users_display = [[u, latest_content_type(user_rank[u.id]), user_rank[u.id]] for u in most_active_users]
    most_active_users_display=sorted(most_active_users_display, key=lambda usr: user_rank[usr[0].id]['score'],reverse=True)
    new_users_display = [[u, latest_content_type(user_rank[u.id]), user_rank[u.id]] for u in new_users]

    # select all time active users
    # We store aggregate counts on the user profile for faster querying.
    all_time_uploaders = Profile.objects.extra(select={'id__count': 'num_sounds'}).order_by("-num_sounds").values("user", "id__count")[:num_all_time_active_users]
    all_time_posters = Profile.objects.extra(select={'id__count': 'num_posts', 'author_id': 'user_id'}).order_by("-num_posts").values("author_id", "id__count")[:num_all_time_active_users]
    # Performing a count(*) on Comment table is slow
    # TODO: Create num_comments on profile and query as above
    all_time_commenters = Comment.objects.all().values("user_id").annotate(Count('id')).order_by("-id__count")[:num_all_time_active_users]

    # rank
    user_rank,sort_list = create_user_rank(all_time_uploaders,all_time_posters,all_time_commenters)
    #retrieve users list
    all_time_most_active_users = User.objects.select_related("profile").filter(id__in=[u[1] for u in sorted(sort_list,reverse=True)[:num_all_time_active_users]])
    all_time_most_active_users_display = [[u, user_rank[u.id]] for u in all_time_most_active_users]
    all_time_most_active_users_display=sorted(all_time_most_active_users_display, key=lambda usr: user_rank[usr[0].id]['score'],reverse=True)

    return render_to_response('accounts/accounts.html', dict(most_active_users=most_active_users_display, all_time_most_active_users= all_time_most_active_users_display, new_users = new_users_display, logged_users = logged_users, user_rank=user_rank,num_days=num_days), context_instance=RequestContext(request))



def account(request, username):
    try:
        user = User.objects.select_related('profile').get(username__iexact=username)
    except User.DoesNotExist:
        raise Http404
    # expand tags because we will definitely be executing, and otherwise tags is called multiple times
    tags = list(user.profile.get_tagcloud() if user.profile else [])
    latest_sounds = Sound.public.filter(user=user).select_related('license', 'pack', 'geotag', 'user', 'user__profile')[0:settings.SOUNDS_PER_PAGE]
    latest_packs = Pack.objects.select_related().filter(user=user).filter(num_sounds__gt=0).order_by("-last_updated")[0:10]
    latest_geotags = Sound.public.select_related('license', 'pack', 'geotag', 'user', 'user__profile').filter(user=user).exclude(geotag=None)[0:10]
    google_api_key = settings.GOOGLE_API_KEY
    home = False
    has_bookmarks = Bookmark.objects.filter(user=user).exists()
    if not user.is_active:
        messages.add_message(request, messages.INFO, 'This account has <b>not been activated</b> yet.')

    return render_to_response('accounts/account.html', locals(), context_instance=RequestContext(request))

logger = logging.getLogger("upload")

def handle_uploaded_file(user_id, f):
    # handle a file uploaded to the app. Basically act as if this file was uploaded through FTP
    directory = os.path.join(settings.UPLOADS_PATH, str(user_id))

    logger.info("\thandling file upload")

    try:
        os.mkdir(directory)
    except:
        logger.info("\tfailed creating directory, probably already exist")
        pass

    path = os.path.join(directory, os.path.basename(f.name))
    try:
        logger.info("\topening file: %s", path)
        destination = open(path.encode("utf-8"), 'wb')
        for chunk in f.chunks():
            destination.write(chunk)
        logger.info("file upload done")
    except Exception, e:
        logger.warning("failed writing file error: %s", str(e))
        return False

    return True

@csrf_exempt
def upload_file(request):
    """ upload a file. This function does something weird: it gets the session id from the
    POST variables. This is weird but... as far as we know it's not too bad as we only need
    the user login """

    logger.info("start uploading file")

    # get the current session engine
    engine = __import__(settings.SESSION_ENGINE, {}, {}, [''])
    session_data = engine.SessionStore(request.POST.get('sessionid', ''))

    try:
        user_id = session_data['_auth_user_id']
        logger.info("\tuser id %s", str(user_id))
    except KeyError:
        logger.warning("failed to get user id from session")
        return HttpResponseBadRequest("You're not logged in. Log in and try again.")

    try:
        request.user = User.objects.get(id=user_id)
        logger.info("\tfound user: %s", request.user.username)
    except User.DoesNotExist:
        logger.warning("user with this id does not exist")
        return HttpResponseBadRequest("user with this ID does not exist.")

    if request.method == 'POST':
        form = UploadFileForm(request.POST, request.FILES)

        if form.is_valid():
            logger.info("\tform data is valid")
            if handle_uploaded_file(user_id, request.FILES["file"]):
                return HttpResponse("File uploaded OK")
            else:
                return HttpResponseServerError("Error in file upload")
        else:
            logger.warning("form data is invalid: %s", str(form.errors))
            return HttpResponseBadRequest("Form is not valid.")
    else:
        logger.warning("no data in post")
        return HttpResponseBadRequest("No POST data in request")

@login_required
def upload(request, no_flash = False):
    form = UploadFileForm()
    success = False
    error = False
    if no_flash:
        if request.method == 'POST':
            form = UploadFileForm(request.POST, request.FILES)
            if form.is_valid():
                if handle_uploaded_file(request.user.id, request.FILES["file"]):
                    uploaded_file=request.FILES["file"]
                    success = True
                else:
                    error = True
    return render_to_response('accounts/upload.html', locals(), context_instance=RequestContext(request))


@login_required
def delete(request):
    import time

    encrypted_string = request.GET.get("user", None)

    waited_too_long = False
    
    num_sounds = request.user.sounds.all().count()

    if encrypted_string != None:
        try:
            user_id, now = decrypt(encrypted_string).split("\t")
            user_id = int(user_id)

            if user_id != request.user.id:
                raise PermissionDenied

            link_generated_time = float(now)
            if abs(time.time() - link_generated_time) < 10:
                from forum.models import Post, Thread
                from comments.models import Comment
                from sounds.models import DeletedSound
            
                deleted_user = User.objects.get(id=settings.DELETED_USER_ID)
            
                for post in Post.objects.filter(author=request.user):
                    post.author = deleted_user
                    post.save()
                
                for thread in Thread.objects.filter(author=request.user):
                    thread.author = deleted_user
                    thread.save()
                    
                for comment in Comment.objects.filter(user=request.user):
                    comment.user = deleted_user
                    comment.save()

                for sound in DeletedSound.objects.filter(user=request.user):
                    sound.user = deleted_user
                    sound.save()

                request.user.delete()
                return HttpResponseRedirect(reverse("front-page"))
            else:
                waited_too_long = True
        except:
            pass

    encrypted_link = encrypt(u"%d\t%f" % (request.user.id, time.time()))

    return render_to_response('accounts/delete.html', locals(), context_instance=RequestContext(request))


def old_user_link_redirect(request):
    user_id = request.GET.get('id', False)
    if user_id:
        try:
            user = get_object_or_404(User, id=int(user_id))
            return HttpResponsePermanentRedirect(reverse("account", args=[user.username]))
        except ValueError:
            raise Http404
    else:
        raise Http404


# got characters from rfc3986 (minus @, + which are valid for django usernames)
BAD_USERNAME_CHARACTERS = {':': '_colon_',
                           '/': '_slash_',
                           '?': '_qmark_',
                           '#': '_hash_',
                           '[': '_lbrack1_',
                           ']': '_rbrack1_',
                           '!': '_emark_',
                           '$': '_dollar_',
                           '&': '_amper_',
                           "'": '_quote_',
                           '(': '_lbrack2_',
                           ')': '_rbrack2_',
                           '*': '_stardom_',
                           ',': '_comma_',
                           ';': '_scolon_',
                           '=': '_equal_',
                           '{': '_lbrack3_',
                           '}': '_rbrack3_'
                           }


def transform_username_fs1fs2(fs1_name, fs2_append=''):
    """ Returns a tuple (changed, name) where changed is a boolean
        indicating the name was transformed and name a string
        with the correct username for freesound 2
    """
    if any([x in fs1_name for x in BAD_USERNAME_CHARACTERS.keys()]):
        fs2_name = fs1_name
        for bad_char, replacement in BAD_USERNAME_CHARACTERS.items():
            fs2_name = fs2_name.replace(bad_char, replacement)
        fs2_name = '%s%s' % (fs2_name, fs2_append)

        # If the transformed name is too long, create a hash.
        if len(fs2_name) > 30:
            m = hashlib.md5()
            m.update(fs2_name.encode('utf-8'))
            # Hack: m.hexdigest() is too long.
            fs2_name = base64.urlsafe_b64encode(m.digest())
        return True, fs2_name
    else:
        return False, fs1_name


def login_wrapper(request):
    if request.method == "POST":
        old_name = request.POST.get('username', False)
        if old_name:
            changed, new_name = transform_username_fs1fs2(old_name)
            if changed:
                try:
                    # check if the new name actually exists
                    _ = User.objects.get(username=new_name)
                    msg = """Hi there! Your old username had some weird
    characters in it and we had to change it. It is now <b>%s</b>. If you don't like
    it, please contact us and we'll change it for you.""" % new_name
                    messages.add_message(request, messages.WARNING, msg)
                except User.DoesNotExist:
                    pass
    return authviews.login(request, template_name='accounts/login.html')


@login_required
def email_reset(request):

    if request.method == "POST":
        form = EmailResetForm(request.POST, user = request.user)
        if form.is_valid():

            # save new email info to DB (temporal)
            try:
                rer = ResetEmailRequest.objects.get(user=request.user)
                rer.email = form.cleaned_data['email']
            except ResetEmailRequest.DoesNotExist:
                rer = ResetEmailRequest(user=request.user, email=form.cleaned_data['email'])

            rer.save()


            # send email to the new address
            user = request.user
            email = form.cleaned_data["email"]
            current_site = get_current_site(request)
            site_name = current_site.name
            domain = current_site.domain

            c = {
                'email': email,
                'domain': domain,
                'site_name': site_name,
                'uid': int_to_base36(user.id),
                'user': user,
                'token': default_token_generator.make_token(user),
                'protocol': 'http',
            }

            subject = loader.render_to_string('accounts/email_reset_subject.txt', c)
            subject = ''.join(subject.splitlines())
            email_body = loader.render_to_string('accounts/email_reset_email.html', c)
            send_mail(subject=subject, email_body=email_body, email_to=[email])

            return HttpResponseRedirect(reverse('accounts.views.email_reset_done'))
    else:
        form = EmailResetForm(user = request.user)

    return render_to_response('accounts/email_reset_form.html',locals(),context_instance=RequestContext(request))


def email_reset_done(request):
    return render_to_response('accounts/email_reset_done.html',locals(),context_instance=RequestContext(request))


@never_cache
def email_reset_complete(request, uidb36=None, token=None):

    # Check that the link is valid and the base36 corresponds to a user id
    assert uidb36 is not None and token is not None # checked by URLconf
    try:
        uid_int = base36_to_int(uidb36)
        user = User.objects.get(id=uid_int)
    except (ValueError, User.DoesNotExist):
        raise Http404

    # Retreive the new mail from the DB
    try:
        rer = ResetEmailRequest.objects.get(user=user)
    except ResetEmailRequest.DoesNotExist:
        raise Http404

    # Change the mail in the DB
    old_email = user.email
    user.email = rer.email
    user.save()

    # Remove temporal mail change information ftom the DB
    ResetEmailRequest.objects.get(user=user).delete()

    return render_to_response('accounts/email_reset_complete.html',locals(),context_instance=RequestContext(request))

@login_required
def flag_user(request, username = None):

    if request.POST:
        flagged_user = User.objects.get(username__iexact=request.POST["username"])
        reporting_user = request.user
        object_id = request.POST["object_id"]

        if object_id:
            if request.POST["flag_type"] == "PM":
                flagged_object = Message.objects.get(id = object_id)
            elif request.POST["flag_type"] == "FP":
                flagged_object = Post.objects.get(id = object_id)
            elif request.POST["flag_type"] == "SC":
                flagged_object = Comment.objects.get(id = object_id)
            else:
                return HttpResponse(json.dumps({"errors":True}), mimetype='application/javascript')
        else:
            return HttpResponse(json.dumps({"errors":True}), mimetype='application/javascript')

        uflag = UserFlag(user = flagged_user, reporting_user = reporting_user, content_object = flagged_object)
        uflag.save()

        reports_count = UserFlag.objects.filter(user__username = flagged_user.username).values('reporting_user').distinct().count()
        if  reports_count == settings.USERFLAG_THRESHOLD_FOR_NOTIFICATION or reports_count == settings.USERFLAG_THRESHOLD_FOR_AUTOMATIC_BLOCKING:
            # Get all flagged objects by the user, create links to admin pages and send email
            flagged_objects = UserFlag.objects.filter(user__username = flagged_user.username)
            urls = []
            added_objects = []
            for object in flagged_objects:
                key = str(object.content_type) + str(object.object_id)
                if not key in added_objects:
                    added_objects.append(key)
                    try:
                        obj = object.content_type.get_object_for_this_type(id=object.object_id)
                        url = reverse('admin:%s_%s_change' %(obj._meta.app_label,  obj._meta.module_name),  args=[obj.id] )
                        urls.append([str(object.content_type),request.build_absolute_uri(url)])
                    except Exception:
                        urls.append([str(object.content_type),"url not available"])

            user_url = reverse('admin:%s_%s_delete' %(flagged_user._meta.app_label,  flagged_user._meta.module_name),  args=[flagged_user.id] )
            user_url = request.build_absolute_uri(user_url)
            clear_url = reverse("clear-flags-user", args=[flagged_user.username])
            clear_url = request.build_absolute_uri(clear_url)

            if reports_count < settings.USERFLAG_THRESHOLD_FOR_AUTOMATIC_BLOCKING:
                template_to_use = 'accounts/report_spammer_admins.txt'
            else:
                template_to_use = 'accounts/report_blocked_spammer_admins.txt'

            to_emails = []
            for mail in settings.ADMINS:
                to_emails.append(mail[1])
            send_mail_template(u'Spam report for user ' + flagged_user.username , template_to_use, locals(), None, to_emails)

        return HttpResponse(json.dumps({"errors":None}), mimetype='application/javascript')
    else:
        return HttpResponse(json.dumps({"errors":True}), mimetype='application/javascript')

@login_required
def clear_flags_user(request, username):
    if request.user.is_superuser or request.user.is_staff:
        flags = UserFlag.objects.filter(user__username = username)
        num = len(flags)
        for flag in flags:
            flag.delete()

        return render_to_response('accounts/flags_cleared.html',locals(),context_instance=RequestContext(request))
    else:
        return HttpResponseRedirect(reverse('accounts-login'))

def donate_redirect(request):
    pledgie_campaign_url = "http://pledgie.com/campaigns/%d/" % settings.PLEDGIE_CAMPAIGN
    return HttpResponseRedirect(pledgie_campaign_url)

@login_required
def pending(request):
    user = request.user
    tickets_sounds = TicketViews.get_pending_sounds(user)
    pendings = []
    for ticket, sound in tickets_sounds:
        last_comments = ticket.get_n_last_non_moderator_only_comments(3)
        pendings.append( (ticket, sound, last_comments) )

    show_pagination = len(pendings) > settings.SOUNDS_PENDING_MODERATION_PER_PAGE

    n_unprocessed_sounds = Sound.objects.select_related().filter(user=user).exclude(processing_state="OK").count()
    if n_unprocessed_sounds:
        messages.add_message(request, messages.WARNING, '%i of your recently uploaded sounds are still in processing '
                                                        'phase and therefore are not yet ready for moderation. These '
                                                        'sounds won\'t appear in this list until they are successfully '
                                                        'processed. This process should take no more than a few minutes.' % n_unprocessed_sounds)

    moderators_version = False
    return render_to_response('accounts/pending.html', combine_dicts(paginate(request, pendings, settings.SOUNDS_PENDING_MODERATION_PER_PAGE), locals()), context_instance=RequestContext(request))

########NEW FILE########
__FILENAME__ = admin
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.contrib import admin
from api.models import ApiKey

class ApiKeyAdmin(admin.ModelAdmin):
    raw_id_fields = ('user',) 
    search_fields = ('=user__username', )
    list_filter = ('status', )
    list_display = ("key", "user", "status")

admin.site.register(ApiKey, ApiKeyAdmin)
########NEW FILE########
__FILENAME__ = api_utils
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

import settings
from piston.utils import rc
import traceback
from models import ApiKey
from apiv2.models import ApiV2Client
from piston.emitters import Emitter
from piston.handler import typemapper
import logging

logger = logging.getLogger("api")

def build_error_response(e, request):
    
    #logger.error(str(e.status_code) + ' API error: ' + e.type)
    content = {"error": True,
               "type": e.type,
               "status_code": e.status_code,
               "explanation": ""}
    content.update(e.extra)
    response = rc.BAD_REQUEST
    format = request.GET.get("format", "json")
    
    em_info = Emitter.get(format)
    RequestEmitter = em_info[0]
    emitter = RequestEmitter(content, typemapper, "", "", False)
    response.content = emitter.render(request)
    response['Content-Type'] = em_info[1]

    return response
    

class ReturnError(Exception):
    def __init__(self, status_code, type, extra):
        self.status_code = status_code
        self.type = type
        self.extra = extra

def build_unexpected(e, request):
    debug = traceback.format_exc() if settings.DEBUG else str(e)
    logger.error('500 API error: Unexpected')
    
    return build_error_response(ReturnError(500,
                                            "InternalError",
                                            {"explanation":
                                             "An internal Freesound error ocurred.",
                                             "really_really_sorry": True,
                                             "debug": debug}
                                             ), request)

def create_unexpected_error(e):
    if settings.DEBUG:
        debug = traceback.format_exc() if settings.DEBUG else str(e)
    else:
        debug = "-"
        #logger.error('500 API error: Unexpected')
    return ReturnError(500,
                       "InternalError",
                       {"explanation": "An internal Freesound error ocurred.",
                        "really_really_sorry": True,
                        "debug": debug})


def build_invalid_url(e):
    format = e.GET.get("format", "json")
    logger.error('404 API error: Invalid Url')
    
    return build_error_response(ReturnError(404,
                                            "InvalidUrl",
                                            {"explanation":
                                             "The introduced url is invalid.",}
                                             ), e)

class auth():

    def __init__(self, get_parameter='api_key'): # FROM FREESOUND
        self.get_parameter = get_parameter

    def __call__(self, f):
        """
        If there are decorator arguments, __call__() is only called
        once, as part of the decoration process! You can only give
        it a single argument, which is the function object.
        """
        def decorated_api_func(handler, request, *args, **kargs):
            try:

                # Try to get the api key
                api_key = request.GET.get(self.get_parameter, False)
                if not api_key:
                    logger.error('401 API error: Authentication error (no api key supplied)')
                    raise ReturnError(401, "AuthenticationError",
                                          {"explanation":  "Please include your api key as the api_key GET parameter"},
                                          )
                try:
                    db_api_key = ApiKey.objects.get(key=api_key, status='OK')
                except ApiKey.DoesNotExist:
                    if not settings.APIV2KEYS_ALLOWED_FOR_APIV1:
                        logger.error('401 API error: Authentication error (wrong api key)')
                        raise ReturnError(401, "AuthenticationError",
                                          {"explanation":  "Supplied api_key does not exist"},
                                          )
                    else:
                        # Look for the key in the ApiV2Client models. In this way keys for ApiV2 can be used for ApiV1
                        try:
                            db_api_key = ApiV2Client.objects.get(key=api_key, status='OK')

                        except ApiV2Client.DoesNotExist:
                            logger.error('401 API error: Authentication error (wrong api key)')
                            raise ReturnError(401, "AuthenticationError",
                                          {"explanation":  "Supplied api_key does not exist"},
                                          )

                request.user = db_api_key.user
                return f(handler, request, *args, **kargs)
            except ReturnError, e:
                return build_error_response(e, request)
            except Exception, e:
                return build_unexpected(e, request)

        return decorated_api_func
########NEW FILE########
__FILENAME__ = forms
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

import django.forms as forms

class ApiKeyForm(forms.Form):
    name          = forms.CharField(label='Application name', widget=forms.TextInput(attrs={'style': 'width:500px'}))
    url           = forms.URLField(label='Application url', widget=forms.TextInput(attrs={'style': 'width:500px'}))
    description   = forms.CharField(label='Describe your application', widget=forms.Textarea(attrs={'style': 'width:500px'}))
    accepted_tos  = forms.BooleanField(label='',
                                       help_text='Check this box to accept the <a href="/help/tos_api/" target="_blank">terms of use</a> of the Freesound API',
                                       required=True,
                                       error_messages={'required': 'You must accept the terms of use in order to get an API key.'})
########NEW FILE########
__FILENAME__ = handlers
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.conf import settings
from piston.handler import BaseHandler
from piston.utils import rc
from search.forms import SoundSearchForm
from apiv2.forms import SEARCH_SORT_OPTIONS_API
from search.views import search_prepare_sort, search_prepare_query
from sounds.models import Sound, Pack, Download
from bookmarks.models import Bookmark, BookmarkCategory
from utils.search.solr import Solr, SolrQuery, SolrException, SolrResponseInterpreter, SolrResponseInterpreterPaginator
import logging
from django.contrib.auth.models import User
from utils.search.search import add_all_sounds_to_solr
from django.contrib.sites.models import Site
from utils.pagination import paginate
from django.core.urlresolvers import reverse
from utils.nginxsendfile import sendfile
import yaml
from utils.similarity_utilities import get_similar_sounds, api_search, get_sounds_descriptors
from similarity.client import Similarity
from api.api_utils import auth, ReturnError#, parse_filter, parse_target
import os
from django.contrib.syndication.views import Feed
from urllib import quote
from django.core.cache import cache
from similarity.client import SimilarityException

logger = logging.getLogger("api")

# UTILITY FUNCTIONS

def my_quote(s):
    return quote(s,safe=":[]*+()'")

def prepend_base(rel):
    return "http://%s%s" % (Site.objects.get_current().domain, rel)

def get_sound_api_url(id):
    return prepend_base(reverse('api-single-sound', args=[id]))

def get_sound_api_analysis_url(id):
    return prepend_base(reverse('api-sound-analysis', args=[id]))

def get_sound_web_url(username, id):
    return prepend_base(reverse('sound', args=[username, id]))
    
def get_user_api_url(username):
    return prepend_base(reverse('api-single-user', args=[username]))

def get_user_web_url(username):
    return prepend_base(reverse('account', args=[username]))

def get_bookmark_category_api_url(username, category_id):
    return prepend_base(reverse('api-user-bookmark-category', args=[username, category_id]))

def get_bookmark_category_web_url(username, category_id):
    return prepend_base(reverse('bookmarks-for-user-for-category', args=[username, category_id]))

def get_user_sounds_api_url(username):
    return prepend_base(reverse('api-user-sounds', args=[username]))

def get_user_packs_api_url(username):
    return prepend_base(reverse('api-user-packs', args=[username]))

def get_user_bookmark_categories_api_url(username):
    return prepend_base(reverse('api-user-bookmark-categories', args=[username]))

def get_pack_api_url(pack_id):
    return prepend_base(reverse('api-single-pack', args=[pack_id]))

def get_pack_web_url(username, pack_id):
    return prepend_base(reverse('pack', args=[username, pack_id]))

def get_pack_sounds_api_url(pack_id):
    return prepend_base(reverse('api-pack-sounds', args=[pack_id]))

def get_sound_links(sound):
    ref = get_sound_api_url(sound.id)

    d = {
        'ref': ref,
        'url': get_sound_web_url(sound.user.username, sound.id),
        'serve': ref+'serve/',
        'preview-hq-mp3'   : prepend_base(sound.locations("preview.HQ.mp3.url")),
        'preview-hq-ogg'   : prepend_base(sound.locations("preview.HQ.ogg.url")),
        'preview-lq-mp3'   : prepend_base(sound.locations("preview.LQ.mp3.url")),
        'preview-lq-ogg'   : prepend_base(sound.locations("preview.LQ.ogg.url")),
        'waveform_m': prepend_base(sound.locations("display.wave.M.url")),
        'waveform_l': prepend_base(sound.locations("display.wave.L.url")),
        'spectral_m': prepend_base(sound.locations("display.spectral.M.url")),
        'spectral_l': prepend_base(sound.locations("display.spectral.L.url")),
        'analysis_stats': get_sound_api_analysis_url(sound.id),
        'analysis_frames': prepend_base(sound.locations("analysis.frames.url")),
        'similarity': ref+'similar/',
         }
    if sound.pack_id:
        d['pack'] = get_pack_api_url(sound.pack_id)
    return d

def prepare_minimal_user(user):
    return {'username': user.username,
            'ref': get_user_api_url(user.username),
            'url': get_user_web_url(user.username),}

def prepare_single_sound(sound):
    d = {}
    for field in ["num_downloads", "channels", "duration", "samplerate", "samplerate", \
                  "id", "num_comments", "num_ratings", "filesize", \
                  "type", "description", "bitdepth", "bitrate",  "created", \
                  "avg_rating", "original_filename"]:
        d[field] = getattr(sound, field)
    try:
        d['license'] = sound.license.deed_url
    except:
        pass
    try:
        d['geotag'] = {'lat':sound.geotag.lat,'lon':sound._geotag_cache.lon}
    except:
        pass
    d['user'] = prepare_minimal_user(sound.user)
    d['tags'] = get_tags(sound)
    d.update(get_sound_links(sound))
    return d

def prepare_collection_sound(sound, include_user=True, include_geotag=False, custom_fields = False, extra_properties = None):
    if not custom_fields:
        d = {}
        for field in ["duration", "type", "original_filename", "id"]:
            d[field] = getattr(sound, field)
        if include_user:
            d['user'] = prepare_minimal_user(sound.user)
        d['tags'] = get_tags(sound)
        
        if include_geotag:
            try:
                d['geotag'] = {'lat':sound.geotag.lat,'lon':sound._geotag_cache.lon}
            except:
                pass

        d.update(get_sound_links(sound))

        if extra_properties:
            d.update(extra_properties)

        return d
    else:
        single_sound_prepared = prepare_single_sound(sound)
        if extra_properties:
            single_sound_prepared.update(extra_properties)

        custom_fields = custom_fields.split(",")
        d = {}
        for field in custom_fields:
            if field in single_sound_prepared.keys():
                d[field] = single_sound_prepared[field]
        return d

def prepare_single_sound_analysis(sound,request,filter):

    try:
        # Load file from disk
        #analysis = yaml.load(file(sound.locations('analysis.statistics.path')))

        # Get data from gaia
        analysis = get_sounds_descriptors([sound.id], [], normalization=False, only_leaf_descriptors=False)[str(sound.id)]
    except Exception, e:
        raise e
        raise Exception('Could not load analysis data.')

    # only show recommended descriptors
    if not ('all' in request.GET and request.GET['all'] in ['1', 'true', 'True']) and not filter:
        analysis = level_filter(analysis, RECOMMENDED_DESCRIPTORS)

    if filter:
        filters = filter.split('/')
        filters = [str(x) for x in filters if x != u'']
        while len(filters) > 0:
            try:
                analysis = analysis.get(filters[0], None)
                if analysis == None:
                    raise Exception('No data here')
                filters = filters[1:]
            except:
                raise ReturnError(400, "InvalidRequest", {"explanation": "Could not find this path in the analysis data."})

    return analysis


def level_filter(d, fields, sep='.'):
    new_d = {}
    for f in fields:
        fs = f.split(sep)
        level_filter_set(new_d, fs, level_filter_get(d, fs))
    return new_d

def level_filter_set(d, levels, value):
    if len(levels) <= 0:
        return d
    if len(levels) == 1:
        d[levels[0]] = value
    else:
        if not d.has_key(levels[0]):
            d[levels[0]] = {}
        level_filter_set(d[levels[0]], levels[1:], value)
    return d

def level_filter_get(d, levels):
    if len(levels) <= 0:
        return d
    if len(levels) == 1:
        return d.get(levels[0], '')
    else:
        return level_filter_get(d[levels[0]], levels[1:])


RECOMMENDED_DESCRIPTORS = [ #'metadata.audio_properties',
                            #'highlevel.culture',
                            #'highlevel.gender',
                            #'highlevel.moods',
                            #'highlevel.timbre',
                            #'highlevel.voice_instrumental',
                            #'highlevel.acoustic',
                            #'highlevel.electronic',
                            'tonal.key_key',
                            'tonal.key_scale',
                            'tonal.key_strength',
                            'tonal.tuning_frequency',
                            'rhythm.bpm',
                            'lowlevel.average_loudness',
                            'lowlevel.dissonance.mean',
                            'lowlevel.pitch.mean',
                            'lowlevel.pitch_salience.mean',
                            'lowlevel.spectral_centroid.mean',
                            'lowlevel.mfcc.mean'
                            ]

def get_tags(sound):
    return [tagged.tag.name for tagged in sound.tags.select_related("tag").all()]

def prepare_single_user(user):
    d = {}
    for field in ["username", "first_name", "last_name", "date_joined"]:
        d[field] = getattr(user, field)
    d['ref'] = get_user_api_url(user.username)
    d['url'] = get_user_web_url(user.username)
    d['about'] = user.profile.about
    d['home_page'] = user.profile.home_page
    d['signature'] = user.profile.signature
    d['sounds'] = get_user_sounds_api_url(user.username)
    d['packs'] = get_user_packs_api_url(user.username)
    d['bookmark_categories'] = get_user_bookmark_categories_api_url(user.username)
    return d

def prepare_single_pack(pack, include_user=True, include_description=False):
    d = {}
    for field in ["name", "num_downloads", "created"]:
        d[field] = getattr(pack, field)
    user = User.objects.get(id=pack.user_id)
    if include_user:
        d['user'] = prepare_minimal_user(user)
    if include_description:
        d['description'] = pack.description
    d['ref'] = get_pack_api_url(pack.id)
    d['url'] = get_pack_web_url(user.username, pack.id)
    d['sounds'] = get_pack_sounds_api_url(pack.id)
    return d

def prepare_single_bookmark_category(username, category):
    d = {}
    d['id'] = category.id
    d['name'] = category.name
    d['url'] = get_bookmark_category_web_url(username, category.id)
    d['sounds'] = get_bookmark_category_api_url(username, category.id)
    return d

def find_api_option(cleaned_sort):
    for t in SEARCH_SORT_OPTIONS_API:
        if t[1] == cleaned_sort:
            return t[0]
    return None

def add_request_id(request,result):
    if request.GET.get('request_id', '') != '':
        result['request_id'] = request.GET.get('request_id', '')

# HANDLERS

class SoundSearchHandler(BaseHandler):
    '''
    api endpoint:   /sounds/search
    '''
    allowed_methods = ('GET',)

    '''
    input:          q, f, p, s
    output:         #paginated_search_results#
    curl:           curl http://www.freesound.org/api/sounds/search/?q=hoelahoep
    '''

    @auth()
    def read(self, request):
        
        form = SoundSearchForm(SEARCH_SORT_OPTIONS_API, request.GET)
        if not form.is_valid():
            resp = rc.BAD_REQUEST
            resp.content = form.errors
            return resp

        cd = form.cleaned_data
        grouping = request.GET.get('g', "")
        if grouping == "0":
            grouping = ""

        solr = Solr(settings.SOLR_URL)
        sounds_per_page = min(int(request.GET.get('sounds_per_page', settings.SOUNDS_PER_API_RESPONSE)),settings.MAX_SOUNDS_PER_API_RESPONSE)
        query = search_prepare_query(cd['q'],
                                     cd['f'],
                                     search_prepare_sort(cd['s'], SEARCH_SORT_OPTIONS_API),
                                     cd['p'],
                                     sounds_per_page,
                                     grouping = grouping)

        try:
            results = SolrResponseInterpreter(solr.select(unicode(query)))
            paginator = SolrResponseInterpreterPaginator(results,sounds_per_page)
            page = paginator.page(form.cleaned_data['p'])
            sounds = []
            bad_results = 0
            for object in page['object_list'] :
                try:
                    sound = prepare_collection_sound(Sound.objects.select_related('user').get(id=object['id']), custom_fields = request.GET.get('fields', False))
                    if 'more_from_pack' in object.keys():
                        if object['more_from_pack'] > 0:
                            link = prepend_base(reverse('api-search')+'?q=%s&f=pack:"%s" %s&s=%s&g=%s' % (my_quote(cd['q']),object['pack_name'],my_quote(cd['f']),cd['s'],""))
                            if request.GET.get('sounds_per_page', None):
                                link += "&sounds_per_page=" +  str(request.GET.get('sounds_per_page', None))
                            if request.GET.get('fields', False):
                                link += "&fields=" + str(request.GET.get('fields', False))
                            sound['results_from_the_same_pack'] = link
                            sound['n_results_from_the_same_pack'] = object['more_from_pack']
                    sounds.append(sound)
                except: # This will happen if there are synchronization errors between solr index and the database. In that case sounds are ommited and both num_results and results per page might become inacurate
                    pass
            result = {'sounds': sounds, 'num_results': paginator.count - bad_results, 'num_pages': paginator.num_pages}

            # construct previous and next urls
            if page['has_other_pages']:
                if page['has_previous']:
                    result['previous'] = self.__construct_pagination_link(cd['q'],
                                                                          page['previous_page_number'],
                                                                          cd['f'],
                                                                          find_api_option(cd['s']),
                                                                          request.GET.get('sounds_per_page', None),
                                                                          request.GET.get('fields', False),
                                                                          grouping)
                if page['has_next']:
                    result['next'] = self.__construct_pagination_link(cd['q'],
                                                                      page['next_page_number'],
                                                                      cd['f'],
                                                                      find_api_option(cd['s']),
                                                                      request.GET.get('sounds_per_page',None),
                                                                      request.GET.get('fields', False),
                                                                      grouping)
            add_request_id(request,result)
            logger.info("Searching,q=" + cd['q'] + ",f=" + cd['f'] + ",p=" + str(cd['p']) + ",sounds_per_page=" + str(sounds_per_page) + ",api_key=" + request.GET.get("api_key", False) + ",api_key_username=" + request.user.username)
            return result

        except SolrException, e:
            error = "search_query %s filter_query %s sort %s error %s" \
                        % (cd['s'], cd['f'], cd['s'], e)
            raise ReturnError(500, "SearchError", {"explanation": error})


    def __construct_pagination_link(self, q, p, f, s, spp, fields, grouping):
        link = prepend_base(reverse('api-search')+'?q=%s&p=%s&f=%s&s=%s&g=%s' % (my_quote(q),p,my_quote(f),s,grouping))
        if spp:
            link += "&sounds_per_page=" +  str(spp)
        if fields:
            link += "&fields=" + str(fields)
        return link


class SoundContentSearchHandler(BaseHandler):
    '''
    api endpoint:   /sounds/content_search
    '''
    allowed_methods = ('GET',)

    '''
    input:          t, f, p
    output:         #paginated_search_results#
    curl:           curl http://www.freesound.org/api/sounds/content_search/?t=".lowlevel.pitch.mean:220.56"
    '''

    @auth()
    def read(self, request):
        t = request.GET.get("t", "")
        f = request.GET.get("f", "")

        if not t and not f:
            raise ReturnError(400, "BadRequest", {"explanation": "Introduce either a target, a filter or both."})
        try:
            results, count, note = api_search(target=t, filter=f, num_results=int(request.GET.get('max_results', settings.SOUNDS_PER_PAGE)))
        except SimilarityException, e:
            raise ReturnError(e.status_code, "SimilarityError", {"explanation": e.message})
        except Exception, e:
            if str(e)[0:6] == u"Target" or str(e)[0:6] == u"Filter":
                raise ReturnError(400, "BadRequest", {'explanation':e})
            else:
                raise ReturnError(500, "ContentBasedSearchError", {'explanation':'Unknown error 500'})

        paginator = paginate(request, results, min(int(request.GET.get('sounds_per_page', settings.SOUNDS_PER_API_RESPONSE)),settings.MAX_SOUNDS_PER_API_RESPONSE),'p')
        page = paginator['page']
        sounds = []
        if int(request.GET.get("p", "1")) <= paginator['paginator'].num_pages: # This is to mimic solr paginator behavior
            for result in page.object_list:
                try:
                    sound = prepare_collection_sound(Sound.objects.select_related('user').get(id=int(result[0])), include_user=False, custom_fields = request.GET.get('fields', False))
                    sounds.append(sound)
                except Exception, e:
                    # Delete sound from gaia index so it does not appear again in similarity searches
                    if Similarity.contains(int(result[0])):
                        Similarity.delete(int(result[0]))
                    # Invalidate similarity search cache
                    cache_key = "content-based-search-t-%s-f-%s-nr-%s" % (t.replace(" ",""),f.replace(" ",""),int(request.GET.get('max_results', settings.SOUNDS_PER_PAGE)))
                    cache.delete(cache_key)

        #sounds = [prepare_collection_sound(Sound.objects.select_related('user').get(id=int(result[0])), include_user=False, custom_fields = request.GET.get('fields', False)) for result in page.object_list]
        result = {'sounds': sounds,  'num_results': paginator['paginator'].count, 'num_pages': paginator['paginator'].num_pages}

        if int(request.GET.get("p", "1")) <= paginator['paginator'].num_pages: # This is to mimic solr paginator behavior
            if page.has_other_pages():
                if page.has_previous():
                    result['previous'] = self.__construct_pagination_link(str(t), str(f), page.previous_page_number(), request.GET.get('sounds_per_page',None), int(request.GET.get('max_results', False)), request.GET.get('fields', False))
                if page.has_next():
                    result['next'] = self.__construct_pagination_link(str(t), str(f), page.next_page_number(), request.GET.get('sounds_per_page',None), int(request.GET.get('max_results', False)), request.GET.get('fields', False))

        add_request_id(request,result)

        logger.info("Content searching, t=" + str(t) + ", f=" + str(f) + ", api_key=" + request.GET.get("api_key", False) + ",api_key_username=" + request.user.username)
        return result

    def __construct_pagination_link(self, t, f, p, spp, num_results, fields):

        link = prepend_base(reverse('api-content-search')+'?t=%s&f=%s&p=%s' % (my_quote(t.replace('"',"'")),my_quote(f.replace('"',"'")),p))#get_user_sounds_api_url(u)+'?p=%s' % p
        if spp:
            link += "&sounds_per_page=" + str(spp)
        if num_results:
            link += "&max_results=" + str(num_results)
        if fields:
            link += "&fields=" + str(fields)
        return link


class SoundHandler(BaseHandler):
    '''
    api endpoint:   /sounds/<sound_id>
    '''
    allowed_methods = ('GET',)

    '''
    input:          n.a.
    output:         #single_sound#
    curl:           curl http://www.freesound.org/api/sounds/2
    '''

    @auth()
    def read(self, request, sound_id):

        try:
            sound = Sound.objects.select_related('geotag', 'user', 'license', 'tags').get(id=sound_id, moderation_state="OK", processing_state="OK")
        except Sound.DoesNotExist: #@UndefinedVariable
            raise ReturnError(404, "NotFound", {"explanation": "Sound with id %s does not exist." % sound_id})

        result = prepare_single_sound(sound)

        add_request_id(request,result)
        logger.info("Sound info,id=" + sound_id + ",api_key=" + request.GET.get("api_key", False) + ",api_key_username=" + request.user.username)
        return result

class SoundServeHandler(BaseHandler):
    '''
    api endpoint:    /sounds/serve|preview
    '''
    allowed_methods = ('GET',)

    '''
    input:        n.a.
    output:       binary file
    curl:         curl http://www.freesound.org/api/sounds/2/serve
    '''

    @auth()
    def read(self, request, sound_id):
        
        try:
            sound = Sound.objects.get(id=sound_id, moderation_state="OK", processing_state="OK")            
        except Sound.DoesNotExist: #@UndefinedVariable
            raise ReturnError(404, "NotFound", {"explanation": "Sound with id %s does not exist." % sound_id})
        
        # Check if file actually exists in the hard drive
        if not os.path.exists(sound.locations('path')) :
            raise ReturnError(404, "NotFound", {"explanation": "Sound with id %s is not available for download." % sound_id})
        
        # DISABLED (FOR THE MOMENT WE DON'T UPDATE DOWNLOADS TABLE THROUGH API)
        #Download.objects.get_or_create(user=request.user, sound=sound, interface='A')
        
        logger.info("Serving sound,id=" + sound_id + ",api_key=" + request.GET.get("api_key", False) + ",api_key_username=" + request.user.username)
        return sendfile(sound.locations("path"), sound.friendly_filename(), sound.locations("sendfile_url"))


class SoundSimilarityHandler(BaseHandler):
    '''
    api endpoint:    /sounds/<sound_id>/similarity
    '''
    allowed_methods = ('GET',)

    '''
    input:        n.a.
    output:       #collection_of_similar_sounds#
    curl:         curl http://www.freesound.org/api/sounds/2/similar
    '''

    @auth()
    def read(self, request, sound_id):
        
        try:
            sound = Sound.objects.get(id=sound_id, moderation_state="OK", processing_state="OK", similarity_state="OK")
            #TODO: similarity_state="OK"
            #TODO: this filter has to be added again, but first the db has to be updated

        except Sound.DoesNotExist: #@UndefinedVariable
            raise ReturnError(404, "NotFound", {"explanation": "Sound with id %s does not exist or similarity data is not ready." % sound_id})

        try:
            similar_sounds, count, note = api_search(target=str(sound.id), preset=request.GET.get('preset', None), num_results=int(request.GET.get('num_results', settings.SOUNDS_PER_PAGE)))
        except SimilarityException, e:
            raise ReturnError(404, "NotFound", {"explanation": e})

        sounds = []
        for similar_sound in similar_sounds:
            try:
                sound = prepare_collection_sound(Sound.objects.select_related('user').get(id=similar_sound[0]), custom_fields = request.GET.get('fields', False))
                sound['distance'] = similar_sound[1]
                sounds.append(sound)
            except Exception, e:
                # Delete sound from gaia index so it does not appear again in similarity searches
                if Similarity.contains(similar_sound[0]):
                    Similarity.delete(similar_sound[0])
                # Invalidate similarity search cache
                cache_key = "similar-for-sound-%s-%s" % (similar_sound[0], request.GET.get('preset', None))
                cache.delete(cache_key)

        result = {'sounds': sounds, 'num_results': len(sounds)}
        add_request_id(request,result)
        logger.info("Sound similarity,id=" + sound_id + ",api_key=" + request.GET.get("api_key", False) + ",api_key_username=" + request.user.username)
        return result



class SoundAnalysisHandler(BaseHandler):
    '''
    api endpoint:   /sounds/<sound_id>/analysis/<filter>
    '''
    allowed_methods = ('GET',)

    '''
    input:          n.a.
    output:         #single_sound_analysis#
    curl:           curl http://www.freesound.org/api/sounds/2/analysis
    '''

    @auth()
    def read(self, request, sound_id, filter=False):

        try:
            sound = Sound.objects.select_related('geotag', 'user', 'license', 'tags').get(id=sound_id, moderation_state="OK", analysis_state="OK")
        except Sound.DoesNotExist: #@UndefinedVariable
            raise ReturnError(404, "NotFound", {"explanation": "Sound with id %s does not exist or analysis data is not ready." % sound_id})
        
        # TODO: check 404 in http://tabasco.upf.edu/api/sounds/52749/analysis/?api_key=*

        result = prepare_single_sound_analysis(sound,request,filter)

        add_request_id(request,result)
        logger.info("Sound analysis,id=" + sound_id + ",api_key=" + request.GET.get("api_key", False) + ",api_key_username=" + request.user.username)
        return result

"""
# For future use (when we serve analysis files through autenthication)
class SoundAnalysisFramesHandler(BaseHandler):
    '''
    api endpoint:   /sounds/<sound_id>/analysis_frames
    '''
    allowed_methods = ('GET',)

    '''
    #input:          n.a.
    #output:         binary file
    #curl:           curl http://www.freesound.org/api/sounds/2/analysis_frames
    '''

    def read(self, request, sound_id, filter=False):

        try:
            sound = Sound.objects.select_related('geotag', 'user', 'license', 'tags').get(id=sound_id, moderation_state="OK", analysis_state="OK")
        except Sound.DoesNotExist: #@UndefinedVariable
            resp = rc.NOT_FOUND
            resp.content = 'There is no sound with id %s or analysis is not ready' % sound_id
            return resp

        return sendfile(sound.locations('analysis.frames.path'), sound.friendly_filename().split('.')[0] + '.json', sound.locations("sendfile_url").split('.')[0] + '.json')
"""

class SoundGeotagHandler(BaseHandler):
    '''
    api endpoint:   /sounds/geotag/
    '''
    allowed_methods = ('GET',)

    '''
    input:          min_lat, max_lat, min_lon, max_lon, p
    output:         #paginated_sound_results#
    curl:           curl http://www.freesound.org/api/sounds/geotag/?min_lon=2.005176544189453&max_lon=2.334766387939453&min_lat=41.3265528618605&max_lat=41.4504467428547
    '''

    @auth()
    def read(self, request):
        
        min_lat = request.GET.get('min_lat', 0.0)
        max_lat = request.GET.get('max_lat', 0.0)
        min_lon = request.GET.get('min_lon', 0.0)
        max_lon = request.GET.get('max_lon', 0.0)
        
        if min_lat <= max_lat and min_lon <= max_lon:
            raw_sounds = Sound.objects.select_related("geotag").exclude(geotag=None).filter(moderation_state="OK", processing_state="OK").filter(geotag__lat__range=(min_lat,max_lat)).filter(geotag__lon__range=(min_lon,max_lon))
        elif min_lat > max_lat and min_lon <= max_lon:
            raw_sounds = Sound.objects.select_related("geotag").exclude(geotag=None).filter(moderation_state="OK", processing_state="OK").exclude(geotag__lat__range=(max_lat,min_lat)).filter(geotag__lon__range=(min_lon,max_lon))
        elif min_lat <= max_lat and min_lon > max_lon:
            raw_sounds = Sound.objects.select_related("geotag").exclude(geotag=None).filter(moderation_state="OK", processing_state="OK").filter(geotag__lat__range=(min_lat,max_lat)).exclude(geotag__lon__range=(max_lon,min_lon))
        elif min_lat > max_lat and min_lon > max_lon:
            raw_sounds = Sound.objects.select_related("geotag").exclude(geotag=None).filter(moderation_state="OK", processing_state="OK").exclude(geotag__lat__range=(max_lat,min_lat)).exclude(geotag__lon__range=(max_lon,min_lon))
        else:
            return ReturnError(400, "BadRequest", {"explanation": "Parameters min_lat, max_lat, min_long and max_log are not correctly defined."})

        paginator = paginate(request, raw_sounds, min(int(request.GET.get('sounds_per_page', settings.SOUNDS_PER_API_RESPONSE)),settings.MAX_SOUNDS_PER_API_RESPONSE), 'p')
        page = paginator['page']
        if int(request.GET.get("p", "1")) <= paginator['paginator'].num_pages: # This is to mimic solr paginator behavior
            sounds = [prepare_collection_sound(sound, include_user=True, include_geotag=True, custom_fields = request.GET.get('fields', False)) for sound in page.object_list]
        else:
            sounds = []
        result = {'sounds': sounds, 'num_results': paginator['paginator'].count, 'num_pages': paginator['paginator'].num_pages}
        if int(request.GET.get("p", "1")) <= paginator['paginator'].num_pages: # This is to mimic solr paginator behavior
            if page.has_other_pages():
                if page.has_previous():
                    result['previous'] = self.__construct_pagination_link(page.previous_page_number(), min_lon, max_lon, min_lat, max_lat, request.GET.get('sounds_per_page',None), request.GET.get('fields', False))
                if page.has_next():
                    result['next'] = self.__construct_pagination_link(page.next_page_number(), min_lon, max_lon, min_lat, max_lat, request.GET.get('sounds_per_page',None), request.GET.get('fields', False))

        add_request_id(request,result)
        logger.info("Geotags search,min_lat=" + str(min_lat) + ",max_lat=" + str(max_lat) + ",min_lon=" + str(min_lon) + ",max_lon=" + str(max_lon) + ",api_key=" + request.GET.get("api_key", False) + ",api_key_username=" + request.user.username)
        return result

    def __construct_pagination_link(self, p, min_lon, max_lon, min_lat, max_lat, spp, fields):
        link = prepend_base(reverse('api-sound-geotag')) + '?p=%s&min_lon=%s&max_lon=%s&min_lat=%s&max_lat=%s' % (p,min_lon,max_lon,min_lat,max_lat)
        if spp:
            link += "&sounds_per_page=" + str(spp)
        if fields:
            link += "&fields=" + str(fields)
        return link

class UserHandler(BaseHandler):
    '''
    api endpoint:   /people/<username>
    '''
    allowed_methods = ('GET',)

    '''
    input:          n.a.
    output:         #single_user#
    curl:           curl http://www.freesound.org/api/people/vincent_akkermans
    '''

    @auth()
    def read(self, request, username):
        try:
            user = User.objects.get(username__iexact=username)
        except User.DoesNotExist:
            raise ReturnError(404, "NotFound", {"explanation": "User (%s) does not exist." % username})

        result = prepare_single_user(user)

        add_request_id(request,result)
        logger.info("User info,username=" + username + ",api_key=" + request.GET.get("api_key", False) + ",api_key_username=" + request.user.username)
        return result

class UserSoundsHandler(BaseHandler):
    '''
    api endpoint:   /people/<username>/sounds
    '''
    allowed_methods = ('GET',)

    '''
    input:          p, c
    output:         #user_sounds#
    curl:           curl http://www.freesound.org/api/people/vincent_akkermans/sounds?p=5
    '''

    @auth()
    def read(self, request, username):
        try:
            user = User.objects.get(username__iexact=username)
        except User.DoesNotExist:
            raise ReturnError(404, "NotFound", {"explanation": "User (%s) does not exist." % username})

        paginator = paginate(request, Sound.public.filter(user=user, processing_state="OK", moderation_state="OK"), min(int(request.GET.get('sounds_per_page', settings.SOUNDS_PER_API_RESPONSE)),settings.MAX_SOUNDS_PER_API_RESPONSE), 'p')
        page = paginator['page']
        if int(request.GET.get("p", "1")) <= paginator['paginator'].num_pages: # This is to mimic solr paginator behavior
            sounds = [prepare_collection_sound(sound, include_user=True, custom_fields = request.GET.get('fields', False)) for sound in page.object_list]
        else:
            sounds = []
        result = {'sounds': sounds,  'num_results': paginator['paginator'].count, 'num_pages': paginator['paginator'].num_pages}

        if int(request.GET.get("p", "1")) <= paginator['paginator'].num_pages: # This is to mimic solr paginator behavior
            if page.has_other_pages():
                if page.has_previous():
                    result['previous'] = self.__construct_pagination_link(username, page.previous_page_number(), request.GET.get('sounds_per_page',None), request.GET.get('fields', False))
                if page.has_next():
                    result['next'] = self.__construct_pagination_link(username, page.next_page_number(), request.GET.get('sounds_per_page',None), request.GET.get('fields', False))

        add_request_id(request,result)
        logger.info("User sounds,username=" + username + ",api_key=" + request.GET.get("api_key", False) + ",api_key_username=" + request.user.username)
        return result

    #TODO: auth() ?
    def __construct_pagination_link(self, u, p, spp, fields):
        link = get_user_sounds_api_url(u)+'?p=%s' % p
        if spp:
            link += "&sounds_per_page=" + str(spp)
        if fields:
            link += "&fields=" + str(fields)
        return link

class UserPacksHandler(BaseHandler):
    '''
    api endpoint:   /people/<username>/packs
    '''
    allowed_methods = ('GET',)

    '''
    input:          n.a.
    output:         #user_packs#
    curl:           curl http://www.freesound.org/api/people/vincent_akkermans/packs
    '''

    @auth()
    def read(self, request, username):
        try:
            user = User.objects.get(username__iexact=username)
        except User.DoesNotExist:
            raise ReturnError(404, "NotFound", {"explanation": "User (%s) does not exist." % username})

        packs = [prepare_single_pack(pack, include_user=False) for pack in Pack.objects.filter(user=user)]
        result = {'packs': packs, 'num_results': len(packs)}

        add_request_id(request,result)
        logger.info("User packs,username=" + username + ",api_key=" + request.GET.get("api_key", False) + ",api_key_username=" + request.user.username)
        return result

class UserBookmarkCategoriesHandler(BaseHandler):
    '''
    api endpoint:   /people/<username>/bookmark_categories
    '''
    allowed_methods = ('GET',)

    '''
    input:          n.a.
    output:         #user_bookmark_categories#
    curl:           curl http://www.freesound.org/api/people/vincent_akkermans/bookmark_categories
    '''

    @auth()
    def read(self, request, username):
        try:
            user = User.objects.get(username__iexact=username)
        except User.DoesNotExist:
            raise ReturnError(404, "NotFound", {"explanation": "User (%s) does not exist." % username})

        categories = [prepare_single_bookmark_category(username, category) for category in BookmarkCategory.objects.filter(user=user)]
        # Add uncategorized category (if uncategorized bookmarks exist)
        if Bookmark.objects.select_related("sound").filter(user=user,category=None).count():
            categories.append({
                'name':'Uncategorized bookmarks',
                'url':get_user_bookmark_categories_api_url(username),
                'sounds':prepend_base(reverse('api-user-bookmark-uncategorized', args=[username]))
            })

        result = {'categories': categories, 'num_results': len(categories)}

        add_request_id(request,result)
        logger.info("User bookmark categories,username=" + username + ",api_key=" + request.GET.get("api_key", False) + ",api_key_username=" + request.user.username)
        return result

class UserBookmarkCategoryHandler(BaseHandler):
    '''
    api endpoint:   /people/<username>/bookmark_categories/<category_id>/sounds/
    '''
    allowed_methods = ('GET',)

    '''
    input:          n.a.
    output:         #user_bookmark_category_sounds#
    curl:           curl http://www.freesound.org/api/people/vincent_akkermans/bookmark_categories/34/sounds/
    '''

    @auth()
    def read(self, request, username, category_id = None):
        try:
            user = User.objects.get(username__iexact=username)
            if category_id:
                category = BookmarkCategory.objects.get(user__username__iexact=username, id=category_id )
        except BookmarkCategory.DoesNotExist:
            raise ReturnError(404, "NotFound", {"explanation": "Bookmark category with id %s does not exist." % category_id})
        except User.DoesNotExist:
            raise ReturnError(404, "NotFound", {"explanation": "User (%s) does not exist." % username})

        if category_id:
            bookmarked_sounds = category.bookmarks.select_related("sound").all()
        else:
            bookmarked_sounds = Bookmark.objects.select_related("sound").filter(user=user,category=None)

        paginator = paginate(request, bookmarked_sounds, min(int(request.GET.get('sounds_per_page', settings.SOUNDS_PER_API_RESPONSE)),settings.MAX_SOUNDS_PER_API_RESPONSE), 'p')
        page = paginator['page']
        if int(request.GET.get("p", "1")) <= paginator['paginator'].num_pages: # This is to mimic solr paginator behavior
            sounds = [prepare_collection_sound(bookmark.sound, include_user=True, custom_fields = request.GET.get('fields', False), extra_properties={'bookmark_name':bookmark.name}) for bookmark in page.object_list]
        else:
            sounds = []
        result = {'sounds': sounds, 'num_results': paginator['paginator'].count, 'num_pages': paginator['paginator'].num_pages}
        if int(request.GET.get("p", "1")) <= paginator['paginator'].num_pages: # This is to mimic solr paginator behavior
            if page.has_other_pages():
                if page.has_previous():
                    result['previous'] = self.__construct_pagination_link(username, category_id, page.previous_page_number())
                if page.has_next():
                    result['next'] = self.__construct_pagination_link(username, category_id, page.next_page_number())

        add_request_id(request,result)
        logger.info("User bookmarks for category,username=" + username + ",category_id=" + str(category_id) + ",api_key=" + request.GET.get("api_key", False) + ",api_key_username=" + request.user.username)
        return result

    def __construct_pagination_link(self, username, category_id, p):
        return get_bookmark_category_api_url(username,category_id)+'?p=%s' % p

class PackHandler(BaseHandler):
    '''
    api endpoint:   /packs/<pack_id>
    '''
    allowed_methods = ('GET',)

    '''
    input:          n.a.
    output:         #user_packs#
    curl:           curl http://www.freesound.org/api/packs/<pack_id>
    '''

    @auth()
    def read(self, request, pack_id):
        try:
            pack = Pack.objects.get(id=pack_id)
        except Pack.DoesNotExist:
            raise ReturnError(404, "NotFound", {"explanation": "Pack with id %s does not exist." % pack_id})

        result = prepare_single_pack(pack, include_description=True)

        add_request_id(request,result)
        logger.info("Pack info,id=" + pack_id + ",api_key=" + request.GET.get("api_key", False) + ",api_key_username=" + request.user.username)
        return result

class PackSoundsHandler(BaseHandler):
    '''
    api endpoint:   /packs/<pack_id>/sounds
    '''
    allowed_methods = ('GET',)

    '''
    input:          p
    output:         #pack_sounds#
    curl:           curl http://www.freesound.org/api/packs/<pack_id>/sounds
    '''

    @auth()
    def read(self, request, pack_id):
        try:
            pack = Pack.objects.get(id=pack_id)
        except User.DoesNotExist:
            raise ReturnError(404, "NotFound", {"explanation": "Pack with id %s does not exist." % pack_id})

        paginator = paginate(request, Sound.objects.filter(pack=pack.id, processing_state="OK", moderation_state="OK"), min(int(request.GET.get('sounds_per_page', settings.SOUNDS_PER_API_RESPONSE)),settings.MAX_SOUNDS_PER_API_RESPONSE), 'p')
        page = paginator['page']
        if int(request.GET.get("p", "1")) <= paginator['paginator'].num_pages: # This is to mimic solr paginator behavior
            sounds = [prepare_collection_sound(sound, include_user=True, custom_fields = request.GET.get('fields', False)) for sound in page.object_list]
        else:
            sounds = []
        result = {'sounds': sounds, 'num_results': paginator['paginator'].count, 'num_pages': paginator['paginator'].num_pages}
        if int(request.GET.get("p", "1")) <= paginator['paginator'].num_pages: # This is to mimic solr paginator behavior
            if page.has_other_pages():
                if page.has_previous():
                    result['previous'] = self.__construct_pagination_link(pack_id, page.previous_page_number(),request.GET.get('sounds_per_page', None), request.GET.get('fields', False))
                if page.has_next():
                    result['next'] = self.__construct_pagination_link(pack_id, page.next_page_number(),request.GET.get('sounds_per_page', None), request.GET.get('fields', False))

        add_request_id(request,result)
        logger.info("Pack sounds,id=" + pack_id + ",api_key=" + request.GET.get("api_key", False) + ",api_key_username=" + request.user.username)
        return result

    def __construct_pagination_link(self, pack_id, p, spp, fields):
        link = get_pack_sounds_api_url(pack_id)+'?p=%s' % p
        if spp:
            link += "&sounds_per_page=" + str(spp)
        if fields:
            link += "&fields=" + str(fields)

        return link


class PackServeHandler(BaseHandler):
    '''
    api endpoint:    /packs/id/serve
    '''
    allowed_methods = ('GET',)

    '''
    input:        n.a.
    output:       binary file
    curl:         curl http://www.freesound.org/api/packs/2/serve
    '''

    @auth()
    def read(self, request, pack_id):
        try:
            pack = Pack.objects.get(id=pack_id)
        except Pack.DoesNotExist:
            raise ReturnError(404, "NotFound", {"explanation": "Pack with id %s does not exist." % pack_id})

        logger.info("Serving pack,id=" + pack_id + ",api_key=" + request.GET.get("api_key", False) + ",api_key_username=" + request.user.username)
        return sendfile(pack.locations("path"), pack.friendly_filename(), pack.locations("sendfile_url"))



# N.B. don't add this to a production environment!
class UpdateSolrHandler(BaseHandler):
    allowed_methods = ('GET',)

    @auth()
    def read(self, request):
        sound_qs = Sound.objects.select_related("pack", "user", "license") \
                                .filter(processing_state="OK", moderation_state="OK")
        add_all_sounds_to_solr(sound_qs)
        return rc.ALL_OK


# Pool handlers (RSS)
class SoundPoolSearchHandler(Feed):
    title = "Freesound"
    link = "http://freesound.org/"

    def get_object(self, request):
        type = request.GET.get('type', 'all')
        query = request.GET.get('query', '')
        limit = request.GET.get('limit', 20)
        offset = request.GET.get('offset', 0)
        return {'type':type,'query':query,'limit':limit,'offset':offset}

    def items(self, obj):
        if obj['query'] != "": 
            try:
                solr = Solr(settings.SOLR_URL)
                query = SolrQuery()
                fields=[('id',4),
                        ('tag', 3),
                        ('description', 3),
                        ('username', 2),
                        ('pack_tokenized', 2),
                        ('original_filename', 2),]
                
                
                if obj['type'] == "phrase":
                    query.set_dismax_query('"' + obj['query'] + '"',query_fields=fields) # EXACT (not 100%)    
                elif obj['type'] == "any":
                    query.set_dismax_query(obj['query'],query_fields=[],minimum_match=0) # OR
                else:
                    query.set_dismax_query(obj['query'],query_fields=[],minimum_match="100%") # AND
                
                lim = obj['limit']
                if lim > 100:
                    lim = 100
                
                    
                query.set_query_options(start=obj['offset'], rows=lim, filter_query="", sort=['created desc'])
                
                try:
                    results = SolrResponseInterpreter(solr.select(unicode(query)))
                    
                    sounds = []
                    for object in results.docs :
                        try:
                            sounds.append(object)
                        except: # This will happen if there are synchronization errors between solr index and the database. In that case sounds are ommited and both num_results and results per page might become inacurate
                            pass

                    logger.info("Sound pool search RSS")
                    return sounds
        
                except SolrException, e:
                    return []
            except:
                return []
        else:
            return []

    def item_title(self, item):
        return item['original_filename']

    def item_description(self, item):
        tags = item['tag']
        s= "Tags: "
        for t in tags:
            s = s + t + " "
        s += "<br>"
        desc = item['description']
        s = s + desc
        return s
        
    def item_link(self, item):
        return "http://freesound.org/people/" + str(item['username']) + "/sounds/" + str(item['id'])
        
    def item_author_name(self, item):
        return item['username']
        
    def item_author_link(self, item):
        return "http://freesound.org/people/" + str(item['username'])
         
    def item_pubdate(self, item):
        return item['created']


class SoundPoolInfoHandler(Feed):
    title = "Freesound"
    link = "http://freesound.org/"

    def items(self):
        logger.info("Sound pool info RSS")
        return []

    def item_title(self, item):
        return ""

    def item_description(self, item):
        return ""

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'ApiKey'
        db.create_table('api_apikey', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('key', self.gf('django.db.models.fields.CharField')(default='446bdb9d5c5043d58e18cbeb3de2399d', unique=True, max_length=32, db_index=True)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(related_name='api_keys', to=orm['auth.User'])),
            ('status', self.gf('django.db.models.fields.CharField')(default='OK', max_length=3)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=64)),
            ('url', self.gf('django.db.models.fields.URLField')(max_length=200)),
            ('description', self.gf('django.db.models.fields.TextField')(blank=True)),
        ))
        db.send_create_signal('api', ['ApiKey'])


    def backwards(self, orm):
        
        # Deleting model 'ApiKey'
        db.delete_table('api_apikey')


    models = {
        'api.apikey': {
            'Meta': {'object_name': 'ApiKey'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'default': "'7867661c92634dd187dc2eaba03d2d99'", 'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'OK'", 'max_length': '3'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'api_keys'", 'to': "orm['auth.User']"})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['api']

########NEW FILE########
__FILENAME__ = 0002_auto__add_field_apikey_accepted_tos
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'ApiKey.accepted_tos'
        db.add_column('api_apikey', 'accepted_tos', self.gf('django.db.models.fields.BooleanField')(default=False), keep_default=False)


    def backwards(self, orm):
        
        # Deleting field 'ApiKey.accepted_tos'
        db.delete_column('api_apikey', 'accepted_tos')


    models = {
        'api.apikey': {
            'Meta': {'object_name': 'ApiKey'},
            'accepted_tos': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'default': "'ded96910152b44eba113087e27326538'", 'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'OK'", 'max_length': '3'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'api_keys'", 'to': "orm['auth.User']"})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['api']

########NEW FILE########
__FILENAME__ = models
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.contrib.auth.models import User
from django.db import models
import uuid

def generate_key():
    return str(uuid.uuid4()).replace('-','')

class ApiKey(models.Model):
    STATUS_CHOICES = (('OK',  'Approved'),
                      ('REJ', 'Rejected'),
                      ('REV', 'Revoked'),
                      ('PEN', 'Pending'))
    
    DEFAULT_STATUS = 'OK'

    key            = models.CharField(max_length=32, default=generate_key, db_index=True, unique=True)
    user           = models.ForeignKey(User, related_name='api_keys')
    status         = models.CharField(max_length=3, default=DEFAULT_STATUS, choices=STATUS_CHOICES)
    name           = models.CharField(max_length=64)
    url            = models.URLField()
    description    = models.TextField(blank=True)
    accepted_tos   = models.BooleanField(default=False)

    @property
    def client_id(self):
        return "-"

    @property
    def client_secret(self):
        return self.key

    @property
    def redirect_uri(self):
        return "-"

    @property
    def get_scope_display(self):
        return "-"

    @property
    def version(self):
        return "V1"

########NEW FILE########
__FILENAME__ = urls
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.conf.urls.defaults import *
from piston.resource import Resource
from handlers import *
from api_utils import build_invalid_url
import settings

if not settings.APIV2KEYS_ALLOWED_FOR_APIV1:
    from views import create_api_key as apply_for_api_key_view
else:
    from apiv2.views import create_apiv2_key as apply_for_api_key_view



class AR(Resource):
    def __call__(self, *args, **kwargs):
        response = super(AR, self).__call__(*args, **kwargs)
        response['Access-Control-Allow-Origin'] = '*'
        return response

urlpatterns = patterns('',
    # sounds
    url(r'^sounds/search/$',                                        AR(SoundSearchHandler),         name='api-search'),
    url(r'^sounds/content_search/$',                                AR(SoundContentSearchHandler),  name='api-content-search'),
    url(r'^sounds/(?P<sound_id>\d+)/$',                             AR(SoundHandler),               name='api-single-sound'),
    url(r'^sounds/(?P<sound_id>\d+)/analysis/$',                    AR(SoundAnalysisHandler),       name='api-sound-analysis'),
    url(r'^sounds/(?P<sound_id>\d+)/analysis(?P<filter>/[\w\/]+)/$',AR(SoundAnalysisHandler),       name='api-sound-analysis-filtered'),
    # For future use (when we serve analysis files through autenthication)
    #url(r'^sounds/(?P<sound_id>\d+)/analysis_frames/$',            AR(SoundAnalysisFramesHandler), name='api-sound-analysis-frames'),
    url(r'^sounds/(?P<sound_id>\d+)/serve/$',                       AR(SoundServeHandler),          name='api-sound-serve'),
    url(r'^sounds/(?P<sound_id>\d+)/similar/$',                     AR(SoundSimilarityHandler),     name='api-sound-similarity'),
    url(r'^sounds/geotag/$',                                        AR(SoundGeotagHandler),         name='api-sound-geotag'),
    
    # users
    url(r'^people/(?P<username>[^//]+)/$',                                                     AR(UserHandler),                    name='api-single-user'),
    url(r'^people/(?P<username>[^//]+)/sounds/$',                                              AR(UserSoundsHandler),              name='api-user-sounds'),
    url(r'^people/(?P<username>[^//]+)/packs/$',                                               AR(UserPacksHandler),               name='api-user-packs'),
    url(r'^people/(?P<username>[^//]+)/bookmark_categories/$',                                 AR(UserBookmarkCategoriesHandler),  name='api-user-bookmark-categories'),
    url(r'^people/(?P<username>[^//]+)/bookmark_categories/(?P<category_id>\d+)/sounds/$',     AR(UserBookmarkCategoryHandler),    name='api-user-bookmark-category'),
    url(r'^people/(?P<username>[^//]+)/bookmark_categories/uncategorized/sounds/$',            AR(UserBookmarkCategoryHandler),    name='api-user-bookmark-uncategorized'),

    # packs
    url(r'^packs/(?P<pack_id>\d+)/$',                               AR(PackHandler),           name='api-single-pack'),
    url(r'^packs/(?P<pack_id>\d+)/serve/$',                         AR(PackServeHandler),      name='api-pack-serve'),
    url(r'^packs/(?P<pack_id>\d+)/sounds/$',                        AR(PackSoundsHandler),     name='api-pack-sounds'),

    # cc-mixter pool
    url(r'^pool/search$',                                           SoundPoolSearchHandler(),   name='api-pool-search'),
    url(r'^pool/search/$',                                          SoundPoolSearchHandler(),   name='api-pool-search-slash'),
    url(r'^pool/info$',                                             SoundPoolInfoHandler(),     name='api-pool-info'),
    url(r'^pool/info/$',                                            SoundPoolInfoHandler(),     name='api-pool-info-slash'),
    
    # website
    url(r'^apply/$', apply_for_api_key_view),

    # anything else (invalid urls)
    url(r'/$', build_invalid_url ),
)



########NEW FILE########
__FILENAME__ = views
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from forms import ApiKeyForm
from models import ApiKey
from django.contrib.auth.decorators import login_required
from django.shortcuts import render_to_response
from django.template import RequestContext

@login_required
def create_api_key(request):
    if request.method == 'POST':
        form = ApiKeyForm(request.POST)
        if form.is_valid():
            db_api_key = ApiKey()
            db_api_key.user = request.user
            db_api_key.description = form.cleaned_data['description']
            db_api_key.name        = form.cleaned_data['name']
            db_api_key.url         = form.cleaned_data['url']
            db_api_key.accepted_tos= form.cleaned_data['accepted_tos']
            db_api_key.save()
            form = ApiKeyForm()
    else:
        form = ApiKeyForm()
    return render_to_response('api/apply_key.html', 
                              { 'user': request.user, 'form': form }, 
                              context_instance=RequestContext(request))
########NEW FILE########
__FILENAME__ = admin
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.contrib import admin
from apiv2.models import ApiV2Client


class ApiV2ClientAdmin(admin.ModelAdmin):
    raw_id_fields = ('user',)
    search_fields = ('=user__username', )
    list_filter = ('status', )
    list_display = ("user", "client_id", "client_secret", "oauth_client", "status", "allow_oauth_passoword_grant")

admin.site.register(ApiV2Client, ApiV2ClientAdmin)
########NEW FILE########
__FILENAME__ = authentication
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.core.exceptions import ImproperlyConfigured
from rest_framework import exceptions
from rest_framework.authentication import get_authorization_header
from rest_framework.authentication import BaseAuthentication, SessionAuthentication as DjangoRestFrameworkSessionAuthentication
from apiv2.models import ApiV2Client
import provider.oauth2 as oauth2_provider
import datetime
provider_now = datetime.datetime.now

'''
We overwrite OAuth2Authentication from rest_framework.authentication because of a problem when importing provider_now.
Django-oauth2-provider tries to import a function only present in django >= 1.4 (django.utils.timezone), and we
are using 1.3.

We may use this overwritten class to add some extra funcitonality.
'''


class OAuth2Authentication(BaseAuthentication):
    """
    OAuth 2 authentication backend using `django-oauth2-provider`
    """
    www_authenticate_realm = 'api'

    def __init__(self, *args, **kwargs):
        super(OAuth2Authentication, self).__init__(*args, **kwargs)

        if oauth2_provider is None:
            raise ImproperlyConfigured(
                "The 'django-oauth2-provider' package could not be imported. "
                "It is required for use with the 'OAuth2Authentication' class.")

    @property
    def authentication_method_name(self):
        return "OAuth2"

    def authenticate(self, request):
        """
        Returns two-tuple of (user, token) if authentication succeeds,
        or None otherwise.
        """

        auth = get_authorization_header(request).split()

        if not auth or auth[0].lower() != b'bearer':
            return None

        if len(auth) == 1:
            msg = 'Invalid bearer header. No credentials provided.'
            raise exceptions.AuthenticationFailed(msg)
        elif len(auth) > 2:
            msg = 'Invalid bearer header. Token string should not contain spaces.'
            raise exceptions.AuthenticationFailed(msg)

        return self.authenticate_credentials(request, auth[1])

    def authenticate_credentials(self, request, access_token):
        """
        Authenticate the request, given the access token.
        """

        try:
            token = oauth2_provider.models.AccessToken.objects.select_related('user','client')
            # provider_now switches to timezone aware datetime when
            # the oauth2_provider version supports to it.
            token = token.get(token=access_token, expires__gt=provider_now())
        except oauth2_provider.models.AccessToken.DoesNotExist:
            if token.filter(token=access_token).exists():
                # Expired token
                raise exceptions.AuthenticationFailed('Expired token.')
            else:
                raise exceptions.AuthenticationFailed('Invalid token.')

        user = token.user

        if not user.is_active:
            raise exceptions.AuthenticationFailed('User inactive or deleted')

        if not token.client.apiv2_client.status == 'OK':
            raise exceptions.AuthenticationFailed('Suspended token or token pending for approval')

        return (user, token)

    def authenticate_header(self, request):
        """
        Bearer is the only finalized type currently

        Check details on the `OAuth2Authentication.authenticate` method
        """
        return 'Bearer realm="%s"' % self.www_authenticate_realm


'''
We also overwrite TokenAuthentication so we can add extra features and change the default Token model.
'''


class TokenAuthentication(BaseAuthentication):
    """
    Simple token based authentication.

    Clients should authenticate by passing the token key in the "Authorization"
    HTTP header, prepended with the string "Token ".  For example:

        Authorization: Token 401f7ac837da42b97f613d789819ff93537bee6a
    """

    model = ApiV2Client

    @property
    def authentication_method_name(self):
        return "Token"

    def authenticate(self, request):
        auth = get_authorization_header(request).split()

        # If the token is not provided through the header check if it is provided as a query parameter
        if not auth:
            token = request.GET.get('token', None)
            if token:
                auth = ['Token', token]

        if not auth or auth[0].lower() != b'token':
            return None

        if len(auth) == 1:
            msg = 'Invalid token header. No credentials provided.'
            raise exceptions.AuthenticationFailed(msg)
        elif len(auth) > 2:
            msg = 'Invalid token header. Token string should not contain spaces.'
            raise exceptions.AuthenticationFailed(msg)

        return self.authenticate_credentials(auth[1])

    def authenticate_credentials(self, key):
        try:
            token = self.model.objects.get(key=key)
        except self.model.DoesNotExist:
            raise exceptions.AuthenticationFailed('Invalid token')

        if not token.user.is_active:
            raise exceptions.AuthenticationFailed('User inactive or deleted')

        if not token.status == 'OK':
            raise exceptions.AuthenticationFailed('Suspended token or token pending for approval')

        return (token.user, token)

    def authenticate_header(self, request):
        return 'Token'


class SessionAuthentication(DjangoRestFrameworkSessionAuthentication):

    """
    Use Django's session framework for authentication.
    """

    @property
    def authentication_method_name(self):
        return "Session"
########NEW FILE########
__FILENAME__ = combined_search_strategies
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from freesound.utils.similarity_utilities import api_search as similarity_api_search
from freesound.utils.search.solr import Solr, SolrException, SolrResponseInterpreter
from similarity.client import SimilarityException
from search.views import search_prepare_query
from exceptions import ServerErrorException, BadRequestException, NotFoundException
from urllib import unquote
import settings


def merge_all(search_form, target_file=None, extra_parameters=None):
    """
    Merge all strategy will get all results from solr and all results from gaia and then combine the ids
    in a unique list. The advantage of this strategy is that it returns the exact total number of matches for the query.
    The disadvantage is that depending on the query it can become really slow, and sometimes throwing timeouts.
    """

    if not extra_parameters:
        extra_parameters = dict()
    solr_page_size = extra_parameters.get('cs_solr_page_size', 500)
    max_solr_pages = extra_parameters.get('cs_max_solr_pages', 10)
    gaia_page_size = extra_parameters.get('cs_gaia_page_size', 9999999)  # We can get ALL gaia results at once
    max_gaia_pages = extra_parameters.get('cs_max_gaia_pages', 1)

    # Get all gaia results
    gaia_ids, gaia_count, distance_to_target_data, note = get_gaia_results(search_form, target_file, page_size=gaia_page_size, max_pages=max_gaia_pages)

    # Get 'max_pages' pages of size 'page_size' from solr results
    solr_ids, solr_count = get_solr_results(search_form, page_size=solr_page_size, max_pages=max_solr_pages)

    if len(solr_ids) == solr_count and len(gaia_ids) == gaia_count:
        # Got complete results, maybe we should log that?
        pass

    if search_form.cleaned_data['target'] or target_file:
        # Combined search, sort by gaia_ids
        results_a = gaia_ids
        results_b = solr_ids
    else:
        # Combined search, sort by solr ids
        results_a = solr_ids
        results_b = gaia_ids

    # Combine results
    results_b_set = set(results_b)
    combined_ids = [id for id in results_a if id in results_b_set]
    combined_count = len(combined_ids)
    return combined_ids[(search_form.cleaned_data['page'] - 1) * search_form.cleaned_data['page_size']:search_form.cleaned_data['page'] * search_form.cleaned_data['page_size']], \
           combined_count, distance_to_target_data, None, note, None, None


def filter_both(search_form, target_file=None, extra_parameters=None):
    """
    Filter both strategy will first get either some results from solr and then check if returned results are also
    valid results in a gaia query, or the other way around.
    In gaia and solr we can restrict the query to a particular set of results, but there are limitations both in the
    length of the resulting url and in the number of OR clauses that solr can support.
    """

    if not extra_parameters:
        extra_parameters = dict()
    solr_filter_id_block_size = extra_parameters.get('cs_solr_filter_id_block_size', 350)
    solr_filter_id_max_pages = extra_parameters.get('cs_solr_filter_id_max_pages', 7)
    solr_max_pages = extra_parameters.get('cs_max_solr_pages', 7)
    solr_page_size = extra_parameters.get('cs_solr_page_size', 1000)
    gaia_filter_id_block_size = extra_parameters.get('cs_gaia_filter_id_block_size', 350)
    gaia_filter_id_max_pages = extra_parameters.get('cs_gaia_filter_id_max_pages', 7)
    gaia_max_pages = extra_parameters.get('cs_max_gaia_pages', 1)
    gaia_page_size = extra_parameters.get('cs_gaia_page_size', 9999999)  # We can get ALL gaia results at once

    if search_form.cleaned_data['target'] or target_file:
        # First search into gaia and then into solr (get all gaia results)
        gaia_ids, gaia_count, distance_to_target_data, note = get_gaia_results(search_form, target_file, page_size=gaia_page_size, max_pages=gaia_max_pages)
        valid_ids_pages = [gaia_ids[i:i+solr_filter_id_block_size] for i in range(0, len(gaia_ids), solr_filter_id_block_size) if (i/solr_filter_id_block_size) < solr_filter_id_max_pages]
        solr_ids = list()
        solr = Solr(settings.SOLR_URL)
        for valid_ids_page in valid_ids_pages:
            page_solr_ids, solr_count = get_solr_results(search_form, page_size=len(valid_ids_page), max_pages=1, valid_ids=valid_ids_page, solr=solr)
            solr_ids += page_solr_ids

        if gaia_count <= solr_filter_id_block_size * solr_filter_id_max_pages:
            # Got complete results, maybe we should log that?
            #print 'COMPLETE results (starting with gaia)'
            pass
    else:
        # First search into solr and then into gaia
        # These queries are SLOW because we need to get many pages from solr
        solr_ids, solr_count = get_solr_results(search_form, page_size=solr_page_size, max_pages=solr_max_pages)

        # Now we should split solr ids in blocks and iteratively query gaia restricting the results to those ids
        # present in the current block. However given that gaia results can be retrieved
        # all at once very quickly, we optimize this bit by retrieving them all at once and avoiding many requests
        # to similarity server.
        gaia_ids, gaia_count, distance_to_target_data, note = get_gaia_results(search_form, target_file, page_size=gaia_page_size, max_pages=gaia_max_pages)
        '''
        # That would be the code without the optimization:
        valid_ids_pages = [solr_ids[i:i+gaia_filter_id_block_size] for i in range(0, len(solr_ids), gaia_filter_id_block_size) if (i/gaia_filter_id_block_size) < gaia_filter_id_max_pages]
        gaia_ids = list()
        distance_to_target_data = None
        note = None
        for valid_ids_page in valid_ids_pages:
            page_gaia_ids, page_gaia_count, page_distance_to_target_data, note = get_gaia_results(search_form, target_file, page_size=len(valid_ids_page), max_pages=1, valid_ids=valid_ids_page)
            gaia_ids += page_gaia_ids
        '''
        if solr_count <= solr_page_size * solr_max_pages and gaia_count < gaia_page_size * gaia_max_pages:
            # Got complete results, maybe we should log that?
            #print 'COMPLETE results (starting with solr)'
            pass


    if search_form.cleaned_data['target'] or target_file:
        # Combined search, sort by gaia_ids
        results_a = gaia_ids
        results_b = solr_ids
    else:
        # Combined search, sort by solr ids
        results_a = solr_ids
        results_b = gaia_ids

    # Combine results
    results_b_set = set(results_b)
    combined_ids = [id for id in results_a if id in results_b_set]
    combined_count = len(combined_ids)
    return combined_ids[(search_form.cleaned_data['page'] - 1) * search_form.cleaned_data['page_size']:search_form.cleaned_data['page'] * search_form.cleaned_data['page_size']], \
           combined_count, distance_to_target_data, None, note, None, None


def merge_optimized(search_form, target_file=None, extra_parameters=None):
    """
    Filter both strategy will first get either some results from solr and then check if returned results are also
    valid results in a gaia query, or the other way around.
    In gaia and solr we can restrict the query to a particular set of results, but there are limitations both in the
    length of the resulting url and in the number of OR clauses that solr can support.
    """

    if not extra_parameters:
        extra_parameters = dict()
    solr_filter_id_block_size = extra_parameters.get('cs_solr_filter_id_block_size', 350)
    solr_filter_id_max_pages = extra_parameters.get('cs_solr_filter_id_max_pages', 7)
    solr_max_requests = extra_parameters.get('cs_max_solr_requests', 20)
    solr_page_size = extra_parameters.get('cs_solr_page_size', 200)
    gaia_max_pages = extra_parameters.get('cs_max_gaia_pages', 1)
    gaia_page_size = extra_parameters.get('cs_gaia_page_size', 9999999)  # We can get ALL gaia results at once

    num_requested_results = search_form.cleaned_data['page_size']
    params_for_next_page = dict()

    debug_note = ''

    if search_form.cleaned_data['target'] or target_file:
        # First search into gaia and get all results that have not been checked in previous calls (indicated in request parameter 'cs_lcvidp')
        last_checked_valid_id_position = extra_parameters.get('cs_lcvidp', 0)
        if last_checked_valid_id_position < 0:
            last_checked_valid_id_position = 0
        gaia_ids, gaia_count, distance_to_target_data, note = get_gaia_results(search_form, target_file, page_size=gaia_page_size, max_pages=gaia_max_pages, offset=last_checked_valid_id_position)
        if len(gaia_ids):
            # Now divide gaia results in blocks of "solr_filter_id_block_size" results and iteratively query solr limiting the
            # results to those ids in the common block to obtain common results for the search.
            # Once we get as many results as "num_requested_results" or we exceed a maximum number
            # of iterations (solr_filter_id_max_pages), return what we got and update 'cs_lcvidp' parameter for further calls.
            valid_ids_pages = [gaia_ids[i:i+solr_filter_id_block_size] for i in range(0, len(gaia_ids), solr_filter_id_block_size)]
            solr_ids = list()
            checked_gaia_ids = list()
            solr = Solr(settings.SOLR_URL)
            for count, valid_ids_page in enumerate(valid_ids_pages):
                page_solr_ids, solr_count = get_solr_results(search_form, page_size=len(valid_ids_page), max_pages=1, valid_ids=valid_ids_page, solr=solr)
                solr_ids += page_solr_ids
                checked_gaia_ids += valid_ids_page
                if len(solr_ids) >= num_requested_results:
                    debug_note = 'Found enough results in %i solr requests' % (count + 1)
                    #print 'Did %i requests to solr' % (count + 1)
                    break
                if count + 1 > solr_filter_id_max_pages:
                    debug_note = 'Did %i solr requests (still not enough results)' % (count + 1)
                    #print 'Too many requests and not enough results'
                    break

            combined_ids = list()
            for index, sid in enumerate(checked_gaia_ids):
                if sid in solr_ids:
                    combined_ids.append(sid)
                new_last_checked_valid_id_position = index + 1
                if len(combined_ids) == num_requested_results:
                    break

            if len(checked_gaia_ids) == len(gaia_ids):
                params_for_next_page['no_more_results'] = True
            params_for_next_page['cs_lcvidp'] = last_checked_valid_id_position + new_last_checked_valid_id_position
        else:
            # No more gaia ids to check against solr, no more possible results!
            combined_ids = list()
            distance_to_target_data = dict()
            note = None
            params_for_next_page['no_more_results'] = True

    else:
        # First search into gaia to obtain a list of all sounds that match content-based query parameters
        gaia_ids, gaia_count, distance_to_target_data, note = get_gaia_results(search_form, target_file, page_size=gaia_page_size, max_pages=gaia_max_pages)
        last_retrieved_solr_id_pos = extra_parameters.get('cs_lrsidp', 0)
        if last_retrieved_solr_id_pos < 0:
            last_retrieved_solr_id_pos = 0

        if len(gaia_ids) < solr_filter_id_block_size:
            # optimization, if there are few gaia_ids, we can get all results in one query
            solr_ids, solr_count = get_solr_results(search_form, page_size=len(gaia_ids), max_pages=1, valid_ids=gaia_ids, offset=last_retrieved_solr_id_pos)
            combined_ids = solr_ids[:num_requested_results]
            params_for_next_page['cs_lrsidp'] = last_retrieved_solr_id_pos + num_requested_results
            if len(combined_ids) < num_requested_results:
                params_for_next_page['no_more_results'] = True
        else:
            # Now query solr starting at the last retrieved solr result position (parameter 'cs_lrsidp') and iteratively combine the results of
            # each page of the query with gaia ids. Once we reach the desired  "num_requested_results", return what we got and
            # update 'cs_lrsidp' parameter for further queries. Set a maximum number of iterations (solr_max_requests) to prevent a virtually
            # infinite query if not enough results are found (num_requested_results is not reached).
            combined_ids = list()
            new_last_retrieved_solr_id_pos = last_retrieved_solr_id_pos
            stop_main_for_loop = False
            n_requests_made = 0
            for i in range(0, solr_max_requests):
                if stop_main_for_loop:
                    continue
                offset = last_retrieved_solr_id_pos + i * solr_page_size
                solr_ids, solr_count = get_solr_results(search_form, page_size=solr_page_size, max_pages=1, offset=offset)
                n_requests_made += 1
                common_ids = list(set(solr_ids).intersection(gaia_ids))
                for index, sid in enumerate(solr_ids):
                    new_last_retrieved_solr_id_pos += 1
                    if sid in common_ids:
                        combined_ids.append(sid)
                    if len(combined_ids) == num_requested_results:
                        stop_main_for_loop = True
                        break
                    if new_last_retrieved_solr_id_pos == solr_count:
                        params_for_next_page['no_more_results'] = True
                        stop_main_for_loop = True
                        break
            if n_requests_made == solr_max_requests and len(combined_ids) < num_requested_results:
                debug_note = 'Did %i solr requests (still not enough results)' % n_requests_made
                #print 'Too many requests and not enough results'
            else:
                debug_note = 'Found enough results in %i solr requests' % n_requests_made
                #print 'Did %i requests to solr' % n_requests_made
            params_for_next_page['cs_lrsidp'] = new_last_retrieved_solr_id_pos

    # Combine results
    return combined_ids, len(combined_ids), distance_to_target_data, None, note, params_for_next_page, debug_note


def get_gaia_results(search_form, target_file, page_size, max_pages, start_page=1, valid_ids=None, offset=None):
    gaia_ids = list()
    gaia_count = None
    distance_to_target_data = dict()
    note = None

    try:
        current_page = start_page
        n_page_requests = 1
        # Iterate over gaia result pages
        while (len(gaia_ids) < gaia_count or gaia_count == None) and n_page_requests <= max_pages:
            if not offset:
                offset = (current_page - 1) * page_size
            results, count, note = similarity_api_search(target=search_form.cleaned_data['target'],
                                                         filter=search_form.cleaned_data['descriptors_filter'],
                                                         num_results=page_size,
                                                         offset=offset,
                                                         target_file=target_file,
                                                         in_ids=valid_ids)

            gaia_ids += [id[0] for id in results]
            gaia_count = count
            if search_form.cleaned_data['target'] or target_file:
                # Save sound distance to target into so it can be later used in the view class and added to results
                distance_to_target_data.update(dict(results))

            #print 'Gaia page %i (total %i sounds)' % (current_page, gaia_count)
            current_page += 1
            n_page_requests += 1

    except SimilarityException, e:
        if e.status_code == 500:
            raise ServerErrorException(msg=e.message)
        elif e.status_code == 400:
            raise BadRequestException(msg=e.message)
        elif e.status_code == 404:
            raise NotFoundException(msg=e.message)
        else:
            raise ServerErrorException(msg='Similarity server error: %s' % e.message)
    except Exception, e:
        raise ServerErrorException(msg='The similarity server could not be reached or some unexpected error occurred.')

    return gaia_ids, gaia_count, distance_to_target_data, note


def get_solr_results(search_form, page_size, max_pages, start_page=1, valid_ids=None, solr=None, offset=None):
    if not solr:
        solr = Solr(settings.SOLR_URL)

    query_filter = search_form.cleaned_data['filter']
    if valid_ids:
        # Update solr filter to only return results in valid ids
        ids_filter = 'id:(' + ' OR '.join([str(item) for item in valid_ids]) + ')'
        if query_filter:
            query_filter += ' %s' % ids_filter
        else:
            query_filter = ids_filter

    solr_ids = []
    solr_count = None

    try:
        current_page = start_page
        n_page_requests = 1
        # Iterate over solr result pages
        while (len(solr_ids) < solr_count or solr_count == None) and n_page_requests <= max_pages:
            query = search_prepare_query(unquote(search_form.cleaned_data['query'] or ""),
                                         unquote(query_filter or ""),
                                         search_form.cleaned_data['sort'],
                                         current_page,
                                         page_size,
                                         grouping=False,
                                         include_facets=False,
                                         offset=offset)
            result = SolrResponseInterpreter(solr.select(unicode(query)))
            solr_ids += [element['id'] for element in result.docs]
            solr_count = result.num_found

            #print 'Solr page %i (total %i sounds)' % (current_page, solr_count)
            current_page += 1
            n_page_requests += 1

    except SolrException, e:
        raise ServerErrorException(msg='Search server error: %s' % e.message)
    except Exception, e:
        raise ServerErrorException(msg='The search server could not be reached or some unexpected error occurred.')

    return solr_ids, solr_count
########NEW FILE########
__FILENAME__ = examples
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#


examples = {
    # Search
    'TextSearch': [
        ('Simple search', ['apiv2/search/text/?query=cars', 'apiv2/search/text/?query=piano&page=2', 'apiv2/search/text/?query=bass -drum', 'apiv2/search/text/?query="bass drum" -double']),
        ('Search with a filter', ['apiv2/search/text/?query=music&filter=tag:guitar','apiv2/search/text/?query=music&filter=type:(wav OR aiff)','apiv2/search/text/?query=music&filter=tag:bass tag:drum','apiv2/search/text/?query=music&filter=tag:bass description:"heavy distortion"','apiv2/search/text/?query=music&filter=is_geotagged:true tag:field-recording duration:[60 TO 120]','apiv2/search/text/?query=music&filter=samplerate:44100 type:wav channels:2','apiv2/search/text/?query=music&filter=duration:[0.1 TO 0.3] avg_rating:[3 TO *]']),
        ('Simple search and selection of sound fields to return in the results', ['apiv2/search/text/?query=alarm&fields=name,previews', 'apiv2/search/text/?query=alarm&fields=name,previews,analysis&descriptors=lowlevel.spectral_centroid.mean,lowlevel.pitch.mean', 'apiv2/search/text/?query=loop&fields=uri,analysis&descriptors=rhythm.onset_times']),
        ('Group search results by pack', ['apiv2/search/text/?query=piano&group_by_pack=1']),
        ('Get geotagged sounds with tag field-recording. Return only geotag and tags for each result', ['apiv2/search/text/?filter=is_geotagged:1 tag:field-recording&fields=geotag,tags']),
        ('Basic geospatial filtering', ['apiv2/search/text/?filter=geotag:"Intersects(-74.093 41.042 -69.347 44.558)"', 'apiv2/search/text/?filter=geotag:"IsDisjointTo(-74.093 41.042 -69.347 44.558)"']),
        ('Geospatial with customizable max error parameter (in degrees) and combinations of filters',
                                 ['apiv2/search/text/?filter=geotag:"Intersects(-74.093 41.042 -69.347 44.558)" distErr=20',
                                  'apiv2/search/text/?filter=geotag:"Intersects(-80 40 -60 50)" OR geotag:"Intersects(60 40 100 50)"&fields=id,geotag,tags',
                                  'apiv2/search/text/?filter=(geotag:"Intersects(-80 40 -60 50)" OR geotag:"Intersects(60 40 100 50)") AND tag:field-recording&fields=id,geotag,tags']),
        ('Geospatial search for points at a maximum distance d (in km) from a latitude,longitude position and with a particular tag', ['apiv2/search/text/?filter={!geofilt sfield=geotag pt=41.3833,2.1833 d=10} tag:barcelona&fields=id,geotag,tags',]),
    ],
    'ContentSearch': [
        ('Setting a target as some descriptor values', ['apiv2/search/content/?target=lowlevel.pitch.mean:220', 'apiv2/search/content/?target=lowlevel.pitch.mean:220 AND lowlevel.pitch.var:0']),
        ('Using multidimensional descriptors in the target', ['apiv2/search/content/?target=sfx.tristimulus.mean:0,1,0&fields=id,analysis&descriptors=sfx.tristimulus.mean']),
        ('Using a Freesound sound id as target', ['apiv2/search/content/?target=1234']),
        ('Using an Essentia analysis file as target', ['curl -X POST -H "Authorization: Token {{your_api_key}}" -F analysis_file=@"/path/to/your_file.json" \'%s/apiv2/search/content/\'']),
        ('Using descriptors filter', ['apiv2/search/content/?descriptors_filter=lowlevel.pitch.mean:[219.9 TO 220.1]', 'apiv2/search/content/?descriptors_filter=lowlevel.pitch.mean:[219.9 TO 220.1] AND lowlevel.pitch_salience.mean:[0.6 TO *]', 'apiv2/search/content/?descriptors_filter=lowlevel.mfcc.mean[0]:[-1124 TO -1121]', 'apiv2/search/content/?descriptors_filter=lowlevel.mfcc.mean[1]:[17 TO 20] AND lowlevel.mfcc.mean[4]:[0 TO 20]', 'apiv2/search/content/?descriptors_filter=tonal.key_key:"Asharp"', 'apiv2/search/content/?descriptors_filter=tonal.key_scale:"major"', 'apiv2/search/content/?descriptors_filter=(tonal.key_key:"C" AND tonal.key_scale:"major") OR (tonal.key_key:"A" AND tonal.key_scale:"minor")', 'apiv2/search/content/?descriptors_filter=tonal.key_key:"C" tonal.key_scale="major" tonal.key_strength:[0.8 TO *]']),
    ],
    'CombinedSearch': [
        ('Combining query with target descriptors and textual filter', ['apiv2/search/combined/?target=rhythm.bpm:120&filter=tag:loop']),
        ('Combining textual query with descriptors filter', ['apiv2/search/combined/?filter=tag:loop&descriptors_filter=rhythm.bpm:[119 TO 121]']),
        ('Combining two filters (textual and descriptors)', ['apiv2/search/combined/?descriptors_filter=tonal.key_key:"A" tonal.key_scale:"major"&filter=tag:chord']),
        ('Combining textual query with multidimensional descriptors filter', ['apiv2/search/combined/?query=music&fields=id,analysis&descriptors=lowlevel.mfcc.mean&descriptors_filter=lowlevel.mfcc.mean[1]:[17 TO 20] AND lowlevel.mfcc.mean[4]:[0 TO 20]']),
    ],

    # Sounds
    'SoundInstance': [
        ('Complete sound information', ['apiv2/sounds/1234/']),
        ('Complete sound information plus some descriptors', ['apiv2/sounds/213524/?descriptors=lowlevel.mfcc,rhythm.bpm']),
        ('Getting only id and tags for a particular sound', ['apiv2/sounds/1234/?fields=id,tags']),
        ('Getting sound name and spectral centroid values (second example gets normalized centroid values)', ['apiv2/sounds/1234/?fields=name,analysis&descriptors=lowlevel.spectral_centroid', 'apiv2/sounds/1234/?fields=name,analysis&descriptors=lowlevel.spectral_centroid&normalized=1']),
    ],
    'SoundAnalysis': [
        ('Full analysis information', ['apiv2/sounds/1234/analysis/']),
        ('Getting only tristimulus descriptor', ['apiv2/sounds/1234/analysis/?descriptors=sfx.tristimulus']),
        ('Getting normalized mean mfcc descriptors', ['apiv2/sounds/1234/analysis/?descriptors=lowlevel.mfcc.mean&normalized=1']),
    ],
    'SimilarSounds': [
        ('Getting similar sounds', ['apiv2/sounds/80408/similar/', 'apiv2/sounds/80408/similar/?page=2', 'apiv2/sounds/1234/similar/?fields=name,analysis&descriptors=lowlevel.pitch.mean&descriptors_filter=.lowlevel.pitch.mean:[90 TO 110]']),
    ],
    'SoundComments': [
        ('Get sound comments', ['apiv2/sounds/14854/comments/', 'apiv2/sounds/14854/comments/?page=2']),
    ],
    'DownloadSound': [
        ('Download a sound', ['curl -H "Authorization: Bearer {{access_token}}" \'%s/apiv2/sounds/14854/download/\'']),
    ],
    'UploadSound': [
        ('Upload a sound (audiofile only, no description)', ['curl -X POST -H "Authorization: Bearer {{access_token}}" -F audiofile=@"/path/to/your_file.wav" \'%s/apiv2/sounds/upload/\'']),
        ('Upload and describe a sound all at once', ['curl -X POST -H "Authorization: Bearer {{access_token}}" -F audiofile=@"/path/to/your_file.wav" -F "tags=field-recording birds nature h4n" -F "description=This sound was recorded...<br>bla bla bla..." -F "license=Attribution" \'%s/apiv2/sounds/upload/\'']),
        ('Upload and describe a sound with name, pack and geotag', ['curl -X POST -H "Authorization: Bearer {{access_token}}" -F audiofile=@"/path/to/your_file.wav" -F "name=Another cool sound" -F "tags=field-recording birds nature h4n" -F "description=This sound was recorded...<br>bla bla bla..." -F "license=Attribution" -F "pack=A birds pack" -F "geotag=2.145677,3.22345,14" \'%s/apiv2/sounds/upload/\'']),
    ],
    'PendingUploads': [
        ('Get uploaded sounds that are pending description, processing or moderation', ['curl -H "Authorization: Bearer {{access_token}}" \'%s/apiv2/sounds/pending_uploads/\'']),
    ],
    'DescribeSound': [
        ('Describe a sound (only with required fields)', ['curl -X POST -H "Authorization: Bearer {{access_token}}" --data "upload_filename=your_file.wav&tags=field-recording birds nature h4n&description=This sound was recorded...<br>bla bla bla...&license=Attribution" \'%s/apiv2/sounds/describe/\'']),
        ('Also add a name to the sound', ['curl -X POST -H "Authorization: Bearer {{access_token}}" --data "upload_filename=your_file.wav&name=A cool bird sound&tags=field-recording birds nature h4n&description=This sound was recorded...<br>bla bla bla...&license=Attribution" \'%s/apiv2/sounds/describe/\'']),
        ('Include geotag and pack information', ['curl -X POST -H "Authorization: Bearer {{access_token}}" --data "upload_filename=your_file.wav&name=A cool bird sound&tags=field-recording birds nature h4n&description=This sound was recorded...<br>bla bla bla...&license=Attribution&pack=A birds pack&geotag=2.145677,3.22345,14" \'%s/apiv2/sounds/describe/\'']),
    ],
    #'EditSoundDescription': [
    #    ('Setting tags of an existing sound to be "new tags for the sound" and description to "New sound description..."', ['curl -X POST -H "Authorization: Bearer {{access_token}}" --data "tags=new tags for the sound&description=New sound description..." \'%s/apiv2/sounds/1234/edit/\'']),
    #],
    'BookmarkSound': [
        ('Simple bookmark', ['curl -X POST -H "Authorization: Bearer {{access_token}}" --data "name=Classic thunderstorm" \'%s/apiv2/sounds/2523/bookmark/\'']),
        ('Bookmark with category', ['curl -X POST -H "Authorization: Bearer {{access_token}}" --data "name=Nice loop&category=Nice loops" \'%s/apiv2/sounds/1234/bookmark/\'']),
    ],
    'RateSound': [
        ('Rate sounds', ['curl -X POST -H "Authorization: Bearer {{access_token}}" --data "rating=5" \'%s/apiv2/sounds/2523/rate/\'', 'curl -X POST -H "Authorization: Bearer {{access_token}}" --data "rating=4" \'%s/apiv2/sounds/1234/rate/\'']),
    ],
    'CommentSound': [
        ('Comment sounds', ['curl -X POST -H "Authorization: Bearer {{access_token}}" --data "comment=Cool! I understand now why this is the most downloaded sound in Freesound..." \'%s/apiv2/sounds/2523/comment/\'', 'curl -X POST -H "Authorization: Bearer {{access_token}}" --data "comment=A very cool sound!" \'%s/apiv2/sounds/1234/comment/\'']),
    ],

    # Users
    'UserInstance': [
        ('User information', ['apiv2/users/reinsamba/', 'apiv2/users/Freed/']),
    ],
    'UserSounds': [
        ('Getting user sounds', ['apiv2/users/Jovica/sounds/', 'apiv2/users/Jovica/sounds/?page=2', 'apiv2/users/Jovica/sounds/?fields=id,bitdepth,type,samplerate']),
    ],
    'UserPacks': [
        ('Getting user packs', ['apiv2/users/reinsamba/packs/', 'apiv2/users/reinsamba/packs/?page=2']),
    ],
    'UserBookmarkCategories': [
        ('Users bookmark categories', ['apiv2/users/frederic.font/bookmark_categories/']),
    ],
    'UserBookmarkCategorySounds': [
        ('Getting uncategorized bookmarks', ['apiv2/users/frederic.font/bookmark_categories/0/sounds/']),
        ('Getting sounds of a particular bookmark cateogry', ['apiv2/users/frederic.font/bookmark_categories/11819/sounds/', 'apiv2/users/frederic.font/bookmark_categories/11819/sounds/?fields=duration,previews']),
    ],

    # Packs
    'PackInstance': [
        ('Getting a pack', ['apiv2/packs/9678/']),
    ],
    'PackSounds': [
        ('Getting pack sounds', ['apiv2/packs/9678/sounds/','apiv2/packs/9678/sounds/?fields=id,name']),
    ],
    'DownloadPack': [
        ('Download a pack', ['curl -H "Authorization: Bearer {{access_token}}" \'%s/apiv2/packs/9678/download/\'']),
    ],

}
########NEW FILE########
__FILENAME__ = exceptions
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from rest_framework.exceptions import APIException
from rest_framework import status
import logging

logger = logging.getLogger("api_errors")


class NotFoundException(APIException):
    detail = None
    status_code = status.HTTP_404_NOT_FOUND

    def __init__(self, msg="Not found"):
        logger.error('<%i Not found> %s' % (self.status_code, msg))
        self.detail = msg


class InvalidUrlException(APIException):
    detail = None
    status_code = status.HTTP_400_BAD_REQUEST

    def __init__(self, msg="Invalid url"):
        logger.error('<%i Invalid url> %s' % (self.status_code, msg))
        self.detail = msg


class BadRequestException(APIException):
    detail = None
    status_code = status.HTTP_400_BAD_REQUEST

    def __init__(self, msg="Bad request"):
        logger.error('<%i Bad request> %s' % (self.status_code, msg))
        self.detail = msg


class ConflictException(APIException):
    detail = None
    status_code = status.HTTP_409_CONFLICT

    def __init__(self, msg="Conflict"):
        logger.error('<%i Conflict> %s' % (self.status_code, msg))
        self.detail = msg


class UnauthorizedException(APIException):
    detail = None
    status_code = status.HTTP_401_UNAUTHORIZED

    def __init__(self, msg="Not authorized"):
        logger.error('<%i Not authorized> %s' % (self.status_code, msg))
        self.detail = msg


class RequiresHttpsException(APIException):
    detail = None
    status_code = status.HTTP_403_FORBIDDEN

    def __init__(self, msg="This resource requires a secure connection (https)"):
        logger.error('<%i Requires Https> %s' % (self.status_code, msg))
        self.detail = msg


class ServerErrorException(APIException):
    detail = None
    status_code = status.HTTP_500_INTERNAL_SERVER_ERROR

    def __init__(self, msg="Server error"):
        logger.error('<%i Server error> %s' % (self.status_code, msg))
        self.detail = msg


class OtherException(APIException):
    detail = None
    status_code = None

    def __init__(self, msg="Bad request", status=status.HTTP_400_BAD_REQUEST):
        logger.error('<%i Other exception> %s' % (status, msg))
        self.detail = msg
        self.status_code = status


class Throttled(APIException):
    detail = None
    status_code = status.HTTP_429_TOO_MANY_REQUESTS

    def __init__(self, msg="Request was throttled"):
        logger.error('<%i Throttled> %s' % (self.status_code, msg))
        self.detail = msg


########NEW FILE########
__FILENAME__ = forms
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

import django.forms as forms
import settings
from urllib import quote, unquote
from django.contrib.sites.models import Site
from exceptions import BadRequestException


class ApiV2ClientForm(forms.Form):
    name          = forms.CharField(label='Application name', widget=forms.TextInput(attrs={'style': 'width:500px'}))
    url           = forms.URLField(label='Application url', widget=forms.TextInput(attrs={'style': 'width:500px'}))
    redirect_uri  = forms.URLField(label='Your application\'s callback URL*', widget=forms.TextInput(attrs={'style': 'width:500px'}))
    description   = forms.CharField(label='Describe your application', widget=forms.Textarea(attrs={'style': 'width:500px'}))
    accepted_tos  = forms.BooleanField(label='',
                                       help_text='Check this box to accept the <a href="/help/tos_api/" target="_blank">terms of use</a> of the Freesound API',
                                       required=True,
                                       error_messages={'required': 'You must accept the terms of use in order to get access to the API.'})


SEARCH_SORT_OPTIONS_API = [
        ("score", "score desc"),
        ("duration_desc", "duration desc"),
        ("duration_asc", "duration asc"),
        ("created_desc", "created desc"),
        ("created_asc", "created asc"),
        ("downloads_desc", "num_downloads desc"),
        ("downloads_asc", "num_downloads asc"),
        ("rating_desc", "avg_rating desc"),
        ("rating_asc", "avg_rating asc")
    ]

SEARCH_DEFAULT_SORT = "score desc"


def my_quote(s):
    return quote(s,safe=",:[]*+()'")


class SoundCombinedSearchFormAPI(forms.Form):
    query               = forms.CharField(required=False, label='query')
    page                = forms.CharField(required=False, label='page')
    filter              = forms.CharField(required=False, label='filter')
    sort                = forms.CharField(required=False, label='sort')
    fields              = forms.CharField(required=False, label='fields')
    descriptors         = forms.CharField(required=False, label='descriptors')
    normalized          = forms.CharField(required=False, label='normalized')
    page_size           = forms.CharField(required=False, label='page_size')
    group_by_pack       = forms.CharField(required=False, label='group_by_pack')
    descriptors_filter  = forms.CharField(required=False, label='descriptors_filter')
    target              = forms.CharField(required=False, label='target')

    def clean_query(self):
        query = self.cleaned_data['query']
        if unquote(query).replace('"','').isspace() or unquote(query).replace('"','') == '':
            return ""
        return my_quote(query) if 'query' in self.data else None

    def clean_filter(self):
        filter = self.cleaned_data['filter']
        if 'filter' in self.data and (not filter or filter.isspace()):
            raise BadRequestException('Invalid filter.')
        return my_quote(filter) if 'filter' in self.data else None

    def clean_descriptors(self):
        descriptors = self.cleaned_data['descriptors']
        return my_quote(descriptors) if descriptors != None else ""

    def clean_normalized(self):
        requested_normalized = self.cleaned_data['normalized']
        normalized = ''
        if requested_normalized:
            normalized = '1'
        return normalized

    def clean_page(self):
        try:
            page = int(self.cleaned_data['page'])
        except:
            return 1
        return page

    def clean_sort(self):

        sort_option = None
        for option in SEARCH_SORT_OPTIONS_API:
            if option[0] == str(self.cleaned_data['sort']):
                sort_option = option[1]
                self.original_url_sort_value = option[0]

        if not sort_option:
            sort_option = SEARCH_DEFAULT_SORT
            self.original_url_sort_value = SEARCH_DEFAULT_SORT.split(' ')[0]

        if sort_option == "avg_rating desc":
            sort = [sort_option, "num_ratings desc"]
        elif sort_option == "avg_rating asc":
            sort = [sort_option, "num_ratings asc"]
        else:
            sort = [sort_option]

        return sort

    def clean_fields(self):
        fields = self.cleaned_data['fields']
        return my_quote(fields) if fields != None else ""

    def clean_group_by_pack(self):
        requested_group_by_pack = self.cleaned_data['group_by_pack']
        group_by_pack = ''
        try:
            if int(requested_group_by_pack):
                group_by_pack = '1'
        except:
            pass
        return group_by_pack

    def clean_page_size(self):
        requested_paginate_by = self.cleaned_data[settings.REST_FRAMEWORK['PAGINATE_BY_PARAM']] or settings.REST_FRAMEWORK['PAGINATE_BY']
        try:
            paginate_by = min(int(requested_paginate_by), settings.REST_FRAMEWORK['MAX_PAGINATE_BY'])
        except:
            paginate_by = settings.REST_FRAMEWORK['MAX_PAGINATE_BY']
        return paginate_by

    def clean_descriptors_filter(self):
        descriptors_filter = self.cleaned_data['descriptors_filter']
        if 'descriptors_filter' in self.data and (not descriptors_filter or descriptors_filter.isspace()):
            raise BadRequestException('Invalid descriptiors_filter.')
        return my_quote(descriptors_filter) if descriptors_filter != None else ""

    def clean_target(self):
        target = self.cleaned_data['target']
        if 'target' in self.data and (not target or target.isspace()):
            raise BadRequestException('Invalid target.')
        return my_quote(target) if target != None else ""

    def construct_link(self, base_url, page=None, filter=None, group_by_pack=None, include_page=True):
        link = "?"
        if self.cleaned_data['query'] != None:
            link += '&query=%s' % self.cleaned_data['query']
        if not filter:
            if self.cleaned_data['filter']:
                link += '&filter=%s' % self.cleaned_data['filter']
        else:
            link += '&filter=%s' % my_quote(filter)
        if self.original_url_sort_value and not self.original_url_sort_value == SEARCH_DEFAULT_SORT.split(' ')[0]:
            link += '&sort=%s' % self.original_url_sort_value
        if self.cleaned_data['descriptors_filter']:
                link += '&descriptors_filter=%s' % self.cleaned_data['descriptors_filter']
        if self.cleaned_data['target']:
                link += '&target=%s' % self.cleaned_data['target']
        if include_page:
            if not page:
                if self.cleaned_data['page'] and self.cleaned_data['page'] != 1:
                    link += '&page=%s' % self.cleaned_data['page']
            else:
                link += '&page=%s' % str(page)
        if self.cleaned_data['page_size'] and not self.cleaned_data['page_size'] == settings.REST_FRAMEWORK['PAGINATE_BY']:
            link += '&page_size=%s' % str(self.cleaned_data['page_size'])
        if self.cleaned_data['fields']:
            link += '&fields=%s' % self.cleaned_data['fields']
        if self.cleaned_data['descriptors']:
            link += '&descriptors=%s' % self.cleaned_data['descriptors']
        if self.cleaned_data['normalized']:
            link += '&normalized=%s' % self.cleaned_data['normalized']
        if not group_by_pack:
            if self.cleaned_data['group_by_pack']:
                link += '&group_by_pack=%s' % self.cleaned_data['group_by_pack']
        else:
            link += '&group_by_pack=%s' % group_by_pack

        return "http://%s%s%s" % (Site.objects.get_current().domain, base_url, link)


class SoundTextSearchFormAPI(SoundCombinedSearchFormAPI):
    '''
    This form is like CombinedSearch but disabling content-search-only fields
    '''

    def clean_target(self):
        return None

    def clean_descriptors_filter(self):
        return None


class SoundContentSearchFormAPI(SoundCombinedSearchFormAPI):
    '''
    This form is like CombinedSearch but disabling text-search-only fields
    '''

    def clean_query(self):
        return None

    def clean_filter(self):
        return None

    def clean_sort(self):
        self.original_url_sort_value = False
        return None

    def clean_group_by_pack(self):
        return None


class SimilarityFormAPI(SoundCombinedSearchFormAPI):

    def clean_query(self):
        return None

    def clean_filter(self):
        return None

    def clean_sort(self):
        self.original_url_sort_value = None
        return None

    def clean_group_by_pack(self):
        return None

    def clean_target(self):
        return None
########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'ApiV2Client'
        db.create_table('apiv2_apiv2client', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('oauth_client', self.gf('django.db.models.fields.related.ForeignKey')(default=None, related_name='apiv2_client', null=True, blank=True, to=orm['oauth2.Client'])),
            ('key', self.gf('django.db.models.fields.CharField')(max_length=40, blank=True)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(related_name='apiv2_client', to=orm['auth.User'])),
            ('status', self.gf('django.db.models.fields.CharField')(default='OK', max_length=3)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=64)),
            ('url', self.gf('django.db.models.fields.URLField')(max_length=200)),
            ('redirect_uri', self.gf('django.db.models.fields.URLField')(max_length=200, blank=True)),
            ('description', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('accepted_tos', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('allow_oauth_passoword_grant', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
        ))
        db.send_create_signal('apiv2', ['ApiV2Client'])


    def backwards(self, orm):
        
        # Deleting model 'ApiV2Client'
        db.delete_table('apiv2_apiv2client')


    models = {
        'apiv2.apiv2client': {
            'Meta': {'object_name': 'ApiV2Client'},
            'accepted_tos': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_oauth_passoword_grant': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '40', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'oauth_client': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'related_name': "'apiv2_client'", 'null': 'True', 'blank': 'True', 'to': "orm['oauth2.Client']"}),
            'redirect_uri': ('django.db.models.fields.URLField', [], {'max_length': '200', 'blank': 'True'}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'OK'", 'max_length': '3'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'apiv2_client'", 'to': "orm['auth.User']"})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'oauth2.client': {
            'Meta': {'object_name': 'Client'},
            'client_id': ('django.db.models.fields.CharField', [], {'default': "'d700223176fc3827ecdf'", 'max_length': '255'}),
            'client_secret': ('django.db.models.fields.CharField', [], {'default': "'15474c439ff37b6c6cc38a4ce20a11d62f0202e1'", 'max_length': '255'}),
            'client_type': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'redirect_uri': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'oauth2_client'", 'null': 'True', 'to': "orm['auth.User']"})
        }
    }

    complete_apps = ['apiv2']

########NEW FILE########
__FILENAME__ = 0002_auto__chg_field_apiv2client_oauth_client__add_unique_apiv2client_oauth
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Changing field 'ApiV2Client.oauth_client'
        db.alter_column('apiv2_apiv2client', 'oauth_client_id', self.gf('django.db.models.fields.related.OneToOneField')(null=True, to=orm['oauth2.Client'], unique=True))

        # Adding unique constraint on 'ApiV2Client', fields ['oauth_client']
        db.create_unique('apiv2_apiv2client', ['oauth_client_id'])


    def backwards(self, orm):
        
        # Removing unique constraint on 'ApiV2Client', fields ['oauth_client']
        db.delete_unique('apiv2_apiv2client', ['oauth_client_id'])

        # Changing field 'ApiV2Client.oauth_client'
        db.alter_column('apiv2_apiv2client', 'oauth_client_id', self.gf('django.db.models.fields.related.ForeignKey')(null=True, to=orm['oauth2.Client']))


    models = {
        'apiv2.apiv2client': {
            'Meta': {'object_name': 'ApiV2Client'},
            'accepted_tos': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_oauth_passoword_grant': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '40', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'oauth_client': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'apiv2_client'", 'null': 'True', 'default': 'None', 'to': "orm['oauth2.Client']", 'blank': 'True', 'unique': 'True'}),
            'redirect_uri': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'OK'", 'max_length': '3'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'apiv2_client'", 'to': "orm['auth.User']"})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'oauth2.client': {
            'Meta': {'object_name': 'Client'},
            'client_id': ('django.db.models.fields.CharField', [], {'default': "'3c8828eb2e18db67964d'", 'max_length': '255'}),
            'client_secret': ('django.db.models.fields.CharField', [], {'default': "'9e7ccb0ff8d438b93d206f9929b9df809474c111'", 'max_length': '255'}),
            'client_type': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'redirect_uri': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'oauth2_client'", 'null': 'True', 'to': "orm['auth.User']"})
        }
    }

    complete_apps = ['apiv2']

########NEW FILE########
__FILENAME__ = 0003_auto__add_field_apiv2client_scopes
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'ApiV2Client.scopes'
        db.add_column('apiv2_apiv2client', 'scopes', self.gf('django.db.models.fields.CharField')(default='r', max_length=3), keep_default=False)


    def backwards(self, orm):
        
        # Deleting field 'ApiV2Client.scopes'
        db.delete_column('apiv2_apiv2client', 'scopes')


    models = {
        'apiv2.apiv2client': {
            'Meta': {'object_name': 'ApiV2Client'},
            'accepted_tos': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_oauth_passoword_grant': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '40', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'oauth_client': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'apiv2_client'", 'null': 'True', 'default': 'None', 'to': "orm['oauth2.Client']", 'blank': 'True', 'unique': 'True'}),
            'redirect_uri': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'scopes': ('django.db.models.fields.CharField', [], {'default': "'r'", 'max_length': '3'}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'OK'", 'max_length': '3'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'apiv2_client'", 'to': "orm['auth.User']"})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'oauth2.client': {
            'Meta': {'object_name': 'Client'},
            'client_id': ('django.db.models.fields.CharField', [], {'default': "'3c8eed6a8d7dc1fdeeb6'", 'max_length': '255'}),
            'client_secret': ('django.db.models.fields.CharField', [], {'default': "'dc95c3ea14759a18d06ab30f50d2c65778456f86'", 'max_length': '255'}),
            'client_type': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'redirect_uri': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'oauth2_client'", 'null': 'True', 'to': "orm['auth.User']"})
        }
    }

    complete_apps = ['apiv2']

########NEW FILE########
__FILENAME__ = 0004_auto__del_field_apiv2client_scopes__add_field_apiv2client_scope
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Deleting field 'ApiV2Client.scopes'
        db.delete_column('apiv2_apiv2client', 'scopes')

        # Adding field 'ApiV2Client.scope'
        db.add_column('apiv2_apiv2client', 'scope', self.gf('django.db.models.fields.CharField')(default='r', max_length=3), keep_default=False)


    def backwards(self, orm):
        
        # Adding field 'ApiV2Client.scopes'
        db.add_column('apiv2_apiv2client', 'scopes', self.gf('django.db.models.fields.CharField')(default='r', max_length=3), keep_default=False)

        # Deleting field 'ApiV2Client.scope'
        db.delete_column('apiv2_apiv2client', 'scope')


    models = {
        'apiv2.apiv2client': {
            'Meta': {'object_name': 'ApiV2Client'},
            'accepted_tos': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_oauth_passoword_grant': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '40', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'oauth_client': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'apiv2_client'", 'null': 'True', 'default': 'None', 'to': "orm['oauth2.Client']", 'blank': 'True', 'unique': 'True'}),
            'redirect_uri': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'scope': ('django.db.models.fields.CharField', [], {'default': "'r'", 'max_length': '3'}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'OK'", 'max_length': '3'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'apiv2_client'", 'to': "orm['auth.User']"})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'oauth2.client': {
            'Meta': {'object_name': 'Client'},
            'client_id': ('django.db.models.fields.CharField', [], {'default': "'0132c225843bf3d2ebcb'", 'max_length': '255'}),
            'client_secret': ('django.db.models.fields.CharField', [], {'default': "'445cd36cff2e9d434d82ecaeadac943beca9fa63'", 'max_length': '255'}),
            'client_type': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'redirect_uri': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'oauth2_client'", 'null': 'True', 'to': "orm['auth.User']"})
        }
    }

    complete_apps = ['apiv2']

########NEW FILE########
__FILENAME__ = 0005_auto__add_uploadedsoundfile
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'UploadedSoundFile'
        db.create_table('apiv2_uploadedsoundfile', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('title', self.gf('django.db.models.fields.CharField')(default='default_value', max_length=100)),
            ('docfile', self.gf('django.db.models.fields.files.FileField')(max_length=100)),
        ))
        db.send_create_signal('apiv2', ['UploadedSoundFile'])


    def backwards(self, orm):
        
        # Deleting model 'UploadedSoundFile'
        db.delete_table('apiv2_uploadedsoundfile')


    models = {
        'apiv2.apiv2client': {
            'Meta': {'object_name': 'ApiV2Client'},
            'accepted_tos': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_oauth_passoword_grant': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '40', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'oauth_client': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'apiv2_client'", 'null': 'True', 'default': 'None', 'to': "orm['oauth2.Client']", 'blank': 'True', 'unique': 'True'}),
            'redirect_uri': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'scope': ('django.db.models.fields.CharField', [], {'default': "'r'", 'max_length': '3'}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'OK'", 'max_length': '3'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'apiv2_client'", 'to': "orm['auth.User']"})
        },
        'apiv2.uploadedsoundfile': {
            'Meta': {'object_name': 'UploadedSoundFile'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'docfile': ('django.db.models.fields.files.FileField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'default': "'default_value'", 'max_length': '100'})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'oauth2.client': {
            'Meta': {'object_name': 'Client'},
            'client_id': ('django.db.models.fields.CharField', [], {'default': "'d791a1a6d1150660e9da'", 'max_length': '255'}),
            'client_secret': ('django.db.models.fields.CharField', [], {'default': "'455c5df6f48b951aa18f9c64908dad818c65d508'", 'max_length': '255'}),
            'client_type': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'redirect_uri': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'oauth2_client'", 'null': 'True', 'to': "orm['auth.User']"})
        }
    }

    complete_apps = ['apiv2']

########NEW FILE########
__FILENAME__ = 0006_auto__del_field_uploadedsoundfile_title__del_field_uploadedsoundfile_d
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Deleting field 'UploadedSoundFile.title'
        db.delete_column('apiv2_uploadedsoundfile', 'title')

        # Deleting field 'UploadedSoundFile.docfile'
        db.delete_column('apiv2_uploadedsoundfile', 'docfile')

        # Adding field 'UploadedSoundFile.filename'
        db.add_column('apiv2_uploadedsoundfile', 'filename', self.gf('django.db.models.fields.CharField')(default='default_value', max_length=100), keep_default=False)

        # Adding field 'UploadedSoundFile.audiofile'
        db.add_column('apiv2_uploadedsoundfile', 'audiofile', self.gf('django.db.models.fields.files.FileField')(default='examnple/file.wav', max_length=100), keep_default=False)


    def backwards(self, orm):
        
        # Adding field 'UploadedSoundFile.title'
        db.add_column('apiv2_uploadedsoundfile', 'title', self.gf('django.db.models.fields.CharField')(default='default_value', max_length=100), keep_default=False)

        # Adding field 'UploadedSoundFile.docfile'
        db.add_column('apiv2_uploadedsoundfile', 'docfile', self.gf('django.db.models.fields.files.FileField')(default='example/file.wav', max_length=100), keep_default=False)

        # Deleting field 'UploadedSoundFile.filename'
        db.delete_column('apiv2_uploadedsoundfile', 'filename')

        # Deleting field 'UploadedSoundFile.audiofile'
        db.delete_column('apiv2_uploadedsoundfile', 'audiofile')


    models = {
        'apiv2.apiv2client': {
            'Meta': {'object_name': 'ApiV2Client'},
            'accepted_tos': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_oauth_passoword_grant': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '40', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'oauth_client': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'apiv2_client'", 'null': 'True', 'default': 'None', 'to': "orm['oauth2.Client']", 'blank': 'True', 'unique': 'True'}),
            'redirect_uri': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'scope': ('django.db.models.fields.CharField', [], {'default': "'r'", 'max_length': '3'}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'OK'", 'max_length': '3'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'apiv2_client'", 'to': "orm['auth.User']"})
        },
        'apiv2.uploadedsoundfile': {
            'Meta': {'object_name': 'UploadedSoundFile'},
            'audiofile': ('django.db.models.fields.files.FileField', [], {'max_length': '100'}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'filename': ('django.db.models.fields.CharField', [], {'default': "'default_value'", 'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'oauth2.client': {
            'Meta': {'object_name': 'Client'},
            'client_id': ('django.db.models.fields.CharField', [], {'default': "'6a41ff0cfa7ea5ce5101'", 'max_length': '255'}),
            'client_secret': ('django.db.models.fields.CharField', [], {'default': "'d20156b3ca10c37d0eed78c121fb1cb62ad13523'", 'max_length': '255'}),
            'client_type': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'redirect_uri': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'oauth2_client'", 'null': 'True', 'to': "orm['auth.User']"})
        }
    }

    complete_apps = ['apiv2']

########NEW FILE########
__FILENAME__ = 0007_auto__del_uploadedsoundfile
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Deleting model 'UploadedSoundFile'
        db.delete_table('apiv2_uploadedsoundfile')


    def backwards(self, orm):
        
        # Adding model 'UploadedSoundFile'
        db.create_table('apiv2_uploadedsoundfile', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('filename', self.gf('django.db.models.fields.CharField')(default='default_value', max_length=100)),
            ('audiofile', self.gf('django.db.models.fields.files.FileField')(max_length=100)),
            ('created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
        ))
        db.send_create_signal('apiv2', ['UploadedSoundFile'])


    models = {
        'apiv2.apiv2client': {
            'Meta': {'object_name': 'ApiV2Client'},
            'accepted_tos': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_oauth_passoword_grant': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '40', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'oauth_client': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'apiv2_client'", 'null': 'True', 'default': 'None', 'to': "orm['oauth2.Client']", 'blank': 'True', 'unique': 'True'}),
            'redirect_uri': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'scope': ('django.db.models.fields.CharField', [], {'default': "'r'", 'max_length': '3'}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'OK'", 'max_length': '3'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'apiv2_client'", 'to': "orm['auth.User']"})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'oauth2.client': {
            'Meta': {'object_name': 'Client'},
            'client_id': ('django.db.models.fields.CharField', [], {'default': "'ab497683234239330f06'", 'max_length': '255'}),
            'client_secret': ('django.db.models.fields.CharField', [], {'default': "'b2c830c3f9a3d31d0912b576939f66bc8c371a35'", 'max_length': '255'}),
            'client_type': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'redirect_uri': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'oauth2_client'", 'null': 'True', 'to': "orm['auth.User']"})
        }
    }

    complete_apps = ['apiv2']

########NEW FILE########
__FILENAME__ = 0008_auto__add_field_apiv2client_throttling_level
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'ApiV2Client.throttling_level'
        db.add_column('apiv2_apiv2client', 'throttling_level', self.gf('django.db.models.fields.IntegerField')(default=1), keep_default=False)


    def backwards(self, orm):
        
        # Deleting field 'ApiV2Client.throttling_level'
        db.delete_column('apiv2_apiv2client', 'throttling_level')


    models = {
        'apiv2.apiv2client': {
            'Meta': {'object_name': 'ApiV2Client'},
            'accepted_tos': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_oauth_passoword_grant': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '40', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'oauth_client': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'apiv2_client'", 'null': 'True', 'default': 'None', 'to': "orm['oauth2.Client']", 'blank': 'True', 'unique': 'True'}),
            'redirect_uri': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'scope': ('django.db.models.fields.CharField', [], {'default': "'rw'", 'max_length': '3'}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'OK'", 'max_length': '3'}),
            'throttling_level': ('django.db.models.fields.IntegerField', [], {'default': '1'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'apiv2_client'", 'to': "orm['auth.User']"})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'oauth2.client': {
            'Meta': {'object_name': 'Client'},
            'client_id': ('django.db.models.fields.CharField', [], {'default': "'dbc48ed781beaea75b27'", 'max_length': '255'}),
            'client_secret': ('django.db.models.fields.CharField', [], {'default': "'b472bf8b3133b2c29431596b5999e9bc2e65d0e2'", 'max_length': '255'}),
            'client_type': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'redirect_uri': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'oauth2_client'", 'null': 'True', 'to': "orm['auth.User']"})
        }
    }

    complete_apps = ['apiv2']

########NEW FILE########
__FILENAME__ = models
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.db import models
from django.contrib.auth.models import User
from provider.oauth2.models import Client


class ApiV2Client(models.Model):

    STATUS_CHOICES = (('OK',  'Approved'),
                      ('REJ', 'Rejected'),
                      ('REV', 'Revoked'),
                      ('PEN', 'Pending'))

    DEFAULT_STATUS = 'OK'

    SCOPE_CHOICES = (('r', 'read'),
                     ('w', 'write'),
                     ('rw', 'read+write'))

    DEFAULT_SCOPE = 'rw'

    oauth_client                = models.OneToOneField(Client, related_name='apiv2_client', default=None, null=True, blank=True)
    key                         = models.CharField(max_length=40, blank=True)
    user                        = models.ForeignKey(User, related_name='apiv2_client')
    status                      = models.CharField(max_length=3, default=DEFAULT_STATUS, choices=STATUS_CHOICES)
    name                        = models.CharField(max_length=64)
    url                         = models.URLField()
    redirect_uri                = models.URLField()
    description                 = models.TextField(blank=True)
    accepted_tos                = models.BooleanField(default=False)
    allow_oauth_passoword_grant = models.BooleanField(default=False)
    scope                       = models.CharField(max_length=3, default=DEFAULT_SCOPE, choices=SCOPE_CHOICES)
    created                     = models.DateTimeField(auto_now_add=True)
    throttling_level            = models.IntegerField(default=1)

    def __unicode__(self):
        return "credentials for developer %s" % self.user.username

    def save(self, *args, **kwargs):

        # If oauth client does not exist create a new one (that means ApiV2Client is being saved for the first time)
        # Otherwise update existing client

        if not self.oauth_client:
            # Set oauth client (create oauth client object)
            oauth_cient = Client.objects.create(
                user=self.user,
                name=self.name,
                url=self.url,
                redirect_uri=self.redirect_uri,
                client_type=1, # Public client
            )
            self.oauth_client = oauth_cient

            # Set key (using same key as in oauth client to simplify work for developers)
            self.key = self.oauth_client.client_secret

        else:
            # Update existing oauth client
            self.oauth_client.name = self.name
            self.oauth_client.url = self.url
            self.oauth_client.redirect_uri = self.redirect_uri
            self.oauth_client.save()

        return super(ApiV2Client, self).save(*args, **kwargs)

    def delete(self, *args, **kwargs):
        # On delete, delete also oauth client
        self.oauth_client.delete()
        super(ApiV2Client, self).delete(*args, **kwargs)

    @property
    def client_id(self):
        return self.oauth_client.client_id

    @property
    def client_secret(self):
        return self.oauth_client.client_secret

    @property
    def version(self):
        return "V2"
########NEW FILE########
__FILENAME__ = oauth2_urls
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.conf.urls.defaults import patterns, url
from django.contrib.auth import logout
from django.contrib.auth import REDIRECT_FIELD_NAME
from django.contrib.auth.views import redirect_to_login
from django.views.decorators.csrf import csrf_exempt
from django.http import HttpResponse
from apiv2.utils import AccessTokenView, Authorize, Capture, Redirect, prepend_base
import settings


'''
We create oauth2_urls.py files and then include to the main apiv2/urls.py because we were having namespace problems
otherwise. Apparently if namespace is defined manually (ex: name='oauth2:capture'), Django complains.
'''


if settings.USE_MINIMAL_TEMPLATES_FOR_OAUTH:
    login_url = prepend_base('/apiv2/login/', use_https=not settings.DEBUG, dynamic_resolve=False)
else:
    login_url = prepend_base(settings.LOGIN_URL, use_https=not settings.DEBUG, dynamic_resolve=False)


def https_and_login_required(view_func):
    def _wrapped_view_func(request, *args, **kwargs):
        if not request.using_https and not settings.DEBUG:
            return HttpResponse('{"detail": "This resource requires a secure connection (https)"}', status=403)
        if not request.user.is_authenticated():
            # Quick fix, should be implemented better
            path = request.build_absolute_uri().split('/apiv2/')[1]
            path = prepend_base('/apiv2/' + path, use_https=not settings.DEBUG, dynamic_resolve=False)
            return redirect_to_login(path, login_url, REDIRECT_FIELD_NAME)

        return view_func(request, *args, **kwargs)
    return _wrapped_view_func
    #return login_required(_wrapped_view_func, login_url=login_url)

def https_and_force_login(view_func):
    def _wrapped_view_func(request, *args, **kwargs):
        if not request.using_https and not settings.DEBUG:
            return HttpResponse('{"detail": "This resource requires a secure connection (https)"}', status=403)
        # Logout the user so we make sure he needs to login again
        logout(request)
        # Quick fix, should be implemented better
        path = request.build_absolute_uri().split('/apiv2/')[1]
        path = prepend_base('/apiv2/' + path, use_https=not settings.DEBUG, dynamic_resolve=False)
        path = path.replace('logout_and_', '')
        return redirect_to_login(path, login_url, REDIRECT_FIELD_NAME)

    return _wrapped_view_func
    #return login_required(_wrapped_view_func, login_url=login_url)


def https_required_and_crsf_exempt(view_func):
    def _wrapped_view_func(request, *args, **kwargs):
        if not request.using_https and not settings.DEBUG:
            return HttpResponse('{"detail": "This resource requires a secure connection (https)"}', status=403)
        return view_func(request, *args, **kwargs)
    return csrf_exempt(_wrapped_view_func)


urlpatterns = patterns('',
    url('^authorize/?$', https_and_login_required(Capture.as_view()), name='capture'),
    url('^logout_and_authorize/?$', https_and_force_login(Capture.as_view()), name='capture'),
    url('^authorize/confirm/?$', https_and_login_required(Authorize.as_view()), name='authorize'),
    url('^redirect/?$', https_and_login_required(Redirect.as_view()), name='redirect'),
    url('^access_token/?$', https_required_and_crsf_exempt(AccessTokenView.as_view()), name='access_token'),
)
########NEW FILE########
__FILENAME__ = serializers
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from sounds.models import Sound, Pack
from ratings.models import Rating
from comments.models import Comment
from bookmarks.models import BookmarkCategory, Bookmark
from django.contrib.auth.models import User
from django.core.urlresolvers import reverse
from rest_framework import serializers
from freesound.utils.tags import clean_and_split_tags
from freesound.utils.similarity_utilities import get_sounds_descriptors
from utils import prepend_base


###################
# SOUND SERIALIZERS
###################

DEFAULT_FIELDS_IN_SOUND_LIST = 'id,name,tags,username,license'  # Separated by commas (None = all)
DEFAULT_FIELDS_IN_SOUND_DETAIL = None  # Separated by commas (None = all)
DEFAULT_FIELDS_IN_PACK_DETAIL = None  # Separated by commas (None = all)


class AbstractSoundSerializer(serializers.HyperlinkedModelSerializer):
    '''
    In this abstract class we define ALL possible fields that a sound object should serialize/deserialize.
    Inherited classes set the default fields that will be shown in each view, although those can be altered using
    the 'fields' request parameter.
    '''
    default_fields = None

    def __init__(self, *args, **kwargs):
        super(AbstractSoundSerializer, self).__init__(*args, **kwargs)
        requested_fields = self.context['request'].GET.get("fields", self.default_fields)
        if not requested_fields: # If parameter is in url but parameter is empty, set to default
            requested_fields = self.default_fields

        if requested_fields:
            allowed = set(requested_fields.split(","))
            existing = set(self.fields.keys())
            for field_name in existing - allowed:
                self.fields.pop(field_name)


    class Meta:
        model = Sound
        fields = ('id',
                  #'uri',
                  'url',
                  'name',
                  'tags',
                  'description',
                  'geotag',
                  'created',
                  'license',
                  'type',
                  'channels',
                  'filesize',
                  'bitrate',
                  'bitdepth',
                  'duration',
                  'samplerate',
                  #'user',
                  'username',
                  'pack',
                  'download',
                  'bookmark',
                  'previews',
                  'images',
                  'num_downloads',
                  'avg_rating',
                  'num_ratings',
                  'rate',
                  'comments',
                  'num_comments',
                  'comment',
                  'similar_sounds',
                  'analysis',
                  'analysis_frames',
                  'analysis_stats',
                  )


    uri = serializers.SerializerMethodField('get_uri')
    def get_uri(self, obj):
        return prepend_base(reverse('apiv2-sound-instance', args=[obj.id]), request_is_secure=self.context['request'].using_https)

    url = serializers.SerializerMethodField('get_url')
    def get_url(self, obj):
        return prepend_base(reverse('sound', args=[obj.user.username, obj.id]), request_is_secure=self.context['request'].using_https)

    user = serializers.SerializerMethodField('get_user')
    def get_user(self, obj):
        return prepend_base(reverse('apiv2-user-instance', args=[obj.user.username]), request_is_secure=self.context['request'].using_https)

    username = serializers.SerializerMethodField('get_username')
    def get_username(self, obj):
        return obj.user.username

    name = serializers.SerializerMethodField('get_name')
    def get_name(self, obj):
        return obj.original_filename

    tags = serializers.SerializerMethodField('get_tags')
    def get_tags(self, obj):
        return [tagged.tag.name for tagged in obj.tags.select_related("tag").all()]

    license = serializers.SerializerMethodField('get_license')
    def get_license(self, obj):
        return obj.license.deed_url

    pack = serializers.SerializerMethodField('get_pack')
    def get_pack(self, obj):
        try:
            if obj.pack:
                return prepend_base(reverse('apiv2-pack-instance', args=[obj.pack.id]), request_is_secure=self.context['request'].using_https)
            else:
                return None
        except:
            return None

    previews = serializers.SerializerMethodField('get_previews')
    def get_previews(self, obj):
        return {
                'preview-hq-mp3': prepend_base(obj.locations("preview.HQ.mp3.url"), request_is_secure=self.context['request'].using_https),
                'preview-hq-ogg': prepend_base(obj.locations("preview.HQ.ogg.url"), request_is_secure=self.context['request'].using_https),
                'preview-lq-mp3': prepend_base(obj.locations("preview.LQ.mp3.url"), request_is_secure=self.context['request'].using_https),
                'preview-lq-ogg': prepend_base(obj.locations("preview.LQ.ogg.url"), request_is_secure=self.context['request'].using_https),
        }

    images = serializers.SerializerMethodField('get_images')
    def get_images(self, obj):
        return {
                'waveform_m': prepend_base(obj.locations("display.wave.M.url"), request_is_secure=self.context['request'].using_https),
                'waveform_l': prepend_base(obj.locations("display.wave.L.url"), request_is_secure=self.context['request'].using_https),
                'spectral_m': prepend_base(obj.locations("display.spectral.M.url"), request_is_secure=self.context['request'].using_https),
                'spectral_l': prepend_base(obj.locations("display.spectral.L.url"), request_is_secure=self.context['request'].using_https),
        }

    analysis = serializers.SerializerMethodField('get_analysis')
    def get_analysis(self, obj):
        # Fake implementation. Method implemented in subclasses
        return None

    analysis_frames = serializers.SerializerMethodField('get_analysis_frames')
    def get_analysis_frames(self, obj):
        return prepend_base(obj.locations('analysis.frames.url'), request_is_secure=self.context['request'].using_https)

    analysis_stats = serializers.SerializerMethodField('get_analysis_stats')
    def get_analysis_stats(self, obj):
        return prepend_base(reverse('apiv2-sound-analysis', args=[obj.id]), request_is_secure=self.context['request'].using_https)

    similar_sounds = serializers.SerializerMethodField('get_similar_sounds')
    def get_similar_sounds(self, obj):
        return prepend_base(reverse('apiv2-similarity-sound', args=[obj.id]), request_is_secure=self.context['request'].using_https)

    download = serializers.SerializerMethodField('get_download')
    def get_download(self, obj):
        return prepend_base(reverse('apiv2-sound-download', args=[obj.id]), request_is_secure=self.context['request'].using_https)

    rate = serializers.SerializerMethodField('get_rate')
    def get_rate(self, obj):
        return prepend_base(reverse('apiv2-user-create-rating', args=[obj.id]), request_is_secure=self.context['request'].using_https)

    bookmark = serializers.SerializerMethodField('get_bookmark')
    def get_bookmark(self, obj):
        return prepend_base(reverse('apiv2-user-create-bookmark', args=[obj.id]), request_is_secure=self.context['request'].using_https)

    comment = serializers.SerializerMethodField('get_comment')
    def get_comment(self, obj):
        return prepend_base(reverse('apiv2-user-create-comment', args=[obj.id]), request_is_secure=self.context['request'].using_https)

    ratings = serializers.SerializerMethodField('get_ratings')
    def get_ratings(self, obj):
        return prepend_base(reverse('apiv2-sound-ratings', args=[obj.id]), request_is_secure=self.context['request'].using_https)

    avg_rating = serializers.SerializerMethodField('get_avg_rating')
    def get_avg_rating(self, obj):
        return obj.avg_rating/2

    comments = serializers.SerializerMethodField('get_comments')
    def get_comments(self, obj):
        return prepend_base(reverse('apiv2-sound-comments', args=[obj.id]), request_is_secure=self.context['request'].using_https)

    geotag = serializers.SerializerMethodField('get_geotag')
    def get_geotag(self, obj):
        if obj.geotag:
            return str(obj.geotag.lat) + " " + str(obj.geotag.lon)
        else:
            return None


class SoundListSerializer(AbstractSoundSerializer):

    def __init__(self, *args, **kwargs):
        self.default_fields = DEFAULT_FIELDS_IN_SOUND_LIST
        super(SoundListSerializer, self).__init__(*args, **kwargs)

    def get_analysis(self, obj):
        # Get descriptors from the view class (should have been requested before the serializer is invoked)
        try:
            return self.context['view'].sound_analysis_data[str(obj.id)]
        except Exception, e:
            return None


class SoundSerializer(AbstractSoundSerializer):

    def __init__(self, *args, **kwargs):
        self.default_fields = DEFAULT_FIELDS_IN_SOUND_DETAIL
        super(SoundSerializer, self).__init__(*args, **kwargs)

    def get_analysis(self, obj):
        # Get the sound descriptors from gaia
        try:
            descriptors = self.context['request'].GET.get('descriptors', [])
            if descriptors:
                return get_sounds_descriptors([obj.id],
                                              descriptors.split(','),
                                              self.context['request'].GET.get('normalized', '0') == '1',
                                              only_leaf_descriptors=True)[str(obj.id)]
            else:
                return 'No descriptors specified. You should indicate which descriptors you want with the \'descriptors\' request parameter.'
        except Exception, e:
            return None


##################
# USER SERIALIZERS
##################


class UserSerializer(serializers.HyperlinkedModelSerializer):

    class Meta:
        model = User
        fields = (#'uri',
                  'url',
                  'username',
                  'about',
                  'home_page',
                  'avatar',
                  'date_joined',
                  'num_sounds',
                  'sounds',
                  'num_packs',
                  'packs',
                  'num_posts',
                  'num_comments',
                  'bookmark_categories',
                  )

    url = serializers.SerializerMethodField('get_url')
    def get_url(self, obj):
        return prepend_base(reverse('account', args=[obj.username]), request_is_secure=self.context['request'].using_https)

    uri = serializers.SerializerMethodField('get_uri')
    def get_uri(self, obj):
        return prepend_base(reverse('apiv2-user-instance', args=[obj.username]), request_is_secure=self.context['request'].using_https)

    sounds = serializers.SerializerMethodField('get_sounds')
    def get_sounds(self, obj):
        return prepend_base(reverse('apiv2-user-sound-list', args=[obj.username]), request_is_secure=self.context['request'].using_https)

    packs = serializers.SerializerMethodField('get_packs')
    def get_packs(self, obj):
        return prepend_base(reverse('apiv2-user-packs', args=[obj.username]), request_is_secure=self.context['request'].using_https)

    bookmark_categories = serializers.SerializerMethodField('get_bookmark_categories')
    def get_bookmark_categories(self, obj):
        return prepend_base(reverse('apiv2-user-bookmark-categories', args=[obj.username]), request_is_secure=self.context['request'].using_https)

    avatar = serializers.SerializerMethodField('get_avatar')
    def get_avatar(self, obj):
        if obj.profile.has_avatar:
            return {
                    'Small': prepend_base(obj.profile.locations()['avatar']['S']['url'], request_is_secure=self.context['request'].using_https),
                    'Medium': prepend_base(obj.profile.locations()['avatar']['M']['url'], request_is_secure=self.context['request'].using_https),
                    'Large': prepend_base(obj.profile.locations()['avatar']['L']['url'], request_is_secure=self.context['request'].using_https),
            }
        else:
            return None

    about = serializers.SerializerMethodField('get_about')
    def get_about(self, obj):
        return obj.profile.about

    home_page = serializers.SerializerMethodField('get_home_page')
    def get_home_page(self, obj):
        return obj.profile.home_page

    num_sounds = serializers.SerializerMethodField('get_num_sounds')
    def get_num_sounds(self, obj):
        return obj.sounds.filter(moderation_state="OK", processing_state="OK").count()

    num_packs = serializers.SerializerMethodField('get_num_packs')
    def get_num_packs(self, obj):
        return obj.pack_set.all().count()

    num_posts = serializers.SerializerMethodField('get_num_posts')
    def get_num_posts(self, obj):
        return obj.profile.num_posts

    num_comments = serializers.SerializerMethodField('get_num_comments')
    def get_num_comments(self, obj):
        return obj.comment_set.all().count()


##################
# PACK SERIALIZERS
##################


class PackSerializer(serializers.HyperlinkedModelSerializer):

    class Meta:
        model = Pack
        fields = ('id',
                  #'uri',
                  'url',
                  'description',
                  'created',
                  'name',
                  #'user',
                  'username',
                  'num_sounds',
                  'sounds',
                  'num_downloads')

    url = serializers.SerializerMethodField('get_url')
    def get_url(self, obj):
        return prepend_base(reverse('pack', args=[obj.user.username, obj.id]), request_is_secure=self.context['request'].using_https)

    uri = serializers.SerializerMethodField('get_uri')
    def get_uri(self, obj):
        return prepend_base(reverse('apiv2-pack-instance', args=[obj.id]), request_is_secure=self.context['request'].using_https)

    sounds = serializers.SerializerMethodField('get_sounds')
    def get_sounds(self, obj):
        return prepend_base(reverse('apiv2-pack-sound-list', args=[obj.id]), request_is_secure=self.context['request'].using_https)

    user = serializers.SerializerMethodField('get_user')
    def get_user(self, obj):
        return prepend_base(reverse('apiv2-user-instance', args=[obj.user.username]), request_is_secure=self.context['request'].using_https)

    username = serializers.SerializerMethodField('get_username')
    def get_username(self, obj):
        return obj.user.username

##################
# BOOKMARK SERIALIZERS
##################


class BookmarkCategorySerializer(serializers.HyperlinkedModelSerializer):

    class Meta:
        model = BookmarkCategory
        fields = ('url',
                  'name',
                  'num_sounds',
                  'sounds')

    url = serializers.SerializerMethodField('get_url')
    def get_url(self, obj):
        if obj.id != 0:
            return prepend_base(reverse('bookmarks-for-user-for-category', args=[obj.user.username, obj.id]), request_is_secure=self.context['request'].using_https)
        else:
            return prepend_base(reverse('bookmarks-for-user', args=[obj.user.username]), request_is_secure=self.context['request'].using_https)

    num_sounds = serializers.SerializerMethodField('get_num_sounds')
    def get_num_sounds(self, obj):
        if obj.id != 0: # Category is not 'uncategorized'
            return obj.bookmarks.filter(sound__processing_state="OK", sound__moderation_state="OK").count()
        else:
            return Bookmark.objects.select_related("sound").filter(user__username=obj.user.username, category=None).count()

    sounds = serializers.SerializerMethodField('get_sounds')
    def get_sounds(self, obj):
        return prepend_base(reverse('apiv2-user-bookmark-category-sounds', args=[obj.user.username, obj.id]), request_is_secure=self.context['request'].using_https)


class CreateBookmarkSerializer(serializers.Serializer):
    category = serializers.CharField(max_length=128, required=False, help_text='Not required. Name you want to give to the category under which the bookmark will be classified (leave empty for no category).')
    name = serializers.CharField(max_length=128, required=False, help_text='Not required. Name you want to give to the bookmark (if empty, sound name will be used).')

    def validate_category(self, attrs, source):
        value = attrs[source]
        if value.isspace():
            attrs[source] = None
        return attrs

    def validate_name(self, attrs, source):
        value = attrs[source]
        if value.isspace():
            attrs[source] = None
        return attrs


####################
# RATING SERIALIZERS
####################

class SoundRatingsSerializer(serializers.HyperlinkedModelSerializer):

    class Meta:
        model = Rating
        fields = (#'user',
                  'username',
                  'rating',
                  'created')

    user = serializers.SerializerMethodField('get_user')
    def get_user(self, obj):
        return prepend_base(reverse('apiv2-user-instance', args=[obj.user.username]), request_is_secure=self.context['request'].using_https)

    username = serializers.SerializerMethodField('get_username')
    def get_username(self, obj):
        return obj.user.username

    rating = serializers.SerializerMethodField('get_rating')
    def get_rating(self, obj):
        if (obj.rating % 2 == 1):
            return float(obj.rating)/2
        else:
            return obj.rating/2


class CreateRatingSerializer(serializers.Serializer):
    rating = serializers.IntegerField(required=True, help_text='Required. Chose an integer rating between 0 and 5 (both included).')

    def validate_rating(self, attrs, source):
        value = attrs[source]
        if (value not in [0, 1, 2, 3, 4, 5]):
            raise serializers.ValidationError('You have to introduce an integer value between 0 and 5 (both included).')
        return attrs

####################
# COMMENTS SERIALIZERS
####################

class SoundCommentsSerializer(serializers.HyperlinkedModelSerializer):

    class Meta:
        model = Comment
        fields = (#'user',
                  'username',
                  'comment',
                  'created')

    user = serializers.SerializerMethodField('get_user')
    def get_user(self, obj):
        return prepend_base(reverse('apiv2-user-instance', args=[obj.user.username]), request_is_secure=self.context['request'].using_https)

    username = serializers.SerializerMethodField('get_username')
    def get_username(self, obj):
        return obj.user.username


class CreateCommentSerializer(serializers.Serializer):
    comment = serializers.CharField(required=True, help_text='Required. String comment.')

    def validate_comment(self, attrs, source):
        value = attrs[source]
        if value.isspace():
            raise serializers.ValidationError('This field is required.')
        return attrs


####################
# UPLOAD SERIALIZERS
####################

ALLOWED_EXTENSIONS = ['wav', 'aiff', 'aif', 'ogg', 'flac', 'mp3']

LICENSE_CHOICES = (
        ('Attribution', 'Attribution'),
        ('Attribution Noncommercial', 'Attribution Noncommercial'),
        ('Creative Commons 0', 'Creative Commons 0'),)

class SoundDescriptionSerializer(serializers.Serializer):
    upload_filename = serializers.CharField(max_length=512, help_text='Must match a filename from \'Pending Uploads\' resource.')
    name = serializers.CharField(max_length=512, required=False, help_text='Not required. Name you want to give to the sound (by default it will be the original filename).')
    tags = serializers.CharField(max_length=512, help_text='Separate tags with spaces. Join multi-word tags with dashes.')
    description = serializers.CharField(help_text='Textual description of the sound.')
    license = serializers.ChoiceField(choices=LICENSE_CHOICES, help_text='License for the sound. Must be either \'Attribution\', \'Attribution Noncommercial\' or \'Creative Commons 0\'.')
    pack = serializers.CharField(help_text='Not required. Pack name (if there is no such pack with that name, a new one will be created).', required=False)
    geotag = serializers.CharField(max_length=100, help_text='Not required. Latitude, longitude and zoom values in the form lat,lon,zoom (ex: \'2.145677,3.22345,14\').', required=False)

    def validate_upload_filename(self, attrs, source):
        value = attrs.get(source, None)
        if 'not_yet_described_audio_files' in self.context:
            if value not in self.context['not_yet_described_audio_files']:
                raise serializers.ValidationError('Upload filename (%s) must match with a filename from \'Pending Uploads\' resource.' % value)
        return attrs

    def validate_geotag(self, attrs, source):
        value = attrs.get(source, None)
        if not value:
            return attrs
        fails = False
        try:
            data = value.split(',')
        except:
            fails = True
        if len(data) != 3:
            fails = True
        try:
            float(data[0])
            float(data[1])
            int(data[2])
        except:
            fails = True
        if fails:
            raise serializers.ValidationError('Geotag should have the format \'float,float,integer\' (for latitude, longitude and zoom respectively).')
        else:
            # Check that ranges are corrent
            if float(data[0]) > 90 or float(data[0]) < -90:
                raise serializers.ValidationError('Latitude must be in the range [-90,90].')
            if float(data[1]) > 180 or float(data[0]) < -180:
                raise serializers.ValidationError('Longitude must be in the range [-180,180].')
            if int(data[2]) < 11:
                raise serializers.ValidationError('Zoom must be at least 11.')
        return attrs

    def validate_tags(self, attrs, source):
        value = attrs[source]
        tags = clean_and_split_tags(value)
        if len(tags) < 3:
            raise serializers.ValidationError('Your should at least have 3 tags...')
        elif len(tags) > 30:
            raise serializers.ValidationError('There can be maximum 30 tags, please select the most relevant ones!')
        attrs[source] = tags
        return attrs

    def validate_name(self, attrs, source):
        value = attrs[source]
        if value.isspace():
            attrs[source] = None
        return attrs

    def validate_pack(self, attrs, source):
        value = attrs[source]
        if value.isspace():
            attrs[source] = None
        return attrs

    def validate_description(self, attrs, source):
        if attrs[source].isspace():
            raise serializers.ValidationError('This field is required.')
        return attrs


class EditSoundDescriptionSerializer(serializers.Serializer):
    name = serializers.CharField(max_length=512, required=False, help_text='Not required. New name you want to give to the sound.')
    tags = serializers.CharField(max_length=512, required=False, help_text='Not required. Tags that should be assigned to the sound (note that existing ones will be deleted). Separate tags with spaces. Join multi-word tags with dashes.')
    description = serializers.CharField(required=False, help_text='Not required. New textual description for the sound.')
    license = serializers.ChoiceField(required=False, choices=LICENSE_CHOICES, help_text='Not required. New license for the sound. Must be either \'Attribution\', \'Attribution Noncommercial\' or \'Creative Commons 0\'.')
    pack = serializers.CharField(required=False, help_text='Not required. New pack name for the sound (if there is no such pack with that name, a new one will be created).')
    geotag = serializers.CharField(required=False, max_length=100, help_text='Not required. New geotag for the sound. Latitude, longitude and zoom values in the form lat,lon,zoom (ex: \'2.145677,3.22345,14\').')

    def validate_geotag(self, attrs, source):
        value = attrs.get(source, None)
        if not value:
            return attrs
        fails = False
        try:
            data = value.split(',')
        except:
            fails = True
        if len(data) != 3:
            fails = True
        try:
            float(data[0])
            float(data[1])
            int(data[2])
        except:
            fails = True
        if fails:
            raise serializers.ValidationError('Geotag should have the format \'float,float,integer\' (for latitude, longitude and zoom respectively).')
        else:
            # Check that ranges are corrent
            if float(data[0]) > 90 or float(data[0]) < -90:
                raise serializers.ValidationError('Latitude must be in the range [-90,90].')
            if float(data[1]) > 180 or float(data[0]) < -180:
                raise serializers.ValidationError('Longitude must be in the range [-180,180].')
            if int(data[2]) < 11:
                raise serializers.ValidationError('Zoom must be at least 11.')
        return attrs

    def validate_tags(self, attrs, source):
        value = attrs[source]
        tags = clean_and_split_tags(value)
        if 1 <= len(tags) < 3:
            raise serializers.ValidationError('Your should at least have 3 tags...')
        elif len(tags) > 30:
            raise serializers.ValidationError('There can be maximum 30 tags, please select the most relevant ones!')
        attrs[source] = tags
        return attrs

    def validate_name(self, attrs, source):
        value = attrs[source]
        if value.isspace():
            attrs[source] = None
        return attrs

    def validate_description(self, attrs, source):
        value = attrs[source]
        if value.isspace():
            attrs[source] = None
        return attrs

    def validate_pack(self, attrs, source):
        value = attrs[source]
        if value.isspace():
            attrs[source] = None
        return attrs


class UploadAndDescribeAudioFileSerializer(serializers.Serializer):
    audiofile = serializers.FileField(max_length=100, allow_empty_file=False, help_text='Required. Must be in .wav, .aif, .flac, .ogg or .mp3 format.')
    name = serializers.CharField(max_length=512, required=False, help_text='Not required. Name you want to give to the sound (by default it will be the original filename).')
    tags = serializers.CharField(max_length=512, required=False, help_text='Only required if providing file description. Separate tags with spaces. Join multi-word tags with dashes.')
    description = serializers.CharField(required=False, help_text='Only required if providing file description. Textual description of the sound.')
    license = serializers.ChoiceField(required=False, choices=LICENSE_CHOICES, help_text='Only required if providing file description. License for the sound. Must be either \'Attribution\', \'Attribution Noncommercial\' or \'Creative Commons 0\'.')
    pack = serializers.CharField(help_text='Not required. Pack name (if there is no such pack with that name, a new one will be created).', required=False)
    geotag = serializers.CharField(max_length=100, help_text='Not required. Latitude, longitude and zoom values in the form lat,lon,zoom (ex: \'2.145677,3.22345,14\').', required=False)

    def is_providing_description(self, attrs):
        for key, value in attrs.items():
            if key != 'audiofile' and key != 'upload_filename':
                if value:
                    return True
        return False

    def validate_audiofile(self, attrs, source):
        value = attrs[source]
        try:
            extension = value.name.split('.')[-1]
        except:
            extension = None
        if extension not in ALLOWED_EXTENSIONS or not extension:
            raise serializers.ValidationError('Uploaded file format not supported or not an audio file.')
        return attrs

    def validate_name(self, attrs, source):
        if not self.is_providing_description(attrs):
            attrs[source] = None
        if attrs[source].isspace():
            attrs[source] = None
        return attrs

    def validate_tags(self, attrs, source):
        if not self.is_providing_description(attrs):
            attrs[source] = None
        else:
            value = attrs[source]
            tags = clean_and_split_tags(value)
            if len(tags) < 3:
                raise serializers.ValidationError('Your should at least have 3 tags...')
            elif len(tags) > 30:
                raise serializers.ValidationError('There can be maximum 30 tags, please select the most relevant ones!')
            attrs[source] = tags
        return attrs

    def validate_description(self, attrs, source):
        if not self.is_providing_description(attrs):
            attrs[source] = None
        else:
            if attrs[source].isspace():
                raise serializers.ValidationError('This field is required.')
        return attrs

    def validate_license(self, attrs, source):
        if not self.is_providing_description(attrs):
            attrs[source] = None
        else:
            if not attrs[source]:
                raise serializers.ValidationError('This field is required.')
        return attrs

    def validate_pack(self, attrs, source):
        if not self.is_providing_description(attrs):
            attrs[source] = None
        if attrs[source].isspace():
            attrs[source] = None
        return attrs

    def validate_geotag(self, attrs, source):
        if not self.is_providing_description(attrs):
            attrs[source] = None
        else:
            value = attrs.get(source, None)
            if not value:
                return attrs
            fails = False
            try:
                data = value.split(',')
            except:
                fails = True
            if len(data) != 3:
                fails = True
            try:
                float(data[0])
                float(data[1])
                int(data[2])
            except:
                fails = True
            if fails:
                raise serializers.ValidationError('Geotag should have the format \'float,float,integer\' (for latitude, longitude and zoom respectively).')
            else:
                # Check that ranges are corrent
                if float(data[0]) > 90 or float(data[0]) < -90:
                    raise serializers.ValidationError('Latitude must be in the range [-90,90].')
                if float(data[1]) > 180 or float(data[0]) < -180:
                    raise serializers.ValidationError('Longitude must be in the range [-180,180].')
                if int(data[2]) < 11:
                    raise serializers.ValidationError('Zoom must be at least 11.')
        return attrs


########################
# SIMILARITY SERIALIZERS
########################

ALLOWED_ANALYSIS_EXTENSIONS = ['json']

class SimilarityFileSerializer(serializers.Serializer):
    analysis_file = serializers.FileField(max_length=100, allow_empty_file=False, help_text='Analysis file created with the latest freesound extractor. Must be in .json format.')

    def validate_analysis_file(self, attrs, source):
        value = attrs[source]
        try:
            extension = value.name.split('.')[-1]
        except:
            extension = None

        if extension not in ALLOWED_ANALYSIS_EXTENSIONS or not extension:
            raise serializers.ValidationError('Uploaded analysis file format not supported, must be .json.')

        return attrs
########NEW FILE########
__FILENAME__ = tests
"""
This file demonstrates writing tests using the unittest module. These will pass
when you run "manage.py test".

Replace this with more appropriate tests for your application.
"""

from django.test import TestCase


class SimpleTest(TestCase):
    def test_basic_addition(self):
        """
        Tests that 1 + 1 always equals 2.
        """
        self.assertEqual(1 + 1, 2)

########NEW FILE########
__FILENAME__ = throttling
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from rest_framework.throttling import SimpleRateThrottle
from exceptions import Throttled
from settings import APIV2_BASIC_THROTTLING_RATES_PER_LEVELS


class ClientBasedThrottling(SimpleRateThrottle):
    """
    This throttling class applies different throttling rates depending on the access level of the API client.
    For session request we apply a common throttling rate as there is no API client associated.
    """
    cache_format = 'throtte_%(identity)s'
    client = None

    def __init__(self):
        # Override the usual SimpleRateThrottle, because we can't determine
        # the rate until called by the view.
        pass

    def allow_request(self, request, view):
        # Get the ApiV2Client that made the request and its throttling level
        auth_method_name = request.successful_authenticator.authentication_method_name
        if auth_method_name == "OAuth2":
            self.client = request.auth.client.apiv2_client
            client_throttle_level = int(self.client.throttling_level)
        elif auth_method_name == "Token":
            self.client = request.auth
            client_throttle_level = int(self.client.throttling_level)
        elif auth_method_name == "Session":
            self.client = None
            client_throttle_level = 1

        try:
            limit_rates = view.throttling_rates_per_level[client_throttle_level]
        except:
            # Fallback to basic throttling levels if the view has not defined the throttling rates per level
            limit_rates = APIV2_BASIC_THROTTLING_RATES_PER_LEVELS[client_throttle_level]

        # Apply all the limit rates for the corresponding level
        if limit_rates:
            for rate in limit_rates:
                self.rate = rate
                self.num_requests, self.duration = self.parse_rate(rate)
                passes_throttle = super(ClientBasedThrottling, self).allow_request(request, view)
                if not passes_throttle:
                    msg = "Request was throttled because of exceeding a request limit rate (%s)" % rate
                    if client_throttle_level == 0:
                        # Prevent returning a absurd message like "exceeding a request limit rate (0/minute)"
                        msg = "Request was throttled because the ApiV2 credential has been suspended"
                    raise Throttled(msg=msg)
        return True

    def get_cache_key(self, request, view):
        if self.client:
            return self.cache_format % {
                'identity': self.client.client_id
            }
        else:
            # If using session based auth, we use the user id as identity for throttling cache
            return self.cache_format % {
                'identity': request.user.id
            }
########NEW FILE########
__FILENAME__ = urls
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

# packages to install:
#   - django-oauth2-provider ('0.2.6')
#   - djangorestframework ('2.3.8')
#   - markdown (for browseable api)


from django.conf.urls.defaults import patterns, url, include
from django.contrib.auth.views import login, logout
from apiv2 import views

#
# WATCH OUT! if changing url pattern names these should be changed in vews __doc__ too (to make sure examples work properly)
#

urlpatterns = patterns('apiv2.views',
    #############
    # READ ONLY #
    #############

    # Me
    url(r'^me/$', views.Me.as_view(), name="apiv2-me"),

    # Text/content/combined search
    url(r'^search/text/$', views.TextSearch.as_view(), name="apiv2-sound-text-search"),
    url(r'^search/content/$', views.ContentSearch.as_view(), name="apiv2-sound-content-search"),
    url(r'^search/combined/$', views.CombinedSearch.as_view(), name="apiv2-sound-combined-search"),

    # Sounds
    url(r'^sounds/(?P<pk>[0-9]+)/$', views.SoundInstance.as_view(), name="apiv2-sound-instance"),
    url(r'^sounds/(?P<pk>[0-9]+)/comments/$', views.SoundComments.as_view(), name="apiv2-sound-comments"),
    url(r'^sounds/(?P<pk>[0-9]+)/analysis/$', views.SoundAnalysis.as_view(), name="apiv2-sound-analysis"),
    url(r'^sounds/(?P<pk>[0-9]+)/similar/$', views.SimilarSounds.as_view(), name="apiv2-similarity-sound"),
    url(r'^sounds/(?P<pk>[0-9]+)/download/$', views.DownloadSound.as_view(), name="apiv2-sound-download"),
    # Create or edit
    url(r'^sounds/(?P<pk>[0-9]+)/edit/$', views.EditSoundDescription.as_view(), name='apiv2-sound-edit'),
    url(r'^sounds/(?P<pk>[0-9]+)/bookmark/$', views.BookmarkSound.as_view(), name='apiv2-user-create-bookmark'),
    url(r'^sounds/(?P<pk>[0-9]+)/rate/$', views.RateSound.as_view(), name='apiv2-user-create-rating'),
    url(r'^sounds/(?P<pk>[0-9]+)/comment/$', views.CommentSound.as_view(), name='apiv2-user-create-comment'),
    # Upload and describe
    url(r'^sounds/upload/$', views.UploadSound.as_view(), name="apiv2-uploads-upload"),
    url(r'^sounds/describe/$', views.DescribeSound.as_view(), name="apiv2-uploads-describe"),
    url(r'^sounds/pending_uploads/$', views.PendingUploads.as_view(), name="apiv2-uploads-pending"),

    # Users
    url(r'^users/(?P<username>[^//]+)/$', views.UserInstance.as_view(), name="apiv2-user-instance"),
    url(r'^users/(?P<username>[^//]+)/sounds/$', views.UserSounds.as_view(), name="apiv2-user-sound-list"),
    url(r'^users/(?P<username>[^//]+)/packs/$', views.UserPacks.as_view(), name='apiv2-user-packs'),
    url(r'^users/(?P<username>[^//]+)/bookmark_categories/$', views.UserBookmarkCategories.as_view(), name='apiv2-user-bookmark-categories'),
    url(r'^users/(?P<username>[^//]+)/bookmark_categories/(?P<category_id>\d+)/sounds/$', views.UserBookmarkCategorySounds.as_view(), name='apiv2-user-bookmark-category-sounds'),

    # Packs
    url(r'^packs/(?P<pk>[0-9]+)/$', views.PackInstance.as_view(), name='apiv2-pack-instance'),
    url(r'^packs/(?P<pk>[0-9]+)/sounds/$', views.PackSounds.as_view(), name='apiv2-pack-sound-list'),
    url(r'^packs/(?P<pk>[0-9]+)/download/$', views.DownloadPack.as_view(), name='apiv2-pack-download'),


    #########################
    # MANAGEMENT AND OAUTH2 #
    #########################

    # Client management
    url(r'^apply/$', views.create_apiv2_key, name="apiv2-apply"),
    url(r'^apply/credentials/(?P<key>[^//]+)/delete/$', views.delete_api_credential, name="apiv2-delete-credential"),
    url(r'^apply/credentials/(?P<key>[^//]+)/edit/$', views.edit_api_credential, name="apiv2-edit-credential"),

    # Oauth2
    url(r'^oauth2/', include('apiv2.oauth2_urls', namespace='oauth2')),
    url(r'^login/$', login, {'template_name': 'api/minimal_login.html'}, name="api-login"),
    url(r'^logout/$', logout, {'next_page': '/apiv2/'}, name="api-logout"),

    # Browseable api login and logout
    url(r'^api-auth/', include('rest_framework.urls', namespace='rest_framework')),

    # Minimal registration page
    url(r'^registration/$', views.minimal_registration, name="apiv2-registration"),

    #########
    # OTHER #
    #########
    url(r'^$', views.FreesoundApiV2Resources.as_view()),
    url(r'/$', views.invalid_url),
)



########NEW FILE########
__FILENAME__ = utils
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from provider.views import OAuthError
from provider.scope import to_names, to_int
from provider.oauth2.views import AccessTokenView as DjangoRestFrameworkAccessTokenView, Authorize as DjangoOauth2ProviderAuthorize, Capture as DjangoOauth2ProviderCapture, Redirect as DjangoOauth2ProviderRedirect
from provider.oauth2.forms import PasswordGrantForm
from provider.oauth2.models import RefreshToken, AccessToken
from rest_framework.generics import GenericAPIView as RestFrameworkGenericAPIView, ListAPIView as RestFrameworkListAPIView, RetrieveAPIView as RestFrameworkRetrieveAPIView
from apiv2.authentication import OAuth2Authentication, TokenAuthentication, SessionAuthentication
import combined_search_strategies
from sounds.models import Sound, Pack, License
from freesound.utils.audioprocessing import get_sound_type
from geotags.models import GeoTag
from freesound.utils.filesystem import md5file
from freesound.utils.text import slugify
from exceptions import *
from examples import examples
import shutil
import settings
import os
from freesound.utils.similarity_utilities import get_sounds_descriptors
from freesound.utils.search.solr import Solr, SolrException, SolrResponseInterpreter
from search.views import search_prepare_query
from freesound.utils.similarity_utilities import api_search as similarity_api_search
from similarity.client import SimilarityException
from urllib import unquote, quote
from django.http import HttpResponseRedirect, QueryDict
from django.utils.translation import ugettext as _
from django.contrib.sites.models import Site
from django.core.urlresolvers import resolve, reverse
import urlparse
from freesound.utils.cache import invalidate_template_cache
from django.contrib.auth.models import Group
from tickets.models import Ticket, Queue, LinkedContent, TicketComment
from tickets import TICKET_SOURCE_NEW_SOUND, TICKET_STATUS_NEW


############################
# Authentication util tweaks
############################


class AccessTokenView(DjangoRestFrameworkAccessTokenView):

    '''
    We override only a function of the AccessTokenView class in order to be able to set different
    allowed grant types per API client and to resctrict scopes on a client basis.
    '''

    def get_password_grant(self, request, data, client):
        if not client.apiv2_client.allow_oauth_passoword_grant:
            raise OAuthError({'error': 'unsupported_grant_type'})

        form = PasswordGrantForm(data, client=client)
        if not form.is_valid():
            raise OAuthError(form.errors)
        return form.cleaned_data

    def get_access_token(self, request, user, scope, client):
        # If previous access tokens exist, delete them
        at = AccessToken.objects.filter(user=user, client=client)
        for ati in at:
            ati.delete()

        # Create a new access token
        at = self.create_access_token(request, user, scope, client)
        self.create_refresh_token(request, user, scope, at, client)
        return at

    def refresh_token(self, request, data, client):
        """
        Handle ``grant_type=refresh_token`` requests as defined in :draft:`6`.
        We overwrite this function so that old access tokens are deleted when refreshed. Otherwise multiple access tokens
        can be created, leading to errors.
        """
        rt = self.get_refresh_token_grant(request, data, client)

        #self.invalidate_refresh_token(rt)
        #self.invalidate_access_token(rt.access_token)
        scope = rt.access_token.scope
        rt.access_token.delete()

        at = self.create_access_token(request, rt.user, scope, client)
        rt.delete()
        rt = self.create_refresh_token(request, at.user, at.scope, at, client)

        return self.access_token_response(at)

    def create_access_token(self, request, user, scope, client):

        # Use client scope
        client_scope = client.apiv2_client.get_scope_display()
        #allowed_scopes = [requested_scope for requested_scope in to_names(scope) if requested_scope in client_scope]

        return AccessToken.objects.create(
            user=user,
            client=client,
            scope=to_int(*client_scope.split('+'))
        )

    def create_refresh_token(self, request, user, scope, access_token, client):

        return RefreshToken.objects.create(
            user=user,
            access_token=access_token,
            client=client
        )


class Capture(DjangoOauth2ProviderCapture):
    def get_redirect_url(self, request):
        return prepend_base(reverse('oauth2:authorize') + '/?original_path=%s' % quote(request.get_full_path()), use_https=not settings.DEBUG, dynamic_resolve=False)


class Authorize(DjangoOauth2ProviderAuthorize):
    if settings.USE_MINIMAL_TEMPLATES_FOR_OAUTH:
        template_name = 'api/minimal_authorize_app.html'
    else:
        template_name = 'api/authorize_app.html'

    def handle(self, request, post_data=None):
        data = self.get_data(request)
        original_path = quote(request.GET.get('original_path', ''))

        if data is None:
            return self.error_response(request, {
                'error': 'expired_authorization',
                'error_description': _('Authorization session has expired.')})

        try:
            client, data = self._validate_client(request, data)
        except OAuthError, e:
            if 'redirect_uri' in e.message:
                return self.error_response(request, {'error': 'The redirect_uri request parameter does not match the redirect_uri of ApiV2 client.'}, status=400)
            return self.error_response(request, e.args[0], status=400)

        # Check if request user already has validated access token for client
        has_valid_token = False
        try:
            if AccessToken.objects.filter(user=request.user, client=client).count():
                has_valid_token = True
        except:
            pass

        if not has_valid_token:
            # If user has no valid token display the authorization form as normal
            authorization_form = self.get_authorization_form(request, client, post_data, data)

            if not authorization_form.is_bound or not authorization_form.is_valid():
                return self.render_to_response({
                    'client': client,
                    'form': authorization_form,
                    'oauth_data': data,
                    'original_path': original_path, })
        else:
            # If user has a valid token fill the authorization form with a newly created grant and continue
            post_data = {u'authorize': [u'Authorize!']}
            authorization_form = self.get_authorization_form(request, client, post_data, data)
            if not authorization_form.is_valid():
                return self.render_to_response({
                    'client': client,
                    'form': authorization_form,
                    'oauth_data': data,
                    'original_path': original_path, })

        code = self.save_authorization(request, client, authorization_form, data)

        self.cache_data(request, data)
        self.cache_data(request, code, "code")
        self.cache_data(request, client, "client")

        return HttpResponseRedirect(prepend_base(self.get_redirect_url(request) + '/?original_path=%s' % original_path, use_https=not settings.DEBUG, dynamic_resolve=False))


class Redirect(DjangoOauth2ProviderRedirect):

    def get(self, request):

        data = self.get_data(request)
        code = self.get_data(request, "code")
        error = self.get_data(request, "error")
        client = self.get_data(request, "client")

        redirect_uri = client.redirect_uri # data.get('redirect_uri', None) or
        parsed = urlparse.urlparse(redirect_uri)
        query = QueryDict('', mutable=True)

        if 'state' in data:
            query['state'] = data['state']

        if error is not None:
            query.update(error)
        elif code is None:
            query['error'] = 'access_denied'
        else:
            query['code'] = code

        query['original_path'] = request.GET.get('original_path', '')

        parsed = parsed[:4] + (query.urlencode(), '')
        redirect_uri = urlparse.ParseResult(*parsed).geturl()
        self.clear_data(request)

        return HttpResponseRedirect(redirect_uri)


#############################
# Rest Framework custom views
#############################


class GenericAPIView(RestFrameworkGenericAPIView):
    throttling_rates_per_level = settings.APIV2_BASIC_THROTTLING_RATES_PER_LEVELS
    authentication_classes = (OAuth2Authentication, TokenAuthentication, SessionAuthentication)

    def initial(self, request, *args, **kwargs):
        super(GenericAPIView, self).initial(request, *args, **kwargs)

        # Get request information and store it as class variable
        self.auth_method_name, self.developer, self.user, self.client_id = get_authentication_details_form_request(request)

    def log_message(self, message):
        return '%s <%s> (%s)' % (message, request_parameters_info_for_log_message(self.request.QUERY_PARAMS), basic_request_info_for_log_message(self.auth_method_name, self.developer, self.user, self.client_id))


class OauthRequiredAPIView(RestFrameworkGenericAPIView):
    throttling_rates_per_level = settings.APIV2_BASIC_THROTTLING_RATES_PER_LEVELS
    authentication_classes = (OAuth2Authentication, SessionAuthentication)

    def initial(self, request, *args, **kwargs):
        super(OauthRequiredAPIView, self).initial(request, *args, **kwargs)

        # Get request information and store it as class variable
        self.auth_method_name, self.developer, self.user, self.client_id = get_authentication_details_form_request(request)

        # Check if using https
        throw_exception_if_not_https(request)

    def log_message(self, message):
        return '%s <%s> (%s)' % (message, request_parameters_info_for_log_message(self.request.QUERY_PARAMS), basic_request_info_for_log_message(self.auth_method_name, self.developer, self.user, self.client_id))


class DownloadAPIView(OauthRequiredAPIView):
    throttling_rates_per_level = settings.APIV2_BASIC_THROTTLING_RATES_PER_LEVELS


class WriteRequiredGenericAPIView(RestFrameworkGenericAPIView):
    throttling_rates_per_level = settings.APIV2_POST_THROTTLING_RATES_PER_LEVELS
    authentication_classes = (OAuth2Authentication, SessionAuthentication)

    def initial(self, request, *args, **kwargs):
        super(WriteRequiredGenericAPIView, self).initial(request, *args, **kwargs)

        # Get request informationa dn store it as class variable
        self.auth_method_name, self.developer, self.user, self.client_id = get_authentication_details_form_request(request)

        # Check if using https
        throw_exception_if_not_https(request)

        # Check if client has write permissions
        if self.auth_method_name == "OAuth2":
            if "write" not in request.auth.client.apiv2_client.get_scope_display():
                raise UnauthorizedException

    def log_message(self, message):
        return '%s <%s> (%s)' % (message, request_parameters_info_for_log_message(self.request.QUERY_PARAMS), basic_request_info_for_log_message(self.auth_method_name, self.developer, self.user, self.client_id))


class ListAPIView(RestFrameworkListAPIView):
    throttling_rates_per_level = settings.APIV2_BASIC_THROTTLING_RATES_PER_LEVELS
    authentication_classes = (OAuth2Authentication, TokenAuthentication, SessionAuthentication)

    def initial(self, request, *args, **kwargs):
        super(ListAPIView, self).initial(request, *args, **kwargs)

        # Get request information and store it as class variable
        self.auth_method_name, self.developer, self.user, self.client_id = get_authentication_details_form_request(request)

    def log_message(self, message):
        return '%s <%s> (%s)' % (message, request_parameters_info_for_log_message(self.request.QUERY_PARAMS), basic_request_info_for_log_message(self.auth_method_name, self.developer, self.user, self.client_id))


class RetrieveAPIView(RestFrameworkRetrieveAPIView):
    throttling_rates_per_level = settings.APIV2_BASIC_THROTTLING_RATES_PER_LEVELS
    authentication_classes = (OAuth2Authentication, TokenAuthentication, SessionAuthentication)

    def initial(self, request, *args, **kwargs):
        super(RetrieveAPIView, self).initial(request, *args, **kwargs)

        # Get request information and store it as class variable
        self.auth_method_name, self.developer, self.user, self.client_id = get_authentication_details_form_request(request)

    def log_message(self, message):
        return '%s <%s> (%s)' % (message, request_parameters_info_for_log_message(self.request.QUERY_PARAMS), basic_request_info_for_log_message(self.auth_method_name, self.developer, self.user, self.client_id))


##################
# Search utilities
##################

def api_search(search_form, target_file=None, extra_parameters=False, merging_strategy='merge_optimized'):

    if search_form.cleaned_data['query']  == None and search_form.cleaned_data['filter'] == None and not search_form.cleaned_data['descriptors_filter'] and not search_form.cleaned_data['target'] and not target_file:
        # No input data for search, return empty results
        return [], 0, None, None, None, None, None

    if search_form.cleaned_data['query'] == None and search_form.cleaned_data['filter'] == None:
        # Standard content-based search
        try:
            results, count, note = similarity_api_search(target=search_form.cleaned_data['target'],
                                                         filter=search_form.cleaned_data['descriptors_filter'],
                                                         num_results=search_form.cleaned_data['page_size'],
                                                         offset=(search_form.cleaned_data['page'] - 1) * search_form.cleaned_data['page_size'],
                                                         target_file=target_file)

            gaia_ids = [result[0] for result in results]
            distance_to_target_data = None
            if search_form.cleaned_data['target'] or target_file:
                # Save sound distance to target into view class so it can be accessed by the serializer
                # We only do that when a target is specified (otherwise there is no meaningful distance value)
                distance_to_target_data = dict(results)

            gaia_count = count
            return gaia_ids, gaia_count, distance_to_target_data, None, note, None, None
        except SimilarityException, e:
            if e.status_code == 500:
                raise ServerErrorException(msg=e.message)
            elif e.status_code == 400:
                raise BadRequestException(msg=e.message)
            elif e.status_code == 404:
                raise NotFoundException(msg=e.message)
            else:
                raise ServerErrorException(msg='Similarity server error: %s' % e.message)
        except Exception, e:
            raise ServerErrorException(msg='The similarity server could not be reached or some unexpected error occurred.')


    elif not search_form.cleaned_data['descriptors_filter'] and not search_form.cleaned_data['target'] and not target_file:
        # Standard text-based search
        try:
            solr = Solr(settings.SOLR_URL)
            query = search_prepare_query(unquote(search_form.cleaned_data['query'] or ""),
                                         unquote(search_form.cleaned_data['filter'] or ""),
                                         search_form.cleaned_data['sort'],
                                         search_form.cleaned_data['page'],
                                         search_form.cleaned_data['page_size'],
                                         grouping=search_form.cleaned_data['group_by_pack'],
                                         include_facets=False)

            result = SolrResponseInterpreter(solr.select(unicode(query)))
            solr_ids = [element['id'] for element in result.docs]
            solr_count = result.num_found

            more_from_pack_data = None
            if search_form.cleaned_data['group_by_pack']:
                # If grouping option is on, store grouping info in a dictionary that we can add when serializing sounds
                more_from_pack_data = dict([(int(element['id']), [element['more_from_pack'], element['pack_id'], element['pack_name']]) for element in result.docs])

            return solr_ids, solr_count, None, more_from_pack_data, None, None, None

        except SolrException, e:
            if search_form.cleaned_data['filter'] != None:
                raise BadRequestException(msg='Search server error: %s (please check that your filter syntax and field names are correct)' % e.message)
            raise BadRequestException(msg='Search server error: %s' % e.message)
        except Exception, e:
            raise ServerErrorException(msg='The search server could not be reached or some unexpected error occurred.')

    else:
        # Combined search (there is at least one of query/filter and one of descriptors_filter/target)
        # Strategies are implemented in 'combined_search_strategies'
        strategy = getattr(combined_search_strategies, merging_strategy)
        return strategy(search_form, target_file=target_file, extra_parameters=extra_parameters)


###############
# OTHER UTILS
###############

# General utils
###############

def throw_exception_if_not_https(request):
    if not settings.DEBUG:
        if not request.using_https:
            raise RequiresHttpsException

def prepend_base(rel, dynamic_resolve=True, use_https=False, request_is_secure=False):

    if request_is_secure:
        use_https = True
        dynamic_resolve = False  # don't need to dynamic resolve is request is https

    if dynamic_resolve:
        try:
            url_name = resolve(rel.replace('<sound_id>', '1').replace('<username', 'name').replace('<pack_id>', '1').replace('<category_id>', '1')).url_name
            if url_name in settings.APIV2_RESOURCES_REQUIRING_HTTPS:
                use_https = True
        except Exception, e:
            pass

    if use_https:
        return "https://%s%s" % (Site.objects.get_current().domain, rel)
    else:
        return "http://%s%s" % (Site.objects.get_current().domain, rel)

def get_authentication_details_form_request(request):
    auth_method_name = None
    user = None
    developer = None
    client_id = None

    if request.successful_authenticator:
        auth_method_name = request.successful_authenticator.authentication_method_name
        if auth_method_name == "OAuth2":
            user = request.user
            developer = request.auth.client.user
            client_id = request.auth.client.apiv2_client.client_id
        elif auth_method_name == "Token":
            user = None
            developer = request.auth.user
            client_id = request.auth.client_id
        elif auth_method_name == "Session":
            user = request.user
            developer = None
            client_id = None

    return auth_method_name, developer, user, client_id


def basic_request_info_for_log_message(auth_method_name, developer, user, client_id):
    return 'ApiV2 Auth:%s Dev:%s User:%s Client:%s' % (auth_method_name, developer, user, str(client_id))


def request_parameters_info_for_log_message(get_parameters):
    return ','.join(['%s=%s' % (key, value) for key, value in get_parameters.items()])


class ApiSearchPaginator(object):
    def __init__(self, results, count, num_per_page):
        self.num_per_page = num_per_page
        self.count = count
        self.num_pages = count / num_per_page + int(count % num_per_page != 0)
        self.page_range = range(1, self.num_pages + 1)
        self.results = results

    def page(self, page_num):
        object_list = self.results
        has_next = page_num < self.num_pages
        has_previous = page_num > 1 and page_num <= self.num_pages
        has_other_pages = has_next or has_previous
        next_page_number = page_num + 1
        previous_page_number = page_num - 1
        return locals()


# Docs examples utils
#####################

def get_formatted_examples_for_view(view_name, url_name, max=10):
    try:
        data = examples[view_name]
    except:
        #print 'Could not find examples for view %s' % view_name
        return ''

    count = 0
    output = 'Some quick examples:<div class="request-info" style="clear: both"><pre class="prettyprint">'

    for description, elements in data:
        for element in elements:
            if count >= max:
                break

            if element[0:5] == 'apiv2':
                if url_name in settings.APIV2_RESOURCES_REQUIRING_HTTPS:
                    url = prepend_base('/' + element, dynamic_resolve=False, use_https=True)
                else:
                    url = prepend_base('/' + element, dynamic_resolve=False, use_https=False)
                output += '<span class="pln"><a href="%s">%s</a></span><br>' % (url, url)
            else:
                # This is only apiv2 oauth examples
                url = prepend_base('', dynamic_resolve=False, use_https=True)
                output += '<span class="pln">%s</span><br>' % (element % url)
            count += 1

    output += '</pre></div>'

    return output

# Similarity utils
##################

def get_analysis_data_for_queryset_or_sound_ids(view, queryset=None, sound_ids=[]):
    # Get analysis data for all requested sounds and save it to a class variable so the serializer can access it and
    # we only need one request to the similarity service

    analysis_data_required = 'analysis' in view.request.QUERY_PARAMS.get('fields', '').split(',')
    if analysis_data_required:
        # Get ids of the particular sounds we need
        if queryset:
            paginated_queryset = view.paginate_queryset(queryset)
            ids = [int(sound.id) for sound in paginated_queryset.object_list]
        else:
            ids = [int(sid) for sid in sound_ids]

        # Get descriptor values for the required ids
        # Required descriptors are indicated with the parameter 'descriptors'. If 'descriptors' is empty, we return nothing
        descriptors = view.request.QUERY_PARAMS.get('descriptors', [])
        view.sound_analysis_data = {}
        if descriptors:
            try:
                view.sound_analysis_data = get_sounds_descriptors(ids,
                                                                  descriptors.split(','),
                                                                  view.request.QUERY_PARAMS.get('normalized', '0') == '1',
                                                                  only_leaf_descriptors=True)
            except:
                pass
        else:
            for id in ids:
                view.sound_analysis_data[str(id)] = 'No descriptors specified. You should indicate which descriptors you want with the \'descriptors\' request parameter.'


# Upload handler utils
######################

def create_sound_object(user, original_sound_fields):
    '''
    This function is used by the upload handler to create a sound object with the information provided through post
    parameters.
    '''

    # 1 prepare some variable names
    sound_fields = dict()
    for key, item in original_sound_fields.items():
        sound_fields[key] = item

    filename = sound_fields['upload_filename']
    if not 'name' in sound_fields:
        sound_fields['name'] = filename
    else:
        if not sound_fields['name']:
            sound_fields['name'] = filename

    directory = os.path.join(settings.UPLOADS_PATH, str(user.id))
    dest_path = os.path.join(directory, filename)

    # 2 make sound object
    sound = Sound()
    sound.user = user
    sound.original_filename = sound_fields['name']
    sound.original_path = dest_path
    sound.filesize = os.path.getsize(sound.original_path)
    sound.type = get_sound_type(sound.original_path)
    license = License.objects.get(name=sound_fields['license'])
    sound.license = license

    # 3 md5, check
    try:
        sound.md5 = md5file(sound.original_path)
    except IOError:
        if settings.DEBUG:
            msg = "Md5 could not be computed."
        else:
            msg = "Server error."
        raise ServerErrorException(msg=msg)

    sound_already_exists = Sound.objects.filter(md5=sound.md5).exists()
    if sound_already_exists:
        os.remove(sound.original_path)
        raise OtherException("Sound could not be created because the uploaded file is already part of freesound.")

    # 4 save
    sound.save()

    # 5 move to new path
    orig = os.path.splitext(os.path.basename(sound.original_filename))[0]  # WATCH OUT!
    sound.base_filename_slug = "%d__%s__%s" % (sound.id, slugify(sound.user.username), slugify(orig))
    new_original_path = sound.locations("path")
    if sound.original_path != new_original_path:
        try:
            os.makedirs(os.path.dirname(new_original_path))
        except OSError:
            pass
        try:
            shutil.move(sound.original_path, new_original_path)
        except IOError, e:
            if settings.DEBUG:
                msg = "File could not be copied to the correct destination."
            else:
                msg = "Server error."
            raise ServerErrorException(msg=msg)
        sound.original_path = new_original_path
        sound.save()

    # 6 create pack if it does not exist
    if 'pack' in sound_fields:
        if sound_fields['pack']:
            if Pack.objects.filter(name=sound_fields['pack'], user=user).exists():
                p = Pack.objects.get(name=sound_fields['pack'], user=user)
            else:
                p, created = Pack.objects.get_or_create(user=user, name=sound_fields['pack'])
            sound.pack = p

    # 7 create geotag objects
    # format: lat#lon#zoom
    if 'geotag' in sound_fields:
        if sound_fields['geotag']:
            lat, lon, zoom = sound_fields['geotag'].split(',')
            geotag = GeoTag(user=user,
                lat=float(lat),
                lon=float(lon),
                zoom=int(zoom))
            geotag.save()
            sound.geotag = geotag

    # 8 set description, tags
    sound.description = sound_fields['description']
    sound.set_tags(sound_fields['tags'])
    #sound.set_tags([t.lower() for t in sound_fields['tags'].split(" ") if t])

    # 9 save!
    sound.save()

    # 10 create moderation tickets if needed
    if user.profile.is_whitelisted:
        sound.moderation_state = 'OK'
        sound.save()
    else:
        # create moderation ticket!
        ticket = Ticket()
        ticket.title = 'Moderate sound %s' % sound.original_filename
        ticket.source = TICKET_SOURCE_NEW_SOUND
        ticket.status = TICKET_STATUS_NEW
        ticket.queue = Queue.objects.get(name='sound moderation')
        ticket.sender = user
        lc = LinkedContent()
        lc.content_object = sound
        lc.save()
        ticket.content = lc
        ticket.save()
        tc = TicketComment()
        tc.sender = user
        tc.text = "I've uploaded %s. Please moderate!" % sound.original_filename
        tc.ticket = ticket
        tc.save()

        invalidate_template_cache("user_header", ticket.sender.id)
        moderators = Group.objects.get(name='moderators').user_set.all()
        for moderator in moderators:
            invalidate_template_cache("user_header", moderator.id)

    # 11 proces
    try:
        sound.compute_crc()
    except:
        pass

    try:
        sound.process()
    except Exception, e:
        pass

    return sound
########NEW FILE########
__FILENAME__ = views
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#


from rest_framework.response import Response
from rest_framework.parsers import MultiPartParser
from rest_framework.decorators import api_view, authentication_classes
from rest_framework.exceptions import ParseError
from provider.oauth2.models import AccessToken, Grant
from apiv2.serializers import *
from apiv2.authentication import OAuth2Authentication, TokenAuthentication, SessionAuthentication
from utils import GenericAPIView, ListAPIView, RetrieveAPIView, WriteRequiredGenericAPIView, OauthRequiredAPIView, DownloadAPIView, get_analysis_data_for_queryset_or_sound_ids, create_sound_object, api_search, ApiSearchPaginator, get_sounds_descriptors, prepend_base,  get_formatted_examples_for_view
from exceptions import *
from forms import *
from models import ApiV2Client
from api.models import ApiKey
from sounds.models import Sound, Pack, License
from geotags.models import GeoTag
from bookmarks.models import Bookmark, BookmarkCategory
from api.forms import ApiKeyForm
from accounts.views import handle_uploaded_file, send_activation2
from accounts.forms import RegistrationForm
from freesound.utils.filesystem import generate_tree
from freesound.utils.cache import invalidate_template_cache
from freesound.utils.nginxsendfile import sendfile
from django.db import IntegrityError
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.contrib.contenttypes.models import ContentType
from django.shortcuts import render_to_response
from django.template import RequestContext
from django.http import HttpResponseRedirect, Http404, HttpResponse
from django.core.urlresolvers import reverse
try:
    from collections import OrderedDict
except:
    from freesound.utils.ordered_dict import OrderedDict
from urllib import unquote, quote
import settings
import logging
import datetime
import os

logger = logging.getLogger("api")
logger_error = logging.getLogger("api_errors")
docs_base_url = prepend_base('/docs/api')
resources_doc_filename = 'resources_apiv2.html'


####################################
# SEARCH AND SIMILARITY SEARCH VIEWS
####################################

class TextSearch(GenericAPIView):

    __doc__ = 'Search sounds in Freesound based on their tags and other metadata.' \
              '<br>Full documentation can be found <a href="%s/%s" target="_blank">here</a>. %s' \
              % (docs_base_url, '%s#text-search' % resources_doc_filename,
                 get_formatted_examples_for_view('TextSearch', 'apiv2-sound-search', max=5))

    def get(self, request,  *args, **kwargs):
        logger.info(self.log_message('search'))

        # Validate search form and check page 0
        search_form = SoundTextSearchFormAPI(request.QUERY_PARAMS)
        if not search_form.is_valid():
            raise ParseError
        if search_form.cleaned_data['query'] == None and search_form.cleaned_data['filter'] == None:
           raise BadRequestException(msg='At lesast one request parameter from Text Search should be included in the request.')
        if search_form.cleaned_data['page'] < 1:
            raise NotFoundException

        # Get search results
        try:
            results, count, distance_to_target_data, more_from_pack_data, note, params_for_next_page, debug_note = api_search(search_form)
        except APIException, e:
            raise e
        except Exception, e:
            logger_error.error('<500 Server error unexpected> %s' % str(e))
            raise ServerErrorException(msg='Unexpected error')

        # Paginate results
        paginator = ApiSearchPaginator(results, count, search_form.cleaned_data['page_size'])
        if search_form.cleaned_data['page'] > paginator.num_pages and count != 0:
            raise NotFoundException
        page = paginator.page(search_form.cleaned_data['page'])
        response_data = dict()
        response_data['count'] = paginator.count
        response_data['previous'] = None
        response_data['next'] = None
        if page['has_other_pages']:
                if page['has_previous']:
                    response_data['previous'] = search_form.construct_link(reverse('apiv2-sound-text-search'), page=page['previous_page_number'])
                if page['has_next']:
                    response_data['next'] = search_form.construct_link(reverse('apiv2-sound-text-search'), page=page['next_page_number'])

        # Get analysis data and serialize sound results
        ids = [id for id in page['object_list']]
        get_analysis_data_for_queryset_or_sound_ids(self, sound_ids=ids)
        qs = Sound.objects.select_related('user', 'pack', 'license').filter(id__in=ids)
        qs_sound_objects = dict()
        for sound_object in qs:
            qs_sound_objects[sound_object.id] = sound_object
        sounds = []
        for i, sid in enumerate(ids):
            try:
                sound = SoundListSerializer(qs_sound_objects[sid], context=self.get_serializer_context()).data
                if more_from_pack_data:
                    if more_from_pack_data[sid][0]:
                        sound['more_from_same_pack'] = search_form.construct_link(reverse('apiv2-sound-text-search'), page=1, filter='grouping_pack:"%i_%s"' % (int(more_from_pack_data[sid][1]), more_from_pack_data[sid][2]), group_by_pack='0')
                        sound['n_from_same_pack'] = more_from_pack_data[sid][0] + 1  # we add one as is the sound itself
                sounds.append(sound)
            except:
                # This will happen if there are synchronization errors between solr index, gaia and the database.
                # In that case sounds are are set to null
                sounds.append(None)
        response_data['results'] = sounds

        if note:
            response_data['note'] = note

        return Response(response_data, status=status.HTTP_200_OK)


class ContentSearch(GenericAPIView):

    __doc__ = 'Search sounds in Freesound based on their content descriptors.' \
              '<br>Full documentation can be found <a href="%s/%s" target="_blank">here</a>. %s' \
              % (docs_base_url, '%s#content-search' % resources_doc_filename,
                 get_formatted_examples_for_view('ContentSearch', 'apiv2-sound-content-search', max=5))

    serializer_class = SimilarityFileSerializer
    analysis_file = None

    def get(self, request,  *args, **kwargs):
        logger.info(self.log_message('content_search'))

        # Validate search form and check page 0
        search_form = SoundContentSearchFormAPI(request.QUERY_PARAMS)
        if not search_form.is_valid():
            raise ParseError
        if not search_form.cleaned_data['target'] and not search_form.cleaned_data['descriptors_filter'] and not self.analysis_file:
           raise BadRequestException(msg='At lesast one parameter from Content Search should be included in the request.')
        if search_form.cleaned_data['page'] < 1:
                raise NotFoundException

        # Get search results
        analysis_file = None
        if self.analysis_file:
            analysis_file = self.analysis_file.read()
        try:
            results, count, distance_to_target_data, more_from_pack_data, note, params_for_next_page, debug_note = api_search(search_form, target_file=analysis_file)
        except APIException, e:
            raise e
        except Exception, e:
            logger_error.error('<500 Server error unexpected> %s' % str(e))
            raise ServerErrorException(msg='Unexpected error')

        # Paginate results
        paginator = ApiSearchPaginator(results, count, search_form.cleaned_data['page_size'])
        if search_form.cleaned_data['page'] > paginator.num_pages and count != 0:
            raise NotFoundException
        page = paginator.page(search_form.cleaned_data['page'])
        response_data = dict()
        if self.analysis_file:
            response_data['target_analysis_file'] = '%s (%i KB)' % (self.analysis_file._name, self.analysis_file._size/1024)
        response_data['count'] = paginator.count
        response_data['previous'] = None
        response_data['next'] = None
        if page['has_other_pages']:
                if page['has_previous']:
                    response_data['previous'] = search_form.construct_link(reverse('apiv2-sound-content-search'), page=page['previous_page_number'])
                if page['has_next']:
                    response_data['next'] = search_form.construct_link(reverse('apiv2-sound-content-search'), page=page['next_page_number'])

        # Get analysis data and serialize sound results
        ids = [id for id in page['object_list']]
        get_analysis_data_for_queryset_or_sound_ids(self, sound_ids=ids)
        qs = Sound.objects.select_related('user', 'pack', 'license').filter(id__in=ids)
        qs_sound_objects = dict()
        for sound_object in qs:
            qs_sound_objects[sound_object.id] = sound_object
        sounds = []
        for i, sid in enumerate(ids):
            try:
                sound = SoundListSerializer(qs_sound_objects[sid], context=self.get_serializer_context()).data
                # Distance to target is present we add it to the serialized sound
                if distance_to_target_data:
                    sound['distance_to_target'] = distance_to_target_data[sid]
                sounds.append(sound)
            except:
                # This will happen if there are synchronization errors between solr index, gaia and the database.
                # In that case sounds are are set to null
                sounds.append(None)
        response_data['results'] = sounds

        if note:
            response_data['note'] = note

        return Response(response_data, status=status.HTTP_200_OK)

    def post(self, request,  *args, **kwargs):
        # This view has a post version to handle analysis file uploads
        serializer = SimilarityFileSerializer(data=request.DATA, files=request.FILES)
        if serializer.is_valid():
            analysis_file = request.FILES['analysis_file']
            self.analysis_file = analysis_file
            return self.get(request,  *args, **kwargs)
        else:
            return Response({'detail': serializer.errors}, status=status.HTTP_400_BAD_REQUEST)


class CombinedSearch(GenericAPIView):

    __doc__ = 'Search sounds in Freesound based on their tags, metadata and content-based descriptors.' \
              '<br>Full documentation can be found <a href="%s/%s" target="_blank">here</a>. %s' \
              % (docs_base_url, '%s#combined-search' % resources_doc_filename,
                 get_formatted_examples_for_view('CombinedSearch', 'apiv2-sound-combined-search', max=5))

    serializer_class = SimilarityFileSerializer
    analysis_file = None
    merging_strategy = 'merge_optimized'  # 'filter_both', 'merge_all'

    def get(self, request,  *args, **kwargs):
        logger.info(self.log_message('combined_search'))

        # Validate search form and check page 0
        search_form = SoundCombinedSearchFormAPI(request.QUERY_PARAMS)
        if not search_form.is_valid():
            raise ParseError
        if (not search_form.cleaned_data['target'] and not search_form.cleaned_data['descriptors_filter'] and not self.analysis_file) or (search_form.cleaned_data['query'] == None and search_form.cleaned_data['filter'] == None):
            raise BadRequestException(msg='At lesast one parameter from Text Search and one parameter from Content Search should be included in the request.')
        if (search_form.cleaned_data['target'] and search_form.cleaned_data['query']):
            raise BadRequestException(msg='Request parameters \'target\' and \'query\' can not be used at the same time.')
        if search_form.cleaned_data['page'] < 1:
            raise NotFoundException

        # Get search results
        extra_parameters = dict()
        for key, value in request.QUERY_PARAMS.items():
            if key.startswith('cs_'):
                extra_parameters[key] = int(value)

        analysis_file = None
        if self.analysis_file:
            analysis_file = self.analysis_file.read()
        try:
            results, \
            count, \
            distance_to_target_data, \
            more_from_pack_data, \
            note, \
            params_for_next_page, \
            debug_note \
                = api_search(search_form,
                             target_file=analysis_file,
                             extra_parameters=extra_parameters,
                             merging_strategy=self.merging_strategy)
        except APIException, e:
            raise e
        except Exception, e:
            logger_error.error('<500 Server error unexpected> %s' % str(e))
            raise ServerErrorException(msg='Unexpected error')

        if params_for_next_page:
            extra_parameters.update(params_for_next_page)
        if request.QUERY_PARAMS.get('debug', False):
            extra_parameters.update({'debug': 1})
        extra_parameters_string = ''
        if extra_parameters:
            for key, value in extra_parameters.items():
                extra_parameters_string += '&%s=%s' % (key, str(value))

        response_data = dict()
        if self.analysis_file:
            response_data['target_analysis_file'] = '%s (%i KB)' % (self.analysis_file._name, self.analysis_file._size/1024)

        # Build 'more' link (only add it if we know there might be more results)
        if 'no_more_results' not in extra_parameters:
            if self.merging_strategy == 'merge_optimized':
                response_data['more'] = search_form.construct_link(reverse('apiv2-sound-combined-search'), include_page=False)
            else:
                num_pages = count / search_form.cleaned_data['page_size'] + int(count % search_form.cleaned_data['page_size'] != 0)
                if search_form.cleaned_data['page'] < num_pages:
                    response_data['more'] = search_form.construct_link(reverse('apiv2-sound-combined-search'), page=search_form.cleaned_data['page'] + 1)
                else:
                    response_data['more'] = None
            if extra_parameters_string:
                response_data['more'] += '%s' % extra_parameters_string
        else:
            response_data['more'] = None

        # Get analysis data and serialize sound results
        ids = results
        get_analysis_data_for_queryset_or_sound_ids(self, sound_ids=ids)
        qs = Sound.objects.select_related('user', 'pack', 'license').filter(id__in=ids)
        qs_sound_objects = dict()
        for sound_object in qs:
            qs_sound_objects[sound_object.id] = sound_object
        sounds = []
        for i, sid in enumerate(ids):
            try:
                sound = SoundListSerializer(qs_sound_objects[sid], context=self.get_serializer_context()).data
                # Distance to target is present we add it to the serialized sound
                if distance_to_target_data:
                    sound['distance_to_target'] = distance_to_target_data[sid]
                sounds.append(sound)
            except:
                # This will happen if there are synchronization errors between solr index, gaia and the database.
                # In that case sounds are are set to null
                sounds.append(None)
        response_data['results'] = sounds

        if note:
            response_data['note'] = note

        if request.QUERY_PARAMS.get('debug', False):
            response_data['debug_note'] = debug_note

        return Response(response_data, status=status.HTTP_200_OK)

    def post(self, request,  *args, **kwargs):
        # This view has a post version to handle analysis file uploads
        serializer = SimilarityFileSerializer(data=request.DATA, files=request.FILES)
        if serializer.is_valid():
            analysis_file = request.FILES['analysis_file']
            self.analysis_file = analysis_file
            return self.get(request,  *args, **kwargs)
        else:
            return Response({'detail': serializer.errors}, status=status.HTTP_400_BAD_REQUEST)


#############
# SOUND VIEWS
#############

class SoundInstance(RetrieveAPIView):
    __doc__ = 'Detailed sound information.' \
              '<br>Full documentation can be found <a href="%s/%s" target="_blank">here</a>. %s' \
              % (docs_base_url, '%s#sound-instance' % resources_doc_filename,
                 get_formatted_examples_for_view('SoundInstance', 'apiv2-sound-instance', max=5))

    serializer_class = SoundSerializer
    queryset = Sound.objects.filter(moderation_state="OK", processing_state="OK")

    def get(self, request,  *args, **kwargs):
        logger.info(self.log_message('sound:%i instance' % (int(kwargs['pk']))))
        return super(SoundInstance, self).get(request, *args, **kwargs)


class SoundAnalysis(GenericAPIView):
    __doc__ = 'Sound analysis information.' \
              '<br>Full documentation can be found <a href="%s/%s" target="_blank">here</a>. %s' \
              % (docs_base_url, '%s#sound-analysis' % resources_doc_filename,
                 get_formatted_examples_for_view('SoundAnalysis', 'apiv2-sound-analysis', max=5))

    def get(self, request,  *args, **kwargs):
        sound_id = kwargs['pk']
        descriptors = []
        if request.QUERY_PARAMS.get('descriptors', False):
            descriptors = request.QUERY_PARAMS['descriptors'].split(',')
        logger.info(self.log_message('sound:%i analysis' % (int(sound_id))))
        response_data = get_sounds_descriptors([sound_id],
                                                descriptors,
                                                request.QUERY_PARAMS.get('normalized', '0') == '1',
                                                only_leaf_descriptors=True)
        if response_data:
            return Response(response_data[str(sound_id)], status=status.HTTP_200_OK)
        else:
            raise NotFoundException


class SimilarSounds(GenericAPIView):
    __doc__ = 'Similar sounds to a given Freesound sound.' \
              '<br>Full documentation can be found <a href="%s/%s" target="_blank">here</a>. %s' \
              % (docs_base_url, '%s#similar-sounds' % resources_doc_filename,
                 get_formatted_examples_for_view('SimilarSounds', 'apiv2-similarity-sound', max=5))

    def get(self, request,  *args, **kwargs):

        sound_id = self.kwargs['pk']
        logger.info(self.log_message('sound:%i similar_sounds' % (int(sound_id))))

        # Validate search form and check page 0
        similarity_sound_form = SimilarityFormAPI(request.QUERY_PARAMS)
        if not similarity_sound_form.is_valid():
            raise ParseError
        if similarity_sound_form.cleaned_data['page'] < 1:
            raise NotFoundException

        # Get search results
        similarity_sound_form.cleaned_data['target'] = str(sound_id)
        results, count, distance_to_target_data, more_from_pack_data, note, params_for_next_page, debug_note = api_search(similarity_sound_form)

        # Paginate results
        paginator = ApiSearchPaginator(results, count, similarity_sound_form.cleaned_data['page_size'])
        if similarity_sound_form.cleaned_data['page'] > paginator.num_pages and count != 0:
            raise NotFoundException
        page = paginator.page(similarity_sound_form.cleaned_data['page'])
        response_data = dict()
        response_data['count'] = paginator.count
        response_data['previous'] = None
        response_data['next'] = None
        if page['has_other_pages']:
                if page['has_previous']:
                    response_data['previous'] = similarity_sound_form.construct_link(reverse('apiv2-similarity-sound', args=[sound_id]), page=page['previous_page_number'])
                if page['has_next']:
                    response_data['next'] = similarity_sound_form.construct_link(reverse('apiv2-similarity-sound', args=[sound_id]), page=page['next_page_number'])

        # Get analysis data and serialize sound results
        ids = [id for id in page['object_list']]
        get_analysis_data_for_queryset_or_sound_ids(self, sound_ids=ids)
        qs = Sound.objects.select_related('user', 'pack', 'license').filter(id__in=ids)
        qs_sound_objects = dict()
        for sound_object in qs:
            qs_sound_objects[sound_object.id] = sound_object
        sounds = []
        for i, sid in enumerate(ids):
            try:
                sound = SoundListSerializer(qs_sound_objects[sid], context=self.get_serializer_context()).data
                # Distance to target is present we add it to the serialized sound
                if distance_to_target_data:
                    sound['distance_to_target'] = distance_to_target_data[sid]
                sounds.append(sound)
            except:
                # This will happen if there are synchronization errors between gaia and the database.
                # In that case sounds are are set to null
                sounds.append(None)
        response_data['results'] = sounds

        return Response(response_data, status=status.HTTP_200_OK)


class SoundComments(ListAPIView):
    __doc__ = 'Sounds comments.' \
              '<br>Full documentation can be found <a href="%s/%s" target="_blank">here</a>. %s' \
              % (docs_base_url, '%s#sound-comments' % resources_doc_filename,
                 get_formatted_examples_for_view('SoundComments', 'apiv2-sound-comments', max=5))
    serializer_class = SoundCommentsSerializer

    def get(self, request,  *args, **kwargs):
        logger.info(self.log_message('sound:%i comments' % (int(self.kwargs['pk']))))
        return super(SoundComments, self).get(request, *args, **kwargs)

    def get_queryset(self):
        return Comment.objects.filter(object_id=self.kwargs['pk'])


class DownloadSound(DownloadAPIView):
    __doc__ = 'Download a sound.' \
              '<br>Full documentation can be found <a href="%s/%s" target="_blank">here</a>. %s' \
              % (docs_base_url, '%s#download-sound-oauth2-required' % resources_doc_filename,
                 get_formatted_examples_for_view('DownloadSound', 'apiv2-sound-download', max=5))

    def get(self, request,  *args, **kwargs):
        sound_id = kwargs['pk']
        logger.info(self.log_message('sound:%i download' % (int(sound_id))))
        try:
            sound = Sound.objects.get(id=sound_id, moderation_state="OK", processing_state="OK")
        except Sound.DoesNotExist:
            raise NotFoundException

        if not os.path.exists(sound.locations('path')):
            raise NotFoundException

        return sendfile(sound.locations("path"), sound.friendly_filename(), sound.locations("sendfile_url"))


############
# USER VIEWS
############

class UserInstance(RetrieveAPIView):
    __doc__ = 'Detailed user information.' \
              '<br>Full documentation can be found <a href="%s/%s" target="_blank">here</a>. %s' \
              % (docs_base_url, '%s#user-instance' % resources_doc_filename,
                 get_formatted_examples_for_view('UserInstance', 'apiv2-user-instance', max=5))

    lookup_field = "username"
    serializer_class = UserSerializer
    queryset = User.objects.filter(is_active=True)

    def get(self, request,  *args, **kwargs):
        logger.info(self.log_message('user:%s instance' % (self.kwargs['username'])))
        return super(UserInstance, self).get(request, *args, **kwargs)


class UserSounds(ListAPIView):
    __doc__ = 'Sounds uploaded by a user.' \
              '<br>Full documentation can be found <a href="%s/%s" target="_blank">here</a>. %s' \
              % (docs_base_url, '%s#user-sounds' % resources_doc_filename,
                 get_formatted_examples_for_view('UserSounds', 'apiv2-user-sound-list', max=5))

    lookup_field = "username"
    serializer_class = SoundListSerializer

    def get(self, request,  *args, **kwargs):
        logger.info(self.log_message('user:%s sounds' % (self.kwargs['username'])))
        return super(UserSounds, self).get(request, *args, **kwargs)

    def get_queryset(self):
        try:
            User.objects.get(username=self.kwargs['username'], is_active=True)
        except User.DoesNotExist:
            raise NotFoundException

        queryset = Sound.objects.select_related('user', 'pack', 'license').filter(moderation_state="OK",
                                                                                  processing_state="OK",
                                                                                  user__username=self.kwargs['username'])
        get_analysis_data_for_queryset_or_sound_ids(self, queryset=queryset)
        return queryset


class UserPacks (ListAPIView):
    __doc__ = 'Packs created by a user.' \
              '<br>Full documentation can be found <a href="%s/%s" target="_blank">here</a>. %s' \
              % (docs_base_url, '%s#user-packs' % resources_doc_filename,
                 get_formatted_examples_for_view('UserPacks', 'apiv2-user-packs', max=5))

    serializer_class = PackSerializer
    queryset = Pack.objects.all()

    def get(self, request,  *args, **kwargs):
        logger.info(self.log_message('user:%s packs' % (self.kwargs['username'])))
        return super(UserPacks, self).get(request, *args, **kwargs)

    def get_queryset(self):
        try:
            User.objects.get(username=self.kwargs['username'], is_active=True)
        except User.DoesNotExist:
            raise NotFoundException

        queryset = Pack.objects.select_related('user').filter(user__username=self.kwargs['username'])
        return queryset


class UserBookmarkCategories(ListAPIView):
    __doc__ = 'Bookmark categories created by a user.' \
              '<br>Full documentation can be found <a href="%s/%s" target="_blank">here</a>. %s' \
              % (docs_base_url, '%s#user-bookmark-categories' % resources_doc_filename,
                 get_formatted_examples_for_view('UserBookmarkCategories', 'apiv2-user-bookmark-categories', max=5))

    serializer_class = BookmarkCategorySerializer

    def get(self, request,  *args, **kwargs):
        logger.info(self.log_message('user:%s bookmark_categories' % (self.kwargs['username'])))
        return super(UserBookmarkCategories, self).get(request, *args, **kwargs)

    def get_queryset(self):
        categories = BookmarkCategory.objects.filter(user__username=self.kwargs['username'])
        try:
            user = User.objects.get(username=self.kwargs['username'], is_active=True)
        except User.DoesNotExist:
            raise NotFoundException

        if Bookmark.objects.select_related("sound").filter(user__username=self.kwargs['username'], category=None).count():
            uncategorized = BookmarkCategory(name='Uncategorized', user=user, id=0)
            return [uncategorized] + list(categories)
        else:
            return list(categories)


class UserBookmarkCategorySounds(ListAPIView):
    __doc__ = 'Sounds bookmarked by a user under a particular category.' \
              '<br>Full documentation can be found <a href="%s/%s" target="_blank">here</a>. %s' \
              % (docs_base_url, '%s#user-bookmark-category-sounds' % resources_doc_filename,
                 get_formatted_examples_for_view('UserBookmarkCategorySounds', 'apiv2-user-bookmark-category-sounds', max=5))

    serializer_class = SoundListSerializer

    def get(self, request,  *args, **kwargs):
        logger.info(self.log_message('user:%s sounds_for_bookmark_category:%s' % (self.kwargs['username'], str(self.kwargs.get('category_id', None)))))
        return super(UserBookmarkCategorySounds, self).get(request, *args, **kwargs)

    def get_queryset(self):

        kwargs = dict()
        kwargs['user__username'] = self.kwargs['username']

        if 'category_id' in self.kwargs:
            if int(self.kwargs['category_id']) != 0:
                kwargs['category__id'] = self.kwargs['category_id']
            else:
                kwargs['category'] = None
        else:
            kwargs['category'] = None

        try:
            queryset = [bookmark.sound for bookmark in Bookmark.objects.select_related('sound').filter(**kwargs)]
        except:
            raise NotFoundException

        get_analysis_data_for_queryset_or_sound_ids(self, queryset=queryset)
        #[bookmark.sound for bookmark in Bookmark.objects.select_related("sound").filter(user__username=self.kwargs['username'],category=None)]

        return queryset


############
# PACK VIEWS
############

class PackInstance(RetrieveAPIView):
    __doc__ = 'Detailed pack information.' \
              '<br>Full documentation can be found <a href="%s/%s" target="_blank">here</a>. %s' \
              % (docs_base_url, '%s#pack-instance' % resources_doc_filename,
                 get_formatted_examples_for_view('PackInstance', 'apiv2-pack-instance', max=5))

    serializer_class = PackSerializer
    queryset = Pack.objects.all()

    def get(self, request,  *args, **kwargs):
        logger.info(self.log_message('pack:%i instance' % (int(kwargs['pk']))))
        return super(PackInstance, self).get(request, *args, **kwargs)


class PackSounds(ListAPIView):
    __doc__ = 'Sounds included in a pack.' \
              '<br>Full documentation can be found <a href="%s/%s" target="_blank">here</a>. %s' \
              % (docs_base_url, '%s#pack-sounds' % resources_doc_filename,
                 get_formatted_examples_for_view('PackSounds', 'apiv2-pack-sound-list', max=5))

    serializer_class = SoundListSerializer

    def get(self, request,  *args, **kwargs):
        logger.info(self.log_message('pack:%i sounds' % (int(kwargs['pk']))))
        return super(PackSounds, self).get(request, *args, **kwargs)

    def get_queryset(self):
        try:
            Pack.objects.get(id=self.kwargs['pk'])
        except Pack.DoesNotExist:
            raise NotFoundException

        queryset = Sound.objects.select_related('user', 'pack', 'license').filter(moderation_state="OK",
                                                                                  processing_state="OK",
                                                                                  pack__id=self.kwargs['pk'])
        get_analysis_data_for_queryset_or_sound_ids(self, queryset=queryset)
        return queryset


class DownloadPack(DownloadAPIView):
    __doc__ = 'Download a pack.' \
              '<br>Full documentation can be found <a href="%s/%s" target="_blank">here</a>. %s' \
              % (docs_base_url, '%s#download-pack-oauth2-required' % resources_doc_filename,
                 get_formatted_examples_for_view('DownloadPack', 'apiv2-pack-download', max=5))


    def get(self, request,  *args, **kwargs):
        pack_id = kwargs['pk']
        logger.info(self.log_message('pack:%i download' % (int(pack_id))))
        try:
            pack = Pack.objects.get(id=pack_id)
        except Pack.DoesNotExist:
            raise NotFoundException

        sounds = pack.sound_set.filter(processing_state="OK", moderation_state="OK")
        if not sounds:
            raise NotFoundException(msg='Sounds in pack %i have not yet been described or moderated' % int(pack_id))

        try:
            filelist = "%s %i %s %s\r\n" % (pack.license_crc,
                                            os.stat(pack.locations('license_path')).st_size,
                                            pack.locations('license_url'),
                                            "_readme_and_license.txt")
        except:
            raise ServerErrorException

        for sound in sounds:
            url = sound.locations("sendfile_url")
            name = sound.friendly_filename()
            if sound.crc == '':
                continue
            filelist += "%s %i %s %s\r\n" % (sound.crc, sound.filesize, url, name)
        response = HttpResponse(filelist, content_type="text/plain")
        response['X-Archive-Files'] = 'zip'
        return response


##################
# READ WRITE VIEWS
##################


class UploadSound(WriteRequiredGenericAPIView):
    __doc__ = 'Upload an audiofile and (optionally) describe  it.' \
              '<br>Full documentation can be found <a href="%s/%s" target="_blank">here</a>. %s' \
              % (docs_base_url, '%s#upload-sound-oauth2-required' % resources_doc_filename,
                 get_formatted_examples_for_view('UploadSound', 'apiv2-uploads-upload', max=5))

    serializer_class = UploadAndDescribeAudioFileSerializer
    parser_classes = (MultiPartParser,)

    def post(self, request,  *args, **kwargs):
        logger.info(self.log_message('upload_sound'))
        serializer = UploadAndDescribeAudioFileSerializer(data=request.DATA, files=request.FILES)
        if serializer.is_valid():
            audiofile = request.FILES['audiofile']
            try:
                handle_uploaded_file(self.user.id, audiofile)
            except:
                raise ServerErrorException
            serializer.data['upload_filename'] = request.FILES['audiofile'].name

            if not settings.ALLOW_WRITE_WHEN_SESSION_BASED_AUTHENTICATION and self.auth_method_name == 'Session':
                if serializer.is_providing_description(serializer.data):
                    msg = 'Audio file successfully uploaded and described (now pending processing and moderation).'
                else:
                    msg = 'Audio file successfully uploaded (%i, now pending description).' % audiofile.size
                return Response(data={'detail': msg,
                                      'id': None,
                                      'note': 'Sound has not been saved in the database as browseable API is only for testing purposes.'},
                                status=status.HTTP_201_CREATED)
            else:
                if serializer.is_providing_description(serializer.data):
                    sound = create_sound_object(self.user, serializer.data)
                    return Response(data={'detail': 'Audio file successfully uploaded and described (now pending processing and moderation).', 'id': int(sound.id) }, status=status.HTTP_201_CREATED)
                else:
                    return Response(data={'filename': audiofile.name, 'detail': 'Audio file successfully uploaded (%i, now pending description).' % audiofile.size}, status=status.HTTP_201_CREATED)
        else:
            return Response({'detail': serializer.errors}, status=status.HTTP_400_BAD_REQUEST)


class PendingUploads(OauthRequiredAPIView):
    __doc__ = 'List of uploaded files which have not yet been described, processed or moderated.' \
              '<br>Full documentation can be found <a href="%s/%s" target="_blank">here</a>. %s' \
              % (docs_base_url, '%s#pending-uploads-oauth2-required' % resources_doc_filename,
                 get_formatted_examples_for_view('PendingUploads', 'apiv2-uploads-pending', max=5))

    def get(self, request,  *args, **kwargs):
        logger.info(self.log_message('pending_uploads'))

        # Look for sounds pending description
        file_structure, files = generate_tree(os.path.join(settings.UPLOADS_PATH, str(self.user.id)))
        pending_description = [file_instance.name for file_id, file_instance in files.items()]

        # Look for sounds pending processing
        qs = Sound.objects.filter(user=self.user).exclude(processing_state='OK').exclude(moderation_state='OK')
        pending_processing = [self.get_minimal_sound_info(sound, processing_state=True) for sound in qs]

        # Look for sounds pending moderation
        qs = Sound.objects.filter(user=self.user, processing_state='OK').exclude(moderation_state='OK')
        pending_moderation = [self.get_minimal_sound_info(sound, images=True) for sound in qs]

        data_response = dict()
        data_response['pending_description'] = pending_description
        data_response['pending_processing'] = pending_processing
        data_response['pending_moderation'] = pending_moderation

        return Response(data=data_response, status=status.HTTP_200_OK)

    def get_minimal_sound_info(self, sound, images=False, processing_state=False):
        sound_data = dict()
        for key, value in SoundSerializer(sound, context=self.get_serializer_context()).data.items():
            if key in ['id', 'name', 'tags', 'description', 'created', 'license']:
                sound_data[key] = value
            if images:
                if key == 'images':
                    sound_data[key] = value
        if processing_state:
            PROCESSING_STATE_API = {
                'QU': 'Queued',
                'PE': 'Pending',
                'PR': 'Processing',
                'FA': 'Failed',
                'OK': 'Processed'
            }
            sound_data['processing_state'] = PROCESSING_STATE_API[str(sound.processing_state)]

        return sound_data


class DescribeSound(WriteRequiredGenericAPIView):
    __doc__ = 'Describe a previously uploaded sound.' \
              '<br>Full documentation can be found <a href="%s/%s" target="_blank">here</a>. %s' \
              % (docs_base_url, '%s#describe-sound-oauth2-required' % resources_doc_filename,
                 get_formatted_examples_for_view('DescribeSound', 'apiv2-uploads-describe', max=5))

    serializer_class = SoundDescriptionSerializer

    def post(self, request,  *args, **kwargs):
        logger.info(self.log_message('describe_sound'))
        file_structure, files = generate_tree(os.path.join(settings.UPLOADS_PATH, str(self.user.id)))
        filenames = [file_instance.name for file_id, file_instance in files.items()]
        serializer = SoundDescriptionSerializer(data=request.DATA, context={'not_yet_described_audio_files': filenames})
        if serializer.is_valid():
            if not settings.ALLOW_WRITE_WHEN_SESSION_BASED_AUTHENTICATION and self.auth_method_name == 'Session':
                return Response(data={'detail': 'Sound successfully described (now pending processing and moderation).',
                                      'id': None,
                                      'note': 'Sound has not been saved in the database as browseable API is only for testing purposes.'},
                                status=status.HTTP_201_CREATED)
            else:
                sound = create_sound_object(self.user, serializer.data)
                return Response(data={'detail': 'Sound successfully described (now pending processing and moderation).', 'id': int(sound.id)}, status=status.HTTP_201_CREATED)
        else:
            return Response({'detail': serializer.errors}, status=status.HTTP_400_BAD_REQUEST)


class EditSoundDescription(WriteRequiredGenericAPIView):
    __doc__ = 'Edit the description of an existing sound.' \
              '<br>Full documentation can be found <a href="%s/%s" target="_blank">here</a>. %s' \
              % (docs_base_url, '%s#edit-sound-description-oauth2-required' % resources_doc_filename,
                 get_formatted_examples_for_view('EditSoundDescription', 'apiv2-sound-edit', max=5))

    serializer_class = EditSoundDescriptionSerializer

    def post(self, request,  *args, **kwargs):
        sound_id = kwargs['pk']
        # Check that sound exists
        try:
            sound = Sound.objects.get(id=sound_id, moderation_state="OK", processing_state="OK")
        except Sound.DoesNotExist:
            raise NotFoundException
        # Check that sound belongs to current end user
        if sound.user != self.user:
            raise UnauthorizedException(msg='Not authorized. The sound you\'re trying to edit is not owned by the OAuth2 logged in user.')

        logger.info(self.log_message('sound:%s edit_description' % sound_id))
        serializer = EditSoundDescriptionSerializer(data=request.DATA)
        if serializer.is_valid():
            if not settings.ALLOW_WRITE_WHEN_SESSION_BASED_AUTHENTICATION and self.auth_method_name == 'Session':
                return Response(data={'detail': 'Description of sound %s successfully edited.' % sound_id,
                                      'note': 'Description of sound %s has not been saved in the database as browseable API is only for testing purposes.' % sound_id},
                                status=status.HTTP_200_OK)
            else:
                if 'name' in serializer.data:
                    if serializer.data['name']:
                        sound.original_filename = serializer.data['name']
                if 'description' in serializer.data:
                    if serializer.data['description']:
                        sound.description = serializer.data['description']
                if 'tags' in serializer.data:
                    if serializer.data['tags']:
                        sound.set_tags(serializer.data['tags'])
                if 'license' in serializer.data:
                    if serializer.data['license']:
                        license = License.objects.get(name=serializer.data['license'])
                        sound.license = license
                if 'geotag' in serializer.data:
                    if serializer.data['geotag']:
                        lat, lon, zoom = serializer.data['geotag'].split(',')
                        geotag = GeoTag(user=self.user,
                            lat=float(lat),
                            lon=float(lon),
                            zoom=int(zoom))
                        geotag.save()
                        sound.geotag = geotag
                if 'pack' in serializer.data:
                    if serializer.data['pack']:
                        if Pack.objects.filter(name=serializer.data['pack'], user=self.user).exists():
                            p = Pack.objects.get(name=serializer.data['pack'], user=self.user)
                        else:
                            p, created = Pack.objects.get_or_create(user=self.user, name=serializer.data['pack'])
                        sound.pack = p
                sound.save()

                # Invalidate caches
                invalidate_template_cache("sound_header", sound.id, True)
                invalidate_template_cache("sound_header", sound.id, False)
                invalidate_template_cache("sound_footer_top", sound.id)
                invalidate_template_cache("sound_footer_bottom", sound.id)
                invalidate_template_cache("display_sound", sound.id, True, sound.processing_state, sound.moderation_state)
                invalidate_template_cache("display_sound", sound.id, False, sound.processing_state, sound.moderation_state)

                return Response(data={'detail': 'Description of sound %s successfully edited.' % sound_id}, status=status.HTTP_200_OK)
        else:
            return Response({'detail': serializer.errors}, status=status.HTTP_400_BAD_REQUEST)


class BookmarkSound(WriteRequiredGenericAPIView):
    __doc__ = 'Bookmark a sound.' \
              '<br>Full documentation can be found <a href="%s/%s" target="_blank">here</a>. %s' \
              % (docs_base_url, '%s#bookmark-sound-oauth2-required' % resources_doc_filename,
                 get_formatted_examples_for_view('BookmarkSound', 'apiv2-user-create-bookmark', max=5))

    serializer_class = CreateBookmarkSerializer

    def post(self, request,  *args, **kwargs):
        sound_id = kwargs['pk']
        try:
            sound = Sound.objects.get(id=sound_id, moderation_state="OK", processing_state="OK")
        except Sound.DoesNotExist:
            raise NotFoundException
        logger.info(self.log_message('sound:%s create_bookmark' % sound_id))
        serializer = CreateBookmarkSerializer(data=request.DATA)
        if serializer.is_valid():
            if not settings.ALLOW_WRITE_WHEN_SESSION_BASED_AUTHENTICATION and self.auth_method_name == 'Session':
                return Response(data={'detail': 'Successfully bookmarked sound %s.' % sound_id,
                                      'note': 'This bookmark has not been saved in the database as browseable API is only for testing purposes.'},
                                status=status.HTTP_201_CREATED)
            else:
                if serializer.data['name']:
                    name = serializer.data['name']
                else:
                    name = sound.original_filename
                if serializer.data['category']:
                    category = BookmarkCategory.objects.get_or_create(user=self.user, name=serializer.data['category'])
                    bookmark = Bookmark(user=self.user, name=name, sound_id=sound_id, category=category[0])
                else:
                    bookmark = Bookmark(user=self.user, name=name, sound_id=sound_id)
                bookmark.save()
                return Response(data={'detail': 'Successfully bookmarked sound %s.' % sound_id}, status=status.HTTP_201_CREATED)
        else:
            return Response({'detail': serializer.errors}, status=status.HTTP_400_BAD_REQUEST)


class RateSound(WriteRequiredGenericAPIView):
    __doc__ = 'Rate a sound.' \
              '<br>Full documentation can be found <a href="%s/%s" target="_blank">here</a>. %s' \
              % (docs_base_url, '%s#rate-sound-oauth2-required' % resources_doc_filename,
                 get_formatted_examples_for_view('RateSound', 'apiv2-user-create-rating', max=5))

    serializer_class = CreateRatingSerializer

    def post(self, request,  *args, **kwargs):
        sound_id = kwargs['pk']
        try:
            sound = Sound.objects.get(id=sound_id, moderation_state="OK", processing_state="OK")
        except Sound.DoesNotExist:
            raise NotFoundException
        logger.info(self.log_message('sound:%s create_rating' % sound_id))
        serializer = CreateRatingSerializer(data=request.DATA)
        if serializer.is_valid():
            try:
                if not settings.ALLOW_WRITE_WHEN_SESSION_BASED_AUTHENTICATION and self.auth_method_name == 'Session':
                    return Response(data={'detail': 'Successfully rated sound %s.' % sound_id,
                                          'note': 'This rating has not been saved in the database as browseable API is only for testing purposes.'},
                                    status=status.HTTP_201_CREATED)
                else:
                    Rating.objects.create(user=self.user, object_id=sound_id, content_type=ContentType.objects.get(id=20), rating=int(request.DATA['rating'])*2)
                    return Response(data={'detail': 'Successfully rated sound %s.' % sound_id}, status=status.HTTP_201_CREATED)
            except IntegrityError:
                raise ConflictException(msg='User has already rated sound %s' % sound_id)
            except:
                raise ServerErrorException
        else:
            return Response({'detail': serializer.errors}, status=status.HTTP_400_BAD_REQUEST)


class CommentSound(WriteRequiredGenericAPIView):
    __doc__ = 'Add a comment to a sound.' \
              '<br>Full documentation can be found <a href="%s/%s" target="_blank">here</a>. %s' \
              % (docs_base_url, '%s#comment-sound-oauth2-required' % resources_doc_filename,
                 get_formatted_examples_for_view('CommentSound', 'apiv2-user-create-comment', max=5))

    serializer_class = CreateCommentSerializer

    def post(self, request,  *args, **kwargs):
        sound_id = kwargs['pk']
        try:
            sound = Sound.objects.get(id=sound_id, moderation_state="OK", processing_state="OK")
        except Sound.DoesNotExist:
            raise NotFoundException
        logger.info(self.log_message('sound:%s create_comment' % sound_id))
        serializer = CreateCommentSerializer(data=request.DATA)
        if serializer.is_valid():
            if not settings.ALLOW_WRITE_WHEN_SESSION_BASED_AUTHENTICATION and self.auth_method_name == 'Session':
                return Response(data={'detail': 'Successfully commented sound %s.' % sound_id,
                                      'note': 'This comment has not been saved in the database as browseable API is only for testing purposes.'},
                                status=status.HTTP_201_CREATED)
            else:
                comment = Comment.objects.create(user=self.user, object_id=sound_id, content_type=ContentType.objects.get(id=20), comment=request.DATA['comment'])
                if comment.content_type == ContentType.objects.get_for_model(Sound):
                    sound = comment.content_object
                    sound.num_comments = sound.num_comments + 1
                    sound.save()
                return Response(data={'detail': 'Successfully commented sound %s.' % sound_id}, status=status.HTTP_201_CREATED)
        else:
            return Response({'detail': serializer.errors}, status=status.HTTP_400_BAD_REQUEST)


#############
# OTHER VIEWS
#############

### Me View
class Me(OauthRequiredAPIView):
    __doc__ = 'Get some information about the end-user logged into the api.' \
              '<br>Full documentation can be found <a href="%s/%s" target="_blank">here</a>.' \
              % (docs_base_url, '%s#me-information-about-user-authenticated-using-oauth2-oauth2-required' % resources_doc_filename)

    #authentication_classes = (OAuth2Authentication, SessionAuthentication)

    def get(self, request,  *args, **kwargs):
        logger.info(self.log_message('me'))
        if self.user:
            response_data = UserSerializer(self.user, context=self.get_serializer_context()).data
            response_data.update({
                 'email': self.user.email,
                 'unique_id': self.user.id,
            })
            return Response(response_data, status=status.HTTP_200_OK)
        else:
            raise ServerErrorException


### Root view
class FreesoundApiV2Resources(GenericAPIView):
    __doc__ = 'List of resources available in the Freesound APIv2. ' \
              '<br>Full APIv2 documentation can be found <a href="%s/%s" target="_blank">here</a>.' \
              '<br>Note that urls containing elements in brackets (<>) should be replaced with the corresponding variables.' \
              % (docs_base_url, 'index.html')

    #authentication_classes = (OAuth2Authentication, TokenAuthentication, SessionAuthentication)

    def get(self, request,  *args, **kwargs):
        logger.info(self.log_message('api_root'))
        return Response([
            {'Search resources': OrderedDict(sorted(dict({
                    '01 Text Search': prepend_base(reverse('apiv2-sound-text-search'), request_is_secure=request.using_https),
                    '02 Content Search': prepend_base(reverse('apiv2-sound-content-search'), request_is_secure=request.using_https),
                    '03 Combined Search': prepend_base(reverse('apiv2-sound-combined-search'), request_is_secure=request.using_https),
                }).items(), key=lambda t: t[0]))},
                {'Sound resources': OrderedDict(sorted(dict({
                    '01 Sound instance': prepend_base(reverse('apiv2-sound-instance', args=[0]).replace('0', '<sound_id>'), request_is_secure=request.using_https),
                    '02 Similar sounds': prepend_base(reverse('apiv2-similarity-sound', args=[0]).replace('0', '<sound_id>'), request_is_secure=request.using_https),
                    '03 Sound analysis': prepend_base(reverse('apiv2-sound-analysis', args=[0]).replace('0', '<sound_id>'), request_is_secure=request.using_https),
                    '04 Sound comments': prepend_base(reverse('apiv2-sound-comments', args=[0]).replace('0', '<sound_id>'), request_is_secure=request.using_https),
                    '05 Download sound': prepend_base(reverse('apiv2-sound-download', args=[0]).replace('0', '<sound_id>')),
                    '06 Bookmark sound': prepend_base(reverse('apiv2-user-create-bookmark', args=[0]).replace('0', '<sound_id>')),
                    '07 Rate sound': prepend_base(reverse('apiv2-user-create-rating', args=[0]).replace('0', '<sound_id>')),
                    '08 Comment sound': prepend_base(reverse('apiv2-user-create-comment', args=[0]).replace('0', '<sound_id>')),
                    '09 Upload sound': prepend_base(reverse('apiv2-uploads-upload')),
                    '10 Describe sound': prepend_base(reverse('apiv2-uploads-describe')),
                    '11 Pending uploads': prepend_base(reverse('apiv2-uploads-pending')),
                    '12 Edit sound description': prepend_base(reverse('apiv2-sound-edit', args=[0]).replace('0', '<sound_id>')),
                }).items(), key=lambda t: t[0]))},
                {'User resources': OrderedDict(sorted(dict({
                    '01 User instance': prepend_base(reverse('apiv2-user-instance', args=['uname']).replace('uname', '<username>'), request_is_secure=request.using_https),
                    '02 User sounds': prepend_base(reverse('apiv2-user-sound-list', args=['uname']).replace('uname', '<username>'), request_is_secure=request.using_https),
                    '03 User packs': prepend_base(reverse('apiv2-user-packs', args=['uname']).replace('uname', '<username>'), request_is_secure=request.using_https),
                    '04 User bookmark categories': prepend_base(reverse('apiv2-user-bookmark-categories', args=['uname']).replace('uname', '<username>'), request_is_secure=request.using_https),
                    '05 User bookmark category sounds': prepend_base(reverse('apiv2-user-bookmark-category-sounds', args=['uname', 0]).replace('0', '<category_id>').replace('uname', '<username>'), request_is_secure=request.using_https),
                    '06 Me (information about user authenticated using oauth)': prepend_base(reverse('apiv2-me')),
                }).items(), key=lambda t: t[0]))},
                {'Pack resources': OrderedDict(sorted(dict({
                    '01 Pack instance': prepend_base(reverse('apiv2-pack-instance', args=[0]).replace('0', '<pack_id>'), request_is_secure=request.using_https),
                    '02 Pack sounds': prepend_base(reverse('apiv2-pack-sound-list', args=[0]).replace('0', '<pack_id>'), request_is_secure=request.using_https),
                    '03 Download pack': prepend_base(reverse('apiv2-pack-download', args=[0]).replace('0', '<pack_id>')),
                }).items(), key=lambda t: t[0]))},
            ])


### View for returning "Invalid url" 400 responses
@api_view(['GET'])
@authentication_classes([OAuth2Authentication, TokenAuthentication, SessionAuthentication])
def invalid_url(request):
    raise InvalidUrlException


### View for applying for an apikey
@login_required
def create_apiv2_key(request):

    if request.method == 'POST':
        form = ApiV2ClientForm(request.POST)
        if form.is_valid():
            api_client = ApiV2Client()
            api_client.user = request.user
            api_client.description = form.cleaned_data['description']
            api_client.name = form.cleaned_data['name']
            api_client.url = form.cleaned_data['url']
            api_client.redirect_uri = form.cleaned_data['redirect_uri']
            api_client.accepted_tos = form.cleaned_data['accepted_tos']
            api_client.save()
            form = ApiV2ClientForm()
            logger.info('%s <> (ApiV2 Auth:%s Dev:%s User:%s Client:%s)' % ('new_credential', None, request.user.username, None, api_client.client_id))
    else:
        form = ApiV2ClientForm()

    if settings.APIV2KEYS_ALLOWED_FOR_APIV1:
        user_credentials = list(request.user.apiv2_client.all()) + list(request.user.api_keys.all())
    else:
        user_credentials = request.user.apiv2_client.all()

    use_https_in_callback = True
    if settings.DEBUG:
        use_https_in_callback = False
    fs_callback_url = prepend_base(reverse('permission-granted'), use_https=use_https_in_callback)  #request.build_absolute_uri(reverse('permission-granted'))


    return render_to_response('api/apply_key_apiv2.html',
                              {'user': request.user,
                               'form': form,
                               'user_credentials': user_credentials,
                               'combined_apiv1_and_apiv2': settings.APIV2KEYS_ALLOWED_FOR_APIV1,
                               'fs_callback_url': fs_callback_url,
                               }, context_instance=RequestContext(request))


### View for editing client (works both for apiv2 and apiv1)
@login_required
def edit_api_credential(request, key):
    client = None
    try:
        client = ApiV2Client.objects.get(key=key)
    except ApiV2Client.DoesNotExist:
        pass

    try:
        client = ApiKey.objects.get(key=key)
    except ApiKey.DoesNotExist:
        pass

    if not client:
        raise Http404

    if request.method == 'POST':
        if client.version == 'V2':
            form = ApiV2ClientForm(request.POST)
            if form.is_valid():
                client.name = form.cleaned_data['name']
                client.url = form.cleaned_data['url']
                client.redirect_uri = form.cleaned_data['redirect_uri']
                client.description = form.cleaned_data['description']
                client.accepted_tos = form.cleaned_data['accepted_tos']
                client.save()
                messages.add_message(request, messages.INFO, "Credentials with name %s have been updated." % client.name)
                return HttpResponseRedirect(reverse("apiv2-apply"))
        elif client.version == 'V1':
            form = ApiKeyForm(request.POST)
            if form.is_valid():
                client.name = form.cleaned_data['name']
                client.url = form.cleaned_data['url']
                client.description = form.cleaned_data['description']
                client.accepted_tos = form.cleaned_data['accepted_tos']
                client.save()
                messages.add_message(request, messages.INFO, "Credentials with name %s have been updated." % client.name)
                return HttpResponseRedirect(reverse("apiv2-apply"))
    else:
        if client.version == 'V2':
            form = ApiV2ClientForm(initial={'name': client.name,
                                            'url': client.url,
                                            'redirect_uri': client.redirect_uri,
                                            'description': client.description,
                                            'accepted_tos': client.accepted_tos
                                            })
        elif client.version == 'V1':
            form = ApiKeyForm(initial={'name': client.name,
                                        'url': client.url,
                                        'description': client.description,
                                        'accepted_tos': client.accepted_tos
                                        })

    use_https_in_callback = True
    if settings.DEBUG:
        use_https_in_callback = False
    fs_callback_url = prepend_base(reverse('permission-granted'), use_https=use_https_in_callback)
    return render_to_response('api/edit_api_credential.html',
                              {'client': client,
                               'form': form,
                               'fs_callback_url': fs_callback_url,
                               }, context_instance=RequestContext(request))


### View for deleting api clients (works both for apiv2 and apiv1)
@login_required
def delete_api_credential(request, key):
    name = ""

    try:
        client = ApiV2Client.objects.get(key=key)
        name = client.name
        client.delete()
    except ApiV2Client.DoesNotExist:
        pass

    try:
        client = ApiKey.objects.get(key=key)
        name = client.name
        client.delete()
    except ApiKey.DoesNotExist:
        pass

    messages.add_message(request, messages.INFO, "Credentials with name %s have been deleted." % name)
    return HttpResponseRedirect(reverse("apiv2-apply"))


### View for managing permissions granted to apps
@login_required
def granted_permissions(request):
    user = request.user
    tokens_raw = AccessToken.objects.select_related('client').filter(user=user).order_by('-expires')
    tokens = []
    token_names = []

    # If settings.OAUTH_SINGLE_ACCESS_TOKEN is set to false it is possible that one single user have more than one active
    # access token per application. In that case we only show the one that expires later (and all are removed if permissions
    # revoked). If settings.OAUTH_SINGLE_ACCESS_TOKEN is set to true we don't need the token name check below because
    # there can only be one access token per client-user pair. Nevertheless the code below works in both cases.

    for token in tokens_raw:
        if not token.client.apiv2_client.name in token_names:
            td = (token.expires - datetime.datetime.today())
            seconds_to_expiration_date = (td.microseconds + (td.seconds + td.days * 24 * 3600) * 10**6) / 10**6
            tokens.append({
                'client_name': token.client.apiv2_client.name,
                'expiration_date': token.expires,
                'expired': seconds_to_expiration_date < 0,
                'scope': token.client.apiv2_client.get_scope_display,
                'client_id': token.client.apiv2_client.client_id,
                'developer': token.client.apiv2_client.user.username,
            })
            token_names.append(token.client.apiv2_client.name)

    grants_pending_access_token_request_raw = Grant.objects.select_related('client').filter(user=user).order_by('-expires')
    grants = []
    grant_and_token_names = token_names[:]
    for grant in grants_pending_access_token_request_raw:
        if not grant.client.apiv2_client.name in grant_and_token_names:
            td = (grant.expires - datetime.datetime.today())
            seconds_to_expiration_date = (td.microseconds + (td.seconds + td.days * 24 * 3600) * 10**6) / 10**6
            if seconds_to_expiration_date > 0:
                grants.append({
                    'client_name': grant.client.apiv2_client.name,
                    'expiration_date': grant.expires,
                    'expired': seconds_to_expiration_date < 0,
                    'scope': grant.client.apiv2_client.get_scope_display,
                    'client_id': grant.client.apiv2_client.client_id,
                    'developer': grant.client.apiv2_client.user.username,
                })
                grant_and_token_names.append(grant.client.apiv2_client.name)

    return render_to_response('api/manage_permissions.html',
                              {'user': request.user, 'tokens': tokens, 'grants': grants, 'show_expiration_date': False},
                              context_instance=RequestContext(request))


### View to revoke permissions granted to an application
@login_required
def revoke_permission(request, client_id):
    user = request.user
    tokens = AccessToken.objects.filter(user=user, client__client_id=client_id)
    for token in tokens:
        token.delete()

    grants = Grant.objects.filter(user=user, client__client_id=client_id)
    for grant in grants:
        grant.delete()

    return HttpResponseRedirect(reverse("access-tokens"))


### View to show grant code (pin code) if application does not support redirection
@login_required
def permission_granted(request):
    user = request.user
    code = request.GET.get('code', None)
    app_name = None
    try:
        grant = Grant.objects.get(user=user, code=code)
        app_name = grant.client.apiv2_client.name
    except:
        grant = None

    if settings.USE_MINIMAL_TEMPLATES_FOR_OAUTH:
        template = 'api/minimal_app_authorized.html'
    else:
        template = 'api/app_authorized.html'

    logout_next = request.GET.get('original_path', None)
    if logout_next:
        logout_next = quote(logout_next)
    else:
        logout_next = reverse('api-login')

    return render_to_response(template,
                              {'code': code, 'app_name': app_name, 'logout_next': logout_next},
                              context_instance=RequestContext(request))


### View for registration using minimal template
def minimal_registration(request):

    if request.method == "POST":
        form = RegistrationForm(request, request.POST)
        if form.is_valid():
            user = form.save()
            send_activation2(user)
            return render_to_response('api/minimal_registration_done.html', locals(), context_instance=RequestContext(request))
    else:
        form = RegistrationForm(request)

    return render_to_response('api/minimal_registration.html', locals(), context_instance=RequestContext(request))

########NEW FILE########
__FILENAME__ = admin
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.contrib import admin
from bookmarks.models import Bookmark, BookmarkCategory

class BookmarkAdmin(admin.ModelAdmin):
    raw_id_fields = ('user','category','sound') 
    list_display = ('user', 'name', 'category', 'sound')

class BookmarkCategoryAdmin(admin.ModelAdmin):
    raw_id_fields = ('user',) 
    list_display = ('user', 'name')


admin.site.register(Bookmark, BookmarkAdmin)
admin.site.register(BookmarkCategory, BookmarkCategoryAdmin)
########NEW FILE########
__FILENAME__ = forms
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django import forms
#from django.forms import ModelForm, TextInput, Select
from bookmarks.models import BookmarkCategory, Bookmark

class BookmarkCategoryForm(forms.ModelForm):
    
    class Meta:
        model = BookmarkCategory
        fields = ('name',)
        widgets = {
            'name': forms.TextInput(attrs={'class':'category_name_widget'}),
        }

class BookmarkForm(forms.ModelForm):
    new_category_name = forms.CharField(max_length=128, help_text="<br>If you want a new category, don't select one above, set its new name here.", required=False)

    class Meta:
        model = Bookmark
        fields = ('name','category')
        widgets = {
            'name': forms.TextInput(attrs={'class':'name_widget'}),
        }
    
    def save(self):
        
        try:
            bookmark = Bookmark(user=self.instance.user,sound=self.instance.sound)
            
            if not self.cleaned_data['category']:
                if self.cleaned_data['new_category_name'] != "":
                    category = BookmarkCategory(user=self.instance.user, name=self.cleaned_data['new_category_name'])
                    category.save()
                    bookmark.category = category
                    self.cleaned_data['category'] = category
            else:
                bookmark.category = self.cleaned_data['category']
            
            if self.cleaned_data['name'] != "":
                bookmark.name = self.cleaned_data['name']
            
            bookmark.save()
            return True
        
        except:
            return False
########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'Bookmark'
        db.create_table('bookmarks_bookmark', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'])),
            ('name', self.gf('django.db.models.fields.CharField')(default='', max_length=128)),
            ('sound', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['sounds.Sound'])),
            ('created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, db_index=True, blank=True)),
        ))
        db.send_create_signal('bookmarks', ['Bookmark'])

        # Adding unique constraint on 'Bookmark', fields ['user', 'sound']
        db.create_unique('bookmarks_bookmark', ['user_id', 'sound_id'])

        # Adding model 'BookmarkCategory'
        db.create_table('bookmarks_bookmarkcategory', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'])),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=128)),
            ('description', self.gf('django.db.models.fields.TextField')(default=None, null=True, blank=True)),
        ))
        db.send_create_signal('bookmarks', ['BookmarkCategory'])

        # Adding M2M table for field sounds on 'BookmarkCategory'
        db.create_table('bookmarks_bookmarkcategory_sounds', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('bookmarkcategory', models.ForeignKey(orm['bookmarks.bookmarkcategory'], null=False)),
            ('bookmark', models.ForeignKey(orm['bookmarks.bookmark'], null=False))
        ))
        db.create_unique('bookmarks_bookmarkcategory_sounds', ['bookmarkcategory_id', 'bookmark_id'])


    def backwards(self, orm):
        
        # Removing unique constraint on 'Bookmark', fields ['user', 'sound']
        db.delete_unique('bookmarks_bookmark', ['user_id', 'sound_id'])

        # Deleting model 'Bookmark'
        db.delete_table('bookmarks_bookmark')

        # Deleting model 'BookmarkCategory'
        db.delete_table('bookmarks_bookmarkcategory')

        # Removing M2M table for field sounds on 'BookmarkCategory'
        db.delete_table('bookmarks_bookmarkcategory_sounds')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'bookmarks.bookmark': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'sound'),)", 'object_name': 'Bookmark'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128'}),
            'sound': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sounds.Sound']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'bookmarks.bookmarkcategory': {
            'Meta': {'object_name': 'BookmarkCategory'},
            'description': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'sounds': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'categories'", 'blank': 'True', 'to': "orm['bookmarks.Bookmark']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'comments.comment': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Comment'},
            'comment': ('django.db.models.fields.TextField', [], {}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'related_name': "'replies'", 'null': 'True', 'blank': 'True', 'to': "orm['comments.Comment']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'favorites.favorite': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'Favorite'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'geotags.geotag': {
            'Meta': {'object_name': 'GeoTag'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lat': ('django.db.models.fields.FloatField', [], {'db_index': 'True'}),
            'lon': ('django.db.models.fields.FloatField', [], {'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'zoom': ('django.db.models.fields.IntegerField', [], {})
        },
        'ratings.rating': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'Rating'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'rating': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'sounds.license': {
            'Meta': {'ordering': "['order']", 'object_name': 'License'},
            'abbreviation': ('django.db.models.fields.CharField', [], {'max_length': '8', 'db_index': 'True'}),
            'deed_url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'legal_code_url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '512'}),
            'order': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'summary': ('django.db.models.fields.TextField', [], {})
        },
        'sounds.pack': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'name'),)", 'object_name': 'Pack'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_dirty': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'db_index': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'num_downloads': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'sounds.sound': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Sound'},
            'analysis_state': ('django.db.models.fields.CharField', [], {'default': "'PE'", 'max_length': '2', 'db_index': 'True'}),
            'avg_rating': ('django.db.models.fields.FloatField', [], {'default': '0'}),
            'base_filename_slug': ('django.db.models.fields.CharField', [], {'default': 'None', 'max_length': '512', 'null': 'True', 'blank': 'True'}),
            'bitdepth': ('django.db.models.fields.IntegerField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'bitrate': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'channels': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'date_recorded': ('django.db.models.fields.DateField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'duration': ('django.db.models.fields.FloatField', [], {'default': '0'}),
            'filesize': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'geotag': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['geotags.GeoTag']", 'null': 'True', 'blank': 'True'}),
            'has_bad_description': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_index_dirty': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'license': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sounds.License']"}),
            'md5': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'moderation_date': ('django.db.models.fields.DateTimeField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'moderation_note': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'moderation_state': ('django.db.models.fields.CharField', [], {'default': "'PE'", 'max_length': '2', 'db_index': 'True'}),
            'num_comments': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'num_downloads': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'num_ratings': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'original_filename': ('django.db.models.fields.CharField', [], {'max_length': '512'}),
            'original_path': ('django.db.models.fields.CharField', [], {'default': 'None', 'max_length': '512', 'null': 'True', 'blank': 'True'}),
            'pack': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['sounds.Pack']", 'null': 'True', 'blank': 'True'}),
            'processing_date': ('django.db.models.fields.DateTimeField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'processing_log': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'processing_state': ('django.db.models.fields.CharField', [], {'default': "'PE'", 'max_length': '2', 'db_index': 'True'}),
            'samplerate': ('django.db.models.fields.FloatField', [], {'default': '0'}),
            'similarity_state': ('django.db.models.fields.CharField', [], {'default': "'PE'", 'max_length': '2', 'db_index': 'True'}),
            'sources': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'remixes'", 'blank': 'True', 'to': "orm['sounds.Sound']"}),
            'type': ('django.db.models.fields.CharField', [], {'max_length': '4', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'sounds'", 'to': "orm['auth.User']"})
        },
        'tags.tag': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '100', 'db_index': 'True'})
        },
        'tags.taggeditem': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('tag', 'content_type', 'object_id'),)", 'object_name': 'TaggedItem'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'tag': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['tags.Tag']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        }
    }

    complete_apps = ['bookmarks']

########NEW FILE########
__FILENAME__ = 0002_auto
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Removing M2M table for field sounds on 'BookmarkCategory'
        db.delete_table('bookmarks_bookmarkcategory_sounds')

        # Adding M2M table for field bookmarks on 'BookmarkCategory'
        db.create_table('bookmarks_bookmarkcategory_bookmarks', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('bookmarkcategory', models.ForeignKey(orm['bookmarks.bookmarkcategory'], null=False)),
            ('bookmark', models.ForeignKey(orm['bookmarks.bookmark'], null=False))
        ))
        db.create_unique('bookmarks_bookmarkcategory_bookmarks', ['bookmarkcategory_id', 'bookmark_id'])


    def backwards(self, orm):
        
        # Adding M2M table for field sounds on 'BookmarkCategory'
        db.create_table('bookmarks_bookmarkcategory_sounds', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('bookmarkcategory', models.ForeignKey(orm['bookmarks.bookmarkcategory'], null=False)),
            ('bookmark', models.ForeignKey(orm['bookmarks.bookmark'], null=False))
        ))
        db.create_unique('bookmarks_bookmarkcategory_sounds', ['bookmarkcategory_id', 'bookmark_id'])

        # Removing M2M table for field bookmarks on 'BookmarkCategory'
        db.delete_table('bookmarks_bookmarkcategory_bookmarks')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'bookmarks.bookmark': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'sound'),)", 'object_name': 'Bookmark'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128'}),
            'sound': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sounds.Sound']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'bookmarks.bookmarkcategory': {
            'Meta': {'object_name': 'BookmarkCategory'},
            'bookmarks': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'categories'", 'blank': 'True', 'to': "orm['bookmarks.Bookmark']"}),
            'description': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'comments.comment': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Comment'},
            'comment': ('django.db.models.fields.TextField', [], {}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'related_name': "'replies'", 'null': 'True', 'blank': 'True', 'to': "orm['comments.Comment']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'favorites.favorite': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'Favorite'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'geotags.geotag': {
            'Meta': {'object_name': 'GeoTag'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lat': ('django.db.models.fields.FloatField', [], {'db_index': 'True'}),
            'lon': ('django.db.models.fields.FloatField', [], {'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'zoom': ('django.db.models.fields.IntegerField', [], {})
        },
        'ratings.rating': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'Rating'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'rating': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'sounds.license': {
            'Meta': {'ordering': "['order']", 'object_name': 'License'},
            'abbreviation': ('django.db.models.fields.CharField', [], {'max_length': '8', 'db_index': 'True'}),
            'deed_url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'legal_code_url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '512'}),
            'order': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'summary': ('django.db.models.fields.TextField', [], {})
        },
        'sounds.pack': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'name'),)", 'object_name': 'Pack'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_dirty': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'db_index': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'num_downloads': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'sounds.sound': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Sound'},
            'analysis_state': ('django.db.models.fields.CharField', [], {'default': "'PE'", 'max_length': '2', 'db_index': 'True'}),
            'avg_rating': ('django.db.models.fields.FloatField', [], {'default': '0'}),
            'base_filename_slug': ('django.db.models.fields.CharField', [], {'default': 'None', 'max_length': '512', 'null': 'True', 'blank': 'True'}),
            'bitdepth': ('django.db.models.fields.IntegerField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'bitrate': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'channels': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'date_recorded': ('django.db.models.fields.DateField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'duration': ('django.db.models.fields.FloatField', [], {'default': '0'}),
            'filesize': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'geotag': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['geotags.GeoTag']", 'null': 'True', 'blank': 'True'}),
            'has_bad_description': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_index_dirty': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'license': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sounds.License']"}),
            'md5': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'moderation_date': ('django.db.models.fields.DateTimeField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'moderation_note': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'moderation_state': ('django.db.models.fields.CharField', [], {'default': "'PE'", 'max_length': '2', 'db_index': 'True'}),
            'num_comments': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'num_downloads': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'num_ratings': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'original_filename': ('django.db.models.fields.CharField', [], {'max_length': '512'}),
            'original_path': ('django.db.models.fields.CharField', [], {'default': 'None', 'max_length': '512', 'null': 'True', 'blank': 'True'}),
            'pack': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['sounds.Pack']", 'null': 'True', 'blank': 'True'}),
            'processing_date': ('django.db.models.fields.DateTimeField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'processing_log': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'processing_state': ('django.db.models.fields.CharField', [], {'default': "'PE'", 'max_length': '2', 'db_index': 'True'}),
            'samplerate': ('django.db.models.fields.FloatField', [], {'default': '0'}),
            'similarity_state': ('django.db.models.fields.CharField', [], {'default': "'PE'", 'max_length': '2', 'db_index': 'True'}),
            'sources': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'remixes'", 'blank': 'True', 'to': "orm['sounds.Sound']"}),
            'type': ('django.db.models.fields.CharField', [], {'max_length': '4', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'sounds'", 'to': "orm['auth.User']"})
        },
        'tags.tag': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '100', 'db_index': 'True'})
        },
        'tags.taggeditem': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('tag', 'content_type', 'object_id'),)", 'object_name': 'TaggedItem'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'tag': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['tags.Tag']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        }
    }

    complete_apps = ['bookmarks']

########NEW FILE########
__FILENAME__ = 0003_auto__add_field_bookmark_category__del_unique_bookmark_sound_user__del
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Removing unique constraint on 'Bookmark', fields ['sound', 'user']
        db.delete_unique('bookmarks_bookmark', ['sound_id', 'user_id'])

        # Adding field 'Bookmark.category'
        db.add_column('bookmarks_bookmark', 'category', self.gf('django.db.models.fields.related.ForeignKey')(default=None, related_name='bookmarks', null=True, blank=True, to=orm['bookmarks.BookmarkCategory']), keep_default=False)

        # Deleting field 'BookmarkCategory.description'
        db.delete_column('bookmarks_bookmarkcategory', 'description')

        # Removing M2M table for field bookmarks on 'BookmarkCategory'
        db.delete_table('bookmarks_bookmarkcategory_bookmarks')


    def backwards(self, orm):
        
        # Deleting field 'Bookmark.category'
        db.delete_column('bookmarks_bookmark', 'category_id')

        # Adding unique constraint on 'Bookmark', fields ['sound', 'user']
        db.create_unique('bookmarks_bookmark', ['sound_id', 'user_id'])

        # Adding field 'BookmarkCategory.description'
        db.add_column('bookmarks_bookmarkcategory', 'description', self.gf('django.db.models.fields.TextField')(default=None, null=True, blank=True), keep_default=False)

        # Adding M2M table for field bookmarks on 'BookmarkCategory'
        db.create_table('bookmarks_bookmarkcategory_bookmarks', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('bookmarkcategory', models.ForeignKey(orm['bookmarks.bookmarkcategory'], null=False)),
            ('bookmark', models.ForeignKey(orm['bookmarks.bookmark'], null=False))
        ))
        db.create_unique('bookmarks_bookmarkcategory_bookmarks', ['bookmarkcategory_id', 'bookmark_id'])


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'bookmarks.bookmark': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Bookmark'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'related_name': "'bookmarks'", 'null': 'True', 'blank': 'True', 'to': "orm['bookmarks.BookmarkCategory']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128'}),
            'sound': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sounds.Sound']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'bookmarks.bookmarkcategory': {
            'Meta': {'object_name': 'BookmarkCategory'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'comments.comment': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Comment'},
            'comment': ('django.db.models.fields.TextField', [], {}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'related_name': "'replies'", 'null': 'True', 'blank': 'True', 'to': "orm['comments.Comment']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'favorites.favorite': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'Favorite'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'geotags.geotag': {
            'Meta': {'object_name': 'GeoTag'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lat': ('django.db.models.fields.FloatField', [], {'db_index': 'True'}),
            'lon': ('django.db.models.fields.FloatField', [], {'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'zoom': ('django.db.models.fields.IntegerField', [], {})
        },
        'ratings.rating': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'Rating'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'rating': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'sounds.license': {
            'Meta': {'ordering': "['order']", 'object_name': 'License'},
            'abbreviation': ('django.db.models.fields.CharField', [], {'max_length': '8', 'db_index': 'True'}),
            'deed_url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'legal_code_url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '512'}),
            'order': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'summary': ('django.db.models.fields.TextField', [], {})
        },
        'sounds.pack': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'name'),)", 'object_name': 'Pack'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_dirty': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'num_downloads': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'sounds.sound': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Sound'},
            'analysis_state': ('django.db.models.fields.CharField', [], {'default': "'PE'", 'max_length': '2', 'db_index': 'True'}),
            'avg_rating': ('django.db.models.fields.FloatField', [], {'default': '0'}),
            'base_filename_slug': ('django.db.models.fields.CharField', [], {'default': 'None', 'max_length': '512', 'null': 'True', 'blank': 'True'}),
            'bitdepth': ('django.db.models.fields.IntegerField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'bitrate': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'channels': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'date_recorded': ('django.db.models.fields.DateField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'duration': ('django.db.models.fields.FloatField', [], {'default': '0'}),
            'filesize': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'geotag': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['geotags.GeoTag']", 'null': 'True', 'blank': 'True'}),
            'has_bad_description': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_index_dirty': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'license': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sounds.License']"}),
            'md5': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'moderation_date': ('django.db.models.fields.DateTimeField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'moderation_note': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'moderation_state': ('django.db.models.fields.CharField', [], {'default': "'PE'", 'max_length': '2', 'db_index': 'True'}),
            'num_comments': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'num_downloads': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'num_ratings': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'original_filename': ('django.db.models.fields.CharField', [], {'max_length': '512'}),
            'original_path': ('django.db.models.fields.CharField', [], {'default': 'None', 'max_length': '512', 'null': 'True', 'blank': 'True'}),
            'pack': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['sounds.Pack']", 'null': 'True', 'blank': 'True'}),
            'processing_date': ('django.db.models.fields.DateTimeField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'processing_log': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'processing_state': ('django.db.models.fields.CharField', [], {'default': "'PE'", 'max_length': '2', 'db_index': 'True'}),
            'samplerate': ('django.db.models.fields.FloatField', [], {'default': '0'}),
            'similarity_state': ('django.db.models.fields.CharField', [], {'default': "'PE'", 'max_length': '2', 'db_index': 'True'}),
            'sources': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'remixes'", 'blank': 'True', 'to': "orm['sounds.Sound']"}),
            'type': ('django.db.models.fields.CharField', [], {'max_length': '4', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'sounds'", 'to': "orm['auth.User']"})
        },
        'tags.tag': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '100', 'db_index': 'True'})
        },
        'tags.taggeditem': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('tag', 'content_type', 'object_id'),)", 'object_name': 'TaggedItem'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'tag': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['tags.Tag']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        }
    }

    complete_apps = ['bookmarks']

########NEW FILE########
__FILENAME__ = models
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.contrib.auth.models import User
from sounds.models import Sound
from django.db import models

class BookmarkCategory(models.Model):
    user = models.ForeignKey(User)
    name = models.CharField(max_length=128, default ="")
    
    def __unicode__(self):
        return u"%s" % (self.name)

class Bookmark(models.Model):
    user = models.ForeignKey(User)
    name = models.CharField(max_length=128, default="")
    category = models.ForeignKey(BookmarkCategory, blank = True, null = True, default = None, related_name='bookmarks')
    sound = models.ForeignKey(Sound)
    created = models.DateTimeField(db_index = True, auto_now_add = True)
    
    def __unicode__(self):
        return u"Bookmark: %s" % (self.name)
    
    class Meta:
        ordering = ("-created", )



########NEW FILE########
__FILENAME__ = views
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.shortcuts import render_to_response, get_object_or_404
from django.template import RequestContext
from django.contrib.auth.models import User
from sounds.models import Sound
from bookmarks.models import *
from bookmarks.forms import BookmarkCategoryForm, BookmarkForm
from django.http import HttpResponseRedirect
from django.contrib.auth.decorators import login_required
from django.views.decorators.csrf import csrf_exempt
from django.core.urlresolvers import reverse
from datetime import datetime
from django.contrib import messages
from utils.pagination import paginate
from utils.functional import combine_dicts
from django.http import HttpResponse
import json

def bookmarks(request, username, category_id = None):
    
    user = get_object_or_404(User, username__iexact=username)
    is_owner = request.user.is_authenticated and user == request.user
    
    '''
    if is_owner and request.POST and "create_cat" in request.POST:
        form_bookmark_category = BookmarkCategoryForm(request.POST, instance=BookmarkCategory(user=user))
        if form_bookmark_category.is_valid():
            form_bookmark_category.save()
        
        form_bookmark_category = BookmarkCategoryForm()
        
    form_bookmark_category = BookmarkCategoryForm()
    '''    
    
    n_uncat = Bookmark.objects.select_related("sound").filter(user=user,category=None).count()
    
    if not category_id:
        bookmarked_sounds = Bookmark.objects.select_related("sound").filter(user=user,category=None)
    else:
        category = get_object_or_404(BookmarkCategory,id=category_id,user=user)
        bookmarked_sounds = category.bookmarks.select_related("sound").all()
    
    bookmark_categories = BookmarkCategory.objects.filter(user=user)
    
    return render_to_response('bookmarks/bookmarks.html', combine_dicts(locals(),paginate(request, bookmarked_sounds, 30)), context_instance=RequestContext(request))

@login_required
def delete_bookmark_category(request, category_id):
    
    category = get_object_or_404(BookmarkCategory,id=category_id, user=request.user)
    msg = "Deleted bookmark category \"" + category.name + "\"."
    category.delete()
    messages.add_message(request, messages.WARNING, msg)
    
    next = request.GET.get("next","")
    if next:
        return HttpResponseRedirect(next)
    else:
        return HttpResponseRedirect(reverse("bookmarks-for-user", args=[request.user.username]))

@login_required
def add_bookmark(request, sound_id):
    sound = get_object_or_404(Sound, id=sound_id)

    if request.POST:
        form = BookmarkForm(request.POST, instance=Bookmark(user=request.user, sound=sound))
        form.fields['category'].queryset = BookmarkCategory.objects.filter(user=request.user)
        if form.is_valid():
            form.save()

    if request.is_ajax():
        return HttpResponse()

    else:
        msg = "Added new bookmark for sound \"" + sound.original_filename + "\"."
        messages.add_message(request, messages.WARNING, msg)
        
        next = request.GET.get("next","")
        if next:
            return HttpResponseRedirect(next)
        else:
            return HttpResponseRedirect(reverse("sound", args=[sound.user.username, sound.id]))


@login_required
def delete_bookmark(request, bookmark_id):
    
    bookmark = get_object_or_404(Bookmark,id=bookmark_id, user=request.user)
    msg = "Deleted bookmark for sound \"" + bookmark.sound.original_filename + "\"."
    bookmark.delete()
    messages.add_message(request, messages.WARNING, msg)
    
    next = request.GET.get("next","")
    if next:
        return HttpResponseRedirect(next)
    else:
        return HttpResponseRedirect(reverse("bookmarks-for-user", args=[request.user.username]))

@login_required       
def get_form_for_sound(request, sound_id):
    sound = Sound.objects.get(id=sound_id)
    form = BookmarkForm(instance = Bookmark(name=sound.original_filename), prefix = sound.id)
    form.fields['category'].queryset = BookmarkCategory.objects.filter(user=request.user)
    categories_already_containing_sound = BookmarkCategory.objects.filter(user=request.user, bookmarks__sound=sound).distinct()
    add_bookmark_url = '/'.join(reverse('add-bookmark', args=[sound_id]).split('/')[:-2]) + '/'
    add_bookmark_url = '/'.join(request.build_absolute_uri(reverse('add-bookmark', args=[sound_id])).split('/')[:-2]) + '/'

    data_dict = {
        'bookmarks': Bookmark.objects.filter(user=request.user,sound=sound).count() != 0,
        'sound_id':sound.id,
        'form':form,
        'categories_aready_containing_sound':categories_already_containing_sound,
        'add_bookmark_url': add_bookmark_url
    }
    template = 'bookmarks/bookmark_form.html'
    return render_to_response(template, data_dict, context_instance = RequestContext(request))

########NEW FILE########
__FILENAME__ = admin
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.contrib import admin
from comments.models import Comment

class CommentAdmin(admin.ModelAdmin):
    raw_id_fields = ('user', 'parent') 
    list_display = ('user', 'content_type', 'object_id', 'created')
    search_fields = ('comment', )

admin.site.register(Comment, CommentAdmin)
########NEW FILE########
__FILENAME__ = forms
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django import forms
from utils.forms import HtmlCleaningCharField
from utils.spam import is_spam

class CommentForm(forms.Form):
    comment = HtmlCleaningCharField(widget=forms.Textarea)
    
    def __init__(self, request, *args, **kwargs):
        self.request = request
        super(CommentForm, self).__init__(*args, **kwargs)
    
    def clean_comment(self):
        comment = self.cleaned_data['comment']

        if is_spam(self.request, comment):
            raise forms.ValidationError("Your comment was considered spam, please edit and repost. If it keeps failing please contact the admins.")
        
        return comment

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'Comment'
        db.create_table('comments_comment', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'])),
            ('content_type', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['contenttypes.ContentType'])),
            ('object_id', self.gf('django.db.models.fields.PositiveIntegerField')(db_index=True)),
            ('comment', self.gf('django.db.models.fields.TextField')()),
            ('parent', self.gf('django.db.models.fields.related.ForeignKey')(default=None, related_name='replies', null=True, blank=True, to=orm['comments.Comment'])),
            ('created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, db_index=True, blank=True)),
        ))
        db.send_create_signal('comments', ['Comment'])


    def backwards(self, orm):
        
        # Deleting model 'Comment'
        db.delete_table('comments_comment')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'comments.comment': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Comment'},
            'comment': ('django.db.models.fields.TextField', [], {}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'related_name': "'replies'", 'null': 'True', 'blank': 'True', 'to': "orm['comments.Comment']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['comments']

########NEW FILE########
__FILENAME__ = models
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.contrib.auth.models import User
from django.contrib.contenttypes import generic
from django.contrib.contenttypes.models import ContentType
from django.db import models

class Comment(models.Model):
    user = models.ForeignKey(User)

    content_type = models.ForeignKey(ContentType)
    object_id = models.PositiveIntegerField(db_index=True)
    content_object = generic.GenericForeignKey()

    comment = models.TextField()

    parent = models.ForeignKey('self', null=True, blank=True, related_name='replies', default=None) 

    created = models.DateTimeField(db_index=True, auto_now_add=True)
    
    def __unicode__(self):
        return u"%s comment on %s - %s" % (self.user, self.content_type, self.content_type)
    
    class Meta:
        ordering = ('-created', )
########NEW FILE########
__FILENAME__ = urls
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.conf.urls.defaults import patterns, url
import comments.views as comments

urlpatterns = patterns('',
    url(r'^delete/(?P<comment_id>\d+)/$', comments.delete, name="comment-delete"),
)
########NEW FILE########
__FILENAME__ = views
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from comments.models import Comment
from django.conf import settings
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.contrib.auth.models import User
from django.contrib.contenttypes.models import ContentType
from django.core.exceptions import PermissionDenied
from django.http import HttpResponseRedirect
from django.shortcuts import get_object_or_404, render_to_response
from django.template.context import RequestContext
from sounds.models import Sound
from utils.functional import combine_dicts
from utils.pagination import paginate

@login_required
def delete(request, comment_id):

    comment = get_object_or_404(Comment, id=comment_id)

    if not (request.user.has_perm('comments.delete_comment') \
            or (comment.content_object.user == request.user \
                if comment.content_object and hasattr(comment.content_object, 'user') \
                else False)):
        raise PermissionDenied

    comment.delete()
    messages.success(request, 'Comment deleted.')

    if comment.content_type == ContentType.objects.get_for_model(Sound):
        sound = comment.content_object
        sound.num_comments = sound.num_comments - 1
        sound.save()

    return HttpResponseRedirect(sound.get_absolute_url())

def for_user(request, username):
    """ This is all very hacky because GenericRelations don't allow you to span
    relations with select_related... hence we get the content_objects and then
    load all the sounds related to those in a big lookup. If we don't do this
    the page generates about 90+ queries, with it we only generate 4 queries :-) """
    user = get_object_or_404(User, username__iexact=username)
    sound_type = ContentType.objects.get_for_model(Sound)
    qs = Comment.objects.filter(content_type=sound_type, sound__user=user).select_related("user", "user__profile")
    paginator_obj = paginate(request, qs, 30)
    comments = paginator_obj["page"].object_list
    sound_ids = set([comment.object_id for comment in comments])
    sound_lookup = dict([(sound.id, sound) for sound in list(Sound.objects.filter(id__in=sound_ids))])
    for comment in comments:
        comment.sound_object = sound_lookup[comment.object_id]
    return render_to_response('sounds/comments_for_user.html', combine_dicts(paginator_obj, locals()), context_instance=RequestContext(request))

def all(request):
    """ This is all very hacky because GenericRelations don't allow you to span
    relations with select_related... hence we get the content_objects and then
    load all the sounds related to those in a big lookup. If we don't do this
    the page generates about 90+ queries, with it we only generate 4 queries :-) """
    sound_type = ContentType.objects.get_for_model(Sound)
    qs = Comment.objects.filter(content_type=sound_type).select_related("user", "user__profile")
    paginator_obj = paginate(request, qs, 30)
    comments = paginator_obj["page"].object_list
    sound_ids = set([comment.object_id for comment in comments])
    sound_lookup = dict([(sound.id, sound) for sound in list(Sound.objects.filter(id__in=sound_ids).select_related("user"))])
    for comment in comments:
        comment.sound_object = sound_lookup[comment.object_id]
    return render_to_response('sounds/comments.html', combine_dicts(paginator_obj, locals()), context_instance=RequestContext(request))
########NEW FILE########
__FILENAME__ = context_processor
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.conf import settings

def context_extra(request):
    return {'media_url': settings.MEDIA_URL,
            'request': request,
            'GOOGLE_API_KEY': settings.GOOGLE_API_KEY,
            'last_restart_date': settings.LAST_RESTART_DATE
    }

########NEW FILE########
__FILENAME__ = admin
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.contrib import admin
from favorites.models import Favorite

class FavoriteAdmin(admin.ModelAdmin):
    raw_id_fields = ('user',) 
    list_display = ('user', 'content_type', 'object_id', 'created')

admin.site.register(Favorite, FavoriteAdmin)
########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'Favorite'
        db.create_table('favorites_favorite', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'])),
            ('content_type', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['contenttypes.ContentType'])),
            ('object_id', self.gf('django.db.models.fields.PositiveIntegerField')(db_index=True)),
            ('created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, db_index=True, blank=True)),
        ))
        db.send_create_signal('favorites', ['Favorite'])

        # Adding unique constraint on 'Favorite', fields ['user', 'content_type', 'object_id']
        db.create_unique('favorites_favorite', ['user_id', 'content_type_id', 'object_id'])


    def backwards(self, orm):
        
        # Removing unique constraint on 'Favorite', fields ['user', 'content_type', 'object_id']
        db.delete_unique('favorites_favorite', ['user_id', 'content_type_id', 'object_id'])

        # Deleting model 'Favorite'
        db.delete_table('favorites_favorite')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'favorites.favorite': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'Favorite'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        }
    }

    complete_apps = ['favorites']

########NEW FILE########
__FILENAME__ = models
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.contrib.auth.models import User
from django.contrib.contenttypes import generic
from django.contrib.contenttypes.models import ContentType
from django.db import models

class Favorite(models.Model):
    user = models.ForeignKey(User)

    content_type = models.ForeignKey(ContentType)
    object_id = models.PositiveIntegerField(db_index=True)
    content_object = generic.GenericForeignKey()

    created = models.DateTimeField(db_index=True, auto_now_add=True)
    
    def __unicode__(self):
        return u"%s favorites %s - %s" % (self.user, self.content_type, self.content_type)
    
    class Meta:
        unique_together = (('user', 'content_type', 'object_id'),)
        ordering = ("-created", )
########NEW FILE########
__FILENAME__ = views

########NEW FILE########
__FILENAME__ = admin
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.contrib import admin
from forum.models import Forum, Thread, Post

class ForumAdmin(admin.ModelAdmin):
    raw_id_fields = ('last_post', )
    list_display = ('name', 'num_threads', 'change_order')

admin.site.register(Forum, ForumAdmin)


class ThreadAdmin(admin.ModelAdmin):
    raw_id_fields = ('author', 'last_post','first_post' )
    list_display = ('forum', 'author', 'title', 'status', 'num_posts', 'created')
    list_filters = ('status',)
    search_fields = ('=author__username', "title")

admin.site.register(Thread, ThreadAdmin)


class PostAdmin(admin.ModelAdmin):
    raw_id_fields = ('author', 'thread')
    list_display = ('thread', 'author', 'created')
    search_fields = ('=author__username', "body")

admin.site.register(Post, PostAdmin)

########NEW FILE########
__FILENAME__ = forms
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django import forms
from utils.forms import HtmlCleaningCharField
from utils.spam import is_spam

class PostReplyForm(forms.Form):
    body = HtmlCleaningCharField(widget=forms.Textarea(attrs=dict(cols=100, rows=20)))
    subscribe = forms.BooleanField(help_text="Send me an email notification when new posts are added in this thread.", required=False, initial=True)
    def __init__(self, request, quote, *args, **kwargs):
        self.request = request
        self.quote = quote
        super(PostReplyForm, self).__init__(*args, **kwargs)

    def clean_body(self):
        body = self.cleaned_data['body']

        if self.quote and body.strip() == self.quote:
            raise forms.ValidationError("You should type something...")

        if is_spam(self.request, body):
            raise forms.ValidationError("Your post was considered spam, please edit and repost. If it keeps failing please contact the admins.")

        return body

class NewThreadForm(forms.Form):
    title = forms.CharField()
    body = HtmlCleaningCharField(widget=forms.Textarea(attrs=dict(cols=100, rows=30)))
    subscribe = forms.BooleanField(help_text="Send me an email notification when new posts are added in this thread.", required=False, initial=True)


MODERATION_CHOICES = [(x,x) for x in\
    ['Approve',
     'Delete User']]

class PostModerationForm(forms.Form):
    action      = forms.ChoiceField(choices=MODERATION_CHOICES,
                                    required=True,
                                    widget=forms.RadioSelect(),
                                    label='')
    post      = forms.IntegerField(widget=forms.widgets.HiddenInput)
########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'Forum'
        db.create_table('forum_forum', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('order', self.gf('django.db.models.fields.PositiveIntegerField')()),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=50)),
            ('name_slug', self.gf('django.db.models.fields.CharField')(unique=True, max_length=50, db_index=True)),
            ('description', self.gf('django.db.models.fields.CharField')(max_length=250)),
            ('num_threads', self.gf('django.db.models.fields.PositiveIntegerField')(default=0)),
            ('num_posts', self.gf('django.db.models.fields.PositiveIntegerField')(default=0)),
            ('last_post', self.gf('django.db.models.fields.related.OneToOneField')(related_name='latest_in_forum', null=True, default=None, to=orm['forum.Post'], blank=True, unique=True)),
        ))
        db.send_create_signal('forum', ['Forum'])

        # Adding model 'Thread'
        db.create_table('forum_thread', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('forum', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['forum.Forum'])),
            ('author', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'])),
            ('title', self.gf('django.db.models.fields.CharField')(max_length=250)),
            ('status', self.gf('django.db.models.fields.PositiveSmallIntegerField')(default=1)),
            ('num_posts', self.gf('django.db.models.fields.PositiveIntegerField')(default=0)),
            ('last_post', self.gf('django.db.models.fields.related.OneToOneField')(related_name='latest_in_thread', null=True, default=None, to=orm['forum.Post'], blank=True, unique=True)),
            ('created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, db_index=True, blank=True)),
        ))
        db.send_create_signal('forum', ['Thread'])

        # Adding model 'Post'
        db.create_table('forum_post', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('thread', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['forum.Thread'])),
            ('author', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'])),
            ('body', self.gf('django.db.models.fields.TextField')()),
            ('created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, db_index=True, blank=True)),
            ('modified', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
        ))
        db.send_create_signal('forum', ['Post'])

        # Adding model 'Subscription'
        db.create_table('forum_subscription', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('subscriber', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'])),
            ('thread', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['forum.Thread'])),
            ('is_active', self.gf('django.db.models.fields.BooleanField')(default=True, db_index=True)),
        ))
        db.send_create_signal('forum', ['Subscription'])

        # Adding unique constraint on 'Subscription', fields ['subscriber', 'thread']
        db.create_unique('forum_subscription', ['subscriber_id', 'thread_id'])


    def backwards(self, orm):
        
        # Removing unique constraint on 'Subscription', fields ['subscriber', 'thread']
        db.delete_unique('forum_subscription', ['subscriber_id', 'thread_id'])

        # Deleting model 'Forum'
        db.delete_table('forum_forum')

        # Deleting model 'Thread'
        db.delete_table('forum_thread')

        # Deleting model 'Post'
        db.delete_table('forum_post')

        # Deleting model 'Subscription'
        db.delete_table('forum_subscription')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'forum.forum': {
            'Meta': {'ordering': "['order']", 'object_name': 'Forum'},
            'description': ('django.db.models.fields.CharField', [], {'max_length': '250'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_post': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'latest_in_forum'", 'null': 'True', 'default': 'None', 'to': "orm['forum.Post']", 'blank': 'True', 'unique': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'}),
            'name_slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '50', 'db_index': 'True'}),
            'num_posts': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'num_threads': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'order': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'forum.post': {
            'Meta': {'ordering': "('created',)", 'object_name': 'Post'},
            'author': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'body': ('django.db.models.fields.TextField', [], {}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'thread': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['forum.Thread']"})
        },
        'forum.subscription': {
            'Meta': {'unique_together': "(('subscriber', 'thread'),)", 'object_name': 'Subscription'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'db_index': 'True'}),
            'subscriber': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'thread': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['forum.Thread']"})
        },
        'forum.thread': {
            'Meta': {'ordering': "('-status', '-last_post__created')", 'object_name': 'Thread'},
            'author': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'forum': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['forum.Forum']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_post': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'latest_in_thread'", 'null': 'True', 'default': 'None', 'to': "orm['forum.Post']", 'blank': 'True', 'unique': 'True'}),
            'num_posts': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'status': ('django.db.models.fields.PositiveSmallIntegerField', [], {'default': '1'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '250'})
        }
    }

    complete_apps = ['forum']

########NEW FILE########
__FILENAME__ = 0002_auto
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding index on 'Thread', fields ['status']
        db.create_index('forum_thread', ['status'])


    def backwards(self, orm):
        
        # Removing index on 'Thread', fields ['status']
        db.delete_index('forum_thread', ['status'])


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'forum.forum': {
            'Meta': {'ordering': "['order']", 'object_name': 'Forum'},
            'description': ('django.db.models.fields.CharField', [], {'max_length': '250'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_post': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'latest_in_forum'", 'null': 'True', 'default': 'None', 'to': "orm['forum.Post']", 'blank': 'True', 'unique': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'}),
            'name_slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '50', 'db_index': 'True'}),
            'num_posts': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'num_threads': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'order': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'forum.post': {
            'Meta': {'ordering': "('created',)", 'object_name': 'Post'},
            'author': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'body': ('django.db.models.fields.TextField', [], {}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'thread': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['forum.Thread']"})
        },
        'forum.subscription': {
            'Meta': {'unique_together': "(('subscriber', 'thread'),)", 'object_name': 'Subscription'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'db_index': 'True'}),
            'subscriber': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'thread': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['forum.Thread']"})
        },
        'forum.thread': {
            'Meta': {'ordering': "('-status', '-last_post__created')", 'object_name': 'Thread'},
            'author': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'forum': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['forum.Forum']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_post': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'latest_in_thread'", 'null': 'True', 'default': 'None', 'to': "orm['forum.Post']", 'blank': 'True', 'unique': 'True'}),
            'num_posts': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'status': ('django.db.models.fields.PositiveSmallIntegerField', [], {'default': '1', 'db_index': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '250'})
        }
    }

    complete_apps = ['forum']

########NEW FILE########
__FILENAME__ = 0003_auto__add_field_post_moderation_state
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'Post.moderation_state'
        db.add_column('forum_post', 'moderation_state', self.gf('django.db.models.fields.CharField')(default='OK', max_length=2, db_index=True), keep_default=False)


    def backwards(self, orm):
        
        # Deleting field 'Post.moderation_state'
        db.delete_column('forum_post', 'moderation_state')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'forum.forum': {
            'Meta': {'ordering': "['order']", 'object_name': 'Forum'},
            'description': ('django.db.models.fields.CharField', [], {'max_length': '250'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_post': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'latest_in_forum'", 'null': 'True', 'default': 'None', 'to': "orm['forum.Post']", 'blank': 'True', 'unique': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'}),
            'name_slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '50', 'db_index': 'True'}),
            'num_posts': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'num_threads': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'order': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'forum.post': {
            'Meta': {'ordering': "('created',)", 'object_name': 'Post'},
            'author': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'body': ('django.db.models.fields.TextField', [], {}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'moderation_state': ('django.db.models.fields.CharField', [], {'default': "'OK'", 'max_length': '2', 'db_index': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'thread': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['forum.Thread']"})
        },
        'forum.subscription': {
            'Meta': {'unique_together': "(('subscriber', 'thread'),)", 'object_name': 'Subscription'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'db_index': 'True'}),
            'subscriber': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'thread': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['forum.Thread']"})
        },
        'forum.thread': {
            'Meta': {'ordering': "('-status', '-last_post__created')", 'object_name': 'Thread'},
            'author': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'forum': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['forum.Forum']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_post': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'latest_in_thread'", 'null': 'True', 'default': 'None', 'to': "orm['forum.Post']", 'blank': 'True', 'unique': 'True'}),
            'num_posts': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'status': ('django.db.models.fields.PositiveSmallIntegerField', [], {'default': '1', 'db_index': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '250'})
        }
    }

    complete_apps = ['forum']

########NEW FILE########
__FILENAME__ = 0004_auto__add_field_thread_first_post
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'Thread.first_post'
        db.add_column('forum_thread', 'first_post', self.gf('django.db.models.fields.related.OneToOneField')(related_name='first_in_thread', null=True, default=None, to=orm['forum.Post'], blank=True, unique=True), keep_default=False)


    def backwards(self, orm):
        
        # Deleting field 'Thread.first_post'
        db.delete_column('forum_thread', 'first_post_id')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'forum.forum': {
            'Meta': {'ordering': "['order']", 'object_name': 'Forum'},
            'description': ('django.db.models.fields.CharField', [], {'max_length': '250'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_post': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'latest_in_forum'", 'null': 'True', 'default': 'None', 'to': "orm['forum.Post']", 'blank': 'True', 'unique': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'}),
            'name_slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '50', 'db_index': 'True'}),
            'num_posts': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'num_threads': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'order': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'forum.post': {
            'Meta': {'ordering': "('created',)", 'object_name': 'Post'},
            'author': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'body': ('django.db.models.fields.TextField', [], {}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'moderation_state': ('django.db.models.fields.CharField', [], {'default': "'OK'", 'max_length': '2', 'db_index': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'thread': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['forum.Thread']"})
        },
        'forum.subscription': {
            'Meta': {'unique_together': "(('subscriber', 'thread'),)", 'object_name': 'Subscription'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'db_index': 'True'}),
            'subscriber': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'thread': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['forum.Thread']"})
        },
        'forum.thread': {
            'Meta': {'ordering': "('-status', '-last_post__created')", 'object_name': 'Thread'},
            'author': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'first_post': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'first_in_thread'", 'null': 'True', 'default': 'None', 'to': "orm['forum.Post']", 'blank': 'True', 'unique': 'True'}),
            'forum': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['forum.Forum']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_post': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'latest_in_thread'", 'null': 'True', 'default': 'None', 'to': "orm['forum.Post']", 'blank': 'True', 'unique': 'True'}),
            'num_posts': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'status': ('django.db.models.fields.PositiveSmallIntegerField', [], {'default': '1', 'db_index': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '250'})
        }
    }

    complete_apps = ['forum']

########NEW FILE########
__FILENAME__ = models
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.contrib.auth.models import User
from django.db import models
from django.utils.encoding import smart_unicode
from general.models import OrderedModel
from django.db.models.signals import post_delete, pre_delete
from django.dispatch import receiver
from utils.cache import invalidate_template_cache
from django.utils.translation import ugettext as _
import logging

logger = logging.getLogger('web')

class Forum(OrderedModel):

    name = models.CharField(max_length=50)
    name_slug = models.CharField(max_length=50, unique=True, db_index=True)
    description = models.CharField(max_length=250)

    num_threads = models.PositiveIntegerField(default=0)
    num_posts = models.PositiveIntegerField(default=0)

    last_post = models.OneToOneField('Post', null=True, blank=True, default=None,
                                     related_name="latest_in_forum",
                                     on_delete=models.SET_NULL)

    def set_last_post(self):
        qs = Post.objects.filter(thread__forum=self,moderation_state ='OK')
#        if exclude_post:
#            qs = qs.exclude(id=exclude_post.id)
#        if exclude_thread:
#            qs = qs.exclude(thread=exclude_thread)
        qs = qs.order_by('-created')
        if qs.count() > 0:
            self.last_post = qs[0]
            self.save()

    def __unicode__(self):
        return self.name

    @models.permalink
    def get_absolute_url(self):
        return ("forums-forum", (smart_unicode(self.name_slug),))

    def get_last_post(self):
        return Post.objects.filter(thread__forum=self,moderation_state ='OK').order_by("-created")[0]


class Thread(models.Model):
    forum = models.ForeignKey(Forum)
    author = models.ForeignKey(User)
    title = models.CharField(max_length=250)

    THREAD_STATUS_CHOICES = (
        (0, "Sunk"),
        (1, "Regular"),
        (2, "Sticky"),
    )
    status = models.PositiveSmallIntegerField(choices=THREAD_STATUS_CHOICES, default=1, db_index=True)

    num_posts = models.PositiveIntegerField(default=0)
    last_post = models.OneToOneField('Post', null=True, blank=True, default=None,
                                     related_name="latest_in_thread",
                                     on_delete=models.SET_NULL)
    first_post = models.OneToOneField('Post', null=True, blank=True, default=None,
                                     related_name="first_in_thread",
                                     on_delete=models.SET_NULL)

    created = models.DateTimeField(db_index=True, auto_now_add=True)

    def set_last_post(self):
        qs = Post.objects.filter(thread=self).order_by('-created')
        if qs.count() > 0:
            self.last_post = qs[0]
            self.save()
            try:
                self.forum.set_last_post()
            except Forum.DoesNotExist:
                pass
        else:
            self.delete()

    @models.permalink
    def get_absolute_url(self):
        return ("forums-thread", (smart_unicode(self.forum.name_slug), self.id))

    class Meta:
        ordering = ('-status', '-last_post__created')

    def __unicode__(self):
        return self.title


@receiver(post_delete, sender=Thread)
def update_last_post_on_thread_delete(**kwargs):
    thread = kwargs['instance']
    try:
        thread.forum.set_last_post()
    except Forum.DoesNotExist:
        pass


class Post(models.Model):
    thread = models.ForeignKey(Thread)
    author = models.ForeignKey(User)
    body = models.TextField()

    created = models.DateTimeField(db_index=True, auto_now_add=True)
    modified = models.DateTimeField(auto_now=True)

    MODERATION_STATE_CHOICES = (
        ("NM",_('NEEDS_MODERATION')),
        ("OK",_('OK')),
        )
    moderation_state = models.CharField(db_index=True, max_length=2, choices=MODERATION_STATE_CHOICES, default="OK")

    class Meta:
        ordering = ('created',)
        permissions = (
            ("can_moderate_forum", "Can moderate posts."),
            )

    def __unicode__(self):
        return u"Post by %s in %s" % (self.author, self.thread)

    @models.permalink
    def get_absolute_url(self):
        return ("forums-post", (smart_unicode(self.thread.forum.name_slug), self.thread.id, self.id))


@receiver(post_delete, sender=Post)
def update_last_post_on_post_delete(**kwargs):
    post = kwargs['instance']
    try:
        post.thread.set_last_post()
    except Thread.DoesNotExist:
        # This happens when the thread has already been deleted, for example
        # when a user is deleted through the admin interface. We don't need
        # to update the thread, but it would be nice to get to the forum object
        # somehow and update that one....
        logger.info('Tried setting last posts for thread and forum, but the thread has already been deleted?')
    invalidate_template_cache('latest_posts')


class Subscription(models.Model):
    subscriber = models.ForeignKey(User)
    thread = models.ForeignKey(Thread)
    is_active = models.BooleanField(db_index=True, default=True)

    class Meta:
        unique_together = ("subscriber", "thread")

    def __unicode__(self):
        return u"%s subscribed to %s" % (self.subscriber, self.thread)

########NEW FILE########
__FILENAME__ = display_forum_result
'''
Created on Jul 1, 2011

@author: stelios
'''
from __future__ import absolute_import
from django import template

register = template.Library()

# TODO: do we need takes_context???
@register.inclusion_tag('forum/display_forum_result.html', takes_context=True)
def display_forum_result(context, post, highlight):
    results = []
    for thd in post:
        # highlight is dict, so not ordered. below we much results to highlighted results
        # TODO: find an efficient way to do this... maybe try except keyerror will be faster
        posts = []
        first_doc = thd['doclist']['docs']
        for p in first_doc:
            # highlighted result
            if str(p['id']) in highlight:
                posts.append({'post_id': p['id'],
                             'post_body': highlight[str(p['id'])]['post_body'][0],
                             'post_info': ' - '.join(['Post by: ' + p['post_author'],
                                                      'Date: ' + str(p['post_created'])])})
            else:
                posts.append({'post_id': p['id'],
                             'post_body': p['post_body'],
                             'post_info': ' - '.join(['Post by: ' + p['post_author'],
                                                      'Date: ' + str(p['post_created'])])})

        results.append({
                        'thread_id': first_doc[0]['thread_id'],
                        'thread_title': first_doc[0]['thread_title'],
                        'forum_name': first_doc[0]['forum_name'],
                        'forum_name_slug': first_doc[0]['forum_name_slug'],
                        'post_id': first_doc[0]['id'],
                        'posts': posts,
                        'thread_info': ' - '.join(['Forum: ' + first_doc[0]['forum_name'],
                                                   'Thread by: ' + first_doc[0]['thread_author'],
                                                   'Posts: ' + str(first_doc[0]['num_posts']),
                                                   'Date: ' + str(first_doc[0]['thread_created'])]),
                        })

    return { 'results': results }

########NEW FILE########
__FILENAME__ = smileys
from django import template
from django.conf import settings
import re

register = template.Library()

mapping = """8-) 8) cool
:'( cry
:D :-D grin
=) happy
:-| :| neutral
:( :-( sad
:) :-) smile
:P :-P tongue
:S :-S weird
;) ;-) wink
:O :-O woot"""

d = []
for emoticons, name in map(lambda x: (x[:-1], x[-1]), [x.split() for x in mapping.lower().split("\n")]):
    for emoticon in emoticons:
        d.append((emoticon,name))

emoticons = dict(d)

def smiley_replace(matchobj):
    try:
        expression = emoticons[matchobj.group(0).lower()]
        return "<img src=\"%simages/smileys/%s.png\" alt=\"%s\" class=\"smiley\" />" % (settings.MEDIA_URL, expression, expression)
    except KeyError:
        return matchobj.group(0)

smiley_replacer = re.compile("=\)|;\-?\)|8\-?\)|:'\(|:\-?[OoPpSsDd\)\(\|]")

@register.filter
def smileys(string):
    return smiley_replacer.sub(smiley_replace, string)
smileys.is_safe = True
########NEW FILE########
__FILENAME__ = urls
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.conf.urls.defaults import patterns, url
import forum.views as forum
from search.views import search_forum

urlpatterns = patterns('forum.views',
    url(r'^$', forum.forums, name='forums-forums'),
    url(r'^moderate/$', forum.moderate_posts, name="forums-moderate"),
    url(r'^forums-search/$', search_forum, name="forums-search"),
    url(r'^latest_posts/$', forum.latest_posts, name="forums-latest-posts"),
    url(r'^(?P<forum_name_slug>[\w\-]+)/$', forum.forum, name="forums-forum"),
    url(r'^(?P<forum_name_slug>[\w\-]+)/new-thread/$', forum.new_thread, name="forums-new-thread"),
    url(r'^(?P<forum_name_slug>[\w-]+)/(?P<thread_id>\d+)/$', forum.thread, name="forums-thread"),
    url(r'^(?P<forum_name_slug>[\w-]+)/(?P<thread_id>\d+)/unsubscribe/$', forum.unsubscribe_from_thread, name="forums-thread-unsubscribe"),
    url(r'^(?P<forum_name_slug>[\w-]+)/(?P<thread_id>\d+)/(?P<post_id>\d+)/$', forum.post, name="forums-post"),
    url(r'^(?P<forum_name_slug>[\w-]+)/(?P<thread_id>\d+)/reply/$', forum.reply, name="forums-reply"),
    url(r'^(?P<forum_name_slug>[\w-]+)/(?P<thread_id>\d+)/(?P<post_id>\d+)/reply/$', forum.reply, name="forums-reply-quote"),

    url(r'^post/(?P<post_id>\d+)/edit/$', forum.post_edit, name="forums-post-edit"),
    url(r'^post/(?P<post_id>\d+)/delete/$', forum.post_delete, name="forums-post-delete"),
    url(r'^post/(?P<post_id>\d+)/delete-confirm/$', forum.post_delete_confirm, name="forums-post-delete-confirm"),
)

########NEW FILE########
__FILENAME__ = views
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.conf import settings
from django.contrib.auth.decorators import login_required, permission_required
from django.core.paginator import Paginator, InvalidPage
from django.core.urlresolvers import reverse
from django.http import HttpResponseRedirect, Http404, \
    HttpResponsePermanentRedirect
from django.shortcuts import render_to_response, get_object_or_404
from django.template import RequestContext, loader
from forum.forms import PostReplyForm, NewThreadForm, PostModerationForm
from forum.models import Forum, Thread, Post, Subscription
from utils.functional import combine_dicts
from utils.mail import send_mail_template
from utils.pagination import paginate
from utils.search.search_forum import add_post_to_solr
import logging
import re
import datetime
from django.contrib import messages

logger = logging.getLogger("web")

def deactivate_spammer(user_id):
    from django.contrib.auth.models import User
    from django.contrib.sessions.models import Session
    user = User.objects.get(id=user_id)
    Post.objects.filter(author=user).delete()
    Thread.objects.filter(author=user).delete()
    [s.delete() for s in Session.objects.all() if s.get_decoded().get('_auth_user_id') == user.id]
    user.is_active = False
    user.save()


class last_action(object):
    def __init__(self, view_func):
        self.view_func = view_func
        self.__name__ = view_func.__name__
        self.__doc__ = view_func.__doc__
    
    def __call__(self, request, *args, **kwargs):
        
        if not request.user.is_authenticated():
            return self.view_func(request, *args, **kwargs)

        from datetime import datetime, timedelta
        date_format = "%Y-%m-%d %H:%M:%S:%f"
        date2string = lambda date: date.strftime(date_format)
        string2date = lambda date_string: datetime.strptime(date_string, date_format)
        
        key = "forum-last-visited"
        
        now = datetime.now()
        now_as_string = date2string(now)
        
        if key not in request.COOKIES or not request.session.get(key, False):
            request.session[key] = now_as_string
        elif now - string2date(request.COOKIES[key]) > timedelta(minutes=30):
            request.session[key] = request.COOKIES[key]
        
        request.last_action_time = string2date(request.session.get(key, now_as_string))
        
        reply_object = self.view_func(request, *args, **kwargs)
        
        reply_object.set_cookie(key, now_as_string, 60*60*24*30) # 30 days
        
        return reply_object
            

@last_action
def forums(request):
    forums = Forum.objects.select_related('last_post', 'last_post__author', 'last_post__thread').all()
    return render_to_response('forum/index.html', locals(), context_instance=RequestContext(request))


@last_action
def forum(request, forum_name_slug):
    try:
        forum = Forum.objects.get(name_slug=forum_name_slug)
    except Forum.DoesNotExist: #@UndefinedVariable
        raise Http404

    paginator = paginate(request, Thread.objects.filter(forum=forum, first_post__moderation_state="OK").select_related('last_post', 'last_post__author'), settings.FORUM_THREADS_PER_PAGE)

    return render_to_response('forum/threads.html', combine_dicts(locals(), paginator), context_instance=RequestContext(request))


@last_action
def thread(request, forum_name_slug, thread_id):
    forum = get_object_or_404(Forum, name_slug=forum_name_slug)
    thread = get_object_or_404(Thread, forum=forum, id=thread_id, first_post__moderation_state="OK")

    paginator = paginate(request, Post.objects.select_related('author', 'author__profile').filter(thread=thread, moderation_state="OK"), settings.FORUM_POSTS_PER_PAGE)

    # a logged in user watching a thread can activate his subscription to that thread!
    # we assume the user has seen the latest post if he is browsing the thread
    # this is not entirely correct, but should be close enough
    if request.user.is_authenticated():
        Subscription.objects.filter(thread=thread, subscriber=request.user, is_active=False).update(is_active=True)

    return render_to_response('forum/thread.html', combine_dicts(locals(), paginator), context_instance=RequestContext(request))

@last_action
def latest_posts(request):
    paginator = paginate(request, Post.objects.select_related('author', 'author__profile', 'thread', 'thread__forum').filter(moderation_state="OK").order_by('-created').all(), settings.FORUM_POSTS_PER_PAGE)
    hide_search = True
    return render_to_response('forum/latest_posts.html', combine_dicts(locals(), paginator), context_instance=RequestContext(request))


@last_action
def post(request, forum_name_slug, thread_id, post_id):
    post = get_object_or_404(Post, id=post_id, thread__id=thread_id, thread__forum__name_slug=forum_name_slug, moderation_state="OK")

    posts_before = Post.objects.filter(thread=post.thread, moderation_state="OK", created__lt=post.created).count()
    page = 1 + posts_before / settings.FORUM_POSTS_PER_PAGE
    url = post.thread.get_absolute_url() + "?page=%d#post%d" % (page, post.id)

    return HttpResponseRedirect(url)


@login_required
def reply(request, forum_name_slug, thread_id, post_id=None):
    forum = get_object_or_404(Forum, name_slug=forum_name_slug)
    thread = get_object_or_404(Thread, id=thread_id, forum=forum, first_post__moderation_state="OK")

    is_survey = False
    if thread.title == "Freesound Survey":
        is_survey = True
    survey_text = """
1) What do you use Freesound for? (what are your specific interests? what do you do with Freesound samples? ...)


2) Do you perceive some shared goals in Freesounds user community? If so, which ones? (is there a sense of community? and of long-term goals to be achieved? ...)


3) What kinds of sounds are you most interested in? (do you upload and/or download specific types of sounds? which ones? ...)


4) What makes Freesound different from other sound sharing sites? (you can compare with sites like Soundcloud, Looperman, CCMixter or others)
"""


    if post_id:
        post = get_object_or_404(Post, id=post_id, thread__id=thread_id, thread__forum__name_slug=forum_name_slug)
        quote = loader.render_to_string('forum/quote_style.html', {'post':post})
    else:
        post = None
        quote = ""
    
    latest_posts = Post.objects.select_related('author', 'author__profile', 'thread', 'thread__forum').order_by('-created').filter(thread=thread, moderation_state="OK")[0:15]
    user_can_post_in_forum = request.user.profile.can_post_in_forum()
    user_is_blocked_for_spam_reports = request.user.profile.is_blocked_for_spam_reports()

    if request.method == 'POST':
        form = PostReplyForm(request, quote, request.POST)

        if user_can_post_in_forum[0] and not user_is_blocked_for_spam_reports:
            if form.is_valid():
                if not request.user.post_set.all().count() and ("http://" in form.cleaned_data["body"] or "https://" in form.cleaned_data["body"]): # first post has urls
                    post = Post.objects.create(author=request.user, body=form.cleaned_data["body"], thread=thread, moderation_state="NM")
                    # DO NOT add the post to solr, only do it when it is moderated
                    set_to_moderation = True
                else:
                    post = Post.objects.create(author=request.user, body=form.cleaned_data["body"], thread=thread)
                    add_post_to_solr(post)
                    set_to_moderation = False

                if form.cleaned_data["subscribe"]:
                    subscription, created = Subscription.objects.get_or_create(thread=thread, subscriber=request.user)
                    if not subscription.is_active:
                        subscription.is_active = True
                        subscription.save()

                # figure out if there are active subscriptions in this thread
                emails_to_notify = []
                for subscription in Subscription.objects.filter(thread=thread, is_active=True).exclude(subscriber=request.user):
                    emails_to_notify.append(subscription.subscriber.email)
                    logger.info("NOTIFY %s" % subscription.subscriber.email)
                    subscription.is_active = False
                    subscription.save()

                if emails_to_notify:
                    send_mail_template(u"topic reply notification - " + thread.title, "forum/email_new_post_notification.txt", dict(post=post, thread=thread, forum=forum), email_from=None, email_to=emails_to_notify)

                if not set_to_moderation:
                    return HttpResponseRedirect(post.get_absolute_url())
                else:
                    messages.add_message(request, messages.INFO, "Your post won't be shown until it is manually approved by moderators")
                    return HttpResponseRedirect(post.thread.get_absolute_url())
    else:
        if quote:
            form = PostReplyForm(request, quote, {'body':quote})
        else:
            if is_survey:
                form = PostReplyForm(request, quote, {'body':survey_text})
            else:
                form = PostReplyForm(request, quote)

    if not user_can_post_in_forum[0]:
        messages.add_message(request, messages.INFO, user_can_post_in_forum[1])

    if user_is_blocked_for_spam_reports:
        messages.add_message(request, messages.INFO, "You're not allowed to post in the forums because your account has been temporaly blocked after multiple spam reports")

    return render_to_response('forum/reply.html', locals(), context_instance=RequestContext(request))


@login_required
def new_thread(request, forum_name_slug):
    forum = get_object_or_404(Forum, name_slug=forum_name_slug)
    user_can_post_in_forum = request.user.profile.can_post_in_forum()
    user_is_blocked_for_spam_reports = request.user.profile.is_blocked_for_spam_reports()

    if request.method == 'POST':
        form = NewThreadForm(request.POST)
        if user_can_post_in_forum[0] and not user_is_blocked_for_spam_reports:
            if form.is_valid():
                thread = Thread.objects.create(forum=forum, author=request.user, title=form.cleaned_data["title"])
                mayBeSpam = False
                text = form.cleaned_data["body"]
                if "http://" in form.cleaned_data["body"] or "https://" in form.cleaned_data["body"]: mayBeSpam = True
                if re.search("[a-zA-Z0-9\-\.]+\.[a-zA-Z]{2,3}(\s|$|\/|\]|\.)",  form.cleaned_data["body"]): mayBeSpam = True
                if not request.user.post_set.all().count() and mayBeSpam:
                    post = Post.objects.create(author=request.user, body=form.cleaned_data["body"], thread=thread, moderation_state="NM")
                    # DO NOT add the post to solr, only do it when it is moderated
                    set_to_moderation = True
                else:
                    post = Post.objects.create(author=request.user, body=form.cleaned_data['body'], thread=thread)
                    add_post_to_solr(post)
                    set_to_moderation = False

                # Add first post to thread (this will never be changed)
                # First we have to "reload" thread object from DB, not so overwrite the object we created before when saving
                updated_thread = Thread.objects.get(id=thread.id)
                updated_thread.first_post = post
                updated_thread.save()

                if form.cleaned_data["subscribe"]:
                    Subscription.objects.create(subscriber=request.user, thread=thread, is_active=True)

                if not set_to_moderation:
                    return HttpResponseRedirect(post.get_absolute_url())
                else:
                    messages.add_message(request, messages.INFO, "Your post won't be shown until it is manually approved by moderators")
                    return HttpResponseRedirect(post.thread.forum.get_absolute_url())
    else:
        form = NewThreadForm()

    if not user_can_post_in_forum[0]:
        messages.add_message(request, messages.INFO, user_can_post_in_forum[1])

    if user_is_blocked_for_spam_reports:
        messages.add_message(request, messages.INFO, "You're not allowed to post in the forums because your account has been temporaly blocked after multiple spam reports")

    return render_to_response('forum/new_thread.html', locals(), context_instance=RequestContext(request))


@login_required
def unsubscribe_from_thread(request, forum_name_slug, thread_id):
    forum = get_object_or_404(Forum, name_slug=forum_name_slug)
    thread = get_object_or_404(Thread, forum=forum, id=thread_id, first_post__moderation_state="OK")
    Subscription.objects.filter(thread=thread, subscriber=request.user).delete()
    return render_to_response('forum/unsubscribe_from_thread.html', locals(), context_instance=RequestContext(request))


def old_topic_link_redirect(request):
    post_id = request.GET.get("p", False)
    if post_id:
        post_id = re.sub("\D", "", post_id)
        try:
            post = get_object_or_404(Post, id=post_id)
        except ValueError:
            raise Http404
        return HttpResponsePermanentRedirect(reverse('forums-post', args=[post.thread.forum.name_slug, post.thread.id, post.id]))

    thread_id = request.GET.get("t", False)
    if thread_id:
        thread_id = re.sub("\D", "", thread_id)
        try:
            thread = get_object_or_404(Thread, id=thread_id)
        except ValueError:
            raise Http404
        return HttpResponsePermanentRedirect(reverse('forums-thread', args=[thread.forum.name_slug, thread.id]))

    raise Http404

@login_required
def post_delete(request, post_id):
    post = get_object_or_404(Post, id=post_id)
    if post.author == request.user or request.user.has_perm('forum.delete_post'):
        return render_to_response('forum/confirm_deletion.html',
                                  locals(),
                                  context_instance=RequestContext(request))
    else:
        raise Http404


@login_required
def post_delete_confirm(request, post_id):
    post = get_object_or_404(Post, id=post_id)
    if post.author == request.user or request.user.has_perm('forum.delete_post'):
        thread = post.thread
        post.delete()
        try:
            return HttpResponseRedirect(reverse('forums-post', args=[thread.forum.name_slug, thread.id, thread.last_post.id]))
        except (Post.DoesNotExist, Thread.DoesNotExist, AttributeError), e:
            return HttpResponseRedirect(reverse('forums-forums'))
    else:
        raise Http404

@login_required
def post_edit(request, post_id):
    post = get_object_or_404(Post, id=post_id)
    if post.author == request.user or request.user.has_perm('forum.change_post'):
        if request.method == 'POST':
            form = PostReplyForm(request, '', request.POST)
            if form.is_valid():
                post.body = form.cleaned_data['body']
                post.save()
                return HttpResponseRedirect(reverse('forums-post', args=[post.thread.forum.name_slug, post.thread.id, post.id]))
        else:
            form = PostReplyForm(request, '', {'body': post.body})
        return render_to_response('forum/post_edit.html',
                                  locals(),
                                  context_instance=RequestContext(request))
    else:
        raise Http404

@permission_required('forum.can_moderate_forum')
def moderate_posts(request):
    if request.method == 'POST':
        mod_form = PostModerationForm(request.POST)
        if mod_form.is_valid():
            action = mod_form.cleaned_data.get("action")
            post_id = mod_form.cleaned_data.get("post")
            post = Post.objects.get(id=post_id)
            if action == "Approve":
                post.moderation_state  = "OK"
                post.save()
            elif action == "Delete User":
                try:
                    post.author.delete()
                except: #someone deleted him already
                    pass

    pending_posts = Post.objects.filter(moderation_state='NM')
    post_list = []
    for p in pending_posts:
        f = PostModerationForm(initial={'action':'Approve','post':p.id})
        post_list.append({'post':p,'form':f})
    forums = True # prevent base template showing forum search
    return render_to_response('forum/moderate.html',locals(),context_instance=RequestContext(request))

########NEW FILE########
__FILENAME__ = freesound_exceptions
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

class PermissionDenied(Exception):
    pass
########NEW FILE########
__FILENAME__ = admin
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.contrib import admin
from general.models import AkismetSpam

class AkismetSpamAdmin(admin.ModelAdmin):
    raw_id_fields = ('user', ) 
    list_display = ('user', 'created')
    ordering = ('-created', )
    search_fields = ('=user__username', )

admin.site.register(AkismetSpam, AkismetSpamAdmin)
########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'AkismetSpam'
        db.create_table('general_akismetspam', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'])),
            ('spam', self.gf('django.db.models.fields.TextField')()),
            ('created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
        ))
        db.send_create_signal('general', ['AkismetSpam'])


    def backwards(self, orm):
        
        # Deleting model 'AkismetSpam'
        db.delete_table('general_akismetspam')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'comments.comment': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Comment'},
            'comment': ('django.db.models.fields.TextField', [], {}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'related_name': "'replies'", 'null': 'True', 'blank': 'True', 'to': "orm['comments.Comment']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'favorites.favorite': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'Favorite'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'general.akismetspam': {
            'Meta': {'object_name': 'AkismetSpam'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'spam': ('django.db.models.fields.TextField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'ratings.rating': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'Rating'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'rating': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'tags.tag': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '100', 'db_index': 'True'})
        },
        'tags.taggeditem': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('tag', 'content_type', 'object_id'),)", 'object_name': 'TaggedItem'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'tag': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['tags.Tag']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        }
    }

    complete_apps = ['general']

########NEW FILE########
__FILENAME__ = models
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from comments.models import Comment
from django.contrib.auth.models import User
from django.contrib.contenttypes import generic
from django.contrib.contenttypes.models import ContentType
from django.core.urlresolvers import reverse
from django.db import models
from favorites.models import Favorite
from ratings.models import Rating
from tags.models import TaggedItem

class SocialModel(models.Model):
    tags = generic.GenericRelation(TaggedItem)
    comments = generic.GenericRelation(Comment)
    ratings = generic.GenericRelation(Rating)
    fans = generic.GenericRelation(Favorite)

    class Meta:
        abstract = True

class AkismetSpam(SocialModel):
    user = models.ForeignKey(User)
    spam = models.TextField()
    created = models.DateTimeField(auto_now_add=True)

class OrderedModel(models.Model):
    order = models.PositiveIntegerField(editable=False)

    def save(self, *args, **kwargs):
        if not self.id:
            try:
                self.order = self.__class__.objects.all().order_by("-order")[0].order + 1
            except IndexError:
                self.order = 0
        super(OrderedModel, self).save(*args, **kwargs)

    def change_order(self):
        model_type_id = ContentType.objects.get_for_model(self.__class__).id
        model_id = self.id
        kwargs = {"direction": "up", "model_type_id": model_type_id, "model_id": model_id}
        url_up = reverse("admin-move", kwargs=kwargs)
        kwargs["direction"] = "down"
        url_down = reverse("admin-move", kwargs=kwargs)
        return '<a href="%s">up</a> | <a href="%s">down</a>' % (url_up, url_down)
    change_order.allow_tags = True
    change_order.short_description = 'Move'
    change_order.admin_order_field = 'order'
                
    @staticmethod
    def move(direction, model_type_id, model_id):
        try:
            ModelClass = ContentType.objects.get(id=model_type_id).model_class()

            current_model = ModelClass.objects.get(id=model_id)
            
            if direction == "down":
                swap_model = ModelClass.objects.filter(order__gt=current_model.order).order_by("order")[0]
            elif direction == "up":
                swap_model = ModelClass.objects.filter(order__lt=current_model.order).order_by("-order")[0]
            
            current_model.order, swap_model.order = swap_model.order, current_model.order

            current_model.save()
            swap_model.save()
        except IndexError:
            pass
        except ModelClass.DoesNotExist:
            pass

    class Meta:
        ordering = ["order"]
        abstract = True
########NEW FILE########
__FILENAME__ = absurl
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

import urlparse
from django.template import Library
from django.template.defaulttags import URLNode, url
from django.contrib.sites.models import Site

register = Library()

class AbsoluteURLNode(URLNode):
    def render(self, context):
        path = super(AbsoluteURLNode, self).render(context)
        domain = "http://%s" % Site.objects.get_current().domain
        return urlparse.urljoin(domain, path)

def absurl(parser, token, node_cls=AbsoluteURLNode):
    """Just like {% url %} but ads the domain of the current site."""
    node_instance = url(parser, token)
    return node_cls(view_name=node_instance.view_name,
        args=node_instance.args,
        kwargs=node_instance.kwargs,
        asvar=node_instance.asvar)

absurl = register.tag(absurl)
########NEW FILE########
__FILENAME__ = google_analytics
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django import template
from django.conf import settings

register = template.Library()

@register.inclusion_tag('templatetags/google_analytics.html')
def google_analytics():
    return {'google_analytics_key' : settings.GOOGLE_ANALYTICS_KEY}
    
########NEW FILE########
__FILENAME__ = markup_freesound
"""
This was copied directl from django, but a small hack was added to allow different configuration of
markdown. It uses MARKDOWN_FILTER_SETTINGS from settings.py
"""

from django import template
from django.conf import settings
from django.utils.encoding import smart_str, force_unicode
from django.utils.safestring import mark_safe

register = template.Library()

def markdown(value, arg=''):
    """
    Runs Markdown over a given value, optionally using various
    extensions python-markdown supports.

    Syntax::

        {{ value|markdown:"extension1_name,extension2_name..." }}

    To enable safe mode, which strips raw HTML and only returns HTML
    generated by actual Markdown syntax, pass "safe" as the first
    extension in the list.

    If the version of Markdown in use does not support extensions,
    they will be silently ignored.

    """
    try:
        import markdown
    except ImportError:
        if settings.DEBUG:
            raise template.TemplateSyntaxError, "Error in {% markdown %} filter: The Python markdown library isn't installed."
        return force_unicode(value)
    else:
        # markdown.version was first added in 1.6b. The only version of markdown
        # to fully support extensions before 1.6b was the shortlived 1.6a.
        if hasattr(markdown, 'version'):
            extensions = [e for e in arg.split(",") if e]
            if len(extensions) > 0 and extensions[0] == "safe":
                extensions = extensions[1:]
                safe_mode = True
            else:
                safe_mode = False

            extension_configs = {'wikilinks': [('base_url', '/help/'), ('end_url', '/'), ('html_class', 'wikilink')]}
             
            md = markdown.Markdown(extensions=extensions, extension_configs=extension_configs, safe_mode=safe_mode)
            
            # Unicode support only in markdown v1.7 or above. Version_info
            # exist only in markdown v1.6.2rc-2 or above.
            if getattr(markdown, "version_info", None) < (1,7):
                return mark_safe(force_unicode(md.convert(force_unicode(value))))
            else:
                return mark_safe(md.convert(force_unicode(value)))
        else:
            return mark_safe(force_unicode(markdown.markdown(smart_str(value))))
markdown.is_safe = True

register.filter(markdown)
########NEW FILE########
__FILENAME__ = paginator
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

import urllib
from django import template

register = template.Library()

@register.inclusion_tag('templatetags/paginator.html', takes_context=True)
def show_paginator(context, paginator, page, current_page, request, anchor="", non_grouped_number_of_results = -1 ):
    """
    Adds pagination context variables for use in displaying first, adjacent and
    last page links in addition to those created by the object_list generic
    view.
    """
 
    adjacent_pages = 3
    total_wanted = adjacent_pages * 2 + 1
    min_page_num = max(current_page - adjacent_pages, 1)
    max_page_num = min(current_page + adjacent_pages + 1, paginator.num_pages + 1)

    num_items = max_page_num - min_page_num

    if num_items < total_wanted and num_items < paginator.num_pages:
        if min_page_num == 1:
            # we're at the start, increment max_page_num
            max_page_num += min(total_wanted - num_items, paginator.num_pages - num_items)
        else:
            # we're at the end, decrement
            min_page_num -= min(total_wanted - num_items, paginator.num_pages - num_items)

    # although paginator objects are 0-based, we use 1-based paging
    page_numbers = [n for n in range(min_page_num, max_page_num) if n > 0 and n <= paginator.num_pages]
    
    params = urllib.urlencode([(key, value.encode('utf-8')) for (key, value) in request.GET.items() if key.lower() != u"page"])
    
    if params == "":
        url = request.path + u"?page="
    else:
        url = request.path + u"?" + params + u"&page="

    return {
        "page": page,
        "paginator": paginator,
        "current_page": current_page,
        "page_numbers": page_numbers,
        "show_first": 1 not in page_numbers,
        "show_last": paginator.num_pages not in page_numbers,
        "url" : url,
        "media_url": context['media_url'],
        "anchor": anchor,
        "non_grouped_number_of_results": non_grouped_number_of_results
    }
########NEW FILE########
__FILENAME__ = pledgie
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django import template
import urllib, json
from django.conf import settings

register = template.Library()

class PledgieParserNode(template.Node):
    def __init__(self, var_name, pledgie_id=None, pledgie_id_var_name=None):
        self.pledgie_id = pledgie_id
        self.pledgie_id_var_name = pledgie_id_var_name
        self.var_name = var_name

    def render(self, context):
        pledgie_id = None

        if self.pledgie_id_var_name:
            try:
                pledgie_id = int(context[self.pledgie_id_var_name])
            except KeyError:
                raise template.TemplateSyntaxError, "the variable \"%s\" can't be found in the context" % self.pledgie_id_var_name
            except ValueError:
                raise template.TemplateSyntaxError, "pledgie campaign id's need to be integers!"
        else:
            pledgie_id = int(self.pledgie_id)

        api_url = "https://pledgie.com/campaigns/%d.json" % pledgie_id
        pledge_url = "https://pledgie.com/campaigns/%d/" % pledgie_id

        data = None

        try:
            data = json.loads(urllib.urlopen(api_url, proxies=settings.PROXIES).read(), "utf-8")
            data["to_go"] = int(data["campaign"]["goal"] - data["campaign"]["amount_raised"])
            data["url"] = pledge_url
        #except UnicodeDecodeError:
        #    pass
        except:
            data = {}
            data['to_go'] = 0
            data['url'] = 'unknown'

        context[self.var_name] = data

        return ''

import re

@register.tag(name="get_pledgie_campaign_details")
def get_pledgie_campaign_details(parser, token):
    # This version uses a regular expression to parse tag contents.
    try:
        # Splitting by None == splitting by spaces.
        tag_name, arg = token.contents.split(None, 1)
    except ValueError:
        raise template.TemplateSyntaxError, "%r tag requires arguments" % token.contents.split()[0]

    m = re.search(r'(.*?) as (\w+)', arg)
    if not m:
        raise template.TemplateSyntaxError, "%r tag had invalid arguments" % tag_name
    pledgie_id, var_name = m.groups()

    if pledgie_id[0] == pledgie_id[-1] and pledgie_id[0] in ('"', "'"):
        try:
            pledgie_id = int(pledgie_id[1:-1])
        except ValueError:
            raise template.TemplateSyntaxError, "the pledgie id should be an integer..."

        return PledgieParserNode(var_name, pledgie_id=pledgie_id)
    else:
        return PledgieParserNode(var_name, pledgie_id_var_name=pledgie_id)

########NEW FILE########
__FILENAME__ = rss
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django import template
import feedparser
import urllib2
from django.conf import settings

register = template.Library()

class RssParserNode(template.Node):
    def __init__(self, var_name, url=None, url_var_name=None):
        self.url = url
        self.url_var_name = url_var_name
        self.var_name = var_name

    def render(self, context):
        proxy = urllib2.ProxyHandler( settings.PROXIES )
        if self.url:
            context[self.var_name] = feedparser.parse(self.url, handlers=[proxy])
        else:
            try:
                context[self.var_name] = feedparser.parse(context[self.url_var_name], handlers=[proxy])
            except KeyError:
                raise template.TemplateSyntaxError, "the variable \"%s\" can't be found in the context" % self.url_var_name
        return ''

import re

@register.tag(name="get_rss")
def get_rss(parser, token):
    # This version uses a regular expression to parse tag contents.
    try:
        # Splitting by None == splitting by spaces.
        tag_name, arg = token.contents.split(None, 1)
    except ValueError:
        raise template.TemplateSyntaxError, "%r tag requires arguments" % token.contents.split()[0]
    
    m = re.search(r'(.*?) as (\w+)', arg)
    if not m:
        raise template.TemplateSyntaxError, "%r tag had invalid arguments" % tag_name
    url, var_name = m.groups()
    
    if url[0] == url[-1] and url[0] in ('"', "'"):
        return RssParserNode(var_name, url=url[1:-1])
    else:
        return RssParserNode(var_name, url_var_name=url)
    
########NEW FILE########
__FILENAME__ = util
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.template import Library
import datetime, time
from django.template.defaultfilters import stringfilter

register = Library()

@register.filter
def tuple_to_time(t):
    return datetime.datetime(*t[0:6]) + datetime.timedelta(seconds=time.timezone)


@register.filter(name='truncate_string')
@stringfilter
def truncate_string(value, length):
    if len(value) > length:
        return value[:length-3] + u"..."
    else:
        return value

@register.filter
def duration(value):
    duration_minutes = int(value/60)
    duration_seconds = int(value) % 60
    duration_miliseconds = int((value - int(value)) * 1000)
    return "%02d:%02d:%03d" % (duration_minutes, duration_seconds, duration_miliseconds)

@register.filter
def in_list(value,arg):
    return value in arg
########NEW FILE########
__FILENAME__ = views
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.contrib.admin.views.decorators import staff_member_required
from django.contrib.contenttypes.models import ContentType
from django.http import HttpResponseRedirect
from general.models import OrderedModel
from django.db import transaction

@staff_member_required
@transaction.commit_on_success
def admin_move_ordered_model(request, direction, model_type_id, model_id):
    OrderedModel.move(direction, model_type_id, model_id)
    
    ModelClass = ContentType.objects.get(id=model_type_id).model_class()
    
    app_label = ModelClass._meta.app_label
    model_name = ModelClass.__name__.lower()

    url = "/admin/%s/%s/" % (app_label, model_name)
    
    return HttpResponseRedirect(url)
########NEW FILE########
__FILENAME__ = admin
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.contrib import admin
from geotags.models import GeoTag

class GeoTagAdmin(admin.ModelAdmin):
    search_fields = ('=user__username',)
    raw_id_fields = ('user',) 
    list_display = ('user', 'lat', 'lon', 'created')

admin.site.register(GeoTag, GeoTagAdmin)
########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'GeoTag'
        db.create_table('geotags_geotag', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'])),
            ('lat', self.gf('django.db.models.fields.FloatField')(db_index=True)),
            ('lon', self.gf('django.db.models.fields.FloatField')(db_index=True)),
            ('zoom', self.gf('django.db.models.fields.IntegerField')()),
            ('created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, db_index=True, blank=True)),
        ))
        db.send_create_signal('geotags', ['GeoTag'])


    def backwards(self, orm):
        
        # Deleting model 'GeoTag'
        db.delete_table('geotags_geotag')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'geotags.geotag': {
            'Meta': {'object_name': 'GeoTag'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lat': ('django.db.models.fields.FloatField', [], {'db_index': 'True'}),
            'lon': ('django.db.models.fields.FloatField', [], {'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'zoom': ('django.db.models.fields.IntegerField', [], {})
        }
    }

    complete_apps = ['geotags']

########NEW FILE########
__FILENAME__ = models
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.contrib.auth.models import User
from django.db import models
from django.utils.encoding import smart_unicode

class GeoTag(models.Model):
    user = models.ForeignKey(User)

    lat = models.FloatField(db_index=True)
    lon = models.FloatField(db_index=True)
    zoom = models.IntegerField()

    created = models.DateTimeField(db_index=True, auto_now_add=True)
    
    def __unicode__(self):
        return u"%s (%f,%f)" % (self.user, self.lat, self.lon)

    @models.permalink
    def get_absolute_url(self):
        return ('geotag', (smart_unicode(self.id),))
########NEW FILE########
__FILENAME__ = display_geotags
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django import template

register = template.Library()

@register.inclusion_tag('geotags/display_geotags.html', takes_context=True)
def display_geotags(context, url = "/geotags/geotags_box_json/", width = 900, height = 600, clusters = "on", center_lat = None, center_lon = None, zoom = None, username = None):
    if center_lat and center_lon and zoom:
        borders = "defined"
    else:
        borders = "automatic"

    return {"url":url, "media_url": context['media_url'], "m_width":width, "m_height":height, "clusters":clusters, "center_lat":center_lat, "center_lon":center_lon, "zoom":zoom, "borders":borders, "username":username}
########NEW FILE########
__FILENAME__ = urls
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.conf.urls.defaults import url, patterns
import geotags.views as geotags

urlpatterns = patterns('',
    url(r'^sounds_json/user/(?P<username>[^//]+)/$', geotags.geotags_for_user_json, name="geotags-for-user-json"),
    url(r'^sounds_json/user_latest/(?P<username>[^//]+)/$', geotags.geotags_for_user_latest_json, name="geotags-for-user-latest-json"),
    url(r'^sounds_json/pack/(?P<pack_id>\d+)/$', geotags.geotags_for_pack_json, name="geotags-for-pack-json"),
    url(r'^sounds_json/(?P<tag>[\w-]+)?/?$', geotags.geotags_json, name="geotags-json"),
    url(r'^geotags_box_json/$', geotags.geotags_box_json, name="geotags-box-json"),
    url(r'^infowindow/(?P<sound_id>\d+)/$', geotags.infowindow, name="geotags-infowindow"),
)
########NEW FILE########
__FILENAME__ = views
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.conf import settings
from django.http import Http404, HttpResponse
from django.shortcuts import render_to_response
from django.template import RequestContext
from sounds.models import Sound
from django.views.decorators.cache import cache_page
from django.contrib.auth.models import User
import json

"""
SQL queries in this file are done manually in order to force an INNER JOIN,
since Django insists on doing an OUTER LEFT JOIN, which is too slow.
The equivalent Django query is also provided for each raw query.
"""

geoquery = """SELECT sounds_sound.id,
                     geotags_geotag.lat,
                     geotags_geotag.lon
                FROM sounds_sound
                     %(join)s
          INNER JOIN geotags_geotag
                  ON (sounds_sound.geotag_id = geotags_geotag.id)
               WHERE sounds_sound.processing_state = 'OK'
                 AND sounds_sound.moderation_state = 'OK'
                     %(where)s
            ORDER BY sounds_sound.created DESC
                     %(end)s"""

def generate_json(sound_queryset):
    # When using Django Sound queries:
    #sounds_data = [[s.id, s.geotag.lat, s.geotag.lon] for s in sound_queryset]

    sounds_data = [[s.id, s.lat, s.lon] for s in sound_queryset]

    return HttpResponse(json.dumps(sounds_data), mimetype="application/json")

@cache_page(60 * 15)
def geotags_json(request, tag=None):
    if tag:
        #sounds = Sound.objects.select_related('geotag').filter(tags__tag__name=tag).exclude(geotag=None)
        join = """INNER JOIN "tags_taggeditem"
                           ON ("sounds_sound"."id" = "tags_taggeditem"."object_id")
                   INNER JOIN "tags_tag"
                           ON ("tags_taggeditem"."tag_id" = "tags_tag"."id")"""
        where = """AND "tags_tag"."name" = %s"""
        q = geoquery % {"join": join, "where": where, "end": ""}
        sounds = Sound.objects.raw(q, [tag])
    else:
        #sounds = Sound.public.select_related('geotag').all().exclude(geotag=None)
        q = geoquery % {"join": "", "where": "", "end": ""}
        sounds = Sound.objects.raw(q)

    return generate_json(sounds)

def geotags_box_json(request):    
    box = request.GET.get("box","-180,-90,180,90")
    try:
        min_lat, min_lon, max_lat, max_lon = box.split(",")  
        qs = Sound.objects.select_related("geotag").exclude(geotag=None).filter(moderation_state="OK", processing_state="OK")        
        if min_lat <= max_lat and min_lon <= max_lon:
            sounds = qs.filter(geotag__lat__range=(min_lat,max_lat)).filter(geotag__lon__range=(min_lon,max_lon))
        elif min_lat > max_lat and min_lon <= max_lon:
            sounds = qs.exclude(geotag__lat__range=(max_lat,min_lat)).filter(geotag__lon__range=(min_lon,max_lon))
        elif min_lat <= max_lat and min_lon > max_lon:
            sounds =qs.filter(geotag__lat__range=(min_lat,max_lat)).exclude(geotag__lon__range=(max_lon,min_lon))
        elif min_lat > max_lat and min_lon > max_lon:
            sounds = qs.exclude(geotag__lat__range=(max_lat,min_lat)).exclude(geotag__lon__range=(max_lon,min_lon))        

        sounds_data = [[s.id, s.geotag.lat, s.geotag.lon] for s in sounds]
        return HttpResponse(json.dumps(sounds_data), mimetype="application/json")
    except ValueError:
        raise Http404
    
@cache_page(60 * 15)
def geotags_for_user_json(request, username):
    #sounds = Sound.public.select_related('geotag').filter(user__username__iexact=username).exclude(geotag=None)
    join = """INNER JOIN "auth_user"
                      ON ("sounds_sound"."user_id" = "auth_user"."id")"""
    where = """AND UPPER("auth_user"."username"::text) = UPPER(%s)"""
    q = geoquery % {"join": join, "where": where, "end": ""}
    sounds = Sound.objects.raw(q, [username])
    return generate_json(sounds)

#@cache_page(60 * 15)
def geotags_for_user_latest_json(request, username):
    #sounds = Sound.public.filter(user__username__iexact=username).exclude(geotag=None)[0:10]
    join = """INNER JOIN "auth_user"
                      ON ("sounds_sound"."user_id" = "auth_user"."id")"""
    where = """AND UPPER("auth_user"."username"::text) = UPPER(%s)"""
    end = "LIMIT 10"
    q = geoquery % {"join": join, "where": where, "end": end}
    sounds = Sound.objects.raw(q, [username])
    return generate_json(sounds)

#@cache_page(60 * 15)
def geotags_for_pack_json(request, pack_id):
    #sounds = Sound.public.select_related('geotag').filter(pack__id=pack_id).exclude(geotag=None)
    where = "AND pack_id = %s"
    q = geoquery % {"join": "", "where": where, "end": ""}
    sounds = Sound.objects.raw(q, [pack_id])
    return generate_json(sounds)

def geotags(request, tag=None):
    google_api_key = settings.GOOGLE_API_KEY
    for_user = None
    return render_to_response('geotags/geotags.html', locals(), context_instance=RequestContext(request))

def geotags_box(request):
    m_width = request.GET.get("w",900)
    m_height = request.GET.get("h",600)
    clusters = request.GET.get("c","on")
    center_lat = request.GET.get("c_lat",None)
    center_lon = request.GET.get("c_lon",None)
    zoom = request.GET.get("z",None)
    username = request.GET.get("username",None)
    
    google_api_key = settings.GOOGLE_API_KEY
    return render_to_response('geotags/geotags_box.html', locals(), context_instance=RequestContext(request))


def for_user(request, username):
    try:
        for_user = User.objects.get(username__iexact=username)
    except User.DoesNotExist: #@UndefinedVariable
        raise Http404
    google_api_key = settings.GOOGLE_API_KEY
    tag = None
    return render_to_response('geotags/geotags.html', locals(), context_instance=RequestContext(request))


def infowindow(request, sound_id):
    try:
        sound = Sound.objects.select_related('user', 'geotag').get(id=sound_id)
    except Sound.DoesNotExist: #@UndefinedVariable
        raise Http404

    return render_to_response('geotags/infowindow.html', locals(), context_instance=RequestContext(request))
    
def embed_iframe(request):
    m_width = request.GET.get("w",900)
    m_height = request.GET.get("h",600)
    clusters = request.GET.get("c","on")
    center_lat = request.GET.get("c_lat",None)
    center_lon = request.GET.get("c_lon",None)
    zoom = request.GET.get("z",None)
    username = request.GET.get("username",None)
    
    google_api_key = settings.GOOGLE_API_KEY
    return render_to_response('geotags/geotags_box_iframe.html', locals(), context_instance=RequestContext(request))

########NEW FILE########
__FILENAME__ = local_settings.example
# -*- coding: utf-8 -*-

DEBUG = True
DISPLAY_DEBUG_TOOLBAR = True

ADMINS = (
    ('Your Email Here', 'abc@gmail.com'),
)

# If ALLOWED emails is not empty, only emails going to these destinations will be actually sent
ALLOWED_EMAILS = []

DATABASE_ENGINE = 'django.db.backends.postgresql_psycopg2' # 'postgresql_psycopg2', 'postgresql', 'mysql', 'sqlite3' or 'oracle'.
DATABASE_NAME = 'freesound'             # Or path to database file if using sqlite3.
DATABASE_USER = 'freesound'             # Not used with sqlite3.
DATABASE_HOST = ''             # Set to empty string for localhost. Not used with sqlite3.
DATABASE_PORT = ''             # Set to empty string for default. Not used with sqlite3.
DATABASE_PASSWORD = ''

# Make this unique, and don't share it with anybody.
SECRET_KEY = ''

EMAIL_HOST = 'localhost'
EMAIL_PORT = 2525

PROXIES = {} #'http': 'http://proxy.upf.edu:8080'}

RECAPTCHA_PRIVATE_KEY = ''
RECAPTCHA_PUBLIC_KEY = ''
AKISMET_KEY = ''

GOOGLE_API_KEY = ''
GOOGLE_ANALYTICS_KEY = ''

SOLR_URL = "http://localhost:8983/solr/fs2/"
SOLR_FORUM_URL = "http://localhost:8983/solr/forum/"

GEARMAN_JOB_SERVERS = ["localhost:4730"]

PLEDGIE_CAMPAIGN=14560

LOG_CLICKTHROUGH_DATA = False


#-------------------------------------------------------------------------------
# SOLR ranking weights
DEFAULT_SEARCH_WEIGHTS = {
    'id' : 4,
    'tag' : 4,
    'description' : 3,
    'username' : 1,
    'pack_tokenized' : 2,
    'original_filename' : 2
}

########NEW FILE########
__FILENAME__ = logger.example
'''
Created on Dec 12, 2011

@author: stelios
'''

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'standard': {
            'format': '[%(asctime)s] # %(levelname)s    # %(message)s'
        },
        'worker': {
            'format': '[%(asctime)s] # %(levelname)s    # [%(process)d] %(message)s'
        },
    },
    'handlers': {
        'errorlogfile': {
            'class': 'logging.handlers.TimedRotatingFileHandler',
            'filename': '/var/log/freesound/error500.log',
            'when': 'midnight',
            'backupCount': '14',
            'formatter': 'standard'
        },
        'gelf_error': {
            'class': 'graypy.GELFHandler',
            'host': '10.55.0.20',
            'port': 12201,
            'formatter': 'standard'
        },
        'stderr': {
            'class': 'logging.StreamHandler',
            'formatter': 'standard'
        },
        'audioprocessinglogfile': {
            'class': 'logging.handlers.TimedRotatingFileHandler',
            'filename': '/var/log/freesound/audio.log',
            'when': 'midnight',
            'backupCount': '14',
            'formatter': 'worker'
        },
        'gelf_audio': {
            'class': 'graypy.GELFHandler',
            'host': '10.55.0.20',
            'port': 12201,
            'formatter': 'worker'
        },
        'weblogfile': {
            'class': 'logging.handlers.TimedRotatingFileHandler',
            'filename': '/var/log/freesound/web.log',
            'when': 'midnight',
            'backupCount': '14',
            'formatter': 'standard'
        },
        'gelf_web': {
            'class': 'graypy.GELFHandler',
            'host': '10.55.0.20',
            'port': 12201,
            'formatter': 'standard'
        },
        'api': {
            'class': 'logging.handlers.TimedRotatingFileHandler',
            'filename': '/var/log/freesound/api.log',
            'when': 'midnight',
            'backupCount': '14',
            'formatter': 'standard'
        },
        'gelf_api': {
            'class': 'graypy.GELFHandler',
            'host': '10.55.0.20',
            'port': 12201,
            'formatter': 'standard'
        },
        'searchlogfile': {
            'class': 'logging.handlers.TimedRotatingFileHandler',
            'filename': '/var/log/freesound/search.log',
            'when': 'midnight',
            'backupCount': '14',
            'formatter': 'standard'
        },
        'clickusagelogfile': {
            'class': 'logging.handlers.TimedRotatingFileHandler',
            'filename': '/var/log/freesound/clickusage.log',
            'when': 'midnight',
            'backupCount': '14',
            'formatter': 'standard'
        },
        'gelf_search': {
            'class': 'graypy.GELFHandler',
            'host': '10.55.0.20',
            'port': 12201,
            'formatter': 'standard'
        },
        'uploadlogfile': {
            'class': 'logging.handlers.TimedRotatingFileHandler',
            'filename': '/var/log/freesound/upload.log',
            'when': 'midnight',
            'backupCount': '14',
            'formatter': 'standard'
        },
        'gelf_upload': {
            'class': 'graypy.GELFHandler',
            'host': '10.55.0.20',
            'port': 12201,
            'formatter': 'standard'
        },
        'gearman_worker_processing_handler': {
            'class': 'logging.handlers.TimedRotatingFileHandler',
            'filename': '/var/log/freesound/gearman_worker_processing.log',
            'when': 'midnight',
            'backupCount': '14',
            'formatter': 'standard'
        },
        'gelf_gearman_worker_processing': {
            'class': 'graypy.GELFHandler',
            'host': '10.55.0.20',
            'port': 12201,
            'formatter': 'standard'
        },
        'processing_handler': {
            'class': 'logging.handlers.TimedRotatingFileHandler',
            'filename': '/var/log/freesound/audio_processing.log',
            'when': 'midnight',
            'backupCount': '14',
            'formatter': 'standard'
        },
        'gelf_processing': {
            'class': 'graypy.GELFHandler',
            'host': '10.55.0.20',
            'port': 12201,
            'formatter': 'standard'
        },       
        'mail': {
            'class': 'logging.handlers.WatchedFileHandler',
            'filename': '/var/log/freesound/mail.log',
            'formatter': 'standard'
        },
    },
    'loggers': {
        'django.request': {
            'handlers': ['errorlogfile'],
            'level': 'ERROR',   # only catches 5xx not 4xx messages
            'propagate': True,
        },
        'audio': {
            'handlers': ['audioprocessinglogfile'],
            'level': 'INFO',
            'propagate': False,
        },
        'api': {
            'handlers': ['api'],
            'level': 'INFO',
            'propagate': False,
        },
        'web': {
            'handlers': ['weblogfile'],
            'level': 'INFO',
            'propagate': False,
        },
        'search': {
            'handlers': ['searchlogfile'],
            'level': 'INFO',
            'propagate': False,
        },
        'clickusage': {
            'handlers': ['clickusagelogfile'],
            'level': 'INFO',
            'propagate': False,
        },
        'upload': {
            'handlers': ['uploadlogfile'],
            'level': 'INFO',
            'propagate': False,
        },
        'processing': {
            'handlers': ['processing_handler'],
            'level': 'INFO',
            'propagate': False,
        },
        'gearman_worker_processing': {
            'handlers': ['gearman_worker_processing_handler'],
            'level': 'INFO',
            'propagate': False,
        },
    },
}

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from django.core.management import execute_manager

try:
    import settings # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n(If the file settings.py does indeed exist, it's causing an ImportError somehow.)\n" % __file__)
    sys.exit(1)

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = admin
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.contrib import admin
from messages.models import Message, MessageBody

class MessageAdmin(admin.ModelAdmin):
    raw_id_fields = ('user_from', 'user_to', 'body')
    list_display = ('user_from', 'user_to', 'subject', 'is_sent', 'is_read', 'is_archived', 'created', )
    search_fields = ('=user_from__username', '=user_to__username', 'subject',)
    list_filter = ('is_sent', 'is_read', 'is_archived', )

admin.site.register(Message, MessageAdmin)

admin.site.register(MessageBody)
########NEW FILE########
__FILENAME__ = forms
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django import forms
from django.contrib.auth.models import User
from utils.forms import RecaptchaForm, HtmlCleaningCharField

class ManualUserField(forms.CharField):
    def clean(self, value):
        if not value:
            raise forms.ValidationError('Please enter a username.')
        try:
            return User.objects.get(username__iexact=value)
        except User.DoesNotExist: #@UndefinedVariable
            raise forms.ValidationError("We are sorry, but this username does not exist...")

def MessageReplyClassCreator(baseclass):
    class MessageReplyForm(baseclass):
        to = ManualUserField(widget=forms.TextInput(attrs={'size':'40'}))
        subject = forms.CharField(min_length=3, max_length=128, widget=forms.TextInput(attrs={'size':'80'}))
        body = HtmlCleaningCharField(widget=forms.Textarea(attrs=dict(cols=100, rows=30)))
    return MessageReplyForm

MessageReplyForm = MessageReplyClassCreator(RecaptchaForm)
MessageReplyFormNoCaptcha = MessageReplyClassCreator(forms.Form)
########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'MessageBody'
        db.create_table('messages_messagebody', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('body', self.gf('django.db.models.fields.TextField')()),
        ))
        db.send_create_signal('messages', ['MessageBody'])

        # Adding model 'Message'
        db.create_table('messages_message', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('user_from', self.gf('django.db.models.fields.related.ForeignKey')(related_name='messages_sent', to=orm['auth.User'])),
            ('user_to', self.gf('django.db.models.fields.related.ForeignKey')(related_name='messages_received', to=orm['auth.User'])),
            ('subject', self.gf('django.db.models.fields.CharField')(max_length=128)),
            ('body', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['messages.MessageBody'])),
            ('is_sent', self.gf('django.db.models.fields.BooleanField')(default=True, db_index=True)),
            ('is_read', self.gf('django.db.models.fields.BooleanField')(default=False, db_index=True)),
            ('is_archived', self.gf('django.db.models.fields.BooleanField')(default=False, db_index=True)),
            ('created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, db_index=True, blank=True)),
        ))
        db.send_create_signal('messages', ['Message'])


    def backwards(self, orm):
        
        # Deleting model 'MessageBody'
        db.delete_table('messages_messagebody')

        # Deleting model 'Message'
        db.delete_table('messages_message')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'messages.message': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Message'},
            'body': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['messages.MessageBody']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_archived': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_read': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_sent': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'db_index': 'True'}),
            'subject': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_from': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'messages_sent'", 'to': "orm['auth.User']"}),
            'user_to': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'messages_received'", 'to': "orm['auth.User']"})
        },
        'messages.messagebody': {
            'Meta': {'object_name': 'MessageBody'},
            'body': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['messages']

########NEW FILE########
__FILENAME__ = models
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.contrib.auth.models import User
from django.db import models
from django.utils.encoding import smart_unicode

class MessageBody(models.Model):
    body = models.TextField()

    def __unicode__(self):
        return self.body[0:30] + u"[...]"

class Message(models.Model):
    user_from = models.ForeignKey(User, related_name='messages_sent')
    user_to = models.ForeignKey(User, related_name='messages_received')
    
    subject = models.CharField(max_length=128)
    
    body = models.ForeignKey(MessageBody)
        
    is_sent = models.BooleanField(default=True, db_index=True)
    is_read = models.BooleanField(default=False, db_index=True)
    is_archived = models.BooleanField(default=False, db_index=True)
    
    created = models.DateTimeField(db_index=True, auto_now_add=True)
    
    def get_absolute_url(self):
        return ("message", (smart_unicode(self.id),))

    def __unicode__(self):
        return u"from: [%s] to: [%s]" % (self.user_from, self.user_to)
    
    class Meta:
        ordering = ('-created',)

"""
send message >> creates 2 mails in database:
    in sent messages bram:
        from bram
        to gerard
        sent = 1
        archived = 0
        read = 0 (although this doesn't mattrer for "sent" mails)
    
    in inbox gerard:
        from bram
        to gerard
        sent = 0 (received email by gerard)
        archived = 0
        read = 0
    
gerard opens message:
    in inbox gerard:
        from bram
        to gerard
        sent = 0
        archived = 0
        read = 1
        
gerard archives message:
    in inbox gerard:
        from bram
        to gerard
        sent = 0
        archived = 1
        read = 1


inbox gerard contains:
    where
        to=gerard and
        sent=0 and
        archived=0
        
sent-messages bram contains:
    where
        from=bram and
        sent=1 and
        archived=0
        
etc...

state conversion from phpbb to freesound:

state = 1 or 5 (unread mail!)
    create two mails:
        sent = 1
        archived = 0
        read = 0
    
        sent = 0
        archived = 0
        read = 0

state = 0
        sent = 0
        archived = 0
        read = 1

state = 2
        sent = 1
        archived = 0
        read = 0

state = 3
        sent = 0
        archived = 1
        read = 1

state = 4
        sent = 1
        archived = 1
        read = 1

define('PRIVMSGS_READ_MAIL', 0);

define('PRIVMSGS_NEW_MAIL', 1);
define('PRIVMSGS_SENT_MAIL', 2);

define('PRIVMSGS_SAVED_IN_MAIL', 3);
define('PRIVMSGS_SAVED_OUT_MAIL', 4);

define('PRIVMSGS_UNREAD_MAIL', 5); // same as 1


"""
########NEW FILE########
__FILENAME__ = message_count
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django import template
from messages.models import Message

register = template.Library()

@register.simple_tag
def unread_message_count(user):
    return Message.objects.filter(user_to=user, is_archived=False, is_sent=False, is_read=False).count()
########NEW FILE########
__FILENAME__ = views
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.contrib.auth.decorators import login_required
from django.core.urlresolvers import reverse
from django.db.models import Q
from django.http import HttpResponseRedirect, Http404
from django.shortcuts import render_to_response
from django.template import RequestContext
from messages.forms import MessageReplyForm, MessageReplyFormNoCaptcha
from messages.models import Message, MessageBody
from utils.cache import invalidate_template_cache
from utils.functional import exceptional
from utils.mail import send_mail_template
from utils.pagination import paginate
from BeautifulSoup import BeautifulSoup
import json
from textwrap import wrap
from accounts.models import User
from django.http import HttpResponse
from django.contrib import messages

@login_required
def messages_change_state(request):
    if request.method == "POST":
        choice = request.POST.get("choice", False)
        
        # get all ids, prefixed by "cb_" and after than an integer
        # only get the checkboxes that are "on"
        message_ids = filter(lambda x: x != None, [exceptional(int)(key.replace("cb_", "")) for key in request.POST.keys() if key.startswith("cb_") and request.POST.get(key) == "on"])

        if choice and message_ids:
            messages = Message.objects.filter(Q(user_to=request.user, is_sent=False) | Q(user_from=request.user, is_sent=True)).filter(id__in=message_ids)

            if choice == "a":
                messages.update(is_archived=True)
            elif choice == "d":
                messages.delete()
            elif choice == "r":
                messages.update(is_read=True)
            
            invalidate_template_cache("user_header", request.user.id)
            
    return HttpResponseRedirect(request.POST.get("next", reverse("messages")))

# base query object
base_qs = Message.objects.select_related('body', 'user_from', 'user_to')

@login_required
def inbox(request):
    qs = base_qs.filter(user_to=request.user, is_archived=False, is_sent=False)
    return render_to_response('messages/inbox.html', paginate(request, qs), context_instance=RequestContext(request))


@login_required
def sent_messages(request):
    qs = base_qs.filter(user_from=request.user, is_archived=False, is_sent=True)
    return render_to_response('messages/sent.html', paginate(request, qs), context_instance=RequestContext(request))


@login_required
def archived_messages(request):
    qs = base_qs.filter(user_to=request.user, is_archived=True, is_sent=False)
    return render_to_response('messages/archived.html', paginate(request, qs), context_instance=RequestContext(request))


@login_required
def message(request, message_id):
    try:
        message = base_qs.get(id=message_id)
    except Message.DoesNotExist: #@UndefinedVariable
        raise Http404
    
    if message.user_from != request.user and message.user_to != request.user:
        raise Http404
    
    if not message.is_read:
        message.is_read = True
        invalidate_template_cache("user_header", request.user.id)
        message.save()
        
    return render_to_response('messages/message.html', locals(), context_instance=RequestContext(request))

@login_required
def new_message(request, username=None, message_id=None):
    
    if request.method == 'POST':

        if request.user.profile.num_sounds:
            form = MessageReplyFormNoCaptcha(request.POST)
        else:
            form = MessageReplyForm(request,request.POST)

        if request.user.profile.is_blocked_for_spam_reports():
            messages.add_message(request, messages.INFO, "You're not allowed to send the message because your account has been temporaly blocked after multiple spam reports")
        else:
            if form.is_valid():
                user_from = request.user
                user_to = form.cleaned_data["to"]
                subject = form.cleaned_data["subject"]
                body = MessageBody.objects.create(body=form.cleaned_data["body"])

                Message.objects.create(user_from=user_from, user_to=user_to, subject=subject, body=body, is_sent=True, is_archived=False, is_read=False)
                Message.objects.create(user_from=user_from, user_to=user_to, subject=subject, body=body, is_sent=False, is_archived=False, is_read=False)

                invalidate_template_cache("user_header", user_to.id)

                try:
                    # send the user an email to notify him of the sent message!
                    send_mail_template(u'you have a private message.', 'messages/email_new_message.txt', locals(), None, user_to.email)
                except:
                    # if the email sending fails, ignore...
                    pass

                return HttpResponseRedirect(reverse("messages"))
    else:
        if request.user.profile.num_sounds:
            form = MessageReplyFormNoCaptcha()
        else:
            form = MessageReplyForm(request)

        if message_id:
            try:
                message = Message.objects.get(id=message_id)

                if message.user_from != request.user and message.user_to != request.user:
                    raise Http404
                
                body = message.body.body.replace("\r\n", "\n").replace("\r", "\n")
                body = ''.join(BeautifulSoup(body).findAll(text=True))
                body = "\n".join([(">" if line.startswith(">") else "> ") + "\n> ".join(wrap(line.strip(),60)) for line in body.split("\n")])
                body = "> --- " + message.user_from.username + " wrote:\n>\n" + body
                
                subject = "re: " + message.subject
                to = message.user_from.username

                if request.user.profile.num_sounds:
                    form = MessageReplyFormNoCaptcha(initial=dict(to=to, subject=subject, body=body))
                else:
                    form = MessageReplyForm(request,initial=dict(to=to, subject=subject, body=body))
            except Message.DoesNotExist:
                pass
        elif username:
            if request.user.profile.num_sounds:
                form = MessageReplyFormNoCaptcha(initial=dict(to=username))
            else:
                form = MessageReplyForm(request, initial=dict(to=username))
    
    return render_to_response('messages/new.html', locals(), context_instance=RequestContext(request))

def username_lookup(request):
    results = []
    value = ""
    if request.method == "GET":
        if request.GET.has_key(u'q'):            
            value = request.GET[u'q']

            # When there is at least one character, start searching usernames (only among users previously contacted)
            if len(value) > 0:
                # Only autocompleting for previously contacted users 
                previously_contacted_user_ids1 = list(Message.objects.filter(user_from = request.user.id, ).values_list('user_to', flat='True').distinct())
                previously_contacted_user_ids2 = list(Message.objects.filter(user_to = request.user.id, ).values_list('user_from', flat='True').distinct())
                previously_contacted_user_ids = set(previously_contacted_user_ids1+previously_contacted_user_ids2)
                model_results = User.objects.filter(username__istartswith = value, id__in = previously_contacted_user_ids).order_by('username')#[0:30]
                index = 0
                for r in model_results:
                    results.append( (r.username,index) )
                    index = index + 1

    json_resp = json.dumps(results)
    return HttpResponse(json_resp, mimetype='application/json')


########NEW FILE########
__FILENAME__ = middleware
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.shortcuts import render_to_response
from freesound_exceptions import PermissionDenied
from utils.onlineusers import cache_online_users
from django.contrib.auth.models import User
from accounts.models import Profile
from django.http import HttpResponseRedirect
from django.core.urlresolvers import reverse
# from django.template import RequestContext
from django.conf import settings
from django.core.cache import cache
from sounds.models import Sound


class PermissionDeniedHandler:
    def process_exception(self, request, exception):
        if isinstance(exception, PermissionDenied):
            return render_to_response('permissiondenied.html')
        return None

class OnlineUsersHandler:
    def process_request(self,request):
        cache_online_users(request)
        return None

class CheckIfRequestIsHttps:
    def process_request(self,request):
        # header HTTP_X_FORWARDED_PROTOCOL is set by nginx in loadbalancer
        forwarded_protocol = request.META.get('HTTP_X_FORWARDED_PROTOCOL', None)
        if forwarded_protocol == 'https':
            request.using_https = True
        else:
            request.using_https = False
        # monkey patch request.is_secure()
        request.is_secure = lambda: request.using_https
        return None

class BulkChangeLicenseHandler:
    def process_request(self, request):
        # check for authentication,
        # avoid infinite loop
        # allow user to logout (maybe a bit too much...)
        # don't run it for media URLs
        # N.B. probably better just to check for login in the URL
        if request.user.is_authenticated() \
            and not 'bulklicensechange' in request.get_full_path() \
            and not 'logout' in request.get_full_path() \
            and not 'tosacceptance' in request.get_full_path() \
            and not request.get_full_path().startswith(settings.MEDIA_URL):

            user = request.user
            cache_key = "has-old-license-%s" % user.id
            cache_info = cache.get(cache_key)
            
            if cache_info == None or 0 or not isinstance(cache_info, (list, tuple)):
                has_old_license = user.profile.has_old_license
                has_sounds = Sound.objects.filter(user=user).exists()
                cache.set(cache_key, [has_old_license, has_sounds], 2592000) # 30 days cache
                if has_old_license and has_sounds:
                    return HttpResponseRedirect(reverse("bulk-license-change"))
                
            else :
                has_old_license = cache_info[0] 
                has_sounds = cache_info[1]
                #print "CACHE LICENSE: has_old_license=" + str(has_old_license) + " has_sounds=" + str(has_sounds)
                if has_old_license and has_sounds:
                    return HttpResponseRedirect(reverse("bulk-license-change"))


class TosAcceptanceHandler:
    def process_request(self, request):

        if request.user.is_authenticated() \
            and not 'tosacceptance' in request.get_full_path() \
            and not 'logout' in request.get_full_path() \
            and not 'tos_api' in request.get_full_path() \
            and not 'tos_web' in request.get_full_path() \
            and not 'contact' in request.get_full_path() \
            and not 'bulklicensechange' in request.get_full_path() \
            and not request.get_full_path().startswith(settings.MEDIA_URL):

            user = request.user
            cache_key = "has-accepted-tos-%s" % user.id
            cache_info = cache.get(cache_key)
            
            if not cache_info:
                has_accepted_tos = user.profile.accepted_tos
                if not has_accepted_tos:
                    return HttpResponseRedirect(reverse("tos-acceptance"))
                else:
                    cache.set(cache_key, 'yes', 2592000) # 30 days cache
            else:
                # If there is cache it means the terms has been accepted
                pass

########NEW FILE########
__FILENAME__ = admin
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.contrib import admin
from ratings.models import Rating

class RatingAdmin(admin.ModelAdmin):
    raw_id_fields = ('user',)
    list_display = ('user', 'rating', 'created')
    search_fields = ('=user__username', )
    list_filter = ('rating',)

admin.site.register(Rating, RatingAdmin)
########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'Rating'
        db.create_table('ratings_rating', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'])),
            ('rating', self.gf('django.db.models.fields.IntegerField')()),
            ('content_type', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['contenttypes.ContentType'])),
            ('object_id', self.gf('django.db.models.fields.PositiveIntegerField')(db_index=True)),
            ('created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, db_index=True, blank=True)),
        ))
        db.send_create_signal('ratings', ['Rating'])

        # Adding unique constraint on 'Rating', fields ['user', 'content_type', 'object_id']
        db.create_unique('ratings_rating', ['user_id', 'content_type_id', 'object_id'])


    def backwards(self, orm):
        
        # Removing unique constraint on 'Rating', fields ['user', 'content_type', 'object_id']
        db.delete_unique('ratings_rating', ['user_id', 'content_type_id', 'object_id'])

        # Deleting model 'Rating'
        db.delete_table('ratings_rating')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'ratings.rating': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'Rating'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'rating': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        }
    }

    complete_apps = ['ratings']

########NEW FILE########
__FILENAME__ = models
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.contrib.auth.models import User
from django.contrib.contenttypes import generic
from django.contrib.contenttypes.models import ContentType
from django.db import models

class Rating(models.Model):
    user = models.ForeignKey(User)

    rating = models.IntegerField()

    content_type = models.ForeignKey(ContentType)
    object_id = models.PositiveIntegerField(db_index=True)
    content_object = generic.GenericForeignKey()

    created = models.DateTimeField(db_index=True, auto_now_add=True)

    def __unicode__(self):
        return u"%s rated %s - %s: %d" % (self.user, self.content_type, self.content_type, self.rating)

    class Meta:
        unique_together = (('user', 'content_type', 'object_id'),)
        ordering = ('-created',)
########NEW FILE########
__FILENAME__ = ratings
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.template import Library
from django.contrib.contenttypes.models import ContentType
from django.core.urlresolvers import reverse

register = Library()

@register.filter
def rating_url(object, rating):
    content_type = ContentType.objects.get_for_model(object.__class__)
    return reverse("ratings-add", kwargs=dict(content_type_id=content_type.id, object_id=object.id, rating=rating))
########NEW FILE########
__FILENAME__ = urls
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.conf.urls.defaults import patterns, url
import ratings.views as ratings

urlpatterns = patterns('',
    url(r'^add/(?P<content_type_id>\d+)/(?P<object_id>\d+)/(?P<rating>\d)/$', ratings.add, name="ratings-add"),
)
########NEW FILE########
__FILENAME__ = views
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.contrib.auth.decorators import login_required
from django.contrib.contenttypes.models import ContentType
from django.http import HttpResponse
from ratings.models import Rating
from utils.cache import invalidate_template_cache

@login_required
def add(request, content_type_id, object_id, rating):
    rating = int(rating)
    if rating in range(1,6):
        # in order to keep the ratings compatible with freesound 1, we multiply by two...
        rating = rating*2
        content_type = ContentType.objects.get(id=content_type_id)
        try:
            rating_object = Rating.objects.get(user=request.user, object_id=object_id, content_type=content_type)
            rating_object.rating = rating;
            rating_object.save()
        except Rating.DoesNotExist: #@UndefinedVariable
            rating_object = Rating.objects.create(user=request.user, object_id=object_id, content_type=content_type, rating=rating)
        # make sure the rating is seen on the next page load by invalidating the cache for it.
        ct = ContentType.objects.get(id=content_type_id)
        if ct.name == 'sound':
            # invalidate for logged in/not logged in, only for 'OK' sounds
            invalidate_template_cache("sound_header", object_id, True)
            invalidate_template_cache("sound_header", object_id, False)
            invalidate_template_cache("display_sound", object_id, True, 'OK')
            invalidate_template_cache("display_sound", object_id, False, 'OK')
            # if you want to invalidate some other caches for other content types add them here

    return HttpResponse(str(Rating.objects.filter(object_id=object_id, content_type=content_type).count()))

########NEW FILE########
__FILENAME__ = forms
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

import django.forms as forms

    
SEARCH_SORT_OPTIONS_WEB = [
        ("Automatic by relevance", "score desc"),
        ("Duration (long first)", "duration desc"),
        ("Duration (short first)", "duration asc"),
        ("Date added (newest first)", "created desc"),
        ("Date added (oldest first)", "created asc"),
        ("Downloads (most first)", "num_downloads desc"),
        ("Downloads (least first)", "num_downloads asc"),
        ("Rating (highest first)", "avg_rating desc"),
        ("Rating (lowest first)", "avg_rating asc")
    ]

SEARCH_DEFAULT_SORT = "score desc"


class SoundSearchForm(forms.Form):
    q    = forms.CharField(required=False, label='query')
    p    = forms.CharField(required=False, label='page')
    f    = forms.CharField(required=False, label='filter')
    s    = forms.CharField(required=False, label='sort')
    
    def clean_q(self):
        q = self.cleaned_data['q'] 
        return q if q != None else ""  
    
    def clean_f(self):
        f = self.cleaned_data['f'] 
        return f if f != None else ""  
            
    def clean_p(self):
        try:
            p = int(self.cleaned_data['p'])
        except:
            return 1 
        return p if p >= 1 else 1
    
    def clean_s(self):
        s = self.cleaned_data['s']
        for option in self.sort_options:
            if option[0] == s:
                return option[1]
        return SEARCH_DEFAULT_SORT
        
    def __init__(self, sort_options, *args, **kargs):
        super(SoundSearchForm, self).__init__(*args, **kargs)
        self.sort_options = sort_options
########NEW FILE########
__FILENAME__ = models

########NEW FILE########
__FILENAME__ = search
from django import template
from utils.tags import annotate_tags

register = template.Library()

@register.inclusion_tag('search/facet.html', takes_context=True)
def display_facet(context, filter, facet, type):
    facet = annotate_tags([dict(name=f[0], count=f[1]) for f in facet if f[0] != "0"], sort=True, small_size=0.7, large_size=2.0)

    # If the filter is grouping_pack and there are elements which do not contain the chaarcter "_" means that
    # these sounds do not belong to any pack (as goruping pack values should by "packId_packName" if there is a pack
    # or "soundId" if there is no pack assigned. We did this to be able to filter properly in the facets, as pack names
    # are not unique!. What we do then is filter out the facet elements where, only for the case of grouping_pack,
    # the element name is a single number that does not contain the character "_"

    filtered_facet = []
    for element in facet:
        if filter == "grouping_pack":
            if element['name'].count("_") > 0:
                element['display_name'] = element['name'][element['name'].find("_")+1:] # We also modify the dispay name to remove the id
                filtered_facet.append(element)
        else:
            element['display_name'] = element['name']
            filtered_facet.append(element)
    context.update({"facet":filtered_facet, "type":type, "filter":filter})
    return context
########NEW FILE########
__FILENAME__ = views
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.conf import settings
from django.shortcuts import render_to_response
from django.template import RequestContext
from utils.search.solr import Solr, SolrQuery, SolrResponseInterpreter, \
    SolrResponseInterpreterPaginator, SolrException
from settings import DEFAULT_SEARCH_WEIGHTS
from datetime import datetime
import forms
import logging

logger = logging.getLogger("search")
logger_click = logging.getLogger('clickusage')

def search_prepare_sort(sort, options):
    """ for ordering by rating order by rating, then by number of ratings """
    if sort in [x[1] for x in options]:
        if sort == "avg_rating desc":
            sort = [sort, "num_ratings desc"]
        elif  sort == "avg_rating asc":
            sort = [sort, "num_ratings asc"]
        else:
            sort = [sort]
    else:
        sort = [forms.SEARCH_DEFAULT_SORT]
    return sort


def search_prepare_query(search_query,
                         filter_query,
                         sort,
                         current_page,
                         sounds_per_page,
                         id_weight = DEFAULT_SEARCH_WEIGHTS['id'],
                         tag_weight = DEFAULT_SEARCH_WEIGHTS['tag'],
                         description_weight = DEFAULT_SEARCH_WEIGHTS['description'],
                         username_weight = DEFAULT_SEARCH_WEIGHTS['username'],
                         pack_tokenized_weight = DEFAULT_SEARCH_WEIGHTS['pack_tokenized'],
                         original_filename_weight = DEFAULT_SEARCH_WEIGHTS['original_filename'],
                         grouping = False,
                         include_facets = True,
                         grouping_pack_limit = 1,
                         offset = None):
    query = SolrQuery()

    field_weights = []
    if id_weight != 0 :
        field_weights.append(("id", id_weight))
    if tag_weight != 0 :
        field_weights.append(("tag", tag_weight))
    if description_weight != 0 :
        field_weights.append(("description", description_weight))
    if username_weight != 0 :
        field_weights.append(("username", username_weight))
    if pack_tokenized_weight != 0 :
        field_weights.append(("pack_tokenized", pack_tokenized_weight))
    if original_filename_weight != 0 :
        field_weights.append(("original_filename", original_filename_weight))

    query.set_dismax_query(search_query,
                           query_fields=field_weights,)
    if not offset:
        start = (current_page - 1) * sounds_per_page
    else:
        start = offset
    query.set_query_options(start=start, rows=sounds_per_page, field_list=["id"], filter_query=filter_query, sort=sort)

    if include_facets:
        query.add_facet_fields("samplerate", "grouping_pack", "username", "tag", "bitrate", "bitdepth", "type", "channels", "license")
        query.set_facet_options_default(limit=5, sort=True, mincount=1, count_missing=False)
        query.set_facet_options("tag", limit=30)
        query.set_facet_options("username", limit=30)
        query.set_facet_options("grouping_pack", limit=10)
        query.set_facet_options("license", limit=10)

    if grouping:
        query.set_group_field(group_field="grouping_pack")
        query.set_group_options(group_func=None,
            group_query=None,
            group_rows=10,
            group_start=0,
            group_limit=grouping_pack_limit,  # This is the number of documents that will be returned for each group. By default only 1 is returned.
            group_offset=0,
            group_sort=None,
            group_sort_ingroup=None,
            group_format='grouped',
            group_main=False,
            group_num_groups=True,
            group_cache_percent=0)


    return query

def search(request):
    search_query = request.GET.get("q", "")
    filter_query = request.GET.get("f", "")
    filter_query_link_more_when_grouping_packs = filter_query.replace(' ','+')

    try:
        current_page = int(request.GET.get("page", 1))
    except ValueError:
        current_page = 1
    sort = request.GET.get("s", None)
    sort_options = forms.SEARCH_SORT_OPTIONS_WEB


    grouping = request.GET.get("g", "1") # Group by default
    actual_groupnig = grouping
    # If the query is filtered by pack, do not collapse sounds of the same pack (makes no sense)
    # If the query is thourhg ajax (for sources remix editing), do not collapse
    if "pack" in filter_query or request.GET.get("ajax", "") == "1":
        actual_groupnig = ""

    # Set default values
    id_weight = DEFAULT_SEARCH_WEIGHTS['id']
    tag_weight = DEFAULT_SEARCH_WEIGHTS['tag']
    description_weight = DEFAULT_SEARCH_WEIGHTS['description']
    username_weight = DEFAULT_SEARCH_WEIGHTS['username']
    pack_tokenized_weight = DEFAULT_SEARCH_WEIGHTS['pack_tokenized']
    original_filename_weight = DEFAULT_SEARCH_WEIGHTS['original_filename']

    # Parse advanced search options
    advanced = request.GET.get("advanced", "")

    # if advanced search
    if advanced == "1" :
        a_tag = request.GET.get("a_tag", "")
        a_filename = request.GET.get("a_filename", "")
        a_description = request.GET.get("a_description", "")
        a_packname = request.GET.get("a_packname", "")
        a_soundid = request.GET.get("a_soundid", "")
        a_username = request.GET.get("a_username", "")

        # If none is selected use all (so other filter can be appleid)
        if a_tag or a_filename or a_description or a_packname or a_soundid or a_username != "" :

            # Initialize all weights to 0
            id_weight = 0
            tag_weight = 0
            description_weight = 0
            username_weight = 0
            pack_tokenized_weight = 0
            original_filename_weight = 0

            # Set the weights of selected checkboxes
            if a_soundid != "" :
                id_weight = DEFAULT_SEARCH_WEIGHTS['id']
            if a_tag != "" :
                tag_weight = DEFAULT_SEARCH_WEIGHTS['tag']
            if a_description != "" :
                description_weight = DEFAULT_SEARCH_WEIGHTS['description']
            if a_username != "" :
                username_weight = DEFAULT_SEARCH_WEIGHTS['username']
            if a_packname != "" :
                pack_tokenized_weight = DEFAULT_SEARCH_WEIGHTS['pack_tokenized']
            if a_filename != "" :
                original_filename_weight = DEFAULT_SEARCH_WEIGHTS['original_filename']

    # ALLOW "q" empty queries
    #if search_query.strip() == ""

    sort = search_prepare_sort(sort, forms.SEARCH_SORT_OPTIONS_WEB)

    query = search_prepare_query(search_query,
                                 filter_query,
                                 sort,
                                 current_page,
                                 settings.SOUNDS_PER_PAGE,
                                 id_weight,
                                 tag_weight,
                                 description_weight,
                                 username_weight,
                                 pack_tokenized_weight,
                                 original_filename_weight,
                                 grouping = actual_groupnig
                                 )
    
    solr = Solr(settings.SOLR_URL) 
        
    try:
        results = SolrResponseInterpreter(solr.select(unicode(query)))
        paginator = SolrResponseInterpreterPaginator(results, settings.SOUNDS_PER_PAGE)
        num_results = paginator.count
        non_grouped_number_of_results = results.non_grouped_number_of_matches
        page = paginator.page(current_page)
        error = False
       
        # clickusage tracking           
        if settings.LOG_CLICKTHROUGH_DATA:
            request_full_path = request.get_full_path()
            # The session id of an unauthenticated user is different from the session id of the same user when
            # authenticated.
            request.session["searchtime_session_key"] = request.session.session_key
            if results.docs is not None:
                ids = []
                for item in results.docs:
                    ids.append(item["id"])
            logger_click.info("QUERY : %s : %s : %s : %s" %
                                (unicode(request_full_path).encode('utf-8'), request.session.session_key, unicode(ids).encode('utf-8'), unicode(current_page).encode('utf-8')))

    except SolrException, e:
        logger.warning("search error: query: %s error %s" % (query, e))
        error = True
        error_text = 'There was an error while searching, is your query correct?'
    except Exception, e:
        print e
        logger.error("Could probably not connect to Solr - %s" % e)
        error = True
        error_text = 'The search server could not be reached, please try again later.'
    
    if request.GET.get("ajax", "") != "1":
        return render_to_response('search/search.html', locals(), context_instance=RequestContext(request))
    else:
        return render_to_response('search/search_ajax.html', locals(), context_instance = RequestContext(request))

def search_forum(request):
    search_query = request.GET.get("q", "")
    filter_query = request.GET.get("f", "")
    try:
        current_page = int(request.GET.get("page", 1))
    except ValueError:
        current_page = 1
    current_forum_name_slug = request.GET.get("current_forum_name_slug", "").strip()    # for context sensitive search
    current_forum_name = request.GET.get("current_forum_name", "").strip()              # used in breadcrumb  
    sort = ["thread_created asc"]
    
    # Parse advanced search options
    advanced_search = request.GET.get("advanced_search", "")
    date_from = request.GET.get("dt_from", "")
    date_to = request.GET.get("dt_to", "")
    
    # TEMPORAL WORKAROUND!!! to prevent using watermark as the query for forum search.. (in only happens in some situations)
    if "search in " in search_query :
        invalid = 1
    
    if search_query.strip() != "":
        # add current forum
        if current_forum_name_slug.strip() != "":
            filter_query =  "forum_name_slug:" + current_forum_name_slug
            
        # add date range
        if advanced_search == "1" and date_from != "" or date_to != "":
            filter_query = __add_date_range(filter_query, date_from, date_to)
        
        query = SolrQuery()
        query.set_dismax_query(search_query, query_fields=[("thread_title", 4), ("post_body",3), ("thread_author",3), ("forum_name",2)])
        query.set_highlighting_options_default(field_list=["post_body"],
                                               fragment_size=200, 
                                               alternate_field="post_body", # TODO: revise this param
                                               require_field_match=False, 
                                               pre="<strong>", 
                                               post="</strong>")
        query.set_query_options(start=(current_page - 1) * settings.SOUNDS_PER_PAGE,
                                rows=settings.SOUNDS_PER_PAGE, 
                                field_list=["id", 
                                            "forum_name",
                                            "forum_name_slug",
                                            "thread_id", 
                                            "thread_title", 
                                            "thread_author",
                                            "thread_created", 
                                            "post_body",
                                            "post_author",
                                            "post_created", 
                                            "num_posts"],
                                filter_query=filter_query, 
                                sort=sort)
        
        query.set_group_field("thread_title_grouped")
        query.set_group_options(group_limit=3)
        
        solr = Solr(settings.SOLR_FORUM_URL) 
        
        try:
            results = SolrResponseInterpreter(solr.select(unicode(query)))
            paginator = SolrResponseInterpreterPaginator(results, settings.SOUNDS_PER_PAGE)
            num_results = paginator.count
            page = paginator.page(current_page)
            error = False
        except SolrException, e:
            logger.warning("search error: query: %s error %s" % (query, e))
            error = True
            error_text = 'There was an error while searching, is your query correct?'
        except Exception, e:
            logger.error("Could probably not connect to Solr - %s" % e)
            error = True
            error_text = 'The search server could not be reached, please try again later.'
    else:
        results = []
    
    return render_to_response('search/search_forum.html', locals(), context_instance=RequestContext(request))


def get_pack_tags(pack_obj):
    query = SolrQuery()
    query.set_dismax_query('')
    filter_query = 'username:\"%s\" pack:\"%s\"' % (pack_obj.user.username, pack_obj.name)
    #filter_query = 'pack:\"%s\"' % (pack_obj.name,)
    query.set_query_options(field_list=["id"], filter_query=filter_query)
    query.add_facet_fields("tag")
    query.set_facet_options("tag", limit=20, mincount=1)
    solr = Solr(settings.SOLR_URL)

    try:
        results = SolrResponseInterpreter(solr.select(unicode(query)))
    except SolrException, e:
        #logger.warning("search error: query: %s error %s" % (query, e))
        #error = True
        #error_text = 'There was an error while searching, is your query correct?'
        return False
    except Exception, e:
        #logger.error("Could probably not connect to Solr - %s" % e)
        #error = True
        #error_text = 'The search server could not be reached, please try again later.'
        return False

    return results.facets

def __add_date_range(filter_query, date_from, date_to):
    if filter_query != "":
        filter_query += " "
    
    filter_query += "thread_created:["
    date_from = date_from + "T00:00:00Z" if date_from != "" else "*"
    date_to = date_to + "T00:00:00Z]" if date_to != "" else "*]"
    
    return filter_query + date_from + " TO " + date_to

########NEW FILE########
__FILENAME__ = settings
# -*- coding: utf-8 -*-

# Test comment

# Django settings for freesound project.
import os
import datetime
import logging.config

DEBUG = False

TEMPLATE_CONTEXT_PROCESSORS = (
    # 'django.core.context_processors.auth',
    'django.contrib.auth.context_processors.auth',
    'django.core.context_processors.debug',
    'django.core.context_processors.i18n',
    'django.contrib.messages.context_processors.messages',
    'context_processor.context_extra',
)

MIDDLEWARE_CLASSES = (
    'middleware.PermissionDeniedHandler',
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'middleware.TosAcceptanceHandler',
    'middleware.BulkChangeLicenseHandler',
    'middleware.CheckIfRequestIsHttps',
    #'django.middleware.locale.LocaleMiddleware',
    'django.middleware.doc.XViewMiddleware',
    'django.contrib.flatpages.middleware.FlatpageFallbackMiddleware',
    'django.middleware.transaction.TransactionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'middleware.OnlineUsersHandler',
    'utils.corsheaders.middleware.CorsMiddleware',
)

INSTALLED_APPS = (
    'messages',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.admin',
    'django.contrib.flatpages',
    'django.contrib.markup',
    'django.contrib.messages',
    'south',
    'geotags',
    'accounts',
    'comments',
    'ratings',
    'tags',
    'general',
    'support',
    'wiki',
    'favorites',
    'sounds',
    'bookmarks',
    'forum',
    'search',
    'api',
    'django_extensions',
    'tickets',
    'gunicorn',
    'rest_framework',
    'provider.oauth2',
    'apiv2',
    'provider',
    'utils.corsheaders',
    #'test_utils', # Don't use this in production!
)

AUTHENTICATION_BACKENDS = ('accounts.modelbackend.CustomModelBackend',)

TEMPLATE_DIRS = (
    # Myles' template directory is here because it allows him to work on tabasco.
    '/home/mdebastion/templates',
    os.path.join(os.path.dirname(__file__), 'templates'),
)

# Email settings
SERVER_EMAIL = 'noreply@freesound.org'
EMAIL_SUBJECT_PREFIX = '[freesound] '
SEND_BROKEN_LINK_EMAILS = True
DEFAULT_FROM_EMAIL = 'Freesound NoReply <noreply@freesound.org>'
EMAIL_HOST = 'localhost'
EMAIL_PORT = 25

TIME_ZONE = 'Europe/Brussels'

LANGUAGE_CODE = 'en-us'

SITE_ID = 1

USE_X_FORWARDED_HOST = True

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = False

#CACHE_BACKEND = 'memcached://127.0.0.1:11211/'
CACHE_MIDDLEWARE_SECONDS = 300
CACHE_MIDDLEWARE_KEY_PREFIX = 'freesound'

SESSION_ENGINE = "django.contrib.sessions.backends.cached_db"

ROOT_URLCONF = 'urls'

AUTH_PROFILE_MODULE = 'accounts.Profile'
LOGIN_URL = '/home/login/'
LOGOUT_URL = '/home/logout/'
LOGIN_REDIRECT_URL = '/home/'

IGNORABLE_404_STARTS = ('/cgi-bin/', '/_vti_bin', '/_vti_inf', '/favicon')
IGNORABLE_404_ENDS = ('.jsp', 'mail.pl', 'mailform.pl', 'mail.cgi', 'mailform.cgi', '.php', 'similar')

# A tuple of IP addresses, as strings, that:
# See debug comments, when DEBUG is True
INTERNAL_IPS = ['localhost', '127.0.0.1']

# Absolute path to the directory that holds media.
# Example: "/home/media/media.lawrence.com/"
MEDIA_ROOT = os.path.join(os.path.dirname(__file__), 'media')
MEDIA_URL = "/media/"

# URL prefix for admin media -- CSS, JavaScript and images. Make sure to use a
ADMIN_MEDIA_PREFIX = '/media/admin_media/'


FILES_UPLOAD_DIRECTORY = os.path.join(os.path.dirname(__file__), 'uploads')

# urls for which the "lasta ction time" needs updating
LAST_ACTION_TIME_URLS = ('/forum/', )

FREESOUND_RSS = "http://10.55.0.51/?feed=rss2" #"http://blog.freesound.org/?feed=rss2"

FORUM_POSTS_PER_PAGE = 20
FORUM_THREADS_PER_PAGE = 40
SOUND_COMMENTS_PER_PAGE = 5
SOUNDS_PER_PAGE = 15
PACKS_PER_PAGE = 15
REMIXES_PER_PAGE = 10
SOUNDS_PER_API_RESPONSE = 30
MAX_SOUNDS_PER_API_RESPONSE = 100
SOUNDS_PER_DESCRIBE_ROUND = 10
USERFLAG_THRESHOLD_FOR_NOTIFICATION = 3
USERFLAG_THRESHOLD_FOR_AUTOMATIC_BLOCKING = 6
MAX_TICKETS_IN_MODERATION_ASSIGNED_PAGE = 30
SOUNDS_PENDING_MODERATION_PER_PAGE = 8
MAX_UNMODERATED_SOUNDS_IN_HOME_PAGE = 5

# COOKIE_LAW_EXPIRATION_TIME change in freesound.js (now is 360 days)
# $.cookie("cookieConsent", "yes", { expires: 360, path: '/' });


DELETED_USER_ID = 1

LOG_CLICKTHROUGH_DATA = False

DISPLAY_DEBUG_TOOLBAR = False # change this in the local_settings

#-------------------------------------------------------------------------------
# freesound paths and urls:

DATA_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), '../freesound-data/'))
AVATARS_PATH = os.path.join(DATA_PATH, "avatars/")
PREVIEWS_PATH = os.path.join(DATA_PATH, "previews/")
DISPLAYS_PATH = os.path.join(DATA_PATH, "displays/") # waveform and spectrum views
SOUNDS_PATH = os.path.join(DATA_PATH, "sounds/")
PACKS_PATH = os.path.join(DATA_PATH, "packs/")
UPLOADS_PATH = os.path.join(DATA_PATH, "uploads/")
ANALYSIS_PATH = os.path.join(DATA_PATH, "analysis/")

SENDFILE_SECRET_URL = "/secret/"
SOUNDS_SENDFILE_URL = SENDFILE_SECRET_URL + "sounds/"
PACKS_SENDFILE_URL = SENDFILE_SECRET_URL + "packs/"

#-------------------------------------------------------------------------------

STEREOFY_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), '_sandbox/stereofy/stereofy'))

SESSION_COOKIE_DOMAIN = None # leave this until you know what you are doing

ESSENTIA_EXECUTABLE = '/home/fsweb/freesound/essentia/streaming_extractor_freesound'

# APIV2 settings
################

APIV2KEYS_ALLOWED_FOR_APIV1 = True
ALLOW_WRITE_WHEN_SESSION_BASED_AUTHENTICATION = False
APIV2_RESOURCES_REQUIRING_HTTPS = ['apiv2-sound-download',
                                   'apiv2-user-sound-edit',
                                   'apiv2-user-create-bookmark',
                                   'apiv2-user-create-rating',
                                   'apiv2-user-create-comment',
                                   'apiv2-uploads-upload',
                                   'apiv2-uploads-pending',
                                   'apiv2-uploads-describe',
                                   'apiv2-pack-download','apiv2-me',
                                   'apiv2-logout-oauth2-user',
                                   'oauth2:capture',
                                   'oauth2:authorize',
                                   'oauth2:redirect',
                                   'oauth2:access_token',
                                   'api-login']

REST_FRAMEWORK = {
    'PAGINATE_BY': 15,
    'PAGINATE_BY_PARAM': 'page_size',
    'MAX_PAGINATE_BY': 150,
    'DEFAULT_PERMISSION_CLASSES': ('rest_framework.permissions.IsAuthenticated',),
    'DEFAULT_RENDERER_CLASSES': (
        'rest_framework.renderers.JSONRenderer',
        'rest_framework.renderers.BrowsableAPIRenderer',
        'rest_framework.renderers.YAMLRenderer',
        #'rest_framework.renderers.JSONPRenderer',
        'rest_framework.renderers.XMLRenderer',
    ),
    'DEFAULT_THROTTLE_CLASSES': (
        'apiv2.throttling.ClientBasedThrottling',
    ),
}

# Define Api usage limit rates per defined throttling levels
# Possible time units: second, minute, hour or day

APIV2_BASIC_THROTTLING_RATES_PER_LEVELS = {
    0: ['0/day'],  # Client 'disabled'
    1: ['60/minute', '5000/day'],
    2: ['300/minute', '10000/day'],
    99: [],  # No limit of requests
}

APIV2_POST_THROTTLING_RATES_PER_LEVELS = {
    0: ['0/day'],  # Client 'disabled'
    1: ['30/minute', '500/day'],
    2: ['60/minute', '1000/day'],
    99: [],  # No limit of requests
}

# Oauth2 provider settings
OAUTH_EXPIRE_DELTA = datetime.timedelta(seconds=60*60*24)
OAUTH_EXPIRE_CODE_DELTA = datetime.timedelta(seconds=10*60)
OAUTH_SINGLE_ACCESS_TOKEN = True
USE_MINIMAL_TEMPLATES_FOR_OAUTH = True
#OAUTH_ENFORCE_SECURE = True  # We can not use this parameter because it does not work well with our current django version

# Temportal tag recommendation settings
ONLY_RECOMMEND_TAGS_TO_HALF_OF_UPLOADS = False

# Set DATA_URL. You can overwrite this to point to production data ("http://freesound.org/data/") in local settings if needed ;)
DATA_URL = "/data/"

# leave at bottom starting here!
from local_settings import *

TEMPLATE_DEBUG = DEBUG
MANAGERS = ADMINS

# Only cache templates in production
if DEBUG:
    TEMPLATE_LOADERS = (
        'django.template.loaders.filesystem.load_template_source',
        'django.template.loaders.app_directories.load_template_source',
    )
else:
    TEMPLATE_LOADERS = (
        ('django.template.loaders.cached.Loader', (
            'django.template.loaders.filesystem.load_template_source',
            'django.template.loaders.app_directories.load_template_source',
            #'django.template.loaders.eggs.load_template_source',
        )),
    )

AVATARS_URL = DATA_URL + "avatars/"
PREVIEWS_URL = DATA_URL + "previews/"
DISPLAYS_URL = DATA_URL + "displays/"
ANALYSIS_URL = DATA_URL + "analysis/"

if DEBUG and DISPLAY_DEBUG_TOOLBAR:
    MIDDLEWARE_CLASSES += ('debug_toolbar.middleware.DebugToolbarMiddleware',)
    INSTALLED_APPS += ('debug_toolbar',)
    INTERNAL_IPS +=('127.0.0.1', 'localhost')

    DEBUG_TOOLBAR_PANELS = (
        'debug_toolbar.panels.version.VersionDebugPanel',
        'debug_toolbar.panels.timer.TimerDebugPanel',
        'debug_toolbar.panels.settings_vars.SettingsVarsDebugPanel',
        'debug_toolbar.panels.headers.HeaderDebugPanel',
        'debug_toolbar.panels.request_vars.RequestVarsDebugPanel',
        'debug_toolbar.panels.template.TemplateDebugPanel',
        'debug_toolbar.panels.sql.SQLDebugPanel',
        'debug_toolbar.panels.signals.SignalDebugPanel',
        'debug_toolbar.panels.logger.LoggingPanel',
        'debug_toolbar.panels.cache.CacheDebugPanel'
    )

    DEBUG_TOOLBAR_CONFIG = {
        'INTERCEPT_REDIRECTS': False,
    }

MESSAGE_STORAGE = 'django.contrib.messages.storage.cookie.CookieStorage'


# We use the last restart date as a timestamp of the last time freesound web was restarted (lat time
# settings were loaded). We add this variable to the context processor and use it in base.html as a
# parameter for the url of all.css and freesound.js files, so me make sure client browsers update these
# files when we do a deploy (the url changes)
LAST_RESTART_DATE = datetime.datetime.now().strftime("%d%m")


from logger import LOGGING

########NEW FILE########
__FILENAME__ = gaia_wrapper
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

import os, logging, yaml
from gaia2 import DataSet, transform, DistanceFunctionFactory, View, Point, VariableLength
from similarity_settings import *
from similarity_server_utils import generate_structured_dict_from_layout, get_nested_dictionary_value, get_nested_descriptor_names, set_nested_dictionary_value, parse_filter_list
import time


logger = logging.getLogger('similarity')

class GaiaWrapper:

    def __init__(self, indexing_only_mode=False):
        self.indexing_only_mode = indexing_only_mode
        self.index_path                 = INDEX_DIR
        self.original_dataset           = DataSet()
        if not self.indexing_only_mode:
            self.original_dataset_path  = self.__get_dataset_path(INDEX_NAME)
        else:
            self.original_dataset_path  = self.__get_dataset_path(INDEXING_SERVER_INDEX_NAME)
        self.descriptor_names           = {}
        self.metrics                    = {}
        self.view                       = None
        self.transformations_history    = None

        self.__load_dataset()


    def __get_dataset_path(self, ds_name):
        return os.path.join(INDEX_DIR, ds_name + '.db')


    def __load_dataset(self):
        # Loads the dataset, applies transforms if needed and saves. If dataset does not exists, creates an empty one and saves.

        if not os.path.exists(INDEX_DIR):
            os.makedirs(INDEX_DIR)

        # load original dataset
        if os.path.exists(self.original_dataset_path):
            self.original_dataset.load(self.original_dataset_path)
            self.__calculate_descriptor_names()
            if self.original_dataset.size() >= SIMILARITY_MINIMUM_POINTS and not self.indexing_only_mode:

                # if we have loaded a dataset of the correct size but it is unprepared, prepare it
                if self.original_dataset.history().size() <= 0:
                    self.__prepare_original_dataset()
                    self.__normalize_original_dataset()
                    self.original_dataset.save(self.original_dataset_path)

                # if we have loaded a dataset which has not been normalized, normalize it
                normalized = False
                for element in self.original_dataset.history().toPython():
                    if element['Analyzer name'] == 'normalize':
                        normalized = True
                        break
                if not normalized:
                    self.__normalize_original_dataset()
                    self.original_dataset.save(self.original_dataset_path)
                # Save transformation history so we do not need to compute it every time we need it
                self.transformations_history = self.original_dataset.history().toPython()
                # build metrics for the different similarity presets
                self.__build_metrics()
                # create view
                view = View(self.original_dataset)
                self.view = view

            if self.original_dataset.history().size() <= 0:
                logger.info('Dataset loaded, size: %s points' % (self.original_dataset.size()))
            else:
                logger.info('Dataset loaded, size: %s points (%i fixed-length desc., %i variable-length desc.)' % (self.original_dataset.size(), len(self.descriptor_names['fixed-length']), len(self.descriptor_names['variable-length'])))

        else:
            # If there is no existing dataset we create an empty one.
            # For the moment we do not create any distance metric nor a view because search won't be possible until the DB has a minimum of SIMILARITY_MINIMUM_POINTS
            self.original_dataset.save(self.original_dataset_path)
            self.__calculate_descriptor_names()
            logger.info('Created new dataset, size: %s points (should be 0)' % (self.original_dataset.size()))


    def __prepare_original_dataset(self):
        logger.info('Preparing the original dataset.')
        self.original_dataset = self.prepare_original_dataset_helper(self.original_dataset)
        self.__calculate_descriptor_names()

    def __normalize_original_dataset(self):
        logger.info('Normalizing the original dataset.')
        self.original_dataset = self.normalize_dataset_helper(self.original_dataset, self.descriptor_names['fixed-length'])

    def __calculate_descriptor_names(self):
        layout = self.original_dataset.layout()
        all_descriptor_names = layout.descriptorNames()
        fixed_length_descritpor_names = []
        variable_length_descritpor_names = []
        multidimensional_descriptor_names = []

        for name in all_descriptor_names:
            region = layout.descriptorLocation(name)
            if region.lengthType() == VariableLength:
                variable_length_descritpor_names.append(name)
            else:
                fixed_length_descritpor_names.append(name)
                try:
                    if region.dimension() > 1:
                        multidimensional_descriptor_names.append(name)
                except:
                    pass

        self.descriptor_names = {'all': all_descriptor_names,
                                 'fixed-length': fixed_length_descritpor_names,
                                 'variable-length': variable_length_descritpor_names,
                                 'multidimensional': multidimensional_descriptor_names}


    @staticmethod
    def prepare_original_dataset_helper(ds):
        ds = transform(ds, 'FixLength')  # this transformation marks which descriptors are of fixed length, it optimizes things
        ds = transform(ds, 'Cleaner')
        try:
            ds = transform(ds, 'enumerate', {'descriptorNames': ['.tonal.chords_progression']})
        except:
            logger.info('WARNING: enumerate transformation to .tonal.chords_progression could not be performed.')
        return ds

    @staticmethod
    def normalize_dataset_helper(ds, descriptor_names):
        # Add normalization
        normalization_params = {"descriptorNames": descriptor_names, "independent": True, "outliers": -1}
        ds = transform(ds, 'normalize', normalization_params)
        return ds

    def __build_metrics(self):
        for preset in PRESETS:
            logger.info('Bulding metric for preset %s' % preset)
            name = preset
            path = PRESET_DIR + name + ".yaml"
            preset_file = yaml.load(open(path))
            distance = preset_file['distance']['type']
            parameters = preset_file['distance']['parameters']
            search_metric = DistanceFunctionFactory.create(str(distance), self.original_dataset.layout(), parameters)
            self.metrics[name] = search_metric

    def add_point(self, point_location, point_name):
        if self.original_dataset.contains(str(point_name)):
                self.original_dataset.removePoint(str(point_name))

        p = Point()
        if os.path.exists(str(point_location)):
            try:
                p.load(str(point_location))
                p.setName(str(point_name))
                self.original_dataset.addPoint(p)
                msg = 'Added point with name %s. Index has now %i points.' % (str(point_name), self.original_dataset.size())
                logger.info('Added point with name %s. Index has now %i points.' % (str(point_name), self.original_dataset.size()))
            except Exception, e:
                msg = 'Point with name %s could NOT be added (%s).' % (str(point_name), str(e))
                logger.info(msg)
                return {'error': True, 'result': msg, 'status_code': SERVER_ERROR_CODE}
        else:
            msg = 'Point with name %s could NOT be added because analysis file does not exist (%s).' % (str(point_name), str(point_location))
            logger.info(msg)
            return {'error': True, 'result': msg, 'status_code': SERVER_ERROR_CODE}


        if self.original_dataset.size() == SIMILARITY_MINIMUM_POINTS:
            # Do enumerate
            try:
                self.original_dataset = transform(self.original_dataset, 'enumerate', {'descriptorNames': ['.tonal.chords_progression']})
            except:
                logger.info('WARNING: enumerate transformation to .tonal.chords_progression could not be performed.')


        # If when adding a new point we reach the minimum points for similarity, prepare the dataset, save and create view and distance metrics
        #   This will most never happen, only the first time we start similarity server, there is no index created and we add 2000 points.
        if self.original_dataset.size() == SIMILARITY_MINIMUM_POINTS and not self.indexing_only_mode:
            self.__prepare_original_dataset()
            self.__normalize_original_dataset()
            self.transformations_history = self.original_dataset.history().toPython()
            self.save_index(msg="(reaching 2000 points)")

            # build metrics for the different similarity presets
            self.__build_metrics()
            # create view
            view = View(self.original_dataset)
            self.view = view

        return {'error': False, 'result': msg}

    def delete_point(self, point_name):
        if self.original_dataset.contains(str(point_name)):
            self.original_dataset.removePoint(str(point_name))
            logger.info('Deleted point with name %s. Index has now %i points.' % (str(point_name), self.original_dataset.size()))
            return {'error': False, 'result': True}
        else:
            msg = 'Can\'t delete point with name %s because it does not exist.' % str(point_name)
            logger.info(msg)
            return {'error': True, 'result': msg, 'status_code': NOT_FOUND_CODE}

    def get_point(self, point_name):
        logger.info('Getting point with name %s' % str(point_name))
        if self.original_dataset.contains(str(point_name)):
            return self.original_dataset.point(str(point_name))

    def get_all_point_names(self):
        point_names = sorted([int(name) for name in self.original_dataset.pointNames()])
        logger.info('Getting all point names (%i points)' % len(point_names))
        return {'error': False, 'result': point_names}

    def save_index(self, filename=None, msg=""):
        tic = time.time()
        path = self.original_dataset_path
        if filename:
            path = INDEX_DIR + filename + ".db"
        logger.info('Saving index to (%s)...' % path + msg)
        self.original_dataset.save(path)
        toc = time.time()
        logger.info('Finished saving index (done in %.2f seconds, index has now %i points).' % ((toc - tic), self.original_dataset.size()))
        return {'error': False, 'result': path}

    def clear_index_memory(self):

        if self.original_dataset.size() > 0:
            logger.info('Clearing index memory...')
            self.original_dataset.clear()
            self.original_dataset = None
            self.original_dataset = DataSet()
            self.descriptor_names = {}
            self.metrics = {}
            self.view = None
            msg = 'Cleared indexing dataset memory, current dataset has %i points' % self.original_dataset.size()
            logger.info(msg)
            return {'error': False, 'result': msg}
        else:
            msg = 'Not clearing index because dataset size = 0'
            logger.info(msg)
            return {'error': False, 'result': msg}

    def contains(self, point_name):
        logger.info('Checking if index has point with name %s' % str(point_name))
        return {'error': False, 'result': self.original_dataset.contains(point_name)}

    def get_sounds_descriptors(self, point_names, descriptor_names=None, normalization=True, only_leaf_descriptors=False):
        '''
        Returns a list with the descriptor values for all requested point names
        '''

        logger.info('Getting descriptors for points %s' % ','.join([str(name) for name in point_names]))

        # Add dot '.' at the beginning of descriptor names if not present
        if descriptor_names:
            descriptor_names_aux = list()
            for name in descriptor_names:
                if name[0] != '.':
                    descriptor_names_aux.append('.' + name)
                else:
                    descriptor_names_aux.append(name)
            descriptor_names = descriptor_names_aux[:]
        data = dict()
        required_descriptor_names = self.__calculate_complete_required_descriptor_names(descriptor_names, only_leaf_descriptors=only_leaf_descriptors)
        for point_name in point_names:
            sound_descriptors = self.__get_point_descriptors(point_name, required_descriptor_names, normalization)
            if 'error' not in sound_descriptors:
                data[point_name] = sound_descriptors

        return {'error': False, 'result': data}

    def __calculate_complete_required_descriptor_names(self, descriptor_names, only_leaf_descriptors=False):
        if not descriptor_names:
            descriptor_names = self.descriptor_names['all'][:]
        try:
            structured_layout = generate_structured_dict_from_layout(self.descriptor_names['all'][:])
            processed_descriptor_names = []
            for name in descriptor_names:
                nested_descriptors = get_nested_dictionary_value(name.split('.')[1:], structured_layout)
                if not nested_descriptors:
                    processed_descriptor_names.append(name)
                else:
                    if only_leaf_descriptors:
                        # only return descriptors if nested descriptors are statistics
                        if len(set(nested_descriptors.keys()).intersection(['min', 'max', 'dvar2', 'dmean2', 'dmean', 'var', 'dvar', 'mean'])) > 0:
                            for extra_name in nested_descriptors.keys():
                                processed_descriptor_names.append('%s.%s' % (name, extra_name))
                    else:
                        # Return all nested descriptor names
                        extra_names = []
                        get_nested_descriptor_names(nested_descriptors, extra_names)
                        for extra_name in extra_names:
                            processed_descriptor_names.append('%s.%s' % (name, extra_name))
            processed_descriptor_names = list(set(processed_descriptor_names))
            return processed_descriptor_names
        except:
            return {'error': True, 'result': 'Wrong descriptor names, unable to create layout.', 'status_code': BAD_REQUEST_CODE}

    def __get_point_descriptors(self, point_name, required_descriptor_names, normalization=True):

        # Get normalization coefficients to transform the input data (get info from the last
        # transformation which has been a normalization)

        normalization_coeffs = None
        if not normalization:
            trans_hist = self.transformations_history
            for i in range(0, len(trans_hist)):
                if trans_hist[-(i+1)]['Analyzer name'] == 'normalize':
                    normalization_coeffs = trans_hist[-(i+1)]['Applier parameters']['coeffs']

        required_layout = generate_structured_dict_from_layout(required_descriptor_names)
        try:
            p = self.original_dataset.point(str(point_name))
        except:
            return {'error': True, 'result': 'Sound does not exist in gaia index.', 'status_code': NOT_FOUND_CODE}

        for descriptor_name in required_descriptor_names:
            try:
                value = p.value(str(descriptor_name))
                if normalization_coeffs:
                    if descriptor_name in normalization_coeffs:
                        a = normalization_coeffs[descriptor_name]['a']
                        b = normalization_coeffs[descriptor_name]['b']
                        if len(a) == 1:
                            value = float(value - b[0]) / a[0]
                        else:
                            normalized_value = []
                            for i in range(0, len(a)):
                                normalized_value.append(float(value[i]-b[i]) / a[i])
                            value = normalized_value
            except:
                try:
                    value = p.label(str(descriptor_name))
                except:
                    value = 'unknown'

            if descriptor_name[0] == '.':
                descriptor_name = descriptor_name[1:]
            set_nested_dictionary_value(descriptor_name.split('.'), required_layout, value)
        return required_layout


    # SIMILARITY SEARCH (WEB and API)

    def search_dataset(self, query_point, number_of_results, preset_name, offset=0, descriptors_data=None):
        preset_name = str(preset_name)
        results = []
        count = 0
        size = self.original_dataset.size()
        if size < SIMILARITY_MINIMUM_POINTS:
            msg = 'Not enough datapoints in the dataset (%s < %s).' % (size, SIMILARITY_MINIMUM_POINTS)
            logger.info(msg)
            return {'error': True, 'result': msg, 'status_code': SERVER_ERROR_CODE}

        if query_point:
            query_point = str(query_point)
            logger.info('NN search for point with name %s (preset = %s)' % (query_point,preset_name))
            results = []

            if query_point.endswith('.yaml'):
                # The point doesn't exist in the dataset....
                # So, make a temporary point, add all the transformations
                # to it and search for it
                p, p1 = Point(), Point()
                p.load(query_point)
                p1 = self.original_dataset.history().mapPoint(p)
                results = self.view.nnSearch(p1, self.metrics[preset_name]).get(int(number_of_results), offset=int(offset))
                count = self.view.nnSearch(p1, self.metrics[preset_name]).size()
            else:
                if not self.original_dataset.contains(query_point):
                    msg = "Sound with id %s doesn't exist in the dataset." % query_point
                    logger.info(msg)
                    return {'error':True,'result':msg, 'status_code': NOT_FOUND_CODE}
                results = self.view.nnSearch(query_point, self.metrics[preset_name]).get(int(number_of_results), offset=int(offset))
                count = self.view.nnSearch(query_point, self.metrics[preset_name]).size()

        if descriptors_data:
            # Create a point with the data in 'descriptors_data' and search for it
            try:
                logger.info('NN search for point of uploaded file')
                p, p1 = Point(), Point()
                p.loadFromString(yaml.dump(descriptors_data))
                p1 = self.original_dataset.history().mapPoint(p)
                results = self.view.nnSearch(p1, self.metrics[preset_name]).get(int(number_of_results), offset=int(offset))
                count = self.view.nnSearch(p1, self.metrics[preset_name]).size()
            except:
                msg = 'Unable to create gaia point from uploaded file.'
                logger.info(msg)
                return {'error': True, 'result': msg}

        return {'error': False, 'result': {'results': results, 'count': count}}


    # CONTENT-BASED SEARCH (API)
    def query_dataset(self, query_parameters, number_of_results, preset_name, offset=0, target_sound_id=False, use_file_as_target=False, descriptors_data=None):

        size = self.original_dataset.size()
        if size < SIMILARITY_MINIMUM_POINTS:
            msg = 'Not enough datapoints in the dataset (%s < %s).' % (size, SIMILARITY_MINIMUM_POINTS)
            logger.info(msg)
            return {'error': True, 'result': msg, 'status_code': SERVER_ERROR_CODE}

        trans_hist = self.transformations_history
        layout = self.original_dataset.layout()

        # Get normalization coefficients to transform the input data (get info from the last transformation which has
        # been a normalization)
        coeffs = None
        for i in range(0,len(trans_hist)):
            if trans_hist[-(i+1)]['Analyzer name'] == 'normalize':
                coeffs = trans_hist[-(i+1)]['Applier parameters']['coeffs']

        ##############
        # PARSE TARGET
        ##############

        if not use_file_as_target:
            # If the target is a sound id (target_sound_id!=False), we get the point of this sound and set as target.
            # Otherwise we create a point and add the descriptors provided
            if target_sound_id:
                query_point = str(target_sound_id)
                if not self.original_dataset.contains(query_point):
                    msg = "Sound with id %s doesn't exist in the dataset and can not be set as descriptors_target." % query_point
                    logger.info(msg)
                    return {'error':True,'result':msg, 'status_code':NOT_FOUND_CODE}
                else:
                    q = query_point

            else:
                # Transform input params to the normalized feature space and add them to a query point
                # If there are no params specified in the target, the point is set as empty (probably random sounds are returned)
                q = Point()
                q.setLayout(layout)
                feature_names = []
                # If some target has been specified...
                if query_parameters['target'].keys():
                    for param in query_parameters['target'].keys():
                        # Only add numerical parameters. Non numerical ones (like key) are only used as filters
                        if param in coeffs.keys():
                            feature_names.append(str(param))
                            value = query_parameters['target'][param]
                            if coeffs:
                                a = coeffs[param]['a']
                                b = coeffs[param]['b']
                                if len(a) == 1:
                                    norm_value = a[0]*value + b[0]
                                else:
                                    norm_value = []
                                    for i in range(0,len(a)):
                                        norm_value.append(a[i]*value[i]+b[i])
                                #text = str(type(param)) + " " + str(type(norm_value))
                                q.setValue(str(param), norm_value)
                            else:
                                q.setValue(str(param), value)
        else:
            # Target is specified as the attached file
            # Create a point with the data in 'descriptors_data' and search for it
            try:
                p, q = Point(), Point()
                p.loadFromString(yaml.dump(descriptors_data))
                q = self.original_dataset.history().mapPoint(p)
            except:
                msg = 'Unable to create gaia point from uploaded file. Probably the file does not have the required layout.'
                logger.info(msg)
                return {'error': True, 'result': msg, 'status_code':SERVER_ERROR_CODE}

        ##############
        # PARSE FILTER
        ##############

        filter = ""
        # If some filter has been specified...
        if query_parameters['filter']:
            if type(query_parameters['filter'][0:5]) == str:
                filter = query_parameters['filter']
            else:
                filter = parse_filter_list(query_parameters['filter'], coeffs)


        #############
        # DO QUERY!!!
        #############
        if not use_file_as_target:
            if target_sound_id:
                logger.info("Content based search with target: " + str(target_sound_id) + " (sound id) and filter: " + str(filter) )
            else:
                logger.info("Content based search with target: " + str(query_parameters['target']) + " and filter: " + str(filter) )
        else:
            logger.info("Content based search with give analysis file as target.")

        # If target is a sound id or a file, we use the metric of the preset specified in preset parameter. Otherwise we create a
        # metric with the calculated feature_names
        if target_sound_id or use_file_as_target:
            metric = self.metrics[preset_name]
        else:
            metric = DistanceFunctionFactory.create('euclidean', layout, {'descriptorNames': feature_names})

        results = self.view.nnSearch(q, metric, str(filter)).get(int(number_of_results), offset=int(offset))
        count = self.view.nnSearch(q, metric, str(filter)).size()

        return {'error': False, 'result': {'results': results, 'count': count}}


    def api_search(self, target_type, target, filter, preset_name, metric_descriptor_names, num_results, offset, in_ids):

        # Check if index has sufficient points
        size = self.original_dataset.size()
        if size < SIMILARITY_MINIMUM_POINTS:
            msg = 'Not enough datapoints in the dataset (%s < %s).' % (size, SIMILARITY_MINIMUM_POINTS)
            logger.info(msg)
            return {'error': True, 'result': msg, 'status_code': SERVER_ERROR_CODE}

        # Get some dataset parameters that will be useful later
        trans_hist = self.transformations_history
        layout = self.original_dataset.layout()
        coeffs = None  # Get normalization coefficients
        for i in range(0,len(trans_hist)):
            if trans_hist[-(i+1)]['Analyzer name'] == 'normalize':
                coeffs = trans_hist[-(i+1)]['Applier parameters']['coeffs']
                
        # Set query metric
        metric = self.metrics[preset_name]
        if metric_descriptor_names:
            metric = DistanceFunctionFactory.create('euclidean', layout, {'descriptorNames': metric_descriptor_names})

        # Process target
        if target:
            if target_type == 'sound_id':
                query_point = str(target)
                if not self.original_dataset.contains(query_point):
                    msg = "Sound with id %s doesn't exist in the dataset and can not be set as similarity target." % query_point
                    logger.info(msg)
                    return {'error': True, 'result': msg, 'status_code': NOT_FOUND_CODE}
                else:
                    query = query_point

            elif target_type == 'descriptor_values':
                # Transform input params to the normalized feature space and add them to a query point
                # If there are no params specified in the target, the point is set as empty (probably random sounds are returned)
                feature_names = []
                query = Point()
                query.setLayout(layout)
                try:
                    for param in target.keys():
                        # Only add numerical parameters. Non numerical ones (like key) are only used as filters
                        if param in coeffs.keys():
                            feature_names.append(str(param))
                            value = target[param]
                            if coeffs:
                                a = coeffs[param]['a']
                                b = coeffs[param]['b']
                                if len(a) == 1:
                                    norm_value = a[0]*value + b[0]
                                else:
                                    norm_value = []
                                    for i in range(0,len(a)):
                                        norm_value.append(a[i]*value[i]+b[i])
                                query.setValue(str(param), norm_value)
                            else:
                                query.setValue(str(param), value)
                except:
                    return {'error': True, 'result': 'Invalid target (descriptor values could not be correctly parsed)', 'status_code': BAD_REQUEST_CODE}

                # Overwrite metric with present descriptors in target
                metric = DistanceFunctionFactory.create('euclidean', layout, {'descriptorNames': feature_names})

            elif target_type == 'file':
                # Target is specified as the attached file
                # Create a point with the data in 'descriptors_data' and search for it
                target_file_parsing_type = '-'

                try:
                    # Try directly loading the file
                    p, query = Point(), Point()
                    p.loadFromString(yaml.dump(target))
                    query = self.original_dataset.history().mapPoint(p)
                    target_file_parsing_type = 'mapPoint'

                except Exception, e:
                    logger.info('Unable to create gaia point from uploaded file (%s). Trying addind descriptors one by one.' % e)

                    # If does not work load descriptors one by one
                    try:
                        query = Point()
                        query.setLayout(layout)

                        feature_names = []
                        get_nested_descriptor_names(target, feature_names)
                        feature_names = ['.%s' % item for item in feature_names]
                        nonused_features = []

                        for param in feature_names:
                            if param in coeffs.keys():
                                value = get_nested_dictionary_value(param[1:].split('.'), target)
                                if coeffs:
                                    try:
                                        a = coeffs[param]['a']
                                        b = coeffs[param]['b']
                                        if len(a) == 1:
                                            norm_value = a[0]*value + b[0]
                                        else:
                                            norm_value = []
                                            for i in range(0,len(a)):
                                                norm_value.append(a[i]*value[i]+b[i])
                                        query.setValue(str(param[1:]), norm_value)
                                    except:
                                        nonused_features.append(param)
                                else:
                                    query.setValue(str(param[1:]), value)
                            else:
                                nonused_features.append(param)

                        target_file_parsing_type = 'walkDict'

                    except Exception, e:
                        logger.info('Unable to create gaia point from uploaded file and addind descriptors one by one (%s)' % e)
                        return {'error': True, 'result': 'Unable to create gaia point from uploaded file. Probably the file does not have the required layout. Are you using the last version of Essentia\'s Freesound extractor?', 'status_code': SERVER_ERROR_CODE}
        else:
            query = Point()  # Empty target
            query.setLayout(layout)

        # Process filter
        if filter:
            filter = parse_filter_list(filter, coeffs)
        else:
            filter = ""  # Empty filter

        # log
        log_message = 'Similarity search'
        if target:
            if target_type == 'sound_id':
                log_target = '%s (sound id)' % str(target)
            elif target_type == 'descriptor_values':
                log_target = '%s (descriptor values)' % str(target)
            elif target_type == 'file':
                log_target = 'uploaded file (%s)' % target_file_parsing_type
            log_message += ' with target: %s' % log_target
        if filter:
            log_message += ' with filter: %s' % str(filter)
        logger.info(log_message)

        # if in_ids is specified, edit the filter accordingly
        if in_ids:
            if not filter:
                filter = 'WHERE point.id IN ("' + '", "'.join(in_ids) + '")'
            else:
                filter += ' AND point.id IN ("' + '", "'.join(in_ids) + '")'

        # Do query!
        try:
            search = self.view.nnSearch(query, metric, str(filter))
            results = search.get(num_results, offset=offset)
            count = search.size()
        except Exception, e:
            return {'error': True, 'result': 'Similarity server error', 'status_code': SERVER_ERROR_CODE}

        note = None
        if target_type == 'file':
            if target_file_parsing_type == 'walkDict':
                note = 'The layout of the given analysis file differed from what we expected. Similarity results might not be accurate. Was the file generated with the last version of Essentia\'s Freesound extractor?'

        return {'error': False, 'result': {'results': results, 'count': count, 'note': note}}
########NEW FILE########
__FILENAME__ = similarity_indexing_server
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#


'''
The similarity indexing server is a simpler version of the similarity server which can only handle indexing sounds.
This server can be used to index a new dataset in background so whent it is indexed the main similarity service
can be reloaded with the new index.
'''


from twisted.web import server, resource
from twisted.internet import reactor
from gaia_wrapper import GaiaWrapper
from similarity_settings import *
import logging
import graypy
from logging.handlers import RotatingFileHandler
import json


def server_interface(resource):
    return {
        'add_point': resource.add_point,  # location, sound_id
        'clear_memory': resource.clear_memory,
        'reload_gaia_wrapper': resource.reload_gaia_wrapper,
        'save': resource.save,  # filename (optional)
    }

class SimilarityServer(resource.Resource):
    def __init__(self):
        resource.Resource.__init__(self)
        self.methods = server_interface(self)
        self.isLeaf = False
        self.gaia = GaiaWrapper(indexing_only_mode=True)
        self.request = None

    def error(self,message):
        return json.dumps({'Error': message})

    def getChild(self, name, request):
        return self

    def render_GET(self, request):
        return self.methods[request.prepath[1]](request=request, **request.args)

    def add_point(self, request, location, sound_id):
        return json.dumps( self.gaia.add_point(location[0],sound_id[0]))

    def save(self, request, filename=None):
        if not filename:
            filename = [INDEXING_SERVER_INDEX_NAME]
        return json.dumps(self.gaia.save_index(filename[0]))

    def reload_gaia_wrapper(self, request):
        self.gaia = GaiaWrapper(indexing_only_mode=True)
        return json.dumps({'error': False, 'result': 'Gaia wrapper reloaded!'})

    def clear_memory(self, request):
        # Then clear the memory
        return json.dumps(self.gaia.clear_index_memory())

if __name__ == '__main__':
    # Set up logging
    logger = logging.getLogger('similarity')
    logger.setLevel(logging.DEBUG)
    handler = RotatingFileHandler(LOGFILE_INDEXING_SERVER, maxBytes=2*1024*1024, backupCount=5)
    handler.setLevel(logging.DEBUG)
    std_handler = logging.StreamHandler()
    std_handler.setLevel(logging.DEBUG)
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    handler.setFormatter(formatter)
    logger.addHandler(handler)
    std_handler.setFormatter(formatter)
    logger.addHandler(std_handler)
    handler_graypy = graypy.GELFHandler('10.55.0.48', 12201)
    logger.addHandler(handler_graypy)

    # Start service
    logger.info('Configuring similarity INDEXING service...')
    root = resource.Resource()
    root.putChild("similarity", SimilarityServer())
    site = server.Site(root)
    reactor.listenTCP(INDEXING_SERVER_LISTEN_PORT, site)
    logger.info('Started similarity INDEXING service, listening to port ' + str(INDEXING_SERVER_LISTEN_PORT) + "...")
    reactor.run()
    logger.info('Service stopped.')
########NEW FILE########
__FILENAME__ = similarity_server
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from twisted.web import server, resource
from twisted.internet import reactor
from gaia_wrapper import GaiaWrapper
from similarity_settings import LISTEN_PORT, LOGFILE, DEFAULT_PRESET, DEFAULT_NUMBER_OF_RESULTS, INDEX_NAME, PRESETS, BAD_REQUEST_CODE, NOT_FOUND_CODE, SERVER_ERROR_CODE
import logging
import graypy
from logging.handlers import RotatingFileHandler
from similarity_server_utils import parse_filter, parse_target, parse_metric_descriptors
import json
import yaml


def server_interface(resource):
    return {
        'add_point': resource.add_point,  # location, sound_id
        'delete_point': resource.delete_point, # sound_id
        'get_all_point_names': resource.get_all_point_names,
        'get_descriptor_names': resource.get_descriptor_names,
        'contains': resource.contains,  # sound_id
        'get_sounds_descriptors': resource.get_sounds_descriptors,  # sound_ids, descritor_names (optional), normalization (optional)
        'nnsearch': resource.nnsearch,  # sound_id, num_results (optional), preset (optional)
        'nnrange': resource.nnrange,  # target, filter, num_results (optional), preset (optional), in_ids (optional)
        'api_search': resource.api_search,
        'save': resource.save,  # filename (optional)
    }


class SimilarityServer(resource.Resource):
    def __init__(self):
        resource.Resource.__init__(self)
        self.methods = server_interface(self)
        self.isLeaf = False
        self.gaia = GaiaWrapper()
        self.request = None

    def error(self,message):
        return json.dumps({'Error':message})

    def getChild(self, name, request):
        return self

    def render_GET(self, request):
        return self.methods[request.prepath[1]](request=request, **request.args)

    def render_POST(self, request):
        return self.methods[request.prepath[1]](request=request, **request.args)

    def add_point(self, request, location, sound_id):
        return json.dumps( self.gaia.add_point(location[0],sound_id[0]))

    def delete_point(self, request, sound_id):
        return json.dumps(self.gaia.delete_point(sound_id[0]))

    def contains(self, request, sound_id):
        return json.dumps(self.gaia.contains(sound_id[0]))

    def get_all_point_names(self, request):
        return json.dumps(self.gaia.get_all_point_names())

    def get_descriptor_names(self, request):
        return json.dumps({'error': False, 'result': self.gaia.descriptor_names})

    def get_sounds_descriptors(self, request, sound_ids, descriptor_names=None, normalization=[0], only_leaf_descriptors=[0]):
        kwargs = dict()
        if descriptor_names:
            kwargs['descriptor_names'] = [name for name in descriptor_names[0].split(',') if name]
        kwargs['normalization'] = normalization[0] == '1'
        kwargs['only_leaf_descriptors'] = only_leaf_descriptors[0] == '1'
        return json.dumps(self.gaia.get_sounds_descriptors(sound_ids[0].split(','), **kwargs))

    def nnsearch(self, request, sound_id=None, num_results=None, preset=None, offset=[0]):
        descriptors_data = None
        if not sound_id:
            # Check if attached file
            data = request.content.getvalue().split('&')[0]  # If more than one file attached, just get the first one
            if not data:
                return json.dumps({'error': True, 'result': 'Either specify a point id or attach an analysis file.', 'status_code': BAD_REQUEST_CODE})

            # If not sound id but file attached found, parse file and pass as a dict
            sound_id = [None]
            try:
                descriptors_data = yaml.load(data)
            except:
                return json.dumps({'error': True, 'result': 'Analysis file could not be parsed.', 'status_code': BAD_REQUEST_CODE})

        if not preset:
            preset = [DEFAULT_PRESET]
        else:
            if preset[0] not in PRESETS:
                preset = [DEFAULT_PRESET]
        if not num_results:
            num_results = [DEFAULT_NUMBER_OF_RESULTS]

        return json.dumps(self.gaia.search_dataset(sound_id[0], num_results[0], preset_name=preset[0], offset=offset[0], descriptors_data=descriptors_data))

    def nnrange(self, request, target=None, filter=None, num_results=None, offset=[0], preset=None):
        descriptors_data = None
        if not filter:
            if not target:
                # check if instead of a target, an analysis file was attached
                data = request.content.getvalue().split('&')[0]  # If more than one file attached, just get the first one
                if not data:
                    return json.dumps({'error': True, 'result': 'You should at least specify a descriptors_filter, descriptors_target or attach an analysis file for content based search.', 'status_code': BAD_REQUEST_CODE})
                try:
                    descriptors_data = yaml.load(data)
                except:
                    return json.dumps({'error': True, 'result': 'Analysis file could not be parsed.', 'status_code': BAD_REQUEST_CODE})

        if not num_results:
            num_results = [DEFAULT_NUMBER_OF_RESULTS]
        if not preset:
            preset = [DEFAULT_PRESET]
        else:
            if preset[0] not in PRESETS:
                preset = [DEFAULT_PRESET]

        if filter:
            filter = filter[0]
            pf = parse_filter(filter.replace("'", '"'), self.gaia.descriptor_names['fixed-length'])
        else:
            pf = []

        target_sound_id = False
        use_file_as_target = False
        if target:
            target = target[0]
            try:
                # If target can be parsed as an integer, we assume it corresponds to a sound_id
                target_sound_id = int(target)
                pt = {}
            except:
                pt = parse_target(target.replace("'", '"'), self.gaia.descriptor_names['fixed-length'])
        else:
            pt = {}
            if descriptors_data:
                use_file_as_target = True

        if type(pf) != list or type(pt) != dict:
            message = ""
            if type(pf) == str:
                message += pf
            if type(pt) == str:
                message += pt
            if message == "":
                message = "Invalid filter or target."

            return json.dumps({'error': True, 'result': message, 'status_code': BAD_REQUEST_CODE})


        return json.dumps(self.gaia.query_dataset({'target': pt, 'filter': pf},
                                                  num_results[0],
                                                  preset_name=preset[0],
                                                  offset=offset[0],
                                                  target_sound_id=target_sound_id,
                                                  use_file_as_target=use_file_as_target,
                                                  descriptors_data=descriptors_data))

    def api_search(self, request, target_type=None, target=None, filter=None, preset=[DEFAULT_PRESET], metric_descriptor_names=None, num_results=[DEFAULT_NUMBER_OF_RESULTS], offset=[0], in_ids=None):
        '''
        This function is used as an interface to all search-related gaia funcionalities we use in freesound.
        This function allows the definition of a query point that will be used by gaia as the target for the search (i.e.
        gaia will sort the results by similarity according to this point), and a filter to reduce the scope of the search.

        The query point is defined with the target and target_type parameters, and can be either a sound id from the
        gaia index, a list of descriptors with values or the content of a file attached to a post request.
            Ex:
                target=1234
                target_type=sound_id

                target=.lowlevel.pitch.mean:220
                target_type=descriptors_values

                target=.lowlevel.scvalleys.mean:-8.0,-11.0,-13.0,-15.0,-16.0,-15.0
                target_type=descriptors_values

        The filter is defined as a string following the same syntax as solr filter that is then parsed and translated to
        a representation that gaia can understand.
            Ex:
                filter=.lowlevel.pitch.mean:[100 TO *]
                TODO: how to filter multidimensional features

        Along with target and filter other parameters can be specified:
            - preset: set of descriptors that will be used to determine the similarity distance (by default 'lowlevel' preset)
            - metric_descriptor_names*: a list of descriptor names (separated by ,) that will be used as to build the distance metric (preset will be overwritten)
                * this parameter is bypassed with the descriptor_values target type, as the list is automatically built with the descriptors specified in the target
            - num_results, offset: to control the number of returned results and the offset since the first result (so pagination is possible)
        '''

        if in_ids:
            in_ids = in_ids[0].split(',')

        if not target and not filter:
            if target_type:
                if target_type[0] != 'file':
                    return json.dumps({'error': True, 'result': 'At least \'target\' or \'filter\' should be specified.', 'status_code': BAD_REQUEST_CODE})
            else:
                return json.dumps({'error': True, 'result': 'At least \'target\' or \'filter\' should be specified.', 'status_code': BAD_REQUEST_CODE})
        if target and not target_type:
            return json.dumps({'error': True, 'result': 'Parameter \'target_type\' should be specified.', 'status_code': BAD_REQUEST_CODE})
        if target_type:
            target_type = target_type[0]

        if target or target_type == 'file':
            if target_type == 'sound_id':
                try:
                    target = int(target[0])
                except:
                    return json.dumps({'error': True, 'result': 'Invalid sound id.', 'status_code': BAD_REQUEST_CODE})
            elif target_type == 'descriptor_values':
                try:
                    target = parse_target(target[0].replace("'", '"'), self.gaia.descriptor_names['fixed-length'])
                    if type(target) != dict:
                        if type(target) == str:
                            return json.dumps({'error': True, 'result': target, 'status_code': BAD_REQUEST_CODE})
                        else:
                            return json.dumps({'error': True, 'result': 'Invalid descriptor values for target.', 'status_code': BAD_REQUEST_CODE})
                    if not target.items():
                        return json.dumps({'error': True, 'result': 'Invalid target.', 'status_code': BAD_REQUEST_CODE})
                except Exception, e:
                    return json.dumps({'error': True, 'result': 'Invalid descriptor values for target.', 'status_code': BAD_REQUEST_CODE})
            elif target_type == 'file':
                data = request.content.getvalue().split('&')[0]  # If more than one file attached, just get the first one
                if not data:
                    return json.dumps({'error': True, 'result': 'You specified \'file\' as target file but attached no analysis file.', 'status_code': BAD_REQUEST_CODE})
                try:
                    target = yaml.load(data)
                except:
                    return json.dumps({'error': True, 'result': 'Analysis file could not be parsed.', 'status_code': BAD_REQUEST_CODE})
            else:
                return json.dumps({'error': True, 'result': 'Invalid target type.', 'status_code': BAD_REQUEST_CODE})

        if filter:
            try:
                filter = parse_filter(filter[0].replace("'", '"'), self.gaia.descriptor_names['fixed-length'])
                if type(filter) != list:
                    if type(filter) == str:
                        return json.dumps({'error': True, 'result': filter, 'status_code': BAD_REQUEST_CODE})
                    else:
                        return json.dumps({'error': True, 'result': 'Invalid filter.', 'status_code': BAD_REQUEST_CODE})
            except Exception, e:
                return json.dumps({'error': True, 'result': 'Invalid filter.', 'status_code': BAD_REQUEST_CODE})

        if preset:
            if preset[0] not in PRESETS:
                preset = DEFAULT_PRESET
            else:
                preset = preset[0]

        if not num_results[0]:
            num_results = int(DEFAULT_NUMBER_OF_RESULTS)
        else:
            num_results = int(num_results[0])

        if not offset[0]:
            offset = 0
        else:
            offset = int(offset[0])

        if metric_descriptor_names:
            metric_descriptor_names = parse_metric_descriptors(metric_descriptor_names[0], self.gaia.descriptor_names['fixed-length'])

        return json.dumps(self.gaia.api_search(target_type,
                                              target,
                                              filter,
                                              preset,
                                              metric_descriptor_names,
                                              num_results,
                                              offset,
                                              in_ids))


    def save(self, request, filename=None):
        if not filename:
            filename = [INDEX_NAME]

        return json.dumps(self.gaia.save_index(filename[0]))


if __name__ == '__main__':
    # Set up logging
    logger = logging.getLogger('similarity')
    logger.setLevel(logging.DEBUG)
    handler = RotatingFileHandler(LOGFILE, maxBytes=2*1024*1024, backupCount=5)
    handler.setLevel(logging.DEBUG)
    std_handler = logging.StreamHandler()
    std_handler.setLevel(logging.DEBUG)
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    handler.setFormatter(formatter)
    logger.addHandler(handler)
    std_handler.setFormatter(formatter)
    logger.addHandler(std_handler)
    handler_graypy = graypy.GELFHandler('10.55.0.48', 12201)
    logger.addHandler(handler_graypy)

    # Start service
    logger.info('Configuring similarity service...')
    root = resource.Resource()
    root.putChild("similarity", SimilarityServer())
    site = server.Site(root)
    reactor.listenTCP(LISTEN_PORT, site)
    logger.info('Started similarity service, listening to port ' + str(LISTEN_PORT) + "...")
    reactor.run()
    logger.info('Service stopped.')



########NEW FILE########
__FILENAME__ = similarity_server_utils
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#


def parse_filter(filter_string, layout_descriptor_names):
    ALLOWED_CONTENT_BASED_SEARCH_DESCRIPTORS = layout_descriptor_names

    operators = ['OR','AND','(',')']

    # Find ':'
    filter_struct = []

    min_pos = 0
    while filter_string.find(':',min_pos) != -1:
        current_pos = filter_string.find(':',min_pos)
        min_pos = current_pos + 1

        # Left part (feature name)
        previous_space_pos = filter_string.rfind(' ',0,current_pos)
        feature_name = filter_string[previous_space_pos+1:current_pos]
        if feature_name[0] != '.':
            feature_name = '.' + feature_name

        # Right part (value, range)
        if filter_string[current_pos+1] == '[':
            next_space_pos = current_pos + 1
            for i in range(0,3):
                next_space_pos = filter_string.find(' ',next_space_pos + 1)
            right_part = filter_string[current_pos+2:next_space_pos]
            type_val = "RANGE"

        elif filter_string[current_pos+1] == '"':
            next_quote_pos = filter_string.find('"',current_pos + 2)
            right_part = filter_string[current_pos+1:next_quote_pos+1]
            type_val = "STRING"
        else:
            next_space_pos = filter_string.find(' ',current_pos + 1)
            if next_space_pos == -1:
                next_space_pos = len(filter_string)
            right_part = filter_string[current_pos+1:next_space_pos + 1]
            if not "," in right_part:
                type_val = "NUMBER"
            else:
                type_val = "ARRAY"

        for op in operators:
            feature_name = feature_name.replace(op,"")
            right_part = right_part.replace(op,"")

        # Check if the feature name is allowed (if is correct).
        # As filtering in multidimensional descriptors is indicated by (excample) feature.name.3 or feature.name.0, we
        # also check the existence of this feature name by removing the last number (and dot)
        if feature_name not in ALLOWED_CONTENT_BASED_SEARCH_DESCRIPTORS and feature_name.split('[')[0] not in ALLOWED_CONTENT_BASED_SEARCH_DESCRIPTORS:
            return 'Filter error: At least one feature name does not match with any descirptor name in our database or the matched descriptor can not be used in a filter (' + str(feature_name) + '). '

        filter_struct.append({'feature':feature_name,'type':type_val,'value':right_part,'delimiter_position':current_pos,'id':len(filter_struct)+1})

    # Find OPERATORS clauses
    aux_ops = {}
    for op in operators:
        min_pos = 0
        while filter_string.find(op,min_pos) != -1:
            current_pos = filter_string.find(op,min_pos)
            min_pos = current_pos + 1
            aux_ops[current_pos] = op#.append({'op':op,'pos':current_pos})
    keylist = aux_ops.keys()
    keylist.sort()
    for key in keylist:
        op = aux_ops[key]
        current_pos = key

        # Insert OPERATOR clause in appropiate place of filter_struct
        for i,f in enumerate(filter_struct):
            if type(f) == dict:
                if f['delimiter_position'] > current_pos:
                    filter_struct.insert(i,op)
                    break
        if filter_struct[-1]['delimiter_position'] < current_pos:
            filter_struct.append(op)

    # Add AND operators by default (only where there are no other operators between two features)
    final_filter_struct = []
    for i in range(0,len(filter_struct)):
        if i < len(filter_struct) -1:
            if type(filter_struct[i]) == dict and type(filter_struct[i+1]) == dict:
                final_filter_struct.append(filter_struct[i])
                final_filter_struct.append('AND')
            elif type(filter_struct[i]) == dict and filter_struct[i+1] == "(":
                final_filter_struct.append(filter_struct[i])
                final_filter_struct.append('AND')
            elif filter_struct[i] == ")" and type(filter_struct[i+1]) == dict:
                final_filter_struct.append(filter_struct[i])
                final_filter_struct.append('AND')
            else:
                final_filter_struct.append(filter_struct[i])
        else:
            final_filter_struct.append(filter_struct[i])

    # Check good pairing of parenthesis
    if final_filter_struct.count("(") != final_filter_struct.count(")"):
        return "Bad filter syntax."

    # Change values for current types
    for f in final_filter_struct:
        if type(f) == dict:
            if f['type'] == 'NUMBER':
                f['value'] = float(f['value'])
            elif f['type'] == 'ARRAY':
                f['value'] = [float(x) for x in f['value'].split(',')]
            elif f['type'] == 'STRING':
                f['value'] = str(f['value'].replace('sharp','#'))
            elif f['type'] == 'RANGE':
                min_str = f['value'][:f['value'].find("TO")-1]
                if min_str != "*":
                    min_v = float(min_str)
                else:
                    min_v = None
                max_str = f['value'][f['value'].find("TO")+3:].replace(']','')
                if max_str != "*":
                    max_v = float(max_str)
                else:
                    max_v = None
                f['value'] = {'min':min_v,'max':max_v}

    #print final_filter_struct
    return final_filter_struct

def prepend_value_label(f):
    if f['type'] == 'NUMBER' or f['type'] == 'RANGE' or f['type'] == 'ARRAY':
        return "value"
    else:
        return "label"

def parse_filter_list(filter_list, coeffs):

        filter = "WHERE"
        for f in filter_list:
            if type(f) != dict:
                filter += f
            else:
                if f['type'] == 'NUMBER' or f['type'] == 'STRING' or f['type'] == 'ARRAY':

                    if f['type'] == 'NUMBER':
                        if coeffs:
                            if '[' in f['feature']:
                                # if character [ is in feature name it means that is multidimensional filter
                                f_name = f['feature'].split('[')[0]
                                f_dimension = int(f['feature'].split('[')[1].split(']')[0])
                                norm_value = coeffs[f_name]['a'][f_dimension] * f['value'] + coeffs[f_name]['b'][f_dimension]
                            else:
                                norm_value = coeffs[f['feature']]['a'][0] * f['value'] + coeffs[f['feature']]['b'][0]
                        else:
                            norm_value = f['value']
                    elif f['type'] == 'ARRAY':
                        if coeffs:
                            if '[' in f['feature']:
                                # if character [ is in feature name it means that is multidimensional filter
                                f_name = f['feature'].split('[')[0]
                                norm_value = []
                                for i in range(len(f['value'])):
                                    norm_value.append(coeffs[f_name]['a'][i] * f['value'][i] + coeffs[f_name]['b'][i])
                            else:
                                norm_value = []
                                for i in range(len(f['value'])):
                                    norm_value.append(coeffs[f['feature']]['a'][i] * f['value'][i] + coeffs[f['feature']]['b'][i])
                        else:
                            norm_value = f['value']
                    else:
                        norm_value = f['value']
                    filter += " " + prepend_value_label(f) + f['feature'] + "=" + str(norm_value) + " "

                else:
                    filter += " "
                    if f['value']['min'] is not None:
                        if coeffs:
                            if '[' in f['feature']:
                                # if character [ is in feature name it means that is multidimensional filter
                                f_name = f['feature'].split('[')[0]
                                f_dimension = int(f['feature'].split('[')[1].split(']')[0])
                                norm_value = coeffs[f_name]['a'][f_dimension] * f['value']['min'] + coeffs[f_name]['b'][f_dimension]
                            else:
                                norm_value = coeffs[f['feature']]['a'][0] * f['value']['min'] + coeffs[f['feature']]['b'][0]
                        else:
                            norm_value = f['value']['min']
                        filter += prepend_value_label(f) + f['feature'] + ">" + str(norm_value) + " "
                    if f['value']['max'] is not None:
                        if f['value']['min'] is not None:
                            filter += "AND "
                        if coeffs:
                            if '[' in f['feature']:
                                # if character [ is in feature name it means that is multidimensional filter
                                f_name = f['feature'].split('[')[0]
                                f_dimension = int(f['feature'].split('[')[1].split(']')[0])
                                norm_value = coeffs[f_name]['a'][f_dimension] * f['value']['max'] + coeffs[f_name]['b'][f_dimension]
                            else:
                                norm_value = coeffs[f['feature']]['a'][0] * f['value']['max'] + coeffs[f['feature']]['b'][0]
                        else:
                            norm_value = f['value']['max']
                        filter += prepend_value_label(f) + f['feature'] + "<" + str(norm_value) + " "

        return filter


def parse_target(target_string, layout_descriptor_names):
    ALLOWED_CONTENT_BASED_SEARCH_DESCRIPTORS = layout_descriptor_names
    target_struct = {}

    min_pos = 0
    while target_string.find(':',min_pos) != -1:
        current_pos = target_string.find(':',min_pos)
        min_pos = current_pos + 1

        # Left part (feature name)
        previous_space_pos = target_string.rfind(' ',0,current_pos)
        feature_name = target_string[previous_space_pos+1:current_pos]
        if feature_name[0] != '.':
            feature_name = '.' + feature_name

        if feature_name not in ALLOWED_CONTENT_BASED_SEARCH_DESCRIPTORS:
            return 'Target error: At least one feature name does not match with any descirptor name in our database or the matched descriptor can not be used as target (' + str(feature_name) + '). '

        # Right part
        next_space_pos = target_string.find(' ',current_pos + 1)
        if next_space_pos == -1:
            next_space_pos = len(target_string)
        right_part = target_string[current_pos+1:next_space_pos + 1]
        if not "," in right_part:
            value = float(right_part)
        else:
            value = [float(x) for x in right_part.split(',')]

        target_struct[feature_name] = value

    return target_struct


def parse_metric_descriptors(metric_descriptors_string, layout_descriptor_names):
    return list(set(metric_descriptors_string.split(',')).intersection(layout_descriptor_names))


### Functions to generate a structured dictionary from a list of descriptor names

def create_nested_structure_of_dicts_from_list_of_keys(dict, keys):
    dict_aux = dict
    for count, key in enumerate(keys):
        if key not in dict_aux:
            if count == len(keys) - 1:
                dict_aux[key] = None
            else:
                dict_aux[key] = {}
        dict_aux = dict_aux[key]

def generate_structured_dict_from_layout(layout_descriptor_names):
    names = sorted(layout_descriptor_names)
    structure = dict()
    for name in names:
        create_nested_structure_of_dicts_from_list_of_keys(structure, name.split('.')[1:])
    return structure

def get_nested_dictionary_value(keys, dict):
    if len(keys) == 1:
        return dict[keys[0]]
    else:
        return get_nested_dictionary_value(keys[1:], dict[keys[0]])

def set_nested_dictionary_value(keys, dict, value):
    if len(keys) == 1:
        dict[keys[0]] = value
    else:
        set_nested_dictionary_value(keys[1:], dict[keys[0]], value)

def get_nested_descriptor_names(structured_layout, accumulated_list=[], keys=[]):
    for key, item in structured_layout.items():
        if type(item) == dict:
            keys.append(key)
            get_nested_descriptor_names(item, accumulated_list, keys)
        else:
            keys.append(key)
            accumulated_list.append('.'.join(keys))
        keys.pop()

########NEW FILE########
__FILENAME__ = similarity_settings.example
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

import os
# NOTE: In production and test this file is taken from the deploy repository

# SERVER SETTINGS
INDEX_DIR                   = '/home/fsweb/freesound/freesound-similarity/'
INDEX_NAME                  = 'fs_index'
INDEXING_SERVER_INDEX_NAME  = 'background_index'
PRESET_DIR                  = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'presets/')
PRESETS                     = ['lowlevel']
DEFAULT_PRESET              = "lowlevel"
SIMILARITY_MINIMUM_POINTS   = 2000
LOGFILE                     = '/var/log/freesound/similarity.log'
LOGFILE_INDEXING_SERVER     = '/var/log/freesound/similarity_indexing.log'
LISTEN_PORT                 = 8008
INDEXING_SERVER_LISTEN_PORT = 8009

# CLIENT SETTINGS (to be moved to django settings?)
SIMILARITY_ADDRESS               = 'localhost'
SIMILARITY_PORT                  = 8008
SIMILARITY_INDEXING_SERVER_PORT  = 8009

# OTHER
SIMILAR_SOUNDS_TO_CACHE = 100
SIMILARITY_CACHE_TIME = 60*60*1
DEFAULT_NUMBER_OF_RESULTS = 15

BAD_REQUEST_CODE = 400
SERVER_ERROR_CODE = 500
NOT_FOUND_CODE = 404
########NEW FILE########
__FILENAME__ = admin
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.contrib import admin
from sounds.models import Download, License, Sound, Pack, Flag, DeletedSound

class LicenseAdmin(admin.ModelAdmin):
    list_display = ('name', 'deed_url', 'legal_code_url', 'change_order')

admin.site.register(License, LicenseAdmin)


class SoundAdmin(admin.ModelAdmin):
    fieldsets = ((None, {'fields': ('user', )}),
                 #('Filenames', {'fields': ('original_path', 'base_filename_slug')}),
                 ('Filenames', {'fields': ('base_filename_slug',)}),
                 ('User defined fields', {'fields': ('description', 'license', 'original_filename', 'sources', 'pack')}),
                 ('File properties', {'fields': ('md5', 'type', 'duration', 'bitrate', 'bitdepth', 'samplerate', 'filesize', 'channels', 'date_recorded')}),
                 ('Moderation', {'fields': ('moderation_state', 'moderation_date', 'has_bad_description')}),
                 ('Processing', {'fields': ('processing_state', 'processing_date', 'processing_log', 'analysis_state', 'similarity_state')}),
                 )
    raw_id_fields = ('user', 'pack', 'sources')
    list_display = ('id', 'user', 'original_filename', 'license', 'created', 'moderation_state')
    list_filter = ('moderation_state', 'license', 'processing_state')
admin.site.register(Sound, SoundAdmin)

class DeletedSoundAdmin(admin.ModelAdmin):
    raw_id_fields = ('user',)
    list_display = ('sound_id', 'user')
admin.site.register(DeletedSound, DeletedSoundAdmin)

class PackAdmin(admin.ModelAdmin):
    raw_id_fields = ('user',)
    list_display = ('user', 'name', 'created')
admin.site.register(Pack, PackAdmin)


class FlagAdmin(admin.ModelAdmin):
    raw_id_fields = ('reporting_user', 'sound')
    list_display = ('reporting_user', 'email', 'reason_type')
admin.site.register(Flag, FlagAdmin)
########NEW FILE########
__FILENAME__ = forms
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django import forms
from django.db.models import Q
from django.forms import ModelForm, Textarea, TextInput
from sounds.models import License, Flag, Pack, Sound
from utils.forms import TagField, HtmlCleaningCharField
from utils.mail import send_mail_template
from utils.forms import RecaptchaForm
import re

class GeotaggingForm(forms.Form):
    remove_geotag = forms.BooleanField(required=False)
    lat = forms.FloatField(min_value=-90, max_value=90, required=False)
    lon = forms.FloatField(min_value=-180, max_value=180, required=False)
    zoom = forms.IntegerField(min_value=11, error_messages={'min_value': "You should zoom in more until you reach at least zoom 11."}, required=False)

    def clean(self):
        data = self.cleaned_data

        if not data.get('remove_geotag'):
            lat = data.get('lat', False)
            lon = data.get('lon', False)
            zoom = data.get('zoom', False)

            # second clause is to detect when no values were submitted.
            # otherwise doesn't work in the describe workflow
            if (not (lat and lon and zoom)) and (not (not lat and not lon and not zoom)):
                raise forms.ValidationError('There are missing fields or zoom level is not enough.')

        return data


class SoundDescriptionForm(forms.Form):
    name = forms.CharField(max_length=512, min_length=5,
                           widget=forms.TextInput(attrs={'size': 65, 'class':'inputText'}))
    tags = TagField(widget=forms.Textarea(attrs={'cols': 80, 'rows': 3}),
                    help_text="<br>Separate tags with spaces. Join multi-word tags with dashes. For example: field-recording is a popular tag.")
    description = HtmlCleaningCharField(widget=forms.Textarea(attrs={'cols': 80, 'rows': 10}))


class RemixForm(forms.Form):
    sources = forms.CharField(min_length=1, widget=forms.widgets.HiddenInput(), required=False)

    def __init__(self, sound, *args, **kwargs):
        self.sound = sound
        super(RemixForm, self).__init__(*args, **kwargs)

    def clean_sources(self):
        sources = re.sub("[^0-9,]", "", self.cleaned_data['sources'])
        sources = re.sub(",+", ",", sources)
        sources = re.sub("^,+", "", sources)
        sources = re.sub(",+$", "", sources)
        if len(sources) > 0:
            sources = set([int(source) for source in sources.split(",")])
        else:
            sources = set()

        return sources

    def save(self):
        #print "before save", ",".join([str(source.id) for source in self.sound.sources.all()])

        new_sources = self.cleaned_data['sources']

        old_sources = set(source["id"] for source in self.sound.sources.all().values("id"))

        try:
            new_sources.remove(self.sound.id) # stop the universe from collapsing :-D
        except KeyError:
            pass

        for id in old_sources - new_sources: # in old but not in new
            try:
                source = Sound.objects.get(id=id)
                self.sound.sources.remove(source)
                
                # modify remix_group
                
                
                send_mail_template(
                    u'Sound removed as remix source', 'sounds/email_remix_update.txt',
                    {'source': source, 'action': 'removed', 'remix': self.sound},
                    None, source.user.email
                )
            except Sound.DoesNotExist:
                pass
            except Exception, e:
                # Report any other type of exception and fail silently
                print ("Problem removing source from remix or sending mail: %s" \
                     % e)

        for id in new_sources - old_sources: # in new but not in old
            source = Sound.objects.get(id=id)
            self.sound.sources.add(source)
            try:
                send_mail_template(
                    u'Sound added as remix source', 'sounds/email_remix_update.txt',
                    {'source': source, 'action': 'added', 'remix': self.sound},
                    None, source.user.email
                )
            except Exception, e:
                # Report any exception but fail silently
                print ("Problem sending mail about source added to remix: %s" \
                     % e)


        #print "after save", ",".join([str(source.id) for source in self.sound.sources.all()])


class PackChoiceField(forms.ModelChoiceField):
    def label_from_instance(self, pack):
        return pack.name


class PackForm(forms.Form):
    pack = PackChoiceField(label="Change pack or remove from pack:", queryset=Pack.objects.none(), required=False)
    new_pack = HtmlCleaningCharField(widget=forms.TextInput(attrs={'size': 45}), label="Or fill in the name of a new pack:", required=False, min_length=1)

    def __init__(self, pack_choices, *args, **kwargs):
        super(PackForm, self).__init__(*args, **kwargs)
        self.fields['pack'].queryset = pack_choices.extra(select={'lower_name': 'lower(name)'}).order_by('lower_name')

    # Uncomment the following code to not allow duplicate names in packs (if they belong to different users)
    # What has to be unique is the pair username-packname
    '''
    def clean_new_pack(self):
        try:
            Pack.objects.get(name=self.cleaned_data['new_pack'])
            raise forms.ValidationError('This pack name already exists!')
        except Pack.DoesNotExist: #@UndefinedVariable
            return self.cleaned_data['new_pack']
    '''

class PackDescriptionForm(ModelForm):
    
    class Meta:
        model = Pack
        fields = ('description',)
        widgets = {
            'description': Textarea(attrs={'rows': 5, 'cols':60}),
        }

class PackEditForm(ModelForm):
    pack_sounds = forms.CharField(min_length=1, widget=forms.widgets.HiddenInput(attrs={'id':'pack_sounds','name':'pack_sounds'}), required=False)

    def clean_pack_sounds(self):
        pack_sounds = re.sub("[^0-9,]", "", self.cleaned_data['pack_sounds'])
        pack_sounds = re.sub(",+", ",", pack_sounds)
        pack_sounds = re.sub("^,+", "", pack_sounds)
        pack_sounds = re.sub(",+$", "", pack_sounds)

        if len(pack_sounds) > 0:
            pack_sounds = set([int(sound) for sound in pack_sounds.split(",")])
        else:
            pack_sounds = set()

        return pack_sounds

    def save(self, force_insert=False, force_update=False, commit=True):
        pack = super(PackEditForm, self).save(commit=False)
        new_sounds = self.cleaned_data['pack_sounds']
        current_sounds = [s.id for s in pack.sound_set.all()]

        for snd in current_sounds:
            if snd not in new_sounds:
                pack.sound_set.remove(snd)
        for snd in new_sounds:
            if snd not in current_sounds:
                sound = Sound.objects.get(id=snd)
                pack.sound_set.add(sound)

        if commit:
            pack.save()
        pack.process()
        return pack


    class Meta:
        model = Pack
        fields = ('name','description',)
        widgets = {
            'name': TextInput(),
            'description': Textarea(attrs={'rows': 5, 'cols':50}),
        }



class LicenseForm(forms.Form):
    license = forms.ModelChoiceField(queryset=License.objects.filter(is_public=True), required=True, empty_label=None)

    def clean_license(self):
        if self.cleaned_data['license'].abbreviation == "samp+":
            raise forms.ValidationError('We are in the process of slowly removing this license, please choose another one.')
        return self.cleaned_data['license']


class NewLicenseForm(forms.Form):
    license = forms.ModelChoiceField(queryset=License.objects.filter(Q(name__startswith='Attribution') | Q(name__startswith='Creative')),
                                     required=True)

class FlagForm(RecaptchaForm):
    email = forms.EmailField(label="Your email", required=True, 
            help_text="Required.", error_messages={'required' : 'Required, please enter your email address.',
            'invalid' : 'Your email address appears to be invalid, please check if it\'s correct.'})
    reason_type = forms.ChoiceField(choices=Flag.REASON_TYPE_CHOICES,required=True , label='Reason type')
    reason = forms.CharField(widget=forms.Textarea)

    def save(self):
        f = Flag()
        f.reason_type = self.cleaned_data['reason_type']
        f.reason = self.cleaned_data['reason']
        return f #sound and user are set in view

########NEW FILE########
__FILENAME__ = analyze_all
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.core.management.base import BaseCommand
from sounds.models import Sound
import gearman
import settings

class Command(BaseCommand):
    help = 'Analyze all sounds that have passed moderation and have already been analyzed OK. This command is intended to run it when a new essentia extractor is deployed'


    def handle(self, *args, **options):
        gm_client = gearman.GearmanClient(settings.GEARMAN_JOB_SERVERS)
        for sound in Sound.objects.filter(analysis_state='OK',moderation_state='OK'):
            # we avoid saving the sound as currently this triggers crc calculation
            # also with wait_until_complete=True we avoid processing all sounds at once in gm client machine
            gm_client.submit_job("analyze_sound", str(sound.id), wait_until_complete=True, background=True)
########NEW FILE########
__FILENAME__ = clean_solr_forum_index
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.core.management.base import BaseCommand
from forum.models import Post
from utils.search.solr import Solr, SolrResponseInterpreter, SolrQuery
import settings
import sys

def list_of_dicts_to_list_of_ids(ldicts):
    return [x['id'] for x in ldicts]


class Command(BaseCommand):
    args = ''
    help = 'Get ids from solr forum index and remove the ones corresponding the forums that are NOT in the PG db'

    def handle(self, *args, **options):

        LIMIT = None
        SLICE_SIZE = 500
        solr_post_ids = []
        solr = Solr(url=settings.SOLR_FORUM_URL)
        query = SolrQuery()
        query.set_dismax_query("") # Query to get ALL forums

        print "Retrieving ids from %i to %i"%(0,SLICE_SIZE)
        query.set_query_options(field_list=["id"], rows = SLICE_SIZE, start = 0)
        results = SolrResponseInterpreter(solr.select(unicode(query)))
        solr_post_ids += list_of_dicts_to_list_of_ids(results.docs)
        total_num_documents = results.num_found

        # Start iterating over other pages (slices)
        if LIMIT:
            number_of_documents = min(LIMIT,total_num_documents)
        else:
            number_of_documents = total_num_documents

        for i in range(SLICE_SIZE,number_of_documents,SLICE_SIZE):
            print "Retrieving ids from %i to %i"%(i,i+SLICE_SIZE-1)
            query.set_query_options(field_list=["id"], rows = SLICE_SIZE, start = i)
            results = SolrResponseInterpreter(solr.select(unicode(query)))
            solr_post_ids += list_of_dicts_to_list_of_ids(results.docs)

        solr_post_ids = sorted(list(set(solr_post_ids)))
        if LIMIT:
            solr_post_ids = solr_post_ids[0:LIMIT]
        print "%i document ids retrieved"%len(solr_post_ids)
        n_deleted = 0
        print ""
        for count,id in enumerate(solr_post_ids):
            sys.stdout.write("\rChecking doc %i of %i"%(count,len(solr_post_ids)))
            sys.stdout.flush()

            if Post.objects.filter(id=id,moderation_state="OK").exists():
                pass
            else:
                # Post does not exist in the Db or is not properly moderated and processed
                print "\n\t - Deleting forum with id %i from solr index"%id
                solr.delete_by_id(id)
                n_deleted += 1

        print "\n\nDONE! %i forums deleted from solr index (it may take some minutes to actually see the changes in the page)"%n_deleted





########NEW FILE########
__FILENAME__ = clean_solr_sounds_index
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.core.management.base import BaseCommand
from sounds.models import Sound
from utils.search.solr import Solr, SolrResponseInterpreter, SolrQuery
import settings
import sys

def list_of_dicts_to_list_of_ids(ldicts):
    return [x['id'] for x in ldicts]


class Command(BaseCommand):
    args = ''
    help = 'Get ids from solr index and remove the ones corresponding the sounds that are NOT in the PG db'

    def handle(self, *args, **options):

        LIMIT = None
        SLICE_SIZE = 500
        solr_sound_ids = []
        solr = Solr(url=settings.SOLR_URL)
        query = SolrQuery()
        query.set_dismax_query("") # Query to get ALL sounds

        print "Retrieving ids from %i to %i"%(0,SLICE_SIZE)
        query.set_query_options(field_list=["id"], rows = SLICE_SIZE, start = 0)
        results = SolrResponseInterpreter(solr.select(unicode(query)))
        solr_sound_ids += list_of_dicts_to_list_of_ids(results.docs)
        total_num_documents = results.num_found

        # Start iterating over other pages (slices)
        if LIMIT:
            number_of_documents = min(LIMIT,total_num_documents)
        else:
            number_of_documents = total_num_documents

        for i in range(SLICE_SIZE,number_of_documents,SLICE_SIZE):
            print "Retrieving ids from %i to %i"%(i,i+SLICE_SIZE)
            query.set_query_options(field_list=["id"], rows = SLICE_SIZE, start = i)
            results = SolrResponseInterpreter(solr.select(unicode(query)))
            solr_sound_ids += list_of_dicts_to_list_of_ids(results.docs)

        solr_sound_ids = sorted(list(set(solr_sound_ids)))
        if LIMIT:
            solr_sound_ids = solr_sound_ids[0:LIMIT]
        print "%i document ids retrieved"%len(solr_sound_ids)
        n_deleted = 0
        print ""
        for count,id in enumerate(solr_sound_ids):
            sys.stdout.write("\rChecking doc %i of %i"%(count,len(solr_sound_ids)))
            sys.stdout.flush()

            if Sound.objects.filter(id=id,moderation_state="OK",processing_state="OK").exists():
                pass
            else:
                # Sound does not exist in the Db or is not properly moderated and processed
                print "\n\t - Deleting sound with id %i from solr index"%id
                solr.delete_by_id(id)
                n_deleted += 1

        print "\n\nDONE! %i sounds deleted from solr index (it may take some minutes to actually see the changes in the page)"%n_deleted





########NEW FILE########
__FILENAME__ = create_front_page_caches
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.core.management.base import NoArgsCommand
from django.conf import settings
from django.template.loader import render_to_string
from django.core.cache import cache

class Command(NoArgsCommand):
    help = "Create front page RSS and Pledgie cache."

    def handle(self, **options):
        rss_url = settings.FREESOUND_RSS
        pledgie_campaign = settings.PLEDGIE_CAMPAIGN
        
        rss_cache = render_to_string('rss_cache.html', locals())
        cache.set("rss_cache", rss_cache, 2592000) # 30 days cache

        pledgie_cache = render_to_string('pledgie_cache.html', locals())
        cache.set("pledgie_cache", pledgie_cache, 2592000) # 30 days cache
########NEW FILE########
__FILENAME__ = create_remix_groups
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from __future__ import division
from django.core.management.base import BaseCommand
from django.db import connection
from networkx import nx
from pprint import pprint as pp
from sounds.models import Sound, RemixGroup
import json

# TODO: 1) test me!!! if sound not found in more than 1 groups we should be OK
#       2) save to RemixGroup model
#       3) group number?
class Command(BaseCommand):
    args = ''
    help = 'Create the groups used for rendering the global remix page'

    def handle(self, *args, **options):
        # 1) Get all the sounds that have remixes
        cursor = connection.cursor()
        cursor.execute("""
                        SELECT
                            src.from_sound_id AS from,
                            src.to_sound_id AS to,
                            snd.created AS created
                        FROM
                            sounds_sound_sources src,
                            sounds_sound snd
                        WHERE
                            src.to_sound_id = snd.id
                        ORDER BY
                            snd.created ASC
                        """)

        # 2) Create directed graph
        dg = nx.DiGraph()
        for row in cursor:
            dg.add_edge(row[0], row[1])

        # 3) Add date to nodes for sorting (FIXME: how can we avoid this query???)
        """
        for node in dg.nodes():
            cursor.execute("SELECT snd.created, snd.original_filename, au.username " \
                           "FROM sounds_sound snd, auth_user au WHERE au.id=snd.user_id AND snd.id = %s", [node])
            temp = cursor.fetchone()
            dg.add_node(node, {'date':temp[0],
                               'nodeName': temp[1],
                               'username': temp[2]})
        """
        dg = _create_nodes(dg)
        
        # print dg.nodes(data=True)
        # 4) Find weakly connected components (single direction)
        subgraphs = nx.weakly_connected_component_subgraphs(dg)
        node_list = []
        
        # 5) delete all remixgroup objects to recalculate
        RemixGroup.objects.all().delete()
        
        # 6) Loop through all connected graphs in the dataset
        #    and create the groups
        for sg in subgraphs:
            # _create_and_save_remixgroup(sg_idx, sg)
            _create_and_save_remixgroup(sg, RemixGroup())
            
            """
            print ' ========== NODES ========='
            pp(nodes)
            print ' ========== LINKS ========='
            pp(links)
            """

def _create_nodes(dg):
    for node in dg.nodes():
        sound = Sound.objects.get(id=node)
        dg.add_node(node, {'date': sound.created,
						   'nodeName': sound.original_filename,
                           'username': sound.user.username,
                           'sound_url_mp3': sound.locations()['preview']['LQ']['mp3']['url'],
                           'sound_url_ogg': sound.locations()['preview']['LQ']['ogg']['url'],
                           'waveform_url': sound.locations()['display']['wave']['M']['url']})
    return dg

def _create_and_save_remixgroup(sg, remixgroup): 
    # print ' ========================================= '
    # add to list the subgraphs(connected components) with the extra data
    node_list = sg.nodes(data=True)
    # pp(node_list)

    # sort by date (holds all subgraph nodes sorted by date)
    # we need this since we go forward in time (source older than remix)
    node_list.sort(key=lambda x: x[1]['date']) # I think ['date'] is not necessary
    # print ' ========== SORTED NODE_LIST ========= '
    # pp(node_list)

    # dict with key=sound_id, value=index, nodeName=original_filname
    # in the previous sorted by date list
    # FIXME: no need for all this data, can be simple dict, key=value
    container = dict((val[0], {'index': idx, 'nodeName': val[1]['nodeName']}) for (idx, val) in enumerate(node_list))
    # print ' ========== CONTAINER ========= '
    # pp(container)

    links = []
    remixgroup.save()   # need to save to have primary key before ManyToMany
    # FIXME: no idea why nx.weakly_connected_components(sg) return list in list...
    remixgroup.sounds = set(nx.weakly_connected_components(sg)[0])
    remixgroup.group_size = len(node_list)
    # FIXME: seems like double work here, maybe convert container to list and sort?
    nodes = [{'id': val[0],
              'username': val[1]['username'],
              'nodeName': val[1]['nodeName'],
              'sound_url_mp3': val[1]['sound_url_mp3'],
              'sound_url_ogg': val[1]['sound_url_ogg'],
              'waveform_url': val[1]['waveform_url'],
              'group': 1} for (idx, val) in enumerate(node_list)]
    for line in nx.generate_adjlist(sg):
        # print line
        if len(line.split()) > 1:
            for i, l in enumerate(line.strip().split(" ")):
                # index 0 is the source, which we already know
                if i > 0:
                    link = {'target': container[int(line.split(" ")[0])]['index'],
                            'source': container[int(l)]['index']}
                    links.append(link)
                    #print link
    remixgroup.protovis_data = "{\"color\": \"#F1D9FF\"," \
                               "\"length\":" + str(len(node_list)) + "," \
                               "\"nodes\": " + json.dumps(nodes) + "," \
                               "\"links\": " + json.dumps(links) + "}"
                               
    remixgroup.networkx_data = json.dumps(dict(nodes=sg.nodes(), edges=sg.edges()))                         
    remixgroup.save()   
    print remixgroup.id
    print remixgroup.networkx_data

########NEW FILE########
__FILENAME__ = csv_bulk_upload
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.core.management.base import BaseCommand
from django.contrib.auth.models import User
from django.conf import settings
from sounds.models import Sound, Pack, License
from utils.audioprocessing import get_sound_type
from geotags.models import GeoTag
from utils.filesystem import md5file
from utils.text import slugify
import shutil,os,csv

class Command(BaseCommand):
    args = ''
    help = 'Upload many sounds at once'

    def handle(self, *args, **options):
        sound_list = args[0]
        base_dir = os.path.dirname(sound_list)
        delete_already_existing = False
        if len(args) > 1:
            delete_already_existing = bool(args[1])

        isHeader = True
        for line in csv.reader(open(sound_list,'rU')):
            if isHeader:
                isHeader = False
                continue

            # 0 get data from csv
            pathf,namef,tagsf,geotagf,descriptionf,licensef,packnamef,usernamef = line
            u = User.objects.get(username=usernamef)

            # 1 create dir and move sound to dir
            directory = os.path.join(settings.UPLOADS_PATH, str(u.id))
            if not os.path.exists(directory):
                os.mkdir(directory)
            src_path = base_dir + "/"+ pathf
            dest_path = os.path.join(directory, os.path.basename(pathf))
            #print src_path,dest_path

            shutil.copy(src_path,dest_path)

            # 2 make sound object
            # user id (search), original_fname(name),path (new), filesize,type,slicense
            sound = Sound()
            sound.user = u
            sound.original_filename = namef
            sound.original_path = dest_path
            sound.filesize = os.path.getsize(sound.original_path)
            sound.type = get_sound_type(sound.original_path)
            # License format
            # name: 'Creative Commons 0'
            # name: 'Attribution'
            # name: 'Attribution Noncommercial'
            l = License.objects.get(name=licensef)
            sound.license = l

            # 3 md5, check
            try:
                sound.md5 = md5file(sound.original_path)
            except IOError:
                #messages.add_message(request, messages.ERROR, 'Something went wrong with accessing the file %s.' % sound.original_path)
                continue

            sound_already_exists = Sound.objects.filter(md5=sound.md5).exists()
            if sound_already_exists:
                if delete_already_existing:
                    existing_sound = Sound.objects.get(md5=sound.md5)
                    existing_sound.delete()
                    print 'The file %s is already part of freesound, we re-add it again' % (sound.original_filename)
                else:
                    os.remove(sound.original_path)
                    print 'The file %s is already part of freesound, we re-add it again' % (sound.original_filename)
                    continue

            # 4 save
            sound.save()

            # 5 move to new path
            orig = os.path.splitext(os.path.basename(sound.original_filename))[0] # WATCH OUT!
            sound.base_filename_slug = "%d__%s__%s" % (sound.id, slugify(sound.user.username), slugify(orig))
            new_original_path = sound.locations("path")
            if sound.original_path != new_original_path:
                try:
                    os.makedirs(os.path.dirname(new_original_path))
                except OSError:
                    pass
                try:
                    shutil.move(sound.original_path, new_original_path)
                    #shutil.copy(sound.original_path, new_original_path)
                except IOError, e:
                    print "failed to move file from %s to %s" % (sound.original_path, new_original_path)
                    #logger.info("failed to move file from %s to %s" % (sound.original_path, new_original_path), e)
                #logger.info("moved original file from %s to %s" % (sound.original_path, new_original_path))
                sound.original_path = new_original_path
                sound.save()

            # 6 create pack if it does not exist
            if packnamef:
                if Pack.objects.filter(name=packnamef, user=u).exists():
                    p = Pack.objects.get(name=packnamef, user=u)
                else:
                    p, created = Pack.objects.get_or_create(user=u, name=packnamef)

                sound.pack = p
                #dirty_packs.append(sound.pack)

            # 7 create geotag objects
            # format: lat#lon#zoom
            if geotagf:
                lat,lon,zoom = [g for g in geotagf.split(" ") if g]
                geotag = GeoTag(user=u,
                    lat=float(lat),
                    lon=float(lon),
                    zoom=int(zoom))
                geotag.save()
                sound.geotag = geotag

            # 8 set description, tags
            sound.description = descriptionf
            sound.set_tags([t for t in tagsf.split(" ") if t])

            # 9 save!
            sound.save()

            # if(whitelisted): set moderation OK
            sound.moderation_state = 'OK'
            sound.save()

            # 10 Proces
            try:
                sound.compute_crc()
            except:
                pass

            try:
                sound.process()
            except Exception, e:
                print 'Sound with id %s could not be scheduled. (%s)' % (sound.id, str(e))

            print "Successfully uploaded sound " + sound.original_filename

########NEW FILE########
__FILENAME__ = gm_client_processing
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.core.management.base import BaseCommand
from sounds.models import Sound
import gearman, sys
from django.conf import settings
from optparse import make_option
from datetime import datetime
from django.db import transaction

VALID_QUEUES = ['process_sound', 'analyze_sound']

class Command(BaseCommand):
    """Sends jobs to the Gearman job server, scheduling the processing
    of sounds.
    """
    help = '''Process sounds via Gearman.'''
    args = '''[<sound_id> <...>]'''

    option_list = BaseCommand.option_list + (
        make_option('--all', action='store_true', dest='all', default=False,
            help='Process all sounds'),
        make_option('--pending', action='store_true', dest='pending',
            default=False, help='Process sounds marked as "pending"'),
        make_option('--queue', action='store', dest='queue',
            default=None,
            help='Send job to this queue (default: process_sound)'),
        make_option('--file', action='store', dest='file_input',
            default=None,
            help='Take ids from a file instead of via commands'),
    )


    def handle(self, *args, **options):
        # Parse command-line options.
        qs = Sound.objects.select_related()

        gearman_task = options['queue']
        if gearman_task not in VALID_QUEUES:
            print "Wow.. You're mad as a hatter! Are you sure that's the queue you want? Pick one from: %s." % ', '.join(VALID_QUEUES)
            sys.exit(1)

        if options['all']:
            # All sounds in the database.
            sounds = qs.all().exclude(original_path=None)
        elif options['pending']:
            # Every sound marked as 'pending'.
            if gearman_task == 'process_sound':
                sounds = qs.filter(processing_state="PE").exclude(original_path=None)
            elif gearman_task == 'analyze_sound':
                sounds = qs.filter(analysis_state="PE").exclude(original_path=None)
        else:
            # The sound_ids passed as arguments in command-line.
            sounds = qs.filter(pk__in=args).exclude(original_path=None)

        # generate the job list before the queryset gets updated.
        jobs = [{'task': gearman_task, 'data': str(sound["id"])} for sound in sounds.values("id")]

        # update all sounds to reflect we are processing them... (only for 'process_sound' queue)
        self.stdout.write('Updating database\n')
        if gearman_task == 'process_sound':
            sounds.update(processing_date=datetime.now(), processing_state="QU")
            transaction.commit_unless_managed()
        elif gearman_task == 'analyze_sound':
            sounds.update(processing_date=datetime.now(), analysis_state="QU")
            transaction.commit_unless_managed()
        self.stdout.write('Updating database done\n')

        # Connect to the Gearman job server.
        if len(jobs) > 0:
            self.stdout.write('Sending %d sound(s) to the gearman queue (%s)\n' % (len(jobs), gearman_task))
            # send them to the queue!
            gm_client = gearman.GearmanClient(settings.GEARMAN_JOB_SERVERS)
            gm_client.submit_multiple_jobs(jobs, background=True, wait_until_complete=False)
            self.stdout.write('Sending sounds done')
        else:
            self.stdout.write('no jobs to send')

########NEW FILE########
__FILENAME__ = gm_status
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.core.management.base import NoArgsCommand
from sounds.models import Sound
from django.conf import settings
import gearman

class Command(NoArgsCommand):
    help = 'Display gearman status'

    def handle(self, **options):
        gm_client = gearman.GearmanAdminClient(settings.GEARMAN_JOB_SERVERS)
        
        for task in gm_client.get_status():
            for key, value in task.items():
                self.stdout.write('%s: %s\n' % (key, str(value)))
########NEW FILE########
__FILENAME__ = gm_worker_processing
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

import gearman, sys, traceback, json, time, os
from django.core.management.base import BaseCommand
from utils.audioprocessing.freesound_audio_processing import process
from utils.audioprocessing.essentia_analysis import analyze
from django.conf import settings
from sounds.models import Sound, Pack
from optparse import make_option
from psycopg2 import InterfaceError
from django.db.utils import DatabaseError
from django.db import connection
import logging

logger = logging.getLogger("gearman_worker_processing")

class Command(BaseCommand):
    help = 'Run the sound processing worker'

    option_list = BaseCommand.option_list + (
        make_option('--queue', action='store', dest='queue',
            default='process_sound',
            help='Register this function (default: process_sound)'),
    )

    def write_stdout(self, msg):
        logger.info("[%d] %s" % (os.getpid(),msg))
        self.stdout.write(msg)
        self.stdout.flush()

    def handle(self, *args, **options):
        # N.B. don't take out the print statements as they're
        # very very very very very very very very very very
        # helpful in debugging supervisor+worker+gearman
        self.write_stdout('Starting worker\n')
        task_name = 'task_%s' % options['queue']
        self.write_stdout('Task: %s\n' % task_name)
        if task_name not in dir(self):
            self.write_stdout("Wow.. That's crazy! Maybe try an existing queue?\n")
            sys.exit(1)
        task_func = lambda x, y: getattr(Command, task_name)(self, x, y)
        self.write_stdout('Initializing gm_worker\n')
        gm_worker = gearman.GearmanWorker(settings.GEARMAN_JOB_SERVERS)
        self.write_stdout('Registering task %s, function %s\n' % (task_name, task_func))
        gm_worker.register_task(options['queue'], task_func)
        self.write_stdout('Starting work\n')
        gm_worker.work()
        self.write_stdout('Ended work\n')


    def task_analyze_sound(self, gearman_worker, gearman_job):
        return self.task_process_x(gearman_worker, gearman_job, analyze)


    def task_process_sound(self, gearman_worker, gearman_job):
        return self.task_process_x(gearman_worker, gearman_job, process)

    def task_create_pack_zip(self, gearmanworker, gearman_job):
        # dirty hack: sleep 1 sec while the transaction finishes at the other end
        time.sleep(1)
        pack_id  = gearman_job.data
        self.write_stdout("Processing pack with id %s\n" % pack_id)
        # connection (max of 'intent' times)
        intent = 3
        while intent > 0:
            try:
                pack = Pack.objects.get(id=int(pack_id))
                break
            except (InterfaceError, DatabaseError):
                try:
                    connection.connection.close()
                except:
                    pass
                    # Trick Django into creating a fresh connection on the next db use attempt
                connection.connection = None
                intent -= 1
        if intent <= 0:
            self.write_stdout("Problems while connecting to the database, could not reset the connection and will kill the worker.\n")
            sys.exit(255)
        try:
            self.write_stdout("Found pack with id %d\n" % pack.id)
            pack.create_zip()
            self.write_stdout("Finished creating zip")
        except Exception, e:
            self.write_stdout("ERROR in zip creation: % \n"%str(e))
        return 'true'
    
    def task_process_x(self, gearman_worker, gearman_job, func):
        sound_id = gearman_job.data
        self.write_stdout("Processing sound with id %s\n" % sound_id)
        success = True
        sound = False
        try:
            # If the database connection has become invalid, try to reset the
            # connection (max of 'intent' times)
            intent = 3
            while intent > 0:
                try:
                    # Try to get the sound, and if we succeed continue as normal
                    sound = Sound.objects.select_related().get(id=sound_id)
                    break
                except (InterfaceError, DatabaseError):
                    # Try to close the current connection (it probably already is closed)
                    try:
                        connection.connection.close()
                    except:
                        pass
                    # Trick Django into creating a fresh connection on the next db use attempt
                    connection.connection = None
                    intent -= 1

            # if we didn't succeed in resetting the connection, quit the worker
            if intent <= 0:
                self.write_stdout("Problems while connecting to the database, could not reset the connection and will kill the worker.\n")
                sys.exit(255)

            result = func(sound)
            self.write_stdout("Finished, sound: %s, processing %s\n" % \
                              (sound_id, ("ok" if result else "failed")))
            success = result
            return 'true' if result else 'false'
        except Sound.DoesNotExist:
            self.write_stdout("\t did not find sound with id: %s\n" % sound_id)
            success = False
            return 'false'
        except Exception, e:
            self.write_stdout("\t something went terribly wrong: %s\n" % e)
            self.write_stdout("\t%s\n" % traceback.format_exc())
            success = False
            return 'false'

########NEW FILE########
__FILENAME__ = mail_users
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.core.management.base import BaseCommand
from django.conf import settings
from optparse import make_option
import smtplib, json, sys
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from django.template import loader, Context


class Command(BaseCommand):
    """Send an email to the users specified in a JSON file.
    """
    help = '''Send an email to the users specified in a JSON file.'''
    args = '''[<foshizzle> <input>]'''

    option_list = BaseCommand.option_list + (
        make_option('--foshizzle', action='store_true', dest='foshizzle', default=False,
                    help="Don't do a dry-run and actually send the messages."),
        make_option('--input', action='store', dest='input', default='/tmp/relevant_users.json',
                    help='Load users to send emails to from this file.'),
        make_option('--template', action='store', dest='template', default=False,
                    help='Use this template to render the message body.'),
        make_option('--subject', action='store', dest='subject', default=False,
                    help='Use this subject line for the emails.'),
        make_option('--from', action='store', dest='from', default='noreply@freesound.org',
                    help='Use this email address as the sender.'),
    )

    def handle(self, *args, **options):

        if not options['template'] \
           or not options['subject']:
            self.stdout.write('ERROR: Please provide a template name to render the email text and a subject line.')
            self.stdout.flush()
            sys.exit(1)

        use_html_p = options['template'].endswith('.html')

        with open(options['input'], mode='r') as f:
            users = json.load(f)

        if options['foshizzle']:
            s = smtplib.SMTP('localhost')

        t = loader.get_template(options['template'])

        for user in users:
            c = Context(user)

            if use_html_p:
                msg = MIMEMultipart('alternative')
                msg.attach(MIMEText('''Hi there,

We wanted to send you an email, but it appears your email client does not support HTML.
If you would still like to read this email try to open it in another client. Otherwise
please ignore this message.

Our apologies,

The Freesound team
''', 'plain'))
                # attach HTML last, because Gmail favors the last alternative
                msg.attach(MIMEText(t.render(c), 'html'))
            else:
                msg = MIMEText(t.render(c))

            msg['Subject'] = options['subject']
            msg['From'] = options['from']
            msg['To'] = user['email']
            if options['foshizzle']:
                s.sendmail(options['from'], [user['email']], msg.as_string())
            else:
                print msg.as_string()

        if options['foshizzle']:
            s.quit()


########NEW FILE########
__FILENAME__ = post_conversion
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.core.management.base import NoArgsCommand
from sounds.models import Sound
from django.contrib.auth.models import User
from similarity.client import Similarity
from django.db.models import Max
import os


#BAD_USERNAME_CHARACTERS = ' '

class Command(NoArgsCommand):
    help = """ 1) Determine which sounds have already been copied from FS1 and processed and set processing_state accordingly.
               2) Update the num_comments field on sound
           """

    def handle(self, **options):

        # Update sounds
        max_sound_id = Sound.objects.all().aggregate(Max('id'))['id__max']
        counter = 0

        for sound_id in xrange(max_sound_id+1):

            changed = False
            try:
                sound = Sound.objects.get(id=sound_id)
            except Sound.DoesNotExist:
                continue

            # check some random paths
            if sound.processing_state != 'OK' and \
               os.path.exists(sound.locations('path')) and \
               os.path.exists(sound.locations('preview.HQ.mp3.path')) and \
               os.path.exists(sound.locations('display.spectral.L.path')):
                sound.processing_state = 'OK'
                changed = True


            if sound.analysis_state != 'OK' and \
               os.path.exists(sound.locations('analysis.statistics.path')) and \
               os.path.exists(sound.locations('analysis.frames.path')):
                sound.analysis_state = 'OK'
                changed = True

            if sound.analysis_state == 'OK' and Similarity.contains(sound.id):
                sound.similarity_state = 'OK'
                changed = True

            if changed:
                sound.save()

            counter += 1
            if counter % 1000 == 0:
                print 'Processed %s sounds' % counter

########NEW FILE########
__FILENAME__ = post_dirty_sounds_to_solr
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.core.management.base import BaseCommand
from sounds.models import Sound
from utils.search.search import add_all_sounds_to_solr

class Command(BaseCommand):
    args = ''
    help = 'Add all sounds with index_dirty flag True to SOLR index'

    def handle(self, *args, **options):
        sound_qs = Sound.objects.select_related("pack", "user", "license") \
                                .filter(is_index_dirty=True,
                                        moderation_state='OK',
                                        processing_state='OK')

        add_all_sounds_to_solr(sound_qs, mark_index_clean=True)

########NEW FILE########
__FILENAME__ = post_sounds_to_tagrecommendation
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.core.management.base import BaseCommand
from sounds.models import Sound
from utils.tagrecommendation_utilities import get_id_of_last_indexed_sound, post_sounds_to_tagrecommendation_service
from optparse import make_option


class Command(BaseCommand):
    args = ''
    help = 'Get the id of the last indexed sound in tag recommendation service and send tag information of the older ones'
    option_list = BaseCommand.option_list + (
    make_option('-a','--all',
        dest='all',
        action='store_true',
        default=False,
        help='Repost all sounds to tag recommendation even if they were already indexed'),
    )

    def handle(self, *args, **options):

        if options['all']:
            last_indexed_id = 0
        else:
            last_indexed_id = get_id_of_last_indexed_sound()

        print "Starting at id %i" % last_indexed_id
        sound_qs = Sound.objects.filter(moderation_state='OK', processing_state='OK', id__gt=last_indexed_id).order_by("id")
        post_sounds_to_tagrecommendation_service(sound_qs)
########NEW FILE########
__FILENAME__ = process_reschedule_all
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.core.management.base import NoArgsCommand
from sounds.models import Sound
from django.db.models import Q

class Command(NoArgsCommand):
    args = '<num_days>'
    help = 'Take all sounds that are sitting the processing queue marked as "queue" and reschedule them'

    def handle(self, **options):
        Sound.objects.filter(Q(processing_state='PR') | Q(processing_state='QU')).update(processing_state = "PE")

########NEW FILE########
__FILENAME__ = process_reschedule_late
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.core.management.base import BaseCommand
from sounds.models import Sound
from datetime import datetime
from django.db.models import Q

class Command(BaseCommand):
    args = '<num_hours>'
    help = 'Take all sounds that have been sitting (for num_hours) the processing queue marked as "being processed" and reschedule them'

    def handle(self, *args, **options):
        num_hours = int(args[0])
        for sound in Sound.objects.filter(Q(processing_state='PR') | Q(processing_state='QU'), processing_date__lt=datetime.now()-datetime.timedelta(hours=num_hours)):
            sound.processing_state = "PE"
            sound.save()

########NEW FILE########
__FILENAME__ = recreate_dirty_packs
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.core.management.base import BaseCommand
from sounds.models import Pack

class Command(BaseCommand):
    args = ''
    help = "Find packs that need refreshing and create them"
    def handle(self, *args, **options):
        for pack in Pack.objects.filter(is_dirty=True):
            pack.create_zip()

########NEW FILE########
__FILENAME__ = reindex_solr
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.core.management.base import BaseCommand
from sounds.models import Sound
from utils.search.search import add_all_sounds_to_solr

class Command(BaseCommand):
    args = ''
    help = 'Take all sounds and send them to Solr'

    def handle(self, *args, **options):
        sound_qs = Sound.objects.select_related("pack", "user", "license") \
                                .filter(processing_state="OK", moderation_state="OK")
        add_all_sounds_to_solr(sound_qs)

########NEW FILE########
__FILENAME__ = reindex_solr_forum
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.core.management.base import BaseCommand
from forum.models import Post
from utils.search.search_forum import add_all_posts_to_solr

class Command(BaseCommand):
    args = ''
    help = 'Take all posts and send them to Solr'

    def handle(self, *args, **options):
        post_qs = Post.objects.select_related("forum", "thread", "user")
        add_all_posts_to_solr(post_qs)
########NEW FILE########
__FILENAME__ = report_index_statuses
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#


from django.core.management.base import BaseCommand
from optparse import make_option
from utils.search.search import get_all_sound_ids_from_solr
from utils.similarity_utilities import Similarity
from sounds.models import Sound
from utils.search.solr import Solr
import settings
import sys

class Command(BaseCommand):
    help = "This command checks the status of the solr and gaia index compared to the fs database. Reports about sounds which " \
           "are missing in gaia and solr and sounds that are in gaia or solr but not in fs dataset. Moreover, it changes the status " \
           "of the sounds in fs dataset that are not in gaia or solr so the next time the indexes are updated " \
           "(running similarity_update and post_dirty_sounds_to_solr) they are indexed."

    option_list = BaseCommand.option_list + (
    make_option('-n','--no-changes',
        dest='no-changes',
        action='store_true',
        default=False,
        help='Using the option --no-changes the is_index_dirty and similarity_state sound fields will not be modified.'),
    )

    def handle(self,  *args, **options):

        # init
        solr = Solr(settings.SOLR_URL)

        # Get all solr ids
        print "Getting solr ids...",
        solr_ids = get_all_sound_ids_from_solr()
        print "done!"

        # Get ell gaia ids
        print "Getting gaia ids...",
        gaia_ids = Similarity.get_all_sound_ids()
        print "done!"

        print "Getting freesound db data..."
        # Get all moderated and processed sound ids
        queryset = Sound.objects.filter(processing_state='OK', moderation_state='OK').order_by('id').only("id")
        fs_mp = [sound.id for sound in queryset]
        # Get ell moderated, processed and analysed sounds
        queryset = Sound.objects.filter(processing_state='OK', moderation_state='OK', analysis_state='OK').order_by('id').only("id")
        fs_mpa = [sound.id for sound in queryset]
        print "done!"

        print "\nNumber of sounds per index:\n--------------------------"
        print "Solr index\t\t%i" % len(solr_ids)
        print "Gaia index\t\t%i" % len(gaia_ids)
        print "Freesound\t\t%i  (moderated and processed)" % len(fs_mp)
        print "Freesound\t\t%i  (moderated, processed and analyzed)" % len(fs_mpa)

        print "\n\n***************\nSOLR INDEX\n***************\n"
        in_solr_not_in_fs = list(set(solr_ids).intersection(set(set(solr_ids).difference(fs_mp))))
        in_fs_not_in_solr = list(set(fs_mp).intersection(set(set(fs_mp).difference(solr_ids))))
        print "Sounds in solr but not in fs:\t%i" % len(in_solr_not_in_fs)
        print "Sounds in fs but not in solr:\t%i" % len(in_fs_not_in_solr)

        if not options['no-changes']:
            # Mark fs sounds to go processing
            if in_fs_not_in_solr:
                print "Changing is_index_dirty_state of sounds that require it"
                N = len(in_fs_not_in_solr)
                for count, sid in enumerate(in_fs_not_in_solr):
                    sys.stdout.write('\r\tChanging state of sound sound %i of %i         ' % (count+1, N))
                    sys.stdout.flush()
                    sound = Sound.objects.get(id=sid)
                    sound.set_single_field('is_index_dirty', True)

            # Delete sounds from solr that are not in the db
            if in_solr_not_in_fs:
                print "\nDeleting sounds that should not be in solr"
                N = len(in_solr_not_in_fs)
                for count, sid in enumerate(in_solr_not_in_fs):
                    sys.stdout.write('\r\tDeleting sound %i of %i         ' % (count+1, N))
                    sys.stdout.flush()
                    solr.delete_by_id(sid)

        print "\n***************\nGAIA INDEX\n***************\n"
        in_gaia_not_in_fs = list(set(gaia_ids).intersection(set(set(gaia_ids).difference(fs_mp))))
        in_fs_not_in_gaia = list(set(fs_mpa).intersection(set(set(fs_mpa).difference(gaia_ids))))
        print "Sounds in gaia but not in fs:\t%i" % len(in_gaia_not_in_fs)
        print "Sounds in fs but not in gaia:\t%i  (only considering sounds correctly analyzed)" % len(in_fs_not_in_gaia)
        Similarity.save()

        if not options['no-changes']:
            # Mark fs sounds to go processing
            if in_fs_not_in_gaia:
                print "Changing similarity_state of sounds that require it"
                N = len(in_fs_not_in_gaia)
                for count, sid in enumerate(in_fs_not_in_gaia):
                    sys.stdout.write('\r\tChanging state of sound %i of %i         ' % (count+1, N))
                    sys.stdout.flush()
                    sound = Sound.objects.get(id=sid)
                    sound.set_similarity_state('PE')

            # Delete sounds from gaia that are not in the db
            if in_gaia_not_in_fs:
                print "\nDeleting sounds that should not be in solr"
                N = len(in_gaia_not_in_fs)
                for count, sid in enumerate(in_gaia_not_in_fs):
                    sys.stdout.write('\r\tDeleting sound %i of %i         ' % (count+1, N))
                    sys.stdout.flush()
                    Similarity.delete(sid)

                Similarity.save()











########NEW FILE########
__FILENAME__ = select_relevant_users
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.core.management.base import BaseCommand
from django.contrib.auth.models import User
from django.conf import settings
from optparse import make_option
import time, json, os, sys
from datetime import date

settings.DEBUG = False


class Command(BaseCommand):
    """Select relevant active users and write a JSON list of these users to a file.
    """
    help = '''Select relevant active users and write a JSON list of these users to a file.'''
    args = '''[<limit> <since> <sounds> <output>]'''

    option_list = BaseCommand.option_list + (
        make_option('--limit', action='store', dest='limit', default=100,
                    help='Limit the number of users.'),
        make_option('--since', action='store', dest='since', default='2010-6-1',
                    help='Only select users that have logged in since this date (yyyy-(m)m-(d)d).'),
        make_option('--sounds', action='store', dest='sounds', default=100,
                    help='Only select users that have uploaded more than this number of sounds.'),
        make_option('--output', action='store', dest='output', default='/tmp/relevant_users.json',
                    help='Write the JSON list of selected users to this file.')
    )

    def handle(self, *args, **options):

        tic = time.clock()

        qs = User.objects.raw("""
SELECT id
FROM auth_user
WHERE last_login >= '%s'
AND id IN ( SELECT user_id
            FROM sounds_sound
            GROUP BY user_id
            HAVING COUNT(user_id) > %s
            ORDER BY COUNT(user_id) DESC )
LIMIT %s
""" % \
(options['since'], options['sounds'], options['limit']))

        users = [{'sounds': user.sounds.all().count(),
                  'email': user.email,
                  'id': user.id,
                  'username': user.username} for user in qs]

        with open(options['output'], mode='w') as f:
            json.dump(users, f)

        toc = time.clock()

        self.stdout.write('\n\n')
        self.stdout.write("Selecting at most %s users active since %s with more than %s sounds.\n" % \
                          (options['limit'], options['since'], options['sounds']))
        self.stdout.write("%s users selected " % str(len(users)))
        self.stdout.write('(performed in ' + str(toc-tic) + ' seconds)\n')
        self.stdout.write("The JSON representation of the select users was written to: \n\t%s\n" % \
                          options['output'])
        self.stdout.flush()

########NEW FILE########
__FILENAME__ = set_first_post_in_threads
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.core.management.base import BaseCommand
from forum.models import Thread
from forum.models import Post


class Command(BaseCommand):
    args = ''
    help = 'Fill first_post field in every Thread object'

    def handle(self, *args, **options):
        thread_qs = Thread.objects.all()
        for thread in thread_qs:
            first_post = thread.post_set.all()[0]
            thread.first_post = first_post
            thread.save()

########NEW FILE########
__FILENAME__ = similarity_save_index
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.core.management.base import BaseCommand
from similarity.client import Similarity
from optparse import make_option


class Command(BaseCommand):
    args = ''
    help = 'Save current similarity index'
    option_list = BaseCommand.option_list + (
    make_option('-i','--indexing_server',
        dest='indexing_server',
        action='store_true',
        default=False,
        help='Save the index of the indexing server instead of the index of the main similarity server'),
    )

    def handle(self, *args, **options):
        if options['indexing_server']:
            Similarity.save_indexing_server()
        else:
            Similarity.save()


########NEW FILE########
__FILENAME__ = similarity_update
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.core.management.base import BaseCommand
from sounds.models import Sound
from similarity.client import Similarity
from optparse import make_option
import yaml


class Command(BaseCommand):
    help = "Take all sounds that haven't been added to the similarity service yet and add them. Use option --force to " \
           "force reindex ALL sounds. Pas a number argument to limit the number of sounds that will be reindexed " \
           "(to avoid collapsing similarity if using crons). Pass a string argument with the freesound extractor version" \
           "to only index sounds analyzed with the specified version."
    option_list = BaseCommand.option_list + (
    make_option('-f','--force',
        dest='force',
        action='store_true',
        default=False,
        help='Reindex all sounds regardless of their similarity state'),
    )
    option_list += (
    make_option('-i','--indexing_server',
        dest='indexing_server',
        action='store_true',
        default=False,
        help='Send files to the indexing server instead of the main similarity server'),
    )

    def handle(self,  *args, **options):

        limit = None
        freesound_extractor_version = ''
        for arg in args:
            if arg.isdigit():
                limit = int(arg)
            else:
                freesound_extractor_version = arg

        if options['force']:
            to_be_added = Sound.objects.filter(analysis_state='OK', moderation_state='OK').order_by('id')[:limit]
        else:
            to_be_added = Sound.objects.filter(analysis_state='OK', similarity_state='PE', moderation_state='OK').order_by('id')[:limit]

        N = len(to_be_added)
        for count, sound in enumerate(to_be_added):

            # Check if sound analyzed using the desired extractor
            if freesound_extractor_version:
                try:
                    data = yaml.load(open(sound.locations('analysis.statistics.path')), Loader=yaml.cyaml.CLoader)
                except:
                    print 'Sound with id %i was not indexed (no yaml file found when checking for extractor version)' % sound.id
                    continue

                if 'freesound_extractor' in data['metadata']['version']:
                    if data['metadata']['version']['freesound_extractor'] != freesound_extractor_version:
                        print 'Sound with id %i was not indexed (it was analyzed with extractor version %s)' % (sound.id, data['metadata']['version']['freesound_extractor'])
                        continue
                else:
                    print 'Sound with id %i was not indexed (it was analyzed with an unknown extractor)' % sound.id
                    continue

            try:
                if options['indexing_server']:
                    result = Similarity.add_to_indeixing_server(sound.id, sound.locations('analysis.statistics.path'))
                else:
                    result = Similarity.add(sound.id, sound.locations('analysis.statistics.path'))
                    sound.set_similarity_state('OK')
                print "%s (%i of %i)" % (result, count+1, N)

                # Every 2000 added sounds, save the index
                if count % 2000 == 0:
                    if options['indexing_server']:
                        Similarity.save_indexing_server()
                    else:
                        Similarity.save()

            except Exception, e:
                if not options['indexing_server']:
                    sound.set_similarity_state('FA')
                print 'Sound could not be added (id: %i, %i of %i): \n\t%s' % (sound.id, count+1, N ,str(e))

        # At the end save the index
        if options['indexing_server']:
            Similarity.save_indexing_server()
        else:
            Similarity.save()
########NEW FILE########
__FILENAME__ = test_api
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

import requests
import json
from django.core.management.base import BaseCommand
from django.contrib.sites.models import Site
from apiv2.examples import examples


def api_request(full_url, type='GET', post_data=None, auth='token', token=None):

    if '?' not in full_url:
        url = full_url
        params = dict()
    else:
        url = full_url.split('?')[0]
        params = dict()
        for param in full_url.split('?')[1].split('&'):
            name = param.split('=')[0]
            value = '='.join(param.split('=')[1:])
            params[name] = value

    if post_data:
        data = json.dumps(post_data)

    if auth == 'token':
        headers = {'Authorization': 'Token %s' % token }

    if type == 'GET':
        r = requests.get(url, params=params, headers=headers)
    elif type == 'POST':
        r = requests.post(url, params=params, data=data, headers=headers)

    return r


class Command(BaseCommand):
    help = "Test apiv2 with examples from apiv2/examples.py. Usage: python manage.py test_api [custom_base_url] [token] [section]"

    def handle(self,  *args, **options):
        if args:
            base_url = str(args[0])
            if len(args) > 1:
                token = str(args[1])
            else:
                token = False
            if len(args) > 2:
                section = str(args[2])
            else:
                section = False
        else:
            base_url = "http://%s/" % Site.objects.get_current().domain
            section = False
            token = False

        if not token:
            from apiv2.models import ApiV2Client
            client = ApiV2Client.objects.filter(user__username='apitest')[0]
            token = client.client_secret

        ok = list()
        failed = list()
        error = list()

        print ''
        for key, items in examples.items():
            if 'Download' not in key:
                if section:
                    if section not in key:
                        continue

                print 'Testing %s' % key
                print '--------------------------------------'

                for desc, urls in items:
                    for url in urls:
                        if url[0:4] != 'curl':
                            prepended_url = base_url + url
                            print '- %s' % prepended_url,
                            try:
                                r = api_request(prepended_url, token=token)
                                if r.status_code == 200:
                                    print 'OK'
                                    ok.append(prepended_url)
                                else:
                                    print 'FAIL! (%i)' % r.status_code
                                    failed.append((prepended_url, r.status_code))
                            except Exception, e:
                                print 'ERROR (%s)' % str(e)
                                error.append(prepended_url)

                print ''

        print '\nRUNNING TESTS FINISHED:'
        print '\t%i tests completed successfully' % len(ok)
        if error:
            print '\t%i tests gave errors (connection, etc...)' % len(error)
        print '\t%i tests failed' % len(failed)
        for url, status_code in failed:
            print '\t\t- %s (%i)' % (url, status_code)


########NEW FILE########
__FILENAME__ = whitelist_user
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.core.management.base import BaseCommand
from tickets.models import Ticket
from tickets import TICKET_STATUS_CLOSED

class Command(BaseCommand):
    help = "Whitelist a user and close all pending tickets. Take as argument a ticket_id"

    def handle(self,  *args, **options):

        ticket_id = str(args[0])
        ticket = Ticket.objects.get(id=ticket_id)
        whitelist_user = ticket.sender
        whitelist_user.profile.is_whitelisted = True
        whitelist_user.profile.save()
        pending_tickets = Ticket.objects.filter(sender=whitelist_user,
                                                source='new sound') \
                                        .exclude(status=TICKET_STATUS_CLOSED)
        # Set all sounds to OK and the tickets to closed
        for pending_ticket in pending_tickets:
            if pending_ticket.content:
                pending_ticket.content.content_object.moderation_state = "OK"
                pending_ticket.content.content_object.save()
                pending_ticket.content.content_object.mark_index_dirty()
            # This could be done with a single update, but there's a chance
            # we lose a sound that way (a newly created ticket who's sound
            # is not set to OK, but the ticket is closed).
            pending_ticket.status = TICKET_STATUS_CLOSED
            pending_ticket.save()
########NEW FILE########
__FILENAME__ = management
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

import os

from django.db.models.signals import post_syncdb
from django.dispatch import receiver
from django.conf import settings

@receiver(post_syncdb)
def create_locations(sender, **kwargs):
    for folder in [settings.SOUNDS_PATH,
                   settings.PACKS_PATH,
                   settings.AVATARS_PATH,
                   settings.UPLOADS_PATH,
                   settings.PREVIEWS_PATH,
                   settings.DISPLAYS_PATH]:
        if not os.path.isdir(folder):
            try:
                os.mkdir(folder)
                print ("Successfullly created the folder: '%s'" % folder)
            except Exception, e:
                print ("Problem creating this folder: '%s', %s"
                    % (folder, e))
        else:
            print ("Folder: '%s' already exists" % folder)

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'License'
        db.create_table('sounds_license', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('order', self.gf('django.db.models.fields.PositiveIntegerField')()),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=512)),
            ('abbreviation', self.gf('django.db.models.fields.CharField')(max_length=8, db_index=True)),
            ('summary', self.gf('django.db.models.fields.TextField')()),
            ('deed_url', self.gf('django.db.models.fields.URLField')(max_length=200)),
            ('legal_code_url', self.gf('django.db.models.fields.URLField')(max_length=200)),
            ('is_public', self.gf('django.db.models.fields.BooleanField')(default=True)),
        ))
        db.send_create_signal('sounds', ['License'])

        # Adding model 'Sound'
        db.create_table('sounds_sound', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(related_name='sounds', to=orm['auth.User'])),
            ('created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, db_index=True, blank=True)),
            ('original_filename', self.gf('django.db.models.fields.CharField')(max_length=512)),
            ('original_path', self.gf('django.db.models.fields.CharField')(default=None, max_length=512, null=True, blank=True)),
            ('base_filename_slug', self.gf('django.db.models.fields.CharField')(default=None, max_length=512, null=True, blank=True)),
            ('description', self.gf('django.db.models.fields.TextField')()),
            ('date_recorded', self.gf('django.db.models.fields.DateField')(default=None, null=True, blank=True)),
            ('license', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['sounds.License'])),
            ('pack', self.gf('django.db.models.fields.related.ForeignKey')(default=None, to=orm['sounds.Pack'], null=True, blank=True)),
            ('geotag', self.gf('django.db.models.fields.related.ForeignKey')(default=None, to=orm['geotags.GeoTag'], null=True, blank=True)),
            ('type', self.gf('django.db.models.fields.CharField')(max_length=4, db_index=True)),
            ('duration', self.gf('django.db.models.fields.FloatField')(default=0)),
            ('bitrate', self.gf('django.db.models.fields.IntegerField')(default=0)),
            ('bitdepth', self.gf('django.db.models.fields.IntegerField')(default=None, null=True, blank=True)),
            ('samplerate', self.gf('django.db.models.fields.FloatField')(default=0)),
            ('filesize', self.gf('django.db.models.fields.IntegerField')(default=0)),
            ('channels', self.gf('django.db.models.fields.IntegerField')(default=0)),
            ('md5', self.gf('django.db.models.fields.CharField')(unique=True, max_length=32, db_index=True)),
            ('is_index_dirty', self.gf('django.db.models.fields.BooleanField')(default=True)),
            ('moderation_state', self.gf('django.db.models.fields.CharField')(default='PE', max_length=2, db_index=True)),
            ('moderation_date', self.gf('django.db.models.fields.DateTimeField')(default=None, null=True, blank=True)),
            ('moderation_note', self.gf('django.db.models.fields.TextField')(default=None, null=True, blank=True)),
            ('has_bad_description', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('processing_state', self.gf('django.db.models.fields.CharField')(default='PE', max_length=2, db_index=True)),
            ('processing_date', self.gf('django.db.models.fields.DateTimeField')(default=None, null=True, blank=True)),
            ('processing_log', self.gf('django.db.models.fields.TextField')(default=None, null=True, blank=True)),
            ('similarity_state', self.gf('django.db.models.fields.CharField')(default='PE', max_length=2, db_index=True)),
            ('analysis_state', self.gf('django.db.models.fields.CharField')(default='PE', max_length=2, db_index=True)),
            ('num_comments', self.gf('django.db.models.fields.PositiveIntegerField')(default=0)),
            ('num_downloads', self.gf('django.db.models.fields.PositiveIntegerField')(default=0)),
            ('avg_rating', self.gf('django.db.models.fields.FloatField')(default=0)),
            ('num_ratings', self.gf('django.db.models.fields.PositiveIntegerField')(default=0)),
        ))
        db.send_create_signal('sounds', ['Sound'])

        # Adding M2M table for field sources on 'Sound'
        db.create_table('sounds_sound_sources', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('from_sound', models.ForeignKey(orm['sounds.sound'], null=False)),
            ('to_sound', models.ForeignKey(orm['sounds.sound'], null=False))
        ))
        db.create_unique('sounds_sound_sources', ['from_sound_id', 'to_sound_id'])

        # Adding model 'Pack'
        db.create_table('sounds_pack', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'])),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('description', self.gf('django.db.models.fields.TextField')(default=None, null=True, blank=True)),
            ('is_dirty', self.gf('django.db.models.fields.BooleanField')(default=True, db_index=True)),
            ('created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, db_index=True, blank=True)),
            ('num_downloads', self.gf('django.db.models.fields.PositiveIntegerField')(default=0)),
        ))
        db.send_create_signal('sounds', ['Pack'])

        # Adding unique constraint on 'Pack', fields ['user', 'name']
        db.create_unique('sounds_pack', ['user_id', 'name'])

        # Adding model 'Flag'
        db.create_table('sounds_flag', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('sound', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['sounds.Sound'])),
            ('reporting_user', self.gf('django.db.models.fields.related.ForeignKey')(default=None, to=orm['auth.User'], null=True, blank=True)),
            ('email', self.gf('django.db.models.fields.EmailField')(max_length=75)),
            ('reason_type', self.gf('django.db.models.fields.CharField')(default='I', max_length=1)),
            ('reason', self.gf('django.db.models.fields.TextField')()),
            ('created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, db_index=True, blank=True)),
        ))
        db.send_create_signal('sounds', ['Flag'])

        # Adding model 'Download'
        db.create_table('sounds_download', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'])),
            ('sound', self.gf('django.db.models.fields.related.ForeignKey')(default=None, to=orm['sounds.Sound'], null=True, blank=True)),
            ('pack', self.gf('django.db.models.fields.related.ForeignKey')(default=None, to=orm['sounds.Pack'], null=True, blank=True)),
            ('created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, db_index=True, blank=True)),
        ))
        db.send_create_signal('sounds', ['Download'])

        # Adding model 'RemixGroup'
        db.create_table('sounds_remixgroup', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('protovis_data', self.gf('django.db.models.fields.TextField')(default=None, null=True, blank=True)),
            ('group_size', self.gf('django.db.models.fields.PositiveIntegerField')(default=0)),
        ))
        db.send_create_signal('sounds', ['RemixGroup'])

        # Adding M2M table for field sounds on 'RemixGroup'
        db.create_table('sounds_remixgroup_sounds', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('remixgroup', models.ForeignKey(orm['sounds.remixgroup'], null=False)),
            ('sound', models.ForeignKey(orm['sounds.sound'], null=False))
        ))
        db.create_unique('sounds_remixgroup_sounds', ['remixgroup_id', 'sound_id'])


    def backwards(self, orm):
        
        # Removing unique constraint on 'Pack', fields ['user', 'name']
        db.delete_unique('sounds_pack', ['user_id', 'name'])

        # Deleting model 'License'
        db.delete_table('sounds_license')

        # Deleting model 'Sound'
        db.delete_table('sounds_sound')

        # Removing M2M table for field sources on 'Sound'
        db.delete_table('sounds_sound_sources')

        # Deleting model 'Pack'
        db.delete_table('sounds_pack')

        # Deleting model 'Flag'
        db.delete_table('sounds_flag')

        # Deleting model 'Download'
        db.delete_table('sounds_download')

        # Deleting model 'RemixGroup'
        db.delete_table('sounds_remixgroup')

        # Removing M2M table for field sounds on 'RemixGroup'
        db.delete_table('sounds_remixgroup_sounds')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'comments.comment': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Comment'},
            'comment': ('django.db.models.fields.TextField', [], {}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'related_name': "'replies'", 'null': 'True', 'blank': 'True', 'to': "orm['comments.Comment']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'favorites.favorite': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'Favorite'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'geotags.geotag': {
            'Meta': {'object_name': 'GeoTag'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lat': ('django.db.models.fields.FloatField', [], {'db_index': 'True'}),
            'lon': ('django.db.models.fields.FloatField', [], {'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'zoom': ('django.db.models.fields.IntegerField', [], {})
        },
        'ratings.rating': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'Rating'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'rating': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'sounds.download': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Download'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'pack': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['sounds.Pack']", 'null': 'True', 'blank': 'True'}),
            'sound': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['sounds.Sound']", 'null': 'True', 'blank': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'sounds.flag': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Flag'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'reason': ('django.db.models.fields.TextField', [], {}),
            'reason_type': ('django.db.models.fields.CharField', [], {'default': "'I'", 'max_length': '1'}),
            'reporting_user': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['auth.User']", 'null': 'True', 'blank': 'True'}),
            'sound': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sounds.Sound']"})
        },
        'sounds.license': {
            'Meta': {'ordering': "['order']", 'object_name': 'License'},
            'abbreviation': ('django.db.models.fields.CharField', [], {'max_length': '8', 'db_index': 'True'}),
            'deed_url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'legal_code_url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '512'}),
            'order': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'summary': ('django.db.models.fields.TextField', [], {})
        },
        'sounds.pack': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'name'),)", 'object_name': 'Pack'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_dirty': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'db_index': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'num_downloads': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'sounds.remixgroup': {
            'Meta': {'object_name': 'RemixGroup'},
            'group_size': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'protovis_data': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'sounds': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'remix_group'", 'blank': 'True', 'to': "orm['sounds.Sound']"})
        },
        'sounds.sound': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Sound'},
            'analysis_state': ('django.db.models.fields.CharField', [], {'default': "'PE'", 'max_length': '2', 'db_index': 'True'}),
            'avg_rating': ('django.db.models.fields.FloatField', [], {'default': '0'}),
            'base_filename_slug': ('django.db.models.fields.CharField', [], {'default': 'None', 'max_length': '512', 'null': 'True', 'blank': 'True'}),
            'bitdepth': ('django.db.models.fields.IntegerField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'bitrate': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'channels': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'date_recorded': ('django.db.models.fields.DateField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'duration': ('django.db.models.fields.FloatField', [], {'default': '0'}),
            'filesize': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'geotag': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['geotags.GeoTag']", 'null': 'True', 'blank': 'True'}),
            'has_bad_description': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_index_dirty': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'license': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sounds.License']"}),
            'md5': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'moderation_date': ('django.db.models.fields.DateTimeField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'moderation_note': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'moderation_state': ('django.db.models.fields.CharField', [], {'default': "'PE'", 'max_length': '2', 'db_index': 'True'}),
            'num_comments': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'num_downloads': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'num_ratings': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'original_filename': ('django.db.models.fields.CharField', [], {'max_length': '512'}),
            'original_path': ('django.db.models.fields.CharField', [], {'default': 'None', 'max_length': '512', 'null': 'True', 'blank': 'True'}),
            'pack': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['sounds.Pack']", 'null': 'True', 'blank': 'True'}),
            'processing_date': ('django.db.models.fields.DateTimeField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'processing_log': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'processing_state': ('django.db.models.fields.CharField', [], {'default': "'PE'", 'max_length': '2', 'db_index': 'True'}),
            'samplerate': ('django.db.models.fields.FloatField', [], {'default': '0'}),
            'similarity_state': ('django.db.models.fields.CharField', [], {'default': "'PE'", 'max_length': '2', 'db_index': 'True'}),
            'sources': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'remixes'", 'blank': 'True', 'to': "orm['sounds.Sound']"}),
            'type': ('django.db.models.fields.CharField', [], {'max_length': '4', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'sounds'", 'to': "orm['auth.User']"})
        },
        'tags.tag': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '100', 'db_index': 'True'})
        },
        'tags.taggeditem': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('tag', 'content_type', 'object_id'),)", 'object_name': 'TaggedItem'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'tag': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['tags.Tag']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        }
    }

    complete_apps = ['sounds']

########NEW FILE########
__FILENAME__ = 0002_auto__add_deletedsound
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'DeletedSound'
        db.create_table('sounds_deletedsound', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('sound_id', self.gf('django.db.models.fields.IntegerField')(default=0, db_index=True)),
        ))
        db.send_create_signal('sounds', ['DeletedSound'])


    def backwards(self, orm):
        
        # Deleting model 'DeletedSound'
        db.delete_table('sounds_deletedsound')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'comments.comment': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Comment'},
            'comment': ('django.db.models.fields.TextField', [], {}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'related_name': "'replies'", 'null': 'True', 'blank': 'True', 'to': "orm['comments.Comment']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'favorites.favorite': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'Favorite'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'geotags.geotag': {
            'Meta': {'object_name': 'GeoTag'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lat': ('django.db.models.fields.FloatField', [], {'db_index': 'True'}),
            'lon': ('django.db.models.fields.FloatField', [], {'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'zoom': ('django.db.models.fields.IntegerField', [], {})
        },
        'ratings.rating': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'Rating'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'rating': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'sounds.deletedsound': {
            'Meta': {'object_name': 'DeletedSound'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'sound_id': ('django.db.models.fields.IntegerField', [], {'default': '0', 'db_index': 'True'})
        },
        'sounds.download': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Download'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'pack': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['sounds.Pack']", 'null': 'True', 'blank': 'True'}),
            'sound': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['sounds.Sound']", 'null': 'True', 'blank': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'sounds.flag': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Flag'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'reason': ('django.db.models.fields.TextField', [], {}),
            'reason_type': ('django.db.models.fields.CharField', [], {'default': "'I'", 'max_length': '1'}),
            'reporting_user': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['auth.User']", 'null': 'True', 'blank': 'True'}),
            'sound': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sounds.Sound']"})
        },
        'sounds.license': {
            'Meta': {'ordering': "['order']", 'object_name': 'License'},
            'abbreviation': ('django.db.models.fields.CharField', [], {'max_length': '8', 'db_index': 'True'}),
            'deed_url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'legal_code_url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '512'}),
            'order': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'summary': ('django.db.models.fields.TextField', [], {})
        },
        'sounds.pack': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'name'),)", 'object_name': 'Pack'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_dirty': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'db_index': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'num_downloads': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'sounds.remixgroup': {
            'Meta': {'object_name': 'RemixGroup'},
            'group_size': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'protovis_data': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'sounds': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'remix_group'", 'blank': 'True', 'to': "orm['sounds.Sound']"})
        },
        'sounds.sound': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Sound'},
            'analysis_state': ('django.db.models.fields.CharField', [], {'default': "'PE'", 'max_length': '2', 'db_index': 'True'}),
            'avg_rating': ('django.db.models.fields.FloatField', [], {'default': '0'}),
            'base_filename_slug': ('django.db.models.fields.CharField', [], {'default': 'None', 'max_length': '512', 'null': 'True', 'blank': 'True'}),
            'bitdepth': ('django.db.models.fields.IntegerField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'bitrate': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'channels': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'date_recorded': ('django.db.models.fields.DateField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'duration': ('django.db.models.fields.FloatField', [], {'default': '0'}),
            'filesize': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'geotag': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['geotags.GeoTag']", 'null': 'True', 'blank': 'True'}),
            'has_bad_description': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_index_dirty': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'license': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sounds.License']"}),
            'md5': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'moderation_date': ('django.db.models.fields.DateTimeField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'moderation_note': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'moderation_state': ('django.db.models.fields.CharField', [], {'default': "'PE'", 'max_length': '2', 'db_index': 'True'}),
            'num_comments': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'num_downloads': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'num_ratings': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'original_filename': ('django.db.models.fields.CharField', [], {'max_length': '512'}),
            'original_path': ('django.db.models.fields.CharField', [], {'default': 'None', 'max_length': '512', 'null': 'True', 'blank': 'True'}),
            'pack': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['sounds.Pack']", 'null': 'True', 'blank': 'True'}),
            'processing_date': ('django.db.models.fields.DateTimeField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'processing_log': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'processing_state': ('django.db.models.fields.CharField', [], {'default': "'PE'", 'max_length': '2', 'db_index': 'True'}),
            'samplerate': ('django.db.models.fields.FloatField', [], {'default': '0'}),
            'similarity_state': ('django.db.models.fields.CharField', [], {'default': "'PE'", 'max_length': '2', 'db_index': 'True'}),
            'sources': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'remixes'", 'blank': 'True', 'to': "orm['sounds.Sound']"}),
            'type': ('django.db.models.fields.CharField', [], {'max_length': '4', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'sounds'", 'to': "orm['auth.User']"})
        },
        'tags.tag': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '100', 'db_index': 'True'})
        },
        'tags.taggeditem': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('tag', 'content_type', 'object_id'),)", 'object_name': 'TaggedItem'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'tag': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['tags.Tag']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        }
    }

    complete_apps = ['sounds']

########NEW FILE########
__FILENAME__ = 0003_auto__add_field_deletedsound_user
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'DeletedSound.user'
        db.add_column('sounds_deletedsound', 'user', self.gf('django.db.models.fields.related.ForeignKey')(default=1, to=orm['auth.User']), keep_default=False)


    def backwards(self, orm):
        
        # Deleting field 'DeletedSound.user'
        db.delete_column('sounds_deletedsound', 'user_id')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'comments.comment': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Comment'},
            'comment': ('django.db.models.fields.TextField', [], {}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'related_name': "'replies'", 'null': 'True', 'blank': 'True', 'to': "orm['comments.Comment']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'favorites.favorite': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'Favorite'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'geotags.geotag': {
            'Meta': {'object_name': 'GeoTag'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lat': ('django.db.models.fields.FloatField', [], {'db_index': 'True'}),
            'lon': ('django.db.models.fields.FloatField', [], {'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'zoom': ('django.db.models.fields.IntegerField', [], {})
        },
        'ratings.rating': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'Rating'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'rating': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'sounds.deletedsound': {
            'Meta': {'object_name': 'DeletedSound'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'sound_id': ('django.db.models.fields.IntegerField', [], {'default': '0', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'sounds.download': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Download'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'pack': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['sounds.Pack']", 'null': 'True', 'blank': 'True'}),
            'sound': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['sounds.Sound']", 'null': 'True', 'blank': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'sounds.flag': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Flag'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'reason': ('django.db.models.fields.TextField', [], {}),
            'reason_type': ('django.db.models.fields.CharField', [], {'default': "'I'", 'max_length': '1'}),
            'reporting_user': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['auth.User']", 'null': 'True', 'blank': 'True'}),
            'sound': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sounds.Sound']"})
        },
        'sounds.license': {
            'Meta': {'ordering': "['order']", 'object_name': 'License'},
            'abbreviation': ('django.db.models.fields.CharField', [], {'max_length': '8', 'db_index': 'True'}),
            'deed_url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'legal_code_url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '512'}),
            'order': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'summary': ('django.db.models.fields.TextField', [], {})
        },
        'sounds.pack': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'name'),)", 'object_name': 'Pack'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_dirty': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'db_index': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'num_downloads': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'sounds.remixgroup': {
            'Meta': {'object_name': 'RemixGroup'},
            'group_size': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'protovis_data': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'sounds': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'remix_group'", 'blank': 'True', 'to': "orm['sounds.Sound']"})
        },
        'sounds.sound': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Sound'},
            'analysis_state': ('django.db.models.fields.CharField', [], {'default': "'PE'", 'max_length': '2', 'db_index': 'True'}),
            'avg_rating': ('django.db.models.fields.FloatField', [], {'default': '0'}),
            'base_filename_slug': ('django.db.models.fields.CharField', [], {'default': 'None', 'max_length': '512', 'null': 'True', 'blank': 'True'}),
            'bitdepth': ('django.db.models.fields.IntegerField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'bitrate': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'channels': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'date_recorded': ('django.db.models.fields.DateField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'duration': ('django.db.models.fields.FloatField', [], {'default': '0'}),
            'filesize': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'geotag': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['geotags.GeoTag']", 'null': 'True', 'blank': 'True'}),
            'has_bad_description': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_index_dirty': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'license': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sounds.License']"}),
            'md5': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'moderation_date': ('django.db.models.fields.DateTimeField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'moderation_note': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'moderation_state': ('django.db.models.fields.CharField', [], {'default': "'PE'", 'max_length': '2', 'db_index': 'True'}),
            'num_comments': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'num_downloads': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'num_ratings': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'original_filename': ('django.db.models.fields.CharField', [], {'max_length': '512'}),
            'original_path': ('django.db.models.fields.CharField', [], {'default': 'None', 'max_length': '512', 'null': 'True', 'blank': 'True'}),
            'pack': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['sounds.Pack']", 'null': 'True', 'blank': 'True'}),
            'processing_date': ('django.db.models.fields.DateTimeField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'processing_log': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'processing_state': ('django.db.models.fields.CharField', [], {'default': "'PE'", 'max_length': '2', 'db_index': 'True'}),
            'samplerate': ('django.db.models.fields.FloatField', [], {'default': '0'}),
            'similarity_state': ('django.db.models.fields.CharField', [], {'default': "'PE'", 'max_length': '2', 'db_index': 'True'}),
            'sources': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'remixes'", 'blank': 'True', 'to': "orm['sounds.Sound']"}),
            'type': ('django.db.models.fields.CharField', [], {'max_length': '4', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'sounds'", 'to': "orm['auth.User']"})
        },
        'tags.tag': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '100', 'db_index': 'True'})
        },
        'tags.taggeditem': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('tag', 'content_type', 'object_id'),)", 'object_name': 'TaggedItem'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'tag': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['tags.Tag']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        }
    }

    complete_apps = ['sounds']

########NEW FILE########
__FILENAME__ = 0004_auto__add_field_sound_crc__add_field_pack_license_crc
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'Sound.crc'
        db.add_column('sounds_sound', 'crc', self.gf('django.db.models.fields.CharField')(default='', max_length=8, blank=True), keep_default=False)

        # Adding field 'Pack.license_crc'
        db.add_column('sounds_pack', 'license_crc', self.gf('django.db.models.fields.CharField')(default='', max_length=8, blank=True), keep_default=False)


    def backwards(self, orm):
        
        # Deleting field 'Sound.crc'
        db.delete_column('sounds_sound', 'crc')

        # Deleting field 'Pack.license_crc'
        db.delete_column('sounds_pack', 'license_crc')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'comments.comment': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Comment'},
            'comment': ('django.db.models.fields.TextField', [], {}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'related_name': "'replies'", 'null': 'True', 'blank': 'True', 'to': "orm['comments.Comment']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'favorites.favorite': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'Favorite'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'geotags.geotag': {
            'Meta': {'object_name': 'GeoTag'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lat': ('django.db.models.fields.FloatField', [], {'db_index': 'True'}),
            'lon': ('django.db.models.fields.FloatField', [], {'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'zoom': ('django.db.models.fields.IntegerField', [], {})
        },
        'ratings.rating': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'Rating'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'rating': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'sounds.deletedsound': {
            'Meta': {'object_name': 'DeletedSound'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'sound_id': ('django.db.models.fields.IntegerField', [], {'default': '0', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'sounds.download': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Download'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'pack': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['sounds.Pack']", 'null': 'True', 'blank': 'True'}),
            'sound': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['sounds.Sound']", 'null': 'True', 'blank': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'sounds.flag': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Flag'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'reason': ('django.db.models.fields.TextField', [], {}),
            'reason_type': ('django.db.models.fields.CharField', [], {'default': "'I'", 'max_length': '1'}),
            'reporting_user': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['auth.User']", 'null': 'True', 'blank': 'True'}),
            'sound': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sounds.Sound']"})
        },
        'sounds.license': {
            'Meta': {'ordering': "['order']", 'object_name': 'License'},
            'abbreviation': ('django.db.models.fields.CharField', [], {'max_length': '8', 'db_index': 'True'}),
            'deed_url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'legal_code_url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '512'}),
            'order': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'summary': ('django.db.models.fields.TextField', [], {})
        },
        'sounds.pack': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'name'),)", 'object_name': 'Pack'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_dirty': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'license_crc': ('django.db.models.fields.CharField', [], {'max_length': '8', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'num_downloads': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'sounds.remixgroup': {
            'Meta': {'object_name': 'RemixGroup'},
            'group_size': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'protovis_data': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'sounds': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'remix_group'", 'blank': 'True', 'to': "orm['sounds.Sound']"})
        },
        'sounds.sound': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Sound'},
            'analysis_state': ('django.db.models.fields.CharField', [], {'default': "'PE'", 'max_length': '2', 'db_index': 'True'}),
            'avg_rating': ('django.db.models.fields.FloatField', [], {'default': '0'}),
            'base_filename_slug': ('django.db.models.fields.CharField', [], {'default': 'None', 'max_length': '512', 'null': 'True', 'blank': 'True'}),
            'bitdepth': ('django.db.models.fields.IntegerField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'bitrate': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'channels': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'crc': ('django.db.models.fields.CharField', [], {'max_length': '8', 'blank': 'True'}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'date_recorded': ('django.db.models.fields.DateField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'duration': ('django.db.models.fields.FloatField', [], {'default': '0'}),
            'filesize': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'geotag': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['geotags.GeoTag']", 'null': 'True', 'blank': 'True'}),
            'has_bad_description': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_index_dirty': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'license': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sounds.License']"}),
            'md5': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'moderation_date': ('django.db.models.fields.DateTimeField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'moderation_note': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'moderation_state': ('django.db.models.fields.CharField', [], {'default': "'PE'", 'max_length': '2', 'db_index': 'True'}),
            'num_comments': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'num_downloads': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'num_ratings': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'original_filename': ('django.db.models.fields.CharField', [], {'max_length': '512'}),
            'original_path': ('django.db.models.fields.CharField', [], {'default': 'None', 'max_length': '512', 'null': 'True', 'blank': 'True'}),
            'pack': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['sounds.Pack']", 'null': 'True', 'blank': 'True'}),
            'processing_date': ('django.db.models.fields.DateTimeField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'processing_log': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'processing_state': ('django.db.models.fields.CharField', [], {'default': "'PE'", 'max_length': '2', 'db_index': 'True'}),
            'samplerate': ('django.db.models.fields.FloatField', [], {'default': '0'}),
            'similarity_state': ('django.db.models.fields.CharField', [], {'default': "'PE'", 'max_length': '2', 'db_index': 'True'}),
            'sources': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'remixes'", 'blank': 'True', 'to': "orm['sounds.Sound']"}),
            'type': ('django.db.models.fields.CharField', [], {'max_length': '4', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'sounds'", 'to': "orm['auth.User']"})
        },
        'tags.tag': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '100', 'db_index': 'True'})
        },
        'tags.taggeditem': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('tag', 'content_type', 'object_id'),)", 'object_name': 'TaggedItem'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'tag': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['tags.Tag']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        }
    }

    complete_apps = ['sounds']

########NEW FILE########
__FILENAME__ = 0005_add_indexes_Download
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        db.create_index('sounds_download', ['user_id', 'created'])
        db.create_index('sounds_download', ['sound_id', 'created'])
        db.execute("CREATE INDEX sounds_download_pack_id_nn_created ON sounds_download(pack_id, created) where pack_id is not null")

    def backwards(self, orm):
        
        db.delete_index('sounds_download', ['user_id', 'created'])
        db.delete_index('sounds_download', ['sound_id', 'created'])
        db.execute("DROP INDEX sounds_download_pack_id_nn_created")


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'comments.comment': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Comment'},
            'comment': ('django.db.models.fields.TextField', [], {}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'related_name': "'replies'", 'null': 'True', 'blank': 'True', 'to': "orm['comments.Comment']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'favorites.favorite': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'Favorite'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'geotags.geotag': {
            'Meta': {'object_name': 'GeoTag'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lat': ('django.db.models.fields.FloatField', [], {'db_index': 'True'}),
            'lon': ('django.db.models.fields.FloatField', [], {'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'zoom': ('django.db.models.fields.IntegerField', [], {})
        },
        'ratings.rating': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'Rating'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'rating': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'sounds.deletedsound': {
            'Meta': {'object_name': 'DeletedSound'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'sound_id': ('django.db.models.fields.IntegerField', [], {'default': '0', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'sounds.download': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Download'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'pack': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['sounds.Pack']", 'null': 'True', 'blank': 'True'}),
            'sound': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['sounds.Sound']", 'null': 'True', 'blank': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'sounds.flag': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Flag'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'reason': ('django.db.models.fields.TextField', [], {}),
            'reason_type': ('django.db.models.fields.CharField', [], {'default': "'I'", 'max_length': '1'}),
            'reporting_user': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['auth.User']", 'null': 'True', 'blank': 'True'}),
            'sound': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sounds.Sound']"})
        },
        'sounds.license': {
            'Meta': {'ordering': "['order']", 'object_name': 'License'},
            'abbreviation': ('django.db.models.fields.CharField', [], {'max_length': '8', 'db_index': 'True'}),
            'deed_url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'legal_code_url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '512'}),
            'order': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'summary': ('django.db.models.fields.TextField', [], {})
        },
        'sounds.pack': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'name'),)", 'object_name': 'Pack'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_dirty': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'license_crc': ('django.db.models.fields.CharField', [], {'max_length': '8', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'num_downloads': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'sounds.remixgroup': {
            'Meta': {'object_name': 'RemixGroup'},
            'group_size': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'protovis_data': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'sounds': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'remix_group'", 'blank': 'True', 'to': "orm['sounds.Sound']"})
        },
        'sounds.sound': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Sound'},
            'analysis_state': ('django.db.models.fields.CharField', [], {'default': "'PE'", 'max_length': '2', 'db_index': 'True'}),
            'avg_rating': ('django.db.models.fields.FloatField', [], {'default': '0'}),
            'base_filename_slug': ('django.db.models.fields.CharField', [], {'default': 'None', 'max_length': '512', 'null': 'True', 'blank': 'True'}),
            'bitdepth': ('django.db.models.fields.IntegerField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'bitrate': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'channels': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'crc': ('django.db.models.fields.CharField', [], {'max_length': '8', 'blank': 'True'}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'date_recorded': ('django.db.models.fields.DateField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'duration': ('django.db.models.fields.FloatField', [], {'default': '0'}),
            'filesize': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'geotag': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['geotags.GeoTag']", 'null': 'True', 'blank': 'True'}),
            'has_bad_description': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_index_dirty': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'license': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sounds.License']"}),
            'md5': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'moderation_date': ('django.db.models.fields.DateTimeField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'moderation_note': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'moderation_state': ('django.db.models.fields.CharField', [], {'default': "'PE'", 'max_length': '2', 'db_index': 'True'}),
            'num_comments': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'num_downloads': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'num_ratings': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'original_filename': ('django.db.models.fields.CharField', [], {'max_length': '512'}),
            'original_path': ('django.db.models.fields.CharField', [], {'default': 'None', 'max_length': '512', 'null': 'True', 'blank': 'True'}),
            'pack': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['sounds.Pack']", 'null': 'True', 'blank': 'True'}),
            'processing_date': ('django.db.models.fields.DateTimeField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'processing_log': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'processing_state': ('django.db.models.fields.CharField', [], {'default': "'PE'", 'max_length': '2', 'db_index': 'True'}),
            'samplerate': ('django.db.models.fields.FloatField', [], {'default': '0'}),
            'similarity_state': ('django.db.models.fields.CharField', [], {'default': "'PE'", 'max_length': '2', 'db_index': 'True'}),
            'sources': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'remixes'", 'blank': 'True', 'to': "orm['sounds.Sound']"}),
            'type': ('django.db.models.fields.CharField', [], {'max_length': '4', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'sounds'", 'to': "orm['auth.User']"})
        },
        'tags.tag': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '100', 'db_index': 'True'})
        },
        'tags.taggeditem': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('tag', 'content_type', 'object_id'),)", 'object_name': 'TaggedItem'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'tag': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['tags.Tag']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        }
    }

    complete_apps = ['sounds']

########NEW FILE########
__FILENAME__ = 0006_auto__add_field_pack_num_sounds__add_field_pack_last_updated
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'Pack.num_sounds'
        db.add_column('sounds_pack', 'num_sounds', self.gf('django.db.models.fields.PositiveIntegerField')(default=0), keep_default=False)
        db.create_index('sounds_pack', ['num_sounds'])

        # Adding field 'Pack.last_updated'
        db.add_column('sounds_pack', 'last_updated', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, default=datetime.datetime(2014, 3, 7, 14, 32, 15, 377395), db_index=True, blank=True), keep_default=False)


    def backwards(self, orm):
        
        # Deleting field 'Pack.num_sounds'
        db.delete_column('sounds_pack', 'num_sounds')

        # Deleting field 'Pack.last_updated'
        db.delete_column('sounds_pack', 'last_updated')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'comments.comment': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Comment'},
            'comment': ('django.db.models.fields.TextField', [], {}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'related_name': "'replies'", 'null': 'True', 'blank': 'True', 'to': "orm['comments.Comment']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'favorites.favorite': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'Favorite'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'geotags.geotag': {
            'Meta': {'object_name': 'GeoTag'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lat': ('django.db.models.fields.FloatField', [], {'db_index': 'True'}),
            'lon': ('django.db.models.fields.FloatField', [], {'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'zoom': ('django.db.models.fields.IntegerField', [], {})
        },
        'ratings.rating': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'Rating'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'rating': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'sounds.deletedsound': {
            'Meta': {'object_name': 'DeletedSound'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'sound_id': ('django.db.models.fields.IntegerField', [], {'default': '0', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'sounds.download': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Download'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'pack': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['sounds.Pack']", 'null': 'True', 'blank': 'True'}),
            'sound': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['sounds.Sound']", 'null': 'True', 'blank': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'sounds.flag': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Flag'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'reason': ('django.db.models.fields.TextField', [], {}),
            'reason_type': ('django.db.models.fields.CharField', [], {'default': "'I'", 'max_length': '1'}),
            'reporting_user': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['auth.User']", 'null': 'True', 'blank': 'True'}),
            'sound': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sounds.Sound']"})
        },
        'sounds.license': {
            'Meta': {'ordering': "['order']", 'object_name': 'License'},
            'abbreviation': ('django.db.models.fields.CharField', [], {'max_length': '8', 'db_index': 'True'}),
            'deed_url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'legal_code_url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '512'}),
            'order': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'summary': ('django.db.models.fields.TextField', [], {})
        },
        'sounds.pack': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('user', 'name'),)", 'object_name': 'Pack'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_dirty': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'license_crc': ('django.db.models.fields.CharField', [], {'max_length': '8', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'num_downloads': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'num_sounds': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'sounds.remixgroup': {
            'Meta': {'object_name': 'RemixGroup'},
            'group_size': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'protovis_data': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'sounds': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'remix_group'", 'blank': 'True', 'to': "orm['sounds.Sound']"})
        },
        'sounds.sound': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Sound'},
            'analysis_state': ('django.db.models.fields.CharField', [], {'default': "'PE'", 'max_length': '2', 'db_index': 'True'}),
            'avg_rating': ('django.db.models.fields.FloatField', [], {'default': '0'}),
            'base_filename_slug': ('django.db.models.fields.CharField', [], {'default': 'None', 'max_length': '512', 'null': 'True', 'blank': 'True'}),
            'bitdepth': ('django.db.models.fields.IntegerField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'bitrate': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'channels': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'crc': ('django.db.models.fields.CharField', [], {'max_length': '8', 'blank': 'True'}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'date_recorded': ('django.db.models.fields.DateField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'duration': ('django.db.models.fields.FloatField', [], {'default': '0'}),
            'filesize': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'geotag': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['geotags.GeoTag']", 'null': 'True', 'blank': 'True'}),
            'has_bad_description': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_index_dirty': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'license': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sounds.License']"}),
            'md5': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'moderation_date': ('django.db.models.fields.DateTimeField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'moderation_note': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'moderation_state': ('django.db.models.fields.CharField', [], {'default': "'PE'", 'max_length': '2', 'db_index': 'True'}),
            'num_comments': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'num_downloads': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'num_ratings': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'original_filename': ('django.db.models.fields.CharField', [], {'max_length': '512'}),
            'original_path': ('django.db.models.fields.CharField', [], {'default': 'None', 'max_length': '512', 'null': 'True', 'blank': 'True'}),
            'pack': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['sounds.Pack']", 'null': 'True', 'blank': 'True'}),
            'processing_date': ('django.db.models.fields.DateTimeField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'processing_log': ('django.db.models.fields.TextField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'processing_state': ('django.db.models.fields.CharField', [], {'default': "'PE'", 'max_length': '2', 'db_index': 'True'}),
            'samplerate': ('django.db.models.fields.FloatField', [], {'default': '0'}),
            'similarity_state': ('django.db.models.fields.CharField', [], {'default': "'PE'", 'max_length': '2', 'db_index': 'True'}),
            'sources': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'remixes'", 'blank': 'True', 'to': "orm['sounds.Sound']"}),
            'type': ('django.db.models.fields.CharField', [], {'max_length': '4', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'sounds'", 'to': "orm['auth.User']"})
        },
        'tags.tag': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '100', 'db_index': 'True'})
        },
        'tags.taggeditem': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('tag', 'content_type', 'object_id'),)", 'object_name': 'TaggedItem'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'tag': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['tags.Tag']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        }
    }

    complete_apps = ['sounds']

########NEW FILE########
__FILENAME__ = models
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.conf import settings
from django.contrib.auth.models import User
from django.db import models, connection
from django.utils.encoding import smart_unicode
from django.utils.translation import ugettext as _
from general.models import OrderedModel, SocialModel
from geotags.models import GeoTag
from tags.models import TaggedItem, Tag
from utils.sql import DelayedQueryExecuter
from utils.text import slugify
from utils.locations import locations_decorator
import os, logging, random, datetime, gearman, tempfile, shutil, subprocess
from utils.search.search import delete_sound_from_solr
from utils.filesystem import delete_object_files
from django.db import connection, transaction
from search.views import get_pack_tags
from django.db.models import Count
from django.db.models.signals import post_delete, post_save, pre_save
from django.contrib.contenttypes import generic
from similarity.client import Similarity

search_logger = logging.getLogger('search')
web_logger = logging.getLogger('web')
audio_logger = logging.getLogger('audio')

class License(OrderedModel):
    """A creative commons license model"""
    name = models.CharField(max_length=512)
    abbreviation = models.CharField(max_length=8, db_index=True)
    summary = models.TextField()
    deed_url = models.URLField()
    legal_code_url = models.URLField()
    is_public = models.BooleanField(default=True)

    def __unicode__(self):
        return self.name

class SoundManager(models.Manager):
    def latest_additions(self, num_sounds, period='2 weeks', use_interval=True):
        interval_query = ("and created > now() - interval '%s'" % period) if use_interval else ""
        query = """
                select
                    username,
                    sound_id,
                    extra
                from (
                select
                    (select username from auth_user where auth_user.id = user_id) as username,
                    max(id) as sound_id,
                    max(created) as created,
                    count(*) - 1 as extra
                from
                    sounds_sound
                where
                    processing_state = 'OK' and
                    moderation_state = 'OK'
                    %s
                group by
                    user_id
                ) as X order by created desc limit %d;""" % (interval_query, num_sounds)
        return DelayedQueryExecuter(query)

    def random(self):
        sound_count = self.filter(moderation_state="OK", processing_state="OK").count()
        if sound_count:
            offset = random.randint(0, sound_count - 1)
            cursor = connection.cursor() #@UndefinedVariable
            cursor.execute("""select id from sounds_sound
                              where moderation_state='OK'
                              and processing_state='OK'
                              offset %d limit 1""" % offset)
            return cursor.fetchone()[0]
        else:
            return None


class PublicSoundManager(models.Manager):
    """ a class which only returns public sounds """
    def get_query_set(self):
        return super(PublicSoundManager, self).get_query_set().filter(moderation_state="OK", processing_state="OK")

class Sound(SocialModel):
    user = models.ForeignKey(User, related_name='sounds')
    created = models.DateTimeField(db_index=True, auto_now_add=True)

    # filenames
    original_filename = models.CharField(max_length=512) # name of the file the user uploaded
    original_path = models.CharField(max_length=512, null=True, blank=True, default=None) # name of the file on disk before processing
    base_filename_slug = models.CharField(max_length=512, null=True, blank=True, default=None) # base of the filename, this will be something like: id__username__filenameslug

    # user defined fields
    description = models.TextField()
    date_recorded = models.DateField(null=True, blank=True, default=None)

    license = models.ForeignKey(License)
    sources = models.ManyToManyField('self', symmetrical=False, related_name='remixes', blank=True)
    pack = models.ForeignKey('Pack', null=True, blank=True, default=None, on_delete=models.SET_NULL)
    geotag = models.ForeignKey(GeoTag, null=True, blank=True, default=None, on_delete=models.SET_NULL)

    # file properties
    SOUND_TYPE_CHOICES = (
        ('wav', 'Wave'),
        ('ogg', 'Ogg Vorbis'),
        ('aiff', 'AIFF'),
        ('mp3', 'Mp3'),
        ('flac', 'Flac')
    )
    type = models.CharField(db_index=True, max_length=4, choices=SOUND_TYPE_CHOICES)
    duration = models.FloatField(default=0)
    bitrate = models.IntegerField(default=0)
    bitdepth = models.IntegerField(null=True, blank=True, default=None)
    samplerate = models.FloatField(default=0)
    filesize = models.IntegerField(default=0)
    channels = models.IntegerField(default=0)
    md5 = models.CharField(max_length=32, unique=True, db_index=True)
    crc = models.CharField(max_length=8,blank=True)
    is_index_dirty = models.BooleanField(null=False, default=True)

    # moderation
    MODERATION_STATE_CHOICES = (
        ("PE",_('Pending')),
        ("OK",_('OK')),
        ("DE",_('Deferred')),
    )
    moderation_state = models.CharField(db_index=True, max_length=2, choices=MODERATION_STATE_CHOICES, default="PE")
    moderation_date = models.DateTimeField(null=True, blank=True, default=None)
    moderation_note = models.TextField(null=True, blank=True, default=None)
    has_bad_description = models.BooleanField(default=False)

    # processing
    PROCESSING_STATE_CHOICES = (
        ("QU",_('Queued')),
        ("PE",_('Pending')),
        ("PR",_('Processing')),
        ("OK",_('OK')),
        ("FA",_('Failed')),
    )
    processing_state = models.CharField(db_index=True, max_length=2, choices=PROCESSING_STATE_CHOICES, default="PE")
    processing_date = models.DateTimeField(null=True, blank=True, default=None)
    processing_log = models.TextField(null=True, blank=True, default=None)

    similarity_state = models.CharField(db_index=True, max_length=2, choices=PROCESSING_STATE_CHOICES, default="PE")
    analysis_state = models.CharField(db_index=True, max_length=2, choices=PROCESSING_STATE_CHOICES, default="PE")

    num_comments = models.PositiveIntegerField(default=0)
    num_downloads = models.PositiveIntegerField(default=0)

    avg_rating = models.FloatField(default=0)
    num_ratings = models.PositiveIntegerField(default=0)

    objects = SoundManager()
    public = PublicSoundManager()

    def __unicode__(self):
        return self.base_filename_slug

    def friendly_filename(self):
        filename_slug = slugify(os.path.splitext(self.original_filename)[0])
        username_slug =  slugify(self.user.username)
        return "%d__%s__%s.%s" % (self.id, username_slug, filename_slug, self.type)

    @locations_decorator()
    def locations(self):
        id_folder = str(self.id/1000)
        sound_user_id = self.user_id
        return dict(
            path = os.path.join(settings.SOUNDS_PATH, id_folder, "%d_%d.%s" % (self.id, sound_user_id, self.type)),
            sendfile_url = settings.SOUNDS_SENDFILE_URL + "%s/%d_%d.%s" % (id_folder, self.id, sound_user_id, self.type),
            preview = dict(
                HQ = dict(
                    mp3 = dict(
                        path = os.path.join(settings.PREVIEWS_PATH, id_folder, "%d_%d-hq.mp3" % (self.id, sound_user_id)),
                        url = settings.PREVIEWS_URL + "%s/%d_%d-hq.mp3" % (id_folder, self.id, sound_user_id)
                    ),
                    ogg = dict(
                        path = os.path.join(settings.PREVIEWS_PATH, id_folder, "%d_%d-hq.ogg" % (self.id, sound_user_id)),
                        url = settings.PREVIEWS_URL + "%s/%d_%d-hq.ogg" % (id_folder, self.id, sound_user_id)
                    )
                ),
                LQ = dict(
                    mp3 = dict(
                        path = os.path.join(settings.PREVIEWS_PATH, id_folder, "%d_%d-lq.mp3" % (self.id, sound_user_id)),
                        url = settings.PREVIEWS_URL + "%s/%d_%d-lq.mp3" % (id_folder, self.id, sound_user_id),
                        # The alternative url is sent to the requesting browser if the clickthrough logger is activated
                        # After logging the clickthrough data, the reponse is redirected to a url stripped of the _alt part.
                        # the redirect will be handled by nginx
                        url_alt = settings.PREVIEWS_URL.replace("previews","previews_alt") + "%s/%d_%d-lq.mp3" % (id_folder, self.id, sound_user_id)
                    ),
                    ogg = dict(
                        path = os.path.join(settings.PREVIEWS_PATH, id_folder, "%d_%d-lq.ogg" % (self.id, sound_user_id)),
                        url = settings.PREVIEWS_URL + "%s/%d_%d-lq.ogg" % (id_folder, self.id, sound_user_id),
                        # Refer to comments in mp3.url_alt 
                        url_alt = settings.PREVIEWS_URL.replace("previews","previews_alt") + "%s/%d_%d-lq.ogg" % (id_folder, self.id, sound_user_id)
                    ),
                )
            ),
            display = dict(
                spectral = dict(
#                    S = dict(
#                        path = os.path.join(settings.DISPLAYS_PATH, id_folder, "%d_%d_spec_S.jpg" % (self.id, sound_user_id)),
#                        url = settings.DISPLAYS_URL + "%s/%d_%d_spec_S.jpg" % (id_folder, self.id, sound_user_id)
#                    ),
                    M = dict(
                        path = os.path.join(settings.DISPLAYS_PATH, id_folder, "%d_%d_spec_M.jpg" % (self.id, sound_user_id)),
                        url = settings.DISPLAYS_URL + "%s/%d_%d_spec_M.jpg" % (id_folder, self.id, sound_user_id)
                    ),
                    L = dict(
                        path = os.path.join(settings.DISPLAYS_PATH, id_folder, "%d_%d_spec_L.jpg" % (self.id, sound_user_id)),
                        url = settings.DISPLAYS_URL + "%s/%d_%d_spec_L.jpg" % (id_folder, self.id, sound_user_id)
                    )
                ),
                wave = dict(
#                    S = dict(
#                        path = os.path.join(settings.DISPLAYS_PATH, id_folder, "%d_%d_wave_S.png" % (self.id, sound_user_id)),
#                        url = settings.DISPLAYS_URL + "%s/%d_%d_wave_S.png" % (id_folder, self.id, sound_user_id)
#                    ),
                    M = dict(
                        path = os.path.join(settings.DISPLAYS_PATH, id_folder, "%d_%d_wave_M.png" % (self.id, sound_user_id)),
                        url = settings.DISPLAYS_URL + "%s/%d_%d_wave_M.png" % (id_folder, self.id, sound_user_id)
                    ),
                    L = dict(
                        path = os.path.join(settings.DISPLAYS_PATH, id_folder, "%d_%d_wave_L.png" % (self.id, sound_user_id)),
                        url = settings.DISPLAYS_URL + "%s/%d_%d_wave_L.png" % (id_folder, self.id, sound_user_id)
                    )
                )
            ),
            analysis = dict(
                statistics = dict(
                    path = os.path.join(settings.ANALYSIS_PATH, id_folder, "%d_%d_statistics.yaml" % (self.id, sound_user_id)),
                    url = settings.ANALYSIS_URL + "%s/%d_%d_statistics.yaml" % (id_folder, self.id, sound_user_id)
                ),
                frames = dict(
                    path = os.path.join(settings.ANALYSIS_PATH, id_folder, "%d_%d_frames.json" % (self.id, sound_user_id)),
                    url = settings.ANALYSIS_URL + "%s/%d_%d_frames.json" % (id_folder, self.id, sound_user_id)
                )
            )
        )

    def get_channels_display(self):
        if self.channels == 1:
            return u"Mono"
        elif self.channels == 2:
            return u"Stereo"
        else:
            return self.channels

    def type_warning(self):
        return self.type == "ogg" or self.type == "flac"

    def duration_warning(self):
        # warn from 5 minutes and more
        return self.duration > 60*5

    def filesize_warning(self):
        # warn for 50MB and up
        return self.filesize > 50 * 1024 * 1024

    def samplerate_warning(self):
        # warn anything special
        return self.samplerate not in [11025, 22050, 44100]

    def bitdepth_warning(self):
        return self.bitdepth not in [8,16]

    def bitrate_warning(self):
        return self.bitrate not in [32, 64, 96, 128, 160, 192, 224, 256, 320]

    def channels_warning(self):
        return self.channels not in [1,2]

    def duration_ms(self):
        return self.duration * 1000

    def rating_percent(self):
        return int(self.avg_rating*10)

    def process(self, force=False):
        gm_client = gearman.GearmanClient(settings.GEARMAN_JOB_SERVERS)
        if force or self.processing_state != "OK":
            #self.processing_date = datetime.datetime.now()
            self.set_processing_state("QU")
            gm_client.submit_job("process_sound", str(self.id), wait_until_complete=False, background=True)
            audio_logger.info("Send sound with id %s to queue 'process'" % self.id)
        if force or self.analysis_state != "OK":
            self.set_analysis_state("QU")
            gm_client.submit_job("analyze_sound", str(self.id), wait_until_complete=False, background=True)
            audio_logger.info("Send sound with id %s to queue 'analyze'" % self.id)
        #self.save()

    def mark_index_dirty(self):
        self.is_index_dirty = True
        self.save()


    @models.permalink
    def get_absolute_url(self):
        return ('sound', (self.user.username, smart_unicode(self.id),))

    def set_tags(self, tags):
        # remove tags that are not in the list
        for tagged_item in self.tags.all():
            if tagged_item.tag.name not in tags:
                tagged_item.delete()

        # add tags that are not there yet
        for tag in tags:
            if self.tags.filter(tag__name=tag).count() == 0:
                (tag_object, created) = Tag.objects.get_or_create(name=tag) #@UnusedVariable
                tagged_object = TaggedItem.objects.create(user=self.user, tag=tag_object, content_object=self)
                tagged_object.save()

    # N.B. These set functions are used in the distributed processing.
    # They set a single field to prevent overwriting eachother's result in
    # the database, which is what happens if you use Django's save() method.
    def set_single_field(self, field, value, include_quotes=True):
        self.set_fields([[field, value, include_quotes]])

    def set_fields(self, fields):
        query = "UPDATE sounds_sound SET "
        query += ", ".join([('%s = %s' % (field[0], (field[1] if not field[2] else ("'%s'" % field[1])))) for field in fields])
        query += " WHERE id = %s" % self.id
        cursor = connection.cursor()
        cursor.execute(query)
        transaction.commit_unless_managed()

    def set_processing_state(self, state):
        self.set_single_field('processing_state', state)

    def set_analysis_state(self, state):
        self.set_single_field('analysis_state', state)

    def set_similarity_state(self, state):
        self.set_single_field('similarity_state', state)

    def set_moderation_state(self, state):
        self.set_single_field('moderation_state', state)

    def set_original_path(self, path):
        self.set_single_field('original_path', path)

    def set_audio_info_fields(self, info):
        field_names = ['samplerate', 'bitrate', 'bitdepth', 'channels', 'duration']
        field_values = [[field, info[field] if info[field] is not None else "null", False] for field in field_names]
        self.set_fields(field_values)
    
    def compute_crc(self):
        p = subprocess.Popen(["crc32",self.locations('path')],stdout=subprocess.PIPE)
        self.crc= p.communicate()[0].split(" ")[0][:-1]
        self.save()

    # N.B. This is used in the ticket template (ugly, but a quick fix)
    def is_sound(self):
        return True

    # N.B. Temporary, so we can get rid of the original_path which breaks things in migration
    #@property
    #def original_path(self):
    #    return self.locations("path")

    #@original_path.setter
    #def original_path(self, value):
    #    return self.set_original_path(value)


    class Meta(SocialModel.Meta):
        ordering = ("-created", )


class DeletedSound(models.Model):
    user = models.ForeignKey(User)
    sound_id = models.IntegerField(default=0, db_index=True)

def on_delete_sound(sender,instance, **kwargs):
    if instance.moderation_state == "OK" and instance.processing_state == "OK":
        try:
            DeletedSound.objects.get_or_create(sound_id=instance.id, user=instance.user)
        except User.DoesNotExist:
            deleted_user = User.objects.get(id=settings.DELETED_USER_ID)
            DeletedSound.objects.get_or_create(sound_id=instance.id, user=deleted_user)
        
    try:            
        if instance.geotag:
            instance.geotag.delete()
    except:
        pass
    if instance.pack:
        instance.pack.process()
    
    delete_sound_from_solr(instance)
    delete_object_files(instance, web_logger)
    if instance.similarity_state=='OK':
	try:
    		if Similarity.contains(instance.id):
        		Similarity.delete(instance.id)
	except:
		web_logger.warn("ommitting similarity deletion for deleted sound %d"%instance.id)
		
    web_logger.debug("Deleted sound with id %i"%instance.id)

post_delete.connect(on_delete_sound, sender=Sound)

def recreate_pack(sender,instance,**kwargs):
    if instance.moderation_state=="OK" and instance.pack:
        instance.pack.process()
 
post_save.connect(recreate_pack, sender=Sound)

def set_dirty(sender,instance,**kwargs):
    instance.is_index_dirty=True

pre_save.connect(set_dirty, sender=Sound)


class Pack(SocialModel):
    user = models.ForeignKey(User)
    name = models.CharField(max_length=255)
    description = models.TextField(null=True, blank=True, default=None)
    is_dirty = models.BooleanField(db_index=True, default=False)

    created = models.DateTimeField(db_index=True, auto_now_add=True)
    num_downloads = models.PositiveIntegerField(default=0)
    license_crc = models.CharField(max_length=8,blank=True)

    num_sounds = models.PositiveIntegerField(default=0)
    last_updated = models.DateTimeField(db_index=True, auto_now_add=True)

    def __unicode__(self):
        return self.name

    @models.permalink
    def get_absolute_url(self):
        return ('pack', (self.user.username, smart_unicode(self.id),))

    class Meta(SocialModel.Meta):
        unique_together = ('user', 'name')
        ordering = ("-created",)

    def friendly_filename(self):
        name_slug = slugify(self.name)
        username_slug =  slugify(self.user.username)
        return "%d__%s__%s.zip" % (self.id, username_slug, name_slug)

    @locations_decorator()
    def locations(self):
        return dict(
                    sendfile_url = settings.PACKS_SENDFILE_URL + "%d.zip" % self.id,
                    license_url = settings.PACKS_SENDFILE_URL + "%d_license.txt" % self.id,
                    license_path = os.path.join(settings.PACKS_PATH, "%d_license.txt" % self.id),
                    path = os.path.join(settings.PACKS_PATH, "%d.txt" % self.id),
                   )

    def process(self):
        sounds = self.sound_set.filter(processing_state="OK", moderation_state="OK").order_by("-created")
        self.num_sounds = sounds.count()
        if self.num_sounds:
            self.last_updated = sounds[0].created
        self.create_license_file()
        self.save()
    
    def create_license_file(self):
        """ Create a license file containing the licenses of all sounds in the
            pack, and update the pack license_crc field, but DO NOT save the pack
        """
        from django.template.loader import render_to_string
        pack_sounds = Sound.objects.filter(pack=self.id,processing_state="OK", moderation_state="OK")
        if len(pack_sounds)>0:
             licenses = License.objects.all()
             license_path = self.locations("license_path")
             attribution = render_to_string("sounds/pack_attribution.txt", dict(pack=self, licenses=licenses,sound_list = pack_sounds))
             f = open(license_path,'w')
             f.write(attribution.encode("UTF-8"))
             f.close()
             p = subprocess.Popen(["crc32",license_path],stdout=subprocess.PIPE)
             self.license_crc = p.communicate()[0].split(" ")[0][:-1]
    
    def get_random_sound_from_pack(self):
        pack_sounds = Sound.objects.filter(pack=self.id,processing_state="OK", moderation_state="OK").order_by('?')[0:1]
        return pack_sounds[0]

    def get_random_sounds_from_pack(self):
        pack_sounds = Sound.objects.filter(pack=self.id,processing_state="OK", moderation_state="OK").order_by('?')[0:3]
        return pack_sounds[0:min(3,len(pack_sounds))]

    def get_pack_tags(self, max_tags = 50):
        pack_tags = get_pack_tags(self)
        if pack_tags != False :
            tags = [t[0] for t in pack_tags['tag']]
            return {'tags': tags, 'num_tags': len(tags)}
        else :
            return -1

    def remove_sounds_from_pack(self):
        Sound.objects.filter(pack_id=self.id).update(pack=None)
        self.process()
  
    def delete(self):
        """ This deletes all sounds in the pack as well. """
        # TODO: remove from solr?
        # delete files
        delete_object_files(self, web_logger)
        # super class delete
        super(SocialModel, self).delete()


class Flag(models.Model):
    sound = models.ForeignKey(Sound)
    reporting_user = models.ForeignKey(User, null=True, blank=True, default=None)
    email = models.EmailField()
    REASON_TYPE_CHOICES = (
        ("O",_('Offending sound')),
        ("I",_('Illegal sound')),
        ("T",_('Other problem')),
    )
    reason_type = models.CharField(max_length=1, choices=REASON_TYPE_CHOICES, default="I")
    reason = models.TextField()

    created = models.DateTimeField(db_index=True, auto_now_add=True)

    def __unicode__(self):
        return u"%s: %s" % (self.reason_type, self.reason[:100])

    class Meta:
        ordering = ("-created",)


class Download(models.Model):
    # download interface (UNUSED)
    #DOWNLOAD_INTERFACE_CHOICES = (
    #    ("W",_('Web')),
    #    ("A",_('API')),
    #)

    user = models.ForeignKey(User)
    sound = models.ForeignKey(Sound, null=True, blank=True, default=None)
    pack = models.ForeignKey(Pack, null=True, blank=True, default=None)
    created = models.DateTimeField(db_index=True, auto_now_add=True)
    #interface = models.CharField(db_index=True, max_length=1, choices=DOWNLOAD_INTERFACE_CHOICES, default="W")

    class Meta:
        ordering = ("-created",)


class RemixGroup(models.Model):
    protovis_data = models.TextField(null=True, blank=True, default=None)
    # facilitate recreating the remixgroup
    # FIXME: temp commented to not fuckup the deployment in tabasco
    # networkx_data = models.TextField(null=True, blank=True, default=None)   

    sounds = models.ManyToManyField(Sound,
                                    symmetrical=False,
                                    related_name='remix_group',
                                    blank=True)

    # facilitate ordering according to group size
    group_size = models.PositiveIntegerField(null=False, default=0)

########NEW FILE########
__FILENAME__ = display_license_form
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django import template

register = template.Library()

@register.inclusion_tag('sounds/license_form.html', takes_context=True)
def display_license_form(context, form):
    return {'form': form, "media_url": context['media_url']}
########NEW FILE########
__FILENAME__ = display_pack
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from __future__ import absolute_import
from sounds.models import Pack, Sound
from django import template

register = template.Library()

@register.inclusion_tag('sounds/display_pack.html', takes_context=True)
def display_pack(context, pack):

    if isinstance(pack, Pack):
        pack_id = pack.id
        pack_obj = [pack]
        
    else:
        pack_id = int(pack)
        try:
            #sound_obj = Sound.objects.get(id=sound_id)
            pack_obj = Pack.objects.select_related('username').filter(id=pack) # need to use filter here because we don't want the query to be evaluated already!
        except Pack.DoesNotExist:
            pack_obj = []
    
    if hasattr(pack, 'num_sounds'):
        num_sounds = pack.num_sounds
    else:
        num_sounds = Sound.objects.filter(pack=pack_id).count()

    return { 'pack_id':     pack_id,
             'pack':        pack_obj,
             'media_url':   context['media_url'],
             'num_sounds':  num_sounds,
           }

########NEW FILE########
__FILENAME__ = display_remix
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from __future__ import absolute_import, division
#avoid namespace clash with 'tags' templatetag
from django import template
import json
from random import randint

register = template.Library()
@register.inclusion_tag('sounds/display_remix.html', takes_context=True)

# TODO: ***just a reminder***
#       there is probably a more efficient way to prepare the data
#       CHECK ===> documentation for v.Layout.Network.Link #sourceNode
#
# FIXME: pagination doesn't work with this, we're missing the source....
def display_remix(context, sound, sounds):
    
    nodes = []
    links = []
    tempList = []

    # get position in queryset related to ids
    # we need this to create the links between the nodes
    for idx,val in enumerate(sounds):
        tempList.append({'id': val.id, 'pos': idx})
            
    for idx,val in enumerate(sounds):
        nodes.append({
                      'nodeName':val.original_filename,
                      'group':1,
                      'id':val.id,
                      'username': val.user.username
                      })
        
        # since we go forward in time, if a sound has sources you can assign its sources
        # the target will always be the current object
        for src in val.sources.all():
            # we don't want the sources of the first item 
            # since that could give us the whole graph
            if idx > 0:
                links.append({
                              'source': str([t['pos'] for t in tempList if t['id']==src.id]).strip('[,]'),
                              'source_id': src.id, 
                              'target': idx,
                              'target_id': val.id,
                              'value': 1
                              })
            
            
    return  { 'data' :  json.dumps({
                                    'nodes' : nodes,
                                    'links' : links,
                                    'length': len(sounds),   # to calculate canvas height
                                    'color': '#F1D9FF',
                                    'eccentricity' : __calculateEccentricity(len(sounds)) 
                                    }) }    
 
# Calculate eccentricity so the arcs don't get clipped
# N.B. this is not the canonical way to calculate eccentricity but protovis uses this formula  
def __calculateEccentricity(sounds_length):
    eccentricity = 0
    if sounds_length > 3:
        a = (sounds_length-2) * 80
        b = 200
        eccentricity = (1 - b/a) * (1 - b/a)
    
    return eccentricity

########NEW FILE########
__FILENAME__ = display_sound
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from __future__ import absolute_import
#avoid namespace clash with 'tags' templatetag
from tags.models import TaggedItem as ti
from django.contrib.contenttypes.models import ContentType
from sounds.models import Sound
from django import template
import settings

register = template.Library()
sound_content_type = ContentType.objects.get_for_model(Sound)

@register.inclusion_tag('sounds/display_sound.html', takes_context=True)
def display_sound(context, sound):

    if isinstance(sound, Sound):
        sound_id = sound.id
        sound_obj = [sound]
    else:
        sound_id = int(sound)
        try:
            #sound_obj = Sound.objects.get(id=sound_id)
            sound_obj = Sound.objects.select_related().filter(id=sound) # need to use filter here because we don't want the query to be evaluated already!
        except Sound.DoesNotExist:
            sound_obj = []

    return { 'sound_id':     sound_id,
             'sound':        sound_obj,
             'sound_tags':   ti.objects.select_related() \
                                .filter(object_id=sound_id, content_type=sound_content_type)[0:12],
             'do_log':       settings.LOG_CLICKTHROUGH_DATA,
             'media_url':    context['media_url'],
             'request':      context['request']
           }

########NEW FILE########
__FILENAME__ = pending_sounds
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django import template
import tickets.views as TicketViews

register = template.Library()

@register.simple_tag
def pending_sounds_count(user):
    pending_sounds = TicketViews.get_pending_sounds(user)
    return len(pending_sounds)


########NEW FILE########
__FILENAME__ = tests
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.test import TestCase, Client
from sounds.models import Sound, Pack
from django.core.urlresolvers import reverse

# Test old sound links redirect
class OldSoundLinksRedirectTestCase(TestCase):
    
    fixtures = ['sounds.json']
    
    def setUp(self):
        self.client = Client()
        self.sound = Sound.objects.all()[0]
        
    def test_old_sound_link_redirect_ok(self):
        # 301 permanent redirect, result exists
        response = self.client.get(reverse('old-sound-page'), data={'id' : self.sound.id})
        self.assertEqual(response.status_code, 301)
        
    def test_old_sound_link_redirect_not_exists_id(self):
        # 404 id does not exist
        response = self.client.get(reverse('old-sound-page'), data={'id' : 0}, follow=True)
        self.assertEqual(response.status_code, 404)
        
    def test_old_sound_link_redirect_invalid_id(self):
        # 404 invalid id
        response = self.client.get(reverse('old-sound-page'), data={'id' : 'invalid_id'}, follow=True)
        self.assertEqual(response.status_code, 404)    

# Test old pack links redirect
class OldPackLinksRedirectTestCase(TestCase):
    
    fixtures = ['packs.json']
            
    def setUp(self):
        self.client = Client()
        self.pack = Pack.objects.all()[0]
                    
    def test_old_pack_link_redirect_ok(self):
        response = self.client.get(reverse('old-pack-page'), data={'id' : self.pack.id})
        self.assertEqual(response.status_code, 301)
        
        
    def test_old_pack_link_redirect_not_exists_id(self):
        response = self.client.get(reverse('old-pack-page'), data={'id' : 0}, follow=True)
        self.assertEqual(response.status_code, 404)
        
        
    def test_old_pack_link_redirect_invalid_id(self):
        response = self.client.get(reverse('old-pack-page'), data={'id' : 'invalid_id'}, follow=True)
        self.assertEqual(response.status_code, 404)
########NEW FILE########
__FILENAME__ = views
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from accounts.models import Profile
from comments.forms import CommentForm
from comments.models import Comment
from django.conf import settings
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.contrib.auth.models import User, Group
from django.contrib.contenttypes.models import ContentType
from django.contrib.sites.models import Site
from django.core.cache import cache
from django.core.paginator import Paginator, PageNotAnInteger, EmptyPage
from django.core.servers.basehttp import FileWrapper
from django.core.urlresolvers import reverse
from django.db import connection, transaction
from django.db.models import Count, Max, Q
from django.http import HttpResponseRedirect, Http404, HttpResponse, \
    HttpResponsePermanentRedirect
from django.shortcuts import render_to_response, get_object_or_404
from django.template import RequestContext
from forum.models import Post, Thread
from freesound_exceptions import PermissionDenied
from geotags.models import GeoTag
from networkx import nx
from sounds.forms import SoundDescriptionForm, PackForm, GeotaggingForm, \
    NewLicenseForm, FlagForm, RemixForm, PackDescriptionForm, PackEditForm
from sounds.management.commands.create_remix_groups import _create_nodes, \
    _create_and_save_remixgroup
from sounds.models import Sound, Pack, Download, RemixGroup, DeletedSound
from sounds.templatetags import display_sound
from tickets import TICKET_SOURCE_NEW_SOUND, TICKET_STATUS_CLOSED
from tickets.models import Ticket, TicketComment
from utils.cache import invalidate_template_cache
from utils.encryption import encrypt, decrypt
from utils.functional import combine_dicts
from utils.mail import send_mail_template
from utils.nginxsendfile import sendfile
from utils.pagination import paginate
from utils.similarity_utilities import get_similar_sounds
from utils.text import remove_control_chars
import datetime
import settings
import time
import logging
import json
import os

logger = logging.getLogger('web')
logger_click = logging.getLogger('clickusage')

sound_content_type = ContentType.objects.get_for_model(Sound)

def get_random_sound():
    cache_key = "random_sound"
    random_sound = cache.get(cache_key)
    if not random_sound:
        random_sound = Sound.objects.random()
        cache.set(cache_key, random_sound, 60*60*24)
    return random_sound

def get_random_uploader():
    cache_key = "random_uploader"
    random_uploader = cache.get(cache_key)
    if not random_uploader:
        random_uploader = Profile.objects.random_uploader()
        cache.set(cache_key, random_uploader, 60*60*24)
    return random_uploader

def sounds(request):
    n_weeks_back = 1
    latest_sounds = Sound.objects.latest_additions(5, '2 days')
    latest_packs = Pack.objects.select_related().filter(num_sounds__gt=0).order_by("-last_updated")[0:20]
    last_week = datetime.datetime.now()-datetime.timedelta(weeks=n_weeks_back)

    # N.B. this two queries group by twice on sound id, if anyone ever find out why....
    #popular_sounds = Download.objects.filter(created__gte=last_week)  \
    #                                 .exclude(sound=None)             \
    #                                 .values('sound_id')              \
    #                                 .annotate(num_d=Count('sound'))  \
    #                                 .order_by("-num_d")[0:5]
    popular_sounds = Sound.objects.filter(created__gte=last_week).order_by("-num_downloads")[0:5]


    packs = Download.objects.filter(created__gte=last_week)  \
                            .exclude(pack=None)              \
                            .values('pack_id')               \
                            .annotate(num_d=Count('pack'))   \
                            .order_by("-num_d")[0:5]

    #packs = []
    popular_packs = []                              
    for pack in packs:
        pack_obj = Pack.objects.select_related().get(id=pack['pack_id'])
        popular_packs.append({'pack': pack_obj,
                              'num_d': pack['num_d']
                              })
    
    random_sound = get_random_sound()
    random_uploader = get_random_uploader()
    return render_to_response('sounds/sounds.html', locals(), context_instance=RequestContext(request))


def remixed(request):
    # TODO: this doesn't return the right results after remix_group merge
    qs = RemixGroup.objects.all().order_by('-group_size')
    return render_to_response('sounds/remixed.html', combine_dicts(locals(), paginate(request, qs, settings.SOUND_COMMENTS_PER_PAGE)), context_instance=RequestContext(request))


def random(request):
    sound_id = Sound.objects.random()
    if sound_id is None:
        raise Http404
    sound_obj = Sound.objects.get(pk=sound_id)
    return HttpResponseRedirect(reverse("sound",args=[sound_obj.user.username,sound_id])+"?random_browsing=true")


def packs(request):
    order = request.GET.get("order", "name")
    if order not in ["name", "-last_updated", "-created", "-num_sounds", "-num_downloads"]:
        order = "name"
    qs = Pack.objects.select_related() \
                     .filter(num_sounds__gt=0) \
                     .order_by(order)
    return render_to_response('sounds/browse_packs.html',
                              combine_dicts(paginate(request, qs, settings.PACKS_PER_PAGE, cache_count=True), locals()),
                              context_instance=RequestContext(request))


def get_current_thread_ids():
    cursor = connection.cursor()
    cursor.execute("""
SELECT forum_thread.id
FROM forum_thread, forum_post
WHERE forum_thread.last_post_id = forum_post.id
ORDER BY forum_post.id DESC
LIMIT 10
""")
    return [x[0] for x in cursor.fetchall()]


def front_page(request):
    rss_cache = cache.get("rss_cache", None)
    pledgie_cache = cache.get("pledgie_cache", None)
    current_forum_threads = Thread.objects.filter(pk__in=get_current_thread_ids(),first_post__moderation_state="OK",last_post__moderation_state="OK") \
                                          .order_by('-last_post__created') \
                                          .select_related('author',
                                                          'thread',
                                                          'last_post', 'last_post__author', 'last_post__thread', 'last_post__thread__forum',
                                                          'forum', 'forum__name_slug')
    latest_additions = Sound.objects.latest_additions(5, '2 days')
    random_sound = get_random_sound()
    return render_to_response('index.html', locals(), context_instance=RequestContext(request))


def sound(request, username, sound_id):
    try:
        sound = Sound.objects.select_related("license", "user", "user__profile", "pack", "remix_group").get(id=sound_id)
        if sound.user.username.lower() != username.lower():
            raise Http404
        user_is_owner = request.user.is_authenticated() and (sound.user == request.user or request.user.is_superuser \
                        or request.user.is_staff or Group.objects.get(name='moderators') in request.user.groups.all())
        # If the user is authenticated and this file is his, don't worry about moderation_state and processing_state
        if user_is_owner:
            if sound.moderation_state != "OK":
                messages.add_message(request, messages.INFO, 'Be advised, this file has <b>not been moderated</b> yet.')
            if sound.processing_state != "OK":
                messages.add_message(request, messages.INFO, 'Be advised, this file has <b>not been processed</b> yet.')
        else:
            if sound.moderation_state != 'OK' or sound.processing_state != 'OK':
                raise Http404
    except Sound.DoesNotExist: #@UndefinedVariable
        try:
            DeletedSound.objects.get(sound_id=sound_id)
            return render_to_response('sounds/deleted_sound.html', {}, context_instance=RequestContext(request))
        except DeletedSound.DoesNotExist:
            raise Http404

    tags = sound.tags.select_related("tag__name")

    if request.method == "POST":
        form = CommentForm(request, request.POST)
        if request.user.profile.is_blocked_for_spam_reports():
            messages.add_message(request, messages.INFO, "You're not allowed to post the comment because your account has been temporaly blocked after multiple spam reports")
        else:
            if form.is_valid():
                comment_text=form.cleaned_data["comment"]
                sound.comments.add(Comment(content_object=sound,
                                           user=request.user,
                                           comment=comment_text))
                sound.num_comments = sound.num_comments + 1
                sound.save()
                try:
                    # send the user an email to notify him of the new comment!
                    logger.debug("Notifying user %s of a new comment by %s" % (sound.user.username, request.user.username))
                    send_mail_template(u'You have a new comment.', 'sounds/email_new_comment.txt',
                                       {'sound': sound, 'user': request.user, 'comment': comment_text},
                                       None, sound.user.email)
                except Exception, e:
                    # if the email sending fails, ignore...
                    logger.error("Problem sending email to '%s' about new comment: %s" \
                                 % (request.user.email, e))

                return HttpResponseRedirect(sound.get_absolute_url())
    else:
        form = CommentForm(request)

    qs = Comment.objects.select_related("user", "user__profile").filter(content_type=sound_content_type, object_id=sound_id)
    display_random_link = request.GET.get('random_browsing')
    do_log = settings.LOG_CLICKTHROUGH_DATA

    #facebook_like_link = urllib.quote_plus('http://%s%s' % (Site.objects.get_current().domain, reverse('sound', args=[sound.user.username, sound.id])))
    return render_to_response('sounds/sound.html', combine_dicts(locals(), paginate(request, qs, settings.SOUND_COMMENTS_PER_PAGE)), context_instance=RequestContext(request))


def sound_download(request, username, sound_id):
    if not request.user.is_authenticated():
        return HttpResponseRedirect('%s?next=%s' % (reverse("accounts-login"),
                                                    reverse("sound", args=[username, sound_id])))   
    if settings.LOG_CLICKTHROUGH_DATA:
        click_log(request,click_type='sounddownload',sound_id=sound_id)
    
    sound = get_object_or_404(Sound, id=sound_id, moderation_state="OK", processing_state="OK")
    if sound.user.username.lower() != username.lower():
        raise Http404
    Download.objects.get_or_create(user=request.user, sound=sound)
    return sendfile(sound.locations("path"), sound.friendly_filename(), sound.locations("sendfile_url"))


def sound_preview(request, folder_id, sound_id, user_id):

    if settings.LOG_CLICKTHROUGH_DATA:
        click_log(request,click_type='soundpreview',sound_id=sound_id)

    url = request.get_full_path().replace("data/previews_alt/","data/previews/")
    return HttpResponseRedirect(url)


def pack_download(request, username, pack_id):
    from django.http import HttpResponse

    if not request.user.is_authenticated():
        return HttpResponseRedirect('%s?next=%s' % (reverse("accounts-login"),
                                                    reverse("pack", args=[username, pack_id])))
        
    if settings.LOG_CLICKTHROUGH_DATA:
        click_log(request,click_type='packdownload',pack_id=pack_id)
        
    pack = get_object_or_404(Pack, id=pack_id)
    if pack.user.username.lower() != username.lower():
        raise Http404
    Download.objects.get_or_create(user=request.user, pack=pack)

    filelist =  "%s %i %s %s\r\n" % (pack.license_crc,os.stat(pack.locations('license_path')).st_size, pack.locations('license_url'), "_readme_and_license.txt")
    for sound in pack.sound_set.filter(processing_state="OK", moderation_state="OK"):
        url = sound.locations("sendfile_url")
        name = sound.friendly_filename()
        if sound.crc=='': continue
        filelist = filelist + "%s %i %s %s\r\n"%(sound.crc, sound.filesize,url,name)
    response = HttpResponse(filelist, content_type="text/plain")
    response['X-Archive-Files']='zip'
    return response


@login_required
def sound_edit(request, username, sound_id):
    ONLY_RECOMMEND_TAGS_TO_HALF_OF_UPLOADS = settings.ONLY_RECOMMEND_TAGS_TO_HALF_OF_UPLOADS

    sound = get_object_or_404(Sound, id=sound_id, processing_state='OK')
    if sound.user.username.lower() != username.lower():
        raise Http404

    if not (request.user.has_perm('sound.can_change') or sound.user == request.user):
        raise PermissionDenied

    def invalidate_sound_cache(sound):
        invalidate_template_cache("sound_header", sound.id, True)
        invalidate_template_cache("sound_header", sound.id, False)
        invalidate_template_cache("sound_footer_top", sound.id)
        invalidate_template_cache("sound_footer_bottom", sound.id)
        invalidate_template_cache("display_sound", sound.id, True, sound.processing_state, sound.moderation_state)
        invalidate_template_cache("display_sound", sound.id, False, sound.processing_state, sound.moderation_state)

    def is_selected(prefix):
        if request.method == "POST":
            for name in request.POST.keys():
                if name.startswith(prefix + '-'):
                    return True
        return False

    if is_selected("description"):
        description_form = SoundDescriptionForm(request.POST, prefix="description")
        if description_form.is_valid():
            data = description_form.cleaned_data
            sound.set_tags(data["tags"])
            sound.description = remove_control_chars(data["description"])
            sound.original_filename = data["name"]
            sound.mark_index_dirty()
            invalidate_sound_cache(sound)
            
            # also update any possible related sound ticket
            tickets = Ticket.objects.filter(content__object_id=sound.id,
                                            source=TICKET_SOURCE_NEW_SOUND) \
                                   .exclude(status=TICKET_STATUS_CLOSED)
            for ticket in tickets:
                tc = TicketComment(sender=request.user,
                                   ticket=ticket,
                                   moderator_only=False,
                                   text='%s updated the sound description and/or tags.' % request.user.username)
                tc.save()
                ticket.send_notification_emails(ticket.NOTIFICATION_UPDATED,
                                                ticket.MODERATOR_ONLY)
            return HttpResponseRedirect(sound.get_absolute_url())
    else:
        tags = " ".join([tagged_item.tag.name for tagged_item in sound.tags.all().order_by('tag__name')])
        description_form = SoundDescriptionForm(prefix="description",
                                                initial=dict(tags=tags,
                                                             description=sound.description,
                                                             name=sound.original_filename))

    packs = Pack.objects.filter(user=request.user)

    if is_selected("pack"):
        pack_form = PackForm(packs, request.POST, prefix="pack")
        if pack_form.is_valid():
            data = pack_form.cleaned_data
            dirty_packs = []
            if data['new_pack']:
                (pack, created) = Pack.objects.get_or_create(user=sound.user, name=data['new_pack'])
                sound.pack = pack
            else:
                new_pack = data["pack"]
                old_pack = sound.pack
                if new_pack != old_pack:
                    sound.pack = new_pack
                if new_pack:
                    dirty_packs.append(new_pack)
                if old_pack:
                    dirty_packs.append(old_pack)

            for p in dirty_packs:
               p.process()

            sound.mark_index_dirty()
            invalidate_sound_cache(sound)
            return HttpResponseRedirect(sound.get_absolute_url())
    else:
        pack_form = PackForm(packs, prefix="pack", initial=dict(pack=sound.pack.id) if sound.pack else None)

    if is_selected("geotag"):
        geotag_form = GeotaggingForm(request.POST, prefix="geotag")
        
        if geotag_form.is_valid():
            data = geotag_form.cleaned_data
            
            if data["remove_geotag"]:
                if sound.geotag:
                    geotag = sound.geotag.delete()
                    sound.geotag = None
                    sound.mark_index_dirty()
            else:
                if sound.geotag:
                    sound.geotag.lat = data["lat"]
                    sound.geotag.lon = data["lon"]
                    sound.geotag.zoom = data["zoom"]
                    sound.geotag.save()
                else:
                    sound.geotag = GeoTag.objects.create(lat=data["lat"], lon=data["lon"], zoom=data["zoom"], user=request.user)
                    sound.mark_index_dirty()

            invalidate_sound_cache(sound)
            
            return HttpResponseRedirect(sound.get_absolute_url())
    else:
        if sound.geotag:
            geotag_form = GeotaggingForm(prefix="geotag", initial=dict(lat=sound.geotag.lat, lon=sound.geotag.lon, zoom=sound.geotag.zoom))
        else:
            geotag_form = GeotaggingForm(prefix="geotag")

    license_form = NewLicenseForm(request.POST)
    if request.POST and license_form.is_valid():
        sound.license = license_form.cleaned_data["license"]
        sound.mark_index_dirty()
        invalidate_sound_cache(sound)
        return HttpResponseRedirect(sound.get_absolute_url())
    else:
        license_form = NewLicenseForm(initial={'license': sound.license})
    
    google_api_key = settings.GOOGLE_API_KEY

    return render_to_response('sounds/sound_edit.html', locals(), context_instance=RequestContext(request))



@login_required
def pack_edit(request, username, pack_id):
    pack = get_object_or_404(Pack, id=pack_id)
    if pack.user.username.lower() != username.lower():
        raise Http404
    pack_sounds = ",".join([str(s.id) for s in pack.sound_set.all()])

    if not (request.user.has_perm('pack.can_change') or pack.user == request.user):
        raise PermissionDenied

    if request.method == "POST":
        form = PackEditForm(request.POST,instance=pack)
        if form.is_valid():
            form.save()
            return HttpResponseRedirect(pack.get_absolute_url())
    else:
        form = PackEditForm(instance=pack,initial=dict(pack_sounds=pack_sounds))
        current_sounds = pack.sound_set.all()
    return render_to_response('sounds/pack_edit.html', locals(), context_instance=RequestContext(request)) # TODO: make edit page


@login_required
def pack_delete(request, username, pack_id):

    pack = get_object_or_404(Pack, id=pack_id)
    if pack.user.username.lower() != username.lower():
        raise Http404

    if not (request.user.has_perm('pack.can_change') or pack.user == request.user):
        raise PermissionDenied

    encrypted_string = request.GET.get("pack", None)

    waited_too_long = False

    if encrypted_string != None:
        pack_id, now = decrypt(encrypted_string).split("\t")
        pack_id = int(pack_id)
        link_generated_time = float(now)

        if pack_id != pack.id:
            raise PermissionDenied

        if abs(time.time() - link_generated_time) < 10:
            logger.debug("User %s requested to delete pack %s" % (request.user.username,pack_id))
            print pack
            pack.delete()
            print "DELETED!"
            return HttpResponseRedirect(reverse("accounts-home"))
        else:
            waited_too_long = True


    encrypted_link = encrypt(u"%d\t%f" % (pack.id, time.time()))

    return render_to_response('sounds/pack_delete.html', locals(), context_instance=RequestContext(request))


@login_required
def sound_edit_sources(request, username, sound_id):
    sound = get_object_or_404(Sound, id=sound_id, moderation_state="OK", processing_state="OK")
    if sound.user.username.lower() != username.lower():
        raise Http404

    if not (request.user.has_perm('sound.can_change') or sound.user == request.user):
        raise PermissionDenied

    current_sources = sound.sources.all()
    sources_string = ",".join(map(str, [source.id for source in current_sources]))

    remix_group = RemixGroup.objects.filter(sounds=current_sources)
    # No prints in production code!
    #print ("======== remix group id following ===========")
    #print (remix_group[0].id)

    if request.method == 'POST':
        form = RemixForm(sound, request.POST)
        if form.is_valid():
            form.save()
            # FIXME: temp solution to not fuckup the deployment in tabasco
            # remix_group = RemixGroup.objects.filter(sounds=sound) 
            # if remix_group:
            #     __recalc_remixgroup(remix_group[0], sound)
        else:
            # TODO: Don't use prints! Either use logging or return the error to the user. ~~ Vincent
            pass #print ("Form is not valid!!!!!!! %s" % ( form.errors))
    else:
        form = RemixForm(sound,initial=dict(sources=sources_string))
    return render_to_response('sounds/sound_edit_sources.html', locals(), context_instance=RequestContext(request))

# TODO: handle case were added/removed sound is part of remixgroup
def __recalc_remixgroup(remixgroup, sound):

    # recreate remixgroup
    dg = nx.DiGraph()
    data = json.loads(remixgroup.networkx_data)
    dg.add_nodes_from(data['nodes'])
    dg.add_edges_from(data['edges'])
    
    # print "========= NODES =========="
    print dg.nodes()
    # print "========= EDGES =========="
    print dg.edges()
    
    # add new nodes/edges (sources in this case)
    for source in sound.sources.all():
        if source.id not in dg.successors(sound.id) \
                    and source.created < sound.created: # time-bound, avoid illegal source assignment
            dg.add_node(source.id)
            dg.add_edge(sound.id, source.id)
            remix_group = RemixGroup.objects.filter(sounds=source)
            if remix_group:
                dg = __nested_remixgroup(dg, remix_group[0])
            
    try:
        # remove old nodes/edges
        for source in dg.successors(sound.id):
            if source not in [s.id for s in sound.sources.all()]:
                dg.remove_node(source) # TODO: check if edges are removed automatically
        
        # create and save the modified remixgroup
        dg = _create_nodes(dg)
        print "============ NODES AND EDGES =============="
        print dg.nodes()
        print dg.edges()
        _create_and_save_remixgroup(dg, remixgroup)
    except Exception, e:
        logger.warning(e)    

def __nested_remixgroup(dg1, remix_group):
    print "============= nested remix_group ================ \n"
    dg2 = nx.DiGraph()
    data = json.loads(remix_group.networkx_data)
    dg2.add_nodes_from(data['nodes'])
    dg2.add_edges_from(data['edges'])
        
    print "========== MERGED GROUP NODES: " + str(dg1.nodes())

    # FIXME: this combines the graphs correctly
    #        recheck the time-bound concept
    dg1 = nx.compose(dg1, dg2)
    print dg1.nodes()

    return dg1

def remixes(request, username, sound_id):
    sound = get_object_or_404(Sound, id=sound_id, moderation_state="OK", processing_state="OK")
    if sound.user.username.lower() != username.lower():
        raise Http404
    try:
        remix_group = sound.remix_group.all()[0]
    except:
        raise Http404
    return HttpResponseRedirect(reverse("remix-group", args=[remix_group.id]))

def remix_group(request, group_id):
    group = get_object_or_404(RemixGroup, id=group_id)
    data = group.protovis_data
    sounds = group.sounds.all().order_by('created')
    last_sound = sounds[len(sounds)-1]
    group_sound = sounds[0]
    return render_to_response('sounds/remixes.html',
                              locals(),
                              context_instance=RequestContext(request))


def geotag(request, username, sound_id):
    sound = get_object_or_404(Sound, id=sound_id, moderation_state="OK", processing_state="OK")
    if sound.user.username.lower() != username.lower():
        raise Http404
    google_api_key = settings.GOOGLE_API_KEY
    return render_to_response('sounds/geotag.html', locals(), context_instance=RequestContext(request))


def similar(request, username, sound_id):
    sound = get_object_or_404(Sound,
                              id=sound_id,
                              moderation_state="OK",
                              processing_state="OK",
                              analysis_state="OK",
                              similarity_state="OK")
    if sound.user.username.lower() != username.lower():
        raise Http404

    similar_sounds, count = get_similar_sounds(sound,request.GET.get('preset', None), int(settings.SOUNDS_PER_PAGE))
    logger.debug('Got similar_sounds for %s: %s' % (sound_id, similar_sounds))
    return render_to_response('sounds/similar.html', locals(), context_instance=RequestContext(request))


def pack(request, username, pack_id):
    try:
        pack = Pack.objects.select_related().get(id=pack_id)
        if pack.user.username.lower() != username.lower():
            raise Http404
    except Pack.DoesNotExist:
        raise Http404
    qs = Sound.objects.select_related('pack', 'user', 'license', 'geotag').filter(pack=pack, moderation_state="OK", processing_state="OK")
    num_sounds_ok = len(qs)
    # TODO: refactor: This list of geotags is only used to determine if we need to show the geotag map or not
    pack_geotags = Sound.public.select_related('license', 'pack', 'geotag', 'user', 'user__profile').filter(pack=pack).exclude(geotag=None).exists()
    google_api_key = settings.GOOGLE_API_KEY
    
    if num_sounds_ok == 0 and pack.num_sounds != 0:
        messages.add_message(request, messages.INFO, 'The sounds of this pack have <b>not been moderated</b> yet.')
    else :
        if num_sounds_ok < pack.num_sounds :
            messages.add_message(request, messages.INFO, 'This pack contains more sounds that have <b>not been moderated</b> yet.')

    # If user is owner of pack, display form to add description
    enable_description_form = False
    if request.user.username == username:
        enable_description_form = True
        form = PackDescriptionForm(instance = pack)

    # Manage POST info (if adding a description)
    if request.method == 'POST':
        form = PackDescriptionForm(request.POST, pack)
        if form.is_valid():
            pack.description = form.cleaned_data['description']
            pack.save()
        else:
            pass

    file_exists = os.path.exists(pack.locations("license_path"))

    return render_to_response('sounds/pack.html', combine_dicts(locals(), paginate(request, qs, settings.SOUNDS_PER_PAGE)), context_instance=RequestContext(request))


def packs_for_user(request, username):
    user = get_object_or_404(User, username__iexact=username)
    order = request.GET.get("order", "name")
    if order not in ["name", "-last_updated", "-created", "-num_sounds", "-num_downloads"]:
        order = "name"
    qs = Pack.objects.select_related().filter(user=user).filter(num_sounds__gt=0).order_by(order)
    return render_to_response('sounds/packs.html', combine_dicts(paginate(request, qs, settings.PACKS_PER_PAGE), locals()), context_instance=RequestContext(request))


def for_user(request, username):
    user = get_object_or_404(User, username__iexact=username)
    qs = Sound.public.filter(user=user)
    return render_to_response('sounds/for_user.html', combine_dicts(paginate(request, qs, settings.SOUNDS_PER_PAGE), locals()), context_instance=RequestContext(request))


@login_required
def delete(request, username, sound_id):    
    sound = get_object_or_404(Sound, id=sound_id)
    if sound.user.username.lower() != username.lower():
        raise Http404

    if not (request.user.has_perm('sound.delete_sound') or sound.user == request.user):
        raise PermissionDenied

    encrypted_string = request.GET.get("sound", None)

    waited_too_long = False

    if encrypted_string != None:
        sound_id, now = decrypt(encrypted_string).split("\t")
        sound_id = int(sound_id)
        link_generated_time = float(now)

        if sound_id != sound.id:
            raise PermissionDenied

        if abs(time.time() - link_generated_time) < 10:
            logger.debug("User %s requested to delete sound %s" % (request.user.username,sound_id))
            sound.delete()
            return HttpResponseRedirect(reverse("accounts-home"))
        else:
            waited_too_long = True


    encrypted_link = encrypt(u"%d\t%f" % (sound.id, time.time()))

    return render_to_response('sounds/delete.html', locals(), context_instance=RequestContext(request))


def flag(request, username, sound_id):
    sound = get_object_or_404(Sound, id=sound_id, moderation_state="OK", processing_state="OK")
    if sound.user.username.lower() != username.lower():
        raise Http404

    user = None
    email = None
    if request.user.is_authenticated():
        user = request.user
        email = request.user.email

    if request.method == "POST":
        flag_form = FlagForm(request, request.POST)
        if flag_form.is_valid():
            flag = flag_form.save()
            flag.reporting_user=user
            flag.sound = sound
            flag.save()

            send_mail_template(u"[flag] flagged file", "sounds/email_flag.txt", dict(flag=flag), flag.email)

            return HttpResponseRedirect(sound.get_absolute_url())
    else:
        if user:
            flag_form = FlagForm(request,initial=dict(email=email))
        else:
            flag_form = FlagForm(request)

    return render_to_response('sounds/sound_flag.html', locals(), context_instance=RequestContext(request))


def __redirect_old_link(request, cls, url_name):
    obj_id = request.GET.get('id', False)
    if obj_id:
        try:
            obj = get_object_or_404(cls, id=int(obj_id))
            return HttpResponsePermanentRedirect(reverse(url_name, args=[obj.user.username, obj_id]))
        except ValueError:
            raise Http404
    else:
        raise Http404

def old_sound_link_redirect(request):
    return __redirect_old_link(request, Sound, "sound")

def old_pack_link_redirect(request):
    return __redirect_old_link(request, Pack, "pack")

def display_sound_wrapper(request, username, sound_id):
    sound = get_object_or_404(Sound, id=sound_id) #TODO: test the 404 case
    if sound.user.username.lower() != username.lower():
        raise Http404
    return render_to_response('sounds/display_sound.html', display_sound.display_sound(RequestContext(request), sound), context_instance=RequestContext(request))


def embed_iframe(request, sound_id, player_size):
    if player_size not in ['mini', 'small', 'medium', 'large', 'large_no_info']:
        raise Http404
    size = player_size
    sound = get_object_or_404(Sound, id=sound_id, moderation_state='OK', processing_state='OK')
    username_and_filename = '%s - %s' % (sound.user.username, sound.original_filename)
    return render_to_response('sounds/sound_iframe.html', locals(), context_instance=RequestContext(request))

def downloaders(request, username, sound_id):
    sound = get_object_or_404(Sound, id=sound_id)
    
    # Retrieve all users that downloaded a sound
    qs = Download.objects.filter(sound=sound_id)
    return render_to_response('sounds/downloaders.html', combine_dicts(paginate(request, qs, 32, object_count=sound.num_downloads), locals()), context_instance=RequestContext(request))

def pack_downloaders(request, username, pack_id):
    pack = get_object_or_404(Pack, id = pack_id)
    
    # Retrieve all users that downloaded a sound
    qs = Download.objects.filter(pack=pack_id)
    return render_to_response('sounds/pack_downloaders.html', combine_dicts(paginate(request, qs, 32, object_count=pack.num_downloads), locals()), context_instance=RequestContext(request))

def click_log(request,click_type=None, sound_id="", pack_id="" ):
    
    searchtime_session_key = request.session.get("searchtime_session_key", "")
    authenticated_session_key = ""
    if request.user.is_authenticated():
        authenticated_session_key = request.session.session_key
    if click_type in ['soundpreview', 'sounddownload']:
        entity_id = sound_id
    else:
        entity_id = pack_id

    logger_click.info("%s : %s : %s : %s"
                          % (click_type, authenticated_session_key, searchtime_session_key, unicode(entity_id).encode('utf-8')))

########NEW FILE########
__FILENAME__ = admin
# -*- coding: utf-8 -*-
########NEW FILE########
__FILENAME__ = forms
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django import forms
from utils.forms import RecaptchaForm

class ContactForm(RecaptchaForm):
    your_email = forms.EmailField()
    subject = forms.CharField()
    message = forms.CharField(widget=forms.Textarea(attrs={'rows': 10, 'cols': 50}))
########NEW FILE########
__FILENAME__ = models
# -*- coding: utf-8 -*-
########NEW FILE########
__FILENAME__ = views
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.contrib.auth.models import User
from django.shortcuts import render_to_response
from django.template import RequestContext
from support.forms import ContactForm
from utils.mail import send_mail_template

def contact(request):
    email_sent = False
    user = None
    
    if request.user.is_authenticated():
        user = request.user 

    if request.POST:
        form = ContactForm(request, request.POST)
        if form.is_valid():
            subject = u"[support] " + form.cleaned_data['subject']
            email_from = form.cleaned_data['your_email']
            message = form.cleaned_data['message']

            # append some useful admin information to the email:
            if not user:
                try:
                    user = User.objects.get(email__iexact=email_from)
                except User.DoesNotExist: #@UndefinedVariable
                    pass
            
            send_mail_template(subject, "support/email_support.txt", locals(), email_from)

            email_sent = True
    else:
        if user:
            form = ContactForm(request, initial={"your_email": user.email})
        else:
            form = ContactForm(request)

    return render_to_response('support/contact.html', locals(), context_instance=RequestContext(request))
########NEW FILE########
__FILENAME__ = heuristics
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from tag_recommendation_utils import *

heuristics = {
    'hRankPercentage015': {'name':'RankP@0.15','c':cNMostSimilar, 'a':aNormalizedRankSum,'s':sPercentage, 'options':{'cNMostSimilar_N':100, 'aNormalizedRankSum_factor':1.0, 'sPercentage_percentage': 0.15}},
}
########NEW FILE########
__FILENAME__ = tag_recommendation_utils
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#


import operator
from numpy import *


def cNMostSimilar(input_tags, tag_names, similarity_matrix, options):

    N = options['cNMostSimilar_N']
    unicode_tag_names = [t.decode('utf-8') for t in tag_names]
    candidate_tags = []
    for tag in input_tags:
        # Check that tag exists in the tag matrix, if it does not exist we cannot recommend similar tags
        if tag in unicode_tag_names:
            # Find N most similar tags in the row
            idx = unicode_tag_names.index(tag)
            #where(tag_names == tag)[0][0]
            row_idx = nonzero(similarity_matrix[idx,:])
            row_idx = row_idx[0]
            row = similarity_matrix[idx,row_idx]
            MAX = N
            most_similar_idx = row.argsort()[-MAX-1:-1][::-1] # We pick the first N most similar tags (practically the same as no threshold but more efficient)
            most_similar_dist = row[most_similar_idx]
            most_similar_tags = tag_names[row_idx[most_similar_idx]]

            rank = N
            for count,item in enumerate(most_similar_tags):
                if item not in input_tags:
                    candidate_tags.append( {'name':item, 'rank':rank, 'dist':most_similar_dist[count], 'from':tag} )
                    rank -= 1
                else:
                    pass # recommended tag was already present in input tags
        else:
            pass  # If tag does not exist we do not recommend anything. Maybe we could do something else here

    return candidate_tags


def aNormalizedRankSum(candidate_tags, input_tags, options):

    factor = options['aNormalizedRankSum_factor']

    candidate_tags.sort(key=operator.itemgetter('rank'))
    candidate_tags.reverse()

    aggregated_candiate_tags = {}
    for item in candidate_tags:
        if item['name'] in aggregated_candiate_tags: # Item already there
            aggregated_candiate_tags[item['name']] = (aggregated_candiate_tags[item['name']] + float(item['rank'])/(len(input_tags))) * factor
        else:
            aggregated_candiate_tags[item['name']] = float(item['rank'])/(len(input_tags))
    aggregated_candiate_tags_list = []
    for key in aggregated_candiate_tags.keys():
        aggregated_candiate_tags_list.append({"name":key, "rank": aggregated_candiate_tags[key]})
    aggregated_candiate_tags_list.sort(key=operator.itemgetter('rank'))
    aggregated_candiate_tags_list.reverse()

    return aggregated_candiate_tags, aggregated_candiate_tags_list


def sThreshold(aggregated_candiate_tags_list, aggregated_candiate_tags, input_tags, options, threshold = None):

    if not threshold:
        threshold = options['sThreshold_threshold']

    recommended_tags = []
    for item in aggregated_candiate_tags_list:
        if item['rank'] >= threshold:
            recommended_tags.append(item)

    added_tags = []
    for item in recommended_tags:
        added_tags.append(item['name'])

    return added_tags


def sPercentage(aggregated_candiate_tags_list, aggregated_candiate_tags, input_tags, options):

    percentage = options['sPercentage_percentage']
    max_score = aggregated_candiate_tags_list[0]['rank']
    threshold = max_score*(1.0-percentage)
    return sThreshold(aggregated_candiate_tags_list, aggregated_candiate_tags, input_tags, options, threshold)

########NEW FILE########
__FILENAME__ = tagrecommendation_server
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

# This machine where the server runs has some important python dependencies
#   - twisted
#   - numpy
#   - sklearn (joblib)


from twisted.web import server, resource
from twisted.internet import reactor
from tagrecommendation_settings import *
import logging
import graypy
from logging.handlers import RotatingFileHandler
import json
from communityBasedTagRecommendation import CommunityBasedTagRecommender
from utils import loadFromJson, saveToJson


def server_interface(resource):
    return {
        'recommend_tags': resource.recommend_tags,  # input_tags (tags separated by commas), max_number_of_tags (optional)
        'reload': resource.reload,
        'last_indexed_id': resource.last_indexed_id,
        'add_to_index': resource.add_to_index,  # sound_ids (str separated by commas), sound_tagss (sets of tags separated by #)
    }


class TagRecommendationServer(resource.Resource):
    def __init__(self):
        resource.Resource.__init__(self)
        self.methods = server_interface(self)
        self.isLeaf = False

        self.load()

    def load(self):
        try:
            tag_recommendation_data = loadFromJson(RECOMMENDATION_DATA_DIR + 'Current_database_and_class_names.json')
            DATABASE = tag_recommendation_data['database']
            CLASSES = tag_recommendation_data['classes']
            self.cbtr = CommunityBasedTagRecommender(dataset=DATABASE, classes=CLASSES)
            self.cbtr.load_recommenders()

        except:
            self.cbtr = None
            logger.info("No computed matrices were found, recommendation system not loading for the moment (but service listening for data to come).")

        try:
            self.index_stats = loadFromJson(RECOMMENDATION_DATA_DIR + 'Current_index_stats.json')
            logger.info("Matrices computed out of information from %i sounds" % self.index_stats['n_sounds_in_matrix'])
        except Exception, e:
            print e
            self.index_stats = {
                'n_sounds_in_matrix': 0,
            }

        try:
            self.index = loadFromJson(RECOMMENDATION_DATA_DIR + 'Index.json')
            self.index_stats['biggest_id_in_index'] = max([int(key) for key in self.index.keys()])
            self.index_stats['n_sounds_in_index'] = len(self.index.keys())
        except Exception, e:
            logger.info("Index file not present. Listening for indexing data from appservers.")
            self.index_stats['biggest_id_in_index'] = 0
            self.index_stats['n_sounds_in_index'] = 0
            self.index = dict()

    def error(self,message):
        return json.dumps({'Error': message})

    def getChild(self, name, request):
        return self

    def render_GET(self, request):
        return self.methods[request.prepath[1]](**request.args)

    def recommend_tags(self, input_tags, max_number_of_tags=None):

        try:
            logger.debug('Getting recommendation for input tags %s' % input_tags)
            input_tags = input_tags[0].split(",")
            if max_number_of_tags:
                max_number_of_tags = int(max_number_of_tags[0])
            recommended_tags, com_name = self.cbtr.recommend_tags(input_tags,
                                                                  max_number_of_tags=max_number_of_tags)
            result = {'error': False, 'result': {'tags': recommended_tags, 'community': com_name}}

        except Exception, e:
            logger.debug('Errors occurred while recommending tags to %s' % input_tags)
            result = {'error': True, 'result': str(e)}

        return json.dumps(result)

    def reload(self):
        logger.info('Reloading tagrecommendation server...')
        self.load()
        result = {'error': False, 'result': "Server reloaded"}
        return json.dumps(result)

    def last_indexed_id(self):
        result = {'error': False, 'result': self.index_stats['biggest_id_in_index']}
        logger.info('Getting last indexed id information (%i, %i sounds in index, %i sounds in matrix)' % (self.index_stats['biggest_id_in_index'],
                                                                                                           self.index_stats['n_sounds_in_index'],
                                                                                                           self.index_stats['n_sounds_in_matrix']))
        return json.dumps(result)

    def add_to_index(self, sound_ids, sound_tagss):
        sound_ids = sound_ids[0].split(",")
        sound_tags = [stags.split(",") for stags in sound_tagss[0].split("-!-!-")]
        logger.info('Adding %i sounds to recommendation index' % len(sound_ids))

        for count, sound_id in enumerate(sound_ids):
            sid = sound_id
            stags = sound_tags[count]
            self.index[sid] = stags

        if len(self.index.keys()) % 1000 == 0:
            # Every 1000 indexed sounds, save the index
            logger.info('Saving tagrecommendation index...')
            saveToJson(RECOMMENDATION_DATA_DIR + 'Index.json', self.index, verbose=False)
            self.index_stats['biggest_id_in_index'] = max([int(key) for key in self.index.keys()])
            self.index_stats['n_sounds_in_index'] = len(self.index.keys())

        result = {'error': False, 'result': True}
        return json.dumps(result)


if __name__ == '__main__':
    # Set up logging
    logger = logging.getLogger('tagrecommendation')
    logger.setLevel(logging.DEBUG)
    handler = RotatingFileHandler(LOGFILE, maxBytes=2*1024*1024, backupCount=5)
    handler.setLevel(logging.DEBUG)
    std_handler = logging.StreamHandler()
    std_handler.setLevel(logging.DEBUG)
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    handler.setFormatter(formatter)
    logger.addHandler(handler)
    std_handler.setFormatter(formatter)
    logger.addHandler(std_handler)
    handler_graypy = graypy.GELFHandler('10.55.0.48', 12201)
    logger.addHandler(handler_graypy)

    # Start service
    logger.info('Configuring tag recommendation service...')
    root = resource.Resource()
    root.putChild("tagrecommendation", TagRecommendationServer())
    site = server.Site(root)
    reactor.listenTCP(LISTEN_PORT, site)
    logger.info('Started tag recommendation service, listening to port ' + str(LISTEN_PORT) + "...")
    reactor.run()
    logger.info('Service stopped.')



########NEW FILE########
__FILENAME__ = tagrecommendation_settings.example
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

import os
# NOTE: In production and test this file is taken from the deploy repository

# SERVER SETTINGS
LOGFILE                     = '/var/log/freesound/tagrecommendation.log'
LISTEN_PORT                 = 8010
RECOMMENDATION_DATA_DIR     = '/home/fsweb/freesound/freesound-tagrecommendation/'
RECOMMENDATION_TMP_DATA_DIR = RECOMMENDATION_DATA_DIR + 'tmp/'

# CLIENT SETTINGS (to be moved to django settings?)
TAGRECOMMENDATION_ADDRESS          = 'localhost'
TAGRECOMMENDATION_PORT             = 8010
TAGRECOMMENDATION_CACHE_TIME       = 60*60*24*7 # One week?


# This tag recommendation server needs some data files to be in the data folder
#
# For the class detection step:
#   Classifier.pkl              (precomputed classifier pickled)
#   Classifier_meta.json        (metadata of the classifier)
#   Classifier_TAG_NAMES.npy    (vector of all tag names used to train the classifier)
#
# Classifier files can be found in freesound-deploy repository.
#
# Having this classifier the recommendation server can be started. Once the server is running
# a command from the appservers must be run so the recomendation is feeded with tag assignement data
# from freesound which is stored in a file called Index.json. This fille incrementally stores
# all tag assingment information from freesound. Once this file exists and has some data, the
# "update_tagrecommendation_data.py" script can be run and will generate the following files:
#
# For every class used:
#   [[DATABASE]]_[[CLASSNAME]]_SIMILARITY_MATRIX_cosine_SUBSET.npy
#   [[DATABASE]]_[[CLASSNAME]]_SIMILARITY_MATRIX_cosine_SUBSET_TAG_NAMES.npy
# Example:
#   FREESOUND2012_CFX_SIMILARITY_MATRIX_cosine_SUBSET.npy
#   FREESOUND2012_CFX_SIMILARITY_MATRIX_cosine_SUBSET_TAG_NAMES.npy
#   ...
#
# Once the files are generated the recommendation service is restarted and ready.
########NEW FILE########
__FILENAME__ = update_tagrecommendation_data
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#


from recommendationDataProcessor import RecommendationDataProcessor

rdp = RecommendationDataProcessor()
rdp.process_tag_recommendation_data(tag_threshold=10, line_limit=9999999999999999)
rdp.clear_temp_files()
#rdp.rollback_last_backup()

########NEW FILE########
__FILENAME__ = utils
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

import json
from numpy import zeros
import sys


def loadFromJson(path, verbose=False):
    with open(path, 'r') as f:
        if verbose:
            print "Loading data from '" + path + "'"
        return json.load(f)

def saveToJson(path="", data="", verbose=True):
    with open(path, mode='w') as f:
        if verbose:
            print "Saving data to '" + path + "'"
        json.dump(data,f,indent=4)

def mtx2npy(M, verbose = True):
    n = M.shape[0]
    m = M.shape[1]
    npy = zeros((n, m) , 'float32')
    #non_zero_index = M.keys()
    items = M.items()
    nItems = len(M.items())
    done = 0
    #for index in non_zero_index :
    for index, value in items:
        npy[ index[0] ][ index[1] ] = value #M[ index[0] , index[1] ]

        done += 1
        if verbose:
            sys.stdout.write("\rConverting to npy... " + '%.2f'%((float(done)*100)/float(nItems)) + "% ")
            sys.stdout.flush()

    if verbose:
        sys.stdout.write("\n")
        sys.stdout.flush()
    return npy


########NEW FILE########
__FILENAME__ = admin
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.contrib import admin
from tags.models import Tag, TaggedItem

class TagAdmin(admin.ModelAdmin):
    list_display = ('tag',)

admin.site.register(Tag)

class TaggedItemAdmin(admin.ModelAdmin):
    search_fields = ('=tag__name',)
    raw_id_fields = ('user', 'tag')
    list_display = ('user', 'content_type', 'object_id', 'tag', 'created')

admin.site.register(TaggedItem, TaggedItemAdmin)
########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'Tag'
        db.create_table('tags_tag', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.SlugField')(unique=True, max_length=100, db_index=True)),
        ))
        db.send_create_signal('tags', ['Tag'])

        # Adding model 'TaggedItem'
        db.create_table('tags_taggeditem', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'])),
            ('tag', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['tags.Tag'])),
            ('content_type', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['contenttypes.ContentType'])),
            ('object_id', self.gf('django.db.models.fields.PositiveIntegerField')(db_index=True)),
            ('created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, db_index=True, blank=True)),
        ))
        db.send_create_signal('tags', ['TaggedItem'])

        # Adding unique constraint on 'TaggedItem', fields ['tag', 'content_type', 'object_id']
        db.create_unique('tags_taggeditem', ['tag_id', 'content_type_id', 'object_id'])

        # Adding model 'FS1Tag'
        db.create_table('tags_fs1tag', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('fs1_id', self.gf('django.db.models.fields.IntegerField')(unique=True, db_index=True)),
            ('tag', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['tags.Tag'])),
        ))
        db.send_create_signal('tags', ['FS1Tag'])


    def backwards(self, orm):
        
        # Removing unique constraint on 'TaggedItem', fields ['tag', 'content_type', 'object_id']
        db.delete_unique('tags_taggeditem', ['tag_id', 'content_type_id', 'object_id'])

        # Deleting model 'Tag'
        db.delete_table('tags_tag')

        # Deleting model 'TaggedItem'
        db.delete_table('tags_taggeditem')

        # Deleting model 'FS1Tag'
        db.delete_table('tags_fs1tag')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'tags.fs1tag': {
            'Meta': {'object_name': 'FS1Tag'},
            'fs1_id': ('django.db.models.fields.IntegerField', [], {'unique': 'True', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'tag': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['tags.Tag']"})
        },
        'tags.tag': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '100', 'db_index': 'True'})
        },
        'tags.taggeditem': {
            'Meta': {'ordering': "('-created',)", 'unique_together': "(('tag', 'content_type', 'object_id'),)", 'object_name': 'TaggedItem'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'tag': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['tags.Tag']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        }
    }

    complete_apps = ['tags']

########NEW FILE########
__FILENAME__ = models
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.contrib.auth.models import User
from django.contrib.contenttypes import generic
from django.contrib.contenttypes.models import ContentType
from django.db import models
from django.utils.encoding import smart_unicode

class Tag(models.Model):
    name = models.SlugField(unique=True, db_index=True, max_length=100)

    def __unicode__(self):
        return self.name

    class Meta:
        ordering = ("name",)


class TaggedItem(models.Model):
    user = models.ForeignKey(User)

    tag = models.ForeignKey(Tag)

    #content_type = models.ForeignKey(ContentType, related_name='tags')
    content_type = models.ForeignKey(ContentType)
    object_id = models.PositiveIntegerField(db_index=True)
    content_object = generic.GenericForeignKey()

    created = models.DateTimeField(db_index=True, auto_now_add=True)

    def __unicode__(self):
        return u"%s tagged %s - %s: %s" % (self.user, self.content_type, self.content_type, self.tag)

    @models.permalink
    def get_absolute_url(self):
        return ('tag', (smart_unicode(self.tag.id),))

    class Meta:
        ordering = ("-created",)
        unique_together = (('tag', 'content_type', 'object_id'),)

# Class to get old tags ids linked to new tag ids
# The goal is to at some point deprecate the old tag ids completely
class FS1Tag(models.Model):
    # The old id from FS1
    fs1_id = models.IntegerField(unique=True, db_index=True)

    tag = models.ForeignKey(Tag)

########NEW FILE########
__FILENAME__ = tags
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django import template
from utils.tags import annotate_tags

register = template.Library()

@register.filter
def add_sizes(tags, arguments):
    sort, small_size, large_size = arguments.split(":")
    return annotate_tags(tags, sort.lower() == "true", float(small_size), float(large_size))

@register.filter
def join_tags_exclude(list, exclude):
    return "/".join(sorted(filter(lambda x: x != exclude, list))) if list else None

@register.filter
def join_tags_include(list, include):
    return "/".join(sorted(list + [include])) if list else include
########NEW FILE########
__FILENAME__ = tests
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.test import TestCase
from django.test.client import Client
from tags.models import FS1Tag
from django.core.urlresolvers import reverse

class OldTagLinksRedirectTestCase(TestCase):
    
    fixtures = ['fs1tags.json']
    
    def setUp(self):
        self.client = Client()
        self.fs1tags = [tag.fs1_id for tag in FS1Tag.objects.all()[0:2]]
        
    def test_old_tag_link_redirect_single_ok(self):
        # 301 permanent redirect, single tag result exists
        response = self.client.get(reverse('old-tag-page'), data={'id' : self.fs1tags[0]})
        self.assertEqual(response.status_code, 301)
    
    def test_old_tag_link_redirect_multi_ok(self):    
        # 301 permanent redirect, multiple tags result exists
        ids = '_'.join([ str(temp) for temp in self.fs1tags])
        response = self.client.get(reverse('old-tag-page'), data={'id' : ids})
        self.assertEqual(response.status_code, 301)
        
    def test_old_tag_link_redirect_partial_ids_list(self):
        # 301 permanent redirect, one of the tags in the list exists
        partial_ids = str(self.fs1tags[0]) + '_0'
        response = self.client.get(reverse('old-tag-page'), data={'id' : partial_ids})
        self.assertEqual(response.status_code, 301)    
        
    def test_old_tag_link_redirect_not_exists_id(self):
        # 404 id exists does not exist
        response = self.client.get(reverse('old-tag-page'), data={'id' : 0}, follow=True)
        self.assertEqual(response.status_code, 404)
        
    def test_old_tag_link_redirect_invalid_id(self):
        # 404 invalid id
        response = self.client.get(reverse('old-tag-page'), data={'id' : 'invalid_id'}, follow=True)
        self.assertEqual(response.status_code, 404)    
        
    def test_old_tag_link_redirect_partial_invalid_id(self):
        # 404 invalid id in the id list
        partial_ids = str(self.fs1tags[0]) + '_invalidValue'
        response = self.client.get(reverse('old-tag-page'), data={'id' : partial_ids}, follow=True)
        self.assertEqual(response.status_code, 404) 
########NEW FILE########
__FILENAME__ = views
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from tags.models import Tag, FS1Tag
from django.conf import settings
from django.core.urlresolvers import reverse
from django.http import Http404, HttpResponsePermanentRedirect
from django.shortcuts import render_to_response
from django.template import RequestContext
from utils.search.solr import SolrQuery, SolrResponseInterpreter, \
    SolrResponseInterpreterPaginator, SolrException, Solr
import logging

search_logger = logging.getLogger("search")

def tags(request, multiple_tags=None):
    if multiple_tags:
        multiple_tags = multiple_tags.split('/')
    else:
        multiple_tags = []
    
    multiple_tags = sorted(filter(lambda x:x, multiple_tags))
    
    try:
        current_page = int(request.GET.get("page", 1))
    except ValueError:
        current_page = 1

    solr = Solr(settings.SOLR_URL)
    
    query = SolrQuery()
    if multiple_tags:
        query.set_query(" ".join("tag:\"" + tag + "\"" for tag in multiple_tags))
    else:
        query.set_query("*:*")
    query.set_query_options(start=(current_page - 1) * settings.SOUNDS_PER_PAGE, rows=settings.SOUNDS_PER_PAGE, field_list=["id"], sort=["num_downloads desc"])
    query.add_facet_fields("tag")
    query.set_facet_options_default(limit=100, sort=True, mincount=1, count_missing=False)
    
    try:
        
        results = SolrResponseInterpreter(solr.select(unicode(query)))
        
        
        paginator = SolrResponseInterpreterPaginator(results, settings.SOUNDS_PER_PAGE)
        page = paginator.page(current_page)
        error = False
        tags = [dict(name=f[0], count=f[1]) for f in results.facets["tag"]]
    except SolrException, e:
        error = True
        search_logger.error("SOLR ERROR - %s" % e)
    except :
        error = True
    return render_to_response('sounds/tags.html', locals(), context_instance=RequestContext(request))


def old_tag_link_redirect(request):    
    fs1tag_id = request.GET.get('id', False)
    if fs1tag_id:
        tags = fs1tag_id.split('_')
        try:
            fs1tags = FS1Tag.objects.filter(fs1_id__in=tags).values_list('tag', flat=True)            
        except ValueError, e:
            raise Http404
            
        tags = Tag.objects.filter(id__in=fs1tags).values_list('name', flat=True)
        if not tags:
            raise Http404
         
        return HttpResponsePermanentRedirect(reverse("tags", args=['/'.join(tags)]))
    else:
        raise Http404    
########NEW FILE########
__FILENAME__ = admin
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.contrib import admin
from models import Queue, Ticket

class QueueAdmin(admin.ModelAdmin): 
    list_display = ('name',)

admin.site.register(Queue, QueueAdmin)


class TicketAdmin(admin.ModelAdmin):
    raw_id_fields = ('sender', 'assignee') 
    list_display = ('id', 'source', 'status', 'assignee', 'sender')

admin.site.register(Ticket, TicketAdmin)
########NEW FILE########
__FILENAME__ = forms
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django import forms
from models import UserAnnotation
from utils.forms import RecaptchaForm
from tickets import *

class ModeratorMessageForm(forms.Form):
    message     = forms.CharField(widget=forms.Textarea,)
    moderator_only = forms.BooleanField(required=False)

class UserMessageForm(forms.Form):
    message     = forms.CharField(widget=forms.Textarea)

class UserContactForm(UserMessageForm):
    title       = forms.CharField()

    def __init__(self, *args, **kwargs):
        super(UserContactForm, self).__init__(*args, **kwargs)
        self.fields.keyOrder = ['title', 'message']

class AnonymousMessageForm(RecaptchaForm):
    message     = forms.CharField(widget=forms.Textarea)

class AnonymousContactForm(AnonymousMessageForm):
    title       = forms.CharField()
    email       = forms.EmailField()

    def __init__(self, *args, **kwargs):
        super(AnonymousContactForm, self).__init__(*args, **kwargs)
        self.fields.keyOrder = ['email', 'title', 'message']

# Sound moderation forms
MODERATION_CHOICES = [(x,x) for x in \
                      ['Approve',
                       'Delete',
                       'Defer',
                       'Return',
                       'Whitelist']]

class SoundModerationForm(forms.Form):
    action      = forms.ChoiceField(choices=MODERATION_CHOICES,
                                    required=True,
                                    widget=forms.RadioSelect(),
                                    label='')
    ticket      = forms.IntegerField(widget=forms.widgets.HiddenInput)

class ModerationMessageForm(forms.Form):
    message     = forms.CharField(widget=forms.Textarea,
                                  required=False,
                                  label='')
    moderator_only = forms.BooleanField(required=False)

class UserAnnotationForm(forms.Form):
    text = forms.CharField(widget=forms.Textarea,
                           required=True,
                           label='')


TICKET_STATUS_CHOICES = [(x,x.capitalize()) for x in \
                         [TICKET_STATUS_ACCEPTED,
                          TICKET_STATUS_CLOSED,
                          TICKET_STATUS_DEFERRED,
                          TICKET_STATUS_NEW]]

class TicketModerationForm(forms.Form):
    status      = forms.ChoiceField(choices=TICKET_STATUS_CHOICES,
                                    required=False,
                                    label='Ticket status')

class SoundStateForm(forms.Form):
    state       = forms.ChoiceField(choices=[("OK", "OK"),
                                             ("PE", "Pending"),
                                             ("DE", "Delete")],
                                    required=False,
                                    label='Sound state')

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'Queue'
        db.create_table('tickets_queue', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=128)),
            ('notify_by_email', self.gf('django.db.models.fields.BooleanField')(default=False)),
        ))
        db.send_create_signal('tickets', ['Queue'])

        # Adding M2M table for field groups on 'Queue'
        db.create_table('tickets_queue_groups', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('queue', models.ForeignKey(orm['tickets.queue'], null=False)),
            ('group', models.ForeignKey(orm['auth.group'], null=False))
        ))
        db.create_unique('tickets_queue_groups', ['queue_id', 'group_id'])

        # Adding model 'LinkedContent'
        db.create_table('tickets_linkedcontent', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('content_type', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['contenttypes.ContentType'])),
            ('object_id', self.gf('django.db.models.fields.PositiveIntegerField')(db_index=True)),
        ))
        db.send_create_signal('tickets', ['LinkedContent'])

        # Adding model 'Ticket'
        db.create_table('tickets_ticket', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('title', self.gf('django.db.models.fields.CharField')(max_length=256)),
            ('source', self.gf('django.db.models.fields.CharField')(max_length=128)),
            ('status', self.gf('django.db.models.fields.CharField')(max_length=128)),
            ('key', self.gf('django.db.models.fields.CharField')(default='89d5bf95dc95492fbf46519289d105ba', max_length=32, db_index=True)),
            ('created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, db_index=True, blank=True)),
            ('modified', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('sender', self.gf('django.db.models.fields.related.ForeignKey')(related_name='sent_tickets', null=True, to=orm['auth.User'])),
            ('sender_email', self.gf('django.db.models.fields.EmailField')(max_length=75, null=True)),
            ('assignee', self.gf('django.db.models.fields.related.ForeignKey')(related_name='assigned_tickets', null=True, to=orm['auth.User'])),
            ('queue', self.gf('django.db.models.fields.related.ForeignKey')(related_name='tickets', to=orm['tickets.Queue'])),
            ('content', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['tickets.LinkedContent'], null=True)),
        ))
        db.send_create_signal('tickets', ['Ticket'])

        # Adding model 'TicketComment'
        db.create_table('tickets_ticketcomment', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('sender', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'], null=True)),
            ('text', self.gf('django.db.models.fields.TextField')()),
            ('created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('ticket', self.gf('django.db.models.fields.related.ForeignKey')(related_name='messages', to=orm['tickets.Ticket'])),
            ('moderator_only', self.gf('django.db.models.fields.BooleanField')(default=False)),
        ))
        db.send_create_signal('tickets', ['TicketComment'])

        # Adding model 'UserAnnotation'
        db.create_table('tickets_userannotation', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('sender', self.gf('django.db.models.fields.related.ForeignKey')(related_name='sent_annotations', to=orm['auth.User'])),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(related_name='annotations', to=orm['auth.User'])),
            ('text', self.gf('django.db.models.fields.TextField')()),
        ))
        db.send_create_signal('tickets', ['UserAnnotation'])


    def backwards(self, orm):
        
        # Deleting model 'Queue'
        db.delete_table('tickets_queue')

        # Removing M2M table for field groups on 'Queue'
        db.delete_table('tickets_queue_groups')

        # Deleting model 'LinkedContent'
        db.delete_table('tickets_linkedcontent')

        # Deleting model 'Ticket'
        db.delete_table('tickets_ticket')

        # Deleting model 'TicketComment'
        db.delete_table('tickets_ticketcomment')

        # Deleting model 'UserAnnotation'
        db.delete_table('tickets_userannotation')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'tickets.linkedcontent': {
            'Meta': {'object_name': 'LinkedContent'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'})
        },
        'tickets.queue': {
            'Meta': {'object_name': 'Queue'},
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'notify_by_email': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'tickets.ticket': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Ticket'},
            'assignee': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'assigned_tickets'", 'null': 'True', 'to': "orm['auth.User']"}),
            'content': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['tickets.LinkedContent']", 'null': 'True'}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'default': "'cf777fc0f0f14330a483acfd847b4c61'", 'max_length': '32', 'db_index': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'queue': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'tickets'", 'to': "orm['tickets.Queue']"}),
            'sender': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'sent_tickets'", 'null': 'True', 'to': "orm['auth.User']"}),
            'sender_email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'null': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'status': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '256'})
        },
        'tickets.ticketcomment': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'TicketComment'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'moderator_only': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'sender': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'null': 'True'}),
            'text': ('django.db.models.fields.TextField', [], {}),
            'ticket': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'messages'", 'to': "orm['tickets.Ticket']"})
        },
        'tickets.userannotation': {
            'Meta': {'object_name': 'UserAnnotation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'sender': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'sent_annotations'", 'to': "orm['auth.User']"}),
            'text': ('django.db.models.fields.TextField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'annotations'", 'to': "orm['auth.User']"})
        }
    }

    complete_apps = ['tickets']

########NEW FILE########
__FILENAME__ = models
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.contrib.auth.models import User, Group
from django.contrib.contenttypes import generic
from django.contrib.contenttypes.models import ContentType
from django.db import models
from django.utils.encoding import smart_unicode
import uuid, logging
from utils.mail import send_mail_template

logger = logging.getLogger("web")

class Queue(models.Model):
    name            = models.CharField(max_length=128)
    groups          = models.ManyToManyField(Group)
    notify_by_email = models.BooleanField()

    def __unicode__(self):
        return self.name


class LinkedContent(models.Model):
    content_type    = models.ForeignKey(ContentType)
    object_id       = models.PositiveIntegerField(db_index=True)
    content_object  = generic.GenericForeignKey('content_type', 'object_id')

    def __unicode__(self):
        return u"<# LinkedContent - pk: %s, type: %s>" % (self.object_id, self.content_type)


class Ticket(models.Model):
    title           = models.CharField(max_length=256)
    source          = models.CharField(max_length=128)
    status          = models.CharField(max_length=128)
    key             = models.CharField(max_length=32, db_index=True, default=lambda: str(uuid.uuid4()).replace('-', ''))
    created         = models.DateTimeField(db_index=True, auto_now_add=True)
    modified        = models.DateTimeField(auto_now=True)
    sender          = models.ForeignKey(User, related_name='sent_tickets', null=True)
    sender_email    = models.EmailField(null=True)
    assignee        = models.ForeignKey(User, related_name='assigned_tickets', null=True)
    queue           = models.ForeignKey(Queue, related_name='tickets')
    content         = models.ForeignKey(LinkedContent, null=True, on_delete=models.SET_NULL)

    NOTIFICATION_QUESTION     = 'tickets/email_notification_question.txt'
    NOTIFICATION_APPROVED     = 'tickets/email_notification_approved.txt'
    NOTIFICATION_APPROVED_BUT = 'tickets/email_notification_approved_but.txt'
    NOTIFICATION_DELETED      = 'tickets/email_notification_deleted.txt'
    NOTIFICATION_UPDATED      = 'tickets/email_notification_updated.txt'
    NOTIFICATION_WHITELISTED  = 'tickets/email_notification_whitelisted.txt'

    MODERATOR_ONLY = 1
    USER_ONLY = 2
    USER_AND_MODERATOR = 3


    def get_n_last_non_moderator_only_comments(self, n):
        """
        Get the last n comments that are not 'moderator only' from the self ticket
        """
        ticket_comments = self.messages.all().filter(moderator_only=False).order_by('-created')
        return list(ticket_comments)[:n] # converting from Django QuerySet to python list in order to use negative indexing

    def send_notification_emails(self, notification_type, sender_moderator):
        ticket = self
        send_to = []
        #send message to assigned moderator
        if sender_moderator in [Ticket.MODERATOR_ONLY, Ticket.USER_AND_MODERATOR]:
            if self.assignee:
                user_to = self.assignee if self.assignee else False
                send_mail_template(u'A freesound moderator handled your upload.',
                                   notification_type,
                                   locals(),
                                   'noreply@freesound.org',
                                   self.assignee.email)
        # send message to user
        if sender_moderator in [Ticket.USER_ONLY, Ticket.USER_AND_MODERATOR]:
            user_to = self.sender if self.sender else False
            email_to = user_to.email if user_to else ticket.sender_email
            if self.sender:
                send_mail_template(u'A freesound moderator handled your upload.',
                                   notification_type,
                                   locals(),
                                   'noreply@freesound.org',
                                   email_to)

    @models.permalink
    def get_absolute_url(self):
        return ('ticket', (smart_unicode(self.key),))

    def __unicode__(self):
        return u"pk %s, key %s" % (self.id, self.key)

    class Meta:
        ordering = ("-created",)
        permissions = (
            ("can_change_status", "Can change the status of the ticket."),
            ("can_change_queue", "Can change the queue of the ticket."),
            ("can_moderate", "Can moderate stuff.")
        )


class TicketComment(models.Model):
    sender          = models.ForeignKey(User, null=True)
    text            = models.TextField()
    created         = models.DateTimeField(auto_now_add=True)
    ticket          = models.ForeignKey(Ticket, related_name='messages')
    moderator_only  = models.BooleanField()

    def __unicode__(self):
        return u"<# Message - ticket_id: %s, ticket_key: %s>" % \
                    (self.ticket.id, self.ticket.key)

    class Meta:
        ordering = ("-created",)
        permissions = (
            ("can_add_moderator_only_message", "Can add read-by-moderator-only messages."),
        )


class UserAnnotation(models.Model):
    sender          = models.ForeignKey(User, related_name='sent_annotations')
    user            = models.ForeignKey(User, related_name='annotations')
    text            = models.TextField()

########NEW FILE########
__FILENAME__ = sound_tickets_count
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django import template
import tickets.views as TicketViews

register = template.Library()

@register.simple_tag
def new_sound_tickets_count():
    return TicketViews.new_sound_tickets_count()

########NEW FILE########
__FILENAME__ = tests
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.test import TestCase, Client
from django.core.urlresolvers import reverse
from models import Ticket, Queue, LinkedContent
from django.contrib.auth.models import User, Group
from tickets import QUEUE_BUG_REPORTS, QUEUE_MANAGEMENT, \
    QUEUE_SOUND_MODERATION, QUEUE_SUPPORT_REQUESTS

class CreateTickets(TestCase):
    
    fixtures = ['moderation_test_users.json']
    
    def setUp(self):
        # test client
        self.client      = Client()
    
    def test_new_ticket(self):
        ticket = Ticket()
        ticket.source = 'contact_form'
        ticket.status = 'new'
        ticket.sender = User.objects.get(username='test_user')
        ticket.queue = Queue.objects.get(name=QUEUE_SUPPORT_REQUESTS)
        ticket.save()
        self.assertEqual(ticket.assignee, None)
        
    def test_new_ticket_linked_content(self):
        ticket = Ticket()
        ticket.source = 'new_sound'
        ticket.status = 'new'
        ticket.sender = User.objects.get(username='test_user')
        ticket.assignee = User.objects.get(username='test_moderator')
        ticket.queue = Queue.objects.get(name=QUEUE_SOUND_MODERATION)
        ticket.save()
        lc = LinkedContent()
        # just to test, this would be a sound object for example
        lc.content_object = User.objects.get(username='test_admin')
        lc.save() 
        ticket.content = lc
        ticket.content.save()
        self.assertEqual(User.objects.get(username='test_admin').id, 
                         ticket.content.object_id)

########NEW FILE########
__FILENAME__ = urls
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.conf.urls.defaults import patterns, url
from django.views.generic.simple import direct_to_template
from views import *

urlpatterns = patterns('',

    #url(r'^new/$',
    #    new_ticket,
    #    name="tickets-new"),

    url(r'^contact/$',
        new_contact_ticket,
        name='tickets-contact'),

    url(r'^$',
        tickets_home,
        name='tickets-home'),

    url(r'^guide/$',
        direct_to_template,
        {'template': 'tickets/guide.html'},
        name='tickets-moderation-guide'),

    url(r'^moderation/$',
        moderation_home,
        name='tickets-moderation-home'),

    url(r'^moderation/tardy_users_sounds/$',
        moderation_tary_users_sounds,
        name='tickets-moderation-tardy-users'),

    url(r'^moderation/tardy_moderators_sounds/$',
        moderation_tary_moderators_sounds,
        name='tickets-moderation-tardy-moderators'),

    url(r'^moderation/assign/(?P<user_id>\d+)/$',
        moderation_assign_user,
        name='tickets-moderation-assign-user'),

    url(r'^moderation/assign/ticket/(?P<user_id>\d+)/(?P<ticket_id>\d+)/$',
        moderation_assign_single_ticket,
        name='tickets-moderation-assign-signle-ticket'),

    url(r'^moderation/assigned/(?P<user_id>\d+)/$',
        moderation_assigned,
        name='tickets-moderation-assigned'),

    url(r'^support/$',
        support_home,
        name='tickets-support-home'),

    url(r'^moderation/annotations/(?P<user_id>\d+)/$',
        user_annotations,
        name='tickets-user-annotations'),

    url(r'^moderation/pending/(?P<username>[^//]+)/$',
        pending_tickets_per_user,
        name='tickets-user-pending_sounds'),

    url(r'^(?P<ticket_key>[\w\d]+)/$',
        ticket,
        name='tickets-ticket'),

    url(r'^(?P<ticket_key>[\w\d]+)/messages/$',
        sound_ticket_messages,
        name='tickets-ticket-messages'),

)

########NEW FILE########
__FILENAME__ = views
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.shortcuts import render_to_response, get_object_or_404, redirect
from django.template import RequestContext
from django.contrib.auth.decorators import login_required, permission_required
from django.contrib.auth.models import User, Group
from django.core.urlresolvers import reverse
from django.http import HttpResponseRedirect, HttpResponse
from models import Ticket, Queue, TicketComment
from forms import *
from tickets import *
from django.db import connection, transaction
from django.contrib import messages
from sounds.models import Sound
import datetime
from utils.cache import invalidate_template_cache
from utils.pagination import paginate
from utils.functional import combine_dicts
from settings import MAX_TICKETS_IN_MODERATION_ASSIGNED_PAGE
from django.core.management import call_command
from threading import Thread
import settings


def __get_contact_form(request, use_post=True):
    return __get_anon_or_user_form(request, AnonymousContactForm, UserContactForm, use_post)


def __get_tc_form(request, use_post=True):
    return __get_anon_or_user_form(request, AnonymousMessageForm, UserMessageForm, use_post, True)


def __get_anon_or_user_form(request, anonymous_form, user_form, use_post=True, include_mod=False):
    if __can_view_mod_msg(request) and anonymous_form != AnonymousContactForm:
        user_form = ModeratorMessageForm
    if len(request.POST.keys()) > 0 and use_post:
        if request.user.is_authenticated():
            return user_form(request.POST)
        else:
            return anonymous_form(request, request.POST)
    else:
        return user_form() if request.user.is_authenticated() else anonymous_form(request)

def __can_view_mod_msg(request):
    return request.user.is_authenticated() \
            and (request.user.is_superuser or request.user.is_staff \
                 or Group.objects.get(name='moderators') in request.user.groups.all())

# TODO: copied from sound_edit view,
def is_selected(request, prefix):
    for name in request.POST.keys():
        if name.startswith(prefix):
            return True
    return False

def invalidate_all_moderators_header_cache():
    mods = Group.objects.get(name='moderators').user_set.all()
    for mod in mods:
        invalidate_template_cache("user_header", mod.id)

def ticket(request, ticket_key):
    can_view_moderator_only_messages = __can_view_mod_msg(request)
    clean_status_forms = True
    clean_comment_form = True
    ticket = get_object_or_404(Ticket, key=ticket_key)
    if request.method == 'POST':

        invalidate_template_cache("user_header", ticket.sender.id)
        invalidate_all_moderators_header_cache()

        # Left ticket message
        if is_selected(request, 'recaptcha') or (request.user.is_authenticated() and is_selected(request, 'message')):
            tc_form = __get_tc_form(request)
            if tc_form.is_valid():
                tc = TicketComment()
                tc.text = tc_form.cleaned_data['message']
                tc.moderator_only = tc_form.cleaned_data.get('moderator_only', False)
                if tc.text:
                    if request.user.is_authenticated():
                        tc.sender = request.user
                    tc.ticket = ticket
                    tc.save()
                    if not request.user.is_authenticated():
                        email_to = Ticket.MODERATOR_ONLY
                    elif request.user == ticket.sender:
                        email_to = Ticket.MODERATOR_ONLY
                    else:
                        email_to = Ticket.USER_ONLY
                    ticket.send_notification_emails(ticket.NOTIFICATION_UPDATED,
                                                    email_to)
            else:
                clean_comment_form = False
        # update sound ticket
        elif is_selected(request, 'tm') or is_selected(request, 'ss'):
            ticket_form = TicketModerationForm(request.POST, prefix="tm")
            sound_form = SoundStateForm(request.POST, prefix="ss")
            if ticket_form.is_valid() and sound_form.is_valid():
                clean_status_forms = True
                clean_comment_form = True
                sound_state = sound_form.cleaned_data.get('state')
                # Sound should be deleted
                if sound_state == 'DE':
                    if ticket.content:
                        ticket.content.content_object.delete()
                        ticket.content.delete()
                        ticket.content = None
                    ticket.status = TICKET_STATUS_CLOSED
                    tc = TicketComment(sender=request.user,
                                       text="Moderator %s deleted the sound and closed the ticket" % request.user,
                                       ticket=ticket,
                                       moderator_only=False)
                    tc.save()
                    ticket.send_notification_emails(ticket.NOTIFICATION_DELETED,
                                                    ticket.USER_ONLY)
                # Set another sound state that's not delete
                else:
                    if ticket.content:
                        ticket.content.content_object.moderation_state = sound_state
                        # Mark the index as dirty so it'll be indexed in Solr
                        if sound_state == "OK":
                            ticket.content.content_object.mark_index_dirty()
                        ticket.content.content_object.save()
                    ticket.status = ticket_form.cleaned_data.get('status')
                    tc = TicketComment(sender=request.user,
                                       text="Moderator %s set the sound to %s and the ticket to %s." % \
                                                (request.user,
                                                 'pending' if sound_state == 'PE' else sound_state,
                                                 ticket.status),
                                       ticket=ticket,
                                       moderator_only=False)
                    tc.save()
                    ticket.send_notification_emails(ticket.NOTIFICATION_UPDATED,
                                                    ticket.USER_ONLY)
                ticket.save()

    if clean_status_forms:
        ticket_form = TicketModerationForm(initial={'status': ticket.status}, prefix="tm")
        sound_form = SoundStateForm(initial={'state':
                                             ticket.content.content_object.moderation_state \
                                             if ticket.content else 'DE'},
                                             prefix="ss")
    if clean_comment_form:
        tc_form = __get_tc_form(request, False)
    return render_to_response('tickets/ticket.html',
                              locals(),
                              context_instance=RequestContext(request))


@login_required
def sound_ticket_messages(request, ticket_key):
    can_view_moderator_only_messages = __can_view_mod_msg(request)
    ticket = get_object_or_404(Ticket, key=ticket_key)
    return render_to_response('tickets/message_list.html',
                              locals(),
                              context_instance=RequestContext(request))


def new_contact_ticket(request):
    ticket_created = False
    if request.POST:
        form = __get_contact_form(request)
        if form.is_valid():
            ticket = Ticket()
            ticket.title = form.cleaned_data['title']
            ticket.source = TICKET_SOURCE_CONTACT_FORM
            ticket.status = TICKET_STATUS_NEW
            ticket.queue = Queue.objects.get(name=QUEUE_SUPPORT_REQUESTS)
            tc = TicketComment()
            if request.user.is_authenticated():
                ticket.sender = request.user
                tc.sender = request.user
            else:
                ticket.sender_email = form.cleaned_data['email']
            tc.text = form.cleaned_data['message']
            ticket.save()
            tc.ticket = ticket
            tc.save()
            ticket_created = True
            # TODO: send email
    else:
        form = __get_contact_form(request, False)
    return render_to_response('tickets/contact.html', locals(), context_instance=RequestContext(request))


# In the next 2 functions we return a queryset os the evaluation is lazy.
# N.B. these functions are used in the home page as well.
def new_sound_tickets_count():
#AND (sound.processing_state = 'OK' OR sound.processing_state = 'FA')
#    return Ticket.objects.filter(status=TICKET_STATUS_NEW,
#                                 source=TICKET_SOURCE_NEW_SOUND)
    return len(list(Ticket.objects.raw("""
SELECT
ticket.id
FROM
tickets_ticket AS ticket,
sounds_sound AS sound,
tickets_linkedcontent AS content
WHERE
    ticket.content_id = content.id
AND ticket.assignee_id is NULL
AND content.object_id = sound.id
AND sound.moderation_state = 'PE'
AND sound.processing_state = 'OK'
AND ticket.status = '%s'
""" % TICKET_STATUS_NEW)))

def new_support_tickets_count():
    return Ticket.objects.filter(assignee=None,
                                 source=TICKET_SOURCE_CONTACT_FORM).count()

@permission_required('tickets.can_moderate')
def tickets_home(request):
    
    if request.user.id :
        sounds_in_moderators_queue_count = Ticket.objects.select_related()\
                                                         .filter(assignee=request.user.id)\
                                                         .exclude(status='closed')\
                                                         .exclude(content=None)\
                                                         .order_by('status', '-created').count()
    else :
        sounds_in_moderators_queue_count = -1
        
    new_upload_count = new_sound_tickets_count()
    tardy_moderator_sounds_count = len(list(__get_tardy_moderator_tickets_all()))
    tardy_user_sounds_count = len(list(__get_tardy_user_tickets_all()))
    new_support_count = new_support_tickets_count()
    sounds_queued_count = Sound.objects.filter(processing_state='QU').count()
    sounds_pending_count = Sound.objects.filter(processing_state='PE').count()
    sounds_processing_count = Sound.objects.filter(processing_state='PR').count()
    sounds_failed_count = Sound.objects.filter(processing_state='FA').count()
    return render_to_response('tickets/tickets_home.html', locals(), context_instance=RequestContext(request))


def __get_new_uploaders_by_ticket():
#AND (sounds_sound.processing_state = 'OK' OR sounds_sound.processing_state = 'FA')
    cursor = connection.cursor()
    cursor.execute("""
SELECT
    tickets_ticket.sender_id, count(*)
FROM
    tickets_ticket, tickets_linkedcontent, sounds_sound
WHERE
    tickets_ticket.source = 'new sound'
    AND sounds_sound.processing_state = 'OK'
    AND sounds_sound.moderation_state = 'PE'
    AND tickets_linkedcontent.object_id = sounds_sound.id
    AND tickets_ticket.content_id = tickets_linkedcontent.id
    AND tickets_ticket.assignee_id is NULL
    AND tickets_ticket.status = '%s'
GROUP BY sender_id""" % TICKET_STATUS_NEW)
    user_ids_plus_new_count = dict(cursor.fetchall())
    user_objects = User.objects.filter(id__in=user_ids_plus_new_count.keys())

    users_aux = []
    for user in user_objects:
        # Pick the oldest non moderated ticket of each user and compute how many seconds it has been in the queue
        user_new_tickets = Ticket.objects.filter(sender__id=user.id, status=TICKET_STATUS_NEW, content__isnull=False).order_by("created")
        oldest_new_ticket = user_new_tickets[0]
        for ticket in user_new_tickets:
            if ticket.content.content_object:
                if ticket.content.content_object.processing_state == 'OK' and ticket.content.content_object.moderation_state == 'PE':
                    oldest_new_ticket = ticket

        days_in_queue = (datetime.datetime.now() - oldest_new_ticket.created).days #seconds_in_queue / (3600 * 24)
        users_aux.append({'user': user, 'days_in_queue': days_in_queue, 'new_sounds': user_ids_plus_new_count[user.id]})

    # Sort users according to their oldest ticket (older = first)
    users_aux.sort(key=lambda item:item['days_in_queue'], reverse=True)
    new_sounds_users = []
    for user in users_aux:
        new_sounds_users.append((user['user'],user['new_sounds'],user['days_in_queue']))

    return new_sounds_users


def __get_unsure_sound_tickets():
    '''Query to get tickets that were returned to the queue by moderators that
    didn't know what to do with the sound.'''
    return Ticket.objects.filter(source=TICKET_SOURCE_NEW_SOUND,
                                 assignee=None,
                                 status=TICKET_STATUS_ACCEPTED)


def __get_tardy_moderator_tickets():
    """Get tickets for moderators that haven't responded in the last day"""
    return Ticket.objects.raw("""
SELECT
distinct(ticket.id),
ticket.modified as modified
FROM
tickets_ticketcomment AS comment,
tickets_ticket AS ticket
WHERE comment.id in (   SELECT MAX(id)
                        FROM tickets_ticketcomment
                        GROUP BY ticket_id    )
AND ticket.assignee_id is Not Null
AND comment.ticket_id = ticket.id
AND (comment.sender_id = ticket.sender_id OR comment.sender_id IS NULL)
AND now() - modified > INTERVAL '24 hours'
AND ticket.status != '%s'
LIMIT 5
""" % TICKET_STATUS_CLOSED)


def __get_tardy_moderator_tickets_all():
    """Get tickets for moderators that haven't responded in the last day"""
    return Ticket.objects.raw("""
SELECT
distinct(ticket.id),
ticket.modified as modified
FROM
tickets_ticketcomment AS comment,
tickets_ticket AS ticket
WHERE comment.id in (   SELECT MAX(id)
                        FROM tickets_ticketcomment
                        GROUP BY ticket_id    )
AND ticket.assignee_id is Not Null
AND comment.ticket_id = ticket.id
AND (comment.sender_id = ticket.sender_id OR comment.sender_id IS NULL)
AND now() - modified > INTERVAL '24 hours'
AND ticket.status != '%s'
""" % TICKET_STATUS_CLOSED)


def __get_tardy_user_tickets():
    """Get tickets for users that haven't responded in the last 2 days"""
    return Ticket.objects.raw("""
SELECT
distinct(ticket.id)
FROM
tickets_ticketcomment AS comment,
tickets_ticket AS ticket
WHERE comment.id in (   SELECT MAX(id)
                        FROM tickets_ticketcomment
                        GROUP BY ticket_id    )
AND ticket.assignee_id is Not Null
AND ticket.status != '%s'
AND comment.ticket_id = ticket.id
AND comment.sender_id != ticket.sender_id
AND now() - comment.created > INTERVAL '2 days'
LIMIT 5
""" % TICKET_STATUS_CLOSED)
    
def __get_tardy_user_tickets_all():
    """Get tickets for users that haven't responded in the last 2 days"""
    return Ticket.objects.raw("""
SELECT
distinct(ticket.id)
FROM
tickets_ticketcomment AS comment,
tickets_ticket AS ticket
WHERE comment.id in (   SELECT MAX(id)
                        FROM tickets_ticketcomment
                        GROUP BY ticket_id    )
AND ticket.assignee_id is Not Null
AND ticket.status != '%s'
AND comment.ticket_id = ticket.id
AND comment.sender_id != ticket.sender_id
AND now() - comment.created > INTERVAL '2 days'
""" % TICKET_STATUS_CLOSED)


@permission_required('tickets.can_moderate')
def moderation_home(request):
    if request.user.id :
        sounds_in_moderators_queue_count = Ticket.objects.select_related()\
                                                         .filter(assignee=request.user.id)\
                                                         .exclude(status='closed')\
                                                         .exclude(content=None)\
                                                         .order_by('status', '-created').count()
    else :
        sounds_in_moderators_queue_count = -1

    new_sounds_users = __get_new_uploaders_by_ticket()
    unsure_tickets = list(__get_unsure_sound_tickets()) #TODO: shouldn't appear
    tardy_moderator_tickets = list(__get_tardy_moderator_tickets())
    tardy_user_tickets = list(__get_tardy_user_tickets())
    tardy_moderator_tickets_count = len(list(__get_tardy_moderator_tickets_all()))
    tardy_user_tickets_count = len(list(__get_tardy_user_tickets_all()))
    
    return render_to_response('tickets/moderation_home.html', locals(), context_instance=RequestContext(request))

@permission_required('tickets.can_moderate')
def moderation_tary_users_sounds(request):
    if request.user.id :
        sounds_in_moderators_queue_count = Ticket.objects.select_related().filter(assignee=request.user.id).exclude(status='closed').exclude(content=None).order_by('status', '-created').count()
    else :
        sounds_in_moderators_queue_count = -1

    tardy_user_tickets = list(__get_tardy_user_tickets_all())

    return render_to_response('tickets/moderation_tardy_users.html', combine_dicts(paginate(request, tardy_user_tickets, 10), locals()), context_instance=RequestContext(request))

@permission_required('tickets.can_moderate')
def moderation_tary_moderators_sounds(request):
    if request.user.id :
        sounds_in_moderators_queue_count = Ticket.objects.select_related().filter(assignee=request.user.id).exclude(status='closed').exclude(content=None).order_by('status', '-created').count()
    else :
        sounds_in_moderators_queue_count = -1

    tardy_moderators_tickets = list(__get_tardy_moderator_tickets_all())

    return render_to_response('tickets/moderation_tardy_moderators.html', combine_dicts(paginate(request, tardy_moderators_tickets, 10), locals()), context_instance=RequestContext(request))


@permission_required('tickets.can_moderate')
def moderation_assign_user(request, user_id):
#AND (sounds_sound.processing_state = 'OK' OR sounds_sound.processing_state = 'FA')
    sender = User.objects.get(id=user_id)
#    Ticket.objects.filter(assignee=None, sender=sender, source=TICKET_SOURCE_NEW_SOUND) \
#        .update(assignee=request.user, status=TICKET_STATUS_ACCEPTED)
    cursor = connection.cursor()
    cursor.execute("""
UPDATE
    tickets_ticket
SET
    assignee_id = %s,
    status = '%s',
    modified = now()
FROM
    sounds_sound,
    tickets_linkedcontent
WHERE
    tickets_ticket.source = 'new sound'
AND sounds_sound.processing_state = 'OK'
AND sounds_sound.moderation_state = 'PE'
AND tickets_linkedcontent.object_id = sounds_sound.id
AND tickets_ticket.content_id = tickets_linkedcontent.id
AND tickets_ticket.assignee_id is NULL
AND tickets_ticket.status = '%s'
AND sounds_sound.user_id = %s""" % \
(request.user.id, TICKET_STATUS_ACCEPTED, TICKET_STATUS_NEW, sender.id))
    transaction.commit_unless_managed()
    msg = 'You have been assigned all new sounds from %s.' % sender.username
    messages.add_message(request, messages.INFO, msg)
    invalidate_all_moderators_header_cache()

    return HttpResponseRedirect(reverse("tickets-moderation-home"))

# TODO: ongoing work
@permission_required('tickets.can_moderate')
def moderation_assign_single_ticket(request, user_id, ticket_id):
#AND (sounds_sound.processing_state = 'OK' OR sounds_sound.processing_state = 'FA')
    
    # REASSIGN SINGLE TICKET
    ticket = Ticket.objects.get(id=ticket_id)
    sender = User.objects.get(id=user_id)
    ticket.assignee = User.objects.get(id=request.user.id)
    
    '''
    cursor = connection.cursor()
    cursor.execute("""
    UPDATE 
        tickets_ticket 
    SET 
        assignee_id = %s
    WHERE 
        tickets_ticket.id = %s
    """ % \
    (request.user.id, ticket.id))
    transaction.commit_unless_managed()
    '''
    '''
    tc = TicketComment(sender=request.user,
                       text="Reassigned ticket to moderator %s" % request.user.username,
                       ticket=ticket,
                       moderator_only=False)
    tc.save()
    '''
    # update modified date, so it doesn't appear in tardy moderator's sounds
    ticket.modified = datetime.datetime.now()
    ticket.save()
    invalidate_all_moderators_header_cache()
    
    msg = 'You have been assigned ticket "%s".' % ticket.title
    messages.add_message(request, messages.INFO, msg)

    next = request.GET.get("next",None)
    p = request.GET.get("p",1)

    if next:
        if next == "tardy_users":
            return HttpResponseRedirect(reverse("tickets-moderation-tardy-users"))
        elif next == "tardy_moderators":
            return HttpResponseRedirect(reverse("tickets-moderation-tardy-moderators")+"?page=%s"%str(p))
        else:
            return HttpResponseRedirect(reverse("tickets-moderation-home")+"?page=%s"%str(p))
    else:
        return HttpResponseRedirect(reverse("tickets-moderation-home"))


@permission_required('tickets.can_moderate')
def moderation_assigned(request, user_id):
    
    can_view_moderator_only_messages = __can_view_mod_msg(request)
    clear_forms = True
    if request.method == 'POST':
        mod_sound_form = SoundModerationForm(request.POST)
        msg_form = ModerationMessageForm(request.POST)

        if mod_sound_form.is_valid() and msg_form.is_valid():

            ticket = Ticket.objects.get(id=mod_sound_form.cleaned_data.get("ticket", False))
            invalidate_template_cache("user_header", ticket.sender.id)
            invalidate_all_moderators_header_cache()
            action = mod_sound_form.cleaned_data.get("action")
            msg = msg_form.cleaned_data.get("message", False)
            moderator_only = msg_form.cleaned_data.get("moderator_only", False)

            if msg:
                tc = TicketComment(sender=ticket.assignee,
                                   text=msg,
                                   ticket=ticket,
                                   moderator_only=moderator_only)
                tc.save()

            if action == "Approve":
                ticket.status = TICKET_STATUS_CLOSED
                ticket.content.content_object.moderation_state = "OK"
                ticket.content.content_object.save()
                ticket.save()
                ticket.content.content_object.mark_index_dirty()
                if msg:
                    ticket.send_notification_emails(Ticket.NOTIFICATION_APPROVED_BUT,
                                                    Ticket.USER_ONLY)
                else:
                    ticket.send_notification_emails(Ticket.NOTIFICATION_APPROVED,
                                                    Ticket.USER_ONLY)
            elif action == "Defer":
                ticket.status = TICKET_STATUS_DEFERRED
                ticket.save()
                # only send a notification if a message was added
                if msg:
                    ticket.send_notification_emails(Ticket.NOTIFICATION_QUESTION,
                                                    Ticket.USER_ONLY)
            elif action == "Return":
                ticket.assignee = None
                ticket.status = TICKET_STATUS_NEW
                # no notification here
                ticket.save()
            elif action == "Delete":
                ticket.send_notification_emails(Ticket.NOTIFICATION_DELETED,
                                                Ticket.USER_ONLY)
                # to prevent a crash if the form is resubmitted
                if ticket.content:
                    ticket.content.content_object.delete()
                    ticket.content.delete()
                    ticket.content = None
                ticket.status = TICKET_STATUS_CLOSED
                ticket.save()
            elif action == "Whitelist":

                th = Thread(target=call_command, args=('whitelist_user', ticket.id,))
                th.start()
                ticket.send_notification_emails(Ticket.NOTIFICATION_WHITELISTED,
                                                Ticket.USER_ONLY)

                messages.add_message(request, messages.INFO, 'User %s has been whitelisted but some of his tickets might '
                                                             'still appear on this list for some time. Please reload the page in a few '
                                                             'seconds to see the updated list of pending tickets' % ticket.sender.username)

        else:
            clear_forms = False
    if clear_forms:
        mod_sound_form = SoundModerationForm(initial={'action': 'Approve'})
        msg_form = ModerationMessageForm()

    qs = Ticket.objects.select_related() \
                       .filter(assignee=user_id) \
                       .exclude(status=TICKET_STATUS_CLOSED) \
                       .exclude(content=None) \
                       .order_by('status', '-created')
    paginaion_response = paginate(request, qs, MAX_TICKETS_IN_MODERATION_ASSIGNED_PAGE)
    paginaion_response['page'].object_list = list(paginaion_response['page'].object_list)
    for ticket in paginaion_response['page'].object_list:
        sound_id = ticket.content.object_id
        try:
            Sound.objects.get(id=sound_id)
        except:
            paginaion_response['page'].object_list.remove(ticket)
            try:
                # Try to delete ticket so error does not happen again
                ticket.delete()
            except:
                pass

    moderator_tickets_count = qs.count()
    moderation_texts = MODERATION_TEXTS
    show_pagination = moderator_tickets_count > MAX_TICKETS_IN_MODERATION_ASSIGNED_PAGE

    return render_to_response('tickets/moderation_assigned.html',
                              combine_dicts(paginaion_response, locals()),
                              context_instance=RequestContext(request))


@permission_required('tickets.can_moderate')
def user_annotations(request, user_id):
    user = get_object_or_404(User, id=user_id)
    num_sounds_ok = Sound.objects.filter(user=user, moderation_state="OK").count()
    num_sounds_pending = Sound.objects.filter(user=user).exclude(moderation_state="OK").count()
    if request.method == 'POST':
        form = UserAnnotationForm(request.POST)
        if form.is_valid():
            ua = UserAnnotation(sender=request.user,
                                user=user,
                                text=form.cleaned_data['text'])
            ua.save()
    else:
        form = UserAnnotationForm()
    annotations = UserAnnotation.objects.filter(user=user)
    return render_to_response('tickets/user_annotations.html',
                              locals(),
                              context_instance=RequestContext(request))


@permission_required('tickets.can_moderate')
def support_home(request):
    return HttpResponse('TODO')


def get_pending_sounds(user):
    ret = []
    # getting all user tickets that last that have not been closed
    user_tickets = Ticket.objects.filter(sender=user).exclude(status=TICKET_STATUS_CLOSED)

    for user_ticket in user_tickets:
        try:
            sound_id = user_ticket.content.object_id
            sound_obj = Sound.objects.get(id=sound_id, processing_state='OK', moderation_state='PE')
            ret.append( (user_ticket, sound_obj) )
        except:
            pass

    return ret


@permission_required('tickets.can_moderate')
def pending_tickets_per_user(request, username):

    user = get_object_or_404(User, username=username)
    tickets_sounds = get_pending_sounds(user)
    pendings = []
    for ticket, sound in tickets_sounds:
        last_comments = ticket.get_n_last_non_moderator_only_comments(3)
        pendings.append( (ticket, sound, last_comments) )

    show_pagination = len(pendings) > settings.SOUNDS_PENDING_MODERATION_PER_PAGE

    n_unprocessed_sounds = Sound.objects.select_related().filter(user=user).exclude(processing_state="OK").count()
    if n_unprocessed_sounds:
        messages.add_message(request, messages.WARNING, '%i of %s\'s recently uploaded sounds are still in processing '
                                                        'phase and therefore are not yet ready for moderation. These '
                                                        'sounds won\'t appear in this list until they are successfully '
                                                        'processed.' % (n_unprocessed_sounds, user.username))

    moderators_version = True
    return render_to_response('accounts/pending.html', combine_dicts(paginate(request, pendings, settings.SOUNDS_PENDING_MODERATION_PER_PAGE), locals()), context_instance=RequestContext(request))


########NEW FILE########
__FILENAME__ = urls
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.conf.urls.defaults import patterns, url, include, handler404, handler500
from django.contrib import admin
from django.views.generic.simple import direct_to_template
import accounts.views
import geotags.views
import search.views
import sounds.views
import support.views
import tags.views
import forum.views
import comments.views
import bookmarks.views
from django.views.generic.simple import redirect_to
from utils.tagrecommendation_utilities import get_recommended_tags_view, log_recommendation_info_view

admin.autodiscover()

urlpatterns = patterns('',
    url(r'^$', sounds.views.front_page, name='front-page'),

    url(r'^people/$', accounts.views.accounts, name="accounts"),
    url(r'^people/(?P<username>[^//]+)/$', accounts.views.account, name="account"),
    url(r'^people/(?P<username>[^//]+)/sounds/$', sounds.views.for_user, name="sounds-for-user"),
    url(r'^people/(?P<username>[^//]+)/flag/$', accounts.views.flag_user, name="flag-user"),
    url(r'^people/(?P<username>[^//]+)/clear_flags/$', accounts.views.clear_flags_user, name="clear-flags-user"),
    url(r'^people/(?P<username>[^//]+)/comments/$', comments.views.for_user, name="comments-for-user"),
    url(r'^people/(?P<username>[^//]+)/geotags/$', geotags.views.for_user, name="geotags-for-user"),
    url(r'^people/(?P<username>[^//]+)/sounds/(?P<sound_id>\d+)/$', sounds.views.sound, name="sound"),
    url(r'^people/(?P<username>[^//]+)/sounds/(?P<sound_id>\d+)/download/.*$', sounds.views.sound_download, name="sound-download"),
    url(r'^people/(?P<username>[^//]+)/sounds/(?P<sound_id>\d+)/flag/$', sounds.views.flag, name="sound-flag"),
    url(r'^people/(?P<username>[^//]+)/sounds/(?P<sound_id>\d+)/edit/sources/$', sounds.views.sound_edit_sources, name="sound-edit-sources"),
    url(r'^people/(?P<username>[^//]+)/sounds/(?P<sound_id>\d+)/edit/$', sounds.views.sound_edit, name="sound-edit"),
    url(r'^people/(?P<username>[^//]+)/sounds/(?P<sound_id>\d+)/remixes/$', sounds.views.remixes, name="sound-remixes"),
    url(r'^people/(?P<username>[^//]+)/sounds/(?P<sound_id>\d+)/geotag/$', sounds.views.geotag, name="sound-geotag"),
    url(r'^people/(?P<username>[^//]+)/sounds/(?P<sound_id>\d+)/delete/$', sounds.views.delete, name="sound-delete"),
    url(r'^people/(?P<username>[^//]+)/sounds/(?P<sound_id>\d+)/similar/$', sounds.views.similar, name="sound-similar"),
    url(r'^people/(?P<username>[^//]+)/sounds/(?P<sound_id>\d+)/downloaders/$', sounds.views.downloaders, name="sound-downloaders"),
    url(r'^people/(?P<username>[^//]+)/packs/$', sounds.views.packs_for_user, name="packs-for-user"),
    url(r'^people/(?P<username>[^//]+)/packs/(?P<pack_id>\d+)/$', sounds.views.pack, name="pack"),
    url(r'^people/(?P<username>[^//]+)/packs/(?P<pack_id>\d+)/edit/$', sounds.views.pack_edit, name="pack-edit"),
    url(r'^people/(?P<username>[^//]+)/packs/(?P<pack_id>\d+)/delete/$', sounds.views.pack_delete, name="pack-delete"),
    url(r'^people/(?P<username>[^//]+)/packs/(?P<pack_id>\d+)/download/.*$', sounds.views.pack_download, name="pack-download"),
    url(r'^people/(?P<username>[^//]+)/packs/(?P<pack_id>\d+)/downloaders/$', sounds.views.pack_downloaders, name="pack-downloaders"),
    url(r'^people/(?P<username>[^//]+)/sounds/(?P<sound_id>\d+)/display/$', sounds.views.display_sound_wrapper, name="sound-display"),
    url(r'^people/(?P<username>[^//]+)/downloaded_sounds/$', accounts.views.downloaded_sounds, name="user-downloaded-sounds"),
    url(r'^people/(?P<username>[^//]+)/downloaded_packs/$', accounts.views.downloaded_packs, name="user-downloaded-packs"),
    url(r'^people/(?P<username>[^//]+)/bookmarks/$', bookmarks.views.bookmarks, name="bookmarks-for-user"),
    url(r'^people/(?P<username>[^//]+)/bookmarks/category/(?P<category_id>\d+)/$', bookmarks.views.bookmarks, name="bookmarks-for-user-for-category"),

    url(r'^embed/sound/iframe/(?P<sound_id>\d+)/simple/(?P<player_size>\w+)/$', sounds.views.embed_iframe, name="embed-simple-sound-iframe"),
    url(r'^embed/geotags_box/iframe/$', geotags.views.embed_iframe, name="embed-geotags-box-iframe"),

    url(r'^browse/$', sounds.views.sounds, name="sounds"),
    url(r'^browse/tags/$', tags.views.tags, name="tags"),
    url(r'^browse/tags/(?P<multiple_tags>[\w//-]+)/$', tags.views.tags, name="tags"),
    url(r'^browse/packs/$', sounds.views.packs, name="packs"),
    url(r'^browse/comments/$', comments.views.all, name="comments"),
    url(r'^browse/random/$', sounds.views.random, name="sounds-random"),
    url(r'^browse/geotags/(?P<tag>[\w-]+)?/?$', geotags.views.geotags, name="geotags"),
    url(r'^browse/geotags_box/$', geotags.views.geotags_box, name="geotags-box"),

    url(r'^browse/remixed/$',
        sounds.views.remixed,
        name="remix-groups"),

    url(r'^browse/remixed/(?P<group_id>\d+)/$',
        sounds.views.remix_group,
        name="remix-group"),

    url(r'^contact/', support.views.contact, name="contact"),
    url(r'^search/$', search.views.search, name='sounds-search'),
    # Alternative previews url for logging clickthrough data
    url(r'^data/previews_alt/(?P<folder_id>\d+)/(?P<sound_id>\d+)_(?P<user_id>\d+)', sounds.views.sound_preview,name="sound-preview"),

    (r'^ratings/', include('ratings.urls')),
    (r'^comments/', include('comments.urls')),
    (r'^help/', include('wiki.urls')),
    (r'^forum/', include('forum.urls')),
    (r'^geotags/', include('geotags.urls')),
    (r'^home/', include('accounts.urls')),
    (r'^tickets/', include('tickets.urls')),

    url(r'^blog/$', "django.views.generic.simple.redirect_to", kwargs={'url': "http://blog.freesound.org/"}, name="blog"),
    url(r'^crossdomain\.xml$', direct_to_template, kwargs={'template':'crossdomain.xml'}, name="crossdomain"),

    # admin views
    url(r'^admin/orderedmove/(?P<direction>up|down)/(?P<model_type_id>\d+)/(?P<model_id>\d+)/$', 'general.views.admin_move_ordered_model', name="admin-move"),
    (r'^admin/doc/', include('django.contrib.admindocs.urls')),
    (r'^admin/', admin.site.urls),

    # api views
    (r'^api/', include('api.urls')),

    # apiv2 views
    (r'^apiv2/', include('apiv2.urls')),

    # tag recommendation
    url(r'^tagrecommendation/recommendtags/$', get_recommended_tags_view, name="recommend-tags"),
    url(r'^tagrecommendation/savelog/$', log_recommendation_info_view, name="log-recommendation-info"),

    # 500 view
    url(r'^crash_me/$',
        accounts.views.crash_me,
        name="crash-me"),

    # donation campaign
    url(r'^donate/', accounts.views.donate_redirect, name="donate-redirect"),

    # old url format redirects
    url(r'^usersViewSingle', accounts.views.old_user_link_redirect, name="old-account-page"),
    url(r'^samplesViewSingle', sounds.views.old_sound_link_redirect, name="old-sound-page"),
    url(r'^packsViewSingle', sounds.views.old_pack_link_redirect, name="old-pack-page"),
    url(r'^tagsViewSingle', tags.views.old_tag_link_redirect, name="old-tag-page"),
    url(r'^forum/viewtopic', forum.views.old_topic_link_redirect, name="old-topic-page"),
    

    # dead season redirect (THIS IS TEMPORAL)
    url(r'^deadseason/$', redirect_to, {'url': 'http://www.freesound.org/people/Slave2theLight/bookmarks/category/4730/'}),
)

#if you need django to host the admin files...
from django.conf import settings
if settings.DEBUG:
    urlpatterns += patterns('',
        (r'^%s/(?P<path>.*)$' % settings.MEDIA_URL.strip('/'), 'django.views.static.serve', {'document_root': settings.MEDIA_ROOT, 'show_indexes': True}),
        (r'^%s/(?P<path>.*)$' % settings.DATA_URL.strip('/'), 'django.views.static.serve', {'document_root': settings.DATA_PATH, 'show_indexes': True}),
    )

########NEW FILE########
__FILENAME__ = convert_to_mp3
#!/usr/bin/env python

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

import sys
from processing import convert_to_mp3

for filename in sys.argv[1:]:
    convert_to_mp3(filename, filename[:-3] + "mp3")
########NEW FILE########
__FILENAME__ = convert_to_wav
#!/usr/bin/env python

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

import sys
from processing import convert_to_wav, audio_info, AudioProcessingException

convert_to_wav(sys.argv[1], sys.argv[2])

try:
    info = audio_info(sys.argv[2])
    if not ( info["bits"] == 16 and info["samplerate"] == 44100 and info["channels"] == 2 and info["duration"] > 0 ):
        print "warning, created file is not 44.1, stereo, 16bit!"
except AudioProcessingException, e:
    print "warning, audio processing seems to have failed:", e
########NEW FILE########
__FILENAME__ = essentia_analysis
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from settings import ESSENTIA_EXECUTABLE
import os, shutil, subprocess, signal, sys

def analyze(sound):
    FFMPEG_TIMEOUT = 3 * 60
    tmp_conv = False

    def  alarm_handler(signum, frame):
        raise Exception("timeout while waiting for ffmpeg")

    #TODO: refactor processing and analysis together
    def write_log(message):
        sys.stdout.write(str(message)+'\n')
        sys.stdout.flush()

    def failure(message, error=None):
        sound.set_analysis_state("FA")
        logging_message = "Failed to process sound with id %s\n" % sound.id
        logging_message += "\tmessage: %s\n" % message
        if error:
            logging_message += "\terror: %s\n" + str(error)
        write_log(message)

    try:
        statistics_path = sound.locations("analysis.statistics.path")
        frames_path = sound.locations("analysis.frames.path")
        input_path = sound.locations('path')

        if not os.path.exists(input_path):
            failure('Could not find file with path %s'% input_path)
            return False

        if os.path.getsize(input_path) >100 * 1024 * 1024: #same as filesize_warning in sound model
            failure('File is larger than 50MB. Passing on it.')
            return False

        ext = os.path.splitext(input_path)[1]
        if ext in ['.wav', '.aiff', '.aifc', '.aif']:
            tmp_conv = True
            tmp_wav_path = '/tmp/conversion_%s.wav' % sound.id
            try:
                p = subprocess.Popen(['ffmpeg', '-y', '-i', input_path, '-acodec', 'pcm_s16le',
                                  '-ac', '1', '-ar', '44100', tmp_wav_path])
                signal.signal(signal.SIGALRM, alarm_handler)
                signal.alarm(FFMPEG_TIMEOUT)
                p.wait()
                signal.alarm(0)
            except Exception, e:
                failure("ffmpeg conversion failed ",e)
                return False
            input_path = tmp_wav_path
        tmp_ana_path = '/tmp/analysis_%s' % sound.id
        essentia_dir = os.path.dirname(os.path.abspath(ESSENTIA_EXECUTABLE))
        os.chdir(essentia_dir)
        exec_array = [ESSENTIA_EXECUTABLE, input_path, tmp_ana_path]

        try:
            p = subprocess.Popen(exec_array, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            p_result = p.wait()
            if p_result != 0:
                output_std, output_err = p.communicate()
                failure( "Essentia extractor returned an error (%s) stdout:%s stderr: %s"%(p_result, output_std, output_err))
                return False
        except Exception, e:
            failure("Essentia extractor failed ",e)
            return False

        __create_dir(statistics_path)
        __create_dir(frames_path)
        shutil.move('%s.yaml' % tmp_ana_path, statistics_path)
        shutil.move('%s_frames.json' % tmp_ana_path, frames_path)
        os.remove('%s.json' % tmp_ana_path)
        sound.set_analysis_state('OK')
    except Exception, e:
        failure("Unexpected error in analysis ",e)
        return False
    finally:
        if tmp_conv:
            os.remove(tmp_wav_path)
    return True

def __create_dir(path):
    dir_path = os.path.dirname(os.path.abspath(path))
    if not  os.path.exists(dir_path):
        os.makedirs(dir_path)

########NEW FILE########
__FILENAME__ = extract_info
#!/usr/bin/env python

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

import sys
from processing import stereofy_and_find_info, AudioProcessingException

try:
    for (k,v) in stereofy_and_find_info("/Users/bram/Development/nightingale/sandbox/legacy/stereofy/stereofy", sys.argv[1], '/dev/null').items():
        print k,"->", v
except AudioProcessingException, e:
    print "warning, audio information extraction seems to have failed:", e

########NEW FILE########
__FILENAME__ = freesound_audio_processing
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from datetime import datetime
from django.conf import settings
from utils.audioprocessing.processing import AudioProcessingException
import utils.audioprocessing.processing as audioprocessing
import os, tempfile, gearman, shutil, sys
import logging

logger = logging.getLogger("processing")

def process(sound):

    def write_log(message):
        logger.info("[%d] %i: %s" % (os.getpid(),sound.id,message))
        sys.stdout.write(str(message)+'\n')
        sys.stdout.flush()

    def failure(message, error=None):
        sound.set_processing_state("FA")
        logging_message = "Failed to process sound with id %s\n" % sound.id
        logging_message += "\tmessage: %s\n" % message
        if error:
            logging_message += "\terror: %s\n" % str(error)
        write_log(logging_message)

    def success(message):
        write_log(message)

    def cleanup(files):
        success("cleaning up files after processing: " + ", ".join(files))
        for filename in files:
            try:
                os.unlink(filename)
            except:
                pass

    # not saving the date of the processing attempt anymore
    sound.set_processing_state("PR")

    new_path = sound.locations('path')
    # Is the file at its new location?
    if not os.path.exists(new_path):
        # Is the file at its old location?
        if not sound.original_path or not os.path.exists(sound.original_path):
            failure("The file to be processed can't be found at its FS1 nor at its FS2 location.")
            return False
        else:
            success("Found the file at its FS1 location: %s" % sound.original_path)
            if not sound.original_path.startswith('/mnt/freesound-data/'):
                failure("The file appears to be in a weird location and not in '/mnt/freesound-data/'!.")
                return False
            success("Copying file from %s to %s" % (sound.original_path, new_path))
            dest_dir = os.path.dirname(new_path)
            if not os.path.exists(dest_dir):
                try:
                    os.makedirs(dest_dir)
                except:
                    failure("Could not create destination directory %s" % dest_dir)
                    return False
            shutil.copy(sound.original_path, new_path)
            sound.set_original_path(new_path)
            success("Copied file from its FS1 to FS2 location.")
    else:
        success("Found the file at its FS2 location: %s" % new_path)
        if sound.original_path != new_path:
            sound.set_original_path(new_path)

    # convert to pcm
    to_cleanup = []
    tmp_wavefile = tempfile.mktemp(suffix=".wav", prefix=str(sound.id))

    try:
        if not audioprocessing.convert_to_pcm(sound.original_path, tmp_wavefile):
            tmp_wavefile = sound.original_path
            success("no need to convert, this file is already pcm data")
        else:
            to_cleanup.append(tmp_wavefile)
            success("converted to pcm: " + tmp_wavefile)
    except AudioProcessingException, e:
        failure("conversion to pcm has failed, trying ffmpeg", e)
        try:
            audioprocessing.convert_using_ffmpeg(sound.original_path, tmp_wavefile)
            to_cleanup.append(tmp_wavefile)
            success("converted to pcm: " + tmp_wavefile)
        except AudioProcessingException, e:
            failure("conversion to pcm with ffmpeg failed", e)
            return False
    except Exception, e:
        failure("unhandled exception", e)
        cleanup(to_cleanup)
        return False

    tmp_wavefile2 = tempfile.mktemp(suffix=".wav", prefix=str(sound.id))

    try:
        info = audioprocessing.stereofy_and_find_info(settings.STEREOFY_PATH, tmp_wavefile, tmp_wavefile2)
        to_cleanup.append(tmp_wavefile2)
    except AudioProcessingException, e:
        failure("stereofy has failed, trying ffmpeg first", e)
        try:
            audioprocessing.convert_using_ffmpeg(sound.original_path, tmp_wavefile)
            info = audioprocessing.stereofy_and_find_info(settings.STEREOFY_PATH, tmp_wavefile, tmp_wavefile2)
            #if tmp_wavefile not in to_cleanup: to_cleanup.append(tmp_wavefile)
            to_cleanup.append(tmp_wavefile2)
        except AudioProcessingException, e:
            failure("ffmpeg + stereofy failed", e)
            cleanup(to_cleanup)
            return False
    except Exception, e:
        failure("unhandled exception", e)
        cleanup(to_cleanup)
        return False

    success("got sound info and stereofied: " + tmp_wavefile2)
    if sound.type in ["mp3","ogg"]:
        info['bitdepth']=0 # mp3 and ogg don't have bitdepth
    sound.set_audio_info_fields(info)

    for mp3_path, quality in [(sound.locations("preview.LQ.mp3.path"),70), (sound.locations("preview.HQ.mp3.path"), 192)]:
        # create preview
        try:
            os.makedirs(os.path.dirname(mp3_path))
        except OSError:
            pass

        try:
            audioprocessing.convert_to_mp3(tmp_wavefile2, mp3_path, quality)
        except AudioProcessingException, e:
            cleanup(to_cleanup)
            failure("conversion to mp3 (preview) has failed", e)
            return False
        except Exception, e:
            failure("unhandled exception", e)
            cleanup(to_cleanup)
            return False
        success("created mp3: " + mp3_path)

    for ogg_path, quality in [(sound.locations("preview.LQ.ogg.path"),1), (sound.locations("preview.HQ.ogg.path"), 6)]:
        # create preview
        try:
            os.makedirs(os.path.dirname(ogg_path))
        except OSError:
            pass

        try:
            audioprocessing.convert_to_ogg(tmp_wavefile2, ogg_path, quality)
        except AudioProcessingException, e:
            cleanup(to_cleanup)
            failure("conversion to ogg (preview) has failed", e)
            return False
        except Exception, e:
            failure("unhandled exception", e)
            cleanup(to_cleanup)
            return False
        success("created ogg: " + ogg_path)

    # create waveform images M
    waveform_path_m = sound.locations("display.wave.M.path")
    spectral_path_m = sound.locations("display.spectral.M.path")

    try:
        os.makedirs(os.path.dirname(waveform_path_m))
    except OSError:
        pass

    try:
        audioprocessing.create_wave_images(tmp_wavefile2, waveform_path_m, spectral_path_m, 120, 71, 2048)
    except AudioProcessingException, e:
        cleanup(to_cleanup)
        failure("creation of images (M) has failed", e)
        return False
    except Exception, e:
        failure("unhandled exception", e)
        cleanup(to_cleanup)
        return False
    success("created previews, medium")

    # create waveform images L
    waveform_path_l = sound.locations("display.wave.L.path")
    spectral_path_l = sound.locations("display.spectral.L.path")
    try:
        audioprocessing.create_wave_images(tmp_wavefile2, waveform_path_l, spectral_path_l, 900, 201, 2048)
    except AudioProcessingException, e:
        cleanup(to_cleanup)
        failure("creation of images (L) has failed", e)
        return False
    except Exception, e:
        failure("unhandled exception", e)
        cleanup(to_cleanup)
        return False
    success("created previews, large")

    cleanup(to_cleanup)
    sound.set_processing_state("OK")

    return True

########NEW FILE########
__FILENAME__ = processing
#!/usr/bin/env python

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from PIL import Image, ImageDraw, ImageColor #@UnresolvedImport
from functools import partial
import math
import numpy
import os
import re
import signal
from . import get_sound_type

try:
    import scikits.audiolab as audiolab
except ImportError:
    print "WARNING: audiolab is not installed so wav2png will not work"
import subprocess

class AudioProcessingException(Exception):
    pass

class TestAudioFile(object):
    """A class that mimics audiolab.sndfile but generates noise instead of reading
    a wave file. Additionally it can be told to have a "broken" header and thus crashing
    in the middle of the file. Also useful for testing ultra-short files of 20 samples."""
    def __init__(self, num_frames, has_broken_header=False):
        self.seekpoint = 0
        self.nframes = num_frames
        self.samplerate = 44100
        self.channels = 1
        self.has_broken_header = has_broken_header

    def seek(self, seekpoint):
        self.seekpoint = seekpoint

    def read_frames(self, frames_to_read):
        if self.has_broken_header and self.seekpoint + frames_to_read > self.num_frames / 2:
            raise RuntimeError()

        num_frames_left = self.num_frames - self.seekpoint
        will_read = num_frames_left if num_frames_left < frames_to_read else frames_to_read
        self.seekpoint += will_read
        return numpy.random.random(will_read)*2 - 1


def get_max_level(filename):
    max_value = 0
    buffer_size = 4096
    audio_file = audiolab.Sndfile(filename, 'r')
    n_samples_left = audio_file.nframes

    while n_samples_left:
        to_read = min(buffer_size, n_samples_left)

        try:
            samples = audio_file.read_frames(to_read)
        except RuntimeError:
            # this can happen with a broken header
            break

        # convert to mono by selecting left channel only
        if audio_file.channels > 1:
            samples = samples[:,0]

        max_value = max(max_value, numpy.abs(samples).max())

        n_samples_left -= to_read

    audio_file.close()

    return max_value

class AudioProcessor(object):
    """
    The audio processor processes chunks of audio an calculates the spectrac centroid and the peak
    samples in that chunk of audio.
    """
    def __init__(self, input_filename, fft_size, window_function=numpy.hanning):
        max_level = get_max_level(input_filename)

        self.audio_file = audiolab.Sndfile(input_filename, 'r')
        self.fft_size = fft_size
        self.window = window_function(self.fft_size)
        self.spectrum_range = None
        self.lower = 100
        self.higher = 22050
        self.lower_log = math.log10(self.lower)
        self.higher_log = math.log10(self.higher)
        self.clip = lambda val, low, high: min(high, max(low, val))

        # figure out what the maximum value is for an FFT doing the FFT of a DC signal
        fft = numpy.fft.rfft(numpy.ones(fft_size) * self.window)
        max_fft = (numpy.abs(fft)).max()
        # set the scale to normalized audio and normalized FFT
        self.scale = 1.0/max_level/max_fft if max_level > 0 else 1

    def read(self, start, size, resize_if_less=False):
        """ read size samples starting at start, if resize_if_less is True and less than size
        samples are read, resize the array to size and fill with zeros """

        # number of zeros to add to start and end of the buffer
        add_to_start = 0
        add_to_end = 0

        if start < 0:
            # the first FFT window starts centered around zero
            if size + start <= 0:
                return numpy.zeros(size) if resize_if_less else numpy.array([])
            else:
                self.audio_file.seek(0)

                add_to_start = -start # remember: start is negative!
                to_read = size + start

                if to_read > self.audio_file.nframes:
                    add_to_end = to_read - self.audio_file.nframes
                    to_read = self.audio_file.nframes
        else:
            self.audio_file.seek(start)

            to_read = size
            if start + to_read >= self.audio_file.nframes:
                to_read = self.audio_file.nframes - start
                add_to_end = size - to_read

        try:
            samples = self.audio_file.read_frames(to_read)
        except RuntimeError:
            # this can happen for wave files with broken headers...
            return numpy.zeros(size) if resize_if_less else numpy.zeros(2)

        # convert to mono by selecting left channel only
        if self.audio_file.channels > 1:
            samples = samples[:,0]

        if resize_if_less and (add_to_start > 0 or add_to_end > 0):
            if add_to_start > 0:
                samples = numpy.concatenate((numpy.zeros(add_to_start), samples), axis=1)

            if add_to_end > 0:
                samples = numpy.resize(samples, size)
                samples[size - add_to_end:] = 0

        return samples


    def spectral_centroid(self, seek_point, spec_range=110.0):
        """ starting at seek_point read fft_size samples, and calculate the spectral centroid """

        samples = self.read(seek_point - self.fft_size/2, self.fft_size, True)

        samples *= self.window
        fft = numpy.fft.rfft(samples)
        spectrum = self.scale * numpy.abs(fft) # normalized abs(FFT) between 0 and 1
        length = numpy.float64(spectrum.shape[0])

        # scale the db spectrum from [- spec_range db ... 0 db] > [0..1]
        db_spectrum = ((20*(numpy.log10(spectrum + 1e-60))).clip(-spec_range, 0.0) + spec_range)/spec_range

        energy = spectrum.sum()
        spectral_centroid = 0

        if energy > 1e-60:
            # calculate the spectral centroid

            if self.spectrum_range == None:
                self.spectrum_range = numpy.arange(length)

            spectral_centroid = (spectrum * self.spectrum_range).sum() / (energy * (length - 1)) * self.audio_file.samplerate * 0.5

            # clip > log10 > scale between 0 and 1
            spectral_centroid = (math.log10(self.clip(spectral_centroid, self.lower, self.higher)) - self.lower_log) / (self.higher_log - self.lower_log)

        return (spectral_centroid, db_spectrum)


    def peaks(self, start_seek, end_seek):
        """ read all samples between start_seek and end_seek, then find the minimum and maximum peak
        in that range. Returns that pair in the order they were found. So if min was found first,
        it returns (min, max) else the other way around. """

        # larger blocksizes are faster but take more mem...
        # Aha, Watson, a clue, a tradeof!
        block_size = 4096

        max_index = -1
        max_value = -1
        min_index = -1
        min_value = 1

        if start_seek < 0:
            start_seek = 0

        if end_seek > self.audio_file.nframes:
            end_seek = self.audio_file.nframes

        if end_seek <= start_seek:
            samples = self.read(start_seek, 1)
            return (samples[0], samples[0])

        if block_size > end_seek - start_seek:
            block_size = end_seek - start_seek

        for i in range(start_seek, end_seek, block_size):
            samples = self.read(i, block_size)

            local_max_index = numpy.argmax(samples)
            local_max_value = samples[local_max_index]

            if local_max_value > max_value:
                max_value = local_max_value
                max_index = local_max_index

            local_min_index = numpy.argmin(samples)
            local_min_value = samples[local_min_index]

            if local_min_value < min_value:
                min_value = local_min_value
                min_index = local_min_index

        return (min_value, max_value) if min_index < max_index else (max_value, min_value)


def interpolate_colors(colors, flat=False, num_colors=256):
    """ given a list of colors, create a larger list of colors interpolating
    the first one. If flatten is True a list of numers will be returned. If
    False, a list of (r,g,b) tuples. num_colors is the number of colors wanted
    in the final list """

    palette = []

    for i in range(num_colors):
        index = (i * (len(colors) - 1))/(num_colors - 1.0)
        index_int = int(index)
        alpha = index - float(index_int)

        if alpha > 0:
            r = (1.0 - alpha) * colors[index_int][0] + alpha * colors[index_int + 1][0]
            g = (1.0 - alpha) * colors[index_int][1] + alpha * colors[index_int + 1][1]
            b = (1.0 - alpha) * colors[index_int][2] + alpha * colors[index_int + 1][2]
        else:
            r = (1.0 - alpha) * colors[index_int][0]
            g = (1.0 - alpha) * colors[index_int][1]
            b = (1.0 - alpha) * colors[index_int][2]

        if flat:
            palette.extend((int(r), int(g), int(b)))
        else:
            palette.append((int(r), int(g), int(b)))

    return palette


def desaturate(rgb, amount):
    """
        desaturate colors by amount
        amount == 0, no change
        amount == 1, grey
    """
    luminosity = sum(rgb) / 3.0
    desat = lambda color: color - amount * (color - luminosity)

    return tuple(map(int, map(desat, rgb)))


class WaveformImage(object):
    """
    Given peaks and spectral centroids from the AudioProcessor, this class will construct
    a wavefile image which can be saved as PNG.
    """
    def __init__(self, image_width, image_height, palette=1):
        if image_height % 2 == 0:
            raise AudioProcessingException, "Height should be uneven: images look much better at uneven height"

        if palette == 1:
            background_color = (0,0,0)
            colors = [
                        (50,0,200),
                        (0,220,80),
                        (255,224,0),
                        (255,70,0),
                     ]
        elif palette == 2:
            background_color = (0,0,0)
            colors = [self.color_from_value(value/29.0) for value in range(0,30)]
        elif palette == 3:
            background_color = (213, 217, 221)
            colors = map( partial(desaturate, amount=0.7), [
                        (50,0,200),
                        (0,220,80),
                        (255,224,0),
                     ])
        elif palette == 4:
            background_color = (213, 217, 221)
            colors = map( partial(desaturate, amount=0.8), [self.color_from_value(value/29.0) for value in range(0,30)])

        self.image = Image.new("RGB", (image_width, image_height), background_color)

        self.image_width = image_width
        self.image_height = image_height

        self.draw = ImageDraw.Draw(self.image)
        self.previous_x, self.previous_y = None, None

        self.color_lookup = interpolate_colors(colors)
        self.pix = self.image.load()

    def color_from_value(self, value):
        """ given a value between 0 and 1, return an (r,g,b) tuple """

        return ImageColor.getrgb("hsl(%d,%d%%,%d%%)" % (int( (1.0 - value) * 360 ), 80, 50))

    def draw_peaks(self, x, peaks, spectral_centroid):
        """ draw 2 peaks at x using the spectral_centroid for color """

        y1 = self.image_height * 0.5 - peaks[0] * (self.image_height - 4) * 0.5
        y2 = self.image_height * 0.5 - peaks[1] * (self.image_height - 4) * 0.5

        line_color = self.color_lookup[int(spectral_centroid*255.0)]

        if self.previous_y != None:
            self.draw.line([self.previous_x, self.previous_y, x, y1, x, y2], line_color)
        else:
            self.draw.line([x, y1, x, y2], line_color)

        self.previous_x, self.previous_y = x, y2

        self.draw_anti_aliased_pixels(x, y1, y2, line_color)

    def draw_anti_aliased_pixels(self, x, y1, y2, color):
        """ vertical anti-aliasing at y1 and y2 """

        y_max = max(y1, y2)
        y_max_int = int(y_max)
        alpha = y_max - y_max_int

        if alpha > 0.0 and alpha < 1.0 and y_max_int + 1 < self.image_height:
            current_pix = self.pix[x, y_max_int + 1]

            r = int((1-alpha)*current_pix[0] + alpha*color[0])
            g = int((1-alpha)*current_pix[1] + alpha*color[1])
            b = int((1-alpha)*current_pix[2] + alpha*color[2])

            self.pix[x, y_max_int + 1] = (r,g,b)

        y_min = min(y1, y2)
        y_min_int = int(y_min)
        alpha = 1.0 - (y_min - y_min_int)

        if alpha > 0.0 and alpha < 1.0 and y_min_int - 1 >= 0:
            current_pix = self.pix[x, y_min_int - 1]

            r = int((1-alpha)*current_pix[0] + alpha*color[0])
            g = int((1-alpha)*current_pix[1] + alpha*color[1])
            b = int((1-alpha)*current_pix[2] + alpha*color[2])

            self.pix[x, y_min_int - 1] = (r,g,b)

    def save(self, filename):
        # draw a zero "zero" line
        a = 25
        for x in range(self.image_width):
            self.pix[x, self.image_height/2] = tuple(map(lambda p: p+a, self.pix[x, self.image_height/2]))

        self.image.save(filename)


class SpectrogramImage(object):
    """
    Given spectra from the AudioProcessor, this class will construct a wavefile image which
    can be saved as PNG.
    """
    def __init__(self, image_width, image_height, fft_size):
        self.image_width = image_width
        self.image_height = image_height
        self.fft_size = fft_size

        self.image = Image.new("RGB", (image_height, image_width))

        colors = [
            (0, 0, 0),
            (58/4,68/4,65/4),
            (80/2,100/2,153/2),
            (90,180,100),
            (224,224,44),
            (255,60,30),
            (255,255,255)
         ]
        self.palette = interpolate_colors(colors)

        # generate the lookup which translates y-coordinate to fft-bin
        self.y_to_bin = []
        f_min = 100.0
        f_max = 22050.0
        y_min = math.log10(f_min)
        y_max = math.log10(f_max)
        for y in range(self.image_height):
            freq = math.pow(10.0, y_min + y / (image_height - 1.0) *(y_max - y_min))
            bin = freq / 22050.0 * (self.fft_size/2 + 1)

            if bin < self.fft_size/2:
                alpha = bin - int(bin)

                self.y_to_bin.append((int(bin), alpha * 255))

        # this is a bit strange, but using image.load()[x,y] = ... is
        # a lot slower than using image.putadata and then rotating the image
        # so we store all the pixels in an array and then create the image when saving
        self.pixels = []

    def draw_spectrum(self, x, spectrum):
        # for all frequencies, draw the pixels
        for (index, alpha) in self.y_to_bin:
            self.pixels.append( self.palette[int((255.0-alpha) * spectrum[index] + alpha * spectrum[index + 1])] )

        # if the FFT is too small to fill up the image, fill with black to the top
        for y in range(len(self.y_to_bin), self.image_height): #@UnusedVariable
            self.pixels.append(self.palette[0])

    def save(self, filename, quality=80):
        assert filename.lower().endswith(".jpg")
        self.image.putdata(self.pixels)
        self.image.transpose(Image.ROTATE_90).save(filename, quality=quality)


def create_wave_images(input_filename, output_filename_w, output_filename_s, image_width, image_height, fft_size, progress_callback=None):
    """
    Utility function for creating both wavefile and spectrum images from an audio input file.
    """
    processor = AudioProcessor(input_filename, fft_size, numpy.hanning)
    samples_per_pixel = processor.audio_file.nframes / float(image_width)

    waveform = WaveformImage(image_width, image_height)
    spectrogram = SpectrogramImage(image_width, image_height, fft_size)

    for x in range(image_width):

        if progress_callback and x % (image_width/10) == 0:
            progress_callback((x*100)/image_width)

        seek_point = int(x * samples_per_pixel)
        next_seek_point = int((x + 1) * samples_per_pixel)

        (spectral_centroid, db_spectrum) = processor.spectral_centroid(seek_point)
        peaks = processor.peaks(seek_point, next_seek_point)

        waveform.draw_peaks(x, peaks, spectral_centroid)
        spectrogram.draw_spectrum(x, db_spectrum)

    if progress_callback:
        progress_callback(100)

    waveform.save(output_filename_w)
    spectrogram.save(output_filename_s)


class NoSpaceLeftException(Exception):
    pass

def convert_to_pcm(input_filename, output_filename):
    """
    converts any audio file type to pcm audio
    """

    if not os.path.exists(input_filename):
        raise AudioProcessingException, "file %s does not exist" % input_filename

    sound_type = get_sound_type(input_filename)

    if sound_type == "mp3":
        cmd = ["lame", "--decode", input_filename, output_filename]
    elif sound_type == "ogg":
        cmd = ["oggdec", input_filename, "-o", output_filename]
    elif sound_type == "flac":
        cmd = ["flac", "-f", "-d", "-s", "-o", output_filename, input_filename]
    else:
        return False

    process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    (stdout, stderr) = process.communicate()

    if process.returncode != 0 or not os.path.exists(output_filename):
        if "No space left on device" in stderr + " " + stdout:
            raise NoSpaceLeftException
        raise AudioProcessingException, "failed converting to pcm data:\n" + " ".join(cmd) + "\n" + stderr + "\n" + stdout

    return True


def stereofy_and_find_info(stereofy_executble_path, input_filename, output_filename):
    """
    converts a pcm wave file to two channel, 16 bit integer
    """

    if not os.path.exists(input_filename):
        raise AudioProcessingException, "file %s does not exist" % input_filename

    cmd = [stereofy_executble_path, "--input", input_filename, "--output", output_filename]

    process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    (stdout, stderr) = process.communicate()

    if process.returncode != 0 or not os.path.exists(output_filename):
        if "No space left on device" in stderr + " " + stdout:
            raise NoSpaceLeftException
        raise AudioProcessingException, "failed calling stereofy data:\n" + " ".join(cmd) + "\n" + stderr + "\n" + stdout

    stdout = (stdout + " " + stderr).replace("\n", " ")

    duration = 0
    m = re.match(r".*#duration (?P<duration>[\d\.]+).*",  stdout)
    if m != None:
        duration = float(m.group("duration"))

    channels = 0
    m = re.match(r".*#channels (?P<channels>\d+).*", stdout)
    if m != None:
        channels = float(m.group("channels"))

    samplerate = 0
    m = re.match(r".*#samplerate (?P<samplerate>\d+).*", stdout)
    if m != None:
        samplerate = float(m.group("samplerate"))

    bitdepth = None
    m = re.match(r".*#bitdepth (?P<bitdepth>\d+).*", stdout)
    if m != None:
        bitdepth = float(m.group("bitdepth"))

    bitrate = (os.path.getsize(input_filename) * 8.0) / 1024.0 / duration if duration > 0 else 0

    return dict(duration=duration, channels=channels, samplerate=samplerate, bitrate=bitrate, bitdepth=bitdepth)


def convert_to_mp3(input_filename, output_filename, quality=70):
    """
    converts the incoming wave file to a mp3 file
    """

    if not os.path.exists(input_filename):
        raise AudioProcessingException, "file %s does not exist" % input_filename

    command = ["lame", "--silent", "--abr", str(quality), input_filename, output_filename]

    process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    (stdout, stderr) = process.communicate()

    if process.returncode != 0 or not os.path.exists(output_filename):
        raise AudioProcessingException, stdout

def convert_to_ogg(input_filename, output_filename, quality=1):
    """
    converts the incoming wave file to n ogg file
    """

    if not os.path.exists(input_filename):
        raise AudioProcessingException, "file %s does not exist" % input_filename

    command = ["oggenc", "-q", str(quality), input_filename, "-o", output_filename]

    process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    (stdout, stderr) = process.communicate()

    if process.returncode != 0 or not os.path.exists(output_filename):
        raise AudioProcessingException, stdout

def convert_using_ffmpeg(input_filename, output_filename):
    """
    converts the incoming wave file to stereo pcm using fffmpeg
    """
    TIMEOUT = 3 * 60
    def  alarm_handler(signum, frame):
        raise AudioProcessingException, "timeout while waiting for ffmpeg"

    if not os.path.exists(input_filename):
        raise AudioProcessingException, "file %s does not exist" % input_filename

    command = ["ffmpeg", "-y", "-i", input_filename, "-ac","1","-acodec", "pcm_s16le", "-ar", "44100", output_filename]

    process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    signal.signal(signal.SIGALRM,alarm_handler)
    signal.alarm(TIMEOUT)
    (stdout, stderr) = process.communicate()
    signal.alarm(0)
    if process.returncode != 0 or not os.path.exists(output_filename):
        raise AudioProcessingException, stdout

########NEW FILE########
__FILENAME__ = wav2png
#!/usr/bin/env python

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from processing import create_wave_images, AudioProcessingException
import optparse
import sys

parser = optparse.OptionParser("usage: %prog [options] input-filename", conflict_handler="resolve")
parser.add_option("-a", "--waveout", action="store", dest="output_filename_w", type="string", help="output waveform image (default input filename + _w.png)")
parser.add_option("-s", "--specout", action="store", dest="output_filename_s", type="string", help="output spectrogram image (default input filename + _s.jpg)")
parser.add_option("-w", "--width", action="store", dest="image_width", type="int", help="image width in pixels (default %default)")
parser.add_option("-h", "--height", action="store", dest="image_height", type="int", help="image height in pixels (default %default)")
parser.add_option("-f", "--fft", action="store", dest="fft_size", type="int", help="fft size, power of 2 for increased performance (default %default)")
parser.add_option("-p", "--profile", action="store_true", dest="profile", help="run profiler and output profiling information")

parser.set_defaults(output_filename_w=None, output_filename_s=None, image_width=500, image_height=171, fft_size=2048)

(options, args) = parser.parse_args()

if len(args) == 0:
    parser.print_help()
    parser.error("not enough arguments")
   
    if len(args) > 1 and (options.output_filename_w != None or options.output_filename_s != None):
        parser.error("when processing multiple files you can't define the output filename!")
 
def progress_callback(percentage):
    sys.stdout.write(str(percentage) + "% ")
    sys.stdout.flush()
   
    # process all files so the user can use wildcards like *.wav
for input_file in args:
    
    output_file_w = options.output_filename_w or input_file + "_w.png"
    output_file_s = options.output_filename_s or input_file + "_s.jpg"
    
    args = (input_file, output_file_w, output_file_s, options.image_width, options.image_height, options.fft_size, progress_callback)

    print "processing file %s:\n\t" % input_file,

    if not options.profile:
        try:
            create_wave_images(*args)
        except AudioProcessingException, e:
            print "Error running wav2png: ", e
    else:
        from hotshot import stats
        import hotshot

        prof = hotshot.Profile("stats")
        prof.runcall(create_wave_images, *args)
        prof.close()
        
        print "\n---------- profiling information ----------\n"
        s = stats.load("stats")
        s.strip_dirs()
        s.sort_stats("time")
        s.print_stats(30)
    
    print
########NEW FILE########
__FILENAME__ = cache
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.core.cache import cache
from django.utils.hashcompat import md5_constructor
from django.utils.http import urlquote
from functional import compose

def invalidate_template_cache(fragment_name, *variables):
    args = md5_constructor(u':'.join(map(compose(urlquote, unicode), variables)))
    cache_key = 'template.cache.%s.%s' % (fragment_name, args.hexdigest())
    cache.delete(cache_key) 
########NEW FILE########
__FILENAME__ = defaults
'''
Copyright 2013 Otto Yiu and other contributors
http://ottoyiu.com

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
'''


from django.conf import settings

default_headers = (
    'x-requested-with',
    'content-type',
    'accept',
    'origin',
    'authorization',
    'x-csrftoken',
)
CORS_ALLOW_HEADERS = getattr(settings, 'CORS_ALLOW_HEADERS', default_headers)

default_methods = (
    'GET',
    'POST',
    'PUT',
    'PATCH',
    'DELETE',
    'OPTIONS',
)
CORS_ALLOW_METHODS = getattr(settings, 'CORS_ALLOW_METHODS', default_methods)

CORS_ALLOW_CREDENTIALS = getattr(settings, 'CORS_ALLOW_CREDENTIALS', False)

CORS_PREFLIGHT_MAX_AGE = getattr(settings, 'CORS_PREFLIGHT_MAX_AGE', 86400)

CORS_ORIGIN_ALLOW_ALL = getattr(settings, 'CORS_ORIGIN_ALLOW_ALL', True)

CORS_ORIGIN_WHITELIST = getattr(settings, 'CORS_ORIGIN_WHITELIST', ())

CORS_ORIGIN_REGEX_WHITELIST = getattr(settings, 'CORS_ORIGIN_REGEX_WHITELIST', ())

CORS_EXPOSE_HEADERS = getattr(settings, 'CORS_EXPOSE_HEADERS', ())

CORS_URLS_REGEX = getattr(settings, 'CORS_URLS_REGEX', '^.*$')

########NEW FILE########
__FILENAME__ = middleware
'''
Copyright 2013 Otto Yiu and other contributors
http://ottoyiu.com

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
'''


import re
from django import http
try:
    from urlparse import urlparse
except ImportError:
    from urllib.parse import urlparse

from utils.corsheaders import defaults as settings


ACCESS_CONTROL_ALLOW_ORIGIN = 'Access-Control-Allow-Origin'
ACCESS_CONTROL_EXPOSE_HEADERS = 'Access-Control-Expose-Headers'
ACCESS_CONTROL_ALLOW_CREDENTIALS = 'Access-Control-Allow-Credentials'
ACCESS_CONTROL_ALLOW_HEADERS = 'Access-Control-Allow-Headers'
ACCESS_CONTROL_ALLOW_METHODS = 'Access-Control-Allow-Methods'
ACCESS_CONTROL_MAX_AGE = 'Access-Control-Max-Age'


class CorsMiddleware(object):

    def process_request(self, request):
        '''
            If CORS preflight header, then create an empty body response (200 OK) and return it

            Django won't bother calling any other request view/exception middleware along with
            the requested view; it will call any response middlewares
        '''
        if (self.is_enabled(request) and
            request.method == 'OPTIONS' and
            'HTTP_ACCESS_CONTROL_REQUEST_METHOD' in request.META):
            response = http.HttpResponse()
            return response
        return None

    def process_response(self, request, response):
        '''
            Add the respective CORS headers
        '''
        origin = request.META.get('HTTP_ORIGIN')
        if self.is_enabled(request) and origin:
            # todo: check hostname from db instead
            url = urlparse(origin)

            if not settings.CORS_ORIGIN_ALLOW_ALL and self.origin_not_found_in_white_lists(origin, url):
                return response

            response[ACCESS_CONTROL_ALLOW_ORIGIN] = "*" if settings.CORS_ORIGIN_ALLOW_ALL else origin

            if len(settings.CORS_EXPOSE_HEADERS):
                response[ACCESS_CONTROL_EXPOSE_HEADERS] = ', '.join(settings.CORS_EXPOSE_HEADERS)

            if settings.CORS_ALLOW_CREDENTIALS:
                response[ACCESS_CONTROL_ALLOW_CREDENTIALS] = 'true'

            if request.method == 'OPTIONS':
                response[ACCESS_CONTROL_ALLOW_HEADERS] = ', '.join(settings.CORS_ALLOW_HEADERS)
                response[ACCESS_CONTROL_ALLOW_METHODS] = ', '.join(settings.CORS_ALLOW_METHODS)
                if settings.CORS_PREFLIGHT_MAX_AGE:
                    response[ACCESS_CONTROL_MAX_AGE] = settings.CORS_PREFLIGHT_MAX_AGE

        return response

    def origin_not_found_in_white_lists(self, origin, url):
        return url.netloc not in settings.CORS_ORIGIN_WHITELIST and not self.regex_domain_match(origin)

    def regex_domain_match(self, origin):
        for domain_pattern in settings.CORS_ORIGIN_REGEX_WHITELIST:
            if re.match(domain_pattern, origin):
                return origin

    def is_enabled(self, request):
        return re.match(settings.CORS_URLS_REGEX, request.path)

########NEW FILE########
__FILENAME__ = dbtime
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from sounds.models import Sound
from django.core.cache import cache
from django.conf import settings
from datetime import datetime

class DBTime():
    last_time = None

    @staticmethod
    def get_last_time():
	if not settings.DEBUG:
	    return datetime.now() 
	if DBTime.last_time is None:
            cache_key = "last_download_time"
            last_time = cache.get(cache_key)
            if not last_time:
		try:
		    last_time = Sound.objects.order_by('-created')[0].created
		except Download.DoesNotExist:
		    last_time = datetime.now()
	    cache.set(cache_key, DBTime.last_time, 60*60*24)
            DBTime.last_time = last_time
	return DBTime.last_time

########NEW FILE########
__FILENAME__ = encryption
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.conf import settings

def encrypt(decrypted_string):
    from Crypto.Cipher import AES
    import base64
    import urllib
    
    encryptor = AES.new(settings.SECRET_KEY[0:16]) #@UndefinedVariable
    
    # encrypted strings need to be len() = multiple of 16
    decrypted_string += u' ' * ( 16 - len(decrypted_string) % 16 )

    encrypted_string = encryptor.encrypt(decrypted_string)
    
    # base64 encoded strings have "=" signs, quote them!
    encoded_string = urllib.quote(base64.b64encode(encrypted_string).replace("/", ".").replace("+", "_").replace("=", "-"))
    
    return encoded_string

def decrypt(quoted_string):
    from Crypto.Cipher import AES
    import base64
    import urllib

    decryptor = AES.new(settings.SECRET_KEY[0:16]) #@UndefinedVariable
    
    encoded_string = urllib.unquote(quoted_string)
    
    encrypted_string = base64.b64decode(encoded_string.replace(".", "/").replace("_", "+").replace("-", "="))
    
    decrypted_string = decryptor.decrypt(encrypted_string).strip()
    
    return decrypted_string 

def create_hash(data):
    import hashlib
    m = hashlib.md5()
    m.update(str(data) + settings.SECRET_KEY)
    return m.hexdigest()[0:8]
########NEW FILE########
__FILENAME__ = filesystem
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

import md5, os, zlib

class File:

    def __init__(self, id, name, full_path, is_dir):
        self.name = name
        self.full_path = full_path
        self.is_dir = is_dir
        self.children = [] if is_dir else None
        self.id = "file%d" % id

    def recursive_print(self, spacer=""):
        print spacer + self.name
        if self.is_dir:
            for child in self.children:
                child.recursive_print(spacer + "  ")

    #def __unicode__(self):
    #    return u'<File %s>' % self.full_path

def generate_tree(path):
    counter = 0
    lookups = {path: File(counter, path, path, True)}
    files = {}

    for (root, dirnames, filenames) in os.walk(path):
        parent = lookups[root]
        for dirname in sorted(dirnames):
            full_path = os.path.join(root, dirname)
            file_object = File(counter, dirname, full_path, True)
            counter += 1
            lookups[full_path] = file_object
            parent.children.append(file_object)

        for filename in sorted(filenames):
            full_path = os.path.join(root, filename)
            file_object = File(counter, filename, full_path, False)
            counter += 1
            files[file_object.id] = file_object
            parent.children.append(file_object)
            
    return lookups[path], files

def md5file(filename):
    """Return the hex digest of a file without loading it all into memory"""
    fh = open(filename, "rb")
    digest = md5.new()
    while 1:
        buf = fh.read(4096)
        if buf == "":
            break
        digest.update(buf)
    fh.close()
    return digest.hexdigest()

def crc32file(filename):
    fh = open(filename, "rb")
    crc32 = 0
    while 1:
        buf = fh.read(4096)
        if buf == "":
            break
        crc32 = zlib.crc32(buf, crc32)
    fh.close()
    return hex(crc32)[2:]

def delete_object_files(obj, logger=False):
    """Given a Django ORM object and a dictionary, delete its associated files on disk."""
    __delete_object_files(obj, obj.locations(), logger)

def __delete_object_files(obj, d, logger=False):
    """Given a Django ORM object and a dictionary, delete its associated files on disk."""
    if isinstance(d, dict):
        for key, val in d.items():
            if key == 'path':
                try:
                    logger.info('Remove %s for object with id %s of type %s.' % \
                                (val, obj.id, obj.__class__))
                    os.remove(val)
                except Exception, e:
                    if logger:
                        logger.error('Could not remove file %s for object with id %s of type %s. (%s)' % \
                                     (val, obj.id, obj.__class__, e))
            else:
                __delete_object_files(obj, val, logger)

########NEW FILE########
__FILENAME__ = forms
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django import forms
from utils.text import clean_html, is_shouting
from django.conf import settings
from recaptcha.client import captcha
from utils.tags import clean_and_split_tags
from HTMLParser import HTMLParseError

class HtmlCleaningCharField(forms.CharField):
    def clean(self, value):
        value = super(HtmlCleaningCharField, self).clean(value)

        if is_shouting(value):
            raise forms.ValidationError('Please moderate the amount of upper case characters in your post...')
        try:
            return clean_html(value)
        except HTMLParseError:
            raise forms.ValidationError('The text you submitted is badly formed HTML, please fix it')


class TagField(forms.CharField):
    def clean(self, value):
        tags = clean_and_split_tags(value)

        if len(tags) < 3:
            raise forms.ValidationError('Your should at least have 3 tags...')
        elif len(tags) > 30:
            raise forms.ValidationError('There can be maximum 30 tags, please select the most relevant ones!')

        return tags


class RecaptchaWidget(forms.Widget):
    """ A Widget which "renders" the output of captcha.displayhtml """
    def render(self, *args, **kwargs):
        if settings.RECAPTCHA_PUBLIC_KEY == '':
            return ''
        return captcha.displayhtml(settings.RECAPTCHA_PUBLIC_KEY).strip()

class RecaptchaWidgetSSL(forms.Widget):
    """ A Widget which "renders" the output of captcha.displayhtml using SSL option"""
    def render(self, *args, **kwargs):
        if settings.RECAPTCHA_PUBLIC_KEY == '':
            return ''
        return captcha.displayhtml(settings.RECAPTCHA_PUBLIC_KEY, use_ssl=True).strip()


class DummyWidget(forms.Widget):
    """
    A dummy Widget class for a placeholder input field which will
    be created by captcha.displayhtml
    """

    # make sure that labels are not displayed either
    is_hidden=True
    def render(self, *args, **kwargs):
        return ''


class RecaptchaForm(forms.Form):
    """
    A form class which uses reCAPTCHA for user validation.
    If the captcha is not guessed correctly, a ValidationError is raised
    for the appropriate field
    """

    captcha_enabled = settings.RECAPTCHA_PUBLIC_KEY != ''

    recaptcha_challenge_field = forms.CharField(widget=DummyWidget, required=captcha_enabled)
    recaptcha_response_field = forms.CharField(widget=RecaptchaWidget, required=captcha_enabled, label="Please prove you are not a robot:")

    if not captcha_enabled:
        recaptcha_response_field.label = ''

    def __init__(self, request, *args, **kwargs):
        if request.using_https:
            # If request is https present https form
            self.base_fields['recaptcha_response_field'].widget = RecaptchaWidgetSSL()

        super(RecaptchaForm, self).__init__(*args, **kwargs)
        self._request = request

        # move the captcha to the bottom of the list of fields
        recaptcha_fields = ['recaptcha_challenge_field', 'recaptcha_response_field']
        self.fields.keyOrder = [key for key in self.fields.keys() if key not in recaptcha_fields] + recaptcha_fields

    def clean_recaptcha_response_field(self):
        if 'recaptcha_challenge_field' in self.cleaned_data:
            self.validate_captcha()
        return self.cleaned_data['recaptcha_response_field']

    def clean_recaptcha_challenge_field(self):
        if 'recaptcha_response_field' in self.cleaned_data:
            self.validate_captcha()
        return self.cleaned_data['recaptcha_challenge_field']

    def validate_captcha(self):
        rcf = self.cleaned_data['recaptcha_challenge_field']
        rrf = self.cleaned_data['recaptcha_response_field']
        ip_address = self._request.META['REMOTE_ADDR']

        # only submit captcha information if it is enabled
        if self.captcha_enabled:
            check = captcha.submit(rcf, rrf, settings.RECAPTCHA_PRIVATE_KEY, ip_address)

            if not check.is_valid:
                raise forms.ValidationError('You have not entered the correct words')
########NEW FILE########
__FILENAME__ = functional
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

import sys

def exceptional(func,alt_return=None,alt_exceptions=(Exception,),final=None,catch=None):
    """turns exceptions into alternative return value"""
    def _exceptional(*args,**kwargs):
        try:
            try: return func(*args,**kwargs)
            except alt_exceptions:
                return alt_return
            except:
                if catch: return catch(sys.exc_info(), lambda:func(*args,**kwargs))
                raise
        finally:
            if final: final()
    return _exceptional

def final(func,final=None,catch=None,alt_exceptions=(),alt_return=None):
    """connects a final call to a function call"""
    def _exceptional(*args,**kwargs):
        try:
            try: return func(*args,**kwargs)
            except alt_exceptions:
                return alt_return
            except:
                if catch: return catch(sys.exc_info(), lambda:func(*args,**kwargs))
                raise
        finally:
            if final: final()
    return _exceptional


def compose(func_1, func_2, unpack=False):
    """
    compose(func_1, func_2, unpack=False) -> function
    
    The function returned by compose is a composition of func_1 and func_2.
    That is, compose(func_1, func_2)(5) == func_1(func_2(5))
    """
    if not callable(func_1):
        raise TypeError("First argument to compose must be callable")
    if not callable(func_2):
        raise TypeError("Second argument to compose must be callable")
    
    if unpack:
        def composition(*args, **kwargs):
            return func_1(*func_2(*args, **kwargs))
    else:
        def composition(*args, **kwargs):
            return func_1(func_2(*args, **kwargs))
    return composition

def first(predicate, itterator):
    for item in itterator:
        if predicate(item):
            return item

def combine_dicts(dict1, dict2):
    return dict(dict1.items() + dict2.items())
########NEW FILE########
__FILENAME__ = images
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from PIL import Image

class ImageProcessingError(Exception):
    pass

def extract_square(input_filename, output_filename, size):
    im = Image.open(input_filename)
    
    if im.mode not in ('L', 'RGB'):
        im = im.convert('RGB')
        
    #fill out and resize the image
    if im.size[0] < size and im.size[1] < size:
        if im.size[0] < im.size[1]:
            ratio = im.size[1] / im.size[0]
            im = im.resize((size / ratio, size), Image.ANTIALIAS)            
        else: 
            ratio = im.size[0] / im.size[1] 
            im = im.resize((size,size / ratio), Image.ANTIALIAS)
        #fill out          
        background = Image.new("RGBA", (size,size), (255, 255, 255, 0)) # use white for empty space  
        background.paste(im, ((size - im.size[0]) / 2, (size - im.size[1]) / 2))  
        background.save(output_filename)
        return
        
    #if one side of the image is smaller and one is bigger
    elif im.size[0] > size and im.size[1] < size:
        ratio = im.size[0] / im.size[1]
        im = im.resize((size * ratio,size), Image.ANTIALIAS)  
                     
    elif im.size[0] < size and im.size[1] > size:  
        ratio = im.size[1] / im.size[0]
        im = im.resize((size, size * ratio), Image.ANTIALIAS)
           
    if im.size[0] > im.size[1]:
        # --------
        # |      |
        # --------
        box = (im.size[0]-im.size[1])/2, 0, im.size[0] - (im.size[0]-im.size[1])/2, im.size[1]
    else: 
        # ____
        # |  |
        # |  |
        # |__|
        box = 0, (im.size[1]-im.size[0])/2, im.size[0], im.size[1] - (im.size[1]-im.size[0])/2 
    
    im = im.crop(box)
    im.thumbnail((size, size), Image.ANTIALIAS)
    im.save(output_filename)

if __name__ == "__main__":
    import sys, os.path
    input_filename = sys.argv[1]
    size = int(sys.argv[2])
    path, ext = os.path.splitext(input_filename)
    output_filename = path + "_t" + ext 
    extract_square(input_filename, output_filename, size)
########NEW FILE########
__FILENAME__ = locations
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

def locations_decorator(cache=True):
    """wraps a locations function and adds two things:
        * caching for the calculation done inside the function if cache is true
        * if the locations function is called with a string, do lookup like in django templates
            i.e. let's say locations() returns {"a": {"b": {"c" : 5}}}, calling
                locations()["a"]["b"]["c"]
            will result in the same as calling:
                locations("a.b.c")
            but is much easier on the typing and easier for copy-pasting
    """
    def decorator(locations_function):
        def wrapped(self, path=None):
            # cache the call to the locations function so it's only calculated once
            if not cache or not hasattr(self, '_locations_cache'):
                self._locations_cache = locations_function(self)

            if path:
                lookup = self._locations_cache
                for piece in path.split("."):
                    lookup = lookup[piece]
                return lookup
            else:
                return self._locations_cache
        return wrapped
    return decorator

def pretty_print_locations(locations, indent=0):
    for (key, value) in locations.iteritems():
        if isinstance(value, dict):
            print "  "*indent, "*", key
            pretty_print_locations(value, indent+1)
        else:
            print "  "*indent, "*", key


if __name__ == "__main__":
    class X(object):
        @locations_decorator()
        def locations(self):
            return dict(a=5)
    x = X()
    print x.locations()
    print x.locations()

########NEW FILE########
__FILENAME__ = mail
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.conf import settings
from django.core.mail import send_mail as core_send_mail
from django.core.mail import send_mass_mail
from django.template.loader import render_to_string

def send_mail(subject, email_body, email_from=None, email_to=[]):
    """ Sends email with a lot of defaults"""
    if not email_from:
        email_from = settings.DEFAULT_FROM_EMAIL
    
    if not email_to:
        email_to = [admin[1] for admin in settings.SUPPORT]
    elif not isinstance(email_to, tuple) and not isinstance(email_to, list):
        email_to = [email_to]

    if settings.ALLOWED_EMAILS:
        email_to = [email for email in email_to if email in settings.ALLOWED_EMAILS]

    try:
        #core_send_mail(settings.EMAIL_SUBJECT_PREFIX + subject, email_body, email_from, email_to, fail_silently=False)
        emails = tuple(( (settings.EMAIL_SUBJECT_PREFIX + subject, email_body, email_from, [email]) for email in email_to ))
        send_mass_mail( emails, fail_silently = False)

        return True
    except:
        return False
    

def send_mail_template(subject, template, context, email_from=None, email_to=[]):
    context["settings"] = settings
    return send_mail(subject, render_to_string(template, context), email_from, email_to)

########NEW FILE########
__FILENAME__ = nginxsendfile
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.http import HttpResponse,Http404
from django.core.servers.basehttp import FileWrapper
from django.conf import settings

import os

def sendfile(path, attachment_name, secret_url = None):
    if not os.path.exists(path):
        raise Http404
    
    if settings.DEBUG:
        response = HttpResponse(FileWrapper(file(path, "rb")))
        response['Content-Length'] = os.path.getsize(path)
    else:
        response = HttpResponse()
        response['X-Accel-Redirect'] = secret_url

    response['Content-Type']="application/octet-stream"
    response['Content-Disposition'] = "attachment; filename=\"%s\"" % attachment_name
    
    return response
########NEW FILE########
__FILENAME__ = onlineusers
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from datetime import timedelta, datetime
from django.core.cache import cache

ONLINE_MINUTES = 10
CACHE_KEY = 'online_user_ids'

_last_purged = datetime.now()

def get_online_users():
    user_dict = cache.get(CACHE_KEY)
    return hasattr(user_dict, 'keys') and user_dict.keys() or []

def cache_online_users(request):
        if request.user.is_anonymous():
            return
        user_dict = cache.get(CACHE_KEY)
        if not user_dict:
            user_dict = {}
        
        now = datetime.now()
        
        # Check if user has marked the option for not being shown in online users list
        if not request.user.profile.not_shown_in_online_users_list :
            user_dict[request.user.id] = now
            
        # purge
        global _last_purged
        if _last_purged + timedelta(minutes=ONLINE_MINUTES) < now:
            purge_older_than = now - timedelta(minutes=ONLINE_MINUTES)
            for user_id, last_seen in user_dict.items():
                if last_seen < purge_older_than:
                    del(user_dict[user_id])
            _last_purged = now

        cache.set(CACHE_KEY, user_dict, 60*60*24)

########NEW FILE########
__FILENAME__ = ordered_dict
# Backport of OrderedDict() class that runs on Python 2.4, 2.5, 2.6, 2.7 and pypy.
# Passes Python2.7's test suite and incorporates all the latest updates.

try:
    from thread import get_ident as _get_ident
except ImportError:
    from dummy_thread import get_ident as _get_ident

try:
    from _abcoll import KeysView, ValuesView, ItemsView
except ImportError:
    pass


class OrderedDict(dict):
    'Dictionary that remembers insertion order'
    # An inherited dict maps keys to values.
    # The inherited dict provides __getitem__, __len__, __contains__, and get.
    # The remaining methods are order-aware.
    # Big-O running times for all methods are the same as for regular dictionaries.

    # The internal self.__map dictionary maps keys to links in a doubly linked list.
    # The circular doubly linked list starts and ends with a sentinel element.
    # The sentinel element never gets deleted (this simplifies the algorithm).
    # Each link is stored as a list of length three:  [PREV, NEXT, KEY].

    def __init__(self, *args, **kwds):
        '''Initialize an ordered dictionary.  Signature is the same as for
        regular dictionaries, but keyword arguments are not recommended
        because their insertion order is arbitrary.

        '''
        if len(args) > 1:
            raise TypeError('expected at most 1 arguments, got %d' % len(args))
        try:
            self.__root
        except AttributeError:
            self.__root = root = []                     # sentinel node
            root[:] = [root, root, None]
            self.__map = {}
        self.__update(*args, **kwds)

    def __setitem__(self, key, value, dict_setitem=dict.__setitem__):
        'od.__setitem__(i, y) <==> od[i]=y'
        # Setting a new item creates a new link which goes at the end of the linked
        # list, and the inherited dictionary is updated with the new key/value pair.
        if key not in self:
            root = self.__root
            last = root[0]
            last[1] = root[0] = self.__map[key] = [last, root, key]
        dict_setitem(self, key, value)

    def __delitem__(self, key, dict_delitem=dict.__delitem__):
        'od.__delitem__(y) <==> del od[y]'
        # Deleting an existing item uses self.__map to find the link which is
        # then removed by updating the links in the predecessor and successor nodes.
        dict_delitem(self, key)
        link_prev, link_next, key = self.__map.pop(key)
        link_prev[1] = link_next
        link_next[0] = link_prev

    def __iter__(self):
        'od.__iter__() <==> iter(od)'
        root = self.__root
        curr = root[1]
        while curr is not root:
            yield curr[2]
            curr = curr[1]

    def __reversed__(self):
        'od.__reversed__() <==> reversed(od)'
        root = self.__root
        curr = root[0]
        while curr is not root:
            yield curr[2]
            curr = curr[0]

    def clear(self):
        'od.clear() -> None.  Remove all items from od.'
        try:
            for node in self.__map.itervalues():
                del node[:]
            root = self.__root
            root[:] = [root, root, None]
            self.__map.clear()
        except AttributeError:
            pass
        dict.clear(self)

    def popitem(self, last=True):
        '''od.popitem() -> (k, v), return and remove a (key, value) pair.
        Pairs are returned in LIFO order if last is true or FIFO order if false.

        '''
        if not self:
            raise KeyError('dictionary is empty')
        root = self.__root
        if last:
            link = root[0]
            link_prev = link[0]
            link_prev[1] = root
            root[0] = link_prev
        else:
            link = root[1]
            link_next = link[1]
            root[1] = link_next
            link_next[0] = root
        key = link[2]
        del self.__map[key]
        value = dict.pop(self, key)
        return key, value

    # -- the following methods do not depend on the internal structure --

    def keys(self):
        'od.keys() -> list of keys in od'
        return list(self)

    def values(self):
        'od.values() -> list of values in od'
        return [self[key] for key in self]

    def items(self):
        'od.items() -> list of (key, value) pairs in od'
        return [(key, self[key]) for key in self]

    def iterkeys(self):
        'od.iterkeys() -> an iterator over the keys in od'
        return iter(self)

    def itervalues(self):
        'od.itervalues -> an iterator over the values in od'
        for k in self:
            yield self[k]

    def iteritems(self):
        'od.iteritems -> an iterator over the (key, value) items in od'
        for k in self:
            yield (k, self[k])

    def update(*args, **kwds):
        '''od.update(E, **F) -> None.  Update od from dict/iterable E and F.

        If E is a dict instance, does:           for k in E: od[k] = E[k]
        If E has a .keys() method, does:         for k in E.keys(): od[k] = E[k]
        Or if E is an iterable of items, does:   for k, v in E: od[k] = v
        In either case, this is followed by:     for k, v in F.items(): od[k] = v

        '''
        if len(args) > 2:
            raise TypeError('update() takes at most 2 positional '
                            'arguments (%d given)' % (len(args),))
        elif not args:
            raise TypeError('update() takes at least 1 argument (0 given)')
        self = args[0]
        # Make progressively weaker assumptions about "other"
        other = ()
        if len(args) == 2:
            other = args[1]
        if isinstance(other, dict):
            for key in other:
                self[key] = other[key]
        elif hasattr(other, 'keys'):
            for key in other.keys():
                self[key] = other[key]
        else:
            for key, value in other:
                self[key] = value
        for key, value in kwds.items():
            self[key] = value

    __update = update  # let subclasses override update without breaking __init__

    __marker = object()

    def pop(self, key, default=__marker):
        '''od.pop(k[,d]) -> v, remove specified key and return the corresponding value.
        If key is not found, d is returned if given, otherwise KeyError is raised.

        '''
        if key in self:
            result = self[key]
            del self[key]
            return result
        if default is self.__marker:
            raise KeyError(key)
        return default

    def setdefault(self, key, default=None):
        'od.setdefault(k[,d]) -> od.get(k,d), also set od[k]=d if k not in od'
        if key in self:
            return self[key]
        self[key] = default
        return default

    def __repr__(self, _repr_running={}):
        'od.__repr__() <==> repr(od)'
        call_key = id(self), _get_ident()
        if call_key in _repr_running:
            return '...'
        _repr_running[call_key] = 1
        try:
            if not self:
                return '%s()' % (self.__class__.__name__,)
            return '%s(%r)' % (self.__class__.__name__, self.items())
        finally:
            del _repr_running[call_key]

    def __reduce__(self):
        'Return state information for pickling'
        items = [[k, self[k]] for k in self]
        inst_dict = vars(self).copy()
        for k in vars(OrderedDict()):
            inst_dict.pop(k, None)
        if inst_dict:
            return (self.__class__, (items,), inst_dict)
        return self.__class__, (items,)

    def copy(self):
        'od.copy() -> a shallow copy of od'
        return self.__class__(self)

    @classmethod
    def fromkeys(cls, iterable, value=None):
        '''OD.fromkeys(S[, v]) -> New ordered dictionary with keys from S
        and values equal to v (which defaults to None).

        '''
        d = cls()
        for key in iterable:
            d[key] = value
        return d

    def __eq__(self, other):
        '''od.__eq__(y) <==> od==y.  Comparison to another OD is order-sensitive
        while comparison to a regular mapping is order-insensitive.

        '''
        if isinstance(other, OrderedDict):
            return len(self)==len(other) and self.items() == other.items()
        return dict.__eq__(self, other)

    def __ne__(self, other):
        return not self == other

    # -- the following methods are only used in Python 2.7 --

    def viewkeys(self):
        "od.viewkeys() -> a set-like object providing a view on od's keys"
        return KeysView(self)

    def viewvalues(self):
        "od.viewvalues() -> an object providing a view on od's values"
        return ValuesView(self)

    def viewitems(self):
        "od.viewitems() -> a set-like object providing a view on od's items"
        return ItemsView(self)
########NEW FILE########
__FILENAME__ = pagination
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.core.paginator import Paginator, InvalidPage
from django.core.cache import cache
import hashlib

# count caching solution from http://timtrueman.com/django-pagination-count-caching/
class CachedCountProxy(object):
    ''' This allows us to monkey-patch count() on QuerySets so we can cache it and speed things up.
    '''

    def __init__(self, queryset):
        self._queryset = queryset
        self._queryset._original_count = self._queryset.count
        self._sql = self._queryset.query.get_compiler(self._queryset.db).as_sql()
        self._sql = self._sql[0] % self._sql[1]

    def __call__(self):
        ''' 1. Check cache
            2. Return cache if it's set
            3. If it's not set, call super and get the count
            4. Cache that for X seconds
        '''
        key = "paginator_count_%s" % hashlib.sha224(self._sql).hexdigest()
        count = cache.get(key)
        if count is None:
            count = self._queryset._original_count()
            cache.set(key, count, 300)
        return count

class CountProvidedPaginator(Paginator):
    """ A django Paginator that takes an optional object_count
        which is the length of object_list. This means that count() or
        len() doesn't have to be called """

    def __init__(self, object_list, per_page, orphans=0, allow_empty_first_page=True, object_count=None):
        Paginator.__init__(self, object_list, per_page, orphans, allow_empty_first_page)
        self._count = object_count


def paginate(request, qs, items_per_page=20, page_get_name='page', cache_count=False, object_count=None):
    # monkeypatch solution to cache the count for performance
    # disabled for now, causes problems on comments.
    if cache_count:
        qs.count = CachedCountProxy(qs)

    paginator = CountProvidedPaginator(qs, items_per_page, object_count=object_count)
    try:
        current_page = int(request.GET.get(page_get_name, 1))
    except ValueError:
        current_page = 1

    try:
        page = paginator.page(current_page)
    except InvalidPage:
        page = paginator.page(1)
        current_page = 1

    return dict(paginator=paginator, current_page=current_page, page=page)

########NEW FILE########
__FILENAME__ = wrapper
# -*- coding: utf-8 -*-

# PayPal python NVP API wrapper class.
# This is a sample to help others get started on working
# with the PayPal NVP API in Python. 
# This is not a complete reference! Be sure to understand
# what this class is doing before you try it on production servers!
# ...use at your own peril.

# see https://www.paypal.com/IntegrationCenter/ic_nvp.html
# and
# https://www.paypal.com/en_US/ebook/PP_NVPAPI_DeveloperGuide/index.html
# for more information.

# by Mike Atlas / LowSingle.com / MassWrestling.com, September 2007
# No License Expressed. Feel free to distribute, modify, 
# and use in any open or closed source project without credit to the author

# lot's of changed by Bram de Jong, but no fundamental changes to how the
# paypal API works, just cleanups. Also removed the DoDirectPayment method as
# it is not needed for Freesound

# Example usage:
# 1.
#   paypal = Paypal()
#   response = paypal.set_express_checkout(100)
#   url = paypal.get_paypal_forward_url(response['token'])
#   HttpResponseRedirect(url)
#
# 2.
#   paypal = Paypal()
#   # customer details are in:
#   response = paypal.get_express_checkout_details(request.GET["TOKEN"])
#   # the actual payment
#   response = paypal.do_express_checkout_payment(request.GET["TOKEN"], request.GET["PayerID"], 100)
#   # if you want to get all info:
#   paypal.get_transaction_details(response['transactionid'])

import urllib, cgi

class Paypal:
    
    def __init__(self, debug=True):
        # fill these in with the API values
        self.signature = dict(
            user='sdk-three_api1.sdk.com',
            pwd='QFZCWN5HZM8VBG7Q',
            signature='A-IzJhZZjhg29XQ2qnhapuwxIDzyAZQ92FRP5dqBzVesOkzbdUONzmOU',
            version='3.0',
        ) 

        self.urls = dict(
            returnurl='http://www.test.com/',
            cancelurl='http://www.test.com/cancelurl',
        )

        self.debug = debug

        if debug:
            self.API_ENDPOINT = 'https://api-3t.sandbox.paypal.com/nvp'
        else:
            self.API_ENDPOINT = 'https://api-3t.paypal.com/nvp'


    def get_paypal_forward_url(self, token):
        if self.debug:
            return 'https://www.sandbox.paypal.com/webscr?cmd=_express-checkout&token=' + token
        else:
            return 'https://www.paypal.com/webscr?cmd=_express-checkout&token=' + token

    
    def query(self, parameters, add_urls=True):
        """for a dict of parameters, create the query-string, get the paypal URL and return the parsed dict"""
        params = self.signature.items() + parameters.items()
        
        print parameters

        if add_urls:
            params += self.urls.items()
        
        # encode the urls into a query string
        params_string = urllib.urlencode( params )
        
        # get the response and parse it
        response = cgi.parse_qs(urllib.urlopen(self.API_ENDPOINT, params_string).read())
       
        # the parsed dict has a list for each value, but all Paypal replies are unique
        return dict([(key.lower(), value[0]) for (key,value) in response.items()])


    def set_express_checkout(self, amount):
        """Set up an express checkout"""
        params = dict(
            method="SetExpressCheckout",
            noshipping=1,
            paymentaction='Authorization',
            amt=amount,
            currencycode='EUR',
            email='', # used by paypal to set email for account creation
            desc='Freesound donation of %d euro' % amount, # description of what the person is buying
            custom=amount, # custom field, can be anything you want
            hdrimg='', # url to image for header, recomended to be stored on https server 
        )

        return self.query(params)
    

    def get_express_checkout_details(self, token):
        """Once the user returns to the return url, call this to get the detailsthe user returns to the return url, call this"""
        params = dict(
            method="GetExpressCheckoutDetails",
            token=token,
        )
        
        return self.query(params)
    
    
    def do_express_checkout_payment(self, token, payer_id, amt):
        """do the actual transaction..."""
        params = dict(
            method="DoExpressCheckoutPayment",
            paymentaction='Sale',
            token=token,
            amt=amt,
            currencycode='EUR',
            payerid=payer_id
        )

        return self.query(params)
        
    
    def get_transaction_details(self, tx_id):
        """get all the details of a transaction that has finished"""
        params = dict(
            method="GetTransactionDetails", 
            transactionid=tx_id
        )
        
        return self.query(params, add_urls=False)

########NEW FILE########
__FILENAME__ = freesound_test
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

import time
from utils.search.solr import Solr, SolrQuery, SolrResponseInterpreter

"""An example of usage, with the freesound custom schema...
"""

solr = Solr("http://localhost:8983/solr/", persistent=True)

lines = file("searches").readlines()
lines.reverse()

num_queries_total = 0
num_queries_this_loop = 0

time_solr = 0
results_solr = 0
results_before = 0

start = time.time()
start_this_loop = start

for index, line in enumerate(lines):
    if index % 200 == 0 and index > 0:
        avg_total = ((time.time() - start_this_loop) * 1000) / float(num_queries_this_loop)
        avg_solr = time_solr / float(num_queries_this_loop)
        avg_python = avg_total - avg_solr
        
        print "Batch of", num_queries_this_loop, "queries. Total queries:", num_queries_total
        print "\tAverage total time:", avg_total
        print "\tAverage solr:", avg_solr
        print "\tAverage python:", avg_python
        print "\tIndex:", index
        print "\tResult quality increase: %d%%" % int((100.0*results_solr)/float(results_before))

        num_queries_this_loop = 0
        time_solr = 0
        results_solr = 0
        results_before = 0
        start_this_loop = time.time()
                        
    try:
        try:
            (search, count) = line.strip().split("\t")
        except ValueError:
            continue
        
        count = int(count)

        results_before += count

        # clean the only few things DisMax doesn't like... :)
        search = search.strip("+-").replace("--", "").replace("+-", "").replace("-+", "").replace("++", "")
        if search == "\"" or search == "\"\"":
            search = ""

        query = SolrQuery()
        query.set_dismax_query(search, query_fields=[("id", 4), ("tag",3), ("description",3), ("username",2), ("pack_original",2), ("filename",2), "comment"])
        query.set_query_options(start=0, rows=10, field_list=["id"])
        query.add_facet_fields("samplerate", "pack_original", "username", "tag", "bitrate", "bitdepth")
        query.set_facet_options_default(limit=5, sort=True, mincount=1, count_missing=True)
        query.set_facet_options("tag", limit=30)
        query.set_facet_options("username", limit=30)
        
        response = solr.select(unicode(query))
        interpreted = SolrResponseInterpreter(response)

        num_queries_total += 1
        num_queries_this_loop += 1
        
        time_solr += interpreted.q_time
        results_solr += interpreted.num_found

    except KeyboardInterrupt:
        break
    except UnicodeDecodeError:
        pass

########NEW FILE########
__FILENAME__ = search
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from solr import Solr, SolrException, SolrResponseInterpreter
import sounds
from django.conf import settings
from freesound.search.views import search_prepare_sort, search_prepare_query
from freesound.search.forms import SEARCH_SORT_OPTIONS_WEB
import logging

logger = logging.getLogger("search")

def convert_to_solr_document(sound):
    logger.info("creating solr XML from sound %d" % sound.id)
    document = {}

    document["id"] = sound.id
    document["username"] = sound.user.username
    document["created"] = sound.created
    document["original_filename"] = sound.original_filename

    document["description"] = sound.description
    document["tag"] = list(sound.tags.select_related("tag").values_list('tag__name', flat=True))

    document["license"] = sound.license.name

    document["is_remix"] = bool(sound.sources.count())
    document["was_remixed"] = bool(sound.remixes.count())


    if sound.pack:
        document["pack"] = sound.pack.name
        document["grouping_pack"] = str(sound.pack.id) + "_" + sound.pack.name
    else:
        document["grouping_pack"] = str(sound.id)


    document["is_geotagged"] = sound.geotag_id != None
    if (sound.geotag_id != None):
        document["geotag"] = str(sound.geotag.lon) + " " + str(sound.geotag.lat)

    document["type"] = sound.type

    document["duration"] = sound.duration
    document["bitdepth"] = sound.bitdepth if sound.bitdepth != None else 0
    document["bitrate"] = sound.bitrate if sound.bitrate != None else 0
    document["samplerate"] = int(sound.samplerate)
    document["filesize"] = sound.filesize
    document["channels"] = sound.channels
    document["md5"] = sound.md5

    document["num_downloads"] = sound.num_downloads

    document["avg_rating"] = sound.avg_rating
    document["num_ratings"] = sound.num_ratings

    document["comment"] = list(sound.comments.values_list('comment', flat=True))
    document["comments"] = sound.num_comments

    document["waveform_path_m"] = sound.locations()["display"]["wave"]["M"]["path"]
    document["waveform_path_l"] = sound.locations()["display"]["wave"]["L"]["path"]
    document["spectral_path_m"] = sound.locations()["display"]["spectral"]["M"]["path"]
    document["spectral_path_l"] = sound.locations()["display"]["spectral"]["L"]["path"]
    document["preview_path"] = sound.locations()["preview"]["LQ"]["mp3"]["path"]

    return document


def add_sound_to_solr(sound):
    logger.info("adding single sound to solr index")
    try:
        Solr(settings.SOLR_URL).add([convert_to_solr_document(sound)])
    except SolrException, e:
        logger.error("failed to add sound %d to solr index, reason: %s" % (sound.id, str(e)))


def add_sounds_to_solr(sounds):
    logger.info("adding multiple sounds to solr index")
    solr = Solr(settings.SOLR_URL)


    logger.info("creating XML")
    documents = map(convert_to_solr_document, sounds)
    logger.info("posting to Solr")
    solr.add(documents)

    logger.info("optimizing solr index")
    #solr.optimize()
    logger.info("done")


def add_all_sounds_to_solr(sound_queryset, slice_size=4000, mark_index_clean=False):
    # Pass in a queryset to avoid needing a reference to
    # the Sound class, it causes circular imports.
    num_sounds = sound_queryset.count()
    for i in range(0, num_sounds, slice_size):
        print "Adding %i sounds to solr, slice %i"%(slice_size,i)
        try:
            sounds_to_update = sound_queryset[i:i+slice_size]
            add_sounds_to_solr(sounds_to_update)
            if mark_index_clean:
                logger.info("Marking sounds as clean.")
                sounds.models.Sound.objects.filter(pk__in=[snd.id for snd in sounds_to_update]).update(is_index_dirty=False)
        except SolrException, e:
            logger.error("failed to add sound batch to solr index, reason: %s" % str(e))


def get_all_sound_ids_from_solr(limit=False):
    logger.info("getting all sound ids from solr.")
    if not limit:
        limit = 99999999999999
    solr = Solr(settings.SOLR_URL)
    solr_ids = []
    solr_count = None
    PAGE_SIZE = 2000
    current_page = 1
    try:
        while (len(solr_ids) < solr_count or solr_count == None) and len(solr_ids) < limit:
            #print "Getting page %i" % current_page
            response = SolrResponseInterpreter(solr.select(unicode(search_prepare_query('', '', search_prepare_sort('created asc', SEARCH_SORT_OPTIONS_WEB), current_page, PAGE_SIZE, include_facets=False))))
            solr_ids += [element['id'] for element in response.docs]
            solr_count = response.num_found
            current_page += 1
    except Exception, e:
        raise Exception(e)

    return sorted(solr_ids)


def delete_sound_from_solr(sound):
    logger.info("deleting sound with id %d" % sound.id)
    try:
        Solr(settings.SOLR_URL).delete_by_id(sound.id)
    except Exception, e:
        logger.error('could not delete sound with id %s (%s).' % (sound.id, e))

########NEW FILE########
__FILENAME__ = search_forum
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from solr import Solr, SolrException
from django.conf import settings
import logging
from forum.models import Post

logger = logging.getLogger("search")

def convert_to_solr_document(post):
    logger.info("creating solr XML from forum post %d" % post.id)
    document = {}

    document["id"] = post.id
    
    document["thread_id"] = post.thread.id
    document["thread_title"] = post.thread.title
    document["thread_author"] = post.thread.author
    document["thread_created"] = post.thread.created
    
    document["forum_name"] = post.thread.forum.name
    document["forum_name_slug"] = post.thread.forum.name_slug
    
    document["post_author"] = post.author
    document["post_created"] = post.created
    document["post_body"] = post.body
    
    document["num_posts"] = post.thread.num_posts
    document["has_posts"] = False if post.thread.num_posts == 0 else True 
    
    logger.info(document)

    return document


def add_post_to_solr(post):
    logger.info("adding single forum post to solr index")
    try:
        Solr(settings.SOLR_FORUM_URL).add([convert_to_solr_document(post)])
    except SolrException, e:
        logger.error("failed to add forum post %d to solr index, reason: %s" % (post.id, str(e)))


def add_posts_to_solr(posts):
    logger.info("adding multiple forum posts to solr index")
    solr = Solr(settings.SOLR_FORUM_URL)


    logger.info("creating XML")
    documents = map(convert_to_solr_document, posts)
    logger.info("posting to Solr")
    solr.add(documents)

    logger.info("optimizing solr index")
    #solr.optimize()
    logger.info("done")
    
def add_all_posts_to_solr(post_queryset, slice_size=4000, mark_index_clean=False):
    # Pass in a queryset to avoid needing a reference to
    # the Post class, it causes circular imports.
    num_posts = post_queryset.count()
    for i in range(0, num_posts, slice_size):
        try:
            add_posts_to_solr(post_queryset[i:i+slice_size])
        except SolrException, e:
            logger.error("failed to add post batch to solr index, reason: %s" % str(e))    
    
def delete_post_from_solr(post):
    logger.info("deleting post with id %d" % post.id)
    try:
        Solr(settings.SOLR_FORUM_URL).delete_by_id(post.id)
    except Exception, e:
        logger.error('could not delete post with id %s (%s).' % (post.id, e))
########NEW FILE########
__FILENAME__ = solr
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     Bram de Jong
#

from datetime import datetime, date
from time import strptime
from xml.etree import cElementTree as ET
import itertools, re, urllib
import httplib, urlparse
import cjson
from socket import error
class Multidict(dict):
    """A dictionary that represents a query string. If values in the dics are tuples, they are expanded.
    None values are skipped and all values are utf-encoded. We need this because in solr, we can have multiple
    fields with the same value, like facet.field

    >>> [ (key, value) for (key,value) in Multidict({"a": 1, "b": (2,3,4), "c":None, "d":False}).items() ]
    [('a', 1), ('b', 2), ('b', 3), ('b', 4), ('d', 'false')]
    """
    def items(self):
        # generator that retuns all items
        def all_items():
            for (key, value) in dict.items(self):
                if isinstance(value, tuple) or isinstance(value, list):
                    for v in value:
                        yield key, v
                else:
                    yield key, value

        # generator that filters all items: drop (key, value) pairs with value=None and convert bools to lower case strings
        for (key, value) in itertools.ifilter(lambda (key,value): value != None and value != "", all_items()):
            if isinstance(value, bool):
                value = unicode(value).lower()
            else:
                value = unicode(value).encode('utf-8')

            yield (key, value)


class SolrQuery(object):
    """A wrapper around a lot of Solr query funcionality.
    """

    def __init__ (self, query_type=None, writer_type="json", indent=None, debug_query=None):
        """Creates a SolrQuery object
        query_type: Which handler to use when replying, default: default, dismax
        writer_type: Available types are: SolJSON, SolPHP, SolPython, SolRuby, XMLResponseFormat, XsltResponseWriter
        indent: format output with indentation or not
        debug_query: if 1 output debug infomation
        """
        # some default parameters
        self.params = {
            'qt': query_type,
            'wt': writer_type,
            'indent': indent,
            'debugQuery': debug_query
        }

    def set_query(self, query):
        self.params['q'] = query

    def set_dismax_query(self, query, query_fields=None, minimum_match=None, phrase_fields=None, phrase_slop=None, query_phrase_slop=None, tie_breaker=None, boost_query=None, boost_functions=None):
        """Created a dismax query: http://wiki.apache.org/solr/DisMaxRequestHandler
        The DisMaxRequestHandler is designed to process simple user entered phrases (without heavy syntax) and search for the individual words
        across several fields using different weighting (boosts) based on the significance of each field. Additional options let you influence
        the score based on rules specific to each use case (independent of user input)

        query_fields: List of fields and the "boosts" to associate with each of them when building DisjunctionMaxQueries from the user's query.
                        should be a list of fields: ["tag", "description", "username"]
                        with optional boosts:  with boosts [("tag", 2), "description", ("username", 3)]
        minimum_match: see docs...
        phrase_fields: after the query, find (in these fields) fields that have all terms close together and boost them
        phrase_slop: amount of slop on phrase queries built for "pf" fields (affects boosting).
        query_phrase_slop: Amount of slop on phrase queries explicitly included in the user's query string (in qf fields; affects matching).
        tie_breaker: see docs...
        boost_query: see docs...
        boost_functions: see docs...
        """
        self.params['qt'] = "dismax"
        self.params['q'] = query
        if query_fields:
            qf = []
            for f in query_fields:
                if isinstance(f, tuple):
                    qf.append("^".join(map(str,f)))
                else:
                    qf.append(f)

            self.params['qf'] = " ".join(qf)
        else:
            self.params['qf'] = None
        self.params['mm'] = minimum_match
        self.params['pf'] = " ".join(phrase_fields) if phrase_fields else phrase_fields
        self.params['ps'] = phrase_slop
        self.params['qs'] = query_phrase_slop
        self.params['tie'] = tie_breaker
        self.params['bq'] = boost_query
        self.params['bf'] = boost_functions

    def set_query_options(self, start=None, rows=None, sort=None, filter_query=None, field_list=None):
        """Set the options for the query.
        start: row where to start
        rows: row where to end
        sort: ['field1 desc', 'field2', 'field3 desc']
        filter_query: filter the returned results by this query
        field_list: ['field1', 'field2', ...] or ['*'] these fields will be returned, default: *
        """
        self.params['sort'] = ",".join(sort) if sort else sort
        self.params['start'] = start
        self.params['rows'] = rows
        self.params['fq'] = filter_query
        self.params['fl'] = ",".join(field_list) if field_list else field_list

    def add_facet_fields(self, *args):
        """Adds facet fields
        """
        self.params['facet'] = True
        try:
            self.params['facet.field'].extend(args)
        except KeyError:
            self.params['facet.field'] = list(args)

    def set_facet_query(self, query):
        """Set additional query for faceting
        """
        self.params['facet.query'] = query

    # set global faceting options for regular fields
    def set_facet_options_default(self, limit=None, offset=None, prefix=None, sort=None, mincount=None, count_missing=None, enum_cache_mindf=None):
        """Set default facet options: these will be applied to all facets, but overridden by particular options (see set_facet_options())
        prefix: retun only facets with this prefix
        sort: sort facets, True or False
        limit: nr of facets to return
        offset: start from this row
        mincount: minimum hits a facet needs to be listed
        count_missing: count items that don't have this facet, True or False
        enum_cache_mindf: when faceting on a field with a very large number of terms, and you wish to decrease memory usage, try a low value of 25 to 50 first
        """
        self.params['facet.limit'] = limit
        self.params['facet.offset'] = offset
        self.params['facet.prefix'] = prefix
        self.params['facet.sort'] = sort
        self.params['facet.mincount'] = mincount
        self.params['facet.missing'] = count_missing
        self.params['facet.enum.cache.minDf'] = enum_cache_mindf

    # set faceting options for one particular field
    def set_facet_options(self, field, prefix=None, sort=None, limit=None, offset=None, mincount=None, count_missing=None):
        """Set facet options for one particular field... see set_facet_options_default() for parameter explanation
        """
        try:
            if field not in self.params['facet.field']:
                raise SolrException, "setting facet options for field that doesn't exist"
        except KeyError:
            raise SolrException, "you haven't defined any facet fields yet"

        self.params['f.%s.facet.limit' % field] = limit
        self.params['f.%s.facet.offset' % field] = offset
        self.params['f.%s.facet.prefix' % field] = prefix
        self.params['f.%s.facet.sort' % field] = sort
        self.params['f.%s.facet.mincount' % field] = mincount
        self.params['f.%s.facet.missing' % field] = count_missing

    def add_date_facet_fields(self, *args):
        """Add date facet fields
        """
        self.params['facet'] = True
        try:
            self.params['facet.date'].extend(args)
        except KeyError:
            self.params['facet.date'] = list(args)

    def set_date_facet_options_default(self, start=None, end=None, gap=None, hardened=None, count_other=None):
        """Set default date facet options: these will be applied to all date facets, but overridden by particular options (see set_date_facet_options())
            start: date start in DateMathParser syntax
            end: date end in DateMathParser syntax
            gap: size of slices of date range
            hardend: True: if gap doesn't devide range make last slice smaller. False: go out of bounds with last slice
            count_other: A tuple of other dates to count: before, after, between, none, all
        """
        self.params['facet.date.start'] = start
        self.params['facet.date.end'] = start
        self.params['facet.date.gap'] = gap
        self.params['facet.date.hardend'] = hardened
        self.params['facet.date.other'] = count_other

    def set_date_facet_options(self, field, start=None, end=None, gap=None, hardened=None, count_other=None):
        """Set date facet options for one particular field... see set_date_facet_options_default() for parameter explanation
        """
        try:
            if field not in self.params['facet.date']:
                raise SolrException, "setting date facet options for field that doesn't exist"
        except KeyError:
            raise SolrException, "you haven't defined any date facet fields yet"

        self.params['f.%s.date.start' % field] = start
        self.params['f.%s.date.end' % field] = start
        self.params['f.%s.date.gap' % field] = gap
        self.params['f.%s.date.hardend' % field] = hardened
        self.params['f.%s.date.other' % field] = count_other

    def set_highlighting_options_default(self, field_list=None, snippets=None, fragment_size=None, merge_contiguous=None, require_field_match=None, max_analyzed_chars=None, alternate_field=None, max_alternate_field_length=None, pre=None, post=None, fragmenter=None, use_phrase_highlighter=None, regex_slop=None, regex_pattern=None, regex_max_analyzed_chars=None):
        """Set default highlighting options: these will be applied to all highlighting, but overridden by particular options (see set_highlighting_options())
        field_list: list of fields to highlight space separated
        snippets: number of snippets to generate
        fragment_size: snippet size, default: 1
        merge_contiguous: merge continuous snippets into one, True or False
        require_field_match: If True, then a field will only be highlighted if the query matched in this particular field
        max_analyzed_chars: How many characters into a document to look for suitable snippets
        alternate_field: if no match is found, use this field as summary
        max_alternate_field_length: size to clip the alternate field to
        pre: what to put before the snippet (like <strong>)
        post: what to put after the snippet (like </strong>)
        fragmenter: specify a text snippet generator for highlighted text.
        use_phrase_highlighter: use SpanScorer to highlight phrase terms only when they appear within the query phrase in the document.
        regex_slop: factor by which the regex fragmenter can stray from the ideal fragment size (given by hl.fragsize) to accomodate the regular expression
        regex_pattern: the regular expression for fragmenting.
        regex_max_analyzed_chars: only analyze this many characters from a field when using the regex fragmenter
        """
        self.params['hl'] = True
        self.params['hl.fl'] = ",".join(field_list) if field_list else field_list
        self.params['hl.fl.snippets'] = snippets
        self.params['hl.fragsize'] = fragment_size
        self.params['hl.mergeContiguous'] = merge_contiguous
        self.params['hl.requireFieldMatch'] = require_field_match
        self.params['hl.maxAnalyzedChars'] = max_analyzed_chars
        self.params['hl.alternateField'] = alternate_field
        self.params['hl.maxAlternateFieldLength'] = max_alternate_field_length
        #self.params['hl.formatter'] = # only valid one is "simple" right now
        self.params['hl.simple.pre'] = pre
        self.params['hl.simple.post'] = post
        self.params['hl.fragmenter'] = fragmenter
        self.params['hl.usePhraseHighlighter'] = use_phrase_highlighter
        self.params['hl.regex.slop'] = regex_slop
        self.params['hl.regex.pattern'] = regex_pattern
        self.params['hl.regex.maxAnalyzedChars'] = regex_max_analyzed_chars

    def set_highlighting_options(self, field, snippets=None, fragment_size=None, merge_contiguous=None, alternate_field=None, pre=None, post=None):
        """Set highlighting options for one particular field... see set_highlighting_options_default() for parameter explanation
        """
        try:
            if field not in self.params['hl.fl']:
                raise SolrException, "setting highlighting options for field that doesn't exist"
        except KeyError:
            raise SolrException, "you haven't defined any highlighting fields yet"

        self.params['f.%s.hl.fl.snippets' % field] = snippets
        self.params['f.%s.hl.fragsize' % field] = fragment_size
        self.params['f.%s.hl.mergeContiguous' % field] = merge_contiguous
        self.params['f.%s.hl.alternateField' % field] = alternate_field
        self.params['f.%s.hl.simple.pre' % field] = pre
        self.params['f.%s.hl.simple.post' % field] = post

    def __unicode__(self):
        return urllib.urlencode(Multidict(self.params))

    def set_group_field(self, group_field=None):
        self.params['group.field'] = group_field

    def set_group_options(self, group_func=None, group_query=None, group_rows=10, group_start=0, group_limit=1, group_offset=0, group_sort=None, group_sort_ingroup=None, group_format='grouped', group_main=False, group_num_groups=True, group_cache_percent=0):
        self.params['group'] = True
        self.params['group.func'] = group_func
        self.params['group.query'] = group_query
        self.params['group.rows'] = group_rows
        self.params['group.start'] = group_start
        self.params['group.limit'] = group_limit
        self.params['group.offset'] = group_offset
        self.params['group.sort'] = group_sort
        self.params['group.sort.ingroup']  = group_sort_ingroup
        self.params['group.format'] = group_format
        self.params['group.main'] = group_main        
        self.params['group.ngroups'] = group_num_groups
        self.params['group.cache.percent'] = group_cache_percent
        


class BaseSolrAddEncoder(object):
    """A Solr Add encoder has one method, called encode. This method will be called on whatever is
    passed to the Solr add() method. It should return an XML compatible with the installed Solr schema.

    >>> encoder = BaseSolrAddEncoder()
    >>> encoder.encode([{"id": 5, "name": "guido", "tag":["python", "coder"], "status":"bdfl"}])
    '<add><doc><field name="status">bdfl</field><field name="tag">python</field><field name="tag">coder</field><field name="id">5</field><field name="name">guido</field></doc></add>'
    """
    def encode(self, docs):
        """Encodes a document as an XML tree. this particular one takes a dictionary and
        translates the key value pairs to <field name="key">value<f/field>
        """
        message = ET.Element('add')

        def add_basic_type(element, name, value):
            """Converts python values to a form suitable for insertion into the xml
            we send to solr and adds it to the doc XML.
            """
            if isinstance(value, datetime):
                value = value.strftime('%Y-%m-%dT%H:%M:%S.000Z')
            elif isinstance(value, date):
                value = value.strftime('%Y-%m-%dT00:00:00.000Z')
            elif isinstance(value, bool):
                if value:
                    value = 'true'
                else:
                    value = 'false'
            else:
                value = unicode(value)

            field = ET.Element('field', name=name)
            field.text = value
            element.append(field)

        for doc in docs:
            d = ET.Element('doc')
            for key, value in doc.items():
                # handle lists, tuples, and other iterabes
                if isinstance(value, (list, tuple)):
                    for v in value:
                        add_basic_type(d, key, v)
                # handle strings and unicode
                else:
                    add_basic_type(d, key, value)
            message.append(d)

        return ET.tostring(message, "utf-8")



class SolrResponseDecoderException(Exception):
    pass


class BaseSolrResponseDecoder(object):
    """The BaseSolrResponseDecoder takes the Response object from urllib2 and decodes it"""


class SolrJsonResponseDecoder(BaseSolrResponseDecoder):

    def __init__(self):
        # matches returned dates in JSON strings
        self.date_match = re.compile("-?\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\d\.?\d*[a-zA-Z]*")

    def decode(self, response_object):
        #return self._decode_dates(json.load(response_object))
        return self._decode_dates(cjson.decode(unicode(response_object.read(),'utf-8'))) #@UndefinedVariable

    def _decode_dates(self, d):
        """Recursively decode date strings to datetime objects.
        """
        if isinstance(d, dict):
            for key, value in d.items():
                d[key] = self._decode_dates(value)
        elif isinstance(d, list):
            for index, value in enumerate(d):
                d[index] = self._decode_dates(value)
        elif isinstance(d, basestring):
            if self.date_match.match(d):
                try:
                    d = datetime(*strptime(d[0:19], "%Y-%m-%dT%H:%M:%S")[0:6])
                except:
                    raise SolrResponseDecoderException, u"Response object has unknown date format: %s" % d
        return d


class SolrException(Exception):
    pass


class Solr(object):
    def __init__(self, url="http://localhost:8983/solr", auto_commit=True, verbose=False, persistent=False, encoder=BaseSolrAddEncoder(), decoder=SolrJsonResponseDecoder()):
        url_split = urlparse.urlparse(url)

        self.host = url_split.hostname
        self.port = url_split.port
        self.path = url_split.path.rstrip('/')

        self.decoder = decoder
        self.encoder = encoder
        self.verbose = verbose
        self.auto_commit = auto_commit

        self.persistent = persistent

        if self.persistent:
            self.conn = httplib.HTTPConnection(self.host, self.port)

    def _request(self, query_string="", message=""):
        if query_string != "":
            path = '%s/select/?%s' % (self.path, query_string)
        else:
            path = '%s/update' % self.path

        if self.verbose:
            print "Connecting to Solr server: %s:%s" % (self.host, self.port)
            print "\tPath:", path
            print "\tSending data:", message

        if self.persistent:
            conn = self.conn
        else:
            conn = httplib.HTTPConnection(self.host, self.port)

        if query_string:
            conn.request('GET', path)
        elif message:
            conn.request('POST', path, message, {'Content-type': 'text/xml'})

        response = conn.getresponse()

        if response.status != 200:
            raise SolrException, response.reason
        
        return response

    def select(self, query_string, raw=False):
        if raw:
            return unicode(self._request(query_string=query_string).read())
        else:
            return self.decoder.decode(self._request(query_string=query_string))

    def add(self, docs):
        encoded_docs = self.encoder.encode(docs)
        try:
            self._request(message=encoded_docs)
        except error, e:
            raise SolrException, e
        #if self.auto_commit:
        #    self.commit()

    def delete_by_id(self, id):
        self._request(message=u'<delete><id>%s</id></delete>' % unicode(id))
        #if self.auto_commit:
        #    self.commit()

    def delete_by_query(self, query):
        self._request(message=u'<delete><query>%s</query></delete>' % unicode(query))
        #if self.auto_commit:
        #    self.commit()

    def commit(self, wait_flush=True, wait_searcher=True):
        message = ET.Element('commit')
        message.set("waitFlush", str(wait_flush).lower())
        message.set("waitSearcher", str(wait_searcher).lower())
        self._request(message=ET.tostring(message, "utf-8"))

    def optimize(self, wait_flush=True, wait_searcher=True):
        message = ET.Element('optimize')
        message.set("waitFlush", str(wait_flush).lower())
        message.set("waitSearcher", str(wait_searcher).lower())
        self._request(message=ET.tostring(message, "utf-8"))


class SolrResponseInterpreter(object):
    def __init__(self, response):
        if "grouped" in response:
            if "thread_title_grouped" in response["grouped"].keys():
                self.docs = response["grouped"]["thread_title_grouped"]["groups"]
                self.start = response["responseHeader"]["params"]["start"]
                self.num_rows = len(self.docs) # response["responseHeader"]["params"]["rows"]
                self.num_found = response["grouped"]["thread_title_grouped"]["ngroups"]
                self.non_grouped_number_of_matches = response["grouped"]["thread_title_grouped"]["matches"]
            elif "grouping_pack" in response["grouped"].keys():
                #self.docs = response["grouped"]["pack"]["groups"]
                self.docs = [{
                                 'id': group['doclist']['docs'][0]['id'],
                                 'more_from_pack':group['doclist']['numFound']-1,
                                 'pack_name':group['groupValue'][group['groupValue'].find("_")+1:],
                                 'pack_id':group['groupValue'][:group['groupValue'].find("_")],
                                 'other_ids': [doc['id'] for doc in group['doclist']['docs'][1:]]
                             } for group in response["grouped"]["grouping_pack"]["groups"] if group['groupValue'] != None ]
                self.start = response["responseHeader"]["params"]["start"]
                self.num_rows = len(self.docs) # response["responseHeader"]["params"]["rows"]
                self.num_found = response["grouped"]["grouping_pack"]["ngroups"]#["matches"]#
                self.non_grouped_number_of_matches = response["grouped"]["grouping_pack"]["matches"]
        else:
            self.docs = response["response"]["docs"]
            self.start = response["response"]["start"]
            self.num_rows = len(self.docs)
            self.num_found = response["response"]["numFound"]
            self.non_grouped_number_of_matches = -1
        
        self.q_time = response["responseHeader"]["QTime"]
        try:
            self.facets = response["facet_counts"]["facet_fields"]
        except KeyError:
            self.facets = {}

        """Facets are given in a list: [facet, number, facet, number, None, number] where the last one
        is the mising field count. Converting all of them to a dict for easier usage:
        {facet:number, facet:number, ..., None:number}
        """
        for facet, fields in self.facets.items():
            self.facets[facet] = [(fields[index], fields[index+1]) for index in range(0, len(fields), 2)]
        
        try:
            self.highlighting = response["highlighting"]
        except KeyError:
            self.highlighting = {}

    def display(self):
        print "Solr response:"
        print "\tGlobal parameters:"
        print "\t\t%d docs found in %d ms" % (self.num_found, self.q_time)
        print "\t\treturning %d docs starting from row %d" % (self.num_rows, self.start)
        print
        print "\tFaceting:"
        print "\t\tNr facets:", len(self.facets)
        print "\t\t\t%s" % "\n\t\t\t".join(["%s with %d entries" % (k,len(v)) for (k,v) in self.facets.items()])
        print
        print "\tHighlighting"
        print "\t\tNr highlighted docs:", len(self.highlighting)
        print
        print "\tDocuments:"
        print "\t\tNr docs found:", self.num_rows
        if self.num_rows > 0:
            print "\t\tPrinting one doc:"
            self.pp(self.docs[0], 3)

    def pp(self, d, indent=0):
        """A pretty print for general data. Tried pprint but just couldn't get it right
        """
        i = "\t"*indent
        if isinstance(d, dict):
            print i, "{"
            for (k,v) in d.items():
                self.pp(k, indent+1)
                print ":"
                self.pp(v, indent+2)
                print
            print i, "}",
        elif isinstance(d, tuple):
            print i, "("
            for v in d:
                self.pp(v, indent+1)
                print
            print i, ")",
        elif isinstance(d, list):
            print i, "["
            for v in d:
                self.pp(v, indent+1)
                print
            print i, "]",
        elif isinstance(d, basestring):
            print i, "\"%s\"" % d,
        else:
            print i, d,


class SolrResponseInterpreterPaginator(object):
    def __init__(self, interpreter, num_per_page):
        self.num_per_page = num_per_page
        self.interpreter = interpreter

        self.count = interpreter.num_found

        self.num_pages = interpreter.num_found / num_per_page + int(interpreter.num_found % num_per_page != 0)

        self.page_range = range(1, self.num_pages + 1)

    def page(self, page_num):
        object_list = self.interpreter.docs
        has_next = page_num < self.num_pages
        has_previous = page_num > 1 and page_num <= self.num_pages
        has_other_pages = has_next or has_previous
        next_page_number = page_num + 1
        previous_page_number = page_num - 1
        #start_index = self.interpreter.start
        #end_index = self.interpreter.start + self.interpreter.num_found
        return locals()


if __name__ == "__main__":
    import doctest
    doctest.testmod()

########NEW FILE########
__FILENAME__ = similarity_utilities
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

import settings, traceback, logging
from sounds.models import Sound
from django.core.cache import cache
from similarity.client import Similarity
from similarity.similarity_settings import PRESETS, DEFAULT_PRESET, SIMILAR_SOUNDS_TO_CACHE, SIMILARITY_CACHE_TIME

logger = logging.getLogger('web')


def get_similar_sounds(sound, preset = DEFAULT_PRESET, num_results = settings.SOUNDS_PER_PAGE, offset = 0 ):

    if preset not in PRESETS:
        preset = DEFAULT_PRESET

    cache_key = "similar-for-sound-%s-%s-%i" % (sound.id, preset, offset)

    # Don't use the cache when we're debugging
    if settings.DEBUG:
        similar_sounds = False
        count = False
    else:
        result = cache.get(cache_key)
        if result:
            similar_sounds = [[int(x[0]), float(x[1])] for x in result['results']]
            count = result['count']
        else:
            similar_sounds = False
            count = False

    if not similar_sounds:
        try:
            result = Similarity.search(sound.id, preset = preset, num_results = num_results, offset = offset)
            similar_sounds = [[int(x[0]), float(x[1])] for x in result['results']]
            count = result['count']
        except Exception, e:
            logger.debug('Could not get a response from the similarity service (%s)\n\t%s' % \
                         (e, traceback.format_exc()))
            result = False
            similar_sounds = []
            count = 0

        if result:
            cache.set(cache_key, result, SIMILARITY_CACHE_TIME)

    return similar_sounds[0:num_results], count


def api_search(target=None, filter=None, preset=None, metric_descriptor_names=None, num_results=None, offset=None, target_file=None, in_ids=None):

    cache_key = 'api-search-t-%s-f-%s-nr-%s-o-%s' % (str(target).replace(" ", ""), str(filter).replace(" ", ""), num_results, offset)
    note = False
    if in_ids:
        in_ids = ','.join([str(sid) for sid in in_ids if sid])

    # Don't use the cache when we're debugging
    if settings.DEBUG or len(cache_key) >= 250 or in_ids:
        returned_sounds = False
        count = False
    else:
        result = cache.get(cache_key)
        if result:
            returned_sounds = [[int(x[0]), float(x[1])] for x in result['results']]
            count = result['count']
        else:
            returned_sounds = False
            count = False

    if not returned_sounds or target_file:
        if target_file:
            # If there is a file attahced, set the file as the target
            target_type = 'file'
            target = None  # If target is given as a file, we set target to None (just in case)
        else:
            # In case there is no file, if the string target represents an integer value, then target is a sound_id, otherwise target is descriptor_values
            if target.isdigit():
                target_type = 'sound_id'
            else:
                target_type = 'descriptor_values'

        result = Similarity.api_search(
            target_type=target_type,
            target=target,
            filter=filter,
            preset=preset,
            metric_descriptor_names=metric_descriptor_names,
            num_results=num_results,
            offset=offset,
            file=target_file,
            in_ids=in_ids
        )

        returned_sounds = [[int(x[0]), float(x[1])] for x in result['results']]
        count = result['count']
        note = result['note']

        if not target_file and not in_ids:
            if len(returned_sounds) > 0 and len(cache_key) < 250 and not settings.DEBUG:
                cache.set(cache_key, result, SIMILARITY_CACHE_TIME)

    return returned_sounds[0:num_results], count, note


def get_sounds_descriptors(sound_ids, descriptor_names, normalization=True, only_leaf_descriptors=False):
    cache_key = "analysis-sound-id-%s-descriptors-%s-normalization-%s"

    cached_data = {}
    # Check if at least some sound analysis data is already on cache
    not_cached_sound_ids = sound_ids[:]
    for id in sound_ids:
        analysis_data = cache.get(cache_key % (str(id), ",".join(sorted(descriptor_names)), str(normalization)))
        if analysis_data:
            cached_data[unicode(id)] = analysis_data
            # remove id form list so it is not included in similarity request
            not_cached_sound_ids.remove(id)
    try:
        returned_data = Similarity.get_sounds_descriptors(not_cached_sound_ids, descriptor_names, normalization, only_leaf_descriptors)
    except Exception, e:
        logger.info('Something wrong occurred with the "get sound descriptors" request (%s)\n\t%s' %\
                     (e, traceback.format_exc()))
        raise Exception(e)

    # save sound analysis information in cache
    for key, item in returned_data.items():
        cache.set(cache_key % (key, ",".join(sorted(descriptor_names)), str(normalization)),
                  item, SIMILARITY_CACHE_TIME)

    returned_data.update(cached_data)

    return returned_data
########NEW FILE########
__FILENAME__ = spam
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from akismet import Akismet, AkismetError
from django.contrib.sites.models import Site
from urllib2 import HTTPError, URLError
from django.conf import settings
from general.models import AkismetSpam

def is_spam(request, comment):

    # If request user has uploaded sounds, we don't check for spam
    if request.user.sounds.count() > 0:
        return False

    domain = "http://%s" % Site.objects.get_current().domain
    api = Akismet(key=settings.AKISMET_KEY, blog_url=domain)
    
    data = {
        'user_ip': request.META.get('REMOTE_ADDR', '127.0.0.1'),
        'user_agent': request.META.get('HTTP_USER_AGENT', ''),
        'referrer': request.META.get('HTTP_REFERER', ''),
        'comment_type': 'comment',
        'comment_author': request.user.username.encode("utf-8") if request.user.is_authenticated() else '',
    }
    
    if False: # set this to true to force a spam detection
        data['comment_author'] = "viagra-test-123"
    
    try:
        if api.comment_check(comment.encode('utf-8'), data=data, build_data=True):
            if request.user.is_authenticated():
                AkismetSpam.objects.create(user=request.user, spam=comment)
            return True
        else:
            return False
    except AkismetError: # failed to contact akismet...
        return False
    except HTTPError: # failed to contact akismet...
        return False
    except URLError: # failed to contact akismet...
        return False

########NEW FILE########
__FILENAME__ = sql
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.db import connection

class DelayedQueryExecuter:
    """ The delayed executed executes a query, but waits for the first time
    the results are actually needed, i.e. via iteration """
    def __init__(self, query):
        self.query = query
        self.cache = None
    
    def __iter__(self):
        if self.cache is None:
            cursor = connection.cursor() #@UndefinedVariable
            cursor.execute(self.query)
            
            column_names = [desc[0] for desc in cursor.description]
            
            # cursor.fetchall fetches all results in one go (i.e. not a generator) so this is just as fast
            self.cache = [dict(zip(column_names, row)) for row in cursor.fetchall()]

        for row in self.cache:
            yield row
########NEW FILE########
__FILENAME__ = tagrecommendation_utilities
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

import logging, traceback, settings
from tagrecommendation.client import TagRecommendation
from tagrecommendation.tagrecommendation_settings import TAGRECOMMENDATION_CACHE_TIME
from django.core.cache import cache
from django.shortcuts import render_to_response
from django.template import RequestContext
from django.http import HttpResponse
import json
from django.contrib.auth.decorators import login_required
from utils.tags import clean_and_split_tags
from math import ceil

logger = logging.getLogger('web')
research_logger = logging.getLogger('tagrecommendation_research')


def get_recommended_tags(input_tags, max_number_of_tags=30):

    cache_key = "recommended-tags-for-%s" % (",".join(sorted(input_tags)))

    # Don't use the cache when we're debugging
    if settings.DEBUG:
        recommended_tags = False
    else:
        try:
            recommended_tags = cache.get(cache_key)
        except:
            recommended_tags = False

    if not recommended_tags:
        try:
            recommended_tags = TagRecommendation.recommend_tags(input_tags)

            if not recommended_tags['tags']:
                recommended_tags['community'] = "-"

            try:
                cache.set(cache_key, recommended_tags, TAGRECOMMENDATION_CACHE_TIME)
            except:
                pass

        except Exception, e:
            logger.error('Could not get a response from the tagrecommendation service (%s)\n\t%s' % \
                         (e, traceback.format_exc()))
            recommended_tags = False

    return recommended_tags['tags'][:max_number_of_tags], recommended_tags['community']


def get_recommended_tags_view(request):
    if request.is_ajax() and request.method == 'POST':
        input_tags = request.POST.get('input_tags', False)
        if input_tags:
            input_tags = list(clean_and_split_tags(input_tags))
            if len(input_tags) > 0:
                tags, community = get_recommended_tags(input_tags)
                return HttpResponse(json.dumps([tags, community]), mimetype='application/javascript')

    return HttpResponse(json.dumps([[],"-"]), mimetype='application/javascript')


def log_recommendation_info_view(request):
    if request.is_ajax() and request.method == 'POST':
        log = request.POST.get('log', False)
        if log:
            research_logger.info(log)

    return HttpResponse(json.dumps(""), mimetype='application/javascript')


def get_id_of_last_indexed_sound():
    try:
        result = TagRecommendation.get_last_indexed_id()
        return result

    except Exception, e:
        return -1


def post_sounds_to_tagrecommendation_service(sound_qs):
    data_to_post = []
    N_SOUNDS_PER_CALL = 10
    total_calls = int(ceil(float(len(sound_qs))/N_SOUNDS_PER_CALL))
    print "Sending recommendation data..."
    idx = 1
    for count, sound in enumerate(sound_qs):
        data_to_post.append(
            (sound.id, list(sound.tags.select_related("tag").values_list('tag__name', flat=True)))
        )
        if (count + 1) % N_SOUNDS_PER_CALL == 0:
            ids = [element[0] for element in data_to_post]
            tagss = [element[1] for element in data_to_post]
            print "\tSending group of sounds %i of %i (%i sounds)" % (idx, total_calls, len(ids))
            idx += 1
            TagRecommendation.add_to_index(ids, tagss)
            data_to_post = []

    if data_to_post:
        ids = [element[0] for element in data_to_post]
        tagss = [element[1] for element in data_to_post]
        print "\tSending group of sounds %i of %i (%i sounds)" % (idx, total_calls, len(ids))
        TagRecommendation.add_to_index(ids, tagss)

    print "Finished!"

########NEW FILE########
__FILENAME__ = tags
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from sets import Set
import re

def size_generator(small_size, large_size, num_items):
    if num_items <= 1:
        yield (small_size + large_size)*0.5
    else:
        for i in range(0,num_items):
            yield (i*(large_size - small_size))/(num_items-1) + small_size;

def annotate(dictionary, **kwargs):
    x = dictionary.copy()
    x.update(**kwargs)
    return x


def annotate_tags(tags, sort=True, small_size=0.7, large_size=1.8):
    """
    if tags are given as:
    [ {"name": "tag1", "count": 1}, {"name": "tag2", "count": 200}, {"name": "tag3", "count": 200}]
    after this function the list will look like this:
    [ {"name": "tag1", "count": 1, "size": 0.7}, {"name": "tag2", "count": 200, "size": 1.8}, {"name": "tag3", "count": 200, "size": 1.8}]
    """
    unique_counts = sorted(Set(tag["count"] for tag in tags))
    lookup = dict(zip(unique_counts, size_generator(small_size, large_size, len(unique_counts))))
    tags = [annotate(tag, size=lookup[tag["count"]]) for tag in tags]
    if sort:
        tags.sort(cmp=lambda x, y: cmp(x["name"].lower(), y["name"].lower()))
    return tags


alphanum_only = re.compile(r"[^ a-zA-Z0-9-]")
multi_dashes = re.compile(r"-+")


def clean_and_split_tags(tags):
    """
    >>> sorted(clean_and_split_tags("a,b\\tc d\\n\\ne"))
    ['a', 'b', 'c', 'd', 'e']
    >>> sorted(clean_and_split_tags("apple\\n\\n\\n    field-recording tree"))
    ['apple', 'field-recording', 'tree']
    """

    tags = alphanum_only.sub(" ", tags)
    tags = multi_dashes.sub("-", tags)
    common_words = "the of to and an in is it you that he was for on are with as i his they be at".split() #@UnusedVariable
    return set([tag for tag in [tag.strip('-') for tag in tags.split()] if tag and tag not in common_words])

########NEW FILE########
__FILENAME__ = text
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

import re, unicodedata
from BeautifulSoup import BeautifulSoup, Comment
from htmlentitydefs import name2codepoint
from django.utils.encoding import smart_unicode

def slugify(s, entities=True, decimal=True, hexadecimal=True, instance=None, slug_field='slug', filter_dict=None):
    """ slugify with character translation which translates foreign characters to regular ascii equivalents """
    s = smart_unicode(s)
    
    #character entity reference
    if entities:
        s = re.sub('&(%s);' % '|'.join(name2codepoint), lambda m: unichr(name2codepoint[m.group(1)]), s)

    #decimal character reference
    if decimal:
        try:
            s = re.sub('&#(\d+);', lambda m: unichr(int(m.group(1))), s)
        except:
            pass

    #hexadecimal character reference
    if hexadecimal:
        try:
            s = re.sub('&#x([\da-fA-F]+);', lambda m: unichr(int(m.group(1), 16)), s)
        except:
            pass

    #translate
    s = unicodedata.normalize('NFKD', s).encode('ascii', 'ignore')

    #replace unwanted characters
    s = re.sub(r'[^-a-z0-9]+', '-', s.lower())

    #remove redundant -
    s = re.sub('-{2,}', '-', s).strip('-')

    slug = s

    if instance:
        def get_query():
            query = instance.__class__.objects.filter(**{slug_field: slug})
            if filter_dict:
                query = query.filter(**filter_dict)
            if instance.pk:
                query = query.exclude(pk=instance.pk)
            return query
        counter = 1
        while get_query():
            slug = "%s-%s" % (s, counter)
            counter += 1
    
    return slug.lower()


def shout_percentage(string):
    if len(string):
        return sum(1 for s in string if s != s.lower() or s == "!") / float(len(string))
    else:
        return 0

def is_shouting(string):
    """
    >>> is_shouting('')
    False
    >>> is_shouting('HELLO THIS IS SHOUTING!!!')
    True
    >>> is_shouting('This is a phrase WITH SONE emphasis!!')
    False
    >>> is_shouting('This is a regular phrase.')
    False
    """
    if len(string) < 5:
        return False
    return shout_percentage(string) > 0.6


# returns if the string ends with any of the endinggs
def endswithone(string, endings):
    reduce(lambda a,b: a or string.endswith(b), endings, False)

# returns if the string starts with any of the starts
def startswithone(string, starts):
    reduce(lambda a,b: a or string.startswith(b), starts, False)


url_regex = re.compile("(https?://\S+)", re.IGNORECASE)

def replace_element_by_children(soup, element):
    """
    replace an element in the DOM with it's child nodes
    """
    parent = element.parent
        
    if not parent:
        parent = soup
    
    # afterwards we need to insert the children where the parent used to be!
    position_in_parent = 0
    for c in parent.contents:
        if c == element:
            break
        else:
            position_in_parent += 1
    
    # in reverse order, insert the child elements in their place.
    for el in element.contents[::-1]:
        parent.insert(position_in_parent, el)

    # delete the element
    element.extract()


def clean_html(input):
    """
    >>> clean_html(u'a b c d')
    u'a b c d'
    >>> clean_html(u'<a href="http://www.google.com" rel="squeek">google</a>')
    u'<a href="http://www.google.com" rel="nofollow">google</a>'
    >>> clean_html(u'<a href="http://www.google.com">google</a>')
    u'<a href="http://www.google.com" rel="nofollow">google</a>'
    >>> clean_html(u'<h1>this should return the <strong>substring</strong> just <b>fine</b></h1>')
    u'this should return the <strong>substring</strong> just <b>fine</b>'
    >>> clean_html(u'<table><tr><td>amazing</td><td>grace</td></tr></table>')
    u'amazinggrace'
    >>> clean_html(u'<a href="javascript:void(0)">click me</a>')
    u'click me'
    >>> clean_html(u'<p class="hello">click me</p>')
    u'<p>click me</p>'
    >>> clean_html(u'<a></a>')
    u''
    >>> clean_html(u'<p>         </p>')
    u'<p> </p>'
    >>> clean_html(u'<a>hello</a>')
    u'hello'
    >>> clean_html(u'<p class="hello" id="1">a<br/>b<br/></a>')
    u'<p>a<br />b<br /></p>'
    >>> clean_html(u'<p></p>')
    u'<p></p>'
    >>> clean_html(u'<A REL="nofollow" hREF="http://www.google.com"><strong>http://www.google.com</strong></a>')
    u'<a href="http://www.google.com" rel="nofollow"><strong>http://www.google.com</strong></a>'
    >>> clean_html(u'<a rel="nofollow" href="http://www.google.com"><strong>http://www.google.com</strong></a>')
    u'<a href="http://www.google.com" rel="nofollow"><strong>http://www.google.com</strong></a>'
    >>> clean_html(u'http://www.google.com <a href="">http://www.google.com</a>')
    u'<a href="http://www.google.com" rel="nofollow">http://www.google.com</a> <a href="http://www.google.com" rel="nofollow">http://www.google.com</a>'
    >>> clean_html(u'<ul><p id=5><a href="123">123</a>hello<tr></tr><strong class=156>there http://www</strong></p></ul>')
    u'<ul><p>123hello<strong>there http://www</strong></p></ul>'
    >>> clean_html(u'abc http://www.google.com abc')
    u'abc <a href="http://www.google.com" rel="nofollow">http://www.google.com</a> abc'
    >>> clean_html(u'GALORE: http://freesound.iua.upf.edu/samplesViewSingle.php?id=22092\\nFreesound Moderator')
    u'GALORE: <a href="http://freesound.iua.upf.edu/samplesViewSingle.php?id=22092" rel="nofollow">http://freesound.iua.upf.edu/samplesViewSingle.php?id=22092</a>\\nFreesound Moderator'
    """
    
    delete_tags = [u"script", u"style", u"head"]
    ok_tags = [u"a", u"img", u"strong", u"b", u"em", u"i", u"u", u"p", u"br",  u"blockquote", u"code"]
    ok_attributes = {u"a": [u"href"], u"img": [u"src", u"alt", u"title"]}
    # all other tags: replace with the content of the tag
    
    soup = BeautifulSoup(input, fromEncoding="utf-8")
    
    # delete all comments
    [comment.extract() for comment in soup.findAll(text=lambda text:isinstance(text, Comment))]

    for element in soup.findAll():
        if element.name in delete_tags:
            element.extract()
            continue
        
        if element.name not in ok_tags:
            replace_element_by_children(soup, element)
            continue
            
        try:
            if element.name in ok_attributes.keys():
                # delete all attributes we don't want
                for (attr_name, attr_value) in element.attrs: #@UnusedVariable
                    if attr_name not in ok_attributes[element.name]:
                        del element[attr_name]

                if element.name == "a":
                    if u"href" not in dict(element.attrs) or not url_regex.match(element[u"href"]):
                        replace_element_by_children(soup, element)
                    else:
                        element["rel"] = u"nofollow"
                elif element.name == u"img":
                    if u"src" not in dict(element.attrs) or not url_regex.match(element[u"src"]):
                        replace_element_by_children(soup, element)
            else:
                # these should not have any attributes
                element.attrs = []
        except AttributeError:
            if element.name in ok_attributes.keys():
                replace_element_by_children(soup, element)

    for text in soup.findAll(text=url_regex):
        if not text.findParents(u'a'):
            text.replaceWith(url_regex.sub(r'<a href="\1" rel="nofollow">\1</a>', text))
    
    return unicode(soup)

def remove_control_chars(text):
    print "removing control chars"
    return ''.join(c for c in text if (ord(c) >= 32 or ord(c) in [9,10,13]))


def _test():
    import doctest
    doctest.testmod()

if __name__ == "__main__":
    _test()

########NEW FILE########
__FILENAME__ = admin
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.contrib import admin
from wiki.models import Page, Content

class PageAdmin(admin.ModelAdmin):
    list_display = ('name', )
admin.site.register(Page, PageAdmin)


class ContentAdmin(admin.ModelAdmin):
    raw_id_fields = ('author', )
    list_display = ('page', 'author', 'title', 'created', )
admin.site.register(Content, ContentAdmin)
########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'Page'
        db.create_table('wiki_page', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=256, db_index=True)),
        ))
        db.send_create_signal('wiki', ['Page'])

        # Adding model 'Content'
        db.create_table('wiki_content', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('page', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['wiki.Page'])),
            ('author', self.gf('django.db.models.fields.related.ForeignKey')(default=None, to=orm['auth.User'], null=True, blank=True)),
            ('title', self.gf('django.db.models.fields.CharField')(max_length=250)),
            ('body', self.gf('django.db.models.fields.TextField')()),
            ('created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, db_index=True, blank=True)),
        ))
        db.send_create_signal('wiki', ['Content'])


    def backwards(self, orm):
        
        # Deleting model 'Page'
        db.delete_table('wiki_page')

        # Deleting model 'Content'
        db.delete_table('wiki_content')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'wiki.content': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Content'},
            'author': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['auth.User']", 'null': 'True', 'blank': 'True'}),
            'body': ('django.db.models.fields.TextField', [], {}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'page': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['wiki.Page']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '250'})
        },
        'wiki.page': {
            'Meta': {'object_name': 'Page'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '256', 'db_index': 'True'})
        }
    }

    complete_apps = ['wiki']

########NEW FILE########
__FILENAME__ = models
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.contrib.auth.models import User
from django.db import models
from django.utils.encoding import smart_unicode

class Page(models.Model):
    name = models.CharField(max_length=256, db_index=True)

    def __unicode__(self):
        return self.name

    def content(self):
        return Content.objects.filter(page=self).latest()
    
    @models.permalink
    def get_absolute_url(self):
        return ("wiki-page", (smart_unicode(self.name),))


class Content(models.Model):
    page = models.ForeignKey(Page)
    author = models.ForeignKey(User, null=True, blank=True, default=None)
    title = models.CharField(max_length=250)
    body = models.TextField()
    created = models.DateTimeField(db_index=True, auto_now_add=True)
    
    class Meta:
        ordering = ('-created', )
        get_latest_by = 'created'

    def __unicode__(self):
        return self.title
########NEW FILE########
__FILENAME__ = urls
# -*- coding: utf-8 -*-

#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django.conf.urls.defaults import patterns, url
import wiki.views as wiki

urlpatterns = patterns('',
    url(r'^$', "django.views.generic.simple.redirect_to", kwargs={'url': "/help/main/"}, name="wiki"),
    url(r'^$', "django.views.generic.simple.redirect_to", kwargs={'url': "/help/developers/"}, name="wiki_developers"),
    url(r'^(?P<name>[//\w_-]+)/history/$', wiki.history, name="wiki-page-history"),
    url(r'^(?P<name>[//\w_-]+)/edit/$', wiki.editpage, name="wiki-page-edit"),
    url(r'^(?P<name>[//\w_-]+)/$', wiki.page, name="wiki-page"),
)
########NEW FILE########
__FILENAME__ = views
#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

from django import forms
from django.core.urlresolvers import reverse
from django.http import HttpResponseRedirect, Http404
from django.shortcuts import render_to_response
from django.template import RequestContext
from wiki.models import Content, Page

def page(request, name):
    try:
        version = int(request.GET.get("version", -1))
    except:
        version = -1
    
    try:
        if version == -1:
            content = Content.objects.filter(page__name__iexact=name).select_related().latest()
        else:
            content = Content.objects.select_related().get(page__name__iexact=name, id=version)
    except Content.DoesNotExist: #@UndefinedVariable
        content = Content.objects.filter(page__name__iexact="blank").select_related().latest()
    
    return render_to_response('wiki/page.html', locals(), context_instance=RequestContext(request)) 

def editpage(request, name):
    if not (request.user.is_authenticated() and request.user.has_perm('wiki.add_page')):
        raise Http404

    # the class for editing...
    class ContentForm(forms.ModelForm):
        title = forms.CharField(label='Page name',widget=forms.TextInput(attrs={'size': '100'}))
        body = forms.CharField(widget=forms.Textarea(attrs={'rows':'40', 'cols':'100'}))
        class Meta:
            model = Content
            exclude = ('author', 'page', "created")
    
    if request.method == "POST":
        form = ContentForm(request.POST)
        
        if form.is_valid():
            content = form.save(commit=False)
            content.page = Page.objects.get_or_create(name=name)[0]
            content.author = request.user
            content.save()
            return HttpResponseRedirect(reverse('wiki-page', args=[name]))
    else:
        try:
            # if the page already exists, load up the previous content
            content = Content.objects.filter(page__name__iexact=name).select_related().latest()
            form = ContentForm(initial={"title": content.title, "body":content.body})
        except Content.DoesNotExist: #@UndefinedVariable
            form = ContentForm()

    return render_to_response('wiki/edit.html', locals(), context_instance=RequestContext(request))

def history(request, name):
    if not (request.user.is_authenticated() and request.user.has_perm('wiki.add_page')):
        raise Http404
    
    try:
        page = Page.objects.get(name__iexact=name)
    except Page.DoesNotExist:
        raise Http404

    try:
        versions = Content.objects.filter(page=page).select_related()
    except Content.DoesNotExist: #@UndefinedVariable
        raise Http404
    
    if request.GET and "version1" in request.GET and "version2" in request.GET:
        import difflib
        version1 = Content.objects.select_related().get(id=request.GET.get("version1"))
        version2 = Content.objects.select_related().get(id=request.GET.get("version2"))
        
        diff = difflib.HtmlDiff(4, 55).make_table(version1.body.split("\n"), version2.body.split("\n"), "version %d" % version1.id, "version %d" % version2.id, True, 5)
        
    
    return render_to_response('wiki/history.html', locals(), context_instance=RequestContext(request)) 
 
########NEW FILE########
__FILENAME__ = add_examples_to_api_docs_source_files
import sys
sys.path.append("../../apiv2")
from examples import examples
base_url = 'http://www.freesound.org/'

def get_formatted_examples_for_view(view_name):
    try:
        data = examples[view_name]
    except:
        print 'Could not find examples for view %s' % view_name
        return ''

    output = ''
    for description, elements in data:
        output += '\n\n%s:\n\n' % description
        output += '::\n\n'
        for element in elements:
            if element[0:5] == 'apiv2':
                output += '  %s%s\n' % (base_url, element)
                #output += '  curl -H "Authorization: Token {{token}}" \'%s%s\'\n' % (base_url, element)
            else:
                output += '  %s\n' % (element % base_url[:-1].replace('http', 'https'))

    return output


with open('source/resources.rst', 'r') as f:
    newlines = []
    for line in f.readlines():
        if '{{examples_' in line:
            name = line.split('{{')[1].split('}}')[0].split('_')[1]
            examples_string = get_formatted_examples_for_view(name)
            for example_line in examples_string.split('\n'):
                newlines.append(example_line + '\n')
        else:
            newlines.append(line)

with open('source/resources_apiv2.rst', 'w') as f:
    for line in newlines:
        f.write(line)
########NEW FILE########
__FILENAME__ = generate_analysis_rst
# Generate skeleton for documentation, 
# add essentia documentation links by hand

import urllib2,json


header = """
.. _analysis-docs:

Analysis Descriptor Documentation
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

.. contents::
    :depth: 3
    :backlinks: top


Analysis Settings
>>>>>>>>>>>>>>>>>

The analysis sample rate is 44100Hz and the audio file's channels are mixed down
to mono. For the lowlevel namespace the frame size is 2048 samples with a hop
size of 1024, while for the tonal namespace the frame size is 4096 and the hop
size 2048.


Acronyms for the statistics
>>>>>>>>>>>>>>>>>>>>>>>>>>>

Generally, the lowlevel descriptors have the statistics mean, max, min, var,
dmean, dmean2, dvar, and dvar2. These should be read as follows.

========= =====================================
Statistic
========= =====================================
mean      The arithmetic mean
max       The maximum value
min       The minimum value
var       The variance
dmean     The mean of the derivative
dmean2    The mean of the second derivative
dvar      The variance of the derivative
dvar2     The variance of the second derivative
========= =====================================

"""

curl_str = "    curl http://www.freesound.org/api/sounds/<sound_id>/analysis/"
image_str = "    .. image:: _static/descriptors/"
height_str = "        :height: 300px"
algorithm_doc_str = "http://essentia.upf.edu/documentation/reference/streaming_"
sorted_namespaces = ["metadata","lowlevel","rhythm","tonal","sfx"]
desc_exceptions = ["metadata.audio_properties","metadata.version","rhythm.onset_rate"]

example_url = "http://freesound.org/api/sounds/1234/analysis/?api_key=53b80e4d8a674ccaa80b780372103680&all=True"

req = urllib2.Request(example_url)
resp = urllib2.urlopen(req)
top = json.loads(resp.read())


mapping = dict()
for line in open("algorithm_mapping.csv"):
	desc,alg = line[:-1].split(",")
	mapping[desc] = alg

print header

for k in sorted_namespaces:
	ns = k[0].upper()+k[1:]
	print ns+ " Descriptors"
	print ">>>>>>>>>>>>>>>>>>>>\n\n"
	for d in top[k].keys():
		descriptor = k+"."+d
		print descriptor
		print "-------------------------"
		print "\n::\n"
		print curl_str+k+"/"+d
		if mapping[descriptor] !="None":
			print "\n**Essentia Algorithm**\n"
			print algorithm_doc_str+mapping[descriptor]+".html"
		stats = top[k][d]
		if descriptor in desc_exceptions: 
			print "\n"
			continue
		if type(stats) ==dict:
			print "\n\n**Stats**::\n\n"
			for s in stats.keys():
				print "/"+s

			print "\n\n**Distribution in Freesound**\n"

			if "mean" in stats.keys():
				if  type(stats['mean'])==list:
					for i in range(len(stats['mean'])):
						img = image_str+descriptor+".mean.%03d"%i
						print img+".png"
						print height_str
				else:
					print image_str+descriptor+".mean.png"
					print height_str
		elif type(stats)== float or type(stats)==int:
			print image_str+descriptor+".png"
			print height_str
		print "\n\n"
		

########NEW FILE########
__FILENAME__ = generate_plots
import gaia2
import pylab as pl
from numpy import std, average, percentile


OUT_FOLDER = 'out_plots' # Must be created
GAIA_INDEX_FILE = 'fs_index.db' # File with gaia index
BINS = 100 # Bins per histogram plot


def plot_histogram(pool, label,  x_label_ticks = False):
    fig = pl.figure()
    ax = fig.add_subplot(111)

    if not x_label_ticks:
        range_min = min(pool) #percentile(pool, 10)
        range_max = max(pool) #percentile(pool, 90)
    else:
        range_min = min(pool)
        range_max = max(pool) + 1

    n_bins = BINS
    if x_label_ticks:
        n_bins = len(x_label_ticks)
    n, bins, patches = ax.hist(pool, bins=n_bins, range=(float(range_min), float(range_max)), log=False, histtype='stepfilled')
    pl.title('Distribution: %s' % label)
    if not x_label_ticks:
        ax.ticklabel_format(axis='x', style='sci', scilimits=(-3,3))
    else:
        pl.xticks(range(0, len(x_label_ticks)),['           %s'%tick for tick in x_label_ticks])
    ax.ticklabel_format(axis='y', style='sci', scilimits=(-2,2))
    ax.set_xlabel('Value')
    ax.set_ylabel('Frequency of occurrence')
    ax.grid(True)
    pl.savefig('%s/%s.png' % (OUT_FOLDER, label[1:]))
    pl.close()

ds = gaia2.DataSet()
dataset_path = GAIA_INDEX_FILE
ds.load(dataset_path)
transformation_history = ds.history().toPython()
normalization_coeffs = None
for i in range(0,len(transformation_history)):
    if transformation_history[-(i+1)]['Analyzer name'] == 'normalize':
        normalization_coeffs = transformation_history[-(i+1)]['Applier parameters']['coeffs']
descriptor_names = ds.layout().descriptorNames()
point_names = ds.pointNames()
example_point = ds.point(point_names[0])
stats = ['dmean', 'dmean2', 'dvar', 'dvar2', 'max', 'mean', 'min', 'var']


for descriptor_name in descriptor_names:

    if descriptor_name.split('.')[-1] in stats:
        if descriptor_name.split('.')[-1] != 'mean':
            continue

    try:
        example_value = example_point.value(descriptor_name)
    except:
        try:
            example_value = example_point.label(descriptor_name)
        except:
            print "ERROR: %s could not be processd" % descriptor_name
            continue

    print "Histogram for descriptor: %s" % descriptor_name
    if type(example_value) == float:
        pool = []
        for point_name in point_names:
            point = ds.point(point_name)
            normalized_value = point.value(descriptor_name)
            if not normalization_coeffs:
                value = normalized_value
            else:
                a = normalization_coeffs[descriptor_name]['a']
                b = normalization_coeffs[descriptor_name]['b']
                value = float(normalized_value - b[0]) / a[0]
            pool.append(value)

        plot_histogram(pool, descriptor_name)

    elif type(example_value) == tuple:
        for i in range(0, len(example_value)):
            label = descriptor_name + '.%.3i' % i
            print "\tDimension %i" % i
            pool = []
            for point_name in point_names:
                point = ds.point(point_name)
                normalized_value = point.value(descriptor_name)[i]
                if not normalization_coeffs:
                    value = normalized_value
                else:
                    a = normalization_coeffs[descriptor_name]['a']
                    b = normalization_coeffs[descriptor_name]['b']
                    value = float(normalized_value - b[i]) / a[i]
                pool.append(value)

            plot_histogram(pool, label)

    elif type(example_value) == str:
        pool = []
        for point_name in point_names:
            point = ds.point(point_name)
            value = point.label(descriptor_name)
            pool.append(value)

        keys = sorted(list(set(pool)))
        key_ids = dict()
        for j, key in enumerate(keys):
            key_ids[key] = j
        pool = [key_ids[value] for value in pool]

        plot_histogram(pool, descriptor_name,  x_label_ticks = keys)
########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Freesound API documentation build configuration file, created by
# sphinx-quickstart on Mon Sep  6 11:41:46 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.append(os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Freesound API'
copyright = u'2014, Universitat Pompeu Fabra'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '2.0'
# The full version, including alpha/beta/rc tags.
release = '2.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'freesound'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['_themes']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
html_title = 'Freesound API documentation'

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = '_static/freesound_logo_small.png'

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'FreesoundAPIdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'FreesoundAPI.tex', u'Freesound API Documentation',
   u'Vincent Akkermans, Bram de Jong', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

########NEW FILE########
__FILENAME__ = generate_report
#!/usr/bin/env python

from settings import *
import MySQLdb, os, sys
import mx.DateTime as dt
import json



db=MySQLdb.connect(user=DB_USER, passwd=DB_PASS, db=DB_NAME)
cursor = db.cursor()
cursor2 = db.cursor()

FIRST_YEAR = 2005
FIRST_MONTH = 5

NOW  = dt.now()
THEN = dt.DateTime(2005, 4, 1)


def generate_dates(start, end, delta_months, delta_days):
    d = start
    while d < end:
        yield d
        d = d + dt.RelativeDateTime(days=delta_days, months=delta_months)


MONTHS = [x for x in generate_dates(THEN, NOW, 1, 0)]
WEEKS  = [x for x in generate_dates(THEN, NOW, 0, 7)]
DAYS   = [x for x in generate_dates(THEN, NOW, 0, 1)]


def execute_query(query, dates):
    '''
    `query` should include {y}, {m}, and {d} format directives for year, month, and day respectively.
    '''
    counts = []
    for d in dates:
        sys.stdout.write('.')
        sys.stdout.flush()
        sql = query.format(y=d.year, m=d.month, d=d.day)
        cursor.execute(sql)
        result = cursor.fetchone()
        counts.append(result[0])
    return counts


def get_users_accum(dates):
    sql = "select count(*) from phpbb_users where FROM_UNIXTIME(user_regdate) < '{y}-{m}-{d}';"
    return execute_query(sql, dates)

def get_downloads_accum(dates):
    sql = "select count(*) from audio_file_downloads where date(date) < '{y}-{m}-{d}';"
    return execute_query(sql, dates)

def get_uploads_accum(dates):
    sql = "select count(*) from audio_file where date(dateAdded) < '{y}-{m}-{d}';"
    return execute_query(sql, dates)





if __name__ == '__main__':

    queries = {'users_accum':
               "select count(*) from phpbb_users where FROM_UNIXTIME(user_regdate) < '{y}-{m}-{d}';",
               'downloads_monthly':
               "select count(*) from audio_file_downloads where year(date) = {y} AND month(date) = {m};",
               'downloads_daily':
               "select count(*) from audio_file_downloads where date(date) = '{y}-{m}-{d}';",
               'uploads_monthly':
               "select count(*) from audio_file where year(dateAdded) = {y} AND month(dateAdded) = {m};",
               'uploads_daily':
               "select count(*) from audio_file where date(dateAdded) = '{y}-{m}-{d}';",
               }

    data = {}
    execs    = [('users_accum_monthly', # will be the index in the json result file
                'users_accum',         # will be used to look up the sql query
                MONTHS),               # will be used as input for the dates

               ('users_accum_weekly',
                'users_accum',
                WEEKS),

               ('downloads_monthly',
                'downloads_monthly',
                MONTHS),

               ('downloads_daily',
                'downloads_daily',
                DAYS),

               ('uploads_monthly',
                'uploads_monthly',
                DAYS),

               ('uploads_daily',
                'uploads_daily',
                DAYS),
              ]
    for result_name, query_name, dates in execs:
        print 'Executing query: %s' % result_name
        data[result_name] = execute_query(queries[query_name], dates)
        print '.'
    report_file = os.path.join(os.path.dirname(__file__), 'report_freesound1_%d%02d%02d_to_%d%02d%02d.json' \
                               % (THEN.year, THEN.month, THEN.day, NOW.year, NOW.month, NOW.day))
    fp = file(report_file, 'w')
    json.dump(data, fp)
    fp.close()
    print "Generated report '%s' \t(date format: yyyymmdd)" % report_file

########NEW FILE########
__FILENAME__ = settings
from settings_local import *

########NEW FILE########
__FILENAME__ = settings_local.example
DB_NAME = "freesound"
DB_PASS = "freesound"
DB_USER = "freesound"

########NEW FILE########
__FILENAME__ = audioclas
#!/usr/bin/python
#
# functions related to AudioClas computing

AUDIOCLAS_EXECUTABLE_SPECTRAL_CENTROID	= '/freesound/scripts/audioclas/bin/audioclas_spectral_centroid'
AUDIOCLAS_EXECUTABLE			= '/freesound/scripts/audioclas/bin/audioclas'
AUDIOCLAS_CONFIGFILE			= '/freesound/scripts/audioclas/bin/audioclas_sfx.conf'
AUDIOCLAS_CONFIGFILE_SPECTRALCENTROID	= '/freesound/scripts/audioclas/bin/spectralCentroid.conf'
AUDIOCLAS_SIGNATURE_DECRYPT		= '/freesound/scripts/audioclas/bin/decryptsig'

STEREOFY_EXECUTABLE			= '/freesound/utils/stereofy/stereofy-static'
WAV2PNG					= '/freesound/utils/wav2png/wav2png-static'

import os
import tempfile
import wave
import sys
import subprocess, shlex

def call(cmd):
	return subprocess.call(shlex.split(cmd))

def cleanup():
	print "cleaning up temp files..."
	files = os.listdir('/tmp/')
	for file in files:
		if file.startswith('AUDIOCLAS_'):
			os.remove('/tmp/%s' % file)


def exitAudioclas(error):
	if error:
		print "exiting with panic :-)"
		cleanup()
		sys.exit(-1)
	else:
		print "all done..."
		cleanup()
		sys.exit(0)


def create_preview(filenameIn, filenameOut):
	print "creating mp3 preview"
#	filenameOut = os.path.splitext( filenameOut )[0] # TODO changer ici et en dessous
	cmd = 'lame --quiet --resample 44.1 --abr 64 %s %s' % (filenameIn, filenameOut)
	print "\tcmd = %s" % cmd

	if call(cmd) != 0:
		print "creating mp3 preview FAILED"
		return -1
	else:
		return 0


def convert_to_wav(audiofile, outfile, samplerate,mp3Preview):
	name, extension = os.path.splitext(audiofile)

	tmpfile = tempfile.mkstemp('.wav', 'AUDIOCLAS_')[1]
	tmpfile2 = tempfile.mkstemp('.wav', 'AUDIOCLAS_')[1]
	tmpfile3 = tempfile.mkstemp('.wav', 'AUDIOCLAS_')[1]

	extension = extension.lower()

	# First decompress to wav, using appropriate decoder (sox if none found)
	if extension == ".mp3":
		cmd = 'mpg321 "%s" -w "%s"' % (audiofile, tmpfile)

	elif extension == ".ogg":
		cmd = 'oggdec "%s" -o "%s"' % (audiofile, tmpfile)

	elif extension in [".flac", ".fla"]:
		cmd = 'flac -f -d -s -o %s %s' % (tmpfile, audiofile)

	elif extension in [ ".aiff", ".aif", ".wav", ".au" ]:
		cmd = 'sndfile-convert -pcm16 "%s" "%s"' % (audiofile, tmpfile)

	else:
		cmd = 'sox "%s" "%s"' % (audiofile, tmpfile)

	print "converting to wav"
	print "\tcmd = %s" % cmd

	# Convert to WAV or disired format anyway
	if  call(cmd) != 0:
		# Do a last-ditch try with SOX...
		cmd = 'sox "%s" "%s"' % (audiofile, tmpfile)
		print "conversion failed, trying alternative method with sox"
		print "\tcmd = %s" % cmd
		if call(cmd) != 0:
			print "alternative method: FAILED"
			return -1

	# Change to equal or less than 2 channels
	cmd = '%s -i %s -o %s' % (STEREOFY_EXECUTABLE, tmpfile, tmpfile2)
	print "Conversion n-channel 2 stereo"
	print "\tcmd = %s" % cmd
	if call(cmd) != 0:
		print "conversion n-channel 2 stereo: FAILED"
		return -1

	# Create mp3 preview
	if create_preview(tmpfile2,mp3Preview) != 0:
		return -1

	# Resample and change to mono
	cmd = '/freesound/utils/libsamplerate/examples/sndfile-resample -to %s -c 2 %s %s' % (samplerate, tmpfile2, outfile)
	print "Resampling, Secret Rabbit Code Powered..."
	print "cmd = %s" % cmd;

	if call(cmd) != 0:
		print "downsampling FAILED"
		return -1

	print "Conversion and mp3 preview created."

	return 0


#def compute(mode, filename, descriptorFilename):
def compute(mode, filename, mp3Preview, image, smallImage,descriptorFile,colorFile):
	# first convert our audiofile to a temporary wav file
	tmpfile = tempfile.mkstemp('.wav', 'AUDIOCLAS_')[1]
	if mode == "-all":
		tmpfile2 = tempfile.mkstemp('.dat', 'AUDIOCLAS_')[1]
		spectralTempfile = tempfile.mkstemp('.tmp','AUDIOCLAS_')[1]

	# convert to wave file at channels and freq, no matter what original file was
	if convert_to_wav(filename, tmpfile, 44100,mp3Preview) != 0:
		exitAudioclas(True)

	# calculate descriptors
	cmd = '%s %s %s %s' % (AUDIOCLAS_EXECUTABLE, AUDIOCLAS_CONFIGFILE, tmpfile, descriptorFile)

	if mode == "-all":
		print "calculating descriptors..."
		print "\tcmd = %s" % cmd

		print "=========================== <AUDIOCLAS> ==========================="
		if call(cmd) != 0:
			print "calculating descriptors: FAILED"
			exitAudioclas(True)
		print "=========================== </AUDIOCLAS> ==========================="

	filename = os.path.splitext( filename )[0]

	if mode == "-all":
		cmd = '%s %s %s %s' % (AUDIOCLAS_EXECUTABLE_SPECTRAL_CENTROID, AUDIOCLAS_CONFIGFILE_SPECTRALCENTROID, tmpfile, colorFile)
		print "calculating spectral centroid for whole file..."
		print "\tcmd = %s" % cmd

		# write the spectral centroid in a file
		print "=========================== <AUDIOCLAS> ==========================="
		if call(cmd) != 0:
			print "calculating descriptors: FAILED"
			exitAudioclas(True)
		print "=========================== </AUDIOCLAS> ==========================="

		print "adding [128] to file"
		cmd = "(echo \'[128]\';cat %s) > %s;mv %s %s" % (colorFile,tmpfile2,tmpfile2,colorFile)
		print "cmd = %s" % cmd
		if os.system(cmd) != 0:
			print "adding [128] to file FAILED"
			exitAudioclas(True)
		#tmp = list(file(colorFile))
		#file(colorFile, "w").write("".join(["[128]\n"] + tmp))
		
		# spectralCentroid = '[128]\n%s' % (result_stream.read().strip())
		# spectralCentoidFile = open ( '%s_color.dat' % (filename), 'w' )
		# spectralCentoidFile.write ( spectralCentroid )
		# spectralCentoidFile.close()

	# create PNG file
	print "creating PNG preview, large"
	if mode == "-all":
		cmd = '%s -i %s -o %s -c %s' % (WAV2PNG, tmpfile, image, colorFile)
	else:
		cmd = '%s -i %s -o %s' % (WAV2PNG, tmpfile, image)
	print "\tcmd = %s" % cmd
        if call(cmd) != 0:
		print "PNG creation FAILED"
		exitAudioclas(True)

	print "creating PNG preview, small"
	if mode == "-all":
		cmd = '%s -i %s -o %s -c %s -w 80 -h 41' % (WAV2PNG, tmpfile, smallImage, colorFile)
	else:
		cmd = '%s -i %s -o %s -w 80 -h 41' % (WAV2PNG, tmpfile, smallImage)
	print "\tcmd = %s" % cmd
        if call(cmd) != 0:
		print "PNG creation FAILED"
		exitAudioclas(True)

	# all clear, exit nicely!
	exitAudioclas(False)

if sys.argv[1] == "-all":
	compute(sys.argv[1],sys.argv[2],sys.argv[3],sys.argv[4],sys.argv[5],sys.argv[6],sys.argv[7])
else:
	compute(sys.argv[1],sys.argv[2],sys.argv[3],sys.argv[4],sys.argv[5],"","")

########NEW FILE########
