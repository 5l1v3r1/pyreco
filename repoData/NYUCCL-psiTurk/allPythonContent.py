__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# psiturk documentation build configuration file, created by
# sphinx-quickstart on Tue Feb 25 16:11:11 2014.
#
# This file is execfile()d with the current directory set to its
# containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys
import os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration ------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.doctest',
    'sphinx.ext.intersphinx',
    'sphinx.ext.todo',
    'sphinx.ext.coverage',
    'sphinx.ext.pngmath',
    'sphinx.ext.mathjax',
    'sphinx.ext.ifconfig',
    'sphinx.ext.viewcode',
]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'psiturk'
copyright = u'2014, McDonnell, J.V., Martin, J.B., Markant, D.B., Coenen, A., Rich, A.S., and Gureckis, T.M.'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '2.0'
# The full version, including alpha/beta/rc tags.
release = '2.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all
# documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
#keep_warnings = False


# -- Options for HTML output ----------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# Add any extra paths that contain custom files (such as robots.txt or
# .htaccess) here, relative to this directory. These files are copied
# directly to the root of the documentation.
#html_extra_path = []

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'psiturkdoc'


# -- Options for LaTeX output ---------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title,
#  author, documentclass [howto, manual, or own class]).
latex_documents = [
  ('index', 'psiturk.tex', u'psiturk Documentation',
   u'McDonnell, J.V., Martin, J.B., Markant, D.B., Coenen, A., Rich, A.S., and Gureckis, T.M.', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output ---------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'psiturk', u'psiturk Documentation',
     [u'McDonnell, J.V., Martin, J.B., Markant, D.B., Coenen, A., Rich, A.S., and Gureckis, T.M.'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output -------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'psiturk', u'psiturk Documentation',
   u'McDonnell, J.V., Martin, J.B., Markant, D.B., Coenen, A., Rich, A.S., and Gureckis, T.M.', 'psiturk', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
#texinfo_no_detailmenu = False


# -- Options for Epub output ----------------------------------------------

# Bibliographic Dublin Core info.
epub_title = u'psiturk'
epub_author = u'McDonnell, J.V., Martin, J.B., Markant, D.B., Coenen, A., Rich, A.S., and Gureckis, T.M.'
epub_publisher = u'McDonnell, J.V., Martin, J.B., Markant, D.B., Coenen, A., Rich, A.S., and Gureckis, T.M.'
epub_copyright = u'2014, McDonnell, J.V., Martin, J.B., Markant, D.B., Coenen, A., Rich, A.S., and Gureckis, T.M.'

# The basename for the epub file. It defaults to the project name.
#epub_basename = u'psiturk'

# The HTML theme for the epub output. Since the default themes are not optimized
# for small screen space, using the same theme for HTML and epub output is
# usually not wise. This defaults to 'epub', a theme designed to save visual
# space.
#epub_theme = 'epub'

# The language of the text. It defaults to the language option
# or en if the language is not set.
#epub_language = ''

# The scheme of the identifier. Typical schemes are ISBN or URL.
#epub_scheme = ''

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
#epub_identifier = ''

# A unique identification for the text.
#epub_uid = ''

# A tuple containing the cover image and cover page html template filenames.
#epub_cover = ()

# A sequence of (type, uri, title) tuples for the guide element of content.opf.
#epub_guide = ()

# HTML files that should be inserted before the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_pre_files = []

# HTML files shat should be inserted after the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_post_files = []

# A list of files that should not be packed into the epub file.
epub_exclude_files = ['search.html']

# The depth of the table of contents in toc.ncx.
#epub_tocdepth = 3

# Allow duplicate toc entries.
#epub_tocdup = True

# Choose between 'default' and 'includehidden'.
#epub_tocscope = 'default'

# Fix unsupported image types using the PIL.
#epub_fix_images = False

# Scale large images.
#epub_max_image_width = 0

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#epub_show_urls = 'inline'

# If false, no index is generated.
#epub_use_index = True


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/': None}

########NEW FILE########
__FILENAME__ = amt_services
import os, sys
import subprocess,signal
from threading import Thread, Event
import urllib2
import string
import datetime
import boto.rds
import boto.ec2
from boto.exception import EC2ResponseError
from boto.rds import RDSConnection
from boto.mturk.connection import MTurkConnection, MTurkRequestError
from boto.mturk.question import ExternalQuestion
from boto.mturk.qualification import LocaleRequirement, \
    PercentAssignmentsApprovedRequirement, Qualifications
from flask import jsonify
import socket
import webbrowser
import re as re


MYSQL_RESERVED_WORDS_CAP = ['ACCESSIBLE','ADD','ALL','ALTER','ANALYZE','AND','AS','ASC','ASENSITIVE','BEFORE','BETWEEN','BIGINT', 'BINARY','BLOB','BOTH','BY','CALL','CASCADE','CASE','CHANGE','CHAR','CHARACTER','CHECK','COLLATE','COLUMN','CONDITION','CONSTRAINT','CONTINUE','CONVERT','CREATE','CROSS','CURRENT_DATE','CURRENT_TIME','CURRENT_TIMESTAMP','CURRENT_USER','CURSOR','DATABASE','DATABASES','DAY_HOUR','DAY_MICROSECOND','DAY_MINUTE','DAY_SECOND','DEC','DECIMAL','DECLARE','DEFAULT','DELAYED','DELETE','DESC','DESCRIBE','DETERMINISTIC','DISTINCT','DISTINCTROW','DIV','DOUBLE','DROP','DUAL','EACH','ELSE','ELSEIF','ENCLOSED','ESCAPED','EXISTS','EXIT','EXPLAIN','FALSE','FETCH','FLOAT','FLOAT4','FLOAT8','FOR','FORCE','FOREIGN','FROM','FULLTEXT','GET','GRANT','GROUP','HAVING','HIGH_PRIORITY','HOUR_MICROSECOND','HOUR_MINUTE','HOUR_SECOND','IF','IGNORE','IN','INDEX','INFILE','INNER','INOUT','INSENSITIVE','INSERT','INT','INT1','INT2','INT3','INT4','INT8','INTEGER','INTERVAL','INTO','IO_AFTER_GTIDS','IO_BEFORE_GTIDS','IS','ITERATE','JOIN','KEY','KEYS','KILL','LEADING','LEAVE','LEFT','LIKE','LIMIT','LINEAR','LINES','LOAD','LOCALTIME','LOCALTIMESTAMP','LOCK','LONG','LONGBLOB','LONGTEXT','LOOP','LOW_PRIORITY','MASTER_BIND','MASTER_SSL_VERIFY_SERVER_CERT','MATCH','MAXVALUE','MEDIUMBLOB','MEDIUMINT','MEDIUMTEXT','MIDDLEINT','MINUTE_MICROSECOND','MINUTE_SECOND','MOD','MODIFIES','NATURAL','NOT','NO_WRITE_TO_BINLOG','NULL','NUMERIC','ON','OPTIMIZE','OPTION','OPTIONALLY','OR','ORDER','OUT','OUTER','OUTFILE','PARTITION','PRECISION','PRIMARY','PROCEDURE','PURGE','RANGE','READ','READS','READ_WRITE','REAL','REFERENCES','REGEXP','RELEASE','RENAME','REPEAT','REPLACE','REQUIRE','RESIGNAL','RESTRICT','RETURN','REVOKE','RIGHT','RLIKE','SCHEMA','SCHEMAS','SECOND_MICROSECOND','SELECT','SENSITIVE','SEPARATOR','SET','SHOW','SIGNAL','SMALLINT','SPATIAL','SPECIFIC','SQL','SQLEXCEPTION','SQLSTATE','SQLWARNING','SQL_BIG_RESULT','SQL_CALC_FOUND_ROWS','SQL_SMALL_RESULT','SSL','STARTING','STRAIGHT_JOIN','TABLE','TERMINATED','THEN','TINYBLOB','TINYINT','TINYTEXT','TO','TRAILING','TRIGGER','TRUE','UNDO','UNION','UNIQUE','UNLOCK','UNSIGNED','UPDATE','USAGE','USE','USING','UTC_DATE','UTC_TIME','UTC_TIMESTAMP','VALUES','VARBINARY','VARCHAR','VARCHARACTER','VARYING','WHEN','WHERE','WHILE','WITH','WRITE','XOR','YEAR_MONTH','ZEROFILL']
MYSQL_RESERVED_WORDS = [word.lower() for word in MYSQL_RESERVED_WORDS_CAP]

class MTurkHIT:

    def __init__(self, json_options):
        self.options = json_options

    def __repr__(self):
        return "%s \n\tStatus: %s \n\tHITid: %s \n\tmax:%s/pending:%s/complete:%s/remain:%s \n\tCreated:%s \n\tExpires:%s\n" % (
            self.options['title'],
            self.options['status'],
            self.options['hitid'],
            self.options['max_assignments'],
            self.options['number_assignments_pending'],
            self.options['number_assignments_completed'],
            self.options['number_assignments_available'],
            self.options['creation_time'],
            self.options['expiration'])

class RDSServices:

    def __init__(self, aws_access_key_id, aws_secret_access_key, region='us-east-1'):
        self.update_credentials(aws_access_key_id, aws_secret_access_key)
        self.set_region(region)
        self.validLogin = self.verify_aws_login()
        # if not self.validLogin:
        #     print 'Sorry, AWS Credentials invalid.\nYou will only be able to '\
        #           + 'test experiments locally until you enter\nvalid '\
        #           + 'credentials in the AWS Access section of config.txt.'

    def update_credentials(self, aws_access_key_id, aws_secret_access_key):
        self.aws_access_key_id = aws_access_key_id
        self.aws_secret_access_key = aws_secret_access_key

    def list_regions(self):
        regions = boto.rds.regions()
        return [reg.name for reg in regions]

    def get_region(self):
        return self.region

    def set_region(self, region):
        self.region = region

    def verify_aws_login(self):
        if (self.aws_access_key_id == 'YourAccessKeyId') or (self.aws_secret_access_key == 'YourSecretAccessKey'):
            return False
        else:
            # rdsparams = dict(
            #     aws_access_key_id=self.aws_access_key_id,
            #     aws_secret_access_key=self.aws_secret_access_key,
            #     region=self.region)
            # self.rdsc = RDSConnection(**rdsparams)
            self.rdsc = boto.rds.connect_to_region(self.region, aws_access_key_id=self.aws_access_key_id, aws_secret_access_key=self.aws_secret_access_key)
            try:
                self.rdsc.get_all_dbinstances()
            except MTurkRequestError as e:
                print(e.error_message)
                return False
            except AttributeError:
                print "*** Unable to establish connection to AWS region %s using your access key/secret key", self.region
                return False
            except boto.exception.BotoServerError:
                print "***********************************************************"
                print "WARNING"
                print "Unable to establish connection to AWS."
                print "While your keys may be valid, your AWS account needs a "
                print "subscription to certain services.  If you haven't been asked"
                print "to provide a credit card and verified your account using your "
                print "phone, it means your keys are not completely set up yet."
                print "Please refer to "
                print "\thttp://psiturk.readthedocs.org/en/latest/amt_setup.html"
                print "***********************************************************"
                return False
            else:
                return True

    def connect_to_aws_rds(self):
        if not self.validLogin:
            print 'Sorry, unable to connect to Amazon\'s RDS database server.  AWS credentials invalid.'
            return False
        # rdsparams = dict(
        #     aws_access_key_id = self.aws_access_key_id,
        #     aws_secret_access_key = self.aws_secret_access_key,
        #     region=self.region)
        # self.rdsc = RDSConnection(**rdsparams)
        self.rdsc = boto.rds.connect_to_region(self.region, aws_access_key_id=self.aws_access_key_id, aws_secret_access_key=self.aws_secret_access_key)
        return True

    def get_db_instance_info(self, dbid):
        if not self.connect_to_aws_rds():
            return False
        try:
            instances = self.rdsc.get_all_dbinstances(dbid)
        except:
            return False
        else:
            myinstance = instances[0]
            return myinstance

    def allow_access_to_instance(self, instance, ip_address):
        if not self.connect_to_aws_rds():
            return False
        try:
            conn = boto.ec2.connect_to_region(self.region, aws_access_key_id=self.aws_access_key_id, aws_secret_access_key=self.aws_secret_access_key)
            sgs = conn.get_all_security_groups('default')
            default_sg = sgs[0]
            default_sg.authorize(ip_protocol='tcp', from_port=3306, to_port=3306, cidr_ip=str(ip_address)+'/32')
        except EC2ResponseError, e:
            if e.error_code=="InvalidPermission.Duplicate":
                return True  # ok it already exists
            else:
                return False
        else:
            return True



    def get_db_instances(self):
        if not self.connect_to_aws_rds():
            return False
        try:
            instances = self.rdsc.get_all_dbinstances()
        except:
            return False
        else:
            return instances

    def delete_db_instance(self, dbid):
        if not self.connect_to_aws_rds():
            return False
        try:
            db = self.rdsc.delete_dbinstance(dbid, skip_final_snapshot=True)
            print db
        except:
            return False
        else:
            return True

    def validate_instance_id(self, instid):
        # 1-63 alphanumeric characters, first must be a letter.
        if re.match('[\w-]+$', instid) is not None:
            if len(instid) <=63 and len(instid)>=1:
                if instid[0].isalpha():
                    return True
        return "*** Error: Instance ids must be 1-63 alphanumeric characters, first is a letter."

    def validate_instance_size(self, size):
        # integer between 5-1024 (inclusive)
        try:
            int(size)
        except ValueError:
            return '*** Error: size must be a whole number between 5 and 1024.'
        if int(size) < 5 or int(size) > 1024:
            return '*** Error: size must be between 5-1024 GB.'
        return True

    def validate_instance_username(self, username):
        # 1-16 alphanumeric characters - first character must be a letter - cannot be a reserved MySQL word
        if re.match('[\w-]+$', username) is not None:
            if len(username) <=16 and len(username)>=1:
                if username[0].isalpha():
                    if username not in MYSQL_RESERVED_WORDS:
                        return True
        return '*** Error: Usernames must be 1-16 alphanumeric chracters, first a letter, cannot be reserved MySQL word.'

    def validate_instance_password(self, password):
        # 1-16 alphanumeric characters - first character must be a letter - cannot be a reserved MySQL word
        if re.match('[\w-]+$', password) is not None:
            if len(password) <=41 and len(password)>=8:
                return True
        return '*** Error: Passwords must be 8-41 alphanumeric characters'

    def validate_instance_dbname(self, dbname):
        # 1-64 alphanumeric characters, cannot be a reserved MySQL word
        if re.match('[\w-]+$', dbname) is not None:
            if len(dbname) <=41 and len(dbname)>=1:
                if dbname.lower() not in MYSQL_RESERVED_WORDS:
                    return True
        return '*** Error: Database names must be 1-64 alphanumeric characters, cannot be a reserved MySQL word.'

    def create_db_instance(self, params):
        if not self.connect_to_aws_rds():
            return False
        try:
            db = self.rdsc.create_dbinstance(
                    id = params['id'],
                    allocated_storage = params['size'],
                    instance_class = 'db.t1.micro',
                    engine = 'MySQL',
                    master_username = params['username'],
                    master_password = params['password'],
                    db_name = params['dbname'],
                    multi_az = False
                )
        except:
            return False
        else:
            return True



class MTurkServices:
    def __init__(self, aws_access_key_id, aws_secret_access_key, is_sandbox):
        self.update_credentials(aws_access_key_id, aws_secret_access_key)
        self.set_sandbox(is_sandbox)
        self.validLogin = self.verify_aws_login()
        if not self.validLogin:
            print 'WARNING *****************************'
            print 'Sorry, AWS Credentials invalid.\nYou will only be able to '\
                  + 'test experiments locally until you enter\nvalid '\
                  + 'credentials in the AWS Access section of ~/.psiturkconfig\n'

    def update_credentials(self, aws_access_key_id, aws_secret_access_key):
        self.aws_access_key_id = aws_access_key_id
        self.aws_secret_access_key = aws_secret_access_key

    def set_sandbox(self, is_sandbox):
        self.is_sandbox = is_sandbox

    def get_reviewable_hits(self):
        if not self.connect_to_turk():
            return False
        try:
            hits = self.mtc.get_all_hits()
        except MTurkRequestError:
            return False
        reviewable_hits = [hit for hit in hits if (hit.HITStatus == "Reviewable" or hit.HITStatus == "Reviewing")]
        hits_data = [MTurkHIT({'hitid': hit.HITId,
                      'title': hit.Title,
                      'status': hit.HITStatus,
                      'max_assignments': hit.MaxAssignments,
                      'number_assignments_completed': hit.NumberOfAssignmentsCompleted,
                      'number_assignments_pending': hit.NumberOfAssignmentsPending,
                      'number_assignments_available': hit.NumberOfAssignmentsAvailable,
                      'creation_time': hit.CreationTime,
                      'expiration': hit.Expiration,
                      }) for hit in reviewable_hits]
        return(hits_data)

    def get_all_hits(self):
        if not self.connect_to_turk():
            return False
        try:
            hits = self.mtc.get_all_hits()
        except MTurkRequestError:
            return False
        hits_data = [MTurkHIT({'hitid': hit.HITId,
                      'title': hit.Title,
                      'status': hit.HITStatus,
                      'max_assignments': hit.MaxAssignments,
                      'number_assignments_completed': hit.NumberOfAssignmentsCompleted,
                      'number_assignments_pending': hit.NumberOfAssignmentsPending,
                      'number_assignments_available': hit.NumberOfAssignmentsAvailable,
                      'creation_time': hit.CreationTime,
                      'expiration': hit.Expiration,
                      }) for hit in hits]
        return(hits_data)

    def get_active_hits(self):
        if not self.connect_to_turk():
            return False
        # hits = self.mtc.search_hits()
        try:
            hits = self.mtc.get_all_hits()
        except MTurkRequestError:
            return False
        active_hits = [hit for hit in hits if not(hit.expired)]
        hits_data = [MTurkHIT({'hitid': hit.HITId,
                      'title': hit.Title,
                      'status': hit.HITStatus,
                      'max_assignments': hit.MaxAssignments,
                      'number_assignments_completed': hit.NumberOfAssignmentsCompleted,
                      'number_assignments_pending': hit.NumberOfAssignmentsPending,
                      'number_assignments_available': hit.NumberOfAssignmentsAvailable,
                      'creation_time': hit.CreationTime,
                      'expiration': hit.Expiration,
                      }) for hit in active_hits]
        return(hits_data)

    def get_workers(self, assignmentStatus = None):
        if not self.connect_to_turk():
            return False
        try:
            hits = self.mtc.search_hits(sort_direction='Descending', page_size=20)
            hit_ids = [hit.HITId for hit in hits]
            workers_nested = [self.mtc.get_assignments(
                                hit_id,
                                status=assignmentStatus,
                                sort_by='SubmitTime',
                                page_size=100
                              ) for hit_id in hit_ids]

            workers = [val for subl in workers_nested for val in subl]  # Flatten nested lists
        except MTurkRequestError:
            return(False)
        worker_data = [{'hitId': worker.HITId,
                        'assignmentId': worker.AssignmentId,
                        'workerId': worker.WorkerId,
                        'submit_time': worker.SubmitTime,
                        'accept_time': worker.AcceptTime,
                        'status': worker.AssignmentStatus
                       } for worker in workers]
        return(worker_data)


    def bonus_worker(self, assignment_id, amount, reason=""):
        if not self.connect_to_turk():
            return False
        try:
            bonus = MTurkConnection.get_price_as_price(amount)
            assignment = self.mtc.get_assignment(assignment_id)[0]
            workerId = assignment.WorkerId
            self.mtc.grant_bonus(workerId, assignment_id, bonus, reason)
            return True
        except MTurkRequestError as e:
            print e
            return False


    def approve_worker(self, assignment_id):
        if not self.connect_to_turk():
            return(False)
        try:
            self.mtc.approve_assignment(assignment_id, feedback=None)
            return True
        except MTurkRequestError:
            return(False)

    def reject_worker(self, assignment_id):
        if not self.connect_to_turk():
            return False
        try:
            self.mtc.reject_assignment(assignment_id, feedback=None)
            return True
        except MTurkRequestError:
            return(False)

    def unreject_worker(self, assignment_id):
        if not self.connect_to_turk():
            return False
        try:
            self.mtc.approve_rejected_assignment(assignment_id)
            return True
        except MTurkRequestError:
            return False

    def verify_aws_login(self):
        if (self.aws_access_key_id == 'YourAccessKeyId') or (self.aws_secret_access_key == 'YourSecretAccessKey'):
            return False
        else:
            host = 'mechanicalturk.amazonaws.com'
            mturkparams = dict(
                aws_access_key_id=self.aws_access_key_id,
                aws_secret_access_key=self.aws_secret_access_key,
                host=host)
            self.mtc = MTurkConnection(**mturkparams)
            try:
                self.mtc.get_account_balance()
            except MTurkRequestError as e:
                print(e.error_message)
                return False
            else:
                return True


    def connect_to_turk(self):
        if not self.validLogin:
            print 'Sorry, unable to connect to Amazon Mechanical Turk. AWS credentials invalid.'
            return False
        if self.is_sandbox:
            host = 'mechanicalturk.sandbox.amazonaws.com'
        else:
            host = 'mechanicalturk.amazonaws.com'

        mturkparams = dict(
            aws_access_key_id = self.aws_access_key_id,
            aws_secret_access_key = self.aws_secret_access_key,
            host=host)
        self.mtc = MTurkConnection(**mturkparams)
        return True

    def configure_hit(self, hit_config):

        # configure question_url based on the id
        experimentPortalURL = hit_config['ad_location']
        frameheight = 600
        mturkQuestion = ExternalQuestion(experimentPortalURL, frameheight)

        # Qualification:
        quals = Qualifications()
        approve_requirement = hit_config['approve_requirement']
        quals.add(
            PercentAssignmentsApprovedRequirement("GreaterThanOrEqualTo",
                                                  approve_requirement))

        if hit_config['us_only']:
            quals.add(LocaleRequirement("EqualTo", "US"))

        # Specify all the HIT parameters
        self.paramdict = dict(
            hit_type = None,
            question = mturkQuestion,
            lifetime = hit_config['lifetime'],
            max_assignments = hit_config['max_assignments'],
            title = hit_config['title'],
            description = hit_config['description'],
            keywords = hit_config['keywords'],
            reward = hit_config['reward'],
            duration = hit_config['duration'],
            approval_delay = None,
            questions = None,
            qualifications = quals
        )

    def check_balance(self):
        if not self.connect_to_turk():
            return('-')
        return(self.mtc.get_account_balance()[0])

    # TODO (if valid AWS credentials haven't been provided then connect_to_turk() will
    # fail, not error checking here and elsewhere)
    def create_hit(self, hit_config):
        try:
            if not self.connect_to_turk():
                return False
            self.configure_hit(hit_config)
            myhit = self.mtc.create_hit(**self.paramdict)[0]
            self.hitid = myhit.HITId
        except:
            return False
        else:
            return self.hitid

    # TODO(Jay): Have a wrapper around functions that serializes them.
    # Default output should not be serialized.
    def expire_hit(self, hitid):
        if not self.connect_to_turk():
            return False
        try:
            self.mtc.expire_hit(hitid)
            return True
        except MTurkRequestError:
            print "Failed to expire HIT. Please check the ID and try again."
            return False

    def dispose_hit(self, hitid):
        if not self.connect_to_turk():
            return False
        try:
            self.mtc.dispose_hit(hitid)
        except Exception, e:
            print 'Failed to dispose of HIT %s. Make sure there are no assignments remaining to be reviewed' % hitid

    def extend_hit(self, hitid, assignments_increment=None, expiration_increment=None):
        if not self.connect_to_turk():
            return False
        try:
            self.mtc.extend_hit(hitid, assignments_increment=int(assignments_increment or 0))
            self.mtc.extend_hit(hitid, expiration_increment=int(expiration_increment or 0)*60)
            return True
        except Exception, e:
            print "Failed to extend HIT %s. Please check the ID and try again." % hitid
            return False

    def get_hit_status(self, hitid):
        if not self.connect_to_turk():
            return False
        try:
            hitdata = self.mtc.get_hit(hitid)
        except:
            return False
        return hitdata[0].HITStatus

    def get_summary(self):
      try:
          balance = self.check_balance()
          summary = jsonify(balance=str(balance))
          return(summary)
      except MTurkRequestError as e:
          print(e.error_message)
          return(False)

########NEW FILE########
__FILENAME__ = command_line
import argparse
import sys, os
from version import version_number 
from psiturk_config import PsiturkConfig
from psiturk_org_services import ExperimentExchangeServices

def process():
	# figure out how we were invoked
	invoked_as = os.path.basename(sys.argv[0])

	if (invoked_as == "psiturk"):
		launch_shell()
	elif (invoked_as == "psiturk-server"):
		launch_server()
	elif (invoked_as == "psiturk-shell"):
		launch_shell()
	elif (invoked_as == "psiturk-setup-example"):
		setup_example()
	elif (invoked_as == "psiturk-install"):
		install_from_exchange()

def install_from_exchange():
	parser = argparse.ArgumentParser(description='Download experiment from the psiturk.org experiment exchange (http://psiturk.org/ee).')
	parser.add_argument('exp_id', metavar='exp_id', type=str, help='the id number of the experiment in the exchange')
	args = parser.parse_args()
	config = PsiturkConfig()
	ee = ExperimentExchangeServices()
	ee.download_experiment(args.exp_id)

def setup_example():
	# add commands for testing, etc..
	parser = argparse.ArgumentParser(description='Creates a simple default project (stroop) in the current directory with the necessary psiTurk files.')

	# optional flags
	parser.add_argument('-v', '--version', help='Print version number.', action="store_true")
	args = parser.parse_args()

	# if requested version just print and quite
	if args.version:
		print version_number
	else:
		import setup_example as se
		se.setup_example()

def launch_server():
	# add commands for testing, etc..
	parser = argparse.ArgumentParser(description='Launch psiTurk experiment webserver process on the host/port defined in config.txt.')

	# optional flags
	parser.add_argument('-v', '--version', help='Print version number.', action="store_true")
	args = parser.parse_args()

	# if requested version just print and quite
	if args.version:
		print version_number
	else:
		import experiment_server as es
		es.launch()

def launch_shell():
	# add commands for testing, etc..
	parser = argparse.ArgumentParser(description='Launch the psiTurk interactive shell.')

	# optional flags
	parser.add_argument('-v', '--version', help='Print version number.', action="store_true")
	parser.add_argument('-c', '--cabinmode', help='Launch psiturk in cabin (offline) mode', action="store_true")
        parser.add_argument('-s', '--script', help = 'Run commands from a script file')
	args = parser.parse_args()
	# if requested version just print and quite
	if args.version:
		print version_number
	else:
		import psiturk_shell as ps
                if args.script:
                        ps.run(cabinmode=args.cabinmode, script=args.script)
                else:
                        ps.run(cabinmode=args.cabinmode)

########NEW FILE########
__FILENAME__ = counter
# Code from Raymond Hettinger
# http://code.activestate.com/recipes/576611-counter-class/
# Redistributed under the terms of the MIT license.
# (intended to reproduce the behavior of collections.Counter in Python>=2.7)

from operator import itemgetter
from heapq import nlargest
from itertools import repeat, ifilter

class Counter(dict):
    '''Dict subclass for counting hashable objects.  Sometimes called a bag
    or multiset.  Elements are stored as dictionary keys and their counts
    are stored as dictionary values.

    >>> Counter('zyzygy')
    Counter({'y': 3, 'z': 2, 'g': 1})

    '''

    def __init__(self, iterable=None, **kwds):
        '''Create a new, empty Counter object.  And if given, count elements
        from an input iterable.  Or, initialize the count from another mapping
        of elements to their counts.

        >>> c = Counter()                           # a new, empty counter
        >>> c = Counter('gallahad')                 # a new counter from an iterable
        >>> c = Counter({'a': 4, 'b': 2})           # a new counter from a mapping
        >>> c = Counter(a=4, b=2)                   # a new counter from keyword args

        '''        
        self.update(iterable, **kwds)

    def __missing__(self, key):
        return 0

    def most_common(self, n=None):
        '''List the n most common elements and their counts from the most
        common to the least.  If n is None, then list all element counts.

        >>> Counter('abracadabra').most_common(3)
        [('a', 5), ('r', 2), ('b', 2)]

        '''        
        if n is None:
            return sorted(self.iteritems(), key=itemgetter(1), reverse=True)
        return nlargest(n, self.iteritems(), key=itemgetter(1))

    def elements(self):
        '''Iterator over elements repeating each as many times as its count.

        >>> c = Counter('ABCABC')
        >>> sorted(c.elements())
        ['A', 'A', 'B', 'B', 'C', 'C']

        If an element's count has been set to zero or is a negative number,
        elements() will ignore it.

        '''
        for elem, count in self.iteritems():
            for _ in repeat(None, count):
                yield elem

    # Override dict methods where the meaning changes for Counter objects.

    @classmethod
    def fromkeys(cls, iterable, v=None):
        raise NotImplementedError(
            'Counter.fromkeys() is undefined.  Use Counter(iterable) instead.')

    def update(self, iterable=None, **kwds):
        '''Like dict.update() but add counts instead of replacing them.

        Source can be an iterable, a dictionary, or another Counter instance.

        >>> c = Counter('which')
        >>> c.update('witch')           # add elements from another iterable
        >>> d = Counter('watch')
        >>> c.update(d)                 # add elements from another counter
        >>> c['h']                      # four 'h' in which, witch, and watch
        4

        '''        
        if iterable is not None:
            if hasattr(iterable, 'iteritems'):
                if self:
                    self_get = self.get
                    for elem, count in iterable.iteritems():
                        self[elem] = self_get(elem, 0) + count
                else:
                    dict.update(self, iterable) # fast path when counter is empty
            else:
                self_get = self.get
                for elem in iterable:
                    self[elem] = self_get(elem, 0) + 1
        if kwds:
            self.update(kwds)

    def copy(self):
        'Like dict.copy() but returns a Counter instance instead of a dict.'
        return Counter(self)

    def __delitem__(self, elem):
        'Like dict.__delitem__() but does not raise KeyError for missing values.'
        if elem in self:
            dict.__delitem__(self, elem)

    def __repr__(self):
        if not self:
            return '%s()' % self.__class__.__name__
        items = ', '.join(map('%r: %r'.__mod__, self.most_common()))
        return '%s({%s})' % (self.__class__.__name__, items)

    # Multiset-style mathematical operations discussed in:
    #       Knuth TAOCP Volume II section 4.6.3 exercise 19
    #       and at http://en.wikipedia.org/wiki/Multiset
    #
    # Outputs guaranteed to only include positive counts.
    #
    # To strip negative and zero counts, add-in an empty counter:
    #       c += Counter()

    def __add__(self, other):
        '''Add counts from two counters.

        >>> Counter('abbb') + Counter('bcc')
        Counter({'b': 4, 'c': 2, 'a': 1})


        '''
        if not isinstance(other, Counter):
            return NotImplemented
        result = Counter()
        for elem in set(self) | set(other):
            newcount = self[elem] + other[elem]
            if newcount > 0:
                result[elem] = newcount
        return result

    def __sub__(self, other):
        ''' Subtract count, but keep only results with positive counts.

        >>> Counter('abbbc') - Counter('bccd')
        Counter({'b': 2, 'a': 1})

        '''
        if not isinstance(other, Counter):
            return NotImplemented
        result = Counter()
        for elem in set(self) | set(other):
            newcount = self[elem] - other[elem]
            if newcount > 0:
                result[elem] = newcount
        return result

    def __or__(self, other):
        '''Union is the maximum of value in either of the input counters.

        >>> Counter('abbb') | Counter('bcc')
        Counter({'b': 3, 'c': 2, 'a': 1})

        '''
        if not isinstance(other, Counter):
            return NotImplemented
        _max = max
        result = Counter()
        for elem in set(self) | set(other):
            newcount = _max(self[elem], other[elem])
            if newcount > 0:
                result[elem] = newcount
        return result

    def __and__(self, other):
        ''' Intersection is the minimum of corresponding counts.

        >>> Counter('abbb') & Counter('bcc')
        Counter({'b': 1})

        '''
        if not isinstance(other, Counter):
            return NotImplemented
        _min = min
        result = Counter()
        if len(self) < len(other):
            self, other = other, self
        for elem in ifilter(self.__contains__, other):
            newcount = _min(self[elem], other[elem])
            if newcount > 0:
                result[elem] = newcount
        return result


if __name__ == '__main__':
    import doctest
    print doctest.testmod()

########NEW FILE########
__FILENAME__ = db

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, scoped_session
from sqlalchemy.ext.declarative import declarative_base

from psiturk_config import PsiturkConfig

config = PsiturkConfig()
config.load_config()

DATABASE = config.get('Database Parameters', 'database_url')

engine = create_engine(DATABASE, echo=False) 
db_session = scoped_session(sessionmaker(autocommit=False,
                                         autoflush=False,
                                         bind=engine))

Base = declarative_base()
Base.query = db_session.query_property()

def init_db():
    #print "Initalizing db if necessary."
    Base.metadata.create_all(bind=engine)

########NEW FILE########
__FILENAME__ = experiment
import os
import sys
import datetime
import logging
from random import choice
import user_agents
import string
import requests
try:
    from collections import Counter
except ImportError:
    from counter import Counter

# Importing flask
from flask import Flask, render_template, render_template_string, request, jsonify

# Database setup
from db import db_session, init_db
from models import Participant
from sqlalchemy import or_

from psiturk_config import PsiturkConfig
from experiment_errors import ExperimentError
from psiturk.user_utils import nocache

config = PsiturkConfig()
config.load_config()

# Set up logging
logfilepath = os.path.join(os.getcwd(),
                           config.get("Server Parameters", "logfile"))

loglevels = [logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR, logging.CRITICAL]
loglevel = loglevels[config.getint('Server Parameters', 'loglevel')]
logging.basicConfig( filename=logfilepath, format='%(asctime)s %(message)s', level=loglevel )


# Status codes
NOT_ACCEPTED = 0
ALLOCATED = 1
STARTED = 2
COMPLETED = 3
SUBMITTED = 4
CREDITED = 5
QUITEARLY = 6
BONUSED = 7

###########################################################
# let's start
###########################################################
app = Flask("Experiment_Server")
def start_app(sandbox):
    global sandbox_bool
    sandbox_bool = sandbox
    return app
app.config.update(SEND_FILE_MAX_AGE_DEFAULT=10) # set cache timeout to 10ms for static files

###########################################################
#  serving warm, fresh, & sweet custom, user-provided routes
###########################################################

try:
    sys.path.append(os.getcwd())
    from custom import custom_code
except ImportError:
    app.logger.info( "Hmm... it seems no custom code (custom.py) assocated with this project.")
else:
    app.register_blueprint(custom_code)

try:
    sys.path.append(os.getcwd())
    from custom_models import *
except ImportError:
    app.logger.info( "Hmm... it seems no custom model code (custom_models.py) assocated with this project.")

init_db()

# read psiturk.js file into memory
psiturk_js_file = os.path.join(os.path.dirname(__file__), "psiturk_js/psiturk.js")
app.logger.error( psiturk_js_file )

if os.path.exists(psiturk_js_file):
    psiturk_js_code = open(psiturk_js_file).read()
else:
    psiturk_js_code = "alert('psiturk.js file not found!');"

#----------------------------------------------
# favicon
#----------------------------------------------
@app.route('/favicon.ico')
def favicon():
    """
    Serving a favicon
    """
    return app.send_static_file('favicon.ico')

@app.errorhandler(ExperimentError)
def handleExpError(e):
    """Handle errors by sending an error page."""
    return e.error_page( request, config.get('HIT Configuration', 'contact_email_on_error') )

@app.route('/static/js/psiturk.js')
def psiturk_js():
    return render_template_string(psiturk_js_code)

#----------------------------------------------
# DB setup
#----------------------------------------------
@app.teardown_request
def shutdown_session(exception=None):
    db_session.remove()

#----------------------------------------------
# Experiment counterbalancing code.
#----------------------------------------------
def get_random_condcount():
    """
    HITs can be in one of three states:
        - jobs that are finished
        - jobs that are started but not finished
        - jobs that are never going to finish (user decided not to do it)
    Our count should be based on the first two, so we count any tasks finished
    or any tasks not finished that were started in the last cutoff_time
    minutes, as specified in the cutoff_time variable in the config file.

    Returns a tuple: (cond, condition)
    """
    cutofftime = datetime.timedelta(minutes=-config.getint('Server Parameters', 'cutoff_time'))
    starttime = datetime.datetime.now() + cutofftime

    numconds = config.getint('Task Parameters', 'num_conds')
    numcounts = config.getint('Task Parameters', 'num_counters')

    participants = Participant.query.\
                   filter(Participant.codeversion == config.get('Task Parameters', 'experiment_code_version')).\
                   filter(or_(Participant.status == COMPLETED,
                              Participant.status == CREDITED,
                              Participant.status == SUBMITTED,
                              Participant.status == BONUSED,
                              Participant.beginhit > starttime)).\
                   all()
    counts = Counter()
    for cond in range(numconds):
        for counter in range(numcounts):
            counts[(cond, counter)] = 0
    for p in participants:
        counts[(p.cond, p.counterbalance)] += 1
    mincount = min( counts.values() )
    minima = [hsh for hsh, count in counts.iteritems() if count == mincount]
    chosen = choice(minima)
    #conds += [ 0 for _ in range(1000) ]
    #conds += [ 1 for _ in range(1000) ]
    app.logger.info( "given %(a)s chose %(b)s" % {'a': counts, 'b': chosen})

    return chosen

#----------------------------------------------
# routes
#----------------------------------------------
@app.route('/')
@nocache
def index():
    return render_template('default.html')

@app.route('/check_worker_status', methods=['GET'])
def check_worker_status():
    if 'workerId' not in request.args:
        resp = {"status": "bad request"}
        return jsonify(**resp)
    else:
        workerId = request.args['workerId']
        try:
            part = Participant.query.\
                   filter(Participant.workerid == workerId).\
                   one()
            status = part.status
        except:
            status = NOT_ACCEPTED
        resp = {"status" : status}
        return jsonify(**resp)


@app.route('/ad', methods=['GET'])
@nocache
def advertisement():
    """
    This is the url we give for the ad for our 'external question'.
    The ad has to display two different things:
    This page will be called from within mechanical turk, with url arguments
    hitId, assignmentId, and workerId.
    If the worker has not yet accepted the hit:
      These arguments will have null values, we should just show an ad for the
      experiment.
    If the worker has accepted the hit:
      These arguments will have appropriate values and we should enter the person
      in the database and provide a link to the experiment popup.
    """
    user_agent_string = request.user_agent.string
    user_agent_obj = user_agents.parse(user_agent_string)
    browser_ok = True
    for rule in string.split(config.get('HIT Configuration', 'browser_exclude_rule'),','):
        myrule = rule.strip()
        if myrule in ["mobile","tablet","touchcapable","pc","bot"]:
            if (myrule == "mobile" and user_agent_obj.is_mobile) or \
               (myrule == "tablet" and user_agent_obj.is_tablet) or \
               (myrule == "touchcapable" and user_agent_obj.is_touch_capable) or \
               (myrule == "pc" and user_agent_obj.is_pc) or \
               (myrule == "bot" and user_agent_obj.is_bot):
                browser_ok = False
        elif myrule in user_agent_string:
            browser_ok = False

    if not browser_ok:
        # Handler for IE users if IE is not supported.
        raise ExperimentError('browser_type_not_allowed')

    if not ('hitId' in request.args and 'assignmentId' in request.args):
        raise ExperimentError('hit_assign_worker_id_not_set_in_mturk')
    hitId = request.args['hitId']
    assignmentId = request.args['assignmentId']
    if hitId[:5] == "debug":
        debug_mode = True
    else:
        debug_mode = False
    already_in_db = False
    if 'workerId' in request.args:
        workerId = request.args['workerId']
        # first check if this workerId has completed the task before (v1)
        nrecords = Participant.query.\
                   filter(Participant.assignmentid != assignmentId).\
                   filter(Participant.workerid == workerId).\
                   count()

        if nrecords > 0:
            # already completed task
            already_in_db = True
    else:
        # If worker has not accepted the hit:
        workerId = None
    try:
        part = Participant.query.\
                           filter(Participant.hitid == hitId).\
                           filter(Participant.assignmentid == assignmentId).\
                           filter(Participant.workerid == workerId).\
                           one()
        status = part.status
    except:
        status = None

    if status == STARTED and not debug_mode:
        # Once participants have finished the instructions, we do not allow
        # them to start the task again.
        raise ExperimentError('already_started_exp_mturk')
    elif status == COMPLETED:
        # They've done the debriefing but perhaps haven't submitted the HIT yet..
        # Turn asignmentId into original assignment id before sending it back to AMT
        return render_template('thanks.html',
                               is_sandbox = sandbox_bool,
                               hitid = hitId,
                               assignmentid = assignmentId,
                               workerid = workerId)
    elif already_in_db and not debug_mode:
        raise ExperimentError('already_did_exp_hit')
    elif status == ALLOCATED or not status or debug_mode:
        # Participant has not yet agreed to the consent. They might not
        # even have accepted the HIT.
        return render_template('ad.html',
                               hitid = hitId,
                               assignmentid = assignmentId,
                               workerid = workerId)
    else:
        raise ExperimentError('status_incorrectly_set')

@app.route('/consent', methods=['GET'])
@nocache
def give_consent():
    """
    Serves up the consent in the popup window.
    """
    if not ('hitId' in request.args and 'assignmentId' in request.args and 'workerId' in request.args):
        raise ExperimentError( 'hit_assign_worker_id_not_set_in_consent')
    hitId = request.args['hitId']
    assignmentId = request.args['assignmentId']
    workerId = request.args['workerId']
    return render_template('consent.html', hitid = hitId, assignmentid=assignmentId, workerid=workerId)

def get_ad_via_hitid(hitId):
    username = config.get('psiTurk Access', 'psiturk_access_key_id')
    password = config.get('psiTurk Access', 'psiturk_secret_access_id')
    try:
        r = requests.get('https://api.psiturk.org/api/ad/lookup/' + hitId, auth=(username,password))
    except:
        raise ExperimentError('api_server_not_reachable')
    else:
        if r.status_code == 200:
            return r.json()['ad_id']
        else:
            return "error"

@app.route('/exp', methods=['GET'])
@nocache
def start_exp():
    """
    Serves up the experiment applet.
    """
    if not ('hitId' in request.args and 'assignmentId' in request.args and 'workerId' in request.args):
        raise ExperimentError( 'hit_assign_worker_id_not_set_in_exp')
    hitId = request.args['hitId']
    assignmentId = request.args['assignmentId']
    workerId = request.args['workerId']
    app.logger.info( "Accessing /exp: %(h)s %(a)s %(w)s " % {"h" : hitId, "a": assignmentId, "w": workerId})
    if hitId[:5] == "debug":
        debug_mode = True
    else:
        debug_mode = False

    # check first to see if this hitId or assignmentId exists.  if so check to see if inExp is set
    matches = Participant.query.\
                        filter(Participant.workerid == workerId).\
                        all()
    numrecs = len(matches)
    if numrecs == 0:
        # Choose condition and counterbalance
        subj_cond, subj_counter = get_random_condcount()

        ip = "UNKNOWN" if not request.remote_addr else request.remote_addr
        browser = "UNKNOWN" if not request.user_agent.browser else request.user_agent.browser
        platform = "UNKNOWN" if not request.user_agent.platform else request.user_agent.platform
        language = "UNKNOWN" if not request.user_agent.language else request.user_agent.language

        # set condition here and insert into database
        participant_attributes = dict(
            assignmentid = assignmentId,
            workerid = workerId,
            hitid = hitId,
            cond = subj_cond,
            counterbalance = subj_counter,
            ipaddress = ip,
            browser = browser,
            platform = platform,
            language = language)
        part = Participant(**participant_attributes)
        db_session.add(part)
        db_session.commit()

    else:
        # A couple possible problems here:
        # 1: They've already done an assignment, then we should tell them they can't do another one
        # 2: They've already worked on this assignment, and got too far to start over.
        # 3: They're in the database twice for the same assignment, that should never happen.
        # 4: They're returning and all is well.
        nrecords = 0
        for record in matches:
            other_assignment = False
            if record.assignmentid != assignmentId:
                other_assignment = True
            else:
                nrecords += 1
        if nrecords <= 1 and not other_assignment:
            part = matches[0]
            if part.status>=STARTED and not debug_mode: # in experiment (or later) can't restart at this point
                raise ExperimentError('already_started_exp')
        else:
            if nrecords > 1:
                app.logger.error( "Error, hit/assignment appears in database more than once (serious problem)")
                raise ExperimentError('hit_assign_appears_in_database_more_than_once')
            if other_assignment:
                raise ExperimentError('already_did_exp_hit')

    if debug_mode:
        ad_server_location = '/complete'
    else:
        # if everything goes ok here relatively safe to assume we can lookup the ad
        ad_id = get_ad_via_hitid(hitId)
        if ad_id != "error":
            if sandbox_bool:
                ad_server_location = 'https://sandbox.ad.psiturk.org/complete/' + str(ad_id)
            else:
                ad_server_location = 'https://ad.psiturk.org/complete/' + str(ad_id)
        else:
            raise ExperimentError('hit_not_registered_with_ad_server')

    return render_template('exp.html', uniqueId=part.uniqueid, condition=part.cond, counterbalance=part.counterbalance, adServerLoc=ad_server_location)

@app.route('/inexp', methods=['POST'])
def enterexp():
    """
    AJAX listener that listens for a signal from the user's script when they
    leave the instructions and enter the real experiment. After the server
    receives this signal, it will no longer allow them to re-access the
    experiment applet (meaning they can't do part of the experiment and
    referesh to start over).
    """
    app.logger.info( "Accessing /inexp")
    if not 'uniqueId' in request.form:
        raise ExperimentError('improper_inputs')
    uniqueId = request.form['uniqueId']

    try:
        user = Participant.query.\
                filter(Participant.uniqueid == uniqueId).\
                one()
        user.status = STARTED
        user.beginexp = datetime.datetime.now()
        db_session.add(user)
        db_session.commit()
        resp = {"status": "success"}
    except:
        app.logger.error( "DB error: Unique user not found.")
        resp = {"status": "error, uniqueId not found"}
    return jsonify(**resp)

# TODD SAYS: this the only route in the whole thing that uses <id> like this
# where everything else uses POST!  This could be confusing but is forced
# somewhat by Backbone?  take heed!
@app.route('/sync/<uid>', methods=['GET', 'PUT'])
def update(uid=None):
    """
    Save experiment data, which should be a JSON object and will be stored
    after converting to string.
    """
    app.logger.info("accessing the /sync route with id: %s" % uid)

    try:
        user = Participant.query.\
                filter(Participant.uniqueid == uid).\
                one()
    except:
        app.logger.error( "DB error: Unique user not found.")

    if hasattr(request, 'json'):
        user.datastring = request.data.decode('utf-8').encode('ascii', 'xmlcharrefreplace')
        db_session.add(user)
        db_session.commit()

    resp = {"condition": user.cond,
            "counterbalance": user.counterbalance,
            "assignmentId": user.assignmentid,
            "workerId": user.workerid,
            "hitId": user.hitid}

    return jsonify(**resp)

@app.route('/quitter', methods=['POST'])
def quitter():
    """
    Mark quitter as such.
    """
    uniqueId = request.form['uniqueId']
    if uniqueId[:5] == "debug":
        debug_mode = True
    else:
        debug_mode = False

    if debug_mode:
        resp = {"status": "didn't mark as quitter since this is debugging"}
        return jsonify(**resp)
    else:
        try:
            uniqueId = request.form['uniqueId']
            app.logger.info( "Marking quitter %s" % uniqueId)
            user = Participant.query.\
                    filter(Participant.uniqueid == uniqueId).\
                    one()
            user.status = QUITEARLY
            db_session.add(user)
            db_session.commit()
        except:
            raise ExperimentError('tried_to_quit')
        else:
            resp = {"status": "marked as quitter"}
            return jsonify(**resp)

# this route should only used when debugging
@app.route('/complete', methods=['GET'])
@nocache
def debug_complete():
    if not 'uniqueId' in request.args:
        raise ExperimentError('improper_inputs')
    else:
        uniqueId = request.args['uniqueId']
        try:
            user = Participant.query.\
                        filter(Participant.uniqueid == uniqueId).\
                        one()
            user.status = COMPLETED
            user.endhit = datetime.datetime.now()
            db_session.add(user)
            db_session.commit()
        except:
            raise ExperimentError('error_setting_worker_complete')
        else:
            return render_template('complete.html')

@app.route('/worker_complete', methods=['GET'])
def worker_complete():
    if not 'uniqueId' in request.args:
        resp = {"status": "bad request"}
        return jsonify(**resp)
    else:
        uniqueId = request.args['uniqueId']
        app.logger.info( "Completed experiment %s" % uniqueId)
        try:
            user = Participant.query.\
                        filter(Participant.uniqueid == uniqueId).\
                        one()
            user.status = COMPLETED
            user.endhit = datetime.datetime.now()
            db_session.add(user)
            db_session.commit()
            status = "success"
        except:
            status = "database error"
        resp = {"status" : status}
        return jsonify(**resp)

@app.route('/worker_submitted', methods=['GET'])
def worker_submitted():
    if not 'uniqueId' in request.args:
        resp = {"status": "bad request"}
        return jsonify(**resp)
    else:
        uniqueId = request.args['uniqueId']
        app.logger.info( "Submitted experiment for %s" % uniqueId)
        try:
            user = Participant.query.\
                        filter(Participant.uniqueid == uniqueId).\
                        one()
            user.status = SUBMITTED
            db_session.add(user)
            db_session.commit()
            status = "success"
        except:
            status = "database error"
        resp = {"status" : status}
        return jsonify(**resp)

# Is this a security risk?
@app.route("/ppid")
def ppid():
    ppid = os.getppid()
    return str(ppid)

#----------------------------------------------
# generic route
#----------------------------------------------
@app.route('/<pagename>')
@app.route('/<foldername>/<pagename>')
def regularpage(foldername=None,pagename=None):
    """
    Route not found by the other routes above. May point to a static template.
    """
    if foldername is None and pagename is None:
        raise ExperimentError('page_not_found')
    if foldername is None and pagename is not None:
        return render_template(pagename)
    else:
        return render_template(foldername+"/"+pagename)

# # Initialize database if necessary
def run_webserver():
    host = "0.0.0.0"
    port = config.getint('Server Parameters', 'port')
    print "Serving on ", "http://" +  host + ":" + str(port)
    app.run(debug=True, host=host, port=port)

if __name__ == '__main__':
    run_webserver()

########NEW FILE########
__FILENAME__ = experiment_errors
#----------------------------------------------
# ExperimentError Exception, for db errors, etc.
#----------------------------------------------
# Possible ExperimentError values.

from flask import render_template

class ExperimentError(Exception):
    """
    Error class for experimental errors, such as subject not being found in
    the database.
    """
    def __init__(self, value):
        experiment_errors = dict(
            status_incorrectly_set = 1000,
            hit_assign_worker_id_not_set_in_mturk = 1001,
            hit_assign_worker_id_not_set_in_consent = 1002,
            hit_assign_worker_id_not_set_in_exp = 1003,
            hit_assign_appears_in_database_more_than_once = 1004,
            already_started_exp = 1008,
            already_started_exp_mturk = 1009,
            already_did_exp_hit = 1010,
            tried_to_quit= 1011,
            intermediate_save = 1012,
            improper_inputs = 1013,
            browser_type_not_allowed = 1014,
            api_server_not_reachable = 1015,
            ad_not_found = 1016,
            error_setting_worker_complete = 1017,
            hit_not_registered_with_ad_server = 1018,
            template_unsafe = 1019,
            page_not_found = 404,
            in_debug = 2005,
            unknown_error = 9999
        )
        self.value = value
        self.errornum = experiment_errors[self.value]
        self.template = "error.html"

    def __str__(self):
        return repr(self.value)
    def error_page(self, request, contact_on_error):
        return render_template(self.template, 
                               errornum = self.errornum, 
                               contact_address = contact_on_error,
                               **request.args)
########NEW FILE########
__FILENAME__ = experiment_server
# myapp.mycustomapplication
from gunicorn.app.base import Application
from gunicorn import util
import multiprocessing
from psiturk_config import PsiturkConfig
import sys

config = PsiturkConfig()
config.load_config()

class ExperimentServer(Application):
    '''
    Custom Gunicorn Server Application that serves up the Experiment application
    '''

    def __init__(self, sandbox):
        '''__init__ method
        Load the base config and assign some core attributes.
        '''
        self.sandbox = sandbox
        self.load_user_config()
        self.usage = None
        self.callable = None
        self.options = self.user_options
        self.prog = None
        self.do_load_config()
        print "Now serving on", "http://" + self.options["bind"]

    def init(self, *args):
        '''init method
        Takes our custom options from self.options and creates a config
        dict which specifies custom settings.
        '''
        cfg = {}
        for k, v in self.options.items():
            if k.lower() in self.cfg.settings and v is not None:
                cfg[k.lower()] = v
        return cfg

    def load(self):
        '''load method
        Imports our application and returns it to be run.
        '''
        return util.import_app("psiturk.experiment:start_app(%s)" % self.sandbox)

    def load_user_config(self):
        workers = config.get("Server Parameters", "threads")  # config calls these threads to avoid confusing with workers
        if workers == "auto":
            workers = str(multiprocessing.cpu_count() * 2 + 1)

        self.loglevels = ["debug", "info", "warning", "error", "critical"]

        self.user_options = {
            'bind': config.get("Server Parameters", "host") + ":" + config.get("Server Parameters", "port"),
            'workers': workers,
            'loglevels': self.loglevels,
            'loglevel': self.loglevels[config.getint("Server Parameters", "loglevel")],
            # 'accesslog': config.get("Server Parameters", "logfile"),
            'errorlog': config.get("Server Parameters", "logfile")
        }

def launch(sandbox):
    ExperimentServer(sandbox).run()

if __name__ == "__main__":
    launch(sys.argv[1])

########NEW FILE########
__FILENAME__ = experiment_server_controller
import os, sys
import subprocess
import signal
import webbrowser
from threading import Thread, Event
import urllib2
import socket


#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# Supporting functions
#   general purpose helper functions used by the dashboard server and controller
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
def is_port_available(ip, port):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(1)
    try:
        s.connect((ip, int(port)))
        s.shutdown(2)
        return False
    except socket.timeout:
        print "*** Failed to test port availability. Check that host\nis set properly in config.txt"
        return True
    except socket.error,e:
        return True

def wait_until_online(function, ip, port):
    """
    Uses Wait_For_State to wait for the server to come online, then runs the given function.
    """
    awaiting_service = Wait_For_State(lambda: not is_port_available(ip, port), function)
    awaiting_service.start()
    return awaiting_service

def launch_browser(host, port, route):
    launchurl = "http://{host}:{port}/{route}".format(host=host, port=port, route=route)
    webbrowser.open(launchurl, new=1, autoraise=True)

def launch_browser_when_online(ip, port, route):
    return wait_until_online(lambda: launch_browser(ip, port, route), ip, port)


#----------------------------------------------------------------
# handles waiting for processes which we don't control (e.g.,
# browser requests)
#----------------------------------------------------------------
class Wait_For_State(Thread):
    """
    Waits for a state-checking function to return True, then runs a given
    function. For example, this is used to launch the browser once the server is
    started up.

    Example:
    t = Wait_For_State(lambda: server.check_port_state(), lambda: print "Server has started!")
    t.start()
    t.cancel() # Cancels thread
    """
    def __init__(self, state_function, function, pollinterval=1):
        Thread.__init__(self)
        self.function = function
        self.state_function = state_function
        self.pollinterval = pollinterval
        self.finished = Event()
        self.final = lambda: ()

    def cancel(self):
        self.finished.set()

    def run(self):
        while not self.finished.is_set():
            if self.state_function():
                self.function()
                self.finished.set()
            else:
                self.finished.wait(self.pollinterval)

#----------------------------------------------
# vanilla exception handler
#----------------------------------------------
class ExperimentServerControllerException(Exception):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

#----------------------------------------------
# simple wrapper class to control the
# starting/stopping of experiment server
#----------------------------------------------
class ExperimentServerController:
    def __init__(self, config):
        self.config = config
        self.server_running = False

    def get_ppid(self):
        if not self.is_port_available():
            url = "http://{hostname}:{port}/ppid".format(hostname=self.config.get("Server Parameters", "host"), port=self.config.getint("Server Parameters", "port"))
            ppid_request = urllib2.Request(url)
            ppid =  urllib2.urlopen(ppid_request).read()
            return ppid
        else:
            raise ExperimentServerControllerException("Cannot shut down experiment server, server not online")

    def restart(self):
        self.shutdown()
        self.startup()

    def shutdown(self, ppid=None):
        if not ppid:
            ppid = self.get_ppid()
        print("Shutting down experiment server at pid %s..." % ppid)
        try:
            os.kill(int(ppid), signal.SIGKILL)
            self.server_running = False
        except ExperimentServerControllerException:
            print ExperimentServerControllerException
        else:
            self.server_running = False

    def is_server_running(self):
        portopen = self.is_port_available()
        #print self.server_running, " ", portopen
        if self.server_running and portopen:  # server running but port open, maybe starting up
            return 'maybe'
        elif not self.server_running and not portopen: # server not running but port blocked maybe shutting down
            return 'maybe'
        elif self.server_running and not portopen: # server running, port blocked, makes sense
            return 'yes'
        elif not self.server_running and portopen: # server off, port open, makes sense
            return 'no'

    def is_port_available(self):
        return is_port_available(self.config.get("Server Parameters", "host"), self.config.getint("Server Parameters", "port"))

    def startup(self, useSandbox):
        server_command = "{python_exec} '{server_script}' {sandbox}".format(
            python_exec = sys.executable,
            server_script = os.path.join(os.path.dirname(__file__), "experiment_server.py"),
            sandbox = useSandbox
        )
        if self.is_port_available() and not self.server_running:
            #print "Running experiment server with command:", server_command
            subprocess.Popen(server_command, shell=True, close_fds=True)
            print "Experiment server launching..."
            self.server_running = True
        else:
            print "Experiment server may be already running..."

########NEW FILE########
__FILENAME__ = models

import datetime
import io, csv, json
from sqlalchemy import Column, Integer, String, DateTime, Boolean, Float, Text

from db import Base
from psiturk_config import PsiturkConfig

config = PsiturkConfig()
config.load_config()

TABLENAME = config.get('Database Parameters', 'table_name')
CODE_VERSION = config.get('Task Parameters', 'experiment_code_version')

class Participant(Base):
    """
    Object representation of a participant in the database.
    """
    __tablename__ = TABLENAME
   
    uniqueid =Column(String(128), primary_key=True)
    assignmentid =Column(String(128), nullable=False)
    workerid = Column(String(128), nullable=False)
    hitid = Column(String(128), nullable=False)
    ipaddress = Column(String(128))
    browser = Column(String(128))
    platform = Column(String(128))
    language = Column(String(128))
    cond = Column(Integer)
    counterbalance = Column(Integer)
    codeversion = Column(String(128))
    beginhit = Column(DateTime)
    beginexp = Column(DateTime)
    endhit = Column(DateTime)
    bonus = Column(Float, default = 0)
    status = Column(Integer, default = 1)
    datastring = Column(Text(4294967295))
    
    def __init__(self, **kwargs):
        self.uniqueid = "{workerid}:{assignmentid}".format(**kwargs)
        for key in kwargs:
            setattr(self, key, kwargs[key])
        self.status = 1
        self.codeversion = CODE_VERSION
        self.beginhit = datetime.datetime.now()
    
    def __repr__(self):
        return "Subject(%s, %s, %s, %s)" % ( 
            self.uniqueid, 
            self.cond, 
            self.status,
            self.codeversion)
    
    def get_trial_data(self):
        try:
            trialdata = json.loads(self.datastring)["data"]
        except:
            # There was no data to return.
            print("No trial data found in record:", self)
            return("")

        try:
            ret = []
            with io.BytesIO() as outstring:
                csvwriter = csv.writer(outstring)
                for trial in trialdata:
                    csvwriter.writerow((
                        self.uniqueid,
                        trial["current_trial"],
                        trial["dateTime"],
                        json.dumps(trial["trialdata"])))
                ret = outstring.getvalue()
            return ret
        except:
            print("Error reading record:", self)
            return("")
    
    def get_event_data(self):
        try:
            eventdata = json.loads(self.datastring)["eventdata"]
        except ValueError:
            # There was no data to return.
            print("No event data found in record:", self)
            return("")
        
        try:
            ret = []
            with io.BytesIO() as outstring:
                csvwriter = csv.writer(outstring)
                for event in eventdata:
                    csvwriter.writerow((self.uniqueid, event["eventtype"], event["interval"], event["value"], event["timestamp"]))
                ret = outstring.getvalue()
            return ret
        except:
            print("Error reading record:", self)
            return("")
    
    def get_question_data(self):
        try:
            questiondata = json.loads(self.datastring)["questiondata"]
        except ValueError:
            # There was no data to return.
            print("No question data found in record:", self)
            return("")
        
        try:
            ret = []
            with io.BytesIO() as outstring:
                csvwriter = csv.writer(outstring)
                for question in questiondata:
                    csvwriter.writerow((self.uniqueid, question, questiondata[question]))
                ret = outstring.getvalue()
            return ret
        except:
            print("Error reading record:", self)
            return("")


########NEW FILE########
__FILENAME__ = psiturk_config
import os
from distutils import file_util
from ConfigParser import SafeConfigParser

class PsiturkConfig(SafeConfigParser):
    def __init__(self, localConfig="config.txt", globalConfigName=".psiturkconfig", **kwargs):

        # If working in OpenShift, move global config file in data directory (has access rights)
        if 'OPENSHIFT_SECRET_TOKEN' in os.environ:
            globalConfig = os.environ['OPENSHIFT_DATA_DIR'] + globalConfigName
        else:
            globalConfig = "~/" + globalConfigName

        self.parent = SafeConfigParser
        self.parent.__init__(self, **kwargs)
        self.localFile = localConfig
        self.globalFile = os.path.expanduser(globalConfig)
        # psiturkConfig contains two additional SafeConfigParser's holding the values
        # of the local and global config files. This lets us write to the local or global file
        # separately without writing all fields to both.
        self.localParser = self.parent(**kwargs)
        self.globalParser = self.parent(**kwargs)

    def load_config(self):
        defaults_folder = os.path.join(os.path.dirname(__file__), "default_configs")
        local_defaults_file = os.path.join(defaults_folder, "local_config_defaults.txt")
        global_defaults_file = os.path.join(defaults_folder, "global_config_defaults.txt")
        if not os.path.exists(self.localFile):
            print "ERROR - no config.txt file in the current directory. \n\nAre you use this directory is a valid psiTurk experiment?  If you are starting a new project run 'psiturk-setup-example' in an empty directory."
            exit()
        self.localParser.read( self.localFile)
        if not os.path.exists(self.globalFile):
            print "No '.psiturkconfig' file found in your home directory.\nCreating default '~/.psiturkconfig' file."
            file_util.copy_file(global_defaults_file, self.globalFile)
        self.globalParser.read(self.globalFile)
        # read default global and local, then user's global and local. This way
        # any field not in the user's files will be set to the default value.
        self.read([global_defaults_file, local_defaults_file, self.globalFile, self.localFile])

    def write(self, changeGlobal=False):
        """
        write to the user's global or local config file.
        """
        filename = self.localFile
        configObject = self.localParser
        if changeGlobal:
            filename = self.globalFile
            configObject = self.globalParser
        with open(filename, 'w') as fp:
            configObject.write(fp)

    def set(self, section, field, value, changeGlobal=False,  *args, **kwargs):
        """
        Set the given field in the given section to the given value.
        Return True if the server needs to be rebooted.
        """
        self.parent.set(self, section, field, str(value), *args, **kwargs)
        if changeGlobal:
            self.globalParser.set(section, field, str(value), *args, **kwargs)
        else:
            self.localParser.set(section, field, str(value), *args, **kwargs)
        self.write(changeGlobal)
        if section in ["Server Parameters","Task Parameters","Database Parameters"]:
            return True
        else:
            return False


########NEW FILE########
__FILENAME__ = psiturk_org_services
import os, sys
import urllib2
import json
import datetime
import requests
from flask import jsonify
from version import version_number
import git

class PsiturkOrgServices:
    """
        PsiturkOrgServices
        this class provides an interface to the API provided
        by the psiturk_org website.  the two main features
        of this API are registering secure ads
        see: https://github.com/NYUCCL/api-psiturk-org
    """
    def __init__(self, key, secret):
        self.apiServer = 'https://api.psiturk.org' # 'https://api.psiturk.org' # by default for now
        self.adServer = 'https://ad.psiturk.org'
        self.sandboxAdServer = 'https://sandbox.ad.psiturk.org'
        self.update_credentials(key,secret)
        if not self.check_credentials():
            print 'WARNING *****************************'
            print 'Sorry, psiTurk Credentials invalid.\nYou will only be able to '\
                  + 'test experiments locally until you enter\nvalid '\
                  + 'credentials in the psiTurk Access section of ~/.psiturkconfig.\nGet your ' \
                  + 'credentials at https://www.psiturk.org/login.\n'

    def check_credentials(self):
        r = requests.get(self.apiServer + '/api/ad', auth=(self.access_key,self.secret_key))
        if r.status_code in [401, 403, 500]:  # not sure 500 server error should be included here
            return False
        else:
            return True

    def update_credentials(self, key, secret):
        self.access_key = key
        self.secret_key = secret 

    def connect(self, server):
        """
            connect:
            "connects to server"  since the is a fairly
            basic API, just allows overriding of which Ad server
            you are talking to
        """
        self.apiServer = server

    def get_system_status(self):
        """
            get_system_status:
        """
        try:
            api_server_status_link = self.apiServer + '/status_msg?version=' + version_number
            response=urllib2.urlopen(api_server_status_link,timeout=1)
            status_msg = json.load(response)['status']
        except:
            status_msg = "Sorry, can't connect to psiturk.org, please check your internet connection.\nYou will not be able to create new hits, but testing locally should work.\n"
        return status_msg
        
    def get_my_ip(self):
        """
            get_my_ip:
            asks and external server what your ip appears to be
            (useful is running from behind a NAT/wifi router).
            Of course, incoming port to the router must be
            forwarded correctly.
        """
        if 'OPENSHIFT_SECRET_TOKEN' in os.environ:
            ip = os.environ['OPENSHIFT_APP_DNS']
        else:
            ip = json.load(urllib2.urlopen('http://httpbin.org/ip'))['origin']
        return ip

    def create_record(self, name, content, username, password):
        #headers = {'key': username, 'secret': password}
        r = requests.post(self.apiServer + '/api/' + name, data=json.dumps(content), auth=(username,password))
        return r

    def update_record(self, name, recordid, content, username, password):
        #headers = {'key': username, 'secret': password}
        r = requests.put(self.apiServer + '/api/' + name + '/' + str(recordid), data=json.dumps(content), auth=(username,password))
        return r

    def delete_record(self, name, recordid, username, password):
        #headers = {'key': username, 'secret': password}
        r = requests.delete(self.apiServer + '/api/' + name + '/' + str(recordid), auth=(username,password))
        return r

    def query_records(self, name, username, password, query=''):
        #headers = {'key': username, 'secret': password}
        r = requests.get(self.apiServer + '/api/' + name + "/" + query, auth=(username,password))
        return r


    def get_ad_url(self, adId, sandbox):
        """
            get_ad_url:
            gets ad server thing
        """
        if sandbox:
            return self.sandboxAdServer + '/view/' + str(adId)
        else:
            return self.adServer + '/view/' + str(adId)

    def set_ad_hitid(self, adId, hitId, sandbox):
        """
            get_ad_hitid:
            updates the ad with the corresponding hitid
        """
        if sandbox:
            r = self.update_record('sandboxad', adId, {'amt_hit_id':hitId}, self.access_key, self.secret_key)
        else:    
            r = self.update_record('ad', adId, {'amt_hit_id':hitId}, self.access_key, self.secret_key)
        if r.status_code == 201:
            return True
        else:
            return False        

    def create_ad(self, ad_content):
        """
            create_ad:
        """
        if not 'is_sandbox' in ad_content:
            return False
        else:
            if ad_content['is_sandbox']:
                r = self.create_record('sandboxad', ad_content, self.access_key, self.secret_key)
            else:
                r = self.create_record('ad', ad_content, self.access_key, self.secret_key)
            if r.status_code == 201:
                return r.json()['ad_id']
            else:
                return False    

    def download_experiment(self, experiment_id):
        """
            download_experiment:
        """
        r = self.query_records('experiment', self.access_key, self.secret_key, query='download/'+experiment_id)
        print r.text
        return


class ExperimentExchangeServices:
    """
        ExperimentExchangeServices
        this class provides a non-authenticated interface to the API provided
        by the psiturk_org website.  the feature is
        interfacing with the experiment exchange
        see: https://github.com/NYUCCL/api-psiturk-org
    """
    def __init__(self):
        self.apiServer = 'https://api.psiturk.org' # 'https://api.psiturk.org' # by default for now

    def query_records_no_auth(self, name, query=''):
        #headers = {'key': username, 'secret': password}
        r = requests.get(self.apiServer + '/api/' + name + "/" + query)
        return r

    def download_experiment(self, experiment_id):
        """
            download_experiment:
        """
        r = self.query_records_no_auth('experiment', query='download/'+experiment_id)
        if r.status_code == 404:
            print "Sorry, no experiment matching id # " + experiment_id
            print "Please double check the code you obtained on the http://psiturk.org/ee"
        else:
            # check if folder with same name already exists.
            expinfo = r.json()
            gitr = requests.get(expinfo['git_url']).json()
            if os.path.exists('./'+gitr['name']):
                print "*"*20
                print "Sorry, you already have a file or folder named "+gitr['name']+". Please rename or delete it before trying to download this experiment.  You can do this by typing `rm -rf " + gitr['name'] + "`" 
                print "*"*20
                return
            if "clone_url" in gitr:
                git.Git().clone(gitr["clone_url"])
                print "="*20
                print "Downloading..."
                print "Name: " + expinfo['name']
                print "Downloads: " + str(expinfo['downloads'])
                print "Keywords: " + expinfo['keywords']
                print "psiTurk Version: " + str(expinfo['psiturk_version_string'])
                print "URL: http://psiturk.org/ee/"+experiment_id
                print "\n"
                print "Experiment downloaded into the `" + gitr['name'] + "` folder of the current directory"
                print "Type 'cd " + gitr['name'] + "` then run the `psiturk` command."
                print "="*20
            else:
                print "Sorry, experiment not located on github.  You might contact the author of this experiment.  Experiment NOT downloaded."
            return
########NEW FILE########
__FILENAME__ = psiturk_shell
# coding: utf-8
import sys
import subprocess
import re
import time
import json
import os
import string
import random
import datetime

from cmd2 import Cmd
from docopt import docopt, DocoptExit
import readline

import webbrowser

import sqlalchemy as sa

from amt_services import MTurkServices, RDSServices
from psiturk_org_services import PsiturkOrgServices
from version import version_number
from psiturk_config import PsiturkConfig
import experiment_server_controller as control
from db import db_session, init_db
from models import Participant

#  colorize target string. Set use_escape to false when text will not be
# interpreted by readline, such as in intro message.
def colorize(target, color, use_escape=True):
    def escape(code):
        return '\001%s\002' % code
    if color == 'purple':
        color_code = '\033[95m'
    elif color == 'cyan':
        color_code = '\033[96m'
    elif color == 'darkcyan':
        color_code = '\033[36m'
    elif color == 'blue':
        color_code = '\033[93m'
    elif color == 'green':
        color_code = '\033[92m'
    elif color == 'yellow':
        color_code = '\033[93m'
    elif color == 'red':
        color_code = '\033[91m'
    elif color == 'white':
        color_code = '\033[37m'
    elif color == 'bold':
        color_code = '\033[1m'
    elif color == 'underline':
        color_code = '\033[4m'
    else:
        color_code = ''
    if use_escape:
        return escape(color_code) + target + escape('\033[0m')
    else:
        return color_code + target + '\033[m'

# Decorator function borrowed from docopt.
def docopt_cmd(func):
    """
    This decorator is used to simplify the try/except block and pass the result
    of the docopt parsing to the called action.
    """
    def fn(self, arg):
        try:
            opt = docopt(fn.__doc__, arg)
        except DocoptExit as e:
            # The DocoptExit is thrown when the args do not match.
            # We print a message to the user and the usage block.
            print('Invalid Command!')
            print(e)
            return
        except SystemExit:
            # The SystemExit exception prints the usage for --help
            # We do not need to do the print here.
            return
        return func(self, opt)
    fn.__name__ = func.__name__
    fn.__doc__ = func.__doc__
    fn.__dict__.update(func.__dict__)
    return fn


#---------------------------------
# psiturk shell class
#  -  all commands contained in methods titled do_XXXXX(self, arg)
#  -  if a command takes any arguments, use @docopt_cmd decorator
#     and describe command usage in docstring
#---------------------------------
class PsiturkShell(Cmd, object):
    """
    Usage:
        psiturk -c
        psiturk_shell -c
    """

    def __init__(self, config, server):
        Cmd.__init__(self)
        self.config = config
        self.server = server

        # Prevents running of commands by abbreviation
        self.abbrev = False
        self.debug = True
        self.helpPath = os.path.join(os.path.dirname(__file__), "shell_help/")
        self.psiTurk_header = 'psiTurk command help:'
        self.super_header = 'basic CMD command help:'

        self.color_prompt()
        self.intro = self.get_intro_prompt()


    #+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.
    #  basic command line functions
    #+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.
    def check_offline_configuration(self):
        quit_on_start = False
        database_url = self.config.get('Database Parameters', 'database_url')
        host = self.config.get('Server Parameters', 'host', 'localhost')
        if database_url[:6] != 'sqlite':
            print "*** Error: config.txt option 'database_url' set to use mysql://.  Please change this sqllite:// while in cabin mode."
            quit_on_start = True
        if host != 'localhost':
            print "*** Error: config option 'host' is not set to localhost.  Please change this to localhost while in cabin mode."
            quit_on_start = True
        if quit_on_start:
            exit()

    def get_intro_prompt(self):
        # offline message
        sysStatus = open(self.helpPath + 'cabin.txt', 'r')
        server_msg = sysStatus.read()
        return server_msg + colorize('psiTurk version ' + version_number +
                                     '\nType "help" for more information.', 'green', False)

    def do_psiturk_status(self, args):
        print self.get_intro_prompt()

    def color_prompt(self):
        prompt = '[' + colorize('psiTurk', 'bold')
        serverString = ''
        server_status = self.server.is_server_running()
        if server_status == 'yes':
            serverString = colorize('on', 'green')
        elif server_status == 'no':
            serverString = colorize('off', 'red')
        elif server_status == 'maybe':
            serverString = colorize('unknown', 'yellow')
        prompt += ' server:' + serverString
        prompt += ' mode:' + colorize('cabin', 'bold')
        prompt += ']$ '
        self.prompt = prompt

    # keep persistent command history
    def preloop(self):
        # create file if it doesn't exist
        open('.psiturk_history', 'a').close()
        readline.read_history_file('.psiturk_history')
        for i in range(readline.get_current_history_length()):
            if readline.get_history_item(i) != None:
                self.history.append(readline.get_history_item(i))
        Cmd.preloop(self)

    def postloop(self):
        readline.write_history_file('.psiturk_history')
        Cmd.postloop(self)

    def onecmd_plus_hooks(self, line):
        if not line:
            return self.emptyline()
        return Cmd.onecmd_plus_hooks(self, line)

    def postcmd(self, stop, line):
        self.color_prompt()
        return Cmd.postcmd(self, stop, line)

    def emptyline(self):
        self.color_prompt()

    # add space after a completion, makes tab completion with
    # multi-word commands cleaner
    def complete(self, text, state):
        return Cmd.complete(self, text, state) + ' '


    #+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.
    #  server management
    #+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.
    def server_on(self):
        self.server.startup('True')
        while self.server.is_server_running() != 'yes':
            time.sleep(0.5)

    def server_off(self):
        self.server.shutdown()
        print 'Please wait. This could take a few seconds.'
        while self.server.is_server_running() != 'no':
            time.sleep(0.5)

    def server_restart(self):
        self.server_off()
        self.server_on()

    def server_log(self):
        logfilename = self.config.get('Server Parameters', 'logfile')
        if sys.platform == "darwin":
            args = ["open", "-a", "Console.app", logfilename]
        else:
            args = ["xterm", "-e", "'tail -f %s'" % logfilename]
        subprocess.Popen(args, close_fds=True)
        print "Log program launching..."

    @docopt_cmd
    def do_debug(self, arg):
        """
        Usage: debug [options]

        -p, --print-only         just provides the URL, doesn't attempt to launch browser
        """
        if self.server.is_server_running() == 'no' or self.server.is_server_running()=='maybe':
            print "Error: Sorry, you need to have the server running to debug your experiment.  Try 'server on' first."
            return

        if 'OPENSHIFT_SECRET_TOKEN' in os.environ:
            base_url = "http://" + self.config.get('Server Parameters', 'host') + "/ad"
        else:
            base_url = "http://" + self.config.get('Server Parameters', 'host') + ":" + self.config.get('Server Parameters', 'port') + "/ad"

        launchurl = base_url + "?assignmentId=debug" + str(self.random_id_generator()) \
                    + "&hitId=debug" + str(self.random_id_generator()) \
                    + "&workerId=debug" + str(self.random_id_generator())

        if arg['--print-only']:
            print "Here's your randomized debug link, feel free to request another:\n\t", launchurl
        else:
            print "Launching browser pointed at your randomized debug link, feel free to request another.\n\t", launchurl
            webbrowser.open(launchurl, new=1, autoraise=True)

    def help_debug(self):
        with open(self.helpPath + 'debug.txt', 'r') as helpText:
            print helpText.read()

    def do_version(self, arg):
        print 'psiTurk version ' + version_number

    def do_print_config(self, arg):
        for section in self.config.sections():
            print '[%s]' % section
            items = dict(self.config.items(section))
            for k in items:
                print "%(a)s=%(b)s" % {'a': k, 'b': items[k]}
            print ''

    def do_reload_config(self, arg):
        restartServer = False
        if self.server.is_server_running() == 'yes' or self.server.is_server_running() == 'maybe':
            r = raw_input("Reloading configuration requires the server to restart. Really reload? y or n: ")
            if r != 'y':
                return
            restartServer = True
        self.config.load_config()
        if restartServer:
            self.server_restart()



    def do_status(self, arg):
        server_status = self.server.is_server_running()
        if server_status == 'yes':
            print 'Server: ' + colorize('currently online', 'green')
        elif server_status == 'no':
            print 'Server: ' + colorize('currently offline', 'red')
        elif server_status == 'maybe':
            print 'Server: ' + colorize('status unknown', 'yellow')

    def do_setup_example(self, arg):
        import setup_example as se
        se.setup_example()


    #+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.
    #  Local SQL database commands
    #+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.
    def db_get_config(self):
        print "Current database setting (database_url): \n\t", self.config.get("Database Parameters", "database_url")

    def db_use_local_file(self, filename=None):
        interactive = False
        if filename is None:
            interactive = True
            filename = raw_input('Enter the filename of the local SQLLite database you would like to use [default=participants.db]: ')
            if filename=='':
                filename='participants.db'
        base_url = "sqlite:///" + filename
        self.config.set("Database Parameters", "database_url", base_url)
        print "Updated database setting (database_url): \n\t", self.config.get("Database Parameters", "database_url")
        if self.server.is_server_running() == 'yes':
            self.server_restart()

    def do_download_datafiles(self, arg):
        contents = {"trialdata": lambda p: p.get_trial_data(), "eventdata": lambda p: p.get_event_data(), "questiondata": lambda p: p.get_question_data()}
        query = Participant.query.all()
        for k in contents:
            ret = "".join([contents[k](p) for p in query])
            f = open(k + '.csv', 'w')
            f.write(ret)
            f.close()

    @docopt_cmd
    def do_open(self, arg):
        """
        Usage: open
               open <folder>

        Opens folder or current directory using the local system's shell command 'open'.
        """
        if arg['<folder>'] is None:
            subprocess.call(["open"])
        else:
            subprocess.call(["open",arg['<folder>']])

    def do_eof(self, arg):
        self.do_quit(arg)
        return True

    def do_exit(self, arg):
        self.do_quit(arg)
        return True

    def do_quit(self, arg):
        if self.server.is_server_running() == 'yes' or self.server.is_server_running() == 'maybe':
            r = raw_input("Quitting shell will shut down experiment server. Really quit? y or n: ")
            if r == 'y':
                self.server_off()
            else:
                return
        return True

    @docopt_cmd
    def do_server(self, arg):
        """
        Usage:
          server on
          server off
          server restart
          server log
          server help
        """
        if arg['on']:
            self.server_on()
        elif arg['off']:
            self.server_off()
        elif arg['restart']:
            self.server_restart()
        elif arg['log']:
            self.server_log()
        else:
            self.help_server()

    server_commands = ('on', 'off', 'restart', 'log', 'help')

    def complete_server(self, text, line, begidx, endidx):
        return  [i for i in PsiturkShell.server_commands if i.startswith(text)]

    def help_server(self):
        with open(self.helpPath + 'server.txt', 'r') as helpText:
            print helpText.read()

    def random_id_generator(self, size = 6, chars = string.ascii_uppercase + string.digits):
        return ''.join(random.choice(chars) for x in range(size))

    # modified version of standard cmd help which lists psiturk commands first
    def do_help(self, arg):
        if arg:
            try:
                func = getattr(self, 'help_' + arg)
            except AttributeError:
                try:
                    doc = getattr(self, 'do_' + arg).__doc__
                    if doc:
                        self.stdout.write("%s\n" % str(doc))
                        return
                except AttributeError:
                    pass
                self.stdout.write("%s\n" % str(self.nohelp % (arg,)))
                return
            func()
        else:
            # Modifications start here
            names = dir(PsiturkShell)
            superNames = dir(Cmd)
            newNames = [m for m in names if m not in superNames]
            help = {}
            cmds_psiTurk = []
            cmds_super = []
            for name in names:
                if name[:5] == 'help_':
                    help[name[5:]]=1
            names.sort()
            prevname = ''
            for name in names:
                if name[:3] == 'do_':
                    if name == prevname:
                        continue
                    prevname = name
                    cmd = name[3:]
                    if cmd in help:
                        del help[cmd]
                    if name in newNames:
                        cmds_psiTurk.append(cmd)
                    else:
                        cmds_super.append(cmd)
            self.stdout.write("%s\n" % str(self.doc_leader))
            self.print_topics(self.psiTurk_header, cmds_psiTurk, 15, 80)
            self.print_topics(self.misc_header, help.keys(), 15, 80)
            self.print_topics(self.super_header, cmds_super, 15, 80)


class PsiturkNetworkShell(PsiturkShell):

    def __init__(self, config, amt_services, aws_rds_services, web_services, server, sandbox):
        self.config = config
        self.amt_services = amt_services
        self.web_services = web_services
        self.db_services = aws_rds_services
        self.sandbox = sandbox

        self.sandboxHITs = 0
        self.liveHITs = 0
        self.tally_hits()
        PsiturkShell.__init__(self, config, server)

        # Prevents running of commands by abbreviation
        self.abbrev = False
        self.debug = True
        self.helpPath = os.path.join(os.path.dirname(__file__), "shell_help/")
        self.psiTurk_header = 'psiTurk command help:'
        self.super_header = 'basic CMD command help:'



    #+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.
    #  basic command line functions
    #+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.
    def get_intro_prompt(self):  # overloads intro prompt with network-aware version
        # if you can reach psiTurk.org, request system status
        # message
        server_msg = self.web_services.get_system_status()
        return server_msg + colorize('psiTurk version ' + version_number +
                                     '\nType "help" for more information.', 'green', False)

    def color_prompt(self):  # overloads prompt with network info
        prompt = '[' + colorize('psiTurk', 'bold')
        serverString = ''
        server_status = self.server.is_server_running()
        if server_status == 'yes':
            serverString = colorize('on', 'green')
        elif server_status == 'no':
            serverString = colorize('off', 'red')
        elif server_status == 'maybe':
            serverString = colorize('unknown', 'yellow')
        prompt += ' server:' + serverString
        if self.sandbox:
            prompt += ' mode:' + colorize('sdbx', 'bold')
        else:
            prompt += ' mode:' + colorize('live', 'bold')
        if self.sandbox:
            prompt += ' #HITs:' + str(self.sandboxHITs)
        else:
            prompt += ' #HITs:' + str(self.liveHITs)
        prompt += ']$ '
        self.prompt = prompt

    def server_on(self):
        self.server.startup(str(self.sandbox))
        while self.server.is_server_running() != 'yes':
            time.sleep(0.5)


    def do_status(self, arg): # overloads do_status with AMT info
        super(PsiturkNetworkShell, self).do_status(arg)
        server_status = self.server.is_server_running()
        self.tally_hits()
        if self.sandbox:
            print 'AMT worker site - ' + colorize('sandbox', 'bold') + ': ' + str(self.sandboxHITs) + ' HITs available'
        else:
            print 'AMT worker site - ' + colorize('live', 'bold') + ': ' + str(self.liveHITs) + ' HITs available'


    #+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.
    #  worker management
    #+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.
    def worker_list(self, submitted, approved, rejected, chosenHit):
        workers = None
        if submitted:
            workers = self.amt_services.get_workers("Submitted")
        elif approved:
            workers = self.amt_services.get_workers("Approved")
        elif rejected:
            workers = self.amt_services.get_workers("Rejected")
        else:
            workers = self.amt_services.get_workers()
        if workers==False:
            print colorize('*** failed to get workers', 'red')
        if chosenHit:
            workers = [worker for worker in workers if worker['hitId']==chosenHit]
            print 'listing workers for HIT', chosenHit
        if not len(workers):
            print "*** no workers match your request"
        else:
            print json.dumps(workers, indent=4,
                             separators=(',', ': '))

    def worker_approve(self, chosenHit, assignment_ids = None):
        if chosenHit:
            workers = self.amt_services.get_workers("Submitted")
            assignment_ids = [worker['assignmentId'] for worker in workers if worker['hitId']==chosenHit]
            print 'approving workers for HIT', chosenHit
        for assignmentID in assignment_ids:
            success = self.amt_services.approve_worker(assignmentID)
            if success:
                print 'approved', assignmentID
            else:
                print '*** failed to approve', assignmentID

    def worker_reject(self, chosenHit, assignment_ids = None):
        if chosenHit:
            workers = self.amt_services.get_workers("Submitted")
            assignment_ids = [worker['assignmentId'] for worker in workers if worker['hitId']==chosenHit]
            print 'rejecting workers for HIT',chosenHit
        for assignmentID in assignment_ids:
            success = self.amt_services.reject_worker(assignmentID)
            if success:
                print 'rejected', assignmentID
            else:
                print '*** failed to reject', assignmentID

    def worker_unreject(self, chosenHit, assignment_ids = None):
        if chosenHit:
            workers = self.amt_services.get_workers("Rejected")
            assignment_ids = [worker['assignmentId'] for worker in workers if worker['hitId']==chosenHit]
        for assignmentID in assignment_ids:
            success = self.amt_services.unreject_worker(assignmentID)
            if success:
                print 'unrejected %s' % (assignmentID)
            else:
                print '*** failed to unreject', assignmentID

    def worker_bonus(self, chosenHit, auto, amount, reason, assignment_ids = None):
        while not reason:
            r = raw_input("Type the reason for the bonus. Workers will see this message: ")
            reason = r
        #bonus already-bonused workers if the user explicitly lists their worker IDs
        overrideStatus = True
        if chosenHit:
            overrideStatus = False
            workers = self.amt_services.get_workers("Approved")
            if workers==False:
                print "No approved workers for HIT", chosenHit
                return
            assignment_ids = [worker['assignmentId'] for worker in workers if worker['hitId']==chosenHit]
            print 'bonusing workers for HIT', chosenHit
        for assignmentID in assignment_ids:
            try:
                init_db()
                part = Participant.query.\
                       filter(Participant.assignmentid == assignmentID).\
                       filter(Participant.endhit != None).\
                       one()
                if auto:
                    amount = part.bonus
                status = part.status
                if amount<=0:
                    print "bonus amount <=$0, no bonus given to", assignmentID
                elif status==7 and not overrideStatus:
                    print "bonus already awarded to ", assignmentID
                else:
                    success = self.amt_services.bonus_worker(assignmentID, amount, reason)
                    if success:
                        print "gave bonus of $" + str(amount) + " to " + assignmentID
                        part.status = 7
                        db_session.add(part)
                        db_session.commit()
                        db_session.remove()
                    else:
                        print "*** failed to bonus", assignmentID
            except:
                print "*** failed to bonus", assignmentID

    #+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.
    #  hit management
    #+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.
    def do_amt_balance(self, arg):
        print self.amt_services.check_balance()
    def help_amt_balance(self):
        with open(self.helpPath + 'amt.txt', 'r') as helpText:
            print helpText.read()

    def hit_list(self, activeHits, reviewableHits):
        hits_data = []
        if activeHits:
            hits_data = self.amt_services.get_active_hits()
        elif reviewableHits:
            hits_data = self.amt_services.get_reviewable_hits()
        else:
            hits_data = self.amt_services.get_all_hits()
        if not hits_data:
            print '*** no hits retrieved'
        else:
            for hit in hits_data:
                print hit

    def hit_extend(self, hitID, assignments, minutes):
        """ Add additional worker assignments or minutes to a HIT.

        Args:
            hitID: A list conaining one hitID string.
            assignments: Variable <int> for number of assignments to add.
            minutes: Variable <int> for number of minutes to add.

        Returns:
            A side effect of this function is that the state of a HIT changes on AMT servers.

        Raises:

        """

        assert type(hitID) is list
        assert type(hitID[0]) is str

        if self.amt_services.extend_hit(hitID[0], assignments, minutes):
            print "HIT extended."

    def hit_dispose(self, allHits, hitIDs=None):
        if allHits:
            hits_data = self.amt_services.get_all_hits()
            hitIDs = [hit.options['hitid'] for hit in hits_data if (hit.options['status']=="Reviewable")]
        for hit in hitIDs:
            # check that the his is reviewable
            status = self.amt_services.get_hit_status(hit)
            if not status:
                print "*** Error getting hit status"
                return
            if self.amt_services.get_hit_status(hit)!="Reviewable":
                print "*** This hit is not 'Reviewable' and so can not be disposed of"
                return
            else:
                success = self.amt_services.dispose_hit(hit)
                #self.web_services.delete_ad(hit)  # also delete the ad
                if success:
                    if self.sandbox:
                        print "deleting sandbox HIT", hit
                    else:
                        print "deleting live HIT", hit
        self.tally_hits()

    def hit_expire(self, allHits, hitIDs=None):
        if allHits:
            hits_data = self.amt_services.get_active_hits()
            hitIDs = [hit.options['hitid'] for hit in hits_data]
        for hit in hitIDs:
            success = self.amt_services.expire_hit(hit)
            if success:
                if self.sandbox:
                    print "expiring sandbox HIT", hit
                else:
                    print "expiring live HIT", hit
        self.tally_hits()

    def tally_hits(self):
        hits = self.amt_services.get_active_hits()
        numHits = 0
        if hits:
            numHits = len(hits)
        if self.sandbox:
            self.sandboxHITs = numHits
        else:
            self.liveHITs = numHits


    def hit_create(self, numWorkers, reward, duration):

        server_loc = str(self.config.get('Server Parameters', 'host'))
        if server_loc in ['localhost', '127.0.0.1']:
            print '\n'.join(['*****************************',
                             '  Sorry, your server is set for local debugging only.  You cannot make public',
                             '  HITs or Ads. Please edit the config.txt file inside your project folder and',
                             '  set the \'host\' variable in the \'Server Parameters\' section to something',
                             '  other than \'localhost\' or \'127.0.0.1\'. This will make your psiturk server',
                             '  process reachable by the external world.  The most useful option is \'0.0.0.0\'',
                             '  Note: You will need to restart the server for your changes to take effect.',
                             ''])

            r = raw_input('\n'.join(['  If you are using an external server process, press `y` to continue.',
                                     '  Otherwise, press `n` to cancel:']))
            if r!='y':
                return

        if not self.web_services.check_credentials():
            print '\n'.join(['*****************************',
                            '  Sorry, your psiTurk Credentials are invalid.\n ',
                            '  You cannot create ads and hits until you enter valid credentials in ',
                            '  the \'psiTurk Access\' section of ~/.psiturkconfig.  You can obtain your',
                            '  credentials or sign up at https://www.psiturk.org/login.\n'])
            return


        if not self.amt_services.verify_aws_login():
            print '\n'.join(['*****************************',
                             '  Sorry, your AWS Credentials are invalid.\n ',
                             '  You cannot create ads and hits until you enter valid credentials in ',
                             '  the \'AWS Access\' section of ~/.psiturkconfig.  You can obtain your ',
                             '  credentials via the Amazon AMT requester website.\n'])
            return

        if self.server.is_server_running() != 'yes':
            print '\n'.join(['*****************************',
                             '  Your psiTurk server is currently not running but you are trying to create ',
                             '  an Ad/HIT.  This can cause problems for worker trying to access your ',
                             '  hit.  Please start the server by first typing \'server on\' then try this ',
                             '  command again.',
                             ''])
            r = raw_input('\n'.join(['  If you are using an external server process, press `y` to continue.',
                                      '  Otherwise, press `n` to cancel:']))
            if r!='y':
                return

        interactive = False
        if numWorkers is None:
            interactive = True
            numWorkers = raw_input('number of participants? ')
        try:
            int(numWorkers)
        except ValueError:

            print '*** number of participants must be a whole number'
            return
        if int(numWorkers) <= 0:
            print '*** number of participants must be greater than 0'
            return
        if interactive:
            reward = raw_input('reward per HIT? ')
        p = re.compile('\d*.\d\d')
        m = p.match(reward)
        if m is None:
            print '*** reward must have format [dollars].[cents]'
            return
        if interactive:
            duration = raw_input('duration of hit (in hours)? ')
        try:
            int(duration)
        except ValueError:
            print '*** duration must be a whole number'
            return
        if int(duration) <= 0:
            print '*** duration must be greater than 0'
            return

        # register with the ad server (psiturk.org/ad/register) using POST
        if os.path.exists('templates/ad.html'):
            ad_html = open('templates/ad.html').read()
        else:
            print '\n'.join(['*****************************',
                             '  Sorry, there was an error registering ad.',
                             '  Both ad.html is required to be in the templates/ folder of your project so that these Ad can be served!'])
            return

        size_of_ad = sys.getsizeof(ad_html)
        if size_of_ad >= 1048576:
            print '\n'.join(['*****************************',
                             '  Sorry, there was an error registering ad.',
                             '  Your local ad.html is %s byes, but the maximum template size uploadable to the Ad server is 1048576 bytes!' % size_of_ad])
            return

        # what all do we need to send to server?
        # 1. server
        # 2. port
        # 3. support_ie?
        # 4. ad.html template
        # 5. contact_email in case an error happens
        ad_content = {'psiturk_external': True,
              'server': str(self.web_services.get_my_ip()),
              'port': str(self.config.get('Server Parameters', 'port')),
              'browser_exclude_rule': str(self.config.get('HIT Configuration', 'browser_exclude_rule')),
              'is_sandbox': int(self.sandbox),
              'ad_html': ad_html,
              # 'amt_hit_id': hitid, Don't know this yet
              'organization_name': str(self.config.get('HIT Configuration', 'organization_name')),
              'experiment_name': str(self.config.get('HIT Configuration', 'title')),
              'contact_email_on_error': str(self.config.get('HIT Configuration', 'contact_email_on_error')),
              'ad_group': str(self.config.get('HIT Configuration', 'ad_group')),
              'keywords': str(self.config.get('HIT Configuration', 'psiturk_keywords'))
        }

        create_failed = False
        fail_msg = None
        ad_id = self.web_services.create_ad(ad_content)
        if ad_id != False:
            ad_url = self.web_services.get_ad_url(ad_id, int(self.sandbox))
            hit_config = {
                "ad_location": ad_url,
                "approve_requirement": self.config.get('HIT Configuration', 'Approve_Requirement'),
                "us_only": self.config.getboolean('HIT Configuration', 'US_only'),
                "lifetime": datetime.timedelta(hours=self.config.getfloat('HIT Configuration', 'lifetime')),
                "max_assignments": numWorkers,
                "title": self.config.get('HIT Configuration', 'title'),
                "description": self.config.get('HIT Configuration', 'description'),
                "keywords": self.config.get('HIT Configuration', 'amt_keywords'),
                "reward": reward,
                "duration": datetime.timedelta(hours=int(duration))
            }
            hit_id = self.amt_services.create_hit(hit_config)
            if hit_id != False:
                if not self.web_services.set_ad_hitid(ad_id, hit_id, int(self.sandbox)):
                    create_failed = True
                    fail_msg = "  Unable to update Ad on http://ad.psiturk.org to point at HIT."
            else:
                create_failed = True
                fail_msg = "  Unable to create HIT on Amazon Mechanical Turk."
        else:
            create_failed = True
            fail_msg = "  Unable to create Ad on http://ad.psiturk.org."

        if create_failed:
            print '\n'.join(['*****************************',
                             '  Sorry, there was an error creating hit and registering ad.'])
            if fail_msg:
                print fail_msg

        else:
            if self.sandbox:
                self.sandboxHITs += 1
            else:
                self.liveHITs += 1
            #print results
            total = float(numWorkers) * float(reward)
            fee = total / 10
            total = total + fee
            location = ''
            if self.sandbox:
                location = 'sandbox'
            else:
                location = 'live'
            print '\n'.join(['*****************************',
                             '  Creating %s HIT' % colorize(location, 'bold'),
                             '    HITid: %s' % str(hit_id),
                             '    Max workers: %s' % numWorkers,
                             '    Reward: $%s' %reward,
                             '    Duration: %s hours' % duration,
                             '    Fee: $%.2f' % fee,
                             '    ________________________',
                             '    Total: $%.2f' % total])
            if self.sandbox:
                print('  Ad for this HIT now hosted at: https://sandbox.ad.psiturk.org/view/%s?assignmentId=debug%s&hitId=debug%s'
                      % (str(ad_id), str(self.random_id_generator()), str(self.random_id_generator())))
                print "Note: This sandboxed ad will expire from the server in 15 days."
            else:
                print('  Ad for this HIT now hosted at: https://ad.psiturk.org/view/%s?assignmentId=debug%s&hitId=debug%s'
                      % (str(ad_id), str(self.random_id_generator()), str(self.random_id_generator())))


    @docopt_cmd
    def do_db(self, arg):
        """
        Usage:
          db get_config
          db use_local_file [<filename>]
          db use_aws_instance [<instance_id>]
          db aws_list_regions
          db aws_get_region
          db aws_set_region [<region_name>]
          db aws_list_instances
          db aws_create_instance [<instance_id> <size> <username> <password> <dbname>]
          db aws_delete_instance [<instance_id>]
          db help
        """
        if arg['get_config']:
            self.db_get_config()
        elif arg['use_local_file']:
            self.db_use_local_file(arg['<filename>'])
        elif arg['use_aws_instance']:
            self.db_use_aws_instance(arg['<instance_id>'])
            pass
        elif arg['aws_list_regions']:
            self.db_aws_list_regions()
        elif arg['aws_get_region']:
            self.db_aws_get_region()
        elif arg['aws_set_region']:
            self.db_aws_set_region(arg['<region_name>'])
        elif arg['aws_list_instances']:
            self.db_aws_list_instances()
        elif arg['aws_create_instance']:
            self.db_create_aws_db_instance(arg['<instance_id>'], arg['<size>'], arg['<username>'], arg['<password>'], arg['<dbname>'])
        elif arg['aws_delete_instance']:
            self.db_aws_delete_instance(arg['<instance_id>'])
        else:
            self.help_db()

    db_commands = ('get_config', 'use_local_file', 'use_aws_instance', 'aws_list_regions', 'aws_get_region', 'aws_set_region', 'aws_list_instances', 'aws_create_instance', 'aws_delete_instance', 'help')

    def complete_db(self, text, line, begidx, endidx):
        return  [i for i in PsiturkNetworkShell.db_commands if i.startswith(text)]

    def help_db(self):
        with open(self.helpPath + 'db.txt', 'r') as helpText:
            print helpText.read()


    #+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.
    #  AWS RDS commands
    #+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.
    def db_aws_list_regions(self):
        regions = self.db_services.list_regions()
        if regions != []:
            print "Avaliable AWS regions:"
        for reg in regions:
            print '\t' + reg,
            if reg == self.db_services.get_region():
                print "(currently selected)"
            else:
                print ''

    def db_aws_get_region(self):
        print self.db_services.get_region()

    def db_aws_set_region(self, region_name):
        interactive = False
        if region_name is None:
            interactive = True
            self.db_aws_list_regions()
            allowed_regions = self.db_services.list_regions()
            region_name = "NONSENSE WORD1234"
            tries = 0
            while region_name not in allowed_regions:
                if tries == 0:
                    region_name = raw_input('Enter the name of the region you would like to use: ')
                else:
                    print "*** The region name (%s) you entered is not allowed, please choose from the list printed above (use type 'db aws_list_regions'." % region_name
                    region_name = raw_input('Enter the name of the region you would like to use: ')
                tries+=1
                if tries > 5:
                    print "*** Error, region you are requesting not available.  No changes made to regions."
                    return
        self.db_services.set_region(region_name)
        print "Region updated to ", region_name
        self.config.set('AWS Access', 'aws_region', region_name, True)
        if self.server.is_server_running() == 'yes':
            self.server_restart()

    def db_aws_list_instances(self):
        instances = self.db_services.get_db_instances()
        if not instances:
            print "There are no DB instances associated with your AWS account in region ", self.db_services.get_region()
        else:
            print "Here are the current DB instances associated with your AWS account in region ", self.db_services.get_region()
            for dbinst in instances:
                print '\t'+'-'*20
                print "\tInstance ID: " + dbinst.id
                print "\tStatus: " + dbinst.status

    def db_aws_delete_instance(self, instance_id):
        interactive = False
        if instance_id is None:
            interactive = True

        instances = self.db_services.get_db_instances()
        instance_list = [dbinst.id for dbinst in instances]

        if interactive:
            valid = False
            if len(instances)==0:
                print "There are no instances you can delete currently.  Use `db aws_create_instance` to make one."
                return
            print "Here are the available instances you can delete:"
            for inst in instances:
                print "\t ", inst.id, "(", inst.status, ")"
            while not valid:
                instance_id = raw_input('Enter the instance identity you would like to delete: ')
                res = self.db_services.validate_instance_id(instance_id)
                if (res == True):
                    valid = True
                else:
                    print res + " Try again, instance name not valid.  Check for typos."
                if instance_id in instance_list:
                    valid = True
                else:
                    valid = False
                    print "Try again, instance not present in this account.  Try again checking for typos."
        else:
            res = self.db_services.validate_instance_id(instance_id)
            if (res != True):
                print "*** Error, instance name either not valid.  Try again checking for typos."
                return
            if instance_id not in instance_list:
                print "*** Error, This instance not present in this account.  Try again checking for typos.  Run `db aws_list_instances` to see valid list."
                return

        r = raw_input("Deleting an instance will erase all your data associated with the database in that instance. Really quit? y or n: ")
        if r == 'y':
            res = self.db_services.delete_db_instance(instance_id)
            if res:
                print "AWS RDS database instance %s deleted.  Run `db aws_list_instances` for current status." % instance_id
            else:
                print "*** Error deleting database instance ", instance_id, ". It maybe because it is still being created, deleted, or is being backed up.  Run `db aws_list_instances` for current status."
        else:
            return

    def db_use_aws_instance(self, instance_id):
        # set your database info to use the current instance
        # configure a security zone for this based on your ip
        interactive = False
        if instance_id is None:
            interactive = True

        instances = self.db_services.get_db_instances()
        instance_list = [dbinst.id for dbinst in instances]

        if len(instances)==0:
            print "There are no instances in this region/account.  Use `db aws_create_instance` to make one first."
            return

        # show list of available instances, if there are none cancel immediately
        if interactive:
            valid = False
            print "Here are the available instances you have.  You can only use those listed as 'available':"
            for inst in instances:
                print "\t ", inst.id, "(", inst.status, ")"
            while not valid:
                instance_id = raw_input('Enter the instance identity you would like to use: ')
                res = self.db_services.validate_instance_id(instance_id)
                if (res == True):
                    valid = True
                else:
                    print res + " Try again, instance name not valid.  Check for typos."
                if instance_id in instance_list:
                    valid = True
                else:
                    valid = False
                    print "Try again, instance not present in this account.  Try again checking for typos."
        else:
            res = self.db_services.validate_instance_id(instance_id)
            if (res != True):
                print "*** Error, instance name either not valid.  Try again checking for typos."
                return
            if instance_id not in instance_list:
                print "*** Error, This instance not present in this account.  Try again checking for typos.  Run `db aws_list_instances` to see valid list."
                return

        r = raw_input("Switching your DB settings to use this instance.  Are you sure you want to do this? ")
        if r == 'y':
            # ask for password
            valid = False
            while not valid:
                password = raw_input('enter the master password for this instance: ')
                res = self.db_services.validate_instance_password(password)
                if res != True:
                    print "*** Error: password seems incorrect, doesn't conform to AWS rules.  Try again"
                else:
                    valid = True

            # get instance
            myinstance = self.db_services.get_db_instance_info(instance_id)
            if myinstance:
                # add security zone to this node to allow connections
                my_ip = self.web_services.get_my_ip()
                if not self.db_services.allow_access_to_instance(myinstance, my_ip):
                    print "*** Error authorizing your ip address to connect to server (%s)." % my_ip
                    return
                print "AWS RDS database instance %s selected." % instance_id

                # using regular sql commands list available database on this node
                try:
                    db_url = 'mysql://' + myinstance.master_username + ":" + password + "@" + myinstance.endpoint[0] + ":" + str(myinstance.endpoint[1])
                    engine = sa.create_engine(db_url, echo=False)
                    e = engine.connect().execute
                    db_names = e("show databases").fetchall()
                except:
                    print "***  Error connecting to instance.  Your password my be incorrect."
                    return
                existing_dbs = [db[0] for db in db_names if db not in [('information_schema',), ('innodb',), ('mysql',), ('performance_schema',)]]
                create_db=False
                if len(existing_dbs)==0:
                    valid = False
                    while not valid:
                        db_name = raw_input("No existing DBs in this instance.  Enter a new name to create one: ")
                        res = self.db_services.validate_instance_dbname(db_name)
                        if res == True:
                            valid = True
                        else:
                            print res + " Try again."
                    create_db=True
                else:
                    print "Here are the available database tables"
                    for db in existing_dbs:
                        print "\t" + db
                    valid = False
                    while not valid:
                        db_name = raw_input("Enter the name of the database you want to use or a new name to create a new one: ")
                        res = self.db_services.validate_instance_dbname(db_name)
                        if res == True:
                            valid = True
                        else:
                            print res + " Try again."
                    if db_name not in existing_dbs:
                        create_db=True
                if create_db:
                    try:
                        connection.execute("CREATE DATABASE %s;" % db_name)
                    except:
                        print "*** Error creating database %s on instance %s" % (db_name,instance_id)
                        return
                base_url = 'mysql://' + myinstance.master_username + ":" + password + "@" + myinstance.endpoint[0] + ":" + str(myinstance.endpoint[1]) + "/" + db_name
                self.config.set("Database Parameters", "database_url", base_url)
                print "Successfully set your current database (database_url) to \n\t%s" % base_url
                if self.server.is_server_running()=='maybe' or self.server.is_server_running()=='yes':
                    self.do_restart_server('')
            else:
                print '\n'.join(["*** Error selecting database instance %s." % arg['<id>'],
                                 "Run `db list_db_instances` for current status of instances, only `available`",
                                 "instances can be used.  Also, your password may be incorrect."])
        else:
            return


    def db_create_aws_db_instance(self, instid=None, size=None, username=None, password=None, dbname=None):
        interactive = False
        if instid is None:
            interactive = True

        if interactive:
            print '\n'.join(['*************************************************',
                             'Ok, here are the rules on creating instances:',
                             '',
                             'instance id:',
                             '  Each instance needs an identifier.  This is the name',
                             '  of the virtual machine created for you on AWS.',
                             '  Rules are 1-63 alphanumeric characters, first must',
                             '  be a letter, must be unique to this AWS account.',
                             '',
                             'size:',
                             '  The maximum size of you database in GB.  Enter an',
                             '  integer between 5-1024',
                             '',
                             'master username:',
                             '  The username you will use to connect.  Rules are',
                             '  1-16 alphanumeric characters, first must be a letter,',
                             '  cannot be a reserved MySQL word/phrase',
                             '',
                             'master password:',
                             '  Rules are 8-41 alphanumeric characters',
                             '',
                             'database name:',
                             '  The name for the first database on this instance.  Rules are',
                             '  1-64 alphanumeric characters, cannot be a reserved MySQL word',
                             '*************************************************',
                             ''])

        if interactive:
            valid = False
            while not valid:
                instid = raw_input('enter an identifier for the instance (see rules above): ')
                res = self.db_services.validate_instance_id(instid)
                if res == True:
                    valid = True
                else:
                    print res + " Try again."
        else:
            res = self.db_services.validate_instance_id(instid)
            if res is not True:
                print res
                return

        if interactive:
            valid = False
            while not valid:
                size = raw_input('size of db in GB (5-1024): ')
                res = self.db_services.validate_instance_size(size)
                if res == True:
                    valid = True
                else:
                    print res + " Try again."
        else:
            res = self.db_services.validate_instance_size(size)
            if res is not True:
                print res
                return

        if interactive:
            valid = False
            while not valid:
                username = raw_input('master username (see rules above): ')
                res = self.db_services.validate_instance_username(username)
                if res == True:
                    valid = True
                else:
                    print res + " Try again."
        else:
            res = self.db_services.validate_instance_username(username)
            if res is not True:
                print res
                return

        if interactive:
            valid = False
            while not valid:
                password = raw_input('master password (see rules above): ')
                res = self.db_services.validate_instance_password(password)
                if res == True:
                    valid = True
                else:
                    print res + " Try again."
        else:
            res = self.db_services.validate_instance_password(password)
            if res is not True:
                print res
                return

        if interactive:
            valid = False
            while not valid:
                dbname = raw_input('name for first database on this instance (see rules): ')
                res = self.db_services.validate_instance_dbname(dbname)
                if res == True:
                    valid = True
                else:
                    print res + " Try again."
        else:
            res = self.db_services.validate_instance_dbname(dbname)
            if res is not True:
                print res
                return

        options = {
            'id': instid,
            'size': size,
            'username': username,
            'password': password,
            'dbname': dbname
        }
        instance = self.db_services.create_db_instance(options)
        if not instance:
            print '\n'.join(['*****************************',
                             '  Sorry, there was an error creating db instance.'])
        else:
            print '\n'.join(['*****************************',
                             '  Creating AWS RDS MySQL Instance',
                             '    id: ' + str(options['id']),
                             '    size: ' + str(options['size']) + " GB",
                             '    username: ' + str(options['username']),
                             '    password: ' + str(options['password']),
                             '    dbname: ' +  str(options['dbname']),
                             '    type: MySQL/db.t1.micro',
                             '    ________________________',
                             ' Be sure to store this information in a safe place.',
                             ' Please wait 5-10 minutes while your database is created in the cloud.',
                             ' You can run \'db aws_list_instances\' to verify it was created (status',
                             ' will say \'available\' when it is ready'])


    #+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.
    #  Basic shell commands
    #+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.+-+.
    @docopt_cmd
    def do_mode(self, arg):
        """
        Usage: mode
               mode <which>
        """
        restartServer = False
        if self.server.is_server_running() == 'yes' or self.server.is_server_running() == 'maybe':
            r = raw_input("Switching modes requires the server to restart. Really switch modes? y or n: ")
            if r != 'y':
                return
            restartServer = True
        if arg['<which>'] is None:
            if self.sandbox:
                arg['<which>'] = 'live'
            else:
                arg['<which>'] = 'sandbox'
        if arg['<which>'] == 'live':
            self.sandbox = False
            self.amt_services.set_sandbox(False)
            self.tally_hits()
            print 'Entered %s mode' % colorize('live', 'bold')
        else:
            self.sandbox = True
            self.amt_services.set_sandbox(True)
            self.tally_hits()
            print 'Entered %s mode' % colorize('sandbox', 'bold')
        if restartServer:
            self.server_restart()
    def help_mode(self):
        with open(self.helpPath + 'mode.txt', 'r') as helpText:
            print helpText.read()

    @docopt_cmd
    def do_hit(self, arg):
        """
        Usage:
          hit create [<numWorkers> <reward> <duration>]
          hit extend <HITid> [(--assignments <number>)] [(--expiration <minutes>)]
          hit expire (--all | <HITid> ...)
          hit dispose (--all | <HITid> ...)
          hit list [--active | --reviewable]
          hit help
        """

        if arg['create']:
            self.hit_create(arg['<numWorkers>'], arg['<reward>'], arg['<duration>'])
        elif arg['extend']:
            self.hit_extend(arg['<HITid>'], arg['<number>'], arg['<minutes>'])
        elif arg['expire']:
            self.hit_expire(arg['--all'], arg['<HITid>'])
        elif arg['dispose']:
            self.hit_dispose(arg['--all'], arg['<HITid>'])
        elif arg['list']:
            self.hit_list(arg['--active'], arg['--reviewable'])
        else:
            self.help_hit()

    hit_commands = ('create', 'extend', 'expire', 'dispose', 'list')

    def complete_hit(self, text, line, begidx, endidx):
        return  [i for i in PsiturkNetworkShell.hit_commands if i.startswith(text)]

    def help_hit(self):
        with open(self.helpPath + 'hit.txt', 'r') as helpText:
            print helpText.read()


    @docopt_cmd
    def do_worker(self, arg):
        """
        Usage:
          worker approve (--hit <hit_id> | <assignment_id> ...)
          worker reject (--hit <hit_id> | <assignment_id> ...)
          worker unreject (--hit <hit_id> | <assignment_id> ...)
          worker bonus  (--amount <amount> | --auto) (--hit <hit_id> | <assignment_id> ...)
          worker list [--submitted | --approved | --rejected] [(--hit <hit_id>)]
          worker help
        """
        if arg['approve']:
            self.worker_approve(arg['<hit_id>'], arg['<assignment_id>'])
        elif arg['reject']:
            self.worker_reject(arg['<hit_id>'], arg['<assignment_id>'])
        elif arg['unreject']:
            self.worker_unreject(arg['<hit_id>'], arg['<assignment_id>'])
        elif arg['list']:
            self.worker_list(arg['--submitted'], arg['--approved'], arg['--rejected'], arg['<hit_id>'])
        elif arg['bonus']:
            self.worker_bonus(arg['<hit_id>'], arg['--auto'], arg['<amount>'], "", arg['<assignment_id>'])
        else:
            self.help_worker()

    worker_commands = ('approve', 'reject', 'unreject', 'bonus', 'list', 'help')

    def complete_worker(self, text, line, begidx, endidx):
        return  [i for i in PsiturkNetworkShell.worker_commands if i.startswith(text)]

    def help_worker(self):
        with open(self.helpPath + 'worker.txt', 'r') as helpText:
            print helpText.read()

    # modified version of standard cmd help which lists psiturk commands first
    def do_help(self, arg):
        if arg:
            try:
                func = getattr(self, 'help_' + arg)
            except AttributeError:
                try:
                    doc = getattr(self, 'do_' + arg).__doc__
                    if doc:
                        self.stdout.write("%s\n" % str(doc))
                        return
                except AttributeError:
                    pass
                self.stdout.write("%s\n" % str(self.nohelp % (arg,)))
                return
            func()
        else:
            # Modifications start here
            names = dir(PsiturkNetworkShell)
            superNames = dir(Cmd)
            newNames = [m for m in names if m not in superNames]
            help = {}
            cmds_psiTurk = []
            cmds_super = []
            for name in names:
                if name[:5] == 'help_':
                    help[name[5:]]=1
            names.sort()
            prevname = ''
            for name in names:
                if name[:3] == 'do_':
                    if name == prevname:
                        continue
                    prevname = name
                    cmd = name[3:]
                    if cmd in help:
                        del help[cmd]
                    if name in newNames:
                        cmds_psiTurk.append(cmd)
                    else:
                        cmds_super.append(cmd)
            self.stdout.write("%s\n" % str(self.doc_leader))
            self.print_topics(self.psiTurk_header, cmds_psiTurk, 15, 80)
            self.print_topics(self.misc_header, help.keys(), 15, 80)
            self.print_topics(self.super_header, cmds_super, 15, 80)

def run(cabinmode=False, script=None):
    usingLibedit = 'libedit' in readline.__doc__
    if usingLibedit:
        print colorize('\n'.join(['libedit version of readline detected.',
                                   'readline will not be well behaved, which may cause all sorts',
                                   'of problems for the psiTurk shell. We highly recommend installing',
                                   'the gnu version of readline by running "sudo pip install gnureadline".',
                                   'Note: "pip install readline" will NOT work because of how the OSX',
                                   'pythonpath is structured.']), 'red', False)
    sys.argv = [sys.argv[0]] # drop arguments which were already processed in command_line.py
    #opt = docopt(__doc__, sys.argv[1:])
    config = PsiturkConfig()
    config.load_config()
    server = control.ExperimentServerController(config)
    if cabinmode:
        shell = PsiturkShell(config, server)
        shell.check_offline_configuration()
    else:
        amt_services = MTurkServices(config.get('AWS Access', 'aws_access_key_id'), \
                                     config.get('AWS Access', 'aws_secret_access_key'),
                                     config.getboolean('Shell Parameters', 'launch_in_sandbox_mode'))
        aws_rds_services = RDSServices(config.get('AWS Access', 'aws_access_key_id'), \
                                 config.get('AWS Access', 'aws_secret_access_key'),
                                 config.get('AWS Access', 'aws_region'))
        web_services = PsiturkOrgServices(config.get('psiTurk Access', 'psiturk_access_key_id'),
                                 config.get('psiTurk Access', 'psiturk_secret_access_id'))
        shell = PsiturkNetworkShell(config, amt_services, aws_rds_services, web_services, server, \
                                    config.getboolean('Shell Parameters', 'launch_in_sandbox_mode'))
    if script:
        with open(script, 'r') as f:
            for line in f:
                shell.onecmd_plus_hooks(line)
    else:
        shell.cmdloop()

########NEW FILE########
__FILENAME__ = user_utils
from functools import wraps, update_wrapper
from flask import Flask, render_template, request, Response, jsonify, make_response


#----------------------------------------------
# decorator for turning off browser caching
#----------------------------------------------
def nocache(f):
    """Stop caching for pages wrapped in nocache decorator."""
    def new_func(*args, **kwargs):
        resp = make_response(f(*args, **kwargs))
        resp.cache_control.no_cache = True
        return resp
    return update_wrapper(new_func, f)

#----------------------------------------------
# class for adding for authentication decorator
#----------------------------------------------
class PsiTurkAuthorization():

    def __init__(self, config):
        self.queryname = config.get('Server Parameters', 'login_username')
        self.querypw = config.get('Server Parameters', 'login_pw')

    def wrapper(func, args):
        return func(*args)

    def check_auth(self, username, password):
        """This function is called to check if a username /
        password combination is valid.
        """
        return username == self.queryname and password == self.querypw

    def authenticate(self):
        """Sends a 401 response that enables basic auth"""
        return Response(
        'Could not verify your access level for that URL.\n'
        'You have to login with proper credentials', 401,
        {'WWW-Authenticate': 'Basic realm="Login Required"'})

    def requires_auth(self, f):
        """
        Decorator to prompt for user name and password. Useful for data dumps, etc.
        that you don't want to be public.
        """
        @wraps(f)
        def decorated(*args, **kwargs):
            auth = request.authorization
            if not auth or not self.check_auth(auth.username, auth.password):
                return self.authenticate()
            return f(*args, **kwargs)
        return decorated
########NEW FILE########
__FILENAME__ = version
version_number = '2.0.1'

########NEW FILE########
__FILENAME__ = __main__

if __name__ == '__main__':
    import experiment
    experiment.run_webserver()

########NEW FILE########
__FILENAME__ = test_psiturk
import os
import sh
import shutil
import unittest
import tempfile
import psiturk
from faker import Faker


fake = Faker()  # Fake data generator

class FlaskTestClientProxy(object):
   '''Spoof user agent'''
   def __init__(self, app):
       self.app = app

   def __call__(self, environ, start_response):
       environ['REMOTE_ADDR'] = environ.get('REMOTE_ADDR', fake.ipv4())
       environ['HTTP_USER_AGENT'] = environ.get('HTTP_USER_AGENT', fake.user_agent())
       return self.app(environ, start_response)


class PsiTurkTestCase(unittest.TestCase):

    def setUp(self):
        '''Build up fixtures'''
        os.chdir('psiturk-example')
        import psiturk.db
        import psiturk.experiment
        self.db_fd, psiturk.experiment.app.config['DATABASE'] = tempfile.mkstemp()
        psiturk.experiment.app.wsgi_app = FlaskTestClientProxy(psiturk.experiment.app.wsgi_app)
        self.app = psiturk.experiment.app.test_client()
        psiturk.db.init_db()

        # Fake MTurk data
        self.worker_id = fake.md5(raw_output=False)
        self.hit_id = fake.md5(raw_output=False)
        self.assignment_id = fake.md5(raw_output=False)

    def test_default_page(self):
        '''Test that root page works.'''
        rv = self.app.get('/')
        assert 'Welcome to psiTurk!' in rv.data

    def test_exp_debug_no_url_vars(self):
        '''Test that exp page throws Error #1003 with no url vars.'''
        rv = self.app.get('/exp')
        assert 'Error: #1003' in rv.data

    def test_exp_with_all_url_vars_not_registered_on_ad_server(self):
        '''Test that exp page throws Error #1018 with all url vars but not registered.'''
        rv = self.app.get('/exp' + '?assignmentId=' + self.assignment_id + '&workerId=' + self.worker_id + '&hitId=' + self.hit_id)
        assert 'Error: #1018' in rv.data

    def tearDown(self):
        '''Tear down fixtures'''
        os.close(self.db_fd)
        os.chdir('..')
        os.unlink(psiturk.experiment.app.config['DATABASE'])


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
