__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# django-webodt documentation build configuration file, created by
# sphinx-quickstart on Fri Dec 17 14:56:15 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))
from webodt_sample import settings
from django.core.management import setup_environ
setup_environ(settings)


# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'django-webodt'
copyright = u'2010-2011, NetAngels team'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.3.1'
# The full version, including alpha/beta/rc tags.
release = '0.3.1'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'nature'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'django-webodtdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'django-webodt.tex', u'django-webodt Documentation',
   u'NetAngels team', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'django-webodt', u'django-webodt Documentation',
     [u'NetAngels team'], 1)
]

########NEW FILE########
__FILENAME__ = cache
# -*- coding: utf-8 -*-
import os
import hashlib
from webodt.conf import WEBODT_CACHE_DIR
from django.conf import settings
from webodt import Document

class CacheManager(object):

    def __init__(self):
        if not os.path.isdir(WEBODT_CACHE_DIR):
            os.makedirs(WEBODT_CACHE_DIR)

    def get(self, odf_document, format):
        filename = self.get_filename(odf_document, format)
        if os.path.isfile(filename):
            return Document(filename, delete_on_close=False)
        return None

    def set(self, odf_document, format, document):
        filename = self.get_filename(odf_document, format)
        fd = open(filename, 'w')
        document.seek(0)
        fd.write(document.read())
        document.seek(0)
        fd.close()

    def delete(self, odf_document, format):
        filename = self.get_filename(odf_document, format)
        if os.path.isfile(filename):
            os.unlink(filename)

    def get_filename(self, odf_document, format):
        sha1 = hashlib.new('sha1')
        odf_document.seek(0)
        odf_data = odf_document.read()
        sha1.update(odf_data)
        odf_document.seek(0)
        sha1.update(format)
        sha1.update(settings.SECRET_KEY)
        digest = sha1.hexdigest()
        filename = os.path.join(WEBODT_CACHE_DIR, '%s.%s' % (digest, format))
        return filename

    def clear(self):
        for filename in os.listdir(WEBODT_CACHE_DIR):
            path = os.path.join(WEBODT_CACHE_DIR, filename)
            if os.path.isfile(path):
                os.unlink(path)

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf8 -*-
from django.conf import settings

WEBODT_TEMPLATE_PATH = getattr(settings, 'WEBODT_TEMPLATE_PATH', '')
WEBODT_DEFAULT_FORMAT = getattr(settings, 'WEBODT_DEFAULT_FORMAT', 'doc')
WEBODT_ABIWORD_COMMAND = getattr(settings, 'WEBODT_ABIWORD_COMMAND', ['/usr/bin/abiword', '--plugin', 'AbiCommand'])
WEBODT_GOOGLEDOCS_EMAIL = getattr(settings, 'WEBODT_GOOGLEDOCS_EMAIL', None)
WEBODT_GOOGLEDOCS_PASSWORD = getattr(settings, 'WEBODT_GOOGLEDOCS_PASSWORD', None)
WEBODT_OPENOFFICE_SERVER = getattr(settings, 'WEBODT_OPENOFFICE_SERVER', ('localhost', 2002))
WEBODT_CONVERTER = getattr(settings, 'WEBODT_CONVERTER', 'webodt.converters.abiword.AbiwordODFConverter')
WEBODT_TMP_DIR = getattr(settings, 'WEBODT_TMP_DIR', None)
WEBODT_CACHE_DIR = getattr(settings, 'WEBODT_CACHE_DIR', '/tmp/webodt_cache')
WEBODT_ODF_TEMPLATE_PREPROCESSORS = getattr(settings, 'WEBODT_ODF_TEMPLATE_PREPROCESSORS', [
    'webodt.preprocessors.xmlfor_preprocessor',
    'webodt.preprocessors.unescape_templatetags_preprocessor',
])

########NEW FILE########
__FILENAME__ = abiword
# -*- coding: utf-8 -*-
from webodt import Document
from webodt.conf import WEBODT_ABIWORD_COMMAND
from webodt.converters import ODFConverter
from webodt.helpers import guess_format_and_filename
import subprocess


class AbiwordODFConverter(ODFConverter):


    def convert(self, document, format=None, output_filename=None, delete_on_close=True):
        output_filename, format = guess_format_and_filename(output_filename, format)
        process = subprocess.Popen(WEBODT_ABIWORD_COMMAND,
            stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE
        )
        args = (document.name, output_filename, format)
        process.communicate('convert %s %s %s\n' % args)
        fd = Document(output_filename, mode='r', delete_on_close=delete_on_close)
        return fd

########NEW FILE########
__FILENAME__ = googledocs
# -*- coding: utf-8 -*-
from cStringIO import StringIO
from lxml import etree
from webodt import Document
from webodt.conf import WEBODT_GOOGLEDOCS_EMAIL, WEBODT_GOOGLEDOCS_PASSWORD
from webodt.converters import ODFConverter
from webodt.helpers import guess_format_and_filename
import urllib
import urllib2
import uuid

AUTH_URL = 'https://www.google.com/accounts/ClientLogin'


class DeleteRequest(urllib2.Request):
    def get_method(self):
        return 'DELETE'


class GoogleDocsODFConverter(ODFConverter):


    def _get_auth_token(self):
        post_data = {
            'accountType': 'HOSTED_OR_GOOGLE',
            'Email': WEBODT_GOOGLEDOCS_EMAIL,
            'Passwd': WEBODT_GOOGLEDOCS_PASSWORD,
            'service': 'writely', # http://code.google.com/intl/ru/apis/documents/faq_gdata.html#clientlogin
            'source': 'NetAngels-webodt-0.1',
        }
        url = urllib2.urlopen(AUTH_URL, urllib.urlencode(post_data))
        data = url.read()
        data_dict = dict([line.split('=', 1) for line in data.splitlines()])
        return data_dict['Auth']


    def __init__(self):
        self.auth_token = self._get_auth_token()


    def convert(self, document, format=None, output_filename=None, delete_on_close=True):
        # opener = urllib2.build_opener(urllib2.HTTPSHandler(debuglevel=1))
        # urllib2.urlopen = opener.open
        output_filename, format = guess_format_and_filename(output_filename, format)
        # upload document
        url = 'https://docs.google.com/feeds/default/private/full'
        data = document.read()
        headers = {
            'GData-Version': '3.0',
            'Authorization': 'GoogleLogin auth=%s' % self.auth_token,
            'Content-Length': str(len(data)),
            'Content-Type': document.content_type,
            'Slug': '%s.%s' % (uuid.uuid4(), document.format),
        }
        request = urllib2.Request(url, data, headers)
        response = urllib2.urlopen(request)
        data = response.read()
        response.close()
        tree = etree.parse(StringIO(data))
        # get document resource id
        resource_id = tree.xpath('gd:resourceId/text()', namespaces={'gd': 'http://schemas.google.com/g/2005'})
        if len(resource_id) != 1:
            raise ValueError('Unexpected error. Document schema was changed')
        resource_id = resource_id[0]
        # get document URL
        document_url = tree.xpath('atom:content/@src', namespaces={'atom': 'http://www.w3.org/2005/Atom'})
        if len(document_url) != 1:
            raise ValueError('Unexpected error. Document schema was changed')
        document_url = document_url[0]
        url = document_url + '&exportFormat=%(format)s&format=%(format)s' % {'format': format}
        # download document
        headers = {
            'GData-Version': '3.0',
            'Authorization': 'GoogleLogin auth=%s' % self.auth_token,
        }
        request = urllib2.Request(url, None, headers)
        response = urllib2.urlopen(request)
        data = response.read()
        response.close()
        fd = open(output_filename, 'w')
        fd.write(data)
        fd.close()

        # remove document from google docs
        self._remove_document(resource_id)

        # return document
        fd = Document(output_filename, mode='r', delete_on_close=delete_on_close)
        return fd

    def _remove_document(self, resource_id):
        # remove document from google docs
        url = 'https://docs.google.com/feeds/default/private/full/%s?delete=true' % resource_id
        headers = {
            'GData-Version': '3.0',
            'If-Match': '*',
            'Authorization': 'GoogleLogin auth=%s' % self.auth_token,
        }
        request = DeleteRequest(url, None, headers)
        response = urllib2.urlopen(request)
        data = response.read()
        response.close()

########NEW FILE########
__FILENAME__ = openoffice
# -*- coding: utf-8 -*-
import uno
import unohelper
from com.sun.star.beans import PropertyValue
from com.sun.star.io import IOException, XOutputStream, XSeekable, XInputStream
from webodt import Document
from webodt.conf import WEBODT_OPENOFFICE_SERVER
from webodt.converters import ODFConverter
from webodt.helpers import guess_format_and_filename

OOO_CONNECTION = 'socket,host=%s,port=%s;urp;StarOffice.ComponentContext' % WEBODT_OPENOFFICE_SERVER


class OpenOfficeODFConverter(ODFConverter):


    def convert(self, document, format=None, output_filename=None, delete_on_close=True):
        output_filename, format = guess_format_and_filename(output_filename, format)
        ### Do the OpenOffice component dance
        context = uno.getComponentContext()
        resolver = context.ServiceManager.createInstanceWithContext('com.sun.star.bridge.UnoUrlResolver', context)
        unocontext = resolver.resolve('uno:%s' % OOO_CONNECTION)
        ### And some more OpenOffice magic
        unosvcmgr = unocontext.ServiceManager
        desktop = unosvcmgr.createInstanceWithContext('com.sun.star.frame.Desktop', unocontext)
        config = unosvcmgr.createInstanceWithContext('com.sun.star.configuration.ConfigurationProvider', unocontext)
        ### Load inputfile
        instream = InputStream(uno.ByteSequence(document.read()))
        inputprops = [
            PropertyValue('InputStream', 0, instream, 0),
        ]
        if document.format == 'html':
            inputprops.append(PropertyValue('FilterName', 0, 'HTML (StarWriter)', 0))
        doc = desktop.loadComponentFromURL('private:stream','_blank',0, tuple(inputprops))
        ### Update document links
        # skip ...
        ### Update document indexes
        # skip ...
        ### Write outputfile
        fd = open(output_filename, 'w')
        filter_name = formats[format]
        outputprops = [
            PropertyValue('FilterData', 0, uno.Any('[]com.sun.star.beans.PropertyValue', tuple(),), 0),
            PropertyValue('FilterName', 0, filter_name, 0),
            PropertyValue('OutputStream', 0, OutputStream(fd), 0),
            PropertyValue('Overwrite', 0, True, 0),
        ]
        if filter_name == 'Text (encoded)':
            outputprops.append(PropertyValue('FilterFlags', 0, 'UTF8, LF', 0))
        doc.storeToURL('private:stream', tuple(outputprops))
        doc.dispose()
        doc.close(True)
        fd.close()
        fd = Document(output_filename, mode='r', delete_on_close=delete_on_close)
        return fd



formats = {
    'bib': 'BibTeX_Writer',
    'doc': 'MS Word 97',
    'odt': 'writer8',
    'pdf': 'writer_pdf_Export',
    'rtf': 'Rich Text Format',
    'txt': 'Text (encoded)',
    'html': 'XHTML Writer File',
}

class OutputStream(unohelper.Base, XOutputStream):
    def __init__(self, descriptor=None):
        self.descriptor = descriptor
        self.closed = 0

    def closeOutput(self):
        self.closed = 1
        if not self.descriptor.isatty:
            self.descriptor.close()

    def writeBytes(self, seq):
        self.descriptor.write(seq.value)

    def flush(self):
        pass


class InputStream(XSeekable, XInputStream, unohelper.Base):
      def __init__(self, seq):
          self.s = seq
          self.nIndex = 0
          self.closed = 0

      def closeInput(self):
          self.closed = 1
          self.s = None

      def skipBytes(self, nByteCount):
          if(nByteCount + self.nIndex > len(self.s)):
              nByteCount = len(self.s) - self.nIndex
          self.nIndex += nByteCount

      def readBytes(self, retSeq, nByteCount):
          nRet = 0
          if(self.nIndex + nByteCount > len(self.s)):
              nRet = len(self.s) - self.nIndex
          else:
              nRet = nByteCount
          retSeq = uno.ByteSequence(self.s.value[self.nIndex : self.nIndex + nRet ])
          self.nIndex = self.nIndex + nRet
          return nRet, retSeq

      def readSomeBytes(self, retSeq , nByteCount):
          #as we never block !
          return readBytes(retSeq, nByteCount)

      def available(self):
          return len(self.s) - self.nIndex

      def getPosition(self):
          return self.nIndex

      def getLength(self):
          return len(self.s)

      def seek(self, pos):
          self.nIndex = pos


########NEW FILE########
__FILENAME__ = xhtml2pdf_converter
#coding:utf-8
from webodt.converters import ConverterError
from webodt.helpers import guess_format_and_filename
try:
    from xhtml2pdf import pisa
except ImportError:
    raise ImportError(u'To use xhtml2pdf converter, please, install xhtml2pdf')
from webodt import Document


class XHTML2PDFConverter(object):

    WEBODT_DEFAULT_FORMAT = 'pdf'

    def convert(self, document, format=None, output_filename=None, delete_on_close=True):
        if document.format != 'html':
            raise ConverterError(u'xhtml2pdf does not support %s input format' % document.format)
        if format != 'pdf':
            raise ConverterError(u'xhtml2pdf does not support %s output format' % format)
        output_filename, format = guess_format_and_filename(output_filename, format)
        input_file = document
        input_filename = document.name
        output_file = open(output_filename, 'wb')

        result = pisa.pisaDocument(
            input_file, output_file, path=input_filename, encoding='UTF-8',
        )

        output_file.close()

        if result.err:
            err_msg = 'Error rendering %s: %s' % (input_filename, result.err)
            raise ConverterError(err_msg)
        fd = Document(output_filename, mode='rb', delete_on_close=delete_on_close)
        return fd

########NEW FILE########
__FILENAME__ = helpers
# -*- coding: utf8 -*-
from webodt.conf import WEBODT_DEFAULT_FORMAT, WEBODT_TMP_DIR
import mimetypes
import tempfile
import os


def get_mimetype(format):
    ext = '.%s' % format
    map = mimetypes.types_map.copy()
    map['.odt'] = 'application/vnd.oasis.opendocument.text'
    map['.rtf'] = 'text/richtext'
    mimetype = map[ext]
    return mimetype


def guess_format_and_filename(filename, format):
    """ guess format and filename of the output document

    Either format and filename or both can be undefined (None) variables.
    Function determines undefined variables on basis of file extension or
    default values. If needed, temporary file will be created and returned.

    @return: tuple of strings (filename, format)
    """
    # filename is defined, format is undefined
    if filename and '.' in filename and not format:
        format = filename.split('.')[-1]
    # format is undefined
    if not format:
        format = WEBODT_DEFAULT_FORMAT
    # filename is undefined
    if not filename:
        lowlevel_fd, filename = tempfile.mkstemp(suffix = '.' + format, dir=WEBODT_TMP_DIR)
        os.close(lowlevel_fd)
    return filename, format
########NEW FILE########
__FILENAME__ = webodt_launch_openoffice
# -*- coding: utf-8 -*-
import os
from optparse import make_option
from django.core.management.base import BaseCommand, CommandError



class Command(BaseCommand):
    help = ('simple wrapper to launch OpenOffice/LibreOffice in a headless mode '
            'without detaching from the console')

    option_list = BaseCommand.option_list + (
        make_option('-H', '--host',
                    help='hostname which office application should bind to',
                    default='127.0.0.1'),
        make_option('-p', '--port',
                    type='int',
                    help='port number which office application should bind to',
                    default=2002),
        make_option('-x', '--executable',
                    help='path to the OpenOffice/LibreOffice executable'),
    )

    office_location_variants = [
        '/usr/lib/libreoffice/program/soffice.bin',
        '/usr/lib/openoffice/program/soffice.bin',
    ]


    def handle(self, *args, **options):
        path = self.get_office_path(options['executable'])
        accept_arg = ('--accept=socket,host={host},port={port};urp;'
                      'StarOffice.NamingService').format(**options)
        self.stdout.write('Launching OpenOffice.\n')
        os.execv(path, [path, accept_arg, '--headless'])

    def get_office_path(self, suggested_path):
        if suggested_path:
            if not os.path.isfile(suggested_path):
                raise CommandError('{0} not found'.format(suggested_path))
            return suggested_path
        for variant in self.office_location_variants:
            if os.path.isfile(variant):
                return variant
        raise CommandError('I cannot find soffice in any pre-defined location. '
                           'Please specify the location with the --executable option. '
                           'Feel free also to ask the author to include this '
                           'path to the list of well-known locations. The issue '
                           'tracker is available at '
                           'https://github.com/NetAngels/django-webodt/issues')

########NEW FILE########
__FILENAME__ = webodt_unpack
# -*- coding: utf-8 -*-
import os
import zipfile
from optparse import make_option
from django.core.management.base import BaseCommand, CommandError
from django.conf import settings
try:
    import tidy
except ImportError:
    XML_FORMAT = False
else:
    XML_FORMAT = True



class Command(BaseCommand):
    args = '[--dir dirname] template.odt'
    help = 'unpack an *.odt template into the directory with given name'

    dir_option = make_option('-d', '--dir', dest='dir',
            help='destination directory name', default=None)
    format_option = make_option('-f', '--format', action='store_true',
            dest='format',
            help='XML pretty print formatting (requires tidy package)', default=False)

    option_list = BaseCommand.option_list + (
        dir_option, format_option
    )

    def handle(self, *args, **options):
        self.args = args
        self.options = options
        self.filename = self._get_odt_file()
        self.dirname = self._get_output_directory()
        self._make_output_directory()
        fd = zipfile.ZipFile(self.filename, mode='r')
        fd.extractall(path=self.dirname)
        if options['format'] and XML_FORMAT:
            self._xml_format()


    def _get_odt_file(self):
        if len(self.args) < 1:
            raise CommandError('odt file is not defined')
        if len(self.args) > 1:
            raise CommandError('Sorry, I can handle only one .odt file at a time')
        full_path = os.path.join(settings.WEBODT_FILE_DIR, self.args[0])
        if not os.path.isfile(full_path):
            raise CommandError('File %s not found' % full_path)
        return full_path


    def _get_output_directory(self):
        if self.options['dir'] != None:
            return self.options['dir']
        basename = os.path.basename(self.filename)
        chunks = basename.split('.')
        if len(chunks) > 1:
            return '.'.join(chunks[:-1])
        else:
            return basename


    def _make_output_directory(self):
        if not os.path.isdir(self.dirname):
            os.makedirs(self.dirname)


    def _xml_format(self):
        for dirname, _, files in os.walk(self.dirname):
            for filename in files:
                full_name = os.path.join(dirname, filename)
                if full_name.endswith('.xml'):
                    i = open(full_name, 'r')
                    obj = tidy.parseString(i.read(), **self._tidy_options)
                    i.close()
                    o = open(full_name, 'w')
                    obj.write(o)


    _tidy_options = {
        'indent': True,
        'indent-spaces': 4,
        'wrap': 0,
        'char-encoding': 'utf8',
        'input-xml': True,
        'output-xml': True,
        # 'write-back': True,
    }

########NEW FILE########
__FILENAME__ = models
# -*- coding: utf8 -*-
########NEW FILE########
__FILENAME__ = preprocessors
# -*- coding: utf-8 -*-
from django.utils.importlib import import_module
from cStringIO import StringIO
from lxml import etree
import re


def list_preprocessors(preprocessors):
    """Create and return list of preprocessor functions
    On a basis parameters:
        `preprocessors` - list of preprocessor function names
    """
    ret = []
    for preprocessor in preprocessors:
        module_name, class_name = preprocessor.rsplit('.', 1)
        mod = import_module(module_name)
        preprocessor_func = getattr(mod, class_name)
        ret.append(preprocessor_func)
    return ret


def unescape_templatetags_preprocessor(template_content):
    replace_map = [
        ('&quot;', '"'),
        ('&lt;', '<'),
        ('&gt;', '>'),
        ('&amp;', '&'),
    ]
    for from_sym, to_sym in replace_map:
        for include_text in re.findall(r'{%(.+?)%}', template_content):
            new_include_text = include_text.replace(from_sym, to_sym)
            template_content = template_content.replace(
                '{%%%s%%}' % include_text, '{%%%s%%}' % new_include_text
            )
        for include_text in re.findall(r'{{(.+?)}}', template_content):
            new_include_text = include_text.replace(from_sym, to_sym)
            template_content = template_content.replace(
                '{{%s}}' % include_text, '{{%s}}' % new_include_text
            )
    return template_content

def xmlfor_preprocessor(template_content):
    tree = etree.parse(StringIO(template_content))

    # 1. search for xmlfor pairs
    re_xmlfor = re.compile(r'{%\s*xmlfor([^%]*)%}')
    re_endxmlfor = re.compile(r'{%\s*endxmlfor[^%]*%}')
    xmlfor_pairs = []
    xmlfor_starts = []
    for el in tree.iter():
        # search for start tag in text
        re_xmlfor_match = re_xmlfor.search(el.text) if el.text else None
        if re_xmlfor_match:
            forloop_clause = re_xmlfor_match.group(1)
            xmlfor_starts.append((el, forloop_clause)) # (<div ...>, 'person in people')
            el.text = re_xmlfor.sub('', el.text)
        # search for start tag in tail
        re_xmlfor_match = re_xmlfor.search(el.tail) if el.tail else None
        if re_xmlfor_match:
            forloop_clause = re_xmlfor_match.group(1)
            xmlfor_starts.append((el.getparent(), forloop_clause))
            el.tail = re_xmlfor.sub('', el.tail)
        # search for end tag in text
        re_endxmlfor_match = re_endxmlfor.search(el.text) if el.text else None
        if re_endxmlfor_match:
            try:
                start_el, forloop_clause = xmlfor_starts.pop()
            except IndexError, e:
                raise ValueError('Unexpected {%% endxmlfor %%} tag near %s' % el.text)
            xmlfor_pairs.append((start_el, el, forloop_clause))
            el.text = re_endxmlfor.sub('', el.text)
        # search for end tag in tail
        re_endxmlfor_match = re_endxmlfor.search(el.tail) if el.tail else None
        if re_endxmlfor_match:
            try:
                start_el, forloop_clause = xmlfor_starts.pop()
            except IndexError, e:
                raise ValueError('Unexpected {%% endxmlfor %%} tag near %s' % el.tail)
            xmlfor_pairs.append((start_el, el.getparent(), forloop_clause))
            el.tail = re_endxmlfor.sub('', el.tail)

    if xmlfor_starts:
        raise ValueError('Unclosed {%% xmlfor %%} tag near %s' % xmlfor_starts[0][0].text)

    # 2. for each pair create {% for %} loop around common ancestor
    for start_tag, end_tag, forloop_clause in xmlfor_pairs:
        ancestor_tag = _find_common_ancestor(start_tag, end_tag)

        # before
        for_text = u'{%% for%s%%}' % forloop_clause
        prev_tag = ancestor_tag.getprevious()
        if prev_tag is not None:
            prev_tail = prev_tag.tail or ''
            prev_tag.tail = u'%s%s' % (prev_tail, for_text)
        else:
            parent_tag = ancestor_tag.getparent()
            parent_text = parent_tag.text or ''
            parent_tag.text = u'%s%s' % (parent_text, for_text)

        # after
        ancestor_tail = ancestor_tag.tail or ''
        ancestor_tag.tail = u'%s%s' % (u'{% endfor %}', ancestor_tail)
    return _tree_to_string(tree)

def _find_common_ancestor(tag1, tag2):
    for ancestor in tag1.iterancestors():
        if ancestor in tag2.iterancestors():
            return ancestor

def _tree_to_string(tree):
    output = StringIO()
    tree.write(output)
    output.seek(0)
    return output.read()

########NEW FILE########
__FILENAME__ = shortcuts
# -*- coding: utf8 -*-
import os

from django.http import HttpResponse
from django.template import Context
from webodt.cache import CacheManager
from webodt.converters import converter
from webodt.helpers import get_mimetype

import webodt

def render_to(format, template_name,
        dictionary=None, context_instance=None, delete_on_close=True,
        cache=CacheManager, preprocessors=None
    ):
    """
    Convert the template given by :attr:`template_name` and :attr:`dictionary`
    to a document in given :attr:`format`. The document (file-like object) will
    be returned.

    :keyword format: Filename extension. It's possible to use "odt", "pdf",
                     "doc", "html" or "rtf" and probably more.

    :keyword context_instance: Optional parameter which should contain instance
                               of the subclass of `django.template.Context`.

    :keyword delete_on_close: Flag which defines whether the returned document
                              should be deleted automatically when closed.

    :keyword preprocessors: List of preprocessors overriding :attr:`WEBODT_ODF_TEMPLATE_PREPROCESSORS`
                            settings variable.  Suitable for ODF documents only.

    If the :attr:`template_name` ends with ".html", template is considered as HTML
    template, otherwise as ODF based template.
    """
    template = _Template(template_name, preprocessors=preprocessors)
    dictionary = dictionary or {}
    if context_instance:
        context_instance.update(dictionary)
    else:
        context_instance = Context(dictionary)
    document = template.render(context_instance, delete_on_close=delete_on_close)
    formatted_document = None
    if cache:
        cache_mgr = cache()
        formatted_document = cache_mgr.get(document, format)
    if not formatted_document:
        formatted_document = converter().convert(document, format, delete_on_close=delete_on_close)
        if cache:
            cache_mgr.set(document, format, formatted_document)
    document.close()
    return formatted_document


def render_to_response(template_name,
        dictionary=None, context_instance=None, filename=None, format='odt',
        cache=CacheManager, preprocessors=None, inline=None, iterator=False,
    ):
    """
    Using same options as :func:`render_to`, return :class:`django.http.HttpResponse`
    object. The document is automatically removed after the last byte of the
    response have been read.

    :keyword iterator: is a flag which determines whether returned
                       :class:`HttpResponse` object should be initialized with
                       a string or with an iterator.

    Consider using iterator if you tend to send large documents only, otherwise
    set this flag to :const:`False`. Be aware that some middlewares can "eat"
    your iterator-based HTTP responses. See `Ticket #6527
    <https://code.djangoproject.com/ticket/6527>`_ for more details.
    """
    mimetype = get_mimetype(format)
    content_fd = render_to(format, template_name, dictionary, context_instance,
        delete_on_close=True, cache=cache, preprocessors=preprocessors
    )
    if iterator:
        content = _ifile(content_fd)
    else:
        content = content_fd.read()
    response = HttpResponse(content, mimetype=mimetype)
    if not filename:
        filename = os.path.basename(template_name)
        filename += '.%s' % format
    response['Content-Disposition'] = (
        inline and 'inline' or 'attachment; filename="%s"' % filename
    )
    return response


def _Template(template_name, preprocessors):
    if template_name.endswith('.html'):
        return webodt.HTMLTemplate(template_name)
    return webodt.ODFTemplate(template_name, preprocessors=preprocessors)


def _ifile(fd, chunk_size=1024, close_on_exit=True):
    while True:
        data = fd.read(chunk_size)
        if not data:
            if close_on_exit:
                fd.close()
            break
        else:
            yield data

########NEW FILE########
__FILENAME__ = base
# -*- coding: utf-8 -*-
from django.template import Context
from django.utils import unittest
from webodt.converters.abiword import AbiwordODFConverter
from webodt.converters.googledocs import GoogleDocsODFConverter
from webodt.converters.openoffice import OpenOfficeODFConverter
from webodt.converters.xhtml2pdf_converter import XHTML2PDFConverter
import datetime
import os
import webodt


class ODFTemplateTest(unittest.TestCase):

    def test_packed_template(self):
        template = webodt.ODFTemplate('sample.odt')
        content = template.get_content_xml()
        self.assertTrue('{{ username }}' in content)

    def test_unpacked_template(self):
        template = webodt.ODFTemplate('sample')
        content = template.get_content_xml()
        self.assertTrue('{{ username }}' in content)

    def test_html_template(self):
        template = webodt.HTMLTemplate('sample.html')
        content = template.get_content()
        self.assertTrue('{{ username }}' in content)


class ODFDocumentTest(unittest.TestCase):

    def test_file(self):
        for template_name in 'sample sample.odt'.split():
            self._test_file(template_name)

    def _test_file(self, template_name):
        template = webodt.ODFTemplate(template_name)
        context = {
            'username': 'John Doe',
            'balance': 10.01
        }
        document = template.render(Context(context))
        self.assertTrue(os.path.isfile(document.name))
        self.assertEqual(os.stat(document.name).st_mode & 0777, 0600)
        self.assertEqual(document.format, 'odt')
        self.assertTrue('John Doe' in document.get_content_xml())
        document.delete()
        self.assertFalse(os.path.isfile(document.name))

    def test_document_auto_removal(self):
        template = webodt.ODFTemplate('sample.odt')
        context = {
            'username': 'John Doe',
            'balance': 10.01
        }
        document = template.render(Context(context), delete_on_close=True)
        self.assertTrue(os.path.isfile(document.name))
        document.close()
        self.assertFalse(os.path.isfile(document.name))


class HTMLDocumentTest(unittest.TestCase):

    def test_file(self):
        template = webodt.HTMLTemplate('sample.html')
        context = {
            'username': 'John Doe',
            'balance': 10.01
        }
        document = template.render(Context(context), delete_on_close=True)
        self.assertTrue(os.path.isfile(document.name))
        self.assertEqual(os.stat(document.name).st_mode & 0777, 0600)
        self.assertEqual(document.format, 'html')
        self.assertTrue('John Doe' in document.get_content())
        document.delete()
        self.assertFalse(os.path.isfile(document.name))

    def test_utf8(self):
        template = webodt.HTMLTemplate('sample.html')
        context = {
            'username': u'Тест',
            'balance': 10.01
        }
        document = template.render(Context(context), delete_on_close=True)
        self.assertTrue(os.path.isfile(document.name))
        self.assertTrue('Тест' in document.get_content()) # we compare bytes, not unicode symbols
        document.delete()


class _ConverterTest(object):
    context = {
        'username': 'John Doe',
        'balance': 10.01
    }
    Converter = None

    def test_converter(self):
        template = webodt.ODFTemplate('sample.odt')
        document = template.render(Context(self.context))
        converter = self.Converter()
        html_document = converter.convert(document, 'html')
        html_data = html_document.read()
        self.assertTrue('John Doe' in html_data)
        document.close()
        html_document.close()
        self.assertFalse(os.path.isfile(document.name))
        self.assertFalse(os.path.isfile(html_document.name))

    def test_convert_utf8(self):
        template = webodt.ODFTemplate('russian_sample.odt')
        document = template.render(Context({'ts': datetime.datetime.now()}))
        converter = self.Converter()
        pdf_document = converter.convert(document, 'pdf')
        pdf_document.read()

    def test_header_and_footer(self):
        """ Check that data in header and footer are handled correctly """
        template = webodt.ODFTemplate('header_sample.odt')
        document = template.render(Context(self.context))
        converter = self.Converter()
        html_document = converter.convert(document, 'html')
        html_data = html_document.read()
        self.assertTrue('John Doe' in html_data)
        document.close()
        html_document.close()

    def test_html_converter(self):
        template = webodt.HTMLTemplate('sample.html')
        document = template.render(Context(self.context), delete_on_close=False)
        converter = self.Converter()
        odt_document = converter.convert(document, 'odt', delete_on_close=False)
        odt_document2 = webodt.ODFDocument(odt_document.name, delete_on_close=False)
        self.assertTrue('John' in odt_document2.get_content_xml())
        document.close()
        document.delete()
        odt_document.close()
        odt_document.delete()


class AbiwordODFConverterTest(_ConverterTest, unittest.TestCase):
    Converter = AbiwordODFConverter


class GoogleDocsODFConverterTest(_ConverterTest, unittest.TestCase):
    Converter = GoogleDocsODFConverter


class OpenOfficeODFConverterTest(_ConverterTest, unittest.TestCase):
    Converter = OpenOfficeODFConverter


class XHTML2PDFConverterTest(unittest.TestCase):

    def test_html_converter(self):
        context = {
            'username': 'John Doe',
            'balance': 10.01
        }
        template = webodt.HTMLTemplate('sample.html')
        document = template.render(Context(context), delete_on_close=False)
        converter = XHTML2PDFConverter()
        pdf_document = converter.convert(document, 'pdf', delete_on_close=False)
        document.close()
        document.delete()
        pdf_document.close()
        pdf_document.delete()

########NEW FILE########
__FILENAME__ = cache
# -*- coding: utf-8 -*-
import os
from django.utils import unittest
import webodt
from webodt.cache import CacheManager
from webodt.converters import converter
from django.template import Context


class CacheManagerTest(unittest.TestCase):

    def setUp(self):
        self.cache_manager = CacheManager()
        self.cache_manager.clear()
        self.converter = converter()

    def test_manager(self):
        template = webodt.ODFTemplate('sample.odt')
        context = {
            'username': 'John Doe',
            'balance': 10.01
        }
        format = 'pdf'
        # check that cache is empty
        odf_document = template.render(Context(context))
        cached_document = self.cache_manager.get(odf_document, format)
        self.assertEqual(cached_document, None)
        # store document to cache
        document = self.converter.convert(odf_document, format)
        self.cache_manager.set(odf_document, format, document)
        # check that cache is not empty
        cached_document = self.cache_manager.get(odf_document, format)
        self.assertEqual(cached_document.read(), document.read())
        # delete data from cache
        self.cache_manager.delete(odf_document, format)
        cached_document = self.cache_manager.get(odf_document, format)
        self.assertEqual(cached_document, None)

    def tearDown(self):
        self.cache_manager.clear()

########NEW FILE########
__FILENAME__ = preprocessors
# -*- coding: utf-8 -*-
from django.template import Context
from cStringIO import StringIO
from lxml import etree
import unittest
import webodt
from webodt.preprocessors import unescape_templatetags_preprocessor, xmlfor_preprocessor, _find_common_ancestor



class UnescapeTemplatetagsTest(unittest.TestCase):

    def test_unescape_templatetags_preprocessor(self):
        content = unescape_templatetags_preprocessor(
            u'{% if user == &quot;John Doe&quot; %}&lt;'
            u'{% if balance &gt; 10.00 %}{{ &quot;profit!&quot; }}{% endif %}'
            u'{% endif %}'
        )
        self.assertEqual(content,
            u'{% if user == "John Doe" %}&lt;'
            u'{% if balance > 10.00 %}{{ "profit!" }}{% endif %}'
            u'{% endif %}'
        )

    def test_unescape_in_templates(self):
        template = webodt.ODFTemplate('unescape_templatetags.odt',
            preprocessors=['webodt.preprocessors.unescape_templatetags_preprocessor',]
        )
        context = {'user': 'John Doe'}
        document = template.render(Context(context))
        self.assertTrue(
            'Unescape templatetags works!' in document.get_content_xml()
        )
        document.delete()


class XMLForTest(unittest.TestCase):

    def test_xmlfor_preprocessor(self):
        input_template = '''<table>
            <tr>
                <td>{% xmlfor user in users %}{{ user.username }}</td>
                <td>{{ user.balance }}{% endxmlfor %}</td>
            </tr>
        </table>'''
        expected_output_template = '''<table>
            {% for user in users %}<tr>
                <td>{{ user.username }}</td>
                <td>{{ user.balance }}</td>
            </tr>{% endfor %}
        </table>'''
        output_template = xmlfor_preprocessor(input_template)
        self.assertEqual(output_template, expected_output_template)

    def test_tail_xmlfor_preprocessor(self):
        input_template = '''<table>
            <tr>
                <td><div>hello</div>{% xmlfor user in users %}{{ user.username }}</td>
                <td><div>{{ user.balance }}</div>{% endxmlfor %}</td>
            </tr>
        </table>'''
        expected_output_template = '''<table>
            {% for user in users %}<tr>
                <td><div>hello</div>{{ user.username }}</td>
                <td><div>{{ user.balance }}</div></td>
            </tr>{% endfor %}
        </table>'''
        output_template = xmlfor_preprocessor(input_template)
        self.assertEqual(output_template, expected_output_template)

    def test_find_common_ancestor(self):
        template = '''
        <table>
            <tr>
                <td><p>foo</p></td>
                <td><div><span>bar</span></div></td>
            </tr>
        </table>
        '''
        tree = etree.parse(StringIO(template))
        start = tree.xpath('//table/tr/td/p')[0]
        end = tree.xpath('//table/tr/td/div/span')[0]
        expected_ancestor = tree.xpath('//table/tr')[0]
        ancestor = _find_common_ancestor(start, end)
        self.assertEqual(ancestor, expected_ancestor)

########NEW FILE########
__FILENAME__ = shortcuts
# -*- coding: utf8 -*-
from django.conf import settings
from django.test.client import Client
from django.utils import unittest
from webodt.shortcuts import render_to, render_to_response
from django.core.urlresolvers import reverse

class RenderToTest(unittest.TestCase):

    def test_render_to(self):
        context = {
            'username': 'John Doe',
            'balance': 10.01
        }
        html_fd = render_to('html', 'sample.odt', context)
        html_data = html_fd.read()
        html_fd.close()
        self.assertTrue('John Doe' in html_data)

    def test_html_render_to(self):
        context = {
            'username': 'John Doe',
            'balance': 10.01
        }
        html_fd = render_to('html', 'sample.html', context)
        html_data = html_fd.read()
        html_fd.close()
        self.assertTrue('John Doe' in html_data)

    def test_render_to_response(self):
        context = {
            'username': 'John Doe',
            'balance': 10.01
        }
        response = render_to_response('sample.odt', dictionary=context,
                                      format='html')
        self.assertTrue('John Doe' in response.content)

    def test_render_to_response_in_view(self):
        client = Client()
        path = reverse('webodt-test-pdf')
        response = client.get(path)
        self.assertEqual(response.status_code, 200)
        self.assertTrue(len(response.content))


class RenderToResponseIteratorTest(unittest.TestCase):
    """
    Render to response with iterator sometimes fails because middlewares eat
    response content. See Django ticket #6527 for more details.

    CommonMiddleware with settings.USE_ETAGS = True reproduces such an issue.
    """
    def setUp(self):
        self._etags = settings.USE_ETAGS
        settings.USE_ETAGS = True

    def tearDown(self):
        settings.USE_ETAGS = self._etags

    def test_render_to_response(self):
        client = Client()
        path = reverse('webodt-test-iterator')
        # iterator turned on
        response = client.get(path + '?iterator=true')
        self.assertEqual(len(response.content), 0)
        # iterator turned off
        response = client.get(path + '?iterator=false')
        self.assertTrue('John Doe' in  response.content)

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
from django.core.management import execute_manager
try:
    import settings # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n(If the file settings.py does indeed exist, it's causing an ImportError somehow.)\n" % __file__)
    sys.exit(1)

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = settings
# Django settings for sample project.

DEBUG = True
TEMPLATE_DEBUG = DEBUG

ADMINS = (
)

MANAGERS = ADMINS

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': '/tmp/sample.sqlite',
    }
}

TIME_ZONE = 'America/Chicago'
LANGUAGE_CODE = 'en-us'
SITE_ID = 1
USE_I18N = True
USE_L10N = True
MEDIA_ROOT = ''
MEDIA_URL = ''
ADMIN_MEDIA_PREFIX = '/media/'
SECRET_KEY = 'secret key'

TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
)

ROOT_URLCONF = 'webodt_sample.urls'

TEMPLATE_DIRS = (
)

INSTALLED_APPS = (
    'webodt',
)

from localsettings import *

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import patterns, url

urlpatterns = patterns('',
    url(r'^test/pdf/$', 'views.test_pdf', name='webodt-test-pdf'),
    url(r'^test/iterator/$', 'views.test_iterator', name='webodt-test-iterator'),
    url(r'^test/pdf_from_html/$', 'views.test_pdf_from_html', name='webodt-test-pdf-from-html'),
)

########NEW FILE########
__FILENAME__ = views
#coding:utf-8
from django.template.context import RequestContext
from webodt.shortcuts import render_to_response


def test_pdf(request):
    context = {'username': 'John Doe', 'balance': 10.01}
    return render_to_response('sample.odt',
        dictionary=context, format='pdf', filename='test.pdf',
        context_instance=RequestContext(request)
    )


def test_pdf_from_html(request):
    context = {'username': 'John Doe', 'balance': 10.01}
    return render_to_response('sample.html',
        dictionary=context, format='pdf', filename='test1.pdf',
        context_instance=RequestContext(request), cache=None,
    )


def test_iterator(request):
    iterator = request.GET.get('iterator') == 'true'
    context = {'username': 'John Doe', 'balance': 10.01}
    return render_to_response('sample.odt',
        dictionary=context, format='html', filename='test.html',
        iterator=iterator,
    )

########NEW FILE########
