The Inspector
=============

The [inspector panel](http://localhost:10010/field/wiki/PaletteOverview#TheInspector) is where you can edit some of the properties of boxes. Simple things - like their position, size and name - will always appear here for anything that you select. Additional properties will sometimes be show (based on what kind of box it is) and can be added or removed from this list using that little '+' gadget. 

Furthermore you can add your own custom properties to this list - just add a property to a box that ends with '_i' and it will appear here so you can quickly edit it.

More information about properties and boxes [can be found here](http://localhost:10010/field/wiki/SelfAndProperties); properties can be used to for some [advanced tricks](http://localhost:10010/field/wiki/SelfAndProperties).


The Selection Palette
=====================

This palette lets you select boxes by name, connection, type or access to global variables. The forward and backward arrows give you the selection history and double clicking on a name will pan the canvas over to the box.

The Code Editor
===============

In Field code resides in boxes. The editor is where you edit this code and by default the language of Field is Python.

Some helpful keyboard short-cuts:

   -   _command-return_ executes the current line or the currently text selection
   -   _command-0_ executes everything in the box (just as if you selected everything and pressed command-return)
   -   _command-left-arrow_ executes everything in the outermost "execution area". Areas appear automatically in the margin to record selections that have been executed previously. Right click on them for more options

By default you are editing the code that stored in the property "python_source". But you can edit other properties here to ---- see the popup box at the top (command-+ will cycle between them). Automatically executed things and GLSLang shader sources are stored here for example. If you activate the WrapInTransform plugin, you'll be able to change the langage of this text editor (a drop-down box will be added to the top of the editor).

Finally, some useful peculularites of Field's code editor. Firstly, you can embed [GUI elements into it](http://localhost:10010/field/EmbeddingGui) (sliders, color pickers, graphs and even other programming languages) --- check out the right click menu. Secondly, the undo stack for the editor is kept separately for each box (it's also saved with the document).

Complete documentation for the text editor [starts here](http://localhost:10010/field/TextEditor).

This directory contains only a subset of the Distutils, specifically
the Python modules in the 'distutils' and 'distutils.command'
packages.  This is all you need to distribute and install Python
modules using the Distutils.  There is also a separately packaged
standalone version of the Distutils available for people who want to
upgrade the Distutils without upgrading Python, available from the
Distutils web page:

    http://www.python.org/sigs/distutils-sig/

The standalone version includes all of the code in this directory,
plus documentation, test scripts, examples, etc.

The Distutils documentation is divided into two documents, "Installing
Python Modules", which explains how to install Python packages, and
"Distributing Python Modules", which explains how to write setup.py
files.  Both documents are part of the standard Python documentation
set, and are available from http://www.python.org/doc/current/ .

        Greg Ward (gward@python.net)

$Id: README 29650 2002-11-13 13:26:59Z akuchling $

This directory exists so that 3rd party packages can be installed
here.  Read the source for site.py for more details.

This directory only contains tests for outstanding bugs that cause
the interpreter to segfault.  Ideally this directory should always
be empty.  Sometimes it may not be easy to fix the underlying cause.

Each test should fail when run from the command line:

	./python Lib/test/crashers/weakref_in_del.py

Each test should have a link to the bug report:

	# http://python.org/sf/BUG#

Put as much info into a docstring or comments to help determine
the cause of the failure.  Particularly note if the cause is
system or environment dependent and what the variables are.

Once the crash is fixed, the test case should be moved into an appropriate
test (even if it was originally from the test suite).  This ensures the
regression doesn't happen again.  And if it does, it should be easier
to track down.

This directory contains test cases that are known to leak references.
The idea is that you can import these modules while in the interpreter
and call the leak function repeatedly.  This will only be helpful if
the interpreter was built in debug mode.  If the total ref count
doesn't increase, the bug has been fixed and the file should be removed
from the repository.

Note:  be careful to check for cyclic garbage.  Sometimes it may be helpful
to define the leak function like:

def leak():
    def inner_leak():
        # this is the function that leaks, but also creates cycles
    inner_leak()
    gc.collect() ; gc.collect() ; gc.collect()

Here's an example interpreter session for test_gestalt which still leaks:

>>> from test.leakers.test_gestalt import leak
[24275 refs]
>>> leak()
[28936 refs]
>>> leak()
[28938 refs]
>>> leak()
[28940 refs]
>>> 

Once the leak is fixed, the test case should be moved into an appropriate
test (even if it was originally from the test suite).  This ensures the
regression doesn't happen again.  And if it does, it should be easier
to track down.

Contains precompiled pyc files for testing org.python.core.PyBytecode by test_pbcvm - don't delete!

+++++++++++++++++++++++++++++++
Writing Python Regression Tests
+++++++++++++++++++++++++++++++

:Author: Skip Montanaro
:Contact: skip@mojam.com

Introduction
============

If you add a new module to Python or modify the functionality of an existing
module, you should write one or more test cases to exercise that new
functionality.  There are different ways to do this within the regression
testing facility provided with Python; any particular test should use only
one of these options.  Each option requires writing a test module using the
conventions of the selected option:

    - unittest_ based tests
    - doctest_ based tests
    - "traditional" Python test modules

Regardless of the mechanics of the testing approach you choose,
you will be writing unit tests (isolated tests of functions and objects
defined by the module) using white box techniques.  Unlike black box
testing, where you only have the external interfaces to guide your test case
writing, in white box testing you can see the code being tested and tailor
your test cases to exercise it more completely.  In particular, you will be
able to refer to the C and Python code in the CVS repository when writing
your regression test cases.

.. _unittest: http://www.python.org/doc/current/lib/module-unittest.html
.. _doctest: http://www.python.org/doc/current/lib/module-doctest.html

unittest-based tests
------------------
The unittest_ framework is based on the ideas of unit testing as espoused
by Kent Beck and the `Extreme Programming`_ (XP) movement.  The specific
interface provided by the framework is tightly based on the JUnit_
Java implementation of Beck's original SmallTalk test framework.  Please
see the documentation of the unittest_ module for detailed information on
the interface and general guidelines on writing unittest-based tests.

The test_support helper module provides two functions for use by
unittest-based tests in the Python regression testing framework:

- ``run_unittest()`` takes a number of ``unittest.TestCase`` derived class as
  parameters and runs the tests defined in those classes.
   
- ``run_suite()`` takes a populated ``TestSuite`` instance and runs the
  tests.
   
``run_suite()`` is preferred because unittest files typically grow multiple
test classes, and you might as well be prepared.

All test methods in the Python regression framework have names that
start with "``test_``" and use lower-case names with words separated with
underscores.

Test methods should *not* have docstrings!  The unittest module prints
the docstring if there is one, but otherwise prints the function name
and the full class name.  When there's a problem with a test, the
latter information makes it easier to find the source for the test
than the docstring.

All unittest-based tests in the Python test suite use boilerplate that
looks like this (with minor variations)::

    import unittest
    from test import test_support

    class MyTestCase1(unittest.TestCase):

        # Define setUp and tearDown only if needed

        def setUp(self):
            unittest.TestCase.setUp(self)
            ... additional initialization...

        def tearDown(self):
            ... additional finalization...
            unittest.TestCase.tearDown(self)

        def test_feature_one(self):
            # Testing feature one
            ...unit test for feature one...

        def test_feature_two(self):
            # Testing feature two
            ...unit test for feature two...

        ...etc...

    class MyTestCase2(unittest.TestCase):
        ...same structure as MyTestCase1...

    ...etc...

    def test_main():
        suite = unittest.TestSuite()
        suite.addTest(unittest.makeSuite(MyTestCase1))
        suite.addTest(unittest.makeSuite(MyTestCase2))
        ...add more suites...
        test_support.run_suite(suite)

    if __name__ == "__main__":
        test_main()

This has the advantage that it allows the unittest module to be used
as a script to run individual tests as well as working well with the
regrtest framework.

.. _Extreme Programming: http://www.extremeprogramming.org/
.. _JUnit: http://www.junit.org/

doctest based tests
-------------------
Tests written to use doctest_ are actually part of the docstrings for
the module being tested.  Each test is written as a display of an
interactive session, including the Python prompts, statements that would
be typed by the user, and the output of those statements (including
tracebacks, although only the exception msg needs to be retained then).
The module in the test package is simply a wrapper that causes doctest
to run over the tests in the module.  The test for the difflib module
provides a convenient example::

    import difflib
    from test import test_support
    test_support.run_doctest(difflib)

If the test is successful, nothing is written to stdout (so you should not
create a corresponding output/test_difflib file), but running regrtest
with -v will give a detailed report, the same as if passing -v to doctest.

A second argument can be passed to run_doctest to tell doctest to search
``sys.argv`` for -v instead of using test_support's idea of verbosity.  This
is useful for writing doctest-based tests that aren't simply running a
doctest'ed Lib module, but contain the doctests themselves.  Then at
times you may want to run such a test directly as a doctest, independent
of the regrtest framework.  The tail end of test_descrtut.py is a good
example::

    def test_main(verbose=None):
        from test import test_support, test_descrtut
        test_support.run_doctest(test_descrtut, verbose)

    if __name__ == "__main__":
        test_main(1)

If run via regrtest, ``test_main()`` is called (by regrtest) without
specifying verbose, and then test_support's idea of verbosity is used.  But
when run directly, ``test_main(1)`` is called, and then doctest's idea of
verbosity is used.

See the documentation for the doctest module for information on
writing tests using the doctest framework.

"traditional" Python test modules
---------------------------------
The mechanics of how the "traditional" test system operates are fairly
straightforward.  When a test case is run, the output is compared with the
expected output that is stored in .../Lib/test/output.  If the test runs to
completion and the actual and expected outputs match, the test succeeds, if
not, it fails.  If an ``ImportError`` or ``test_support.TestSkipped`` error
is raised, the test is not run.

Executing Test Cases
====================
If you are writing test cases for module spam, you need to create a file
in .../Lib/test named test_spam.py.  In addition, if the tests are expected
to write to stdout during a successful run, you also need to create an
expected output file in .../Lib/test/output named test_spam ("..."
represents the top-level directory in the Python source tree, the directory
containing the configure script).  If needed, generate the initial version
of the test output file by executing::

    ./python Lib/test/regrtest.py -g test_spam.py

from the top-level directory.

Any time you modify test_spam.py you need to generate a new expected
output file.  Don't forget to desk check the generated output to make sure
it's really what you expected to find!  All in all it's usually better
not to have an expected-out file (note that doctest- and unittest-based
tests do not).

To run a single test after modifying a module, simply run regrtest.py
without the -g flag::

    ./python Lib/test/regrtest.py test_spam.py

While debugging a regression test, you can of course execute it
independently of the regression testing framework and see what it prints::

    ./python Lib/test/test_spam.py

To run the entire test suite:

- [UNIX, + other platforms where "make" works] Make the "test" target at the
  top level::

    make test

- [WINDOWS] Run rt.bat from your PCBuild directory.  Read the comments at
  the top of rt.bat for the use of special -d, -O and -q options processed
  by rt.bat.

- [OTHER] You can simply execute the two runs of regrtest (optimized and
  non-optimized) directly::

    ./python Lib/test/regrtest.py
    ./python -O Lib/test/regrtest.py

But note that this way picks up whatever .pyc and .pyo files happen to be
around.  The makefile and rt.bat ways run the tests twice, the first time
removing all .pyc and .pyo files from the subtree rooted at Lib/.

Test cases generate output based upon values computed by the test code.
When executed, regrtest.py compares the actual output generated by executing
the test case with the expected output and reports success or failure.  It
stands to reason that if the actual and expected outputs are to match, they
must not contain any machine dependencies.  This means your test cases
should not print out absolute machine addresses (e.g. the return value of
the id() builtin function) or floating point numbers with large numbers of
significant digits (unless you understand what you are doing!).


Test Case Writing Tips
======================
Writing good test cases is a skilled task and is too complex to discuss in
detail in this short document.  Many books have been written on the subject.
I'll show my age by suggesting that Glenford Myers' `"The Art of Software
Testing"`_, published in 1979, is still the best introduction to the subject
available.  It is short (177 pages), easy to read, and discusses the major
elements of software testing, though its publication predates the
object-oriented software revolution, so doesn't cover that subject at all.
Unfortunately, it is very expensive (about $100 new).  If you can borrow it
or find it used (around $20), I strongly urge you to pick up a copy.

The most important goal when writing test cases is to break things.  A test
case that doesn't uncover a bug is much less valuable than one that does.
In designing test cases you should pay attention to the following:

    * Your test cases should exercise all the functions and objects defined
      in the module, not just the ones meant to be called by users of your
      module.  This may require you to write test code that uses the module
      in ways you don't expect (explicitly calling internal functions, for
      example - see test_atexit.py).

    * You should consider any boundary values that may tickle exceptional
      conditions (e.g. if you were writing regression tests for division,
      you might well want to generate tests with numerators and denominators
      at the limits of floating point and integer numbers on the machine
      performing the tests as well as a denominator of zero).

    * You should exercise as many paths through the code as possible.  This
      may not always be possible, but is a goal to strive for.  In
      particular, when considering if statements (or their equivalent), you
      want to create test cases that exercise both the true and false
      branches.  For loops, you should create test cases that exercise the
      loop zero, one and multiple times.

    * You should test with obviously invalid input.  If you know that a
      function requires an integer input, try calling it with other types of
      objects to see how it responds.

    * You should test with obviously out-of-range input.  If the domain of a
      function is only defined for positive integers, try calling it with a
      negative integer.

    * If you are going to fix a bug that wasn't uncovered by an existing
      test, try to write a test case that exposes the bug (preferably before
      fixing it).

    * If you need to create a temporary file, you can use the filename in
      ``test_support.TESTFN`` to do so.  It is important to remove the file
      when done; other tests should be able to use the name without cleaning
      up after your test.

.. _"The Art of Software Testing": 
        http://www.amazon.com/exec/obidos/ISBN=0471043281

Regression Test Writing Rules
=============================
Each test case is different.  There is no "standard" form for a Python
regression test case, though there are some general rules (note that
these mostly apply only to the "classic" tests; unittest_- and doctest_-
based tests should follow the conventions natural to those frameworks)::

    * If your test case detects a failure, raise ``TestFailed`` (found in
      ``test.test_support``).

    * Import everything you'll need as early as possible.

    * If you'll be importing objects from a module that is at least
      partially platform-dependent, only import those objects you need for
      the current test case to avoid spurious ``ImportError`` exceptions
      that prevent the test from running to completion.

    * Print all your test case results using the ``print`` statement.  For
      non-fatal errors, print an error message (or omit a successful
      completion print) to indicate the failure, but proceed instead of
      raising ``TestFailed``.

    * Use ``assert`` sparingly, if at all.  It's usually better to just print
      what you got, and rely on regrtest's got-vs-expected comparison to
      catch deviations from what you expect.  ``assert`` statements aren't
      executed at all when regrtest is run in -O mode; and, because they
      cause the test to stop immediately, can lead to a long & tedious
      test-fix, test-fix, test-fix, ... cycle when things are badly broken
      (and note that "badly broken" often includes running the test suite
      for the first time on new platforms or under new implementations of
      the language).

Miscellaneous
=============
There is a test_support module in the test package you can import for
your test case.  Import this module using either::

    import test.test_support

or::

    from test import test_support

test_support provides the following useful objects:

    * ``TestFailed`` - raise this exception when your regression test detects
      a failure.

    * ``TestSkipped`` - raise this if the test could not be run because the
      platform doesn't offer all the required facilities (like large
      file support), even if all the required modules are available.

    * ``ResourceDenied`` - this is raised when a test requires a resource that
      is not available.  Primarily used by 'requires'.

    * ``verbose`` - you can use this variable to control print output.  Many
      modules use it.  Search for "verbose" in the test_*.py files to see
      lots of examples.

    * ``forget(module_name)`` - attempts to cause Python to "forget" that it
      loaded a module and erase any PYC files.

    * ``is_resource_enabled(resource)`` - Returns a boolean based on whether
      the resource is enabled or not.

    * ``requires(resource [, msg])`` - if the required resource is not
      available the ResourceDenied exception is raised.
    
    * ``verify(condition, reason='test failed')``.  Use this instead of::

          assert condition[, reason]

      ``verify()`` has two advantages over ``assert``:  it works even in -O
      mode, and it raises ``TestFailed`` on failure instead of
      ``AssertionError``.

    * ``have_unicode`` - true if Unicode is available, false otherwise.

    * ``is_jython`` - true if the interpreter is Jython, false otherwise.

    * ``TESTFN`` - a string that should always be used as the filename when
      you need to create a temp file.  Also use ``try``/``finally`` to
      ensure that your temp files are deleted before your test completes.
      Note that you cannot unlink an open file on all operating systems, so
      also be sure to close temp files before trying to unlink them.

    * ``sortdict(dict)`` - acts like ``repr(dict.items())``, but sorts the
      items first.  This is important when printing a dict value, because
      the order of items produced by ``dict.items()`` is not defined by the
      language.

    * ``findfile(file)`` - you can call this function to locate a file
      somewhere along sys.path or in the Lib/test tree - see
      test_linuxaudiodev.py for an example of its use.

    * ``fcmp(x,y)`` - you can call this function to compare two floating
      point numbers when you expect them to only be approximately equal
      withing a fuzz factor (``test_support.FUZZ``, which defaults to 1e-6).

    * ``check_syntax(statement)`` - make sure that the statement is *not*
      correct Python syntax.


Python and C statement coverage results are currently available at

    http://www.musi-cal.com/~skip/python/Python/dist/src/

As of this writing (July, 2000) these results are being generated nightly.
You can refer to the summaries and the test coverage output files to see
where coverage is adequate or lacking and write test cases to beef up the
coverage.

Some Non-Obvious regrtest Features
==================================
    * Automagic test detection:  When you create a new test file
      test_spam.py, you do not need to modify regrtest (or anything else)
      to advertise its existence.  regrtest searches for and runs all
      modules in the test directory with names of the form test_xxx.py.

    * Miranda output:  If, when running test_spam.py, regrtest does not
      find an expected-output file test/output/test_spam, regrtest
      pretends that it did find one, containing the single line

      test_spam

      This allows new tests that don't expect to print anything to stdout
      to not bother creating expected-output files.

    * Two-stage testing:  To run test_spam.py, regrtest imports test_spam
      as a module.  Most tests run to completion as a side-effect of
      getting imported.  After importing test_spam, regrtest also executes
      ``test_spam.test_main()``, if test_spam has a ``test_main`` attribute.
      This is rarely required with the "traditional" Python tests, and
      you shouldn't create a module global with name test_main unless
      you're specifically exploiting this gimmick.  This usage does
      prove useful with unittest-based tests as well, however; defining
      a ``test_main()`` which is run by regrtest and a script-stub in the
      test module ("``if __name__ == '__main__': test_main()``") allows
      the test to be used like any other Python test and also work
      with the unittest.py-as-a-script approach, allowing a developer
      to run specific tests from the command line.

## Field

Field is an open-source software project initiated by OpenEndedGroup, for the creation of their digital artworks.

It is an environment for writing code to rapidly and experimentally assemble and explore algorithmic systems.

It is _visual_, it is __code-based__, it is ___hybrid___.

We think it has something to offer a diverse range of programmers and artists.

Field is developed and tested on Mac OS X (primarily) and Ubuntu 12 + Nvidia proprietary drivers.

*Our main documentation website is: http://openendedgroup.com/field*

### MacOS X

#### Building Field

Before anything else, ensure you have Xcode installed.  Field won't build without it.

To build Field with Java 7 (as supplied by Apple):

	$ cd /Applications
	$ git clone git://github.com/OpenEndedGroup/Field.git
	$ mv Field Field.app
	$ mkdir -p Field.app/Contents/Plugins/1.7.0.jdk/Contents
	$ cd Field.app/Contents/Plugins/1.7.0.jdk/Contents
	$ ln -s /System/Library/Frameworks/JavaVM.framework/Home
	$ cd ../../..
	$ ant

This will build the core of Field. Individual plugins have additional targets inside the `Contents/build.xml` file.

If you want to build them all (and have both Max/MSP and Processing 2.0b1 installed) then:

	$ ant extras_all

For the less bold, you can add individual plugins:

* `$ ant extras_jsrscripting` - adds nascant support for other languages (including Clojure and Ruby)
* `$ ant extras_online` - adds a plugin for writing in-browser JavaScript
* `$ ant extras_jfbxlib` - adds fbx support

... and so on. For the complete list, see the `Contents/build.xml` file.


#### Note

Notice we renamed the cloned repo to Field.app above?

This gives you a clickable "Field" application, so you can launch Field from your main Applications list.

Before this will work, you need to log out and back in after building Field for the first time.


#### Starting Field

Ensure Mercurial is installed first.  It can be installed using [OSX Homebrew](http://brew.sh) using:

	$ brew install hg

If you are using an older version of Java, you will need to do this before running Field the first time:

	$ cd /Applications/Field.app
	$ defaults write com.openendedgroup.Field use16 YES

Instead of launching Field from its application icon, you can start it from the command line, optionally passing a filename to open:

	$ cd /Applications/Field.app
	$ ./Contents/MacOS/field_mac64.sh -field.scratch nameOfFileToOpen.field

On first launch Field will ask where to store your Field files (we suggest ~/Documents/FieldWorkspace).

To start with [the tutorials](http://openendedgroup.com/field/FieldGATech), simply uncompress them and put them inside your workspace.


### Linux

#### Building Field

To build Field:

	$ git clone git://github.com/OpenEndedGroup/Field.git
	$ cd Field/Contents
	$ ant

This will build the core of Field. Individual plugins have additional targets inside the `Contents/build.xml` file.

If you want to build them all (and have both Max/MSP and Processing 2.0b1 installed) then:

	$ ant extras_all

For the less bold, you can add individual plugins:

* `$ ant extras_jsrscripting` - adds nascant support for other languages (including Clojure and Ruby)
* `$ ant extras_online` - adds a plugin for writing in-browser JavaScript
* `$ ant extras_jfbxlib` - adds fbx support

... and so on. For the complete list, see the `Contents/build.xml` file.


#### Starting field

To run:

	$ ./Contents/linux/field_linux32.sh -field.scratch nameOfFileToOpen.field

or:

	$ ./Contents/linux/field_linux64.sh -field.scratch nameOfFileToOpen.field

Should you find that Field crashes on startup complaining of "No Handles", you need to install libwebkitgtk-1.0. For example:

	$ sudo apt-get install libwebkitgtk-1.0-0

On first launch Field will ask where to store your Field files (we suggest ~/Documents/FieldWorkspace), and it will check to see if you have Mercurial installed.

To start with [the tutorials](http://openendedgroup.com/field/FieldGATech), simply uncompress them and put them inside your workspace.


