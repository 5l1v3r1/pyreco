__FILENAME__ = auth
from django.http import HttpResponse
from django.contrib.auth import authenticate
import re
import base64
from functools import wraps

def create_401unauthorized(body="Unauthorized"):
    res = HttpResponse(body)
    res.status_code = 401
    res['WWW-Authenticate'] = 'Basic realm="Secure Area"'
    return res

def firstmatch(regx, strg):
    m = re.match(regx, strg)
    if (m == None):
        return None
    else:
        return m.group(1)

def decodebasicauth(strg):
    if (strg == None):
        return None
    else:
        m = re.match(r'([^:]*)\:(.*)', base64.decodestring(strg))
        if (m != None):
            return (m.group(1), m.group(2))
        else:
            return None

def parse_basicauth(authstr):
    auth = decodebasicauth(firstmatch('Basic (.*)', authstr))
    if (auth == None):
        return None
    else:
        return authenticate(username = auth[0], password = auth[1])
        
def parse_user_from_request(request):
    user = None
    if (request.META.has_key('HTTP_AUTHORIZATION')):
        auth = request.META['HTTP_AUTHORIZATION']
        user = parse_basicauth(auth)

    return user

def login_required(view_f):
    @wraps(view_f)
    def wrapperf(request, *args, **kwargs):
        user = parse_user_from_request(request)

        if (user != None):
            request.user = user
            return view_f(request, *args, **kwargs)

        return create_401unauthorized()

    return wrapperf

def login_optional(view_f):
    @wraps(view_f)
    def wrapperf(request, *args, **kwargs):
        user = parse_user_from_request(request)

        if (user != None):
            request.user = user

        return view_f(request, *args, **kwargs)

    return wrapperf

########NEW FILE########
__FILENAME__ = 0001_initial
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'APIKey'
        db.create_table('api_apikey', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'], null=True)),
            ('special', self.gf('django.db.models.fields.IntegerField')(null=True)),
            ('key', self.gf('django.db.models.fields.CharField')(max_length=50)),
            ('enabled', self.gf('django.db.models.fields.BooleanField')(default=True)),
            ('comment', self.gf('django.db.models.fields.TextField')()),
        ))
        db.send_create_signal('api', ['APIKey'])

        # Adding model 'APILog'
        db.create_table('api_apilog', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('url', self.gf('django.db.models.fields.TextField')()),
            ('method', self.gf('django.db.models.fields.CharField')(max_length=20)),
            ('requestvars', self.gf('django.db.models.fields.TextField')()),
            ('apikey', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['api.APIKey'])),
            ('remoteip', self.gf('django.db.models.fields.CharField')(max_length=20)),
            ('date', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
        ))
        db.send_create_signal('api', ['APILog'])


    def backwards(self, orm):
        # Deleting model 'APIKey'
        db.delete_table('api_apikey')

        # Deleting model 'APILog'
        db.delete_table('api_apilog')


    models = {
        'api.apikey': {
            'Meta': {'object_name': 'APIKey'},
            'comment': ('django.db.models.fields.TextField', [], {}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '50'}),
            'special': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'null': 'True'})
        },
        'api.apilog': {
            'Meta': {'object_name': 'APILog'},
            'apikey': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['api.APIKey']"}),
            'date': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'method': ('django.db.models.fields.CharField', [], {'max_length': '20'}),
            'remoteip': ('django.db.models.fields.CharField', [], {'max_length': '20'}),
            'requestvars': ('django.db.models.fields.TextField', [], {}),
            'url': ('django.db.models.fields.TextField', [], {})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['api']
########NEW FILE########
__FILENAME__ = 0002_auto__add_field_apilog_useragent__add_field_apilog_appver
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding field 'APILog.useragent'
        db.add_column('api_apilog', 'useragent',
                      self.gf('django.db.models.fields.CharField')(default='', max_length=255),
                      keep_default=False)

        # Adding field 'APILog.appver'
        db.add_column('api_apilog', 'appver',
                      self.gf('django.db.models.fields.CharField')(default='', max_length=255),
                      keep_default=False)


    def backwards(self, orm):
        # Deleting field 'APILog.useragent'
        db.delete_column('api_apilog', 'useragent')

        # Deleting field 'APILog.appver'
        db.delete_column('api_apilog', 'appver')


    models = {
        'api.apikey': {
            'Meta': {'object_name': 'APIKey'},
            'comment': ('django.db.models.fields.TextField', [], {}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '50'}),
            'special': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'null': 'True'})
        },
        'api.apilog': {
            'Meta': {'object_name': 'APILog'},
            'apikey': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['api.APIKey']"}),
            'appver': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'date': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'method': ('django.db.models.fields.CharField', [], {'max_length': '20'}),
            'remoteip': ('django.db.models.fields.CharField', [], {'max_length': '20'}),
            'requestvars': ('django.db.models.fields.TextField', [], {}),
            'url': ('django.db.models.fields.TextField', [], {}),
            'useragent': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['api']
########NEW FILE########
__FILENAME__ = models
from django.contrib.gis.db import models
from django.contrib.auth.models import User, Group
from django.core.exceptions import ValidationError

API_KEY_IOS = 1
API_KEY_ANDROID = 2

class APIKey(models.Model):
    user = models.ForeignKey(User, null=True)
    special = models.IntegerField(null=True)
    key = models.CharField(max_length=50)
    enabled = models.BooleanField(default=True)
    comment = models.TextField()

class APILog(models.Model):
    url = models.TextField()
    method = models.CharField(max_length=20)
    requestvars = models.TextField()
    apikey = models.ForeignKey(APIKey)
    remoteip = models.CharField(max_length=20)
    useragent = models.CharField(max_length=255)
    appver = models.CharField(max_length=255)
    date = models.DateTimeField(auto_now=True)


########NEW FILE########
__FILENAME__ = tests
"""
This file demonstrates writing tests using the unittest module. These will pass
when you run "manage.py test".

Replace this with more appropriate tests for your application.
"""
from StringIO import StringIO

from django.contrib.auth.models import User, UserManager, Permission as P, AnonymousUser
from django.contrib.gis.geos import Point
from django.contrib.contenttypes.models import ContentType
from profiles.models import UserProfile
from django_reputation.models import Reputation
from django.test import TestCase
from django.test.client import Client
import unittest
from django_reputation.models import UserReputationAction, ReputationAction
from simplejson import loads, dumps

from django.conf import settings
from urlparse import urlparse
import urllib
from api.test_utils import setupTreemapEnv, teardownTreemapEnv, mkPlot, mkTree
from treemap.models import Species, Plot, Tree, Pending, TreePending, PlotPending, TreeResource
from treemap.forms import TreeAddForm

from api.models import APIKey, APILog
from api.views import InvalidAPIKeyException, plot_or_tree_permissions, plot_permissions, tree_resource_to_dict, _parse_application_version_header_as_dict, _attribute_requires_conversion, get_cql_query

import os
import struct
import base64

API_PFX = "/api/v0.1"

def create_signer_dict(user):
    key = APIKey(user=user,key="TESTING",enabled=True,comment="")
    key.save()

    return { "HTTP_X_API_KEY": key.key }

def _get_path(parsed_url):
    """
    Taken from a class method in the Django test client
    """
    # If there are parameters, add them
    if parsed_url[3]:
        return urllib.unquote(parsed_url[2] + ";" + parsed_url[3])
    else:
        return urllib.unquote(parsed_url[2])

def send_json_body(url, body_object, client, method, sign_dict=None):
    """
    Serialize a list or dictionary to JSON then send it to an endpoint.
    The "post" method exposed by the Django test client assumes that you
    are posting form data, so you need to manually setup the parameters
    to override that default functionality.
    """
    body_string = dumps(body_object)
    body_stream = StringIO(body_string)
    parsed_url = urlparse(url)
    client_params = {
        'CONTENT_LENGTH': len(body_string),
        'CONTENT_TYPE': 'application/json',
        'PATH_INFO': _get_path(parsed_url),
        'QUERY_STRING': parsed_url[4],
        'REQUEST_METHOD': method,
        'wsgi.input': body_stream,
    }
    return _send_with_client_params(url, client, client_params, sign_dict)

def send_binary_body(url, body_stream, size, content_type, client, method, sign_dict=None):
    parsed_url = urlparse(url)
    client_params = {
        'CONTENT_LENGTH': size,
        'CONTENT_TYPE': content_type,
        'PATH_INFO': _get_path(parsed_url),
        'QUERY_STRING': parsed_url[4],
        'REQUEST_METHOD': method,
        'wsgi.input': body_stream,
    }
    return _send_with_client_params(url, client, client_params, sign_dict)

def _send_with_client_params(url, client, client_params, sign_dict=None):
    if sign_dict is not None:
        client_params.update(sign_dict)

    return client.post(url, **client_params)


def post_json(url, body_object, client, sign_dict=None):
    """
    Serialize a list or dictionary to JSON then POST it to an endpoint.
    The "post" method exposed by the Django test client assumes that you
    are posting form data, so you need to manually setup the parameters
    to override that default functionality.
    """
    return send_json_body(url, body_object, client, 'POST', sign_dict)

def post_jpeg_file(url, file_path, client, sign_dict):
    return _post_binary_file(url, file_path, 'image/jpeg', client, sign_dict)

def post_png_file(url, file_path, client, sign_dict):
    return _post_binary_file(url, file_path, 'image/png', client, sign_dict)

def _post_binary_file(url, file_path, content_type, client, sign_dict=None):
    stat = os.stat(file_path)
    response = None
    f = open(file_path, 'rb')
    try:
        response = send_binary_body(url, f, stat.st_size, content_type, client, 'POST', sign_dict)
    finally:
        f.close()
    return response

def put_json(url, body_object, client, sign_dict=None):
    return send_json_body(url, body_object, client, 'PUT', sign_dict)

class Signing(TestCase):
    def setUp(self):
        settings.OTM_VERSION = "1.2.3"
        settings.API_VERSION = "0.1"

        setupTreemapEnv()

        self.u = User.objects.get(username="jim")

    def test_unsigned_will_fail(self):
        self.assertRaises(InvalidAPIKeyException, self.client.get,"%s/version" % API_PFX)

    def test_signed_header(self):
        key = APIKey(user=self.u,key="TESTING",enabled=True,comment="")
        key.save()

        ret = self.client.get("%s/version" % API_PFX, **{ "HTTP_X_API_KEY": key.key })
        self.assertEqual(ret.status_code, 200)

    def test_url_param(self):
        key = APIKey(user=self.u,key="TESTING",enabled=True,comment="")
        key.save()

        ret = self.client.get("%s/version?apikey=%s" % (API_PFX,key.key))
        self.assertEqual(ret.status_code, 200)

    def test_disabled_keys_dont_work(self):
        key = APIKey(user=self.u,key="TESTING",enabled=False,comment="")
        key.save()

        self.assertRaises(InvalidAPIKeyException, self.client.get, "%s/version" % API_PFX, **{ "X-API-Key": key.key })


    def tearDown(self):
        teardownTreemapEnv()


class Authentication(TestCase):
    def setUp(self):
        setupTreemapEnv()

        self.u = User.objects.get(username="jim")
        self.u.set_password("password")
        self.u.save()

        amy = User.objects.get(username="amy")
        amy.reputation = Reputation(user=amy)
        amy.reputation.save()
        amy_profile = UserProfile(user=amy)
        amy_profile.save()
        amy.set_password("password")
        amy.save()

        self.sign = create_signer_dict(self.u)

    def test_401(self):
        ret = self.client.get("%s/login" % API_PFX, **self.sign)
        self.assertEqual(ret.status_code, 401)


    def test_ok(self):
        auth = base64.b64encode("jim:password")
        withauth = dict(self.sign.items() + [("HTTP_AUTHORIZATION", "Basic %s" % auth)])

        ret = self.client.get("%s/login" % API_PFX, **withauth)
        self.assertEqual(ret.status_code, 200)

    def test_malformed_auth(self):
        withauth = dict(self.sign.items() + [("HTTP_AUTHORIZATION", "FUUBAR")])

        ret = self.client.get("%s/login" % API_PFX, **withauth)
        self.assertEqual(ret.status_code, 401)

        auth = base64.b64encode("foobar")
        withauth = dict(self.sign.items() + [("HTTP_AUTHORIZATION", "Basic %s" % auth)])

        ret = self.client.get("%s/login" % API_PFX, **withauth)
        self.assertEqual(ret.status_code, 401)


    def test_bad_cred(self):
        auth = base64.b64encode("jim:passwordz")
        withauth = dict(self.sign.items() + [("HTTP_AUTHORIZATION", "Basic %s" % auth)])

        ret = self.client.get("%s/login" % API_PFX, **withauth)
        self.assertEqual(ret.status_code, 401)

    def test_includes_permissions(self):
        amy = User.objects.get(username="amy")
        self.assertEqual(len(amy.user_permissions.all()), 0, 'Expected the test setUp to create user "amy" with no permissions')

        amy.user_permissions.add(P.objects.get(codename="delete_tree"))
        amy.save()
        amys_perm_count = len(amy.user_permissions.all())

        auth = base64.b64encode("amy:password")
        withauth = dict(self.sign.items() + [("HTTP_AUTHORIZATION", "Basic %s" % auth)])

        ret = self.client.get("%s/login" % API_PFX, **withauth)
        self.assertEqual(ret.status_code, 200, "Authentication failed so testing for permissions is blocked")
        self.assertIsNotNone(ret.content, "Response had no content so testing for permissions is blocked")
        content_dict = loads(ret.content)
        self.assertTrue('permissions' in content_dict, "The response did not contain a permissions attribute")
        self.assertEqual(amys_perm_count, len(content_dict['permissions']))
        self.assertTrue('treemap.delete_tree' in content_dict['permissions'], 'The "delete_tree" permission was not in the permissions list for the test user.')

    def user_has_type(self, user, typ):
        auth = base64.b64encode("%s:%s" % (user.username,user.username))
        withauth = dict(create_signer_dict(user).items() + [("HTTP_AUTHORIZATION", "Basic %s" % auth)])

        ret = self.client.get("%s/login" % API_PFX, **withauth)

        self.assertEqual(ret.status_code, 200)
        json = loads(ret.content)

        self.assertEqual(json['username'], user.username)
        self.assertEqual(json['user_type'], typ)

    def create_user(self, username):
        ben = User.objects.create_user(username, "%s@test.org" % username, username)
        ben.set_password(username)
        ben.save()
        ben_profile = UserProfile(user=ben)
        ben_profile.save()
        ben.reputation = Reputation(user=ben)
        ben.reputation.save()
        return ben

    def test_user_is_admin(self):
        ben = self.create_user("ben")
        ben.is_superuser = True
        ben.save()

        self.user_has_type(ben, {'name': 'administrator', 'level': 1000 })

        ben.delete()

    def test_user_is_editor(self):
        carol = self.create_user("carol")
        carol.reputation.reputation = 1001
        carol.reputation.save()

        self.user_has_type(carol, {'name': 'editor', 'level': 500 })

        carol.delete()

    def test_user_is_public(self):
        dave = self.create_user("dave")
        dave.reputation.reputation = 0
        dave.reputation.save()

        self.user_has_type(dave, {"name": "public", 'level': 0})

        dave.delete()


    def tearDown(self):
        teardownTreemapEnv()

class Logging(TestCase):
    def setUp(self):
        setupTreemapEnv()

        self.u = User.objects.get(username="jim")
        self.sign = create_signer_dict(self.u)

    def test_log_request(self):
        settings.SITE_ROOT = ''

        ret = self.client.get("%s/version?rvar=4,rvar2=5" % API_PFX, **self.sign)
        self.assertEqual(ret.status_code, 200)

        logs = APILog.objects.all()

        self.assertTrue(logs is not None and len(logs) == 1)

        key = APIKey.objects.get(user=self.u)
        log = logs[0]

        self.assertEqual(log.apikey,key)
        self.assertTrue(log.url.endswith("%s/version?rvar=4,rvar2=5" % API_PFX))
        self.assertEqual(log.method, "GET")
        self.assertEqual(log.requestvars, "rvar=4,rvar2=5")

    def tearDown(self):
        teardownTreemapEnv()

class Version(TestCase):
    def setUp(self):
        setupTreemapEnv()

        self.u = User.objects.get(username="jim")
        self.sign = create_signer_dict(self.u)

    def test_version(self):
        settings.OTM_VERSION = "1.2.3"
        settings.API_VERSION = "0.1"

        ret = self.client.get("%s/version" % API_PFX, **self.sign)

        self.assertEqual(ret.status_code, 200)
        json = loads(ret.content)

        self.assertEqual(json["otm_version"], settings.OTM_VERSION)
        self.assertEqual(json["api_version"], settings.API_VERSION)

    def tearDown(self):
        teardownTreemapEnv()


class TileRequest(TestCase):
    def setUp(self):
        setupTreemapEnv()

        self.u = User.objects.get(username="jim")

        self.sign = create_signer_dict(self.u)

    def tearDown(self):
        teardownTreemapEnv()

    def test_returns(self):
        p1 = mkPlot(self.u)
        p1.geometry = Point(-77,36)
        p1.save()

        p2 = mkPlot(self.u)
        p2.geometry = Point(-77.1,36.1)
        p2.save()

        #
        # Test #1 - Simple request
        # bbox(-78,35,-76,37) <--> bbox(-8682920,4163881,-8460281,4439106)
        #
        # Origin is bottom left
        #
        # Expected values:
        p1x = -77.0
        p1y = 36.0
        p1xM = -8571600.0
        p1yM = 4300621.0
        p2x = -77.1
        p2y = 36.1
        p2xM = -8582732.0
        p2yM = 4314389.0

        # Offset X values
        p1offsetx = p1xM - -8682920 #xmin
        p2offsetx = p2xM - -8682920 #xmin

        p1offsety = p1yM - 4163881.0 #ymin
        p2offsety = p2yM - 4163881.0 #ymin

        # Compute scale
        pixelsPerMeterX = 255.0 / (-8460281.0 - -8682920.0)
        pixelsPerMeterY = 255.0 / (4439106.0 - 4163881.0)

        # Computer origin offsets
        pixels1x = int(p1offsetx * pixelsPerMeterX + 0.5)
        pixels2x = int(p2offsetx * pixelsPerMeterX + 0.5)

        pixels1y = int(p1offsety * pixelsPerMeterY + 0.5)
        pixels2y = int(p2offsety * pixelsPerMeterY + 0.5)

        style = 0
        npts = 2

        # Format:
        # | File Header           | Section Header             | Pts                                        |
        # |0xA3A5EA00 | int: size | byte: style | short: # pts | 00 | byte:x1 | byte:y1 | byte:x2 | byte:y2 |
        testoutp = struct.pack("<IIBHxBBBB", 0xA3A5EA00, npts, style, npts, pixels2x, pixels2y, pixels1x, pixels1y)

        outp = self.client.get("%s/tiles?bbox=-78,35,-76,37" % API_PFX, **self.sign)

        self.assertEqual(testoutp, outp.content)


    def test_eats_same_point(self):
        x = 128 # these values come from the test_returns
        y = 127 # test case

        p1 = mkPlot(self.u)
        p1.geometry = Point(-77.0,36.0)
        p1.save()

        p2 = mkPlot(self.u)
        p2.geometry = Point(-77.0,36.0000001)
        p2.save()

        p3 = mkPlot(self.u)
        p3.geometry = Point(-76.99999,36)
        p3.save()

        p4 = mkPlot(self.u)
        p4.geometry = Point(-77.0,35.999999)
        p4.save()

        # These should all map to (x,y)->(128,127)
        npts = 1
        style = 0

        # Format:
        # | File Header           | Section Header             | Pts                                        |
        # |0xA3A5EA00 | int: size | byte: style | short: # pts | 00 | byte:x1 | byte:y1 | byte:x2 | byte:y2 |
        testoutp = struct.pack("<IIBHxBB", 0xA3A5EA00, npts, style, npts, x,y)

        outp = self.client.get("%s/tiles?bbox=-78,35,-76,37" % API_PFX, **self.sign)

        self.assertEqual(testoutp, outp.content)


class PlotListing(TestCase):
    def setUp(self):
        setupTreemapEnv()

        self.u = User.objects.get(username="jim")
        self.sign = create_signer_dict(self.u)
        self.client = Client()

    def tearDown(self):
        teardownTreemapEnv()

    def test_recent_edits(self):
        user = self.u
        p = mkPlot(user)
        p2 = mkPlot(user)
        t3 = mkTree(user)
        acts = ReputationAction.objects.all()

        content_type_p = ContentType(app_label='auth', model='Plot')
        content_type_p.save()

        reputation1 = UserReputationAction(action=acts[0],
                                           user=user,
                                           originating_user=user,
                                           content_type=content_type_p,
                                           object_id=p.pk,
                                           content_object=p,
                                           value=20)
        reputation1.save()

        auth = base64.b64encode("%s:%s" % (user.username,user.username))
        withauth = dict(create_signer_dict(user).items() + [("HTTP_AUTHORIZATION", "Basic %s" % auth)])

        ret = self.client.get("%s/user/%s/edits" % (API_PFX, user.pk), **withauth)
        json = loads(ret.content)

        self.assertEqual(len(json), 1) # Just on reputation item
        self.assertEqual(json[0]['plot_id'], p.pk)
        self.assertEqual(json[0]['id'], reputation1.pk)

        reputation2 = UserReputationAction(action=acts[1 % len(acts)],
                                           user=user,
                                           originating_user=user,
                                           content_type=content_type_p,
                                           object_id=p2.pk,
                                           content_object=p2,
                                           value=20)
        reputation2.save()

        ret = self.client.get("%s/user/%s/edits" % (API_PFX, user.pk), **withauth)
        json = loads(ret.content)

        self.assertEqual(len(json), 2) # Just on reputation item
        self.assertEqual(json[0]['plot_id'], p2.pk)
        self.assertEqual(json[0]['id'], reputation2.pk)

        self.assertEqual(json[1]['plot_id'], p.pk)
        self.assertEqual(json[1]['id'], reputation1.pk)

        reputation3 = UserReputationAction(action=acts[2 % len(acts)],
                                           user=user,
                                           originating_user=user,
                                           content_type=content_type_p,
                                           object_id=t3.pk,
                                           content_object=t3,
                                           value=20)
        reputation3.save()


        ret = self.client.get("%s/user/%s/edits" % (API_PFX, user.pk), **withauth)
        json = loads(ret.content)

        self.assertEqual(len(json), 3) # Just on reputation item
        self.assertEqual(json[0]['plot_id'], t3.plot.pk)
        self.assertEqual(json[0]['id'], reputation3.pk)

        self.assertEqual(json[1]['plot_id'], p2.pk)
        self.assertEqual(json[1]['id'], reputation2.pk)

        self.assertEqual(json[2]['plot_id'], p.pk)
        self.assertEqual(json[2]['id'], reputation1.pk)

        ret = self.client.get("%s/user/%s/edits?offset=1" % (API_PFX, user.pk), **withauth)
        json = loads(ret.content)

        self.assertEqual(len(json), 2) # Just on reputation item
        self.assertEqual(json[0]['plot_id'], p2.pk)
        self.assertEqual(json[0]['id'], reputation2.pk)

        self.assertEqual(json[1]['plot_id'], p.pk)
        self.assertEqual(json[1]['id'], reputation1.pk)

        ret = self.client.get("%s/user/%s/edits?offset=2&length=1" % (API_PFX, user.pk), **withauth)
        json = loads(ret.content)

        self.assertEqual(len(json), 1) # Just on reputation item
        self.assertEqual(json[0]['plot_id'], p.pk)
        self.assertEqual(json[0]['id'], reputation1.pk)

        ret = self.client.get("%s/user/%s/edits?length=1" % (API_PFX, user.pk), **withauth)
        json = loads(ret.content)

        self.assertEqual(len(json), 1) # Just on reputation item
        self.assertEqual(json[0]['plot_id'], t3.plot.pk)
        self.assertEqual(json[0]['id'], reputation3.pk)

        reputation1.delete()
        reputation2.delete()
        reputation3.delete()
        content_type_p.delete()
        p.delete()
        p2.delete()
        t3.delete()

    def test_edit_flags(self):
        content_type_p = ContentType(app_label='auth', model='Plot')
        content_type_p.save()

        content_type_t = ContentType(app_label='auth', model='Tree')
        content_type_t.save()

        p = P(codename="change_user",name="change_user",content_type=content_type_p)
        p.save()

        t = P(codename="change_user",name="change_user",content_type=content_type_t)
        t.save()

        ghost = AnonymousUser()

        peon = User(username="peon")
        peon.save()
        peon.reputation = Reputation(user=peon)
        peon.reputation.save()

        duke = User(username="duke")
        duke.save()
        duke.reputation = Reputation(user=duke)
        duke.reputation.save()

        leroi = User(username="leroi")
        leroi.active = True
        leroi.save() # double save required for m2m...
        leroi.reputation = Reputation(user=leroi)
        leroi.user_permissions.add(p)
        leroi.user_permissions.add(t)
        leroi.save()
        leroi.reputation.save()

        p_peon_0 = mkPlot(peon)
        p_peon_1 = mkPlot(peon)
        p_duke_2 = mkPlot(duke)

        t_duke_0 = mkTree(duke, plot=p_peon_0)
        t_peon_1 = mkTree(peon, plot=p_peon_1)
        t_duke_2 = mkTree(duke, plot=p_duke_2)

        p_roi_3 = mkPlot(leroi)
        t_roi_3 = mkTree(leroi, plot=p_roi_3)

        plots = [p_peon_0, p_peon_1, p_duke_2, p_roi_3]
        trees = [t_duke_0, t_peon_1, t_duke_2, t_roi_3]
        users = [ghost, peon, duke, leroi]

        def mkd(e, d):
            return { "can_delete": d, "can_edit": e }

        def mkdp(pe, pd, te=None, td=None):
            d = { "plot": mkd(pe,pd) }
            if td != None and te != None:
                d["tree"] = mkd(te, td)

            return d

        #################################
        # A None or Anonymous user can't
        # do anything
        for p in plots:
            self.assertEqual(mkd(False,False), plot_or_tree_permissions(p, ghost))
            self.assertEqual(mkdp(False,False,False,False), plot_permissions(p, ghost))

            self.assertEqual(mkd(False,False), plot_or_tree_permissions(p, None))
            self.assertEqual(mkdp(False,False,False,False), plot_permissions(p, None))

        for t in trees:
            self.assertEqual(mkd(False,False), plot_or_tree_permissions(t, ghost))
            self.assertEqual(mkd(False,False), plot_or_tree_permissions(t, None))

        #################################
        # A user can always delete or edit their own trees and plots
        #
        self.assertEqual(mkd(True,True), plot_or_tree_permissions(p_peon_0, peon))
        self.assertEqual(mkd(True,True), plot_or_tree_permissions(p_peon_1, peon))
        self.assertEqual(mkd(True,True), plot_or_tree_permissions(p_duke_2, duke))

        self.assertEqual(mkd(True,True), plot_or_tree_permissions(t_duke_0, duke))
        self.assertEqual(mkd(True,True), plot_or_tree_permissions(t_peon_1, peon))
        self.assertEqual(mkd(True,True), plot_or_tree_permissions(t_duke_2, duke))

        self.assertEqual(mkd(True,True), plot_or_tree_permissions(p_roi_3, leroi))
        self.assertEqual(mkd(True,True), plot_or_tree_permissions(t_roi_3, leroi))

        #################################
        # An admin user can always do anything
        #
        for p in plots:
            self.assertEqual(mkd(True,True), plot_or_tree_permissions(p, leroi))
            self.assertEqual(mkdp(True,True,True,True), plot_permissions(p, leroi))

        for t in trees:
            self.assertEqual(mkd(True,True), plot_or_tree_permissions(t, leroi))

        #################################
        # A user can edit other trees but can't delete
        #
        self.assertEqual(mkdp(True,False,True,False), plot_permissions(p_roi_3, duke))

        #################################
        # No one can edit readonly trees
        #
        for p in plots:
            p.readonly = True
            p.save()
        for t in trees:
            t.readonly = True
            t.save()

        for p in plots:
            for u in users:
                self.assertEqual(mkd(False,False), plot_or_tree_permissions(p, u))
                self.assertEqual(mkdp(False,False,False,False), plot_permissions(p, u))

        for t in trees:
            for u in users:
                self.assertEqual(mkd(False,False), plot_or_tree_permissions(t, u))





    def test_basic_data(self):
        p = mkPlot(self.u)
        p.width = 22
        p.length = 44
        p.present = True
        p.geometry = Point(55,56)
        p.geometry.srid = 4326
        p.readonly = False
        p.save()

        info = self.client.get("%s/plots" % API_PFX, **self.sign)

        self.assertEqual(info.status_code, 200)

        json = loads(info.content)

        self.assertEqual(len(json), 1)
        record = json[0]

        self.assertEqual(record["id"], p.pk)
        self.assertEqual(record["plot_width"], 22)
        self.assertEqual(record["plot_length"], 44)
        self.assertEqual(record["readonly"], False)
        self.assertEqual(record["geometry"]["srid"], 4326)
        self.assertEqual(record["geometry"]["lat"], 56)
        self.assertEqual(record["geometry"]["lng"], 55)
        self.assertEqual(record.get("tree"), None)

    def test_tree_data(self):
        p = mkPlot(self.u)
        t = mkTree(self.u, plot=p)

        t.species = None
        t.dbh = None
        t.present = True
        t.save()

        info = self.client.get("%s/plots" % API_PFX, **self.sign)

        self.assertEqual(info.status_code, 200)

        json = loads(info.content)

        self.assertEqual(len(json), 1)
        record = json[0]

        self.assertEqual(record["tree"]["id"], t.pk)

        t.species = Species.objects.all()[0]
        t.dbh = 11.2
        t.save()

        info = self.client.get("%s/plots" % API_PFX, **self.sign)

        self.assertEqual(info.status_code, 200)

        json = loads(info.content)

        self.assertEqual(len(json), 1)
        record = json[0]

        self.assertEqual(record["tree"]["species"], t.species.pk)
        self.assertEqual(record["tree"]["dbh"], t.dbh)
        self.assertEqual(record["tree"]["id"], t.pk)

    def test_paging(self):
        p0 = mkPlot(self.u)
        p0.present = False
        p0.save()

        p1 = mkPlot(self.u)
        p2 = mkPlot(self.u)
        p3 = mkPlot(self.u)

        r = self.client.get("%s/plots?offset=0&size=2" % API_PFX, **self.sign)

        rids = set([p["id"] for p in loads(r.content)])
        self.assertEqual(rids, set([p1.pk, p2.pk]))


        r = self.client.get("%s/plots?offset=1&size=2" % API_PFX, **self.sign)

        rids = set([p["id"] for p in loads(r.content)])
        self.assertEqual(rids, set([p2.pk, p3.pk]))


        r = self.client.get("%s/plots?offset=2&size=2" % API_PFX, **self.sign)

        rids = set([p["id"] for p in loads(r.content)])
        self.assertEqual(rids, set([p3.pk]))


        r = self.client.get("%s/plots?offset=3&size=2" % API_PFX, **self.sign)

        rids = set([p["id"] for p in loads(r.content)])
        self.assertEqual(rids, set())

        r = self.client.get("%s/plots?offset=0&size=5" % API_PFX, **self.sign)

        rids = set([p["id"] for p in loads(r.content)])
        self.assertEqual(rids, set([p1.pk, p2.pk, p3.pk]))

class Locations(TestCase):
    def setUp(self):
        setupTreemapEnv()

        self.user = User.objects.get(username="jim")
        self.sign = create_signer_dict(self.user)

    def test_locations_plots_endpoint_with_auth(self):
        auth = base64.b64encode("%s:%s" % (self.user.username,self.user.username))
        withauth = dict(create_signer_dict(self.user).items() + [("HTTP_AUTHORIZATION", "Basic %s" % auth)])

        response = self.client.get("%s/locations/0,0/plots" % API_PFX, **withauth)
        self.assertEqual(response.status_code, 200)

    def test_locations_plots_endpoint(self):
        response = self.client.get("%s/locations/0,0/plots" % API_PFX, **self.sign)
        self.assertEqual(response.status_code, 200)

    def test_locations_plots_endpoint_max_plots_param_must_be_a_number(self):
        response = self.client.get("%s/locations/0,0/plots?max_plots=foo" % API_PFX, **self.sign)
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.content, 'The max_plots parameter must be a number between 1 and 500')

    def test_locations_plots_endpoint_max_plots_param_cannot_be_greater_than_500(self):
        response = self.client.get("%s/locations/0,0/plots?max_plots=501" % API_PFX, **self.sign)
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.content, 'The max_plots parameter must be a number between 1 and 500')
        response = self.client.get("%s/locations/0,0/plots?max_plots=500" % API_PFX, **self.sign)
        self.assertEqual(response.status_code, 200)

    def test_locations_plots_endpoint_max_plots_param_cannot_be_less_than_1(self):
        response = self.client.get("%s/locations/0,0/plots?max_plots=0" % API_PFX, **self.sign)
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.content, 'The max_plots parameter must be a number between 1 and 500')
        response = self.client.get("%s/locations/0,0/plots?max_plots=1" % API_PFX, **self.sign)
        self.assertEqual(response.status_code, 200)

    def test_locations_plots_endpoint_distance_param_must_be_a_number(self):
        response = self.client.get("%s/locations/0,0/plots?distance=foo" % API_PFX, **self.sign)
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.content, 'The distance parameter must be a number')
        response = self.client.get("%s/locations/0,0/plots?distance=42" % API_PFX, **self.sign)
        self.assertEqual(response.status_code, 200)

    def test_plots(self):
        plot = mkPlot(self.user)
        plot.present = True
        plot.save()

        response = self.client.get("%s/locations/%s,%s/plots" % (API_PFX, plot.geometry.x, plot.geometry.y), **self.sign)

        self.assertEqual(response.status_code, 200)
        json = loads(response.content)

class CreatePlotAndTree(TestCase):

    def setUp(self):
        setupTreemapEnv()

        self.user = User.objects.get(username="jim")
        self.user.set_password("password")
        self.user.save()
        self.sign = create_signer_dict(self.user)
        auth = base64.b64encode("jim:password")
        self.sign = dict(self.sign.items() + [("HTTP_AUTHORIZATION", "Basic %s" % auth)])

    def test_create_plot_with_tree(self):
        data = {
            "lon": 35,
            "lat": 25,
            "geocode_address": "1234 ANY ST",
            "edit_address_street": "1234 ANY ST",
            "tree": {
                "height": 10
            }
        }

        plot_count = Plot.objects.count()
        reputation_count = UserReputationAction.objects.count()

        response = post_json( "%s/plots"  % API_PFX, data, self.client, self.sign)

        self.assertEqual(201, response.status_code, "Create failed:" + response.content)

        # Assert that a plot was added
        self.assertEqual(plot_count + 1, Plot.objects.count())
        # Assert that reputation was added
        self.assertEqual(reputation_count + 1, UserReputationAction.objects.count())

        response_json = loads(response.content)
        self.assertTrue("id" in response_json)
        id = response_json["id"]
        plot = Plot.objects.get(pk=id)
        self.assertEqual(35.0, plot.geometry.x)
        self.assertEqual(25.0, plot.geometry.y)
        tree = plot.current_tree()
        self.assertIsNotNone(tree)
        self.assertEqual(10.0, tree.height)

    def test_create_plot_with_invalid_tree_returns_400(self):
        data = {
            "lon": 35,
            "lat": 25,
            "geocode_address": "1234 ANY ST",
            "edit_address_street": "1234 ANY ST",
            "tree": {
                "height": 1000000
            }
        }

        tree_count = Tree.objects.count()
        reputation_count = UserReputationAction.objects.count()

        response = post_json( "%s/plots"  % API_PFX, data, self.client, self.sign)

        self.assertEqual(400, response.status_code, "Expected creating a million foot tall tree to return 400:" + response.content)

        body_dict = loads(response.content)
        self.assertTrue('error' in body_dict, "Expected the body JSON to contain an 'error' key")
        errors = body_dict['error']
        self.assertTrue(len(errors) == 1, "Expected a single error message to be returned")
        self.assertEqual('Height is too large.', errors[0])

        # Assert that a tree was _not_ added
        self.assertEqual(tree_count, Tree.objects.count())
        # Assert that reputation was _not_ added
        self.assertEqual(reputation_count, UserReputationAction.objects.count())

    def test_create_plot_with_geometry(self):
        data = {
            "geometry": {
                "lon": 35,
                "lat": 25,
            },
            "geocode_address": "1234 ANY ST",
            "edit_address_street": "1234 ANY ST",
            "tree": {
                "height": 10
            }
        }

        plot_count = Plot.objects.count()
        reputation_count = UserReputationAction.objects.count()

        response = post_json( "%s/plots"  % API_PFX, data, self.client, self.sign)

        self.assertEqual(201, response.status_code, "Create failed:" + response.content)

        # Assert that a plot was added
        self.assertEqual(plot_count + 1, Plot.objects.count())
        # Assert that reputation was added
        self.assertEqual(reputation_count + 1, UserReputationAction.objects.count())

        response_json = loads(response.content)
        self.assertTrue("id" in response_json)
        id = response_json["id"]
        plot = Plot.objects.get(pk=id)
        self.assertEqual(35.0, plot.geometry.x)
        self.assertEqual(25.0, plot.geometry.y)
        tree = plot.current_tree()
        self.assertIsNotNone(tree)
        self.assertEqual(10.0, tree.height)

class PendingTrigger(TestCase):
   def setUp(self):
        setupTreemapEnv()
        settings.PENDING_ON = True

        self.user = User.objects.get(username="jim")
        self.user.set_password("password")
        self.user.save()
        self.sign = create_signer_dict(self.user)
        auth = base64.b64encode("jim:password")
        self.sign = dict(self.sign.items() + [("HTTP_AUTHORIZATION", "Basic %s" % auth)])

        self.public_user1 = User.objects.get(username="amy")
        self.public_user1.set_password("password")
        self.public_user1.save()
        self.public_user1.reputation = Reputation(user=self.public_user1)
        self.public_user1.reputation.save()
        self.public_user1_sign = create_signer_dict(self.public_user1)
        public_user1_auth = base64.b64encode("amy:password")
        self.public_user1_sign = dict(self.public_user1_sign.items() + [("HTTP_AUTHORIZATION", "Basic %s" % public_user1_auth)])

        self.public_user2 = User.objects.get(username="olivia")
        self.public_user2.set_password("password")
        self.public_user2.save()
        self.public_user2.reputation = Reputation(user=self.public_user2)
        self.public_user2.reputation.save()
        self.public_user2_sign = create_signer_dict(self.public_user2)
        public_user2_auth = base64.b64encode("olivia:password")
        self.public_user2_sign = dict(self.public_user2_sign.items() + [("HTTP_AUTHORIZATION", "Basic %s" % public_user2_auth)])


   def create_standard_plot(self, user,x=50,y=50,width=1,length=2,geocoded_address='foo'):
      test_plot = mkPlot(user)
      test_plot.width = 1
      test_plot.length = 2
      test_plot.geocoded_address = 'foo'
      test_plot.save()

      self.assertEqual(50, test_plot.geometry.x)
      self.assertEqual(50, test_plot.geometry.y)
      self.assertEqual(1, test_plot.width)
      self.assertEqual(2, test_plot.length)
      self.assertEqual('foo', test_plot.geocoded_address)
      self.assertEqual(0, len(Pending.objects.all()), "Expected the test to start with no pending records")

      return test_plot

   def verify_standard_plot(self, response_json,x=50,y=50,width=1,length=2,geocoded_address='foo'):
      self.assertEqual(y, response_json['geometry']['lat'])
      self.assertEqual(x, response_json['geometry']['lng'])
      self.assertEqual(width, response_json['plot_width'])
      self.assertEqual(length, response_json['plot_length'])
      self.assertEqual(geocoded_address, response_json['address'])

   def make_and_edit(self, make_user, edit_user_sign, expectpends):
      for p in Pending.objects.all():
         p.delete()

      updated_values = {'geometry': {'lat': 70, 'lon': 60},
                        'plot_width': 11,
                        'plot_length': 22,
                        'geocoded_address': 'bar'}


      plot = self.create_standard_plot(make_user)

      reputation_count = UserReputationAction.objects.count()

      # Send the edit request as a public user
      response = put_json( "%s/plots/%d"  % (API_PFX, plot.id),
                           updated_values, self.client, edit_user_sign)

      response_json = loads(response.content)

      self.assertEqual(200, response.status_code)

      if expectpends:
         # Assert that nothing has changed. Pends should have been created instead
         response_json = loads(response.content)

         self.verify_standard_plot(response_json)
         self.assertEqual(reputation_count, UserReputationAction.objects.count())
         self.assertEqual(4, len(PlotPending.objects.all()),
                          "Expected 4 pends, one for each edited field")

         self.assertEqual(4, len(response_json['pending_edits'].keys()),
                          "Expected the json response to have a "\
                          "pending_edits dict with 4 keys, one for each field")

      else:
         # Assert that values have been updatd
         self.verify_standard_plot(response_json,
                                   x=60, y=70,
                                   width=11, length=22,
                                   geocoded_address='bar')

         self.assertTrue(not response_json['pending_edits'],
                         "Expected no pending edits")

   def test_public_edits_public(self):
      settings.PENDING_REQUIRED_FOR_PUBLIC_EDITING_PUBLIC_TREES = False
      self.make_and_edit(self.public_user1, self.public_user2_sign,
                         expectpends=False)

      settings.PENDING_REQUIRED_FOR_PUBLIC_EDITING_PUBLIC_TREES = True
      self.make_and_edit(self.public_user1, self.public_user2_sign,
                         expectpends=True)

   def test_public_edits_mgmt(self):
      settings.PENDING_REQUIRED_FOR_PUBLIC_EDITING_PUBLIC_TREES = False
      self.make_and_edit(self.user, self.public_user1_sign,
                         expectpends=True)

      settings.PENDING_REQUIRED_FOR_PUBLIC_EDITING_PUBLIC_TREES = True
      self.make_and_edit(self.user, self.public_user1_sign,
                         expectpends=True)

   def test_public_edits_own(self):
      settings.PENDING_REQUIRED_FOR_PUBLIC_EDITING_PUBLIC_TREES = False
      self.make_and_edit(self.public_user1, self.public_user1_sign,
                         expectpends=False)

      settings.PENDING_REQUIRED_FOR_PUBLIC_EDITING_PUBLIC_TREES = True
      self.make_and_edit(self.public_user1, self.public_user1_sign,
                         expectpends=False)

   def test_mgmt_edits_own(self):
      settings.PENDING_REQUIRED_FOR_PUBLIC_EDITING_PUBLIC_TREES = False
      self.make_and_edit(self.user, self.sign,
                         expectpends=False)

      settings.PENDING_REQUIRED_FOR_PUBLIC_EDITING_PUBLIC_TREES = True
      self.make_and_edit(self.user, self.sign,
                         expectpends=False)

   def test_mgmt_edits_public(self):
      settings.PENDING_REQUIRED_FOR_PUBLIC_EDITING_PUBLIC_TREES = False
      self.make_and_edit(self.public_user1, self.sign,
                         expectpends=False)

      settings.PENDING_REQUIRED_FOR_PUBLIC_EDITING_PUBLIC_TREES = True
      self.make_and_edit(self.public_user1, self.sign,
                         expectpends=False)

class UpdatePlotAndTree(TestCase):
    def setUp(self):
        setupTreemapEnv()
        settings.PENDING_ON = False

        self.user = User.objects.get(username="jim")
        self.user.set_password("password")
        self.user.save()
        self.sign = create_signer_dict(self.user)
        auth = base64.b64encode("jim:password")
        self.sign = dict(self.sign.items() + [("HTTP_AUTHORIZATION", "Basic %s" % auth)])

        self.public_user = User.objects.get(username="amy")
        self.public_user.set_password("password")
        self.public_user.save()
        self.public_user.reputation = Reputation(user=self.public_user)
        self.public_user.reputation.save()

        self.public_user_sign = create_signer_dict(self.public_user)
        public_user_auth = base64.b64encode("amy:password")
        self.public_user_sign = dict(self.public_user_sign.items() + [("HTTP_AUTHORIZATION", "Basic %s" % public_user_auth)])

    def test_invalid_plot_id_returns_400_and_a_json_error(self):
        response = put_json( "%s/plots/0"  % API_PFX, {}, self.client, self.sign)
        self.assertEqual(400, response.status_code)
        response_json = loads(response.content)
        self.assertTrue("error" in response_json)
        # Received an error message as expected in response_json['error']

    def test_update_plot(self):
        test_plot = mkPlot(self.user)
        test_plot.width = 1
        test_plot.length = 2
        test_plot.geocoded_address = 'foo'
        test_plot.save()
        self.assertEqual(50, test_plot.geometry.x)
        self.assertEqual(50, test_plot.geometry.y)
        self.assertEqual(1, test_plot.width)
        self.assertEqual(2, test_plot.length)
        self.assertEqual('foo', test_plot.geocoded_address)

        reputation_count = UserReputationAction.objects.count()

        updated_values = {'geometry': {'lat': 70, 'lon': 60}, 'plot_width': 11, 'plot_length': 22, 'geocoded_address': 'bar'}
        response = put_json( "%s/plots/%d"  % (API_PFX, test_plot.id), updated_values, self.client, self.sign)
        self.assertEqual(200, response.status_code)

        response_json = loads(response.content)
        self.assertEqual(70, response_json['geometry']['lat'])
        self.assertEqual(60, response_json['geometry']['lng'])
        self.assertEqual(11, response_json['plot_width'])
        self.assertEqual(22, response_json['plot_length'])
        self.assertEqual('bar', response_json['address'])
        self.assertEqual(reputation_count + 1, UserReputationAction.objects.count())

    def test_update_plot_with_pending(self):
        settings.PENDING_ON = True
        test_plot = mkPlot(self.user)
        test_plot.width = 1
        test_plot.length = 2
        test_plot.geocoded_address = 'foo'
        test_plot.save()
        self.assertEqual(50, test_plot.geometry.x)
        self.assertEqual(50, test_plot.geometry.y)
        self.assertEqual(1, test_plot.width)
        self.assertEqual(2, test_plot.length)
        self.assertEqual('foo', test_plot.geocoded_address)
        self.assertEqual(0, len(Pending.objects.all()), "Expected the test to start with no pending records")

        reputation_count = UserReputationAction.objects.count()

        updated_values = {'geometry': {'lat': 70, 'lon': 60}, 'plot_width': 11, 'plot_length': 22, 'geocoded_address': 'bar'}
        # Send the edit request as a public user
        response = put_json( "%s/plots/%d"  % (API_PFX, test_plot.id), updated_values, self.client, self.public_user_sign)
        self.assertEqual(200, response.status_code)

        # Assert that nothing has changed. Pends should have been created instead
        response_json = loads(response.content)
        self.assertEqual(50, response_json['geometry']['lat'])
        self.assertEqual(50, response_json['geometry']['lng'])
        self.assertEqual(1, response_json['plot_width'])
        self.assertEqual(2, response_json['plot_length'])
        self.assertEqual('foo', response_json['address'])
        self.assertEqual(reputation_count, UserReputationAction.objects.count())
        self.assertEqual(4, len(PlotPending.objects.all()), "Expected 4 pends, one for each edited field")

        self.assertEqual(4, len(response_json['pending_edits'].keys()), "Expected the json response to have a pending_edits dict with 4 keys, one for each field")

    def test_invalid_field_returns_200_field_is_not_in_response(self):
        test_plot = mkPlot(self.user)
        updated_values = {'foo': 'bar'}
        response = put_json( "%s/plots/%d"  % (API_PFX, test_plot.id), updated_values, self.client, self.sign)
        self.assertEqual(200, response.status_code)
        response_json = loads(response.content)
        self.assertFalse("error" in response_json.keys(), "Did not expect an error")
        self.assertFalse("foo" in response_json.keys(), "Did not expect foo to be added to the plot")

    def test_update_creates_tree(self):
        test_plot = mkPlot(self.user)
        test_plot_id = test_plot.id
        self.assertIsNone(test_plot.current_tree())
        updated_values = {'tree': {'dbh': 1.2}}
        response = put_json( "%s/plots/%d"  % (API_PFX, test_plot.id), updated_values, self.client, self.sign)
        self.assertEqual(200, response.status_code)
        tree = Plot.objects.get(pk=test_plot_id).current_tree()
        self.assertIsNotNone(tree)
        self.assertEqual(1.2, tree.dbh)

    def test_update_creates_tree_with_pending(self):
        settings.PENDING_ON = True
        test_plot = mkPlot(self.user)
        test_plot_id = test_plot.id
        self.assertIsNone(test_plot.current_tree())
        self.assertEqual(0, len(Pending.objects.all()), "Expected the test to start with no pending records")

        updated_values = {'tree': {'dbh': 1.2}}
        response = put_json( "%s/plots/%d"  % (API_PFX, test_plot.id), updated_values, self.client, self.public_user_sign)
        self.assertEqual(200, response.status_code)
        self.assertEqual(0, len(Pending.objects.all()), "Expected a new tree to be created, rather than creating pends")
        tree = Plot.objects.get(pk=test_plot_id).current_tree()
        self.assertIsNotNone(tree)
        self.assertEqual(1.2, tree.dbh)

    def test_update_tree(self):
        test_plot = mkPlot(self.user)
        test_tree = mkTree(self.user, plot=test_plot)
        test_tree_id = test_tree.id
        test_tree.dbh = 2.3
        test_tree.save()

        updated_values = {'tree': {'dbh': 3.9}}
        response = put_json( "%s/plots/%d"  % (API_PFX, test_plot.id), updated_values, self.client, self.sign)
        self.assertEqual(200, response.status_code)
        tree = Tree.objects.get(pk=test_tree_id)
        self.assertIsNotNone(tree)
        self.assertEqual(3.9, tree.dbh)

    def test_update_tree_with_pending(self):
        settings.PENDING_ON = True

        test_plot = mkPlot(self.user)
        test_tree = mkTree(self.user, plot=test_plot)
        test_tree_id = test_tree.id
        test_tree.dbh = 2.3
        test_tree.save()

        self.assertEqual(0, len(Pending.objects.all()), "Expected the test to start with no pending records")

        updated_values = {'tree': {'dbh': 3.9}}
        response = put_json( "%s/plots/%d"  % (API_PFX, test_plot.id), updated_values, self.client, self.public_user_sign)
        self.assertEqual(200, response.status_code)
        tree = Tree.objects.get(pk=test_tree_id)
        self.assertIsNotNone(tree)
        self.assertEqual(2.3, tree.dbh, "A pend should have been created instead of editing the tree value.")
        self.assertEqual(1, len(TreePending.objects.all()), "Expected 1 pend record for the edited field.")

        response_json = loads(response.content)
        self.assertEqual(1, len(response_json['pending_edits'].keys()), "Expected the json response to have a pending_edits dict with 1 keys")

    def test_update_tree_species(self):
        test_plot = mkPlot(self.user)
        test_tree = mkTree(self.user, plot=test_plot)
        test_tree_id = test_tree.id

        first_species = Species.objects.all()[0]
        updated_values = {'tree': {'species': first_species.id}}
        response = put_json( "%s/plots/%d"  % (API_PFX, test_plot.id), updated_values, self.client, self.sign)
        self.assertEqual(200, response.status_code)
        tree = Tree.objects.get(pk=test_tree_id)
        self.assertIsNotNone(tree)
        self.assertEqual(first_species, tree.species)

    def test_update_tree_returns_400_on_invalid_species_id(self):
        test_plot = mkPlot(self.user)
        mkTree(self.user, plot=test_plot)

        invalid_species_id = -1
        self.assertRaises(Exception, Species.objects.get, pk=invalid_species_id)

        updated_values = {'tree': {'species': invalid_species_id}}
        response = put_json( "%s/plots/%d"  % (API_PFX, test_plot.id), updated_values, self.client, self.sign)
        self.assertEqual(400, response.status_code)
        response_json = loads(response.content)
        self.assertTrue("error" in response_json.keys(), "Expected an 'error' key in the JSON response")

    def test_approve_pending_edit_returns_404_for_invalid_pend_id(self):
        settings.PENDING_ON = True
        invalid_pend_id = -1
        self.assertRaises(Exception, PlotPending.objects.get, pk=invalid_pend_id)
        self.assertRaises(Exception, TreePending.objects.get, pk=invalid_pend_id)

        response = post_json("%s/pending-edits/%d/approve/"  % (API_PFX, invalid_pend_id), None, self.client, self.sign)
        self.assertEqual(404, response.status_code, "Expected approving and invalid pend id to return 404")

    def test_reject_pending_edit_returns_404_for_invalid_pend_id(self):
        settings.PENDING_ON = True
        invalid_pend_id = -1
        self.assertRaises(Exception, PlotPending.objects.get, pk=invalid_pend_id)
        self.assertRaises(Exception, TreePending.objects.get, pk=invalid_pend_id)

        response = post_json("%s/pending-edits/%d/reject/"  % (API_PFX, invalid_pend_id), None, self.client, self.sign)
        self.assertEqual(404, response.status_code, "Expected approving and invalid pend id to return 404")

    def test_approve_pending_edit(self):
        self.assert_pending_edit_operation('approve')

    def test_reject_pending_edit(self):
        self.assert_pending_edit_operation('reject')

    def assert_pending_edit_operation(self, action, original_dbh=2.3, edited_dbh=3.9):
        settings.PENDING_ON = True

        test_plot = mkPlot(self.user)
        test_tree = mkTree(self.user, plot=test_plot)
        test_tree_id = test_tree.id
        test_tree.dbh = original_dbh
        test_tree.save()

        if action == 'approve':
            status_after_action = 'approved'
        elif action == 'reject':
            status_after_action = 'rejected'
        else:
            raise Exception('Action must be "approve" or "reject"')

        self.assertEqual(0, len(Pending.objects.all()), "Expected the test to start with no pending records")

        updated_values = {'tree': {'dbh': edited_dbh}}
        response = put_json( "%s/plots/%d"  % (API_PFX, test_plot.id), updated_values, self.client, self.public_user_sign)
        self.assertEqual(200, response.status_code)
        tree = Tree.objects.get(pk=test_tree_id)
        self.assertIsNotNone(tree)
        self.assertEqual(original_dbh, tree.dbh, "A pend should have been created instead of editing the tree value.")
        self.assertEqual(1, len(TreePending.objects.all()), "Expected 1 pend record for the edited field.")

        pending_edit = TreePending.objects.all()[0]
        self.assertEqual('pending', pending_edit.status, "Expected the status of the Pending to be 'pending'")
        response = post_json("%s/pending-edits/%d/%s/"  % (API_PFX, pending_edit.id, action), None, self.client, self.sign)
        self.assertEqual(200, response.status_code)

        pending_edit = TreePending.objects.get(pk=pending_edit.id)
        self.assertEqual(status_after_action, pending_edit.status, "Expected the status of the Pending to be '%s'" % status_after_action)
        test_tree = Tree.objects.get(pk=test_tree_id)

        if action == 'approve':
            self.assertEqual(edited_dbh, test_tree.dbh, "Expected dbh to have been updated on the Tree")
        elif action == 'reject':
            self.assertEqual(original_dbh, test_tree.dbh, "Expected dbh to NOT have been updated on the Tree")

        response_json = loads(response.content)
        self.assertTrue('tree' in response_json)
        self.assertTrue('dbh' in response_json['tree'])
        if action == 'approve':
            self.assertEqual(edited_dbh, response_json['tree']['dbh'], "Expected dbh to have been updated in the JSON response")
        elif action == 'reject':
            self.assertEqual(original_dbh, response_json['tree']['dbh'], "Expected dbh to NOT have been updated in the JSON response")

    def test_approve_plot_pending_with_mutiple_pending_edits(self):
        settings.PENDING_ON = True

        test_plot = mkPlot(self.user)
        test_plot.width = 100
        test_plot.length = 50
        test_plot.save()
        test_tree = mkTree(self.user, plot=test_plot)
        test_tree.dbh = 2.3
        test_tree.save()

        updated_values = {
            "plot_width": 125,
            "plot_length": 25,
            "tree": {
                "dbh": 3.9
            }
        }

        response = put_json( "%s/plots/%d"  % (API_PFX, test_plot.id), updated_values, self.client, self.public_user_sign)
        self.assertEqual(response.status_code, 200, "Non 200 response when updating plot")

        updated_values = {
            "plot_width": 175,
        }

        response = put_json( "%s/plots/%d"  % (API_PFX, test_plot.id), updated_values, self.client, self.public_user_sign)
        self.assertEqual(response.status_code, 200, "Non 200 response when updating plot")

        test_plot = Plot.objects.get(pk=test_plot.pk)
        pending_edit_count = len(list(test_plot.get_active_pends_with_tree_pends()))
        self.assertEqual(4, pending_edit_count, "Expected three pending edits but got %d" % pending_edit_count)

        pend = test_plot.get_active_pends()[0]
        approved_pend_id = pend.id

        response = post_json("%s/pending-edits/%d/approve/"  % (API_PFX, approved_pend_id), None, self.client, self.sign)
        self.assertEqual(response.status_code, 200, "Non 200 response when approving the pend")
        self.assertEqual(2, len(list(test_plot.get_active_pends_with_tree_pends())), "Expected there to be 2 pending edits after approval")

        for plot_pending in PlotPending.objects.all():
            if plot_pending.id == approved_pend_id:
                self.assertEqual('approved', plot_pending.status, 'The status of the approved pend should be "approved"')
            elif plot_pending.field == 'width':
                self.assertEqual('rejected', plot_pending.status, 'The status of the non-approved width pends should be "rejected"')
            else: # plot_pending.id != approved_pend_id and plot_pending.field != 'width'
                self.assertEqual('pending', plot_pending.status, 'The status of plot pends not on the width field should still be "pending"')

        for tree_pending in TreePending.objects.all():
            self.assertEqual('pending', tree_pending.status, 'The status of tree pends should still be "pending"')

    def test_remove_plot(self):
        plot = mkPlot(self.user)
        plot_id = plot.pk

        tree = mkTree(self.user, plot=plot)
        tree_id = tree.pk

        response = self.client.delete("%s/plots/%d" % (API_PFX, plot_id), **self.sign)
        self.assertEqual(200, response.status_code, "Expected 200 status code after delete")
        response_dict = loads(response.content)
        self.assertTrue('ok' in response_dict, 'Expected a json object response with a "ok" key')
        self.assertTrue(response_dict['ok'], 'Expected a json object response with a "ok" key set to True')

        plot = Plot.objects.get(pk=plot_id)
        tree = Tree.objects.get(pk=tree_id)

        self.assertFalse(plot.present, 'Expected "present" to be False on a deleted plot')
        for audit_trail_record in plot.history.all():
            self.assertFalse(audit_trail_record.present, 'Expected "present" to be False for all audit trail records for a deleted plot')

        self.assertFalse(tree.present, 'Expected "present" to be False on tree associated with a deleted plot')
        for audit_trail_record in tree.history.all():
            self.assertFalse(audit_trail_record.present, 'Expected "present" to be False for all audit trail records for tree associated with a deleted plot')

    def test_remove_tree(self):
        plot = mkPlot(self.user)
        plot_id = plot.pk

        tree = mkTree(self.user, plot=plot)
        tree_id = tree.pk

        response = self.client.delete("%s/plots/%d/tree" % (API_PFX, plot_id), **self.sign)
        self.assertEqual(200, response.status_code, "Expected 200 status code after delete")
        response_dict = loads(response.content)
        self.assertIsNone(response_dict['tree'], 'Expected a json object response to a None value for "tree" key after the tree is deleted')

        plot = Plot.objects.get(pk=plot_id)
        tree = Tree.objects.get(pk=tree_id)

        self.assertTrue(plot.present, 'Expected "present" to be True after tree is deleted from plot')
        for audit_trail_record in plot.history.all():
            self.assertTrue(audit_trail_record.present, 'Expected "present" to be True for all audit trail records for plot with a deleted tree')

        self.assertFalse(tree.present, 'Expected "present" to be False on tree associated with a deleted plot')
        for audit_trail_record in tree.history.all():
            self.assertFalse(audit_trail_record.present, 'Expected "present" to be False for all audit trail records for tree associated with a deleted plot')

    def test_get_current_tree(self):
        plot = mkPlot(self.user)
        plot_id = plot.pk

        tree = mkTree(self.user, plot=plot)

        response = self.client.get("%s/plots/%d/tree" % (API_PFX, plot_id), **self.sign)
        self.assertEqual(200, response.status_code, "Expected 200 status code after delete")
        response_dict = loads(response.content)
        self.assertTrue('species' in response_dict, 'Expected "species" to be a top level key in the response object')
        self.assertEqual(tree.species.pk, response_dict['species'])

    def test_cant_register_with_space_in_username(self):
        self.assertTrue(User.objects.filter(username='foobar').count() == 0, "The test expects the foobar user to not exists.")
        data = {
            'username': 'foo bar',
            'firstname': 'foo',
            'lastname': 'bar',
            'email': 'foo@bar.com',
            'password': 'drowssap',
            'zipcode': 19107
        }
        response = post_json("%s/user/" % API_PFX, data, self.client, self.sign)
        self.assertEqual(400, response.status_code, "Expected 400 status code after creating user")

    def test_registration(self):
        self.assertTrue(User.objects.filter(username='foobar').count() == 0, "The test expects the foobar user to not exists.")
        data = {
            'username': 'foobar',
            'firstname': 'foo',
            'lastname': 'bar',
            'email': 'foo@bar.com',
            'password': 'drowssap',
            'zipcode': 19107
        }
        response = post_json("%s/user/" % API_PFX, data, self.client, self.sign)
        self.assertEqual(200, response.status_code, "Expected 200 status code after creating user")
        response_dict = loads(response.content)
        self.assertTrue('status' in response_dict, 'Expected "status" to be a top level key in the response object')
        self.assertEqual('success', response_dict['status'], 'Expected "status" to be "success"')
        self.assertTrue(User.objects.filter(username='foobar').count() == 1, 'Expected the "foobar" user to be created.')

    def test_duplicate_registration(self):
        self.assertTrue(User.objects.filter(username='jim').count() == 1, "The test expects the jim user to exist.")
        data = {
            'username': 'jim',
            'firstname': 'Jim',
            'lastname': 'User',
            'email': 'jim@user.com',
            'password': 'drowssap',
            'zipcode': 19107
        }
        response = post_json("%s/user/" % API_PFX, data, self.client, self.sign)
        self.assertEqual(409, response.status_code, "Expected 409 status code after attempting to create duplicate username")
        response_dict = loads(response.content)
        self.assertTrue('status' in response_dict, 'Expected "status" to be a top level key in the response object')
        self.assertEqual('failure', response_dict['status'], 'Expected "status" to be "failure"')
        self.assertTrue('detail' in response_dict, 'Expected "detail" to be a top level key in the response object')
        self.assertEqual('Username jim exists', response_dict['detail'])


def _create_mock_request_without_version():
    return _create_mock_request_with_version_string(None)


def _create_mock_request_with_version_string(version_string):
    class MockRequest(object):
        def __init__(self):
            self.META = {}
            if version_string:
                self.META['HTTP_APPLICATIONVERSION'] = version_string
    return MockRequest()


class VersionHeaderParsing(TestCase):
    def test_missing_version_header(self):
        request = _create_mock_request_without_version()
        version_dict = _parse_application_version_header_as_dict(request)
        self.assertEqual({
            'platform': 'UNKNOWN',
            'version': 'UNKNOWN',
            'build': 'UNKNOWN'
        }, version_dict)

    def test_platform_only(self):
        request = _create_mock_request_with_version_string('ios')
        version_dict = _parse_application_version_header_as_dict(request)
        self.assertEqual({
            'platform': 'ios',
            'version': 'UNKNOWN',
            'build': 'UNKNOWN'
        }, version_dict)

    def test_platform_and_version_missing_build(self):
        request = _create_mock_request_with_version_string('ios-1.2')
        version_dict = _parse_application_version_header_as_dict(request)
        self.assertEqual({
            'platform': 'ios',
            'version': '1.2',
            'build': 'UNKNOWN'
        }, version_dict)

    def test_all(self):
        request = _create_mock_request_with_version_string('ios-1.2-b32')
        version_dict = _parse_application_version_header_as_dict(request)
        self.assertEqual({
            'platform': 'ios',
            'version': '1.2',
            'build': 'b32'
        }, version_dict)

    def test_extra_segments_dropped(self):
        request = _create_mock_request_with_version_string('ios-1.2-b32-some-other junk')
        version_dict = _parse_application_version_header_as_dict(request)
        self.assertEqual({
            'platform': 'ios',
            'version': '1.2',
            'build': 'b32'
        }, version_dict)

    def test_non_numeric_version(self):
        request = _create_mock_request_with_version_string('ios-null-bnull')
        version_dict = _parse_application_version_header_as_dict(request)
        self.assertEqual({
            'platform': 'ios',
            'version': 'null',
            'build': 'bnull'
        }, version_dict)


class ChoiceConversion(TestCase):

    def setUp(self):
        setupTreemapEnv()
        self._setup_test_choice_conversions()

        self.user = User.objects.get(username="jim")
        self.user.set_password("password")
        self.user.save()
        self.sign = create_signer_dict(self.user)
        auth = base64.b64encode("jim:password")
        self.sign = dict(self.sign.items() + [("HTTP_AUTHORIZATION", "Basic %s" % auth)])

        self.public_user = User.objects.get(username="amy")
        self.public_user.set_password("password")
        self.public_user.save()
        self.public_user.reputation = Reputation(user=self.public_user)
        self.public_user.reputation.save()

        self.public_user_sign = create_signer_dict(self.public_user)
        public_user_auth = base64.b64encode("amy:password")
        self.public_user_sign = dict(self.public_user_sign.items() + [("HTTP_AUTHORIZATION", "Basic %s" % public_user_auth)])

    def tearDown(self):
        self._restore_choice_conversions()
        teardownTreemapEnv()

    def _setup_test_choice_conversions(self):
        self.original_choices = settings.CHOICES
        if hasattr(settings, 'CHOICE_CONVERSIONS'):
            self.original_choice_conversions = settings.CHOICE_CONVERSIONS
        else:
            self.original_choice_conversions = None

        settings.CHOICES['conditions'] = [
                ("10", "Good"),
                ("11", "Bad")
            ]
        settings.CHOICE_CONVERSIONS = {
            "condition": {
                'version-threshold': {
                    'ios': '1.2.2'
                },
                "forward": [
                    ("1", "10"),
                    ("2", "11"),
                    ("3", "11")
                ],
                "reverse": [
                    ("10", "1"),
                    ("11", "3")
                ]
            }
        }
        # Form field definitions are cached so a change to settings.CHOICES after the
        # form class has been imported will not be reflected automatically
        TreeAddForm.base_fields['condition'].choices = settings.CHOICES['conditions']

    def _restore_choice_conversions(self):
        settings.CHOICES = self.original_choices
        # Form field definitions are cached so a change to settings.CHOICES after the
        # form class has been imported will not be reflected automatically
        TreeAddForm.base_fields['condition'].choices = settings.CHOICES['conditions']

        if self.original_choice_conversions is not None:
            settings.CHOICE_CONVERSIONS = self.original_choice_conversions

    def test_attribute_requires_conversion_when_no_version_is_specified(self):
        request = _create_mock_request_without_version()
        self.assertTrue(_attribute_requires_conversion(request, 'condition'))

    def test_attribute_requires_conversion_when_version_is_under_threshold(self):
        request = _create_mock_request_with_version_string('ios-1.1-b12')
        self.assertTrue(_attribute_requires_conversion(request, 'condition'))

    def test_attribute_requires_conversion_when_version_is_non_numeric(self):
        request = _create_mock_request_with_version_string('ios-null-bnull')
        self.assertTrue(_attribute_requires_conversion(request, 'condition'))

    def test_attribute_requires_conversion_when_version_is_3_segments(self):
        request = _create_mock_request_with_version_string('ios-1.2.1-b12')
        self.assertTrue(_attribute_requires_conversion(request, 'condition'))

    def test_attribute_does_not_require_conversion_when_version_is_3_segments(self):
        request = _create_mock_request_with_version_string('ios-1.3.1-b12')
        self.assertFalse(_attribute_requires_conversion(request, 'condition'))

    def test_attribute_does_not_require_conversion_when_version_is_equal_to_threshold(self):
        request = _create_mock_request_with_version_string('ios-1.2.2-b12')
        self.assertFalse(_attribute_requires_conversion(request, 'condition'))

    def test_set_tree_attribute_with_choice_conversion(self):
        test_plot = mkPlot(self.user)
        test_tree = mkTree(self.user, plot=test_plot)
        test_tree_id = test_tree.id
        test_tree.condition = "10"
        test_tree.save()

        # We expect the 2 to be converted to an 11
        updated_values = {'tree': {'condition': '2'}}
        response = put_json("%s/plots/%d" %
            (API_PFX, test_plot.id), updated_values, self.client, self.sign)
        self.assertEqual(200, response.status_code)
        tree = Tree.objects.get(pk=test_tree_id)
        self.assertIsNotNone(tree)
        self.assertEqual("11", tree.condition)

    def test_get_tree_with_choice_conversion(self):
        plot = mkPlot(self.user)
        plot_id = plot.pk

        tree = mkTree(self.user, plot=plot)
        tree.condition = "10"
        tree.save()

        response = self.client.get("%s/plots/%d" % (API_PFX, plot_id), **self.sign)
        self.assertEqual(200, response.status_code, "Expected 200 status code after delete")
        response_dict = loads(response.content)
        self.assertTrue('tree' in response_dict, 'Expected "tree" to be a top level key in the response object')
        tree_dict = response_dict['tree']
        self.assertTrue('condition' in tree_dict, 'Expected "condition" to be a key in the tree object')
        self.assertEqual(tree_dict['condition'], '1')

    def test_create_plot_with_tree(self):
        data = {
            "lon": 35,  # Location properties are required
            "lat": 25,  # Location properties are required
            "geocode_address": "1234 ANY ST",  # Location properties are required
            "edit_address_street": "1234 ANY ST",  # Location properties are required
            'tree': {
                'condition': 1
            }
        }

        response = post_json('%s/plots' % API_PFX, data, self.client, self.sign)

        self.assertEqual(201, response.status_code, 'Create failed:' + response.content)

        response_json = loads(response.content)
        self.assertTrue('tree' in response_json)
        self.assertTrue('condition' in response_json['tree'])
        # Check that the server responds with the 'old' choice value
        self.assertEqual('1', response_json['tree']['condition'])

        self.assertTrue('id' in response_json)
        id = response_json['id']
        plot = Plot.objects.get(pk=id)
        tree = plot.current_tree()
        self.assertIsNotNone(tree)
        # Check that the 'new' choice value was set in the database
        self.assertEqual('10', tree.condition)

    def test_update_tree_with_pending(self):
        settings.PENDING_ON = True
        try:
            test_plot = mkPlot(self.user)
            test_tree = mkTree(self.user, plot=test_plot)
            test_tree_id = test_tree.id
            test_tree.condition = 11
            test_tree.save()

            updated_values = {'tree': {'condition': 1}}
            response = put_json("%s/plots/%d" % (API_PFX, test_plot.id), updated_values, self.client, self.public_user_sign)
            self.assertEqual(200, response.status_code)
            tree = Tree.objects.get(pk=test_tree_id)
            self.assertIsNotNone(tree)
            self.assertEqual('11', tree.condition, "A pend should have been created instead of editing the tree value.")

            self.assertEqual(1, len(TreePending.objects.all()))
            pend = TreePending.objects.all()[0]
            self.assertEqual('10', pend.value, "Expected the updated value of 1 to be converted to a 10")

            response_json = loads(response.content)
            self.assertEqual(1, len(response_json['pending_edits'].keys()), "Expected the json response to have a pending_edits dict with 1 keys")
            self.assertEqual('tree.condition', response_json['pending_edits'].keys()[0], "Expected 'tree.condition' to have a pending edit")
            pending_edit = response_json['pending_edits']['tree.condition']
            self.assertEqual('1', pending_edit['latest_value'], "Expected the latest_value to be 1 in the JSON response")
            pending_edit_item = pending_edit['pending_edits'][0]
            self.assertEqual('1', pending_edit_item['value'], "Expected the pending edit value to be 1 in the JSON response")

        finally:
            settings.PENDING_ON = False

    def test_approve_pending_edit(self):
        self.assert_pending_edit_operation('approve')

    def test_reject_pending_edit(self):
        self.assert_pending_edit_operation('reject')

    def assert_pending_edit_operation(self, action):
        settings.PENDING_ON = True

        old_original_conditions = ['2', '3']
        old_edited_condition = '1'

        new_original_condition = '11'
        new_edited_condition = '10'

        test_plot = mkPlot(self.user)
        test_tree = mkTree(self.user, plot=test_plot)
        test_tree_id = test_tree.id
        test_tree.condition = new_original_condition
        test_tree.save()

        if action == 'approve':
            status_after_action = 'approved'
        elif action == 'reject':
            status_after_action = 'rejected'
        else:
            raise Exception('Action must be "approve" or "reject"')

        self.assertEqual(0, len(Pending.objects.all()), "Expected the test to start with no pending records")

        updated_values = {'tree': {'condition': old_edited_condition}}
        response = put_json("%s/plots/%d" % (API_PFX, test_plot.id), updated_values, self.client, self.public_user_sign)
        self.assertEqual(200, response.status_code)
        tree = Tree.objects.get(pk=test_tree_id)
        self.assertIsNotNone(tree)
        self.assertEqual(new_original_condition, tree.condition, "A pend should have been created instead of editing the tree value.")
        self.assertEqual(1, len(TreePending.objects.all()), "Expected 1 pend record for the edited field.")

        pending_edit = TreePending.objects.all()[0]
        self.assertEqual('pending', pending_edit.status, "Expected the status of the Pending to be 'pending'")

        response = post_json("%s/pending-edits/%d/%s/" % (API_PFX, pending_edit.id, action), None, self.client, self.sign)
        self.assertEqual(200, response.status_code)

        pending_edit = TreePending.objects.get(pk=pending_edit.id)
        self.assertEqual(status_after_action, pending_edit.status, "Expected the status of the Pending to be '%s'" % status_after_action)
        test_tree = Tree.objects.get(pk=test_tree_id)

        if action == 'approve':
            self.assertEqual(new_edited_condition, test_tree.condition, "Expected condition to have been updated on the Tree")
        elif action == 'reject':
            self.assertEqual(new_original_condition, test_tree.condition, "Expected condition to NOT have been updated on the Tree")

        response_json = loads(response.content)
        self.assertTrue('tree' in response_json)
        self.assertTrue('condition' in response_json['tree'])
        if action == 'approve':
            self.assertEqual(old_edited_condition, response_json['tree']['condition'], "Expected condition to have been updated in the JSON response")
        elif action == 'reject':
            # Because both 2 and 3 convert to the same value the values that gets restored on
            # rejection is not deterministic
            self.assertTrue(response_json['tree']['condition'] in old_original_conditions, "Expected condition to NOT have been updated in the JSON response")


class Resource(TestCase):
    def setUp(self):
        setupTreemapEnv()

    def tearDown(self):
        teardownTreemapEnv()

    def test_tree_resource_to_dict_on_empty_resource(self):
        # If resources are all calculated as zero, this method should still return a valid object

        tr = TreeResource()
        tr.annual_stormwater_management = 0
        tr.annual_electricity_conserved = 0
        tr.annual_energy_conserved = 0
        tr.annual_natural_gas_conserved = 0
        tr.annual_air_quality_improvement = 0
        tr.annual_co2_sequestered = 0
        tr.annual_co2_avoided = 0
        tr.annual_co2_reduced = 0
        tr.total_co2_stored = 0
        tr.annual_ozone = 0
        tr.annual_nox = 0
        tr.annual_pm10 = 0
        tr.annual_sox = 0
        tr.annual_voc = 0
        tr.annual_bvoc = 0

        resource_dict = tree_resource_to_dict(tr)
        self.assertIsNotNone(resource_dict)

class TreePhoto(TestCase):

    def setUp(self):
        setupTreemapEnv()
        self.user = User.objects.get(username="jim")
        self.user.set_password("password")
        self.user.save()
        self.sign = create_signer_dict(self.user)
        auth = base64.b64encode("jim:password")
        self.sign = dict(self.sign.items() + [("HTTP_AUTHORIZATION", "Basic %s" % auth)])

        self.test_jpeg_path = os.path.join(os.path.dirname(__file__), 'test_resources', '2by2.jpeg')
        self.test_png_path = os.path.join(os.path.dirname(__file__), 'test_resources', '2by2.png')

        def assertSuccessfulResponse(response):
            self.assertIsNotNone(response)
            self.assertIsNotNone(response.content)
            response_dict = loads(response.content)
            self.assertTrue('status' in response_dict)
            self.assertEqual('success', response_dict['status'])
        self.assertSuccessfulResponse = assertSuccessfulResponse

    def tearDown(self):
        teardownTreemapEnv()

    def test_jpeg_tree_photo_file_name(self):
        plot = mkPlot(self.user)
        plot_id = plot.pk
        response = post_jpeg_file( "%s/plots/%d/tree/photo"  % (API_PFX, plot_id), self.test_jpeg_path,
            self.client, self.sign)

        self.assertSuccessfulResponse(response)

        plot = Plot.objects.get(pk=plot_id)
        tree = plot.current_tree()
        self.assertIsNotNone(tree)
        photo = tree.treephoto_set.all()[0]
        self.assertEqual('plot_%d.jpeg' % plot_id, photo.title)

    def test_png_tree_photo_file_name(self):
        plot = mkPlot(self.user)
        plot_id = plot.pk
        response = post_png_file( "%s/plots/%d/tree/photo"  % (API_PFX, plot_id), self.test_png_path,
            self.client, self.sign)

        self.assertSuccessfulResponse(response)

        plot = Plot.objects.get(pk=plot_id)
        tree = plot.current_tree()
        self.assertIsNotNone(tree)
        photo = tree.treephoto_set.all()[0]
        self.assertEqual('plot_%d.png' % plot_id, photo.title)

class CQLFiltering(TestCase):
    """Class for testing the APIs feature to generate CQL strings.

    The testing strategy used here is to:
    1) Test that an API call with no parameters will return an empty CQL string
    2) Test two different boolean parameters
    3) Test that two boolean parameters can be correctly combined
    4) Test a non boolean (string matching) parameter
    """
    def setUp(self):
        setupTreemapEnv()
        self.user = User.objects.get(username="jim")
        self.user.set_password("password")
        self.user.save()
        self.sign = create_signer_dict(self.user)

    def tearDown(self):
        teardownTreemapEnv()

    def assertParamsProduceResponse(self, params, expected_cql):
        expected_json = """{"cql_string": "%s"}""" % expected_cql
        response = self.client.get("%s/cql-filter" % API_PFX, params, **self.sign)
        self.assertEqual(expected_json, response.content)

    def test_without_params(self):
        params = {}
        expected_cql = ""
        self.assertParamsProduceResponse(params, expected_cql)

    def test_boolean_missing_species(self):
        params = {'missing_species' : 'True',}
        expected_cql = "species_id IS NULL"
        self.assertParamsProduceResponse(params, expected_cql)

    def test_boolean_missing_height(self):
        params = {'missing_height' : 'True'}
        expected_cql = "(height IS NULL OR height = 0)"
        self.assertParamsProduceResponse(params, expected_cql)

    def test_boolean_missing_species_and_height(self):
        params = {'missing_species' : 'True', 'missing_height' : 'True'}
        expected_cql =  "species_id IS NULL AND (height IS NULL OR height = 0)"
        self.assertParamsProduceResponse(params, expected_cql)

    def test_matching_tree_owner(self):
        params = {'tree_owner' : 'John Doe'}
        expected_cql =  "tree_owner LIKE '%John Doe%'"
        self.assertParamsProduceResponse(params, expected_cql)

########NEW FILE########
__FILENAME__ = test_utils
from django.conf import settings

settings.POSTAL_CODE_FIELD = None # Use US Zip Code

from django.contrib.auth.models import User
from django.contrib.gis.geos.collections import MultiPolygon
from django.contrib.gis.geos.point import Point
from django.contrib.gis.geos.polygon import Polygon
from django_reputation.models import ReputationAction, Reputation
from api.models import APILog, APIKey
from profiles.models import UserProfile
from treemap.models import Species, BenefitValues, Resource, Neighborhood, ZipCode, ExclusionMask, AggregateNeighborhood, ImportEvent, Tree, Plot

import django.shortcuts

def mkPlot(u, geom=Point(50,50)):
    p = Plot(geometry=geom, last_updated_by=u, import_event=ImportEvent.objects.all()[0],present=True, data_owner=u)
    p.save()

    return p

def mkTree(u, plot=None, species=-1):
    if not plot:
        plot = mkPlot(u)

    if species == -1:
        s = Species.objects.all()[0]
    else:
        s = species

    t = Tree(plot=plot, species=s, last_updated_by=u, import_event=ImportEvent.objects.all()[0])
    t.present = True
    t.save()

    return t

def setupTreemapEnv():
    settings.GEOSERVER_GEO_LAYER = ""
    settings.GEOSERVER_GEO_STYLE = ""
    settings.GEOSERVER_URL = ""

    def local_render_to_response(*args, **kwargs):
        from django.template import loader, RequestContext
        from django.http import HttpResponse

        httpresponse_kwargs = {'mimetype': kwargs.pop('mimetype', None)}
        hr = HttpResponse(
            loader.render_to_string(*args, **kwargs), **httpresponse_kwargs)

        if hasattr(args[1], 'dicts'):
            hr.request_context = args[1].dicts

        return hr

    django.shortcuts.render_to_response = local_render_to_response

    r1 = ReputationAction(name="edit verified", description="blah")
    r2 = ReputationAction(name="edit tree", description="blah")
    r3 = ReputationAction(name="Administrative Action", description="blah")
    r4 = ReputationAction(name="add tree", description="blah")
    r5 = ReputationAction(name="edit plot", description="blah")
    r6 = ReputationAction(name="add plot", description="blah")
    r7 = ReputationAction(name="add stewardship", description="blah")
    r8 = ReputationAction(name="remove stewardship", description="blah")

    for r in [r1,r2,r3,r4,r5,r6,r7,r8]:
        r.save()

    bv = BenefitValues(co2=0.02, pm10=9.41, area="InlandValleys",
                       electricity=0.1166,voc=4.69,ozone=5.0032,natural_gas=1.25278,
                       nox=12.79,stormwater=0.0078,sox=3.72,bvoc=4.96)

    bv.save()

    dbh = "[1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]"
    dbh2 = "[2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]"

    rsrc1 = Resource(meta_species="BDM OTHER", region="NoEastXXX")
    rsrc2 = Resource(meta_species="BDL OTHER", region="NoEastXXX")

    rsrc1.save()
    rsrc2.save()

    u = User.objects.filter(username="jim")

    if u:
        u = u[0]
    else:
        u = User.objects.create_user("jim","jim@test.org","jim")
        u.is_staff = True
        u.is_superuser = True
        u.save()
        up = UserProfile(user=u)
        up.save()
        u.reputation = Reputation(user=u)
        u.reputation.save()

    amy_filter_result = User.objects.filter(username="amy")
    if not amy_filter_result:
        amy = User.objects.create_user("amy","amy@test.org","amy")
    else:
        amy = amy_filter_result[0]
        amy.is_staff = False
        amy.is_superuser = False
        amy.save()
        amy_profile = UserProfile(user=amy)
        amy_profile.save()
        amy.reputation = Reputation(user=amy)
        amy.reputation.save()

    olivia_filter_result = User.objects.filter(username="olivia")
    if not amy_filter_result:
        olivia = User.objects.create_user("olivia","olivia@test.org","olivia")
    else:
        olivia = olivia_filter_result[0]
        olivia.is_staff = False
        olivia.is_superuser = False
        olivia.save()
        olivia_profile = UserProfile(user=olivia)
        olivia_profile.save()
        olivia.reputation = Reputation(user=olivia)
        olivia.reputation.save()

    n1geom = MultiPolygon(Polygon(((0,0),(100,0),(100,100),(0,100),(0,0))))
    n2geom = MultiPolygon(Polygon(((0,101),(101,101),(101,200),(0,200),(0,101))))

    n1 = Neighborhood(name="n1", region_id=2, city="c1", state="PA", county="PAC", geometry=n1geom)
    n2 = Neighborhood(name="n2", region_id=2, city="c2", state="NY", county="NYC", geometry=n2geom)

    n1.save()
    n2.save()

    z1geom = MultiPolygon(Polygon(((0,0),(100,0),(100,100),(0,100),(0,0))))
    z2geom = MultiPolygon(Polygon(((0,100),(100,100),(100,200),(0,200),(0,100))))

    z1 = ZipCode(zip="19107",geometry=z1geom)
    z2 = ZipCode(zip="10001",geometry=z2geom)

    z1.save()
    z2.save()

    exgeom1 = MultiPolygon(Polygon(((0,0),(25,0),(25,25),(0,25),(0,0))))
    ex1 = ExclusionMask(geometry=exgeom1, type="building")

    ex1.save()

    agn1 = AggregateNeighborhood(
        annual_stormwater_management=0.0,
        annual_electricity_conserved=0.0,
        annual_energy_conserved=0.0,
        annual_natural_gas_conserved=0.0,
        annual_air_quality_improvement=0.0,
        annual_co2_sequestered=0.0,
        annual_co2_avoided=0.0,
        annual_co2_reduced=0.0,
        total_co2_stored=0.0,
        annual_ozone=0.0,
        annual_nox=0.0,
        annual_pm10=0.0,
        annual_sox=0.0,
        annual_voc=0.0,
        annual_bvoc=0.0,
        total_trees=0,
        total_plots=0,
        location = n1)

    agn2 = AggregateNeighborhood(
        annual_stormwater_management=0.0,
        annual_electricity_conserved=0.0,
        annual_energy_conserved=0.0,
        annual_natural_gas_conserved=0.0,
        annual_air_quality_improvement=0.0,
        annual_co2_sequestered=0.0,
        annual_co2_avoided=0.0,
        annual_co2_reduced=0.0,
        total_co2_stored=0.0,
        annual_ozone=0.0,
        annual_nox=0.0,
        annual_pm10=0.0,
        annual_sox=0.0,
        annual_voc=0.0,
        annual_bvoc=0.0,
        total_trees=0,
        total_plots=0,
        location = n2)

    agn1.save()
    agn2.save()

    s1 = Species(symbol="s1",genus="testus1",species="specieius1",
                 cultivar_name='',family='',
                 alternate_symbol='a1')
    s2 = Species(symbol="s2",genus="testus2",species="specieius2",
                 cultivar_name='',family='',
                 alternate_symbol='a2')
    s3 = Species(symbol="s3",genus="testus2",species="specieius3",
                 cultivar_name='',family='',
                 alternate_symbol='a3')

    s1.native_status = 'True'
    s1.fall_conspicuous = True
    s1.flower_conspicuous = True
    s1.palatable_human = True

    s2.native_status = 'True'
    s2.fall_conspicuous = False
    s2.flower_conspicuous = True
    s2.palatable_human = False
    s2.wildlife_value = True

    s3.wildlife_value = True

    s1.save()
    s2.save()
    s3.save()

    s1.resource.add(rsrc1)
    s2.resource.add(rsrc2)
    s3.resource.add(rsrc2)

    ie = ImportEvent(file_name='site_add')
    ie.save()

def teardownTreemapEnv():
    for r in APILog.objects.all():
        r.delete()

    for r in APIKey.objects.all():
        r.delete()

    for r in BenefitValues.objects.all():
        r.delete()

    for u in User.objects.all():
        u.delete()

    for r in Neighborhood.objects.all():
        r.delete()

    for r in ZipCode.objects.all():
        r.delete()

    for r in ExclusionMask.objects.all():
        r.delete()

    for r in AggregateNeighborhood.objects.all():
        r.delete()

    for r in Species.objects.all():
        r.delete()

    for r in ImportEvent.objects.all():
        r.delete()

    for r in Tree.objects.all():
        r.delete()

    for r in Plot.objects.all():
        r.delete()

    for r in ReputationAction.objects.all():
        r.delete()

    for r in Resource.objects.all():
        r.delete()

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *
from views import *

urlpatterns = patterns(
    '',
    (r'^$', status),
    (r'^version$', version),
    (r'^plots$', route(GET=get_plot_list, POST=create_plot_optional_tree)),
    (r'^plots/(?P<plot_id>\d+)$', route(GET=get_plot, PUT=update_plot_and_tree, DELETE=remove_plot)),
    (r'^plots/(?P<plot_id>\d+)/tree$', route(GET=get_current_tree_from_plot, DELETE=remove_current_tree_from_plot)),
    (r'^plots/(?P<plot_id>\d+)/tree/photo$', route(POST=add_tree_photo)),
    (r'^plots/(?P<plot_id>\d+)/tree/photo/(?P<photo_id>\d+)', get_tree_image),
    (r'^locations/(?P<lat>-{0,1}\d+(\.\d+){0,1}),(?P<lon>-{0,1}\d+(\.\d+){0,1})/plots', plots_closest_to_point),

    (r'^pending-edits/(?P<pending_edit_id>\d+)/approve', route(POST=approve_pending_edit)),
    (r'^pending-edits/(?P<pending_edit_id>\d+)/reject', route(POST=reject_pending_edit)),

    (r'^species', species_list),
    (r'^addresses/(?P<address>.+)', geocode_address),

    (r'^login/reset_password$', reset_password),
    (r'^login$', verify_auth),

    (r'^user/$', route(POST=register)),
    (r'^user/(?P<user_id>\d+)/photo/(?P<title>.+)$', add_profile_photo),  
    (r'^user/(?P<user_id>\d+)/password$', update_password),  
    (r'^user/(?P<user_id>\d+)/edits$', recent_edits),  

    (r'^tiles',  get_trees_in_tile),

    (r'^cql-filter$', get_cql_query),
)

########NEW FILE########
__FILENAME__ = views
import datetime
from PIL import Image
from django.core.exceptions import ValidationError, PermissionDenied
from django.core.files.base import ContentFile

from django.conf import settings
from django.views.decorators.http import require_http_methods
from django.views.decorators.csrf import csrf_exempt
from django.http import HttpResponse, HttpResponseBadRequest, HttpResponseServerError
from django.shortcuts import get_object_or_404
from django.db import transaction

from django.contrib.auth.forms import PasswordResetForm
from django.contrib.auth.models import User
from django.contrib.auth.tokens import default_token_generator
from django_reputation.models import Reputation, UserReputationAction
from profiles.utils import change_reputation_for_user

from treemap.models import Plot, Species, TreePhoto, ImportEvent, Tree
from treemap.models import BenefitValues
from treemap.models import TreeResource, PlotPending, TreePending
from treemap.forms import TreeAddForm
from treemap.views import get_tree_pend_or_plot_pend_by_id_or_404_not_found,\
    has_pending_permission_or_403_forbidden,\
    requires_pending_record, _build_tree_search_result
from api.models import APIKey, APILog
from django.contrib.gis.geos import Point, fromstr

from profiles.models import UserProfile

from api.auth import login_required, create_401unauthorized, login_optional

from functools import wraps

from omgeo import Geocoder
from omgeo.places import PlaceQuery, Viewbox

import json
import struct
import ctypes
import math

import simplejson

from copy import deepcopy

from distutils.version import StrictVersion

class HttpBadRequestException(Exception):
    pass

class HttpConflictException(Exception):
    pass

class InvalidAPIKeyException(Exception):
    pass

def route(**kwargs):
    @csrf_exempt
    def routed(request, **kwargs2):
        method = request.method
        req_method = kwargs[method]
        return req_method(request, **kwargs2)
    return routed

def json_from_request(request):
    """
    Accessing raw_post_data throws an exception when using the Django test
    client in to make requests in unit tests.
    """
    try:
        data = json.loads(request.raw_post_data)
    except Exception, e:
        data = request.POST
    return data

def validate_and_log_api_req(request):
    # Prefer "apikey" in REQUEST, but take either that or the
    # header value
    key = request.META.get("HTTP_X_API_KEY", None)
    key = request.REQUEST.get("apikey", key)

    if key is None:
        raise InvalidAPIKeyException("key not found as 'apikey' param or 'X-API-Key' header")

    apikeys = APIKey.objects.filter(key=key)

    if len(apikeys) > 0:
        apikey = apikeys[0]
    else:
        raise InvalidAPIKeyException("key not found")

    if not apikey.enabled:
        raise InvalidAPIKeyException("key is not enabled")

    # Log the request
    reqstr = ",".join(["%s=%s" % (k,request.REQUEST[k]) for k in request.REQUEST])
    APILog(url=request.get_full_path(),
           remoteip=request.META["REMOTE_ADDR"],
           requestvars=reqstr,
           method=request.method,
           apikey=apikey,
           useragent=request.META.get("HTTP_USER_AGENT",''),
           appver=request.META.get("HTTP_APPLICATIONVERSION",'')
    ).save()

    return apikey


def api_call_raw(content_type="image/jpeg"):
    """ Wrap an API call that writes raw binary data """
    def decorate(req_function):
        @wraps(req_function)
        def newreq(request, *args, **kwargs):
            try:
                validate_and_log_api_req(request)
                outp = req_function(request, *args, **kwargs)
                if issubclass(outp.__class__, HttpResponse):
                    response = outp
                else:
                    response = HttpResponse(outp)

                response['Content-length'] = str(len(response.content))
                response['Content-Type'] = content_type
            except HttpBadRequestException, bad_request:
                response = HttpResponseBadRequest(bad_request.message)

            return response
        return newreq
    return decorate

def api_call(content_type="application/json"):
    """ Wrap an API call that returns an object that
        is convertable from json
    """
    def decorate(req_function):
        @wraps(req_function)
        @csrf_exempt
        def newreq(request, *args, **kwargs):
            try:
                validate_and_log_api_req(request)
                outp = req_function(request, *args, **kwargs)
                if issubclass(outp.__class__, HttpResponse):
                    response = outp
                else:
                    response = HttpResponse()
                    response.write('%s' % simplejson.dumps(outp))
                    response['Content-length'] = str(len(response.content))
                    response['Content-Type'] = content_type

            except HttpBadRequestException, bad_request:
                response = HttpResponseBadRequest(bad_request.message)

            except HttpConflictException, conflict:
                response = HttpResponse(conflict.message)
                response.status_code = 409

            return response

        return newreq
    return decorate

def datetime_to_iso_string(d):
    if d:
        return d.strftime('%Y-%m-%d %H:%M:%S')
    else:
        return None

def plot_permissions(plot, user):
    perms = { "plot": plot_or_tree_permissions(plot, user) }

    tree = plot.current_tree()
    if tree:
        perms["tree"] = plot_or_tree_permissions(tree, user)

    return perms

def plot_or_tree_permissions(obj, user):
    """ Determine what the given user can do with a tree or plot
        Returns {
           can_delete: <boolean>,
           can_edit: <boolean>,
        } """

    can_delete = False
    can_edit = False

    # If user is none or anonymous, they can't do anything
    if not user or user.is_anonymous():
        can_delete = False
        can_edit = False
    # If an object is readonly, it can never be deleted or edited
    elif obj.readonly:
        can_delete = False
        can_edit = False
    # If the user is an admin they can do whatever they want
    # (but not to readonly trees)
    elif user.has_perm('auth.change_user'):
        can_delete = True
        can_edit = True
    else:
        # If the user is the owner of the object
        # they can do whatever
        creator = obj.created_by
        if creator and creator.pk == user.pk:
            can_delete = True
            can_edit = True
        # If the tree is not readonly, and the user isn't an admin
        # and the user doesn't own the objet, editing is allowed
        # but delete is not
        else:
            can_delete = False
            can_edit = True

    return { "can_delete": can_delete, "can_edit": can_edit }

def can_delete_tree_or_plot(obj, user):
    permissions = plot_or_tree_permissions(obj, user)
    if "can_delete" in permissions:
        return permissions["can_delete"]
    else:
        # This should never happen, but raising an exception ensures that it will fail loudly if a
        # future refactoring introduces a bug.
        raise Exception("Expected the dict returned from plot_or_tree_permissions to contain 'can_delete'")


@require_http_methods(["GET"])
@api_call()
def status(request):
    return [{ 'api_version': 'v0.1',
              'status': 'online',
              'message': '' }]

@require_http_methods(["GET"])
@api_call()
@login_required
def verify_auth(request):
    user_dict = user_to_dict(request.user)
    user_dict["status"] = "success"
    return user_dict

@require_http_methods(["POST"])
@api_call()
@transaction.commit_on_success
def register(request):
    data = json.loads(request.raw_post_data)

    # If a user already exists with the specified username, return a 409 Conflict
    if User.objects.filter(username=data["username"]).count():
        raise HttpConflictException(simplejson.dumps(
            { "status": "failure", "id": -1, "detail": "Username %s exists" % data["username"]}
        ))

    if ' ' in data['username']:
        response = HttpResponse()
        response.status_code = 400
        response.content = simplejson.dumps({"error": "Invalid username"})
        return response

    user = User(username=data["username"],
                first_name=data["firstname"],
                last_name=data["lastname"],
                email=data["email"])

    user.set_password(data["password"])
    user.save()

    user.reputation = Reputation(user=user)
    user.reputation.save()

    profile = UserProfile(user=user,zip_code=data["zipcode"],active=True)
    profile.save()

    return { "status": "success", "id": user.pk }

@require_http_methods(["POST"])
@api_call()
@login_required
def add_tree_photo(request, plot_id):
    content_type = request.META.get('CONTENT_TYPE')
    if not content_type:
        content_type = "image/png" # Older versions of the iOS client sent PNGs exclusively
    file_type = content_type.lower().split('/')[-1]
    uploaded_image = ContentFile(request.raw_post_data)
    uploaded_image.name = "plot_%s.%s" % (plot_id, file_type)

    plot = Plot.objects.get(pk=plot_id)
    tree = plot.current_tree()

    if tree is None:
        import_event, created = ImportEvent.objects.get_or_create(file_name='site_add',)
        tree = Tree(plot=plot, last_updated_by=request.user, import_event=import_event)
        tree.plot = plot
        tree.last_updated_by = request.user
        tree.save()

    treephoto = TreePhoto(tree=tree,title=uploaded_image.name,reported_by=request.user)
    treephoto.photo.save("plot_%s.%s" % (plot_id, file_type), uploaded_image)

    treephoto.save()

    return { "status": "success", "title": treephoto.title, "id": treephoto.pk }


@require_http_methods(["POST"])
@api_call()
@login_required
def add_profile_photo(request, user_id, title):
    uploaded_image = ContentFile(request.raw_post_data)
    uploaded_image.name = "%s.png" % title

    profile = UserProfile.objects.get(user__id=user_id)
    profile.photo.save("%s.png" % title, uploaded_image)

    profile.save()

    return { "status": "success" }

def extract_plot_id_from_rep(repact):
    content_type = repact.content_type
    if content_type.model == "plot":
        return repact.object_id
    elif content_type.model == 'tree':
        return Tree.objects.get(pk=repact.object_id).plot.pk
    else:
        return None

@require_http_methods(["GET"])
@api_call()
@login_required
def recent_edits(request, user_id):
    if (int(user_id) != request.user.pk):
        return create_401unauthorized()

    result_offset = int(request.REQUEST.get("offset",0))
    num_results = min(int(request.REQUEST.get("length",15)),15)

    acts = UserReputationAction.objects.filter(user=request.user).order_by('-date_created')[result_offset:(result_offset+num_results)]

    keys = []
    for act in acts:
        d = {}
        plot_id = extract_plot_id_from_rep(act)
        d["plot_id"] = plot_id

        if plot_id:
            d["plot"] = convert_response_plot_dict_choice_values(request,
                plot_to_dict(Plot.objects.get(pk=plot_id),longform=True,user=request.user)
            )

        d["id"] = act.pk
        d["name"] = act.action.name
        d["created"] = datetime_to_iso_string(act.date_created)
        d["value"] = act.value

        keys.append(d)

    return keys


@require_http_methods(["PUT"])
@api_call()
@login_required
def update_password(request, user_id):
    data = json.loads(request.raw_post_data)

    pw = data["password"]

    user = User.objects.get(pk=user_id)

    user.set_password(pw)
    user.save()

    return { "status": "success" }

@require_http_methods(["GET"])
@api_call_raw("otm/trees")
def get_trees_in_tile(request):
    """ API Request

    Get pixel coordinates for trees in a 256x256 tile

    Verb: GET
    Params:
       bbox - xmin,ymin,xmax,ymax projected into web mercator
       filter_diameter_min - minimum diameter (note, setting this filters trees with no diameter set)
       filter_diameter_max - maximum diameter (note, setting this filters trees with no diameter set)

    Output:
       Raw Binary format as follows:

       0xA3A5EA         - 3 byte magic number
       0x00             - 1 byte pad
       Number of points - 4 byte uint
       Section Header   - 4 bytes
       Point pair - 2 bytes
       Point pair
       ...
       Point pair
       Section Header
       ...

       Section Header:
       Position  Field          Value  Type
       Byte N    Style Type     0-255  Enum
       Byte N+1  Number of pts         Unsigned Short
       Byte N+3  -----          0      Padding

       Point Pair:
       Position Field     Type
       Byte N   X offset  Byte (Unsigned)
       Byte N+1 Y offset  Byte (Unsigned)

    """

    # This method should execute as fast as possible to avoid the django/ORM overhead we are going
    # to execute raw SQL queries
    from django.db import connection, transaction

    cursor = connection.cursor()

    # Construct the bbox
    bbox = request.GET['bbox']
    (xmin,ymin,xmax,ymax) = map(float,bbox.split(","))
    bboxFilterStr = "ST_GeomFromText('POLYGON(({xmin} {ymin},{xmin} {ymax},{xmax} {ymax},{xmax} {ymin},{xmin} {ymin}))', 4326)"
    bboxFilter = bboxFilterStr.format(xmin=xmin,ymin=ymin,xmax=xmax,ymax=ymax)

    (xminM,yminM) = latlng2webm(xmin,ymin)
    (xmaxM,ymaxM) = latlng2webm(xmax,ymax)
    pixelsPerMeterX = 255.0/(xmaxM - xminM)
    pixelsPerMeterY = 255.0/(ymaxM - yminM)

    # Use postgis to do the SRS math, save ourselves some time
    tidcase = "CASE WHEN treemap_tree.id IS null THEN 0 ELSE 1 END"
    dbhcase = "CASE WHEN treemap_tree.dbh IS null THEN 0 ELSE 2 END"
    spccase = "CASE WHEN treemap_tree.species_id IS null THEN 0 ELSE 4 END"

    selectg = "%s + %s + %s as gid" % (tidcase,dbhcase,spccase)
    selectx = "ROUND((ST_X(t.geometry) - {xoffset})*{xfactor}) as x".format(xoffset=xminM,xfactor=pixelsPerMeterX)
    selecty = "ROUND((ST_Y(t.geometry) - {yoffset})*{yfactor}) as y".format(yoffset=yminM,yfactor=pixelsPerMeterY)
    query = "SELECT {xfield}, {yfield}, {gfield}".format(xfield=selectx,yfield=selecty,gfield=selectg)

    force_species_join = False

    filters = []
    filter_values = {}
    if "filter_dbh_min" in request.GET:
        filters.append("treemap_tree.dbh >= %(filter_diameter_min)s")
        filter_values["filter_diameter_min"] = float(request.GET['filter_dbh_min'])

    if "filter_dbh_max" in request.GET:
        filters.append("treemap_tree.dbh <= %(filter_diameter_max)s")
        filter_values["filter_diameter_max"] = float(request.GET['filter_dbh_max'])

    if "filter_edible" in request.GET:
        filters.append("treemap_species.palatable_human = %(edible)s")
        filter_values["edible"] = request.GET['filter_edible'] == "true"
        force_species_join = True

    if "filter_flowering" in request.GET:
        filters.append("treemap_species.flower_conspicuous = %(flower_conspicuous)s")
        filter_values["flower_conspicuous"] = request.GET['filter_flowering']
        force_species_join = True

    if "filter_pests" in request.GET:
        filters.append("treemap_tree.pests = %(filter_pests)s")
        filter_values["filter_pests"] = request.GET['filter_pests']

    if "filter_native" in request.GET:
        filters.append("treemap_species.native_status = %(native_status)s")
        if request.GET['filter_native'].lower() == "true":
            b = "True"
        else:
            b = "False"

        filter_values["native_status"] = b
        force_species_join = True

    if "filter_fall_colors" in request.GET:
        filters.append("treemap_species.fall_conspicuous = %(fall_conspicuous)s")
        filter_values["fall_conspicuous"] = request.GET['filter_fall_colors']
        force_species_join = True

    if "filter_species" in request.GET:
        filters.append("treemap_tree.species_id = %(species_id)s")
        filter_values["species_id"] = int(request.GET['filter_species'])

    where = "where ST_Contains({bfilter},geometry) AND treemap_plot.present".format(bfilter=bboxFilter)
    subselect = "select ST_Transform(geometry, 900913) as geometry, id from treemap_plot {where}".format(where=where)
    fromq = "FROM ({subselect}) as t LEFT OUTER JOIN treemap_tree ON treemap_tree.plot_id=t.id".format(subselect=subselect)

    if force_species_join:
        fromq += " LEFT OUTER JOIN treemap_species ON treemap_species.id=treemap_tree.species_id"

    order = "order by x,y"

    where = ""
    if len(filters) > 0:
        where = "WHERE %s" % (" AND ".join(filters))

    selectQuery = "{0} {1} {2} {3}".format(query, fromq, where, order)

    cursor.execute(selectQuery, filter_values)
    transaction.commit_unless_managed()

    # We have the sorted list, now we want to remove duplicates
    results = []
    rows = cursor.fetchall()
    n = len(rows)

    if n > 0:
        last = rows[0]
        lasti = i = 1
        while i < n:
            if rows[i] != last:
                rows[lasti] = last = rows[i]
                lasti += 1
            i += 1

        rows = rows[:lasti]

    # Partition into groups
    groups = {}
    for (x,y,g) in rows:
        if g not in groups:
            groups[g] = []

        groups[g].append((x,y))

    # After removing duplicates, we can have at most 1 tree per square
    # (since we are using integer values that fall on pixels)
    assert len(rows) <= 65536 # 256*256

    # right now we only show "type 1" trees so the header is
    # 1 | n trees | 0 | size
    sizeoffileheader = 4+4
    numsections = len(groups)
    sizeofsectionheaders = (1+2+1)*numsections
    sizeofrecord = 2
    buffersize = sizeoffileheader + sizeofsectionheaders + sizeofrecord*len(rows)

    buf = ctypes.create_string_buffer(buffersize)
    bufoffset = 0

    # File Header: magic (3), pad(1), length (4)
    # Little endian, no align
    struct.pack_into("<II", buf, bufoffset, 0xA3A5EA00, len(rows))
    bufoffset += 8 #sizeoffileheader

    for group in groups.keys():
        pts = groups[group]

        # Section header: type (1), num(4)
        # Little endian, no align
        # Default to type 1
        struct.pack_into("<BHx", buf, bufoffset, group, len(pts))
        bufoffset += 4 #sizeofheader

        # Write pairs: x(1), y(1)
        # Litle endian, no align
        for (x,y) in pts:
            struct.pack_into("<BB", buf, bufoffset, x, y)
            bufoffset += 2 #sizeofrecord

    return buf.raw

def latlng2webm(lat,lng):
    num = lat * 0.017453292519943295
    x = 6378137.0 * num
    a = lng * 0.017453292519943295

    y = 3189068.5*math.log((1.0 + math.sin(a))/(1.0 - math.sin(a)))

    return (x,y)

@require_http_methods(["POST"])
@api_call()
def reset_password(request):
    resetform = PasswordResetForm({ "email" : request.REQUEST["email"]})

    if (resetform.is_valid()):
        opts = {
            'use_https': request.is_secure(),
            'token_generator': default_token_generator,
            'from_email': None,
            'email_template_name': 'reset_email_password.html',
            'request': request,
            }

        resetform.save(**opts)
        return { "status": "success" }
    else:
        raise HttpBadRequestException()

@require_http_methods(["GET"])
@api_call()
def version(request):
    """ API Request

    Get version information for OTM and the API. Generally, the API is unstable for
    any API version < 1 and minor changes (i.e. 1.4,1.5,1.6) represent no break in
    existing functionality

    Verb: GET
    Params: None
    Output:
      {
        otm_version, string -> Open Tree Map Version (i.e. 1.0.2)
        api_version, string -> API version (i.e. 1.6)
      }

    """
    return { "otm_version": settings.OTM_VERSION,
             "api_version": settings.API_VERSION }

@require_http_methods(["GET"])
@api_call_raw("image/png")
def get_tree_image(request, plot_id, photo_id):
    """ API Request

    Verb: GET
    Params:

    Output:
      image/jpeg raw data
    """
    treephoto = TreePhoto.objects.get(pk=photo_id)

    if treephoto.tree.plot.pk == int(plot_id):
        img = Image.open(treephoto.photo.path)
        try:
           orientation = img._getexif()[0x0112]
           if orientation == 6: # Right turn
              img = img.rotate(-90)
           elif orientation == 5: # Left turn
              img = img.rotate(90)
        except:
           pass

        resized = img.resize((144,132), Image.ANTIALIAS)
        response = HttpResponse(mimetype="image/png")
        resized.save(response, "PNG")
        return response
    else:
        raise HttpBadRequestException('invalid url (missing objects)')

@require_http_methods(["GET"])
@api_call()
def get_plot_list(request):
    """ API Request

    Get a list of all plots in the database. This is meant to be a lightweight
    listing service. To get more details about a plot use the ^plot/{id}$ service

    Verb: GET
    Params:
      offset, integer, default = 0  -> offset to start results from
      size, integer, default = 100 -> Maximum 10000, number of results to get

    Output:
      [{
          width, integer, opt -> Width of tree bed
          length, integer, opt -> Length of bed
          type, string, opt -> Plot type
          geometry, Point -> Lat/lng pt
          readonly, boolean -> True if this is a readonly tree
          tree, {
             id, integer -> tree id
             species, integer, opt -> Species id
             dbh, real, opt -> Diameter of the tree
          }
       }]

      """
    start = int(request.REQUEST.get("offset","0"))
    size = min(int(request.REQUEST.get("size", "100")), 10000)
    end = size + start

    # order_by prevents testing weirdness
    plots = Plot.objects.filter(present=True).order_by('id')[start:end]

    return [convert_response_plot_dict_choice_values(request, plot) for plot in plots_to_list_of_dict(plots,user=request.user)]

@require_http_methods(["GET"])
@api_call()
def species_list(request, lat=None, lon=None):
    allspecies = Species.objects.all()

    return [species_to_dict(z) for z in allspecies]

@require_http_methods(["GET"])
@api_call()
@login_optional
def plots_closest_to_point(request, lat=None, lon=None):
    point = Point(float(lon), float(lat), srid=4326)

    distance_string = request.GET.get('distance', settings.MAP_CLICK_RADIUS)
    try:
        distance = float(distance_string)
    except ValueError:
        raise HttpBadRequestException('The distance parameter must be a number')

    max_plots_string = request.GET.get('max_plots', '1')
    try:
        max_plots = int(max_plots_string)
    except ValueError:
        raise HttpBadRequestException('The max_plots parameter must be a number between 1 and 500')

    if max_plots > 500 or max_plots < 1:
        raise HttpBadRequestException('The max_plots parameter must be a number between 1 and 500')

    species = request.GET.get('species', None)

    sort_recent = request.GET.get('filter_recent', None)
    if sort_recent and sort_recent == "true":
        sort_recent = True
    else:
        sort_recent = False

    sort_pending = request.GET.get('filter_pending', None)
    if sort_pending and sort_pending == "true":
        sort_pending = True
    else:
        sort_pending = False

    has_tree = request.GET.get("has_tree",None)
    if has_tree:
        if has_tree == "true":
            has_tree = True
        else:
            has_tree = False

    has_species = request.GET.get("has_species",None)
    if has_species:
        if has_species == "true":
            has_species = True
        else:
            has_species = False

    has_dbh = request.GET.get("has_dbh",None)
    if has_dbh:
        if has_dbh == "true":
            has_dbh = True
        else:
            has_dbh = False

    plots, extent = Plot.locate.with_geometry(
        point, distance, max_plots, species,
        native=str2bool(request.GET,"filter_native"),
        flowering=str2bool(request.GET,'filter_flowering'),
        fall=str2bool(request.GET,'filter_fall_colors'),
        edible=str2bool(request.GET,'filter_edible'),
        dbhmin=request.GET.get("filter_dbh_min",None),
        dbhmax=request.GET.get("filter_dbh_max",None),
        species=request.GET.get("filter_species",None),
        pests=request.GET.get("filter_pests",None),
        sort_recent=sort_recent, sort_pending=sort_pending,
        has_tree=has_tree, has_species=has_species, has_dbh=has_dbh)

    return [convert_response_plot_dict_choice_values(request, plot) for plot in plots_to_list_of_dict(plots, longform=True, user=request.user)]

def str2bool(ahash, akey):
    if akey in ahash:
        return ahash[akey] == "true"
    else:
        return None

def plots_to_list_of_dict(plots,longform=False,user=None):
    return [plot_to_dict(plot,longform=longform,user=user) for plot in plots]

def point_wkt_to_dict(wkt):
    point = fromstr(wkt)
    return {
        'lat': point.y,
        'lng': point.x,
        'srid': '4326'
    }

def pending_edit_to_dict(pending_edit):
    if pending_edit.field == 'geometry':
        pending_value = point_wkt_to_dict(pending_edit.value) # Pending geometry edits are stored as WKT
    else:
        pending_value = pending_edit.value

    return {
        'id': pending_edit.pk,
        'submitted': datetime_to_iso_string(pending_edit.submitted),
        'value': pending_value,
        'username': pending_edit.submitted_by.username
    }

def plot_to_dict(plot,longform=False,user=None):
    pending_edit_dict = {} #If settings.PENDING_ON then this will be populated and included in the response
    current_tree = plot.current_tree()
    if current_tree:
        tree_dict = { "id" : current_tree.pk }

        if current_tree.species:
            tree_dict["species"] = current_tree.species.pk
            tree_dict["species_name"] = current_tree.species.common_name
            tree_dict["sci_name"] = current_tree.get_scientific_name()

        if current_tree.dbh:
            tree_dict["dbh"] = current_tree.dbh

        if current_tree.height:
            tree_dict["height"] = current_tree.height

        if current_tree.canopy_height:
            tree_dict["canopy_height"] = current_tree.canopy_height

        images = current_tree.treephoto_set.all()

        if len(images) > 0:
            tree_dict["images"] = [{"id": image.pk, "title": image.title, "url": image.photo.url}
                                   for image in images]

        if longform:
            tree_dict['tree_owner'] = current_tree.tree_owner
            tree_dict['steward_name'] = current_tree.steward_name
            tree_dict['sponsor'] = current_tree.sponsor

            if len(TreeResource.objects.filter(tree=current_tree)) > 0:
                tree_dict['eco'] = tree_resource_to_dict(current_tree.treeresource)

            if current_tree.steward_user:
                tree_dict['steward_user'] = current_tree.steward_user

            tree_dict['species_other1'] = current_tree.species_other1
            tree_dict['species_other2'] = current_tree.species_other2
            tree_dict['date_planted'] = datetime_to_iso_string(current_tree.date_planted)
            tree_dict['date_removed'] = datetime_to_iso_string(current_tree.date_removed)
            tree_dict['present'] = current_tree.present
            tree_dict['last_updated'] = datetime_to_iso_string(current_tree.last_updated)
            tree_dict['last_updated_by'] = current_tree.last_updated_by.username
            tree_dict['condition'] = current_tree.condition
            tree_dict['canopy_condition'] = current_tree.canopy_condition
            tree_dict['pests'] = current_tree.pests
            tree_dict['readonly'] = current_tree.readonly

            if settings.PENDING_ON:
                tree_field_reverse_property_name_dict = {'species_id': 'species'}
                for raw_field_name, detail in current_tree.get_active_pend_dictionary().items():
                    if raw_field_name in tree_field_reverse_property_name_dict:
                        field_name = tree_field_reverse_property_name_dict[raw_field_name]
                    else:
                        field_name = raw_field_name
                    pending_edit_dict['tree.' + field_name] = {'latest_value': detail['latest_value'], 'pending_edits': []}
                    for pend in detail['pending_edits']:
                        pend_dict = pending_edit_to_dict(pend)
                        if field_name == 'species':
                            species_set = Species.objects.filter(pk=pend_dict['value'])
                            if species_set:
                                pend_dict['related_fields'] = {
                                    'tree.sci_name': species_set[0].scientific_name,
                                    'tree.species_name': species_set[0].common_name
                                }
                        pending_edit_dict['tree.' + field_name]['pending_edits'].append(pend_dict)

    else:
        tree_dict = None

    base = {
        "id": plot.pk,
        "plot_width": plot.width,
        "plot_length": plot.length,
        "owner_orig_id": plot.owner_orig_id,
        "type": plot.type,
        "readonly": plot.readonly,
        "tree": tree_dict,
        "address": plot.geocoded_address,
        "geometry": {
            "srid": plot.geometry.srid,
            "lat": plot.geometry.y,
            "lng": plot.geometry.x
        }
    }

    if user:
        base["perm"] = plot_permissions(plot,user)

    if longform:
        base['power_lines'] = plot.powerline_conflict_potential
        base['sidewalk_damage'] = plot.sidewalk_damage
        base['address_street'] = plot.address_street
        base['address_city'] = plot.address_city
        base['address_zip'] = plot.address_zip

        if plot.data_owner:
            base['data_owner'] = plot.data_owner.pk

        base['last_updated'] = datetime_to_iso_string(plot.last_updated)

        if plot.last_updated_by:
            base['last_updated_by'] = plot.last_updated_by.username

        if settings.PENDING_ON:
            plot_field_reverse_property_name_dict = {'width': 'plot_width', 'length': 'plot_length', 'powerline_conflict_potential': 'power_lines'}

            for raw_field_name, detail in plot.get_active_pend_dictionary().items():
                if raw_field_name in plot_field_reverse_property_name_dict:
                    field_name = plot_field_reverse_property_name_dict[raw_field_name]
                else:
                    field_name = raw_field_name

                if field_name == 'geometry':
                    latest_value = point_wkt_to_dict(detail['latest_value'])
                else:
                    latest_value = detail['latest_value']

                pending_edit_dict[field_name] = {'latest_value': latest_value, 'pending_edits': []}
                for pend in detail['pending_edits']:
                    pending_edit_dict[field_name]['pending_edits'].append(pending_edit_to_dict(pend))
            base['pending_edits'] = pending_edit_dict

    return base


def convert_response_plot_dict_choice_values(request, plot_dict):
    return convert_plot_dict_choice_values(request, plot_dict, 'reverse')


def convert_request_plot_dict_choice_values(request, plot_dict):
    return convert_plot_dict_choice_values(request, plot_dict, 'forward')


def convert_plot_dict_choice_values(request, plot_dict, direction):
    if direction not in ['forward', 'reverse']:
        raise ValueError('direction argument must be "forward" or "reverse"')

    # If no conversions are defined, bail out quickly since no work has to be done
    if not hasattr(settings, 'CHOICE_CONVERSIONS'):
        return plot_dict

    # The list of attributes that are nested under the 'tree' key in the plot dict
    TREE_ATTRS = ['condition', 'canopy_condition']
    # A map from the Django model atrributes to serialized attribute names
    ATTR_TO_KEY = {
        'powerline_conflict_potential': 'power_lines'
    }

    converted_plot_dict = deepcopy(plot_dict)

    for attr in [x for x in settings.CHOICE_CONVERSIONS.keys() if _attribute_requires_conversion(request, x)]:
        if attr in ATTR_TO_KEY.keys():
            dict_key = ATTR_TO_KEY[attr]
        else:
            dict_key = attr

        conversions = settings.CHOICE_CONVERSIONS[attr][direction]

        def do_conversion(value):
            if value is not None:
                for (a, b) in conversions:
                    if str(value) == str(a):
                        value = b
                        break
            return value

        # Regular fields
        if attr in TREE_ATTRS:
            if 'tree' in converted_plot_dict and converted_plot_dict['tree'] is not None:
                value = do_conversion(converted_plot_dict['tree'].get(dict_key, None))
            else:
                value = None
        else:
            value = do_conversion(converted_plot_dict.get(dict_key, None))

        if value is not None:
            if attr in TREE_ATTRS:
                converted_plot_dict['tree'][dict_key] = value
            else:
                converted_plot_dict[dict_key] = value

        # Pending edits
        if 'pending_edits' in converted_plot_dict:
            if attr in TREE_ATTRS:
                pend_key = 'tree.' + dict_key
            else:
                pend_key = dict_key

            pend_field_dict = converted_plot_dict['pending_edits'].get(pend_key, None)
            if pend_field_dict is not None:
                # Update the latest value
                value = do_conversion(pend_field_dict.get('latest_value', None))
                if value is not None:
                    pend_field_dict['latest_value'] = value

                # Update each pending value
                pend_values_dicts = pend_field_dict.get('pending_edits', None)
                if pend_values_dicts is not None:
                    for pend_value_dict in pend_values_dicts:
                        value = do_conversion(pend_value_dict.get('value', None))
                        if value is not None:
                            pend_value_dict['value'] = value

    return converted_plot_dict


def tree_resource_to_dict(tr):
    b = BenefitValues.objects.all()[0]

    ac_dollar = tr.annual_ozone * b.ozone + tr.annual_nox * b.nox + \
                tr.annual_pm10 * b.pm10 + tr.annual_sox * b.sox + \
                tr.annual_voc * b.voc + tr.annual_bvoc * b.bvoc

    weight_unit = getattr(settings, 'ECO_WEIGHT_UNIT', 'lbs')
    elec_unit = getattr(settings, 'ECO_POWER_UNIT', 'kWh')
    water_unit = getattr(settings, 'ECO_WATER_UNIT', 'gallons')

    return {
        "annual_stormwater_management": with_unit(tr.annual_stormwater_management, b.stormwater, water_unit),
        "annual_electricity_conserved": with_unit(tr.annual_electricity_conserved, b.electricity, elec_unit),
        "annual_energy_conserved": with_unit(tr.annual_energy_conserved, b.electricity, elec_unit),
        "annual_natural_gas_conserved": with_unit(tr.annual_natural_gas_conserved, b.electricity, elec_unit),
        "annual_air_quality_improvement": with_unit(tr.annual_air_quality_improvement, None, weight_unit, dollar=ac_dollar),
        "annual_co2_sequestered": with_unit(tr.annual_co2_sequestered, b.co2, weight_unit),
        "annual_co2_avoided": with_unit(tr.annual_co2_avoided, b.co2, weight_unit),
        "annual_co2_reduced": with_unit(tr.annual_co2_reduced, b.co2, weight_unit),
        "total_co2_stored": with_unit(tr.total_co2_stored, b.co2, weight_unit),
        "annual_ozone": with_unit(tr.annual_ozone, b.ozone, weight_unit),
        "annual_nox": with_unit(tr.annual_nox, b.nox, weight_unit),
        "annual_pm10": with_unit(tr.annual_pm10, b.pm10,  weight_unit),
        "annual_sox": with_unit(tr.annual_sox, b.sox, weight_unit),
        "annual_voc": with_unit(tr.annual_voc, b.voc, weight_unit),
        "annual_bvoc": with_unit(tr.annual_bvoc, b.bvoc, weight_unit) }

def with_unit(val,dollar_factor,unit,dollar=None):
    if dollar is None:
        dollar = dollar_factor * val

    return { "value": val, "unit": unit, "dollars": dollar }


def species_to_dict(s):
    return {
        "id": s.pk,
        "scientific_name": s.scientific_name,
        "genus": s.genus,
        "species": s.species,
        "cultivar": s.cultivar_name,
        "gender": s.gender,
        "common_name": s.common_name }


def user_to_dict(user):
    return {
        "id": user.pk,
        "firstname": user.first_name,
        "lastname": user.last_name,
        "email": user.email,
        "username": user.username,
        "zipcode": UserProfile.objects.get(user__pk=user.pk).zip_code,
        "reputation": Reputation.objects.reputation_for_user(user).reputation,
        "permissions": list(user.get_all_permissions()),
        "user_type": user_access_type(user)
        }

def user_access_type(user):
    """ Given a user, determine the name and "level" of a user """
    if user.is_superuser:
        return { 'name': 'administrator', 'level': 1000 }
    elif Reputation.objects.reputation_for_user(user).reputation > 1000:
        return { 'name': 'editor', 'level': 500 }
    else:
        return { 'name': 'public', 'level': 0 }


@require_http_methods(["GET"])
@api_call()
def geocode_address(request, address):
    def result_in_bounding_box(result):
        x = float(result.x)
        y = float(result.y)
        left = float(settings.BOUNDING_BOX['left'])
        top = float(settings.BOUNDING_BOX['top'])
        right = float(settings.BOUNDING_BOX['right'])
        bottom = float(settings.BOUNDING_BOX['bottom'])
        return x > left and x < right and y > bottom and y < top

    if address is None or len(address) == 0:
        raise HttpBadRequestException("No address specfified")

    query = PlaceQuery(address, viewbox=Viewbox(
        settings.BOUNDING_BOX['left'],
        settings.BOUNDING_BOX['top'],
        settings.BOUNDING_BOX['right'],
        settings.BOUNDING_BOX['bottom'])
    )

    if 'OMGEO_GEOCODER_SOURCES' in dir(settings) and settings.OMGEO_GEOCODER_SOURCES is not None:
        geocoder = Geocoder(settings.OMGEO_GEOCODER_SOURCES)
    else:
        geocoder = Geocoder()

    results = geocoder.geocode(query)
    if results != False:
        response = []
        for result in results:
            if result_in_bounding_box(result): # some geocoders do not support passing a bounding box filter
                response.append({
                     "match_addr": result.match_addr,
                     "x": result.x,
                     "y": result.y,
                     "score": result.score,
                     "locator": result.locator,
                     "geoservice": result.geoservice,
                     "wkid": result.wkid,
                })
        return response
    else:
        # This is not a very helpful error message, but omgeo as of v1.2 does not
        # report failure details.
        return {"error": "The geocoder failed to generate a list of results."}

def flatten_plot_dict_with_tree_and_geometry(plot_dict):
    if 'tree' in plot_dict and plot_dict['tree'] is not None:
        tree_dict = plot_dict['tree']
        for field_name in tree_dict.keys():
            plot_dict[field_name] = tree_dict[field_name]
        del plot_dict['tree']
    if 'geometry' in plot_dict:
        geometry_dict = plot_dict['geometry']
        for field_name in geometry_dict.keys():
            plot_dict[field_name] = geometry_dict[field_name]
        del plot_dict['geometry']

def rename_plot_request_dict_fields(request_dict):
    '''
    The new plot/tree form requires specific field names that do not directly match
    up with the model objects (e.g. the form expects a 'species_id' field) so this
    helper function renames keys in the dictionary to match what the form expects
    '''
    field_map = {'species': 'species_id', 'width': 'plot_width', 'length': 'plot_length'}
    for map_key in field_map.keys():
        if map_key in request_dict:
            request_dict[field_map[map_key]] = request_dict[map_key]
            del request_dict[map_key]
    return request_dict

@require_http_methods(["POST"])
@api_call()
@login_required
def create_plot_optional_tree(request):
    response = HttpResponse()

    # Unit tests fail to access request.raw_post_data
    request_dict = json_from_request(request)

    # Convert any 'legacy' choice values
    request_dict = convert_request_plot_dict_choice_values(request, request_dict)

    # The Django form used to validate and save plot and tree information expects
    # a flat dictionary. Allowing the tree and geometry details to be in nested
    # dictionaries in API calls clarifies, to API clients, the distinction between
    # Plot and Tree and groups the coordinates along with their spatial reference
    flatten_plot_dict_with_tree_and_geometry(request_dict)

    # The new plot/tree form requires specific field names that do not directly match
    # up with the model objects (e.g. the form expects a 'species_id' field) so this
    # helper function renames keys in the dictionary to match what the form expects
    rename_plot_request_dict_fields(request_dict)

    form = TreeAddForm(request_dict, request.FILES)

    if not form.is_valid():
        response.status_code = 400
        if '__all__' in form.errors:
            response.content = simplejson.dumps({"error": form.errors['__all__']})
        else:
            response.content = simplejson.dumps({"error": form.errors})
        return response

    try:
        new_plot = form.save(request)
    except ValidationError, ve:
        response.status_code = 400
        response.content = simplejson.dumps({"error": form.error_class(ve.messages)})
        return response

    new_tree = new_plot.current_tree()
    if new_tree:
        change_reputation_for_user(request.user, 'add tree', new_tree)
    else:
        change_reputation_for_user(request.user, 'add plot', new_plot)

    response.status_code = 201
    new_plot = convert_response_plot_dict_choice_values(request, plot_to_dict(Plot.objects.get(pk=new_plot.id),longform=True,user=request.user))
    response.content = json.dumps(new_plot)
    return response

@require_http_methods(["GET"])
@api_call()
@login_optional
def get_plot(request, plot_id):
    return convert_response_plot_dict_choice_values(request,
        plot_to_dict(Plot.objects.get(pk=plot_id), longform=True, user=request.user)
    )

def compare_fields(v1,v2):
    if v1 is None:
        return v1 == v2
    try:
        v1f = float(v1)
        v2f = float(v2)
        return v1f == v2f
    except ValueError:
        return v1 == v2


def _parse_application_version_header_as_dict(request):
    if request is None:
        return None

    app_version = {
        'platform': 'UNKNOWN',
        'version': 'UNKNOWN',
        'build': 'UNKNOWN'
    }

    version_string = request.META.get("HTTP_APPLICATIONVERSION", '')
    if version_string == '':
        return app_version

    segments = version_string.rsplit('-')
    if len(segments) >= 1:
        app_version['platform'] = segments[0]
    if len(segments) >= 2:
        app_version['version'] = segments[1]
    if len(segments) >= 3:
        app_version['build'] = segments[2]

    return app_version


def _attribute_requires_conversion(request, attr):
    if attr is None:
        return False

    if not hasattr(settings, 'CHOICE_CONVERSIONS'):
        # If CHOICE_CONVERSIONS is not defined in settings then
        # no conversion is required
        return False

    if attr in settings.CHOICE_CONVERSIONS:
        conversion = settings.CHOICE_CONVERSIONS[attr]
        app_version = _parse_application_version_header_as_dict(request)
        if 'version-threshold' in conversion \
        and app_version['platform'] in conversion['version-threshold']:
            threshold_string = conversion['version-threshold'][app_version['platform']]
            # If the threshold is not parsable as a version number, we want this method
            # to crash hard. The CHOICE_CONVERSIONS are misconfigured.
            threshold = StrictVersion(threshold_string)

            try:
                version = StrictVersion(app_version['version'])
            except ValueError:
                # If the version number reported from the app is not parsable as a
                # version number then we assume the app is an old version and that we do
                # need to convert the values.
                return True

            return version < threshold
        else:
            # If a version threshold is not defined for the platform specified in the
            # ApplicationVersion header or the ApplicationVersion header is missing
            # or does not match anything
            return True
    else:
        # If the settings.CHOICE_CONVERSIONS hash does not contain the attribute name
        # then no conversion is required
        return False


@require_http_methods(["PUT"])
@api_call()
@login_required
def update_plot_and_tree(request, plot_id):

    def set_attr_with_choice_correction(request, model, attr, value):
        if _attribute_requires_conversion(request, attr):
            conversions = settings.CHOICE_CONVERSIONS[attr]['forward']
            for (old, new) in conversions:
                if str(value) == str(old):
                    value = new
                    break
        setattr(model, attr, value)

    def get_attr_with_choice_correction(request, model, attr):
        value = getattr(model, attr)
        if _attribute_requires_conversion(request, attr):
            conversions = settings.CHOICE_CONVERSIONS[attr]['reverse']
            for (new, old) in conversions:
                if str(value) == str(new):
                    value = old
                    break
        return value

    response = HttpResponse()
    try:
        plot = Plot.objects.get(pk=plot_id)
    except Plot.DoesNotExist:
        response.status_code = 400
        response.content = simplejson.dumps({"error": "No plot with id %s" % plot_id})
        return response

    request_dict = convert_request_plot_dict_choice_values(request, json_from_request(request))

    flatten_plot_dict_with_tree_and_geometry(request_dict)

    plot_field_whitelist = ['plot_width','plot_length','type','geocoded_address','edit_address_street', 'address_city', 'address_street', 'address_zip', 'power_lines', 'sidewalk_damage']

    # The Django form that creates new plots expects a 'plot_width' parameter but the
    # Plot model has a 'width' parameter so this dict acts as a translator between request
    # keys and model field names
    plot_field_property_name_dict = {'plot_width': 'width', 'plot_length': 'length', 'power_lines': 'powerline_conflict_potential'}

    should_create_plot_pends = requires_pending_record(plot, request.user)

    plot_was_edited = False
    for plot_field_name in request_dict.keys():
        if plot_field_name in plot_field_whitelist:
            if plot_field_name in plot_field_property_name_dict:
                new_name = plot_field_property_name_dict[plot_field_name]
            else:
                new_name = plot_field_name
            new_value = request_dict[plot_field_name]
            if not compare_fields(get_attr_with_choice_correction(request, plot, new_name), new_value):
                if should_create_plot_pends:
                    plot_pend = PlotPending(plot=plot)
                    plot_pend.set_create_attributes(request.user, new_name, new_value)
                    plot_pend.save()
                else:
                    set_attr_with_choice_correction(request, plot, new_name, new_value)
                    plot_was_edited = True

    # TODO: Standardize on lon or lng
    if 'lat' in request_dict or 'lon' in request_dict or 'lng' in request_dict:
        new_geometry = Point(x=plot.geometry.x, y=plot.geometry.y)
        if 'lat' in request_dict:
            new_geometry.y = request_dict['lat']
        if 'lng' in request_dict:
            new_geometry.x = request_dict['lng']
        if 'lon' in request_dict:
            new_geometry.x = request_dict['lon']

        if plot.geometry.x != new_geometry.x or plot.geometry.y != new_geometry.y:
            if should_create_plot_pends:
                plot_pend = PlotPending(plot=plot)
                plot_pend.set_create_attributes(request.user, 'geometry', new_geometry)
                plot_pend.save()
            else:
                plot.geometry = new_geometry
                plot_was_edited = True

    if plot_was_edited:
        plot.last_updated = datetime.datetime.now()
        plot.last_updated_by = request.user
        plot.save()
        change_reputation_for_user(request.user, 'edit plot', plot)

    tree_was_edited = False
    tree_was_added = False
    tree = plot.current_tree()
    tree_field_whitelist = ['species','dbh','height','canopy_height', 'canopy_condition', 'condition','pests']

    if tree is None:
        should_create_tree_pends = False
    else:
        should_create_tree_pends = requires_pending_record(tree, request.user)

    for tree_field in Tree._meta.fields:
        if tree_field.name in request_dict and tree_field.name in tree_field_whitelist:
            if tree is None:
                import_event, created = ImportEvent.objects.get_or_create(file_name='site_add',)
                tree = Tree(plot=plot, last_updated_by=request.user, import_event=import_event)
                tree.plot = plot
                tree.last_updated_by = request.user
                tree.save()
                tree_was_added = True
            if tree_field.name == 'species':
                try:
                    if (tree.species and tree.species.pk != request_dict[tree_field.name]) \
                    or (not tree.species and request_dict[tree_field.name]):
                        if should_create_tree_pends:
                            tree_pend = TreePending(tree=tree)
                            tree_pend.set_create_attributes(request.user, 'species_id', request_dict[tree_field.name])
                            tree_pend.save()
                        else:
                            tree.species = Species.objects.get(pk=request_dict[tree_field.name])
                            tree_was_edited = True
                except Exception:
                    response.status_code = 400
                    response.content = simplejson.dumps({"error": "No species with id %s" % request_dict[tree_field.name]})
                    return response
            else: # tree_field.name != 'species'
                if not compare_fields(get_attr_with_choice_correction(request, tree, tree_field.name), request_dict[tree_field.name]):
                    if should_create_tree_pends:
                        tree_pend = TreePending(tree=tree)
                        tree_pend.set_create_attributes(request.user, tree_field.name, request_dict[tree_field.name])
                        tree_pend.save()
                    else:
                        set_attr_with_choice_correction(request, tree, tree_field.name, request_dict[tree_field.name])
                        tree_was_edited = True

    if tree_was_edited:
        tree.last_updated = datetime.datetime.now()
        tree.last_updated_by = request.user

    if tree_was_added or tree_was_edited:
        tree.save()

    # You cannot get reputation for both adding and editing a tree in one action
    # so I use an elif here
    if tree_was_added:
        change_reputation_for_user(request.user, 'add tree', tree)
    elif tree_was_edited:
        change_reputation_for_user(request.user, 'edit tree', tree)

    full_plot = Plot.objects.get(pk=plot.id)
    return_dict = convert_response_plot_dict_choice_values(request, plot_to_dict(full_plot, longform=True,user=request.user))
    response.status_code = 200
    response.content = simplejson.dumps(return_dict)
    return response

@require_http_methods(["POST"])
@api_call()
@login_required
@has_pending_permission_or_403_forbidden
def approve_pending_edit(request, pending_edit_id):
    pend, model = get_tree_pend_or_plot_pend_by_id_or_404_not_found(pending_edit_id)

    pend.approve_and_reject_other_active_pends_for_the_same_field(request.user)

    if model == 'Tree':
        change_reputation_for_user(pend.submitted_by, 'edit tree', pend.tree, change_initiated_by_user=pend.updated_by)
        updated_plot = Plot.objects.get(pk=pend.tree.plot.id)
    else: # model == 'Plot'
        change_reputation_for_user(pend.submitted_by, 'edit plot', pend.plot, change_initiated_by_user=pend.updated_by)
        updated_plot = Plot.objects.get(pk=pend.plot.id)

    return convert_response_plot_dict_choice_values(request, plot_to_dict(updated_plot, longform=True))

@require_http_methods(["POST"])
@api_call()
@login_required
@has_pending_permission_or_403_forbidden
def reject_pending_edit(request, pending_edit_id):
    pend, model = get_tree_pend_or_plot_pend_by_id_or_404_not_found(pending_edit_id)
    pend.reject(request.user)
    if model == 'Tree':
        updated_plot = Plot.objects.get(pk=pend.tree.plot.id)
    else: # model == 'Plot'
        updated_plot = Plot.objects.get(pk=pend.plot.id)
    return convert_response_plot_dict_choice_values(request, plot_to_dict(updated_plot, longform=True))


@require_http_methods(["DELETE"])
@api_call()
@login_required
@transaction.commit_on_success
def remove_plot(request, plot_id):
    plot = get_object_or_404(Plot, pk=plot_id)
    if can_delete_tree_or_plot(plot, request.user):
        plot.remove()
        return {"ok": True}
    else:
        raise PermissionDenied('%s does not have permission to delete plot %s' % (request.user.username, plot_id))

@require_http_methods(["DELETE"])
@api_call()
@login_required
@transaction.commit_on_success
def remove_current_tree_from_plot(request, plot_id):
    plot = get_object_or_404(Plot, pk=plot_id)
    tree = plot.current_tree()
    if tree:
        if can_delete_tree_or_plot(tree, request.user):
            tree.remove()
            updated_plot = Plot.objects.get(pk=plot_id)
            return convert_response_plot_dict_choice_values(request, plot_to_dict(updated_plot, longform=True, user=request.user))
        else:
            raise PermissionDenied('%s does not have permission to the current tree from plot %s' % (request.user.username, plot_id))
    else:
        raise HttpResponseBadRequest("Plot %s does not have a current tree" % plot_id)

@require_http_methods(["GET"])
@api_call()
def get_current_tree_from_plot(request, plot_id):
    plot = get_object_or_404(Plot, pk=plot_id)
    if  plot.current_tree():
        plot_dict = convert_response_plot_dict_choice_values(request,
            plot_to_dict(plot, longform=True)
        )
        return plot_dict['tree']
    else:
        raise HttpResponseBadRequest("Plot %s does not have a current tree" % plot_id)


@require_http_methods(["GET"])
@api_call()
def get_cql_query(request):
    trees, plots, geog_object, agg_object, tile_query = _build_tree_search_result(request)
    search_results = {
        'cql_string' : tile_query,
        }
    return search_results

########NEW FILE########
__FILENAME__ = choices.example
CHOICES = {
            'alerts': [
                ("1", "Needs Watering"), 
                ("2", "Needs Pruning"), 
                ("3", "Should be Removed"), 
                ("4", "Pest Or Disease Present"), 
                ("5", "Guard Should Be Removed"), 
                ("6", "Stakes And Ties Should Be Removed"), 
                ("7", "Construction Work In The Area"), 
                ("8", "Touching Wires"), 
                ("9", "Blocking Signs or Traffic Signals"), 
                ("10", "Improperly Pruned or Topped")
            ],
            'actions': [
            ],
            'projects': [
            ],
            'sidewalks': [
                ("1", "Minor or No Damage"),
                ("2", "Raised More Than 3/4 Inch")
            ],
            'powerlines': [
                ("1", "Yes"),
                ("2", "No"),
                ("3", "Unknown")
            ],
            'conditions': [
                ("1", "Dead"),
                ("2", "Critical"),
                ("3", "Poor"),
                ("4", "Fair"),
                ("5", "Good"),
                ("6", "Very Good"),
                ("7", "Excellent")
            ],
            'canopy_conditions': [
                ("1", "Full - No Gaps"),
                ("2", "Small Gaps (up to 25% missing)"),
                ("3", "Moderate Gaps (up to 50% missing)"),
                ("4", "Large Gaps (up to 75% missing)"),
                ("5", "Little or None (up to 100% missing)")
            ],
            'plot_types': [
                ("1", "Well/Pit"),
                ("2", "Median/Island"),
                ("3", "Tree Lawn"),
                ("4", "Park"),
                ("5", "Planter"),
                ("6", "Other"),
                ("7", "Yard"),
                ("8", "Natural Area")
            ],
            'plot_stewardship': [
                ("1","Watering"),
                ("2","Pruning"),
                ("3","Mulching, Adding Compost or Amending Soil"),
                ("4","Removing Debris or Trash")
            ],
            'tree_stewardship': [
                ("1","Enlarging the Planting Area"),
                ("2","Adding a Guard"),
                ("3","Removing a Guard"),
                ("4","Herbaceous Planting")
            ]
    }



########NEW FILE########
__FILENAME__ = models
import datetime

from django.db import models

from django.contrib.auth.models import User

class FavoriteBase(models.Model):
    """
    This is the abstract base class that you will subclass to create your own
    domain-specific Favorite model.
    """
    user = models.ForeignKey(User)
    
    date_created = models.DateTimeField(default=datetime.datetime.now)
    
    class Meta(object):
        abstract = True
########NEW FILE########
__FILENAME__ = views
from django.shortcuts import get_object_or_404, render_to_response
from django.template import RequestContext
from django.db import transaction
from django.core import serializers
from django.conf import settings
from django.http import HttpResponse, HttpResponseRedirect

from django.contrib.auth.models import User

RESPONSE_MAPPING = {
    'application/json': 'json',
    'text/xml': 'xml',
}

class FavoriteBase(object):
    """
    This is the base class that all of the class-based views for this app
    will subclass.
    """
    def __init__(self, favorite, content_model, fk_name=None, extra_context={},
        context_init=RequestContext, next_field='next',
        response_mapping=RESPONSE_MAPPING, use_transactions=True):
        self.favorite = favorite
        self.content_model = content_model
        self.extra_context = extra_context
        self.context_init = context_init
        self.response_mapping = response_mapping
        self.next_field = next_field
        self.use_transactions = use_transactions
        
        # If we have no explicitly-set foreign key name, we attempt to
        # determine that information by traversing all of the related fields
        # and choose the first one that relates to the content model
        if fk_name is None:
            for field in self.favorite._meta.fields:
                if field.rel and field.rel.to == self.content_model:
                    fk_name = field.name
                    break
        if fk_name is None:
            raise ValueError('Could not find related field between %s and '
                '%s. Please either specify it to %s using the keyword '
                'argument fk_name, and ensure that your models are '
                'constructed properly' % (
                    self.favorite, self.content_model, self.__class__.__name__
                )
            )
        self.fk_name = fk_name
    
    def __call__(self, request, *args, **kwargs):
        """
        By implementing the call method, we allow the class itself to act as
        the view function, taking in the request object and returning the
        response.  This method is responsible for dealing with transaction
        management, dispatching to the proper instance methods, and returning
        a valid HttpResponse.
        """
        if self.use_transactions:
            transaction.commit_unless_managed()
            transaction.enter_transaction_management()
            transaction.managed(True)
        
        context = self.view(request, *args, **kwargs)
        if isinstance(context, HttpResponseRedirect):
            return context
        context.update(self.extra_context)
        
        if self.next_field in request.REQUEST:
            next = request.REQUEST[self.next_field]
            if ':/' not in next:
                return HttpResponseRedirect(next)
        
        response = self.create_response(request, context)
        if self.use_transactions:
            transaction.commit()
            transaction.leave_transaction_management()
        
        return response
    
    def create_response(self, request, context):
        """
        This method receives the proper context variables and, based upon the
        ``HTTP_ACCEPT`` from the request, it will dispatch the context to the
        proper method for creating HttpResponse objects.  This could involve
        rendering HTML using templates, or it could simply be serialization
        using one of JSON or XML renderers.
        """
        try:
            http_accept = request.META['HTTP_ACCEPT'].split(',')[0]
        except (KeyError, IndexError):
            http_accept = None
        response_kind = self.response_mapping.get(http_accept, 'html')
        context_instance = None
        if response_kind == 'html':
            context_instance = self.context_init(request)
        responder = getattr(self, response_kind)
        return responder(context, context_instance=context_instance)
    
    def json(self, context, context_instance):
        """
        Given some context variables, this method returns a JSON representation
        of those variables.
        """
        raise NotImplemented
    
    def xml(self, context, context_instance):
        """
        Given some context variables, this method returns an XML representation
        of those variables.
        """
        raise NotImplemented
    
    def html(self, context, context_instance):
        """
        Given some context variables, this method returns rendered HTML for
        those variables.
        """
        raise NotImplemented


class CreateFavorite(FavoriteBase):
    """
    This is a class that allows for the favoriting of your content objects.
    """
    def __init__(self, *args, **kwargs):
        self.template_name = kwargs.pop('template_name',
            'favorites/created.html')
        super(CreateFavorite, self).__init__(*args, **kwargs)
    
    def json(self, context, context_instance):
        """
        Given some context variables, this method returns a JSON representation
        of those variables.
        """
        data = serializers.serialize('json', [context['favorite']])
        return HttpResponse(data, content_type='application/json')
    
    def xml(self, context, context_instance):
        """
        Given some context variables, this method returns an XML representation
        of those variables.
        """
        data = serializers.serialize('xml', [context['favorite']])
        return HttpResponse(data, content_type='text/xml')
    
    def html(self, context, context_instance):
        """
        Given some context variables, this method returns rendered HTML for
        those variables.
        """
        return render_to_response(self.template_name, context,
            context_instance=context_instance)
    
    def view(self, request, pk=None):
        """
        Given the request and a primary key (of the content object), this
        method is responsible for returning a dictionary of context variables
        suitable for being passed to one of the serialization methods.
        """
        if not request.user.is_authenticated():
            return HttpResponseRedirect('%s?next=%s' % (
                settings.LOGIN_URL,
                request.path,
            ))
        content_object = get_object_or_404(self.content_model, pk=pk)
        favorite, created = self.favorite.objects.get_or_create(**{
            'user': request.user,
            self.fk_name: content_object,
        })
        return {'favorite': favorite, 'created': created, 'item': content_object}


class DeleteFavorite(FavoriteBase):
    """
    This is a class that allows for the un-favoriting of your content objects.
    """
    def __init__(self, *args, **kwargs):
        self.template_name = kwargs.pop('template_name',
            'favorites/deleted.html')
        super(DeleteFavorite, self).__init__(*args, **kwargs)
    
    def json(self, context, context_instance):
        """
        Given some context variables, this method returns a JSON representation
        of those variables.
        """
        data = serializers.serialize('json', [context['item']])
        return HttpResponse(data, content_type='application/json')
    
    def xml(self, context, context_instance):
        """
        Given some context variables, this method returns an XML representation
        of those variables.
        """
        data = serializers.serialize('xml', [context['item']])
        return HttpResponse(data, content_type='text/xml')
    
    def html(self, context, context_instance):
        """
        Given some context variables, this method returns rendered HTML for
        those variables.
        """
        return render_to_response(self.template_name, context,
            context_instance=context_instance)
    
    def view(self, request, pk=None):
        """
        Given the request and a primary key (of the content object), this
        method is responsible for returning a dictionary of context variables
        suitable for being passed to one of the serialization methods.
        """
        if not request.user.is_authenticated():
            return HttpResponseRedirect('%s?next=%s' % (
                settings.LOGIN_URL,
                request.path,
            ))
        content_object = get_object_or_404(self.content_model, pk=pk)
        favorites = self.favorite.objects.filter(**{
            'user': request.user,
            self.fk_name: content_object,
        })
        i = 0
        for i, favorite in enumerate(favorites):
            favorite.delete()
        return {
            'num_deleted': i,
            'item': content_object,
            self.fk_name: content_object,
        }

class UserFavorites(FavoriteBase):
    """
    This is a class that can produce a list of a user's favorite content
    objects.
    """
    def __init__(self, *args, **kwargs):
        self.template_name = kwargs.pop('template_name',
            'favorites/list.html')
        self.extra_filter = kwargs.pop('extra_filter', lambda x: x)
        super(UserFavorites, self).__init__(*args, **kwargs)
    
    def json(self, context, context_instance):
        """
        Given some context variables, this method returns a JSON representation
        of those variables.
        """
        data = serializers.serialize('json', context['favorites'])
        return HttpResponse(data, content_type='application/json')
    
    def xml(self, context, context_instance):
        """
        Given some context variables, this method returns an XML representation
        of those variables.
        """
        data = serializers.serialize('xml', context['favorites'])
        return HttpResponse(data, content_type='text/xml')
    
    def html(self, context, context_instance):
        """
        Given some context variables, this method returns rendered HTML for
        those variables.
        """
        return render_to_response(self.template_name, context,
            context_instance=context_instance)
    
    def view(self, request, username=None):
        """
        Given the request and a primary key (of the content object), this
        method is responsible for returning a dictionary of context variables
        suitable for being passed to one of the serialization methods.
        """
        # The username can be None, but then the user must be logged in.
        # If the username is None and the user's not logged in, we redirect
        # them to the login page
        if username is None:
            if not request.user.is_authenticated():
                return HttpResponseRedirect('%s?next=%s' % (
                    settings.LOGIN_URL,
                    request.path,
                ))
            user = request.user
        else:
            user = get_object_or_404(User, username__iexact=username)
        
        # Sometimes it can be useful to know if the user is looking at their
        # own page, so we determine that as a convenience
        is_self = user == request.user
        
        # TODO: Can the following queries be made more efficient?
        base_faves = self.favorite.objects.filter(user=user)
        content_ids = self.extra_filter(base_faves).values_list(self.fk_name,
            flat=True).query
        # TODO: Ensure that the content models are returned in order of when
        #       they were favorited.
        favorites = self.content_model.objects.filter(pk__in=content_ids)
        return {
            'favorites': favorites,
            'favorite_user': user,
            'is_self': is_self,
        }
########NEW FILE########
__FILENAME__ = errors
# 3 tuples (error id, error descr, fatal)
from importer.fields import trees


EMPTY_FILE = (1, 'No rows found', True)
MISSING_POINTS = (2, 'You must specify a "%s" and "%s" field' %\
                  (trees.POINT_X, trees.POINT_Y), True)

UNMATCHED_FIELDS = (3, "Some fields in the uploaded dataset "\
                    "didn't match the template", False)

MISSING_SPECIES_FIELDS = (4, 'You must specify i-Tree Code, Common Name '\
                          'Genus and Species', True)

MISSING_FIELD = (5, 'This field is required', True)
GENERIC_ERROR = (6, 'There was an exception', True)

INVALID_GEOM = (10, 'Longitude must be between -180 and 180 and '\
                'latitude must be betwen -90 and 90', True)

GEOM_OUT_OF_BOUNDS = (11, 'Geometry must be in a neighborhood', True)

EXCL_ZONE = (12, 'Geometry may not be in an exclusion zone', True)

INVALID_SPECIES = (20, 'Could not find matching species', True)

INVALID_OTM_ID = (30, 'The given Open Tree Map ID does not exist '\
                  'in the system. This ID is automatically generated '\
                  'by Open Tree Map and should only be used for '\
                  'updating existing records', True)

FLOAT_ERROR = (40, 'Not formatted as a number', True)
POS_FLOAT_ERROR = (41, 'Not formatted as a positive number', True)
INT_ERROR = (42, 'Not formatted as an integer', True)
POS_INT_ERROR = (43, 'Not formatted as a positive integer', True)
BOOL_ERROR = (44, 'Not formatted as a boolean', True)
STRING_TOO_LONG = (45, 'Strings must be less than 255 characters', True)
INVALID_DATE = (46, 'Invalid date (must by YYYY-MM-DD', True)

INVALID_CHOICE = (50, 'These fields must contain a choice value', True)

INVALID_ITREE_CODE = (60, "iTree doesn't exist", True)
MISSING_ITREE_CODE = (61, 'iTree code is missing', True)

TOO_MANY_SPECIES = (70, 'More than one species was matched by this row', False)
MERGE_REQ = (71, 'This row must be merged', False)

NEARBY_TREES = (1050, 'There are already trees very close to this one', False)

SPECIES_DBH_TOO_HIGH = (1060,
                        'The diameter is too large for this species',
                        False)

SPECIES_HEIGHT_TOO_HIGH = (1061,
                           'The height is too large for this species',
                           False)

########NEW FILE########
__FILENAME__ = fields
class species(object):
    GENUS = 'genus'
    SPECIES = 'species'
    CULTIVAR = 'cultivar'
    OTHER_PART_OF_NAME = 'other part of scientific name'
    COMMON_NAME = 'common name'
    USDA_SYMBOL = 'usda symbol'
    ALT_SYMBOL = 'alternative symbol'
    ITREE_CODE = 'i-tree code'

    # This is a pseudo field which is filled in
    # when a matching species is found, but before
    # a commit is made. It is a list of all species
    # that somehow match this one (usda, sci name)
    ORIG_SPECIES = 'calc__species'

    # This is a pseudo field which is filled in
    # when a matching itree code is found
    RESOURCE = 'calc__resource'

    FAMILY = 'family'
    NATIVE_STATUS = 'native status'
    FALL_COLORS = 'fall colors'
    EDIBLE = 'palatable human'
    FLOWERING = 'flowering'
    FLOWERING_PERIOD = 'flowering period'
    FRUIT_PERIOD = 'fruit or nut period'
    WILDLIFE = 'wildlife'
    MAX_DIAMETER = 'max diameter at breast height'
    MAX_HEIGHT = 'max height'
    FACT_SHEET = 'fact sheet'
    TREE_COUNT = 'number of trees in database'
    ID = 'database id of species'
    SCIENTIFIC_NAME = 'scientific name'


    CHOICE_MAP = {
        FLOWERING_PERIOD: 'seasons',
        FRUIT_PERIOD: 'seasons'
    }

    DATE_FIELDS = set()

    STRING_FIELDS = { GENUS, SPECIES, CULTIVAR, OTHER_PART_OF_NAME, COMMON_NAME,
                      USDA_SYMBOL, ALT_SYMBOL, ITREE_CODE, FAMILY,
                      FACT_SHEET}

    POS_FLOAT_FIELDS = { MAX_DIAMETER, MAX_HEIGHT }

    FLOAT_FIELDS = set()

    POS_INT_FIELDS = set()

    BOOLEAN_FIELDS = { NATIVE_STATUS, FALL_COLORS, EDIBLE,
                       FLOWERING, WILDLIFE }

    ALL = DATE_FIELDS | STRING_FIELDS | POS_FLOAT_FIELDS | \
          FLOAT_FIELDS | POS_INT_FIELDS | BOOLEAN_FIELDS | \
          set(CHOICE_MAP.keys())

    PLOT_CHOICES = set()

class trees(object):
    # X/Y are required
    POINT_X = 'point x'
    POINT_Y = 'point y'

    # This is a pseudo field which is filled in
    # when data is cleaned and contains a GEOS
    # point object
    POINT = 'calc__point'

    # This is a pseudo field which is filled in
    # when data is cleaned and may contain a
    # OTM Species object, if the species was
    # matched
    SPECIES_OBJECT = 'calc__species_object'

    # Plot Fields
    ADDRESS = 'address'
    PLOT_WIDTH = 'plot width'
    PLOT_LENGTH = 'plot length'

    READ_ONLY = 'read only'
    OPENTREEMAP_ID_NUMBER = 'opentreemap id number'
    ORIG_ID_NUMBER = 'original id number'

    TREE_PRESENT = 'tree present'

    # Choice fields
    PLOT_TYPE = 'plot type'
    POWERLINE_CONFLICT = 'powerline conflict'
    SIDEWALK = 'sidewalk'

    # Tree Fields
    GENUS = 'genus'
    SPECIES = 'species'
    CULTIVAR = 'cultivar'
    OTHER_PART_OF_NAME = 'other part of scientific name'
    DIAMETER = 'diameter'
    TREE_HEIGHT = 'tree height'
    CANOPY_HEIGHT = 'canopy height'
    DATE_PLANTED = 'date planted'
    DATA_SOURCE = 'data source'
    OWNER = 'tree owner'
    SPONSOR = 'tree sponsor'
    STEWARD = 'tree steward'
    NOTES = 'notes'
    URL = 'tree url'

    # Choice Fields
    TREE_CONDITION = 'condition'
    CANOPY_CONDITION = 'canopy condition'
    ACTIONS = 'actions'
    PESTS = 'pests and diseases'
    LOCAL_PROJECTS = 'local projects'

    # Some plot choice fields aren't automatically
    # converting to choice values. This set determine
    # which are pre-converted
    PLOT_CHOICES = {
        PLOT_TYPE,
        SIDEWALK,
        POWERLINE_CONFLICT
    }

    CHOICE_MAP = {
        PLOT_TYPE: 'plot_types',
        POWERLINE_CONFLICT: 'powerlines',
        SIDEWALK: 'sidewalks',
        TREE_CONDITION: 'conditions',
        CANOPY_CONDITION: 'canopy_conditions',
        ACTIONS: 'actions',
        PESTS: 'pests',
        LOCAL_PROJECTS: 'projects'
    }

    DATE_FIELDS = { DATE_PLANTED }

    STRING_FIELDS = { ADDRESS, GENUS, SPECIES,
                      CULTIVAR, OTHER_PART_OF_NAME, URL,
                      NOTES, OWNER, SPONSOR,
                      STEWARD, DATA_SOURCE,
                      LOCAL_PROJECTS, NOTES, ORIG_ID_NUMBER }

    POS_FLOAT_FIELDS = { PLOT_WIDTH, PLOT_LENGTH,
                         DIAMETER, TREE_HEIGHT,
                         CANOPY_HEIGHT }

    FLOAT_FIELDS = { POINT_X, POINT_Y }

    POS_INT_FIELDS = { OPENTREEMAP_ID_NUMBER }

    BOOLEAN_FIELDS = { READ_ONLY, TREE_PRESENT }

    ALL = { POINT_X, POINT_Y, ADDRESS, PLOT_WIDTH,
            PLOT_LENGTH, READ_ONLY, OPENTREEMAP_ID_NUMBER,
            TREE_PRESENT, PLOT_TYPE, POWERLINE_CONFLICT,
            SIDEWALK, GENUS, SPECIES, CULTIVAR,
            OTHER_PART_OF_NAME, DIAMETER, ORIG_ID_NUMBER,
            CANOPY_HEIGHT, DATE_PLANTED, TREE_CONDITION,
            CANOPY_CONDITION, ACTIONS, PESTS,
            LOCAL_PROJECTS, URL, NOTES, OWNER,
            SPONSOR, STEWARD, DATA_SOURCE, TREE_HEIGHT }

########NEW FILE########
__FILENAME__ = 0001_initial
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'SpeciesImportEvent'
        db.create_table('importer_speciesimportevent', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('file_name', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('errors', self.gf('django.db.models.fields.TextField')(default='')),
            ('owner', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'])),
            ('created', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('completed', self.gf('django.db.models.fields.DateTimeField')(null=True, blank=True)),
            ('commited', self.gf('django.db.models.fields.BooleanField')(default=False)),
        ))
        db.send_create_signal('importer', ['SpeciesImportEvent'])

        # Adding model 'TreeImportEvent'
        db.create_table('importer_treeimportevent', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('file_name', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('errors', self.gf('django.db.models.fields.TextField')(default='')),
            ('owner', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'])),
            ('created', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('completed', self.gf('django.db.models.fields.DateTimeField')(null=True, blank=True)),
            ('commited', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('plot_length_conversion_factor', self.gf('django.db.models.fields.FloatField')(default=1.0)),
            ('plot_width_conversion_factor', self.gf('django.db.models.fields.FloatField')(default=1.0)),
            ('diameter_conversion_factor', self.gf('django.db.models.fields.FloatField')(default=1.0)),
            ('tree_height_conversion_factor', self.gf('django.db.models.fields.FloatField')(default=1.0)),
            ('canopy_height_conversion_factor', self.gf('django.db.models.fields.FloatField')(default=1.0)),
        ))
        db.send_create_signal('importer', ['TreeImportEvent'])

        # Adding model 'SpeciesImportRow'
        db.create_table('importer_speciesimportrow', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('data', self.gf('django.db.models.fields.TextField')()),
            ('idx', self.gf('django.db.models.fields.IntegerField')()),
            ('finished', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('errors', self.gf('django.db.models.fields.TextField')(default='')),
            ('status', self.gf('django.db.models.fields.IntegerField')(default=3)),
            ('species', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['treemap.Species'], null=True, blank=True)),
            ('import_event', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['importer.SpeciesImportEvent'])),
        ))
        db.send_create_signal('importer', ['SpeciesImportRow'])

        # Adding model 'TreeImportRow'
        db.create_table('importer_treeimportrow', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('data', self.gf('django.db.models.fields.TextField')()),
            ('idx', self.gf('django.db.models.fields.IntegerField')()),
            ('finished', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('errors', self.gf('django.db.models.fields.TextField')(default='')),
            ('status', self.gf('django.db.models.fields.IntegerField')(default=3)),
            ('plot', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['treemap.Plot'], null=True, blank=True)),
            ('import_event', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['importer.TreeImportEvent'])),
        ))
        db.send_create_signal('importer', ['TreeImportRow'])


    def backwards(self, orm):
        # Deleting model 'SpeciesImportEvent'
        db.delete_table('importer_speciesimportevent')

        # Deleting model 'TreeImportEvent'
        db.delete_table('importer_treeimportevent')

        # Deleting model 'SpeciesImportRow'
        db.delete_table('importer_speciesimportrow')

        # Deleting model 'TreeImportRow'
        db.delete_table('importer_treeimportrow')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'importer.speciesimportevent': {
            'Meta': {'object_name': 'SpeciesImportEvent'},
            'commited': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'completed': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'errors': ('django.db.models.fields.TextField', [], {'default': "''"}),
            'file_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'owner': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'importer.speciesimportrow': {
            'Meta': {'object_name': 'SpeciesImportRow'},
            'data': ('django.db.models.fields.TextField', [], {}),
            'errors': ('django.db.models.fields.TextField', [], {'default': "''"}),
            'finished': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'idx': ('django.db.models.fields.IntegerField', [], {}),
            'import_event': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['importer.SpeciesImportEvent']"}),
            'species': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Species']", 'null': 'True', 'blank': 'True'}),
            'status': ('django.db.models.fields.IntegerField', [], {'default': '3'})
        },
        'importer.treeimportevent': {
            'Meta': {'object_name': 'TreeImportEvent'},
            'canopy_height_conversion_factor': ('django.db.models.fields.FloatField', [], {'default': '1.0'}),
            'commited': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'completed': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'diameter_conversion_factor': ('django.db.models.fields.FloatField', [], {'default': '1.0'}),
            'errors': ('django.db.models.fields.TextField', [], {'default': "''"}),
            'file_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'owner': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'plot_length_conversion_factor': ('django.db.models.fields.FloatField', [], {'default': '1.0'}),
            'plot_width_conversion_factor': ('django.db.models.fields.FloatField', [], {'default': '1.0'}),
            'tree_height_conversion_factor': ('django.db.models.fields.FloatField', [], {'default': '1.0'})
        },
        'importer.treeimportrow': {
            'Meta': {'object_name': 'TreeImportRow'},
            'data': ('django.db.models.fields.TextField', [], {}),
            'errors': ('django.db.models.fields.TextField', [], {'default': "''"}),
            'finished': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'idx': ('django.db.models.fields.IntegerField', [], {}),
            'import_event': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['importer.TreeImportEvent']"}),
            'plot': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Plot']", 'null': 'True', 'blank': 'True'}),
            'status': ('django.db.models.fields.IntegerField', [], {'default': '3'})
        },
        'treemap.importevent': {
            'Meta': {'object_name': 'ImportEvent'},
            'file_name': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'import_date': ('django.db.models.fields.DateField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        'treemap.neighborhood': {
            'Meta': {'object_name': 'Neighborhood'},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'county': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'geometry': ('django.contrib.gis.db.models.fields.MultiPolygonField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'region_id': ('django.db.models.fields.IntegerField', [], {}),
            'state': ('django.db.models.fields.CharField', [], {'max_length': '2'})
        },
        'treemap.plot': {
            'Meta': {'object_name': 'Plot'},
            'address_city': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'address_street': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'address_zip': ('django.db.models.fields.CharField', [], {'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'data_owner': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'owner'", 'null': 'True', 'to': "orm['auth.User']"}),
            'geocoded_accuracy': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'geocoded_address': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'geocoded_lat': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'geocoded_lon': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'geometry': ('django.contrib.gis.db.models.fields.PointField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'import_event': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.ImportEvent']"}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'last_updated_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'plot_updated_by'", 'to': "orm['auth.User']"}),
            'length': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'neighborhood': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['treemap.Neighborhood']", 'null': 'True', 'symmetrical': 'False'}),
            'neighborhoods': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'owner_additional_id': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'owner_additional_properties': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'owner_orig_id': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'powerline_conflict_potential': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'present': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'readonly': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'sidewalk_damage': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'type': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'width': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'zipcode': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.ZipCode']", 'null': 'True', 'blank': 'True'})
        },
        'treemap.resource': {
            'Meta': {'object_name': 'Resource'},
            'aq_nox_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_nox_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_ozone_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_pm10_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_pm10_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_sox_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_sox_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_voc_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'bvoc_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_sequestered_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_storage_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'electricity_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'hydro_interception_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'meta_species': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'natural_gas_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'region': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'})
        },
        'treemap.species': {
            'Meta': {'object_name': 'Species'},
            'alternate_symbol': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'bloom_period': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'common_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'cultivar_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'fact_sheet': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'fall_conspicuous': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'flower_conspicuous': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'fruit_period': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'gender': ('django.db.models.fields.CharField', [], {'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'genus': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'itree_code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'native_status': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'palatable_human': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'plant_guide': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'resource': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['treemap.Resource']", 'null': 'True', 'symmetrical': 'False'}),
            'scientific_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'species': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'symbol': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'tree_count': ('django.db.models.fields.IntegerField', [], {'default': '0', 'db_index': 'True'}),
            'v_max_dbh': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'v_max_height': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'v_multiple_trunks': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'wildlife_value': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'})
        },
        'treemap.zipcode': {
            'Meta': {'object_name': 'ZipCode'},
            'geometry': ('django.contrib.gis.db.models.fields.MultiPolygonField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'zip': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        }
    }

    complete_apps = ['importer']
########NEW FILE########
__FILENAME__ = 0002_auto__add_field_speciesimportrow_merged
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding field 'SpeciesImportRow.merged'
        db.add_column('importer_speciesimportrow', 'merged',
                      self.gf('django.db.models.fields.BooleanField')(default=False),
                      keep_default=False)


    def backwards(self, orm):
        # Deleting field 'SpeciesImportRow.merged'
        db.delete_column('importer_speciesimportrow', 'merged')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'importer.speciesimportevent': {
            'Meta': {'object_name': 'SpeciesImportEvent'},
            'commited': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'completed': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'errors': ('django.db.models.fields.TextField', [], {'default': "''"}),
            'file_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'owner': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'importer.speciesimportrow': {
            'Meta': {'object_name': 'SpeciesImportRow'},
            'data': ('django.db.models.fields.TextField', [], {}),
            'errors': ('django.db.models.fields.TextField', [], {'default': "''"}),
            'finished': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'idx': ('django.db.models.fields.IntegerField', [], {}),
            'import_event': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['importer.SpeciesImportEvent']"}),
            'merged': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'species': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Species']", 'null': 'True', 'blank': 'True'}),
            'status': ('django.db.models.fields.IntegerField', [], {'default': '3'})
        },
        'importer.treeimportevent': {
            'Meta': {'object_name': 'TreeImportEvent'},
            'canopy_height_conversion_factor': ('django.db.models.fields.FloatField', [], {'default': '1.0'}),
            'commited': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'completed': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'diameter_conversion_factor': ('django.db.models.fields.FloatField', [], {'default': '1.0'}),
            'errors': ('django.db.models.fields.TextField', [], {'default': "''"}),
            'file_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'owner': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'plot_length_conversion_factor': ('django.db.models.fields.FloatField', [], {'default': '1.0'}),
            'plot_width_conversion_factor': ('django.db.models.fields.FloatField', [], {'default': '1.0'}),
            'tree_height_conversion_factor': ('django.db.models.fields.FloatField', [], {'default': '1.0'})
        },
        'importer.treeimportrow': {
            'Meta': {'object_name': 'TreeImportRow'},
            'data': ('django.db.models.fields.TextField', [], {}),
            'errors': ('django.db.models.fields.TextField', [], {'default': "''"}),
            'finished': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'idx': ('django.db.models.fields.IntegerField', [], {}),
            'import_event': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['importer.TreeImportEvent']"}),
            'plot': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Plot']", 'null': 'True', 'blank': 'True'}),
            'status': ('django.db.models.fields.IntegerField', [], {'default': '3'})
        },
        'treemap.importevent': {
            'Meta': {'object_name': 'ImportEvent'},
            'file_name': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'import_date': ('django.db.models.fields.DateField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        'treemap.neighborhood': {
            'Meta': {'object_name': 'Neighborhood'},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'county': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'geometry': ('django.contrib.gis.db.models.fields.MultiPolygonField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'region_id': ('django.db.models.fields.IntegerField', [], {}),
            'state': ('django.db.models.fields.CharField', [], {'max_length': '2'})
        },
        'treemap.plot': {
            'Meta': {'object_name': 'Plot'},
            'address_city': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'address_street': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'address_zip': ('django.db.models.fields.CharField', [], {'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'data_owner': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'owner'", 'null': 'True', 'to': "orm['auth.User']"}),
            'geocoded_accuracy': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'geocoded_address': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'geocoded_lat': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'geocoded_lon': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'geometry': ('django.contrib.gis.db.models.fields.PointField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'import_event': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.ImportEvent']"}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'last_updated_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'plot_updated_by'", 'to': "orm['auth.User']"}),
            'length': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'neighborhood': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['treemap.Neighborhood']", 'null': 'True', 'symmetrical': 'False'}),
            'neighborhoods': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'owner_additional_id': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'owner_additional_properties': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'owner_orig_id': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'powerline_conflict_potential': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'present': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'readonly': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'sidewalk_damage': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'type': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'width': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'zipcode': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.ZipCode']", 'null': 'True', 'blank': 'True'})
        },
        'treemap.resource': {
            'Meta': {'object_name': 'Resource'},
            'aq_nox_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_nox_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_ozone_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_pm10_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_pm10_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_sox_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_sox_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_voc_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'bvoc_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_sequestered_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_storage_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'electricity_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'hydro_interception_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'meta_species': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'natural_gas_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'region': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'})
        },
        'treemap.species': {
            'Meta': {'object_name': 'Species'},
            'alternate_symbol': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'bloom_period': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'common_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'cultivar_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'fact_sheet': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'fall_conspicuous': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'flower_conspicuous': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'fruit_period': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'gender': ('django.db.models.fields.CharField', [], {'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'genus': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'itree_code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'native_status': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'palatable_human': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'plant_guide': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'resource': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['treemap.Resource']", 'null': 'True', 'symmetrical': 'False'}),
            'scientific_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'species': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'symbol': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'tree_count': ('django.db.models.fields.IntegerField', [], {'default': '0', 'db_index': 'True'}),
            'v_max_dbh': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'v_max_height': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'v_multiple_trunks': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'wildlife_value': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'})
        },
        'treemap.zipcode': {
            'Meta': {'object_name': 'ZipCode'},
            'geometry': ('django.contrib.gis.db.models.fields.MultiPolygonField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'zip': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        }
    }

    complete_apps = ['importer']
########NEW FILE########
__FILENAME__ = 0003_auto__add_field_speciesimportevent_status__add_field_treeimportevent_s
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding field 'SpeciesImportEvent.status'
        db.add_column('importer_speciesimportevent', 'status',
                      self.gf('django.db.models.fields.IntegerField')(default=1),
                      keep_default=False)

        # Adding field 'TreeImportEvent.status'
        db.add_column('importer_treeimportevent', 'status',
                      self.gf('django.db.models.fields.IntegerField')(default=1),
                      keep_default=False)


    def backwards(self, orm):
        # Deleting field 'SpeciesImportEvent.status'
        db.delete_column('importer_speciesimportevent', 'status')

        # Deleting field 'TreeImportEvent.status'
        db.delete_column('importer_treeimportevent', 'status')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'importer.speciesimportevent': {
            'Meta': {'object_name': 'SpeciesImportEvent'},
            'commited': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'completed': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'errors': ('django.db.models.fields.TextField', [], {'default': "''"}),
            'file_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'owner': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'status': ('django.db.models.fields.IntegerField', [], {'default': '1'})
        },
        'importer.speciesimportrow': {
            'Meta': {'object_name': 'SpeciesImportRow'},
            'data': ('django.db.models.fields.TextField', [], {}),
            'errors': ('django.db.models.fields.TextField', [], {'default': "''"}),
            'finished': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'idx': ('django.db.models.fields.IntegerField', [], {}),
            'import_event': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['importer.SpeciesImportEvent']"}),
            'merged': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'species': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Species']", 'null': 'True', 'blank': 'True'}),
            'status': ('django.db.models.fields.IntegerField', [], {'default': '3'})
        },
        'importer.treeimportevent': {
            'Meta': {'object_name': 'TreeImportEvent'},
            'canopy_height_conversion_factor': ('django.db.models.fields.FloatField', [], {'default': '1.0'}),
            'commited': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'completed': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'diameter_conversion_factor': ('django.db.models.fields.FloatField', [], {'default': '1.0'}),
            'errors': ('django.db.models.fields.TextField', [], {'default': "''"}),
            'file_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'owner': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'plot_length_conversion_factor': ('django.db.models.fields.FloatField', [], {'default': '1.0'}),
            'plot_width_conversion_factor': ('django.db.models.fields.FloatField', [], {'default': '1.0'}),
            'status': ('django.db.models.fields.IntegerField', [], {'default': '1'}),
            'tree_height_conversion_factor': ('django.db.models.fields.FloatField', [], {'default': '1.0'})
        },
        'importer.treeimportrow': {
            'Meta': {'object_name': 'TreeImportRow'},
            'data': ('django.db.models.fields.TextField', [], {}),
            'errors': ('django.db.models.fields.TextField', [], {'default': "''"}),
            'finished': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'idx': ('django.db.models.fields.IntegerField', [], {}),
            'import_event': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['importer.TreeImportEvent']"}),
            'plot': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Plot']", 'null': 'True', 'blank': 'True'}),
            'status': ('django.db.models.fields.IntegerField', [], {'default': '3'})
        },
        'treemap.importevent': {
            'Meta': {'object_name': 'ImportEvent'},
            'file_name': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'import_date': ('django.db.models.fields.DateField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        'treemap.neighborhood': {
            'Meta': {'object_name': 'Neighborhood'},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'county': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'geometry': ('django.contrib.gis.db.models.fields.MultiPolygonField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'region_id': ('django.db.models.fields.IntegerField', [], {}),
            'state': ('django.db.models.fields.CharField', [], {'max_length': '2'})
        },
        'treemap.plot': {
            'Meta': {'object_name': 'Plot'},
            'address_city': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'address_street': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'address_zip': ('django.db.models.fields.CharField', [], {'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'data_owner': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'owner'", 'null': 'True', 'to': "orm['auth.User']"}),
            'geocoded_accuracy': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'geocoded_address': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'geocoded_lat': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'geocoded_lon': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'geometry': ('django.contrib.gis.db.models.fields.PointField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'import_event': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.ImportEvent']"}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'last_updated_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'plot_updated_by'", 'to': "orm['auth.User']"}),
            'length': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'neighborhood': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['treemap.Neighborhood']", 'null': 'True', 'symmetrical': 'False'}),
            'neighborhoods': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'owner_additional_id': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'owner_additional_properties': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'owner_orig_id': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'powerline_conflict_potential': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'present': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'readonly': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'sidewalk_damage': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'type': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'width': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'zipcode': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.ZipCode']", 'null': 'True', 'blank': 'True'})
        },
        'treemap.resource': {
            'Meta': {'object_name': 'Resource'},
            'aq_nox_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_nox_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_ozone_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_pm10_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_pm10_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_sox_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_sox_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_voc_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'bvoc_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_sequestered_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_storage_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'electricity_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'hydro_interception_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'meta_species': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'natural_gas_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'region': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'})
        },
        'treemap.species': {
            'Meta': {'object_name': 'Species'},
            'alternate_symbol': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'bloom_period': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'common_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'cultivar_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'fact_sheet': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'fall_conspicuous': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'flower_conspicuous': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'fruit_period': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'gender': ('django.db.models.fields.CharField', [], {'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'genus': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'itree_code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'native_status': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'palatable_human': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'plant_guide': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'resource': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['treemap.Resource']", 'null': 'True', 'symmetrical': 'False'}),
            'scientific_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'species': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'symbol': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'tree_count': ('django.db.models.fields.IntegerField', [], {'default': '0', 'db_index': 'True'}),
            'v_max_dbh': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'v_max_height': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'v_multiple_trunks': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'wildlife_value': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'})
        },
        'treemap.zipcode': {
            'Meta': {'object_name': 'ZipCode'},
            'geometry': ('django.contrib.gis.db.models.fields.MultiPolygonField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'zip': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        }
    }

    complete_apps = ['importer']
########NEW FILE########
__FILENAME__ = 0004_auto__add_field_treeimportevent_base_import_event
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding field 'TreeImportEvent.base_import_event'
        db.add_column('importer_treeimportevent', 'base_import_event',
                      self.gf('django.db.models.fields.related.ForeignKey')(default=1, to=orm['treemap.ImportEvent']),
                      keep_default=False)


    def backwards(self, orm):
        # Deleting field 'TreeImportEvent.base_import_event'
        db.delete_column('importer_treeimportevent', 'base_import_event_id')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'importer.speciesimportevent': {
            'Meta': {'object_name': 'SpeciesImportEvent'},
            'commited': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'completed': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'errors': ('django.db.models.fields.TextField', [], {'default': "''"}),
            'file_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'owner': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'status': ('django.db.models.fields.IntegerField', [], {'default': '1'})
        },
        'importer.speciesimportrow': {
            'Meta': {'object_name': 'SpeciesImportRow'},
            'data': ('django.db.models.fields.TextField', [], {}),
            'errors': ('django.db.models.fields.TextField', [], {'default': "''"}),
            'finished': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'idx': ('django.db.models.fields.IntegerField', [], {}),
            'import_event': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['importer.SpeciesImportEvent']"}),
            'merged': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'species': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Species']", 'null': 'True', 'blank': 'True'}),
            'status': ('django.db.models.fields.IntegerField', [], {'default': '3'})
        },
        'importer.treeimportevent': {
            'Meta': {'object_name': 'TreeImportEvent'},
            'base_import_event': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.ImportEvent']"}),
            'canopy_height_conversion_factor': ('django.db.models.fields.FloatField', [], {'default': '1.0'}),
            'commited': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'completed': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'diameter_conversion_factor': ('django.db.models.fields.FloatField', [], {'default': '1.0'}),
            'errors': ('django.db.models.fields.TextField', [], {'default': "''"}),
            'file_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'owner': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'plot_length_conversion_factor': ('django.db.models.fields.FloatField', [], {'default': '1.0'}),
            'plot_width_conversion_factor': ('django.db.models.fields.FloatField', [], {'default': '1.0'}),
            'status': ('django.db.models.fields.IntegerField', [], {'default': '1'}),
            'tree_height_conversion_factor': ('django.db.models.fields.FloatField', [], {'default': '1.0'})
        },
        'importer.treeimportrow': {
            'Meta': {'object_name': 'TreeImportRow'},
            'data': ('django.db.models.fields.TextField', [], {}),
            'errors': ('django.db.models.fields.TextField', [], {'default': "''"}),
            'finished': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'idx': ('django.db.models.fields.IntegerField', [], {}),
            'import_event': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['importer.TreeImportEvent']"}),
            'plot': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Plot']", 'null': 'True', 'blank': 'True'}),
            'status': ('django.db.models.fields.IntegerField', [], {'default': '3'})
        },
        'treemap.importevent': {
            'Meta': {'object_name': 'ImportEvent'},
            'file_name': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'import_date': ('django.db.models.fields.DateField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        'treemap.neighborhood': {
            'Meta': {'object_name': 'Neighborhood'},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'county': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'geometry': ('django.contrib.gis.db.models.fields.MultiPolygonField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'region_id': ('django.db.models.fields.IntegerField', [], {}),
            'state': ('django.db.models.fields.CharField', [], {'max_length': '2'})
        },
        'treemap.plot': {
            'Meta': {'object_name': 'Plot'},
            'address_city': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'address_street': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'address_zip': ('django.db.models.fields.CharField', [], {'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'data_owner': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'owner'", 'null': 'True', 'to': "orm['auth.User']"}),
            'geocoded_accuracy': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'geocoded_address': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'geocoded_lat': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'geocoded_lon': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'geometry': ('django.contrib.gis.db.models.fields.PointField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'import_event': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.ImportEvent']"}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'last_updated_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'plot_updated_by'", 'to': "orm['auth.User']"}),
            'length': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'neighborhood': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['treemap.Neighborhood']", 'null': 'True', 'symmetrical': 'False'}),
            'neighborhoods': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'owner_additional_id': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'owner_additional_properties': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'owner_orig_id': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'powerline_conflict_potential': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'present': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'readonly': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'sidewalk_damage': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'type': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'width': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'zipcode': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.ZipCode']", 'null': 'True', 'blank': 'True'})
        },
        'treemap.resource': {
            'Meta': {'object_name': 'Resource'},
            'aq_nox_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_nox_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_ozone_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_pm10_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_pm10_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_sox_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_sox_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_voc_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'bvoc_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_sequestered_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_storage_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'electricity_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'hydro_interception_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'meta_species': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'natural_gas_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'region': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'})
        },
        'treemap.species': {
            'Meta': {'object_name': 'Species'},
            'alternate_symbol': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'bloom_period': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'common_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'cultivar_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'fact_sheet': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'fall_conspicuous': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'family': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'flower_conspicuous': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'fruit_period': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'gender': ('django.db.models.fields.CharField', [], {'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'genus': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'itree_code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'native_status': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'other_part_of_name': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'palatable_human': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'plant_guide': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'resource': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['treemap.Resource']", 'null': 'True', 'symmetrical': 'False'}),
            'scientific_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'species': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'symbol': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'tree_count': ('django.db.models.fields.IntegerField', [], {'default': '0', 'db_index': 'True'}),
            'v_max_dbh': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'v_max_height': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'v_multiple_trunks': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'wildlife_value': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'})
        },
        'treemap.zipcode': {
            'Meta': {'object_name': 'ZipCode'},
            'geometry': ('django.contrib.gis.db.models.fields.MultiPolygonField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'zip': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        }
    }

    complete_apps = ['importer']
########NEW FILE########
__FILENAME__ = 0005_auto__add_field_speciesimportevent_field_order__add_field_treeimportev
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding field 'SpeciesImportEvent.field_order'
        db.add_column('importer_speciesimportevent', 'field_order',
                      self.gf('django.db.models.fields.TextField')(default=''),
                      keep_default=False)

        # Adding field 'TreeImportEvent.field_order'
        db.add_column('importer_treeimportevent', 'field_order',
                      self.gf('django.db.models.fields.TextField')(default=''),
                      keep_default=False)


    def backwards(self, orm):
        # Deleting field 'SpeciesImportEvent.field_order'
        db.delete_column('importer_speciesimportevent', 'field_order')

        # Deleting field 'TreeImportEvent.field_order'
        db.delete_column('importer_treeimportevent', 'field_order')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'importer.speciesimportevent': {
            'Meta': {'object_name': 'SpeciesImportEvent'},
            'commited': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'completed': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'errors': ('django.db.models.fields.TextField', [], {'default': "''"}),
            'field_order': ('django.db.models.fields.TextField', [], {'default': "''"}),
            'file_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'owner': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'status': ('django.db.models.fields.IntegerField', [], {'default': '1'})
        },
        'importer.speciesimportrow': {
            'Meta': {'object_name': 'SpeciesImportRow'},
            'data': ('django.db.models.fields.TextField', [], {}),
            'errors': ('django.db.models.fields.TextField', [], {'default': "''"}),
            'finished': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'idx': ('django.db.models.fields.IntegerField', [], {}),
            'import_event': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['importer.SpeciesImportEvent']"}),
            'merged': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'species': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Species']", 'null': 'True', 'blank': 'True'}),
            'status': ('django.db.models.fields.IntegerField', [], {'default': '3'})
        },
        'importer.treeimportevent': {
            'Meta': {'object_name': 'TreeImportEvent'},
            'base_import_event': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.ImportEvent']"}),
            'canopy_height_conversion_factor': ('django.db.models.fields.FloatField', [], {'default': '1.0'}),
            'commited': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'completed': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'diameter_conversion_factor': ('django.db.models.fields.FloatField', [], {'default': '1.0'}),
            'errors': ('django.db.models.fields.TextField', [], {'default': "''"}),
            'field_order': ('django.db.models.fields.TextField', [], {'default': "''"}),
            'file_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'owner': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'plot_length_conversion_factor': ('django.db.models.fields.FloatField', [], {'default': '1.0'}),
            'plot_width_conversion_factor': ('django.db.models.fields.FloatField', [], {'default': '1.0'}),
            'status': ('django.db.models.fields.IntegerField', [], {'default': '1'}),
            'tree_height_conversion_factor': ('django.db.models.fields.FloatField', [], {'default': '1.0'})
        },
        'importer.treeimportrow': {
            'Meta': {'object_name': 'TreeImportRow'},
            'data': ('django.db.models.fields.TextField', [], {}),
            'errors': ('django.db.models.fields.TextField', [], {'default': "''"}),
            'finished': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'idx': ('django.db.models.fields.IntegerField', [], {}),
            'import_event': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['importer.TreeImportEvent']"}),
            'plot': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Plot']", 'null': 'True', 'blank': 'True'}),
            'status': ('django.db.models.fields.IntegerField', [], {'default': '3'})
        },
        'treemap.importevent': {
            'Meta': {'object_name': 'ImportEvent'},
            'file_name': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'import_date': ('django.db.models.fields.DateField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        'treemap.neighborhood': {
            'Meta': {'object_name': 'Neighborhood'},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'county': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'geometry': ('django.contrib.gis.db.models.fields.MultiPolygonField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'region_id': ('django.db.models.fields.IntegerField', [], {}),
            'state': ('django.db.models.fields.CharField', [], {'max_length': '2'})
        },
        'treemap.plot': {
            'Meta': {'object_name': 'Plot'},
            'address_city': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'address_street': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'address_zip': ('django.db.models.fields.CharField', [], {'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'data_owner': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'owner'", 'null': 'True', 'to': "orm['auth.User']"}),
            'geocoded_accuracy': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'geocoded_address': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'geocoded_lat': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'geocoded_lon': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'geometry': ('django.contrib.gis.db.models.fields.PointField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'import_event': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.ImportEvent']"}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'last_updated_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'plot_updated_by'", 'to': "orm['auth.User']"}),
            'length': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'neighborhood': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['treemap.Neighborhood']", 'null': 'True', 'symmetrical': 'False'}),
            'neighborhoods': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'owner_additional_id': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'owner_additional_properties': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'owner_orig_id': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'powerline_conflict_potential': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'present': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'readonly': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'sidewalk_damage': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'type': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'width': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'zipcode': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.ZipCode']", 'null': 'True', 'blank': 'True'})
        },
        'treemap.resource': {
            'Meta': {'object_name': 'Resource'},
            'aq_nox_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_nox_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_ozone_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_pm10_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_pm10_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_sox_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_sox_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_voc_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'bvoc_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_sequestered_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_storage_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'electricity_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'hydro_interception_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'meta_species': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'natural_gas_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'region': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'})
        },
        'treemap.species': {
            'Meta': {'object_name': 'Species'},
            'alternate_symbol': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'bloom_period': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'common_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'cultivar_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'fact_sheet': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'fall_conspicuous': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'family': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'flower_conspicuous': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'fruit_period': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'gender': ('django.db.models.fields.CharField', [], {'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'genus': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'itree_code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'native_status': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'other_part_of_name': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'palatable_human': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'plant_guide': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'resource': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['treemap.Resource']", 'null': 'True', 'symmetrical': 'False'}),
            'scientific_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'species': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'symbol': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'tree_count': ('django.db.models.fields.IntegerField', [], {'default': '0', 'db_index': 'True'}),
            'v_max_dbh': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'v_max_height': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'v_multiple_trunks': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'wildlife_value': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'})
        },
        'treemap.zipcode': {
            'Meta': {'object_name': 'ZipCode'},
            'geometry': ('django.contrib.gis.db.models.fields.MultiPolygonField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'zip': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        }
    }

    complete_apps = ['importer']
########NEW FILE########
__FILENAME__ = 0006_auto__add_field_speciesimportevent_max_diameter_conversion_factor__add
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding field 'SpeciesImportEvent.max_diameter_conversion_factor'
        db.add_column('importer_speciesimportevent', 'max_diameter_conversion_factor',
                      self.gf('django.db.models.fields.FloatField')(default=1.0),
                      keep_default=False)

        # Adding field 'SpeciesImportEvent.max_tree_height_conversion_factor'
        db.add_column('importer_speciesimportevent', 'max_tree_height_conversion_factor',
                      self.gf('django.db.models.fields.FloatField')(default=1.0),
                      keep_default=False)


    def backwards(self, orm):
        # Deleting field 'SpeciesImportEvent.max_diameter_conversion_factor'
        db.delete_column('importer_speciesimportevent', 'max_diameter_conversion_factor')

        # Deleting field 'SpeciesImportEvent.max_tree_height_conversion_factor'
        db.delete_column('importer_speciesimportevent', 'max_tree_height_conversion_factor')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'importer.speciesimportevent': {
            'Meta': {'object_name': 'SpeciesImportEvent'},
            'commited': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'completed': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'errors': ('django.db.models.fields.TextField', [], {'default': "''"}),
            'field_order': ('django.db.models.fields.TextField', [], {'default': "''"}),
            'file_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'max_diameter_conversion_factor': ('django.db.models.fields.FloatField', [], {'default': '1.0'}),
            'max_tree_height_conversion_factor': ('django.db.models.fields.FloatField', [], {'default': '1.0'}),
            'owner': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'status': ('django.db.models.fields.IntegerField', [], {'default': '1'})
        },
        'importer.speciesimportrow': {
            'Meta': {'object_name': 'SpeciesImportRow'},
            'data': ('django.db.models.fields.TextField', [], {}),
            'errors': ('django.db.models.fields.TextField', [], {'default': "''"}),
            'finished': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'idx': ('django.db.models.fields.IntegerField', [], {}),
            'import_event': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['importer.SpeciesImportEvent']"}),
            'merged': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'species': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Species']", 'null': 'True', 'blank': 'True'}),
            'status': ('django.db.models.fields.IntegerField', [], {'default': '3'})
        },
        'importer.treeimportevent': {
            'Meta': {'object_name': 'TreeImportEvent'},
            'base_import_event': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.ImportEvent']"}),
            'canopy_height_conversion_factor': ('django.db.models.fields.FloatField', [], {'default': '1.0'}),
            'commited': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'completed': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'diameter_conversion_factor': ('django.db.models.fields.FloatField', [], {'default': '1.0'}),
            'errors': ('django.db.models.fields.TextField', [], {'default': "''"}),
            'field_order': ('django.db.models.fields.TextField', [], {'default': "''"}),
            'file_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'owner': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'plot_length_conversion_factor': ('django.db.models.fields.FloatField', [], {'default': '1.0'}),
            'plot_width_conversion_factor': ('django.db.models.fields.FloatField', [], {'default': '1.0'}),
            'status': ('django.db.models.fields.IntegerField', [], {'default': '1'}),
            'tree_height_conversion_factor': ('django.db.models.fields.FloatField', [], {'default': '1.0'})
        },
        'importer.treeimportrow': {
            'Meta': {'object_name': 'TreeImportRow'},
            'data': ('django.db.models.fields.TextField', [], {}),
            'errors': ('django.db.models.fields.TextField', [], {'default': "''"}),
            'finished': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'idx': ('django.db.models.fields.IntegerField', [], {}),
            'import_event': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['importer.TreeImportEvent']"}),
            'plot': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Plot']", 'null': 'True', 'blank': 'True'}),
            'status': ('django.db.models.fields.IntegerField', [], {'default': '3'})
        },
        'treemap.importevent': {
            'Meta': {'object_name': 'ImportEvent'},
            'file_name': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'import_date': ('django.db.models.fields.DateField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        'treemap.neighborhood': {
            'Meta': {'object_name': 'Neighborhood'},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'county': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'geometry': ('django.contrib.gis.db.models.fields.MultiPolygonField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'region_id': ('django.db.models.fields.IntegerField', [], {}),
            'state': ('django.db.models.fields.CharField', [], {'max_length': '2'})
        },
        'treemap.plot': {
            'Meta': {'object_name': 'Plot'},
            'address_city': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'address_street': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'address_zip': ('django.db.models.fields.CharField', [], {'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'data_owner': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'owner'", 'null': 'True', 'to': "orm['auth.User']"}),
            'geocoded_accuracy': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'geocoded_address': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'geocoded_lat': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'geocoded_lon': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'geometry': ('django.contrib.gis.db.models.fields.PointField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'import_event': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.ImportEvent']"}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'last_updated_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'plot_updated_by'", 'to': "orm['auth.User']"}),
            'length': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'neighborhood': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['treemap.Neighborhood']", 'null': 'True', 'symmetrical': 'False'}),
            'neighborhoods': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'owner_additional_id': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'owner_additional_properties': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'owner_orig_id': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'powerline_conflict_potential': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'present': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'readonly': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'sidewalk_damage': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'type': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'width': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'zipcode': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.ZipCode']", 'null': 'True', 'blank': 'True'})
        },
        'treemap.resource': {
            'Meta': {'object_name': 'Resource'},
            'aq_nox_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_nox_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_ozone_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_pm10_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_pm10_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_sox_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_sox_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_voc_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'bvoc_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_sequestered_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_storage_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'electricity_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'hydro_interception_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'meta_species': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'natural_gas_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'region': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'})
        },
        'treemap.species': {
            'Meta': {'object_name': 'Species'},
            'alternate_symbol': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'bloom_period': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'common_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'cultivar_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'fact_sheet': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'fall_conspicuous': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'family': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'flower_conspicuous': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'fruit_period': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'gender': ('django.db.models.fields.CharField', [], {'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'genus': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'itree_code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'native_status': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'other_part_of_name': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'palatable_human': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'plant_guide': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'resource': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['treemap.Resource']", 'null': 'True', 'symmetrical': 'False'}),
            'scientific_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'species': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'symbol': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'tree_count': ('django.db.models.fields.IntegerField', [], {'default': '0', 'db_index': 'True'}),
            'v_max_dbh': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'v_max_height': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'v_multiple_trunks': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'wildlife_value': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'})
        },
        'treemap.zipcode': {
            'Meta': {'object_name': 'ZipCode'},
            'geometry': ('django.contrib.gis.db.models.fields.MultiPolygonField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'zip': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        }
    }

    complete_apps = ['importer']
########NEW FILE########
__FILENAME__ = models
from django.db.models import Count
from django.conf import settings

from django.contrib.gis.db import models
from django.contrib.auth.models import User
from django.contrib.gis.geos import Point
from django.contrib.gis.measure import D

from treemap.models import Plot, Resource
from importer import fields
from importer import errors

from datetime import datetime

from treemap.models import Species, Neighborhood, Plot,\
    Tree, ExclusionMask, ImportEvent

from eco import benefits

import json

class GenericImportEvent(models.Model):

    class Meta:
        abstract = True

    PENDING_VERIFICATION = 1
    VERIFIYING = 2
    FINISHED_VERIFICATION = 3
    CREATING = 4
    FINISHED_CREATING = 5
    FAILED_FILE_VERIFICATION = 6

    # Original Name of the file
    file_name = models.CharField(max_length=255)

    # Global errors and notices (json)
    errors = models.TextField(default='')

    field_order = models.TextField(default='')

    # Metadata about this particular import
    owner = models.ForeignKey(User)
    created = models.DateTimeField(auto_now=True)
    completed = models.DateTimeField(null=True,blank=True)

    status = models.IntegerField(default=PENDING_VERIFICATION)

    # When false, this dataset is in 'preview' mode
    # When true this dataset has been written to the
    # database
    commited = models.BooleanField(default=False)

    def status_summary(self):
        if self.status == GenericImportEvent.PENDING_VERIFICATION:
            return "Not Yet Started"
        elif self.status == GenericImportEvent.VERIFIYING:
            return "Verifying"
        elif self.status == GenericImportEvent.FINISHED_VERIFICATION:
            return "Verification Complete"
        elif self.status == GenericImportEvent.CREATING:
            return "Creating Trees"
        elif self.status == GenericImportEvent.FAILED_FILE_VERIFICATION:
            return "Invalid File Structure"
        else:
            return "Finished"

    def active(self):
        return self.status != GenericImportEvent.FINISHED_CREATING

    def row_type_counts(self):
        q = self.row_set()\
                .values('status')\
                .annotate(Count('status'))

        return { r['status']: r['status__count'] for r in q }

    def update_status(self):
        """ Update the status field based on current row statuses """
        pass

    def append_error(self, err, data=None):
        code, msg, fatal = err

        if self.errors is None or self.errors == '':
            self.errors = '[]'

        self.errors = json.dumps(
            self.errors_as_array()+ [
                {'code': code,
                 'msg': msg,
                 'data': data,
                 'fatal': fatal}])

        return self

    def errors_as_array(self):
        if self.errors is None or self.errors == '':
            return []
        else:
            return json.loads(self.errors)

    def has_errors(self):
        return len(self.errors_as_array()) > 0

    def row_set(self):
        raise Exception('Abstract Method')

    def rows(self):
        return self.row_set().order_by('idx').all()

    def validate_main_file(self):
        raise Exception('Abstract Method')

class SpeciesImportEvent(GenericImportEvent):
    """
    A TreeImportEvent represents an attempt to upload a csv containing
    species information
    """

    max_diameter_conversion_factor = models.FloatField(default=1.0)
    max_tree_height_conversion_factor = models.FloatField(default=1.0)

    def create_row(self, *args, **kwargs):
        return SpeciesImportRow.objects.create(*args, **kwargs)

    def row_set(self):
        return self.speciesimportrow_set

    def __unicode__(self):
        return u"Species Import #%s" % self.pk

    def status_summary(self):
        if self.status == GenericImportEvent.CREATING:
            return "Creating Species Records"
        else:
            return super(SpeciesImportEvent, self).status_summary()

    def validate_main_file(self):
        """
        Make sure the imported file has rows and valid columns
        """
        if self.rows().count() == 0:
            self.append_error(errors.EMPTY_FILE)

            # This is a fatal error. We need to have at least
            # one row to get header info
            self.status = GenericImportEvent.FAILED_FILE_VERIFICATION
            self.save()
            return False

        has_errors = False
        datastr = self.rows()[0].data
        input_fields = set(json.loads(datastr).keys())

        req = { fields.species.GENUS,
                fields.species.COMMON_NAME, fields.species.ITREE_CODE }

        req -= input_fields
        if req:
            has_errors = True
            self.append_error(errors.MISSING_SPECIES_FIELDS)

        # It is a warning if there are extra input fields
        rem = input_fields - fields.species.ALL
        if len(rem) > 0:
            has_errors = True
            self.append_error(errors.UNMATCHED_FIELDS, list(rem))

        if has_errors:
            self.status = GenericImportEvent.FAILED_FILE_VERIFICATION
            self.save()

        return not has_errors



class TreeImportEvent(GenericImportEvent):
    """
    A TreeImportEvent represents an attempt to upload a csv containing
    tree/plot information
    """

    base_import_event = models.ForeignKey(ImportEvent)

    plot_length_conversion_factor = models.FloatField(default=1.0)
    plot_width_conversion_factor = models.FloatField(default=1.0)
    diameter_conversion_factor = models.FloatField(default=1.0)
    tree_height_conversion_factor = models.FloatField(default=1.0)
    canopy_height_conversion_factor = models.FloatField(default=1.0)

    def create_row(self, *args, **kwargs):
        return TreeImportRow.objects.create(*args, **kwargs)

    def row_set(self):
        return self.treeimportrow_set

    def __unicode__(self):
        return u"Tree Import #%s" % self.pk

    def validate_main_file(self):
        """
        Make sure the imported file has rows and valid columns
        """
        if self.treeimportrow_set.count() == 0:
            self.append_error(errors.EMPTY_FILE)

            # This is a fatal error. We need to have at least
            # one row to get header info
            self.status = GenericImportEvent.FAILED_FILE_VERIFICATION
            self.save()
            return False

        has_errors = False
        datastr = self.treeimportrow_set.all()[0].data
        input_fields = set(json.loads(datastr).keys())

        # Point x/y fields are required
        if (fields.trees.POINT_X not in input_fields or
            fields.trees.POINT_Y not in input_fields):
            has_errors = True
            self.append_error(errors.MISSING_POINTS)

        # It is a warning if there are extra input fields
        rem = input_fields - fields.trees.ALL
        if len(rem) > 0:
            has_errors = True
            self.append_error(errors.UNMATCHED_FIELDS, list(rem))

        if has_errors:
            self.status = GenericImportEvent.FAILED_FILE_VERIFICATION
            self.save()

        return not has_errors




class GenericImportRow(models.Model):
    """
    A row of data and import status
    Subclassed by 'Tree Import Row' and 'Species Import Row'
    """

    class Meta:
        abstract = True

    # JSON dictionary from header <-> rows
    data = models.TextField()

    # Row index from original file
    idx = models.IntegerField()

    finished = models.BooleanField(default=False)

    # JSON field containing error information
    errors = models.TextField(default='')

    # Status
    WAITING=3
    status = models.IntegerField(default=WAITING)

    def __init__(self, *args, **kwargs):
        super(GenericImportRow, self).__init__(*args,**kwargs)
        self.jsondata = None
        self.cleaned = {}

    @property
    def model_fields(self):
        raise Exception('Abstract Method')

    @property
    def datadict(self):
        if self.jsondata is None:
            self.jsondata = json.loads(self.data)

        return self.jsondata

    @datadict.setter
    def datadict(self, v):
        self.jsondata = v
        self.data = json.dumps(self.jsondata)

    def errors_as_array(self):
        if self.errors is None or self.errors == '':
            return []
        else:
            return json.loads(self.errors)

    def has_errors(self):
        return len(self.errors_as_array()) > 0

    def get_fields_with_error(self):
        data = {}
        datadict = self.datadict

        for e in self.errors_as_array():
            for field in e['fields']:
                data[field] = datadict[field]

        return data

    def has_fatal_error(self):
        if self.errors:
            for err in json.loads(self.errors):
                if err['fatal']:
                    return True

        return False


    def append_error(self, err, fields, data=None):
        code, msg, fatal = err

        if self.errors is None or self.errors == '':
            self.errors = '[]'

        # If you give append_error a single field
        # there is no need to get angry
        if isinstance(fields, basestring):
            fields = (fields,) # make into tuple

        self.errors = json.dumps(
            json.loads(self.errors) + [
                {'code': code,
                 'fields': fields,
                 'msg': msg,
                 'data': data,
                 'fatal': fatal}])

        return self

    def safe_float(self, fld):
        try:
            return float(self.datadict[fld])
        except:
            self.append_error(errors.FLOAT_ERROR, fld)
            return False

    def safe_bool(self, fld):
        """ Returns a tuple of (success, bool value) """
        v = self.datadict.get(fld, '').lower()

        if v == '':
            return (True, None)
        if v == 'true' or v == 't' or v == 'yes':
            return (True,True)
        elif v == 'false' or v == 'f' or v == 'no':
            return (True,False)
        else:
            self.append_error(errors.BOOL_ERROR, fld)
            return (False,None)


    def safe_int(self, fld):
        try:
            return int(self.datadict[fld])
        except:
            self.append_error(errors.INT_ERROR, fld)
            return False

    def safe_pos_int(self, fld):
        i = self.safe_int(fld)

        if i is False:
            return False
        elif i < 0:
            self.append_error(errors.POS_INT_ERROR, fld)
            return False
        else:
            return i

    def safe_pos_float(self, fld):
        i = self.safe_float(fld)

        if i is False:
            return False
        elif i < 0:
            self.append_error(errors.POS_FLOAT_ERROR, fld)
            return False
        else:
            return i

    def convert_units(self, data, converts):
        INCHES_TO_DBH_FACTOR = 1.0 / settings.DBH_TO_INCHES_FACTOR

        # Similar to tree
        for fld, factor in converts.iteritems():
            if fld in data and factor != 1.0:
                data[fld] = float(data[fld]) * factor * INCHES_TO_DBH_FACTOR

    def validate_numeric_fields(self):
        def cleanup(fields, fn):
            has_errors = False
            for f in fields:
                if f in self.datadict and self.datadict[f]:
                    maybe_num = fn(f)

                    if maybe_num is False:
                        has_errors = True
                    else:
                        self.cleaned[f] = maybe_num

            return has_errors

        pfloat_ok = cleanup(self.model_fields.POS_FLOAT_FIELDS,
                            self.safe_pos_float)

        float_ok = cleanup(self.model_fields.FLOAT_FIELDS,
                           self.safe_float)

        int_ok = cleanup(self.model_fields.POS_INT_FIELDS,
                         self.safe_pos_int)

        return pfloat_ok and float_ok and int_ok

    def validate_boolean_fields(self):
        has_errors = False
        for f in self.model_fields.BOOLEAN_FIELDS:
            if f in self.datadict:
                success, v = self.safe_bool(f)
                if success and v is not None:
                    self.cleaned[f] = v
                else:
                    has_errors = True

        return has_errors

    def validate_choice_fields(self):
        has_errors = False
        for field,choice_key in self.model_fields.CHOICE_MAP.iteritems():
            value = self.datadict.get(field, None)
            #TODO: Remove hack that checks for '-'
            if value and value != '-':
                all_choices = settings.CHOICES[choice_key]
                choices = { value: id for (id, value) in all_choices }

                if value in choices:
                    self.cleaned[field] = choices[value]
                else:
                    has_errors = True
                    self.append_error(errors.INVALID_CHOICE,
                                      field, choice_key)

        return has_errors

    def validate_string_fields(self):
        has_errors = False
        for field in self.model_fields.STRING_FIELDS:

            value = self.datadict.get(field, None)
            if value:
                if len(value) > 255:
                    self.append_error(errors.STRING_TOO_LONG, field)
                    has_errors = True
                else:
                    self.cleaned[field] = value

        return has_errors

    def validate_date_fields(self):
        has_errors = False
        for field in self.model_fields.DATE_FIELDS:
            value = self.datadict.get(field, None)
            if value:
                try:
                    datep = datetime.strptime(value, '%Y-%m-%d')
                    self.cleaned[self.model_fields.DATE_PLANTED] = datep
                except ValueError, e:
                    self.append_error(errors.INVALID_DATE,
                                      self.model_fields.DATE_PLANTED)
                    has_errors = True

        return has_errors


    def validate_and_convert_datatypes(self):
        self.validate_numeric_fields()
        self.validate_boolean_fields()
        self.validate_choice_fields()
        self.validate_string_fields()
        self.validate_date_fields()

    def validate_row(self):
        """
        Validate a row. Returns True if there were no fatal errors,
        False otherwise

        The method mutates self in two ways:
        - The 'errors' field on self will be appended to
          whenever an error is found
        - The 'cleaned' field on self will be set as fields
          get validated
        """
        raise Exception('Abstract Method')


#TODO: Ok to ignore address?
#TODO: Tree actions (csv field?)

class SpeciesImportRow(GenericImportRow):

    SUCCESS=0
    ERROR=1
    VERIFIED=4

    SPECIES_MAP = {
            'symbol': fields.species.USDA_SYMBOL,
            'alternate_symbol': fields.species.ALT_SYMBOL,
            'itree_code': fields.species.ITREE_CODE,
            'genus': fields.species.GENUS,
            'species': fields.species.SPECIES,
            'cultivar_name': fields.species.CULTIVAR,
            'common_name': fields.species.COMMON_NAME,
            'native_status': fields.species.NATIVE_STATUS,
            'fall_conspicuous': fields.species.FALL_COLORS,
            'palatable_human': fields.species.EDIBLE,
            'flower_conspicuous': fields.species.FLOWERING,
            'bloom_period': fields.species.FLOWERING_PERIOD,
            'fruit_period': fields.species.FRUIT_PERIOD,
            'wildlife_value': fields.species.WILDLIFE,
            'v_max_dbh': fields.species.MAX_DIAMETER,
            'v_max_height': fields.species.MAX_HEIGHT,
            'fact_sheet': fields.species.FACT_SHEET,
            'family': fields.species.FAMILY,
            'other_part_of_name': fields.species.OTHER_PART_OF_NAME,
            'id': fields.species.ID,
            'tree_count': fields.species.TREE_COUNT,
            'scientific_name': fields.species.SCIENTIFIC_NAME,
        }

    # Species reference
    species = models.ForeignKey(Species, null=True, blank=True)
    merged = models.BooleanField(default=False)

    import_event = models.ForeignKey(SpeciesImportEvent)

    def diff_from_species(self, species):
        """ Compute how this row is different from
        the given species

        The result is a json dict with field names:
        { '<field name>': ['<species value>', '<row value>'] }

        Note that you can't *remove* data with species import

        If the returned dictionary is empty, importing this
        row will (essentially) be a nop

        This should only be called after a verify because I
        uses cleaned data
        """
        #TODO: Test me
        if species is None:
            return {}

        data = self.cleaned
        rslt = {}
        for (modelkey, rowkey) in SpeciesImportRow.SPECIES_MAP.iteritems():
            rowdata = data.get(rowkey, None)
            modeldata = getattr(species,modelkey)

            if rowdata and rowdata != modeldata:
                    rslt[rowkey] = (modeldata, rowdata)

        # Always include the ID
        rslt['id'] = (species.pk, None)

        return rslt

    @property
    def model_fields(self):
        return fields.species

    def validate_species(self):
        genus = self.datadict.get(fields.species.GENUS,'')
        species = self.datadict.get(fields.species.SPECIES,'')
        cultivar = self.datadict.get(fields.species.CULTIVAR,'')
        other_part = self.datadict.get(fields.species.OTHER_PART_OF_NAME,'')
        family = self.datadict.get(fields.species.FAMILY,'')

        # Save these as "empty" strings
        self.cleaned[fields.species.GENUS] = genus
        self.cleaned[fields.species.SPECIES] = species
        self.cleaned[fields.species.CULTIVAR] = cultivar
        self.cleaned[fields.species.OTHER_PART_OF_NAME] = other_part
        self.cleaned[fields.species.FAMILY] = family

        if genus != '' or species != '' or cultivar != '' or other_part != '':
            matching_species = Species.objects\
                                      .filter(genus__iexact=genus)\
                                      .filter(species__iexact=species)\
                                      .filter(cultivar_name__iexact=cultivar)\
                                      .filter(other_part_of_name__iexact=other_part)

            self.cleaned[fields.species.ORIG_SPECIES]\
                |= { s.pk for s in matching_species }


        return True

    def validate_code(self, fld, species_fld, addl_filters=None):
        value = self.datadict.get(fld, None)

        if value:
            self.cleaned[fld] = value

            matching_species = Species.objects\
                                      .filter(**{species_fld: value})

            if addl_filters:
                matching_species = matching_species\
                    .filter(**addl_filters)

            self.cleaned[fields.species.ORIG_SPECIES]\
                |= { s.pk for s in matching_species }

        return True

    def validate_usda_code(self):
        # USDA codes don't cover cultivars, so assert that
        # a 'matching' species *must* have the same cultivar
        # and same USDA code
        addl_filter =  {'cultivar_name':
                        self.cleaned.get(fields.species.CULTIVAR,
                                         '')}

        return self.validate_code(fields.species.USDA_SYMBOL,
                                  'symbol', addl_filter)

    def validate_alt_code(self):
        return self.validate_code(fields.species.ALT_SYMBOL,
                                  'alternate_symbol')


    def validate_required_fields(self):
        req = { fields.species.GENUS,
                fields.species.COMMON_NAME, fields.species.ITREE_CODE }

        has_errors = False

        for field in req:
            value = self.cleaned.get(field, None)
            if not value:
                has_errors = True
                self.append_error(errors.MISSING_FIELD, field)

        return not has_errors

    def validate_itree_code(self):
        default_region = settings.ITREE_REGION

        def is_valid_code(code, region=default_region):
            # Each region/datatype pair has its own set of benefits
            # in this case we're using the 'electricity' benefit
            # as the prototype
            breaks, data = benefits._get_data(region, 'electricity')

            return code in data

        has_error = False
        itreecode = self.datadict.get(fields.species.ITREE_CODE)

        # There are two formats for this column
        # The first is simply an itree code:
        # 'CEL OTHER'
        #
        # The other is a pairing between regions and itree codes
        # that looks something like:
        # <region>:<code>, ...
        # SoCalCSMA:CEL OTHER, InlEmpCLM:CEL OTHER
        if itreecode:
            rsrcs = []

            if ':' in itreecode:
                codes = [regioncode.split(':')
                         for regioncode in itreecode.split(',')]

                for region, code in codes:
                    if is_valid_code(code, region):
                        rsrcs.append((code, region))
                    else:
                        has_error = True
                        self.append_error(errors.INVALID_ITREE_CODE,
                                          (fields.species.ITREE_CODE,),
                                          {'region': region,
                                           'code': code})
                        break

                if not has_error:
                    self.cleaned[fields.species.RESOURCE] = rsrcs
            else:
                if is_valid_code(itreecode):
                    self.cleaned[fields.species.RESOURCE] = [(itreecode,None)]
                else:
                    has_error = True
                    self.append_error(errors.INVALID_ITREE_CODE,
                                      (fields.species.ITREE_CODE,))
        else:
            has_error = True
            self.append_error(errors.MISSING_ITREE_CODE,
                              (fields.species.ITREE_CODE,))

        return not has_error


    def validate_row(self):
        """
        Validate a row. Returns True if there were no fatal errors,
        False otherwise

        The method mutates self in two ways:
        - The 'errors' field on self will be appended to
          whenever an error is found
        - The 'cleaned' field on self will be set as fields
          get validated
        """
        # Clear errrors
        self.errors = ''

        # NOTE: Validations append errors directly to importrow
        # and move data over to the 'cleaned' hash as it is
        # validated

        # Convert all fields to correct datatypes
        self.validate_and_convert_datatypes()

        # Check to see if this species matches any existing ones
        # they'll be stored as a set of ORIG_SPECIES
        self.cleaned[fields.species.ORIG_SPECIES] = set()

        self.validate_species()
        self.validate_usda_code()
        self.validate_alt_code()

        self.validate_itree_code()
        self.validate_required_fields()

        # Native status is a horrible field that pretends to
        # be a boolean value but is actually a string so we
        # change it here
        if fields.species.NATIVE_STATUS in self.cleaned:
            self.cleaned[fields.species.NATIVE_STATUS] = str(
                self.cleaned[fields.species.NATIVE_STATUS])


        # If same is set to true this is essentially a no-op
        same = False

        possible_matches = self.cleaned[fields.species.ORIG_SPECIES]
        # TODO: Certain fields require this flag to be reset
        if not self.merged:
            if len(possible_matches) == 0:
                self.merged = True
            else:
                species = [Species.objects.get(pk=pk) for pk in possible_matches]
                diffs = [self.diff_from_species(s) for s in species]
                # There's always a single field that has changed in the
                # diff. This is the 'id' field of the existing species,
                # which will never be the same as the None for the current
                # id.
                if all([diff.keys() == ['id'] for diff in diffs]):
                    self.merged = True
                    same = True

                    self.species = species[0]
                else:
                    diff_keys = set()

                    for diff in diffs:
                        for key in diff.keys():
                            diff_keys.add(key)

                    if len(possible_matches) > 1:
                        self.append_error(errors.TOO_MANY_SPECIES, tuple(diff_keys), tuple(diffs))
                    else:
                        self.append_error(errors.MERGE_REQ, tuple(diff_keys), diffs[0])
                        pk = list(possible_matches)[0]
                        self.species = Species.objects.get(pk=pk)

        fatal = False
        if self.has_fatal_error():
            self.status = SpeciesImportRow.ERROR
            fatal = True
        elif same: # Nothing changed, this has been effectively added
            self.status = SpeciesImportRow.SUCCESS
        else:
            self.status = SpeciesImportRow.VERIFIED

        self.save()
        return not fatal

    def commit_row(self):
        # First validate
        if not self.validate_row():
            return False

        if self.status == SpeciesImportRow.SUCCESS:
            # Nothing changed!
            return True

        # Get our data
        data = self.cleaned

        species_edited = False

        # Initially grab species from row if it exists
        # and edit it
        species = self.species

        # If not specified create a new one
        if species is None:
            species = Species()

        # Convert units
        self.convert_units(data, {
            fields.species.MAX_DIAMETER:
            self.import_event.max_diameter_conversion_factor,

            fields.species.MAX_HEIGHT:
            self.import_event.max_tree_height_conversion_factor
        })

        #TODO: Update tree count nonsense

        for modelkey, importdatakey in SpeciesImportRow.SPECIES_MAP.iteritems():
            importdata = data.get(importdatakey, None)

            if importdata is not None:
                species_edited = True
                setattr(species, modelkey, importdata)

        if species_edited:
            species.save()

        resources = data[fields.species.RESOURCE]

        species.resource.clear()

        for code, region in resources:
            r = Resource.objects.filter(meta_species=code,
                                        region=region)

            if r.exists():
                resource = r[0]
            else:
                resource = Resource.objects.create(meta_species=code,
                                                   region=region)

            species.resource.add(resource)

        species.save()
        resource.save()

        self.species = species
        self.status = TreeImportRow.SUCCESS
        self.save()

        return True

class TreeImportRow(GenericImportRow):
    SUCCESS=0
    ERROR=1
    WATCH=2
    VERIFIED=4

    PLOT_MAP = {
        'geometry': fields.trees.POINT,
        'width': fields.trees.PLOT_WIDTH,
        'length': fields.trees.PLOT_LENGTH,
        'type': fields.trees.PLOT_TYPE,
        'readonly': fields.trees.READ_ONLY,
        'sidewalk_damage': fields.trees.SIDEWALK,
        'powerline_conflict_potential': fields.trees.POWERLINE_CONFLICT,
        'owner_orig_id': fields.trees.ORIG_ID_NUMBER,
        'owner_additional_id': fields.trees.DATA_SOURCE,
        'owner_additional_properties': fields.trees.NOTES
    }

    TREE_MAP = {
        'tree_owner': fields.trees.OWNER,
        'steward_name': fields.trees.STEWARD,
        'dbh': fields.trees.DIAMETER,
        'height': fields.trees.TREE_HEIGHT,
        'canopy_height': fields.trees.CANOPY_HEIGHT,
        'species': fields.trees.SPECIES_OBJECT,
        'sponsor': fields.trees.SPONSOR,
        'date_planted': fields.trees.DATE_PLANTED,
        'readonly': fields.trees.READ_ONLY,
        'projects': fields.trees.LOCAL_PROJECTS,
        'condition': fields.trees.TREE_CONDITION,
        'canopy_condition': fields.trees.CANOPY_CONDITION,
        'url': fields.trees.URL,
        'pests': fields.trees.PESTS
    }

    # plot that was created from this row
    plot = models.ForeignKey(Plot, null=True, blank=True)

    # The main import event
    import_event = models.ForeignKey(TreeImportEvent)

    @property
    def model_fields(self):
        return fields.trees

    def commit_row(self):
        # If this row was already commit... abort
        if self.plot:
            self.status = TreeImportRow.SUCCESS
            self.save()

        # First validate
        if not self.validate_row():
            return False

        # Get our data
        data = self.cleaned

        self.convert_units(data, {
            fields.trees.PLOT_WIDTH:
            self.import_event.plot_width_conversion_factor,

            fields.trees.PLOT_LENGTH:
            self.import_event.plot_length_conversion_factor,

            fields.trees.DIAMETER:
            self.import_event.diameter_conversion_factor,

            fields.trees.TREE_HEIGHT:
            self.import_event.tree_height_conversion_factor,

            fields.trees.CANOPY_HEIGHT:
            self.import_event.canopy_height_conversion_factor
        })

        # We need the import event from treemap.models
        # the names of things are a bit odd here but
        # self.import_event ->
        #   TreeImportEvent (importer) ->
        #     ImportEvent (treemap)
        #
        base_treemap_import_event = self.import_event.base_import_event

        plot_edited = False
        tree_edited = False

        # Initially grab plot from row if it exists
        plot = self.plot
        if plot is None:
            plot = Plot(present=True)

        # Event if TREE_PRESENT is None, a tree
        # can still be spawned here if there is
        # any tree data later
        tree = plot.current_tree()

        # Check for an existing tree:
        if self.model_fields.OPENTREEMAP_ID_NUMBER in data:
            plot = Plot.objects.get(
                pk=data[self.model_fields.OPENTREEMAP_ID_NUMBER])
            tree = plot.current_tree()
        else:
            if data.get(self.model_fields.TREE_PRESENT, False):
                tree_edited = True
                if tree is None:
                    tree = Tree(present=True)

        data_owner = self.import_event.owner

        for modelkey, importdatakey in TreeImportRow.PLOT_MAP.iteritems():
            importdata = data.get(importdatakey, None)

            if importdata:
                plot_edited = True
                setattr(plot, modelkey, importdata)

        if plot_edited:
            plot.last_updated_by = data_owner
            plot.import_event = base_treemap_import_event
            plot.save()

        for modelkey, importdatakey in TreeImportRow.TREE_MAP.iteritems():
            importdata = data.get(importdatakey, None)

            if importdata:
                tree_edited = True
                if tree is None:
                    tree = Tree(present=True)
                setattr(tree, modelkey, importdata)

        if tree_edited:
            tree.last_updated_by = data_owner
            tree.import_event = base_treemap_import_event
            tree.plot = plot
            tree.save()

        self.plot = plot
        self.status = TreeImportRow.SUCCESS
        self.save()

        return True

    def validate_geom(self):
        x = self.cleaned.get(fields.trees.POINT_X, None)
        y = self.cleaned.get(fields.trees.POINT_Y, None)

        # Note, this shouldn't really happen since main
        # file validation will fail, but butter safe than sorry
        if x is None or y is None:
            self.append_error(errors.MISSING_POINTS,
                              (fields.trees.POINT_X, fields.trees.POINT_Y))
            return False

        # Simple validation
        # longitude must be between -180 and 180
        # latitude must be betwen -90 and 90
        if abs(x) > 180 or abs(y) > 90:
            self.append_error(errors.INVALID_GEOM,
                              (fields.trees.POINT_X, fields.trees.POINT_Y))
            return False

        p = Point(x,y)

        if ExclusionMask.objects.filter(geometry__contains=p).exists():
            self.append_error(errors.EXCL_ZONE,
                              (fields.trees.POINT_X, fields.trees.POINT_Y))
            return False
        elif Neighborhood.objects.filter(geometry__contains=p).exists():
            self.cleaned[fields.trees.POINT] = p
        else:
            self.append_error(errors.GEOM_OUT_OF_BOUNDS,
                              (fields.trees.POINT_X, fields.trees.POINT_Y))
            return False

        return True

    def validate_otm_id(self):
        oid = self.cleaned.get(fields.trees.OPENTREEMAP_ID_NUMBER, None)
        if oid:
            has_plot = Plot.objects.filter(
                pk=oid).exists()

            if not has_plot:
                self.append_error(errors.INVALID_OTM_ID,
                                  fields.trees.OPENTREEMAP_ID_NUMBER)
                return False

        return True

    def validate_proximity(self, point):
        base_import_event = self.import_event.base_import_event
        nearby = Plot.objects\
                     .filter(present=True,
                             geometry__distance_lte=(point, D(ft=10.0)))\
                     .distance(point)\
                     .exclude(import_event=base_import_event)\
                     .order_by('distance')[:5]

        if len(nearby) > 0:
            self.append_error(errors.NEARBY_TREES,
                              (fields.trees.POINT_X, fields.trees.POINT_Y),
                              [p.pk for p in nearby])
            return False
        else:
            return True

    def validate_species_max(self, field, max_val, err):
        inputval = self.cleaned.get(field, None)
        if inputval:
            if max_val and inputval > max_val:
                self.append_error(err, field, max_val)
                return False

        return True


    def validate_species_dbh_max(self, species):
        return self.validate_species_max(
            fields.trees.DIAMETER,
            species.v_max_dbh, errors.SPECIES_DBH_TOO_HIGH)

    def validate_species_height_max(self, species):
        return self.validate_species_max(
            fields.trees.TREE_HEIGHT,
            species.v_max_height, errors.SPECIES_HEIGHT_TOO_HIGH)

    def validate_species(self):
        genus = self.datadict.get(fields.trees.GENUS,'')
        species = self.datadict.get(fields.trees.SPECIES,'')
        cultivar = self.datadict.get(fields.trees.CULTIVAR,'')
        other_part = self.datadict.get(fields.trees.OTHER_PART_OF_NAME,'')

        if genus != '' or species != '' or cultivar != '':
            matching_species = Species.objects\
                                      .filter(genus__iexact=genus)\
                                      .filter(species__iexact=species)\
                                      .filter(cultivar_name__iexact=cultivar)\
                                      .filter(other_part_of_name__iexact=other_part)

            if len(matching_species) == 1:
                self.cleaned[fields.trees.SPECIES_OBJECT] = matching_species[0]
            else:
                self.append_error(errors.INVALID_SPECIES,
                                  (fields.trees.GENUS, fields.trees.SPECIES, fields.trees.CULTIVAR),
                                  ' '.join([genus,species,cultivar]).strip())
                return False

        return True

    def validate_row(self):
        """
        Validate a row. Returns True if there were no fatal errors,
        False otherwise

        The method mutates self in two ways:
        - The 'errors' field on self will be appended to
          whenever an error is found
        - The 'cleaned' field on self will be set as fields
          get validated
        """
        # Clear errrors
        self.errors = ''

        # NOTE: Validations append errors directly to importrow
        # and move data over to the 'cleaned' hash as it is
        # validated

        # Convert all fields to correct datatypes
        self.validate_and_convert_datatypes()

        # We can work on the 'cleaned' data from here on out
        self.validate_otm_id()

        # Attaches a GEOS point to fields.trees.POINT
        self.validate_geom()

        # This could be None or not set if there
        # was an earlier error
        pt = self.cleaned.get(fields.trees.POINT, None)

        self.validate_species()

        # This could be None or unset if species data were
        # not given
        species = self.cleaned.get(fields.trees.SPECIES_OBJECT, None)

        # These validations are non-fatal
        if species:
            self.validate_species_dbh_max(species)
            self.validate_species_height_max(species)

        if pt:
            self.validate_proximity(pt)

        fatal = False
        if self.has_fatal_error():
            self.status = TreeImportRow.ERROR
            fatal = True
        elif self.has_errors(): # Has 'warning'/tree watch errors
            self.status = TreeImportRow.WATCH
        else:
            self.status = TreeImportRow.VERIFIED

        self.save()
        return not fatal

########NEW FILE########
__FILENAME__ = tasks
from celery import task

from importer.models import TreeImportRow, GenericImportEvent, \
    GenericImportRow

BLOCK_SIZE = 250

def get_waiting_row_count(ie):
    return ie.rows()\
             .filter(status=GenericImportRow.WAITING)\
             .count()


@task()
def validate_rows(ie, i):
    for row in ie.rows()[i:(i+BLOCK_SIZE)]:
        row.validate_row()

    if get_waiting_row_count(ie) == 0:
        ie.status = GenericImportEvent.FINISHED_VERIFICATION
        ie.save()

@task()
def run_import_event_validation(ie):
    filevalid = ie.validate_main_file()

    ie.status = GenericImportEvent.VERIFIYING
    ie.save()

    rows = ie.rows()
    if filevalid:
        for i in xrange(0,rows.count(), BLOCK_SIZE):
            validate_rows.delay(ie, i)

@task()
def commit_rows(ie, i):
    #TODO: Refactor out [Tree]ImportRow.SUCCESS
    # this works right now because they are the same
    # value (0) but that's not really great
    missing_merges = 0

    for row in ie.rows()[i:(i + BLOCK_SIZE)]:
        needs_merge = hasattr(row, 'merged') and not row.merged
        if row.status != TreeImportRow.SUCCESS and not needs_merge:
            row.commit_row()

        if needs_merge:
            missing_merges += 1

    if get_waiting_row_count(ie) <= missing_merges:
        ie.status = GenericImportEvent.FINISHED_CREATING
        ie.save()

@task()
def commit_import_event(ie):
    filevalid = ie.validate_main_file()

    rows = ie.rows()
    success = []
    failed = []

    #TODO: When using OTM ID field, don't include
    #      that tree in proximity check (duh)
    if filevalid:
        for i in xrange(0,rows.count(), BLOCK_SIZE):
            commit_rows.delay(ie, i)

########NEW FILE########
__FILENAME__ = tests
from django.conf import settings
from django.test import TestCase
from django.test.client import RequestFactory
from django.http import HttpRequest
from django.contrib.auth import SESSION_KEY, BACKEND_SESSION_KEY, login, authenticate
from django.contrib.auth.models import User
from django.contrib.gis.geos import MultiPolygon, Polygon, Point
from django.utils.importlib import import_module

import tempfile
import csv
import json
from datetime import date

from StringIO import StringIO

# Since OTM is such a crazy huge beast, we'll use the same functions
# the API does for setting up a reasonable env
from api.test_utils import setupTreemapEnv, mkPlot

from importer.views import create_rows_for_event, \
    process_csv, process_status, commit, merge_species

from importer import errors,fields

from importer.models import TreeImportEvent, TreeImportRow, \
    SpeciesImportEvent, SpeciesImportRow

from django_reputation.models import Reputation

from treemap.models import Species, Neighborhood, Plot, \
    ExclusionMask, Resource, ImportEvent, Tree

class MergeTest(TestCase):
    def setUp(self):
        setupTreemapEnv()

        self.user = User(username='smith')
        self.user.save()
        self.user.reputation = Reputation()
        self.user.save()

        ie = ImportEvent(file_name="bie1")
        ie.save()

        p1 = mkPlot(self.user, geom=Point(25.0000001,25.0000001))
        p1.import_event = ie
        p1.save()

        p2 = mkPlot(self.user, geom=Point(25.0000002,25.0000002))
        p2.import_event = ie
        p2.save()

        ss = Species.objects.all()
        self.s1 = ss[0]
        self.s2 = ss[1]

        self.t1 = Tree(plot=p1, species=self.s1, last_updated_by=self.user)
        self.t1.import_event = ie
        self.t1.save()

        self.t2 = Tree(plot=p2, species=self.s2, last_updated_by=self.user)
        self.t2.import_event = ie
        self.t2.save()

    def test_cant_merge_same_species(self):
        r = HttpRequest()
        r.REQUEST = {
            'species_to_delete': self.s1.pk,
            'species_to_replace_with': self.s1.pk
        }

        r.user = self.user
        r.user.is_staff = True

        spcnt = Species.objects.all().count()

        resp = merge_species(r)

        self.assertEqual(Species.objects.all().count(), spcnt)
        self.assertEqual(resp.status_code, 400)


    def test_merges(self):
        r = HttpRequest()
        r.REQUEST = {
            'species_to_delete': self.s1.pk,
            'species_to_replace_with': self.s2.pk
        }

        r.user = self.user
        r.user.is_staff = True

        merge_species(r)

        self.assertRaises(Species.DoesNotExist,
                          Species.objects.get, pk=self.s1.pk)

        t1r = Tree.objects.get(pk=self.t1.pk)
        t2r = Tree.objects.get(pk=self.t2.pk)

        self.assertEqual(t1r.species.pk, self.s2.pk)
        self.assertEqual(t2r.species.pk, self.s2.pk)


class ValidationTest(TestCase):
    def setUp(self):
        self.user = User(username='smith')
        self.user.save()

        bie = ImportEvent(file_name="fn")
        bie.save()

        self.ie = TreeImportEvent(file_name='file',
                                  owner=self.user,
                                  base_import_event=bie)
        self.ie.save()

    def mkrow(self,data):
        return TreeImportRow.objects.create(
            data=json.dumps(data), import_event=self.ie, idx=1)

    def assertHasError(self, thing, err, data=None, df=None):
        errors = ''
        errn,msg,fatal = err
        if thing.errors:
            errors = json.loads(thing.errors)
            for e in errors:
                if e['code'] == errn:
                    if data is not None:
                        edata = e['data']
                        if df:
                            edata = df(edata)
                        self.assertEqual(edata, data)
                    return

        raise AssertionError('Error code %s not found in %s' % (errn,errors))

    def assertNotHasError(self, thing, err, data=None):
        errn,msg,fatal = err
        if thing.errors:
            errors = json.loads(thing.errors)
            for e in errors:
                if e['code'] == errn:
                    raise AssertionError('Error code %s found in %s' % (errn,errors))

    def test_species_dbh_and_height(self):
        s1_gsc = Species(symbol='S1G__', scientific_name='',family='',
                         genus='g1', species='s1', cultivar_name='c1',
                         v_max_height=30, v_max_dbh=19)
        s1_gs = Species(symbol='S1GS_', scientific_name='',family='',
                        genus='g1', species='s1', cultivar_name='',
                        v_max_height=22, v_max_dbh=12)
        s1_gsc.save()
        s1_gs.save()

        row = {'point x': '16',
               'point y': '20',
               'genus': 'g1',
               'species': 's1',
               'diameter': '15',
               'tree height': '18'}

        i = self.mkrow(row)
        r = i.validate_row()

        self.assertHasError(i, errors.SPECIES_DBH_TOO_HIGH)
        self.assertNotHasError(i, errors.SPECIES_HEIGHT_TOO_HIGH)

        row['tree height'] = 25
        i = self.mkrow(row)
        r = i.validate_row()

        self.assertHasError(i, errors.SPECIES_DBH_TOO_HIGH)
        self.assertHasError(i, errors.SPECIES_HEIGHT_TOO_HIGH)

        row['cultivar'] = 'c1'
        i = self.mkrow(row)
        r = i.validate_row()

        self.assertNotHasError(i, errors.SPECIES_DBH_TOO_HIGH)
        self.assertNotHasError(i, errors.SPECIES_HEIGHT_TOO_HIGH)

    def test_proximity(self):
        setupTreemapEnv()

        user = User.objects.get(username="jim")
        bie1 = ImportEvent(file_name="bie1")
        bie2 = ImportEvent(file_name="bie2")
        bie3 = ImportEvent(file_name="bie3")
        bie4 = ImportEvent(file_name="bie4")

        for bie in [bie1, bie2, bie3, bie4]:
            bie.save()

        p1 = mkPlot(user, geom=Point(25.0000001,25.0000001))
        p1.import_event = bie1
        p1.save()

        p2 = mkPlot(user, geom=Point(25.0000002,25.0000002))
        p2.import_event = bie2
        p2.save()

        p3 = mkPlot(user, geom=Point(25.0000003,25.0000003))
        p3.import_event = bie3
        p3.save()

        p4 = mkPlot(user, geom=Point(27.0000001,27.0000001))
        p4.import_event = bie4
        p4.save()

        n1 = { p.pk for p in [p1,p2,p3] }
        n2 = { p4.pk }

        i = self.mkrow({'point x': '25.00000025',
                        'point y': '25.00000025'})
        r = i.validate_row()

        self.assertHasError(i, errors.NEARBY_TREES, n1, set)

        i = self.mkrow({'point x': '27.00000015',
                        'point y': '27.00000015'})
        r = i.validate_row()

        self.assertHasError(i, errors.NEARBY_TREES, n2, set)

        i = self.mkrow({'point x': '30.00000015',
                        'point y': '30.00000015'})
        r = i.validate_row()

        self.assertNotHasError(i, errors.NEARBY_TREES)


    def test_species_id(self):
        s1_gsc = Species(symbol='S1G__', scientific_name='',family='',
                         genus='g1', species='s1', cultivar_name='c1')
        s1_gs = Species(symbol='S1GS_', scientific_name='',family='',
                        genus='g1', species='s1', cultivar_name='')
        s1_g = Species(symbol='S1GSC', scientific_name='',family='',
                       genus='g1', species='', cultivar_name='')

        s2_gsc = Species(symbol='S2GSC', scientific_name='',family='',
                         genus='g2', species='s2', cultivar_name='c2')
        s2_gs = Species(symbol='S2GS_', scientific_name='',family='',
                        genus='g2', species='s2', cultivar_name='')

        for s in [s1_gsc, s1_gs, s1_g, s2_gsc, s2_gs]:
            s.save()

        # Simple genus, species, cultivar matches
        i = self.mkrow({'point x': '16',
                        'point y': '20',
                        'genus': 'g1'})
        r = i.validate_row()

        self.assertNotHasError(i, errors.INVALID_SPECIES)

        i = self.mkrow({'point x': '16',
                        'point y': '20',
                        'genus': 'g1',
                        'species': 's1'})
        r = i.validate_row()

        self.assertNotHasError(i, errors.INVALID_SPECIES)

        i = self.mkrow({'point x': '16',
                        'point y': '20',
                        'genus': 'g1',
                        'species': 's1',
                        'cultivar': 'c1'})
        r = i.validate_row()

        self.assertNotHasError(i, errors.INVALID_SPECIES)

        # Test no species info at all
        i = self.mkrow({'point x': '16',
                        'point y': '20'})
        r = i.validate_row()

        self.assertNotHasError(i, errors.INVALID_SPECIES)

        # Test mismatches
        i = self.mkrow({'point x': '16',
                        'point y': '20',
                        'genus': 'g1',
                        'species': 's2',
                        'cultivar': 'c1'})
        r = i.validate_row()

        self.assertHasError(i, errors.INVALID_SPECIES)

        i = self.mkrow({'point x': '16',
                        'point y': '20',
                        'genus': 'g2'})
        r = i.validate_row()

        self.assertHasError(i, errors.INVALID_SPECIES)


    def test_otm_id(self):
        # silly invalid-int-errors should be caught
        i = self.mkrow({'point x': '16',
                        'point y': '20',
                        'opentreemap id number': '44b'})
        r = i.validate_row()

        self.assertFalse(r)
        self.assertHasError(i, errors.INT_ERROR, None)

        i = self.mkrow({'point x': '16',
                        'point y': '20',
                        'opentreemap id number': '-22'})
        r = i.validate_row()

        self.assertFalse(r)
        self.assertHasError(i, errors.POS_INT_ERROR)

        # With no plots in the system, all ids should fail
        i = self.mkrow({'point x': '16',
                        'point y': '20',
                        'opentreemap id number': '44'})
        r = i.validate_row()

        self.assertFalse(r)
        self.assertHasError(i, errors.INVALID_OTM_ID)

        # Add in plot
        setupTreemapEnv() # We need the whole darn thing
                          # just so we can add a plot :(

        # SetupTME provides a special user for us to use
        # as well as particular neighborhood
        user = User.objects.get(username="jim")
        p = mkPlot(user, geom=Point(25,25))
        p.save()

        # With an existing plot it should be fine
        i = self.mkrow({'point x': '16',
                        'point y': '20',
                        'opentreemap id number': p.pk})
        r = i.validate_row()

        self.assertNotHasError(i, errors.INVALID_OTM_ID)
        self.assertNotHasError(i, errors.INT_ERROR)

    def test_geom_validation(self):
        def mkpt(x,y):
            return self.mkrow({'point x': str(x), 'point y': str(y)})

        # Invalid numbers
        i = mkpt('300a','20b')
        r = i.validate_row()

        self.assertFalse(r)
        self.assertHasError(i, errors.FLOAT_ERROR)

        # Crazy lat/lngs
        i = mkpt(300,20)
        r = i.validate_row()

        self.assertFalse(r)
        self.assertHasError(i, errors.INVALID_GEOM)

        i = mkpt(50,93)
        r = i.validate_row()

        self.assertFalse(r)
        self.assertHasError(i, errors.INVALID_GEOM)

        # Out of neighborhood (neighborhood created in setUp)
        ngeom = MultiPolygon(Polygon(
            ((0, 0), (0, 50), (50, 50), (50, 0), (0, 0))))

        neighborhood = Neighborhood(
            name='test neighborhood',
            region_id=34,
            city='blah',
            county='blarg',
            geometry=ngeom)

        neighborhood.save()

        i = mkpt(55,55)
        r = i.validate_row()

        self.assertFalse(r)
        self.assertHasError(i, errors.GEOM_OUT_OF_BOUNDS)

        i = mkpt(-5,-5)
        r = i.validate_row()

        self.assertFalse(r)
        self.assertHasError(i, errors.GEOM_OUT_OF_BOUNDS)

        # This should work...
        i = mkpt(25,25)
        r = i.validate_row()

        # Can't assert that r is true because other validation
        # logic may have tripped it
        self.assertNotHasError(i, errors.GEOM_OUT_OF_BOUNDS)
        self.assertNotHasError(i, errors.INVALID_GEOM)
        self.assertNotHasError(i, errors.FLOAT_ERROR)

        # If we add an exclusion zone, it should fail
        egeom = MultiPolygon(Polygon(
            ((10,10),(10,30),(30,30),(30,10),(10,10))))

        e = ExclusionMask(geometry=egeom, type='blah blah')
        e.save()

        i = mkpt(25,25)
        r = i.validate_row()

        self.assertNotHasError(i, errors.GEOM_OUT_OF_BOUNDS)
        self.assertNotHasError(i, errors.INVALID_GEOM)
        self.assertNotHasError(i, errors.FLOAT_ERROR)
        self.assertHasError(i, errors.EXCL_ZONE)


class FileLevelValidationTest(TestCase):
    def write_csv(self, stuff):
        t = tempfile.NamedTemporaryFile()

        with open(t.name,'w') as csvfile:
            w = csv.writer(csvfile)
            for r in stuff:
                w.writerow(r)

        return t

    def setUp(self):
        self.user = User(username='smith')
        self.user.save()


    def test_empty_file_error(self):
        bie = ImportEvent(file_name="fn")
        bie.save()

        ie = TreeImportEvent(file_name='file',
                             owner=self.user,
                             base_import_event=bie)
        ie.save()

        base_rows = TreeImportRow.objects.count()

        c = self.write_csv([['header_field1','header_fields2','header_field3']])

        create_rows_for_event(ie, c)
        rslt = ie.validate_main_file()

        # No rows added and validation failed
        self.assertEqual(TreeImportRow.objects.count(), base_rows)
        self.assertFalse(rslt)

        ierrors = json.loads(ie.errors)

        # The only error is a bad file error
        self.assertTrue(len(ierrors), 1)
        etpl = (ierrors[0]['code'], ierrors[0]['msg'], True)

        self.assertEqual(etpl, errors.EMPTY_FILE)


    def test_missing_point_field(self):
        bie = ImportEvent(file_name="fn")
        bie.save()

        ie = TreeImportEvent(file_name='file',
                             owner=self.user,
                             base_import_event=bie)
        ie.save()

        base_rows = TreeImportRow.objects.count()

        c = self.write_csv([['address','plot width','plot_length'],
                            ['123 Beach St','5','5'],
                            ['222 Main St','8','8']])

        create_rows_for_event(ie, c)
        rslt = ie.validate_main_file()

        self.assertFalse(rslt)

        ierrors = json.loads(ie.errors)

        # Should be x/y point error
        self.assertTrue(len(ierrors), 1)
        etpl = (ierrors[0]['code'], ierrors[0]['msg'], True)

        self.assertEqual(etpl, errors.MISSING_POINTS)

    def test_unknown_field(self):
        bie = ImportEvent(file_name="fn")
        bie.save()

        ie = TreeImportEvent(file_name='file',
                             owner=self.user,
                             base_import_event=bie)
        ie.save()

        base_rows = TreeImportRow.objects.count()

        c = self.write_csv([['address','name','age','point x','point y'],
                            ['123 Beach St','a','b','5','5'],
                            ['222 Main St','a','b','8','8']])

        create_rows_for_event(ie, c)
        rslt = ie.validate_main_file()

        self.assertFalse(rslt)

        ierrors = json.loads(ie.errors)

        # Should be x/y point error
        self.assertTrue(len(ierrors), 1)
        etpl = (ierrors[0]['code'], ierrors[0]['msg'], False)

        self.assertEqual(etpl, errors.UNMATCHED_FIELDS)
        self.assertEqual(set(ierrors[0]['data']), set(['name','age']))

class IntegrationTests(TestCase):
    def setUp(self):
        setupTreemapEnv()

        self.user = User.objects.get(username='jim')

    def create_csv_stream(self, stuff):
        csvfile = StringIO()

        w = csv.writer(csvfile)
        for r in stuff:
            w.writerow(r)

        return StringIO(csvfile.getvalue())

    def login(self, request, **creds):
        engine = import_module(settings.SESSION_ENGINE)
        request.session = engine.SessionStore()
        user = authenticate(**creds)
        login(request, user)


    def create_csv_request(self, stuff, **kwargs):
        rows = [[z.strip() for z in a.split('|')[1:-1]]
                for a in stuff.split('\n') if len(a.strip()) > 0]

        req = HttpRequest()
        req.user = self.user
        self.login(req, username="jim", password="jim")

        req.FILES = {'filename': self.create_csv_stream(rows)}
        req.REQUEST = kwargs

        return req

    def run_through_process_views(self, csv):
        r = self.create_csv_request(csv, name='some name')
        pk = process_csv(r, fileconstructor=self.constructor())

        resp = process_status(None, pk, self.constructor())
        content = json.loads(resp.content)
        content['pk'] = pk
        return content

    def run_through_commit_views(self, csv):
        r = self.create_csv_request(csv, name='some name')
        pk = process_csv(r, fileconstructor=self.constructor())

        req = HttpRequest()
        req.user = self.user
        self.login(req, username="jim", password="jim")

        commit(req, pk, self.import_type())
        return pk

    def extract_errors(self, json):
        errors = {}
        if 'errors' not in json:
            return errors


        for k,v in json['errors'].iteritems():
            errors[k] = []
            for e in v:
                d = e['data']

                errors[k].append((e['code'], e['fields'], d))

        return errors

class SpeciesIntegrationTests(IntegrationTests):

    def rowconstructor(self):
        return SpeciesImportRow

    def constructor(self):
        return SpeciesImportEvent

    def import_type(self):
        return 'species'

    def test_bad_structure(self):
        csv = """
        | family | native status | diameter |
        | f1     | ns11          | 12       |
        | f2     | ns12          | 14       |
        """

        j = self.run_through_process_views(csv)
        self.assertEqual(len(j['errors']), 2)
        self.assertEqual({e['code'] for e in j['errors']},
                         {errors.MISSING_SPECIES_FIELDS[0],
                          errors.UNMATCHED_FIELDS[0]})

    def test_noerror_load(self):
        csv = """
        | genus   | species    | common name | i-tree code  |
        | g1      | s1         | g1 s1 wowza | BDM OTHER    |
        | g2      | s2         | g2 s2 wowza | BDL OTHER    |
        """

        j = self.run_through_process_views(csv)

        self.assertEqual(j['status'], 'success')
        self.assertEqual(j['rows'], 2)

    def test_invalid_itree(self):
        csv = """
        | genus   | species    | common name | i-tree code  |
        | testus1 | specieius9 | g1 s2 wowza | BDL OTHER    |
        | genus   |            | common name | failure      |
        | testus1 | specieius9 | g1 s2 wowza |              |
        """

        j = self.run_through_process_views(csv)
        ierrors = self.extract_errors(j)
        self.assertNotIn('0', ierrors)
        self.assertEqual(ierrors['1'],
                         [(errors.INVALID_ITREE_CODE[0],
                           [fields.species.ITREE_CODE], None)])
        self.assertEqual(ierrors['2'],
                         [(errors.MISSING_ITREE_CODE[0],
                           ['i-tree code'], None),
                          (errors.MISSING_FIELD[0],
                           ['i-tree code'], None)])

    def test_multiregion_itree(self):
        itree = 'NoEastXXX:ACPL,NMtnPrFNL:BDL OTHER'
        csv = """
        | genus   | species    | common name | i-tree code  |
        | testus1 | specieius9 | g1 s2 wowza | %s           |
        """ % itree

        seid = self.run_through_commit_views(csv)
        ie = SpeciesImportEvent.objects.get(pk=seid)
        s = ie.rows().all()[0].species

        self.assertEqual({(r.meta_species, r.region) for r in s.resource.all()},
                         {('ACPL', 'NoEastXXX'), ('BDL OTHER', 'NMtnPrFNL')})

    def test_species_matching(self):
        csv = """
        | genus   | species    | common name | i-tree code  | usda symbol | alternative symbol | other part of scientific name |
        | testus1 | specieius1 | g1 s2 wowza | BDL OTHER    |             |     |      |
        | genus   | blah       | common name | BDL OTHER    | s1          |     |      |
        | testus1 | specieius1 | g1 s2 wowza | BDL OTHER    | s2          |     |      |
        | testus2 | specieius2 | g1 s2 wowza | BDL OTHER    | s1          | a3  |      |
        | genusN  | speciesN   | gN sN wowza | BDL OTHER    |             |     | var3 |
        """

        j = self.run_through_process_views(csv)
        ierrors = self.extract_errors(j)

        # Errors for multiple species matches
        self.assertEqual(len(ierrors), 4)

        ie = SpeciesImportEvent.objects.get(pk=j['pk'])
        s1,s2,s3 = [s.pk for s in Species.objects.all()]

        s4s = Species(symbol='gnsn', scientific_name='',family='',
                      genus='genusN', species='speciesN', cultivar_name='',
                      other_part_of_name='var3', v_max_dbh=50.0, v_max_height=100.0)
        s4s.save()
        s4 = s4s.pk

        rows = ie.rows()
        matches = []
        for row in rows:
            row.validate_row()
            matches.append(row.cleaned[fields.species.ORIG_SPECIES])

        m1,m2,m3,m4,m5 = matches

        self.assertEqual(m1, {s1})
        self.assertEqual(m2, {s1})
        self.assertEqual(m3, {s1,s2})
        self.assertEqual(m4, {s1,s2,s3})
        self.assertEqual(m5, {s4})

    def test_all_species_data(self):
        csv = """
        | genus     | species     | common name | i-tree code  | usda symbol | alternative symbol |
        | newgenus1 | newspecies1 | g1 s2 wowza | BDL OTHER    | sym1        | a1    |
        """

        seid = self.run_through_commit_views(csv)
        ie = SpeciesImportEvent.objects.get(pk=seid)
        s = ie.rows().all()[0].species

        self.assertEqual(s.genus, 'newgenus1')
        self.assertEqual(s.species, 'newspecies1')
        self.assertEqual(s.common_name, 'g1 s2 wowza')
        self.assertEqual(s.symbol, 'sym1')
        self.assertEqual(s.alternate_symbol, 'a1')
        self.assertEqual(s.itree_code, 'BDL OTHER')

        tgtrsrc = { r.meta_species for r in
                    Resource.objects.filter(meta_species='BDL OTHER')}
        self.assertNotEqual(len(tgtrsrc), 0)
        self.assertEqual({r.meta_species for r in s.resource.all()},
                         tgtrsrc)

        csv = """
        | genus     | species     | common name | i-tree code  | cultivar | %s  | %s  |
        | newgenus2 | newspecies1 | g1 s2 wowza | BDL OTHER    | cvar     | sci | fam |
        """ % ('other part of scientific name', 'family')

        seid = self.run_through_commit_views(csv)
        ie = SpeciesImportEvent.objects.get(pk=seid)
        s = ie.rows().all()[0].species

        self.assertEqual(s.cultivar_name, 'cvar')
        self.assertEqual(s.family, 'fam')
        self.assertEqual(s.other_part_of_name, 'sci')

        csv = """
        | genus     | species     | common name | i-tree code  | %s   | %s    | %s   |
        | newgenus3 | newspecies1 | g1 s2 wowza | BDL OTHER    | true | true  | true |
        """ % ('native status', 'fall colors', 'palatable human')

        seid = self.run_through_commit_views(csv)
        ie = SpeciesImportEvent.objects.get(pk=seid)
        s = ie.rows().all()[0].species

        self.assertEqual(s.native_status, 'True')
        self.assertEqual(s.fall_conspicuous, True)
        self.assertEqual(s.palatable_human, True)

        csv = """
        | genus     | species     | common name | i-tree code  | %s   | %s      | %s   |
        | newgenus4 | newspecies1 | g1 s2 wowza | BDL OTHER    | true | summer  | fall |
        """ % ('flowering', 'flowering period', 'fruit or nut period')

        seid = self.run_through_commit_views(csv)
        ie = SpeciesImportEvent.objects.get(pk=seid)
        s = ie.rows().all()[0].species

        seasons = {k: v for (v,k) in settings.CHOICES['seasons']}

        self.assertEqual(s.flower_conspicuous, True)
        self.assertEqual(s.bloom_period, seasons['summer'])
        self.assertEqual(s.fruit_period, seasons['fall'])

        csv = """
        | genus     | species     | common name | i-tree code  | %s   | %s | %s | %s |
        | newgenus1 | newspecies1 | g1 s2 wowza | BDL OTHER    | true | 10 | 91 | fs |
        """ % ('wildlife', 'max diameter at breast height', 'max height', 'fact sheet')

        seid = self.run_through_commit_views(csv)
        ie = SpeciesImportEvent.objects.get(pk=seid)
        s = ie.rows().all()[0].species

        self.assertEqual(s.wildlife_value, True)
        self.assertEqual(s.fact_sheet, 'fs')
        self.assertEqual(s.v_max_dbh, 10)
        self.assertEqual(s.v_max_height, 91)


    def test_overrides_species(self):
        csv = """
        | genus   | species    | common name | i-tree code  | usda symbol | alternative symbol |
        | testus1 | specieius1 | g1 s2 wowza | BDL OTHER    |             |     |
        | genus   | blah       | common name | BDM OTHER    | s2          |     |
        """

        seid = self.run_through_commit_views(csv)
        ie = SpeciesImportEvent.objects.get(pk=seid)

        # Test to make sure things were updated
        s1 = Species.objects.get(symbol='s1')
        self.assertEqual(s1.genus, 'testus1')
        self.assertEqual(s1.species, 'specieius1')
        self.assertEqual(s1.common_name, 'g1 s2 wowza')

        tgtrsrc = { r.meta_species for r in
                    Resource.objects.filter(meta_species='BDL OTHER')}
        self.assertNotEqual(len(tgtrsrc), 0)
        self.assertEqual({r.meta_species for r in s1.resource.all()},
                         tgtrsrc)

        s2 = Species.objects.get(symbol='s2')
        self.assertEqual(s2.genus, 'genus')
        self.assertEqual(s2.species, 'blah')
        self.assertEqual(s2.common_name, 'common name')


        tgtrsrc = { r.meta_species for r in
                    Resource.objects.filter(meta_species='BDM OTHER')}
        self.assertNotEqual(len(tgtrsrc), 0)
        self.assertEqual({r.meta_species for r in s2.resource.all()},
                         tgtrsrc)

class SpeciesExportTests(TestCase):

    def setUp(self):
        Species.objects.create(symbol='S1GSC', scientific_name='', family='',
                               genus='g1', species='', cultivar_name='',
                               v_max_dbh=50.0, v_max_height=100.0)
        User.objects.create_user(username='foo',
                                 email='foo@bar.com',
                                 password='bar')
        self.client.login(username='foo', password='bar')

    def test_export_all_species(self):
        response = self.client.get('/importer/export/species/all')
        reader = csv.reader(response)
        reader_rows = [r for r in reader][1:]

        self.assertEqual('g1',
                         reader_rows[1][reader_rows[0].index('genus')])
        self.assertEqual('S1GSC',
                         reader_rows[1][reader_rows[0].index('usda symbol')])
        self.assertEqual('50',
                         reader_rows[1][reader_rows[0]
                         .index('max diameter at breast height')])
        self.assertEqual('100',
                         reader_rows[1][reader_rows[0].index('max height')])

class TreeIntegrationTests(IntegrationTests):

    def setUp(self):
        super(TreeIntegrationTests, self).setUp()

        settings.DBH_TO_INCHES_FACTOR = 1.0

    def rowconstructor(self):
        return TreeImportRow

    def import_type(self):
        return 'tree'

    def constructor(self):
        return TreeImportEvent

    def test_noerror_load(self):
        csv = """
        | point x | point y | diameter |
        | 34.2    | 29.2    | 12       |
        | 19.2    | 27.2    | 14       |
        """

        j = self.run_through_process_views(csv)

        # manually adding pk into the test case
        self.assertEqual({'status': 'success', 'rows': 2, 'pk': j['pk']}, j)

        ieid = self.run_through_commit_views(csv)
        ie = TreeImportEvent.objects.get(pk=ieid)

        rows = ie.treeimportrow_set.order_by('idx').all()

        self.assertEqual(len(rows), 2)

        plot1, plot2 = [r.plot for r in rows]
        self.assertIsNotNone(plot1)
        self.assertIsNotNone(plot2)

        self.assertEqual(int(plot1.geometry.x*10), 342)
        self.assertEqual(int(plot1.geometry.y*10), 292)
        self.assertEqual(plot1.current_tree().dbh, 12)

        self.assertEqual(int(plot2.geometry.x*10), 192)
        self.assertEqual(int(plot2.geometry.y*10), 272)
        self.assertEqual(plot2.current_tree().dbh, 14)

    def test_bad_structure(self):
        # Point Y -> PointY, expecting two errors
        csv = """
        | point x | pointy | diameter |
        | 34.2    | 24.2   | 12       |
        | 19.2    | 23.2   | 14       |
        """

        j = self.run_through_process_views(csv)
        self.assertEqual(len(j['errors']), 2)
        self.assertEqual({e['code'] for e in j['errors']},
                         {errors.MISSING_POINTS[0],
                          errors.UNMATCHED_FIELDS[0]})

    def test_faulty_data1(self):
        s1_g = Species(symbol='S1GSC', scientific_name='',family='',
                       genus='g1', species='', cultivar_name='',
                       v_max_dbh=50.0, v_max_height=100.0)
        s1_g.save()

        csv = """
        | point x | point y | diameter | read only | condition | genus | tree height |
        | -34.2   | 24.2    | q12      | true      | Dead      |       |         |
        | 323     | 23.2    | 14       | falseo    | Critical  |       |         |
        | 32.1    | 22.4    | 15       | true      | Dead      |       |         |
        | 33.2    | 19.1    | 32       | true      | Arg       |       |         |
        | 33.2    | q19.1   | -33.3    | true      | Dead      | gfail |         |
        | 32.1    | 12.1    |          | false     | Dead      | g1    | 200     |
        | 32.1    | 12.1    | 300      | false     | Dead      | g1    |         |
        | 11.1    | 12.1    |          | false     | Dead      |       |         |
        """

        gflds = [fields.trees.POINT_X, fields.trees.POINT_Y]
        sflds = [fields.trees.GENUS, fields.trees.SPECIES, fields.trees.CULTIVAR]

        j = self.run_through_process_views(csv)
        ierrors = self.extract_errors(j)
        self.assertEqual(ierrors['0'],
                         [(errors.FLOAT_ERROR[0],
                           [fields.trees.DIAMETER], None),
                          (errors.GEOM_OUT_OF_BOUNDS[0], gflds, None)])

        self.assertEqual(ierrors['1'],
                         [(errors.BOOL_ERROR[0],
                           [fields.trees.READ_ONLY], None),
                          (errors.INVALID_GEOM[0], gflds, None)])
        self.assertNotIn('2', ierrors)
        self.assertEqual(ierrors['3'],
                         [(errors.INVALID_CHOICE[0],
                           [fields.trees.TREE_CONDITION], 'conditions')])
        self.assertEqual(ierrors['4'],
                         [(errors.POS_FLOAT_ERROR[0],
                           [fields.trees.DIAMETER], None),
                          (errors.FLOAT_ERROR[0],
                           [fields.trees.POINT_Y], None),
                          (errors.MISSING_POINTS[0], gflds, None),
                          (errors.INVALID_SPECIES[0], sflds, 'gfail')])
        self.assertEqual(ierrors['5'],
                         [(errors.SPECIES_HEIGHT_TOO_HIGH[0],
                           [fields.trees.TREE_HEIGHT], 100.0)])
        self.assertEqual(ierrors['6'],
                         [(errors.SPECIES_DBH_TOO_HIGH[0],
                           [fields.trees.DIAMETER], 50.0)])
        self.assertEqual(ierrors['7'],
                         [(errors.EXCL_ZONE[0], gflds, None)])

    def test_faulty_data2(self):
        p1 = mkPlot(self.user, geom=Point(25.0000001,25.0000001))
        p1.save()

        string_too_long = 'a' * 256

        csv = """
        | point x    | point y    | opentreemap id number | tree steward | date planted |
        | 25.0000002 | 25.0000002 |          |              | 2012-02-18 |
        | 25.1000002 | 25.1000002 | 133      |              |            |
        | 25.1000002 | 25.1000002 | -3       |              | 2023-FF-33 |
        | 25.1000002 | 25.1000002 | bar      |              | 2012-02-91 |
        | 25.1000002 | 25.1000002 | %s       | %s           |            |
        """ % (p1.pk, string_too_long)

        gflds = [fields.trees.POINT_X, fields.trees.POINT_Y]

        j = self.run_through_process_views(csv)
        ierrors = self.extract_errors(j)
        self.assertEqual(ierrors['0'],
                         [(errors.NEARBY_TREES[0],
                           gflds,
                           [p1.pk])])
        self.assertEqual(ierrors['1'],
                         [(errors.INVALID_OTM_ID[0],
                           [fields.trees.OPENTREEMAP_ID_NUMBER],
                           None)])
        self.assertEqual(ierrors['2'],
                         [(errors.POS_INT_ERROR[0],
                           [fields.trees.OPENTREEMAP_ID_NUMBER],
                           None),
                          (errors.INVALID_DATE[0],
                           [fields.trees.DATE_PLANTED], None)])
        self.assertEqual(ierrors['3'],
                         [(errors.INT_ERROR[0],
                           [fields.trees.OPENTREEMAP_ID_NUMBER], None),
                          (errors.INVALID_DATE[0],
                           [fields.trees.DATE_PLANTED], None)])
        self.assertEqual(ierrors['4'],
                         [(errors.STRING_TOO_LONG[0],
                           [fields.trees.STEWARD], None)])

    def test_unit_changes(self):
        csv = """
        | point x | point y | tree height | canopy height | diameter | plot width | plot length |
        | 45.53   | 31.1    | 10.0        | 11.0          | 12.0     | 13.0       | 14.0        |
        """

        r = self.create_csv_request(csv, name='some name')
        ieid = process_csv(r, fileconstructor=self.constructor(),
                           plot_length_conversion_factor=1.5,
                           plot_width_conversion_factor=2.5,
                           diameter_conversion_factor=3.5,
                           tree_height_conversion_factor=4.5,
                           canopy_height_conversion_factor=5.5)

        req = HttpRequest()
        req.user = self.user
        self.login(req, username="jim", password="jim")

        commit(req, ieid, self.import_type())

        ie = TreeImportEvent.objects.get(pk=ieid)
        plot = ie.treeimportrow_set.all()[0].plot

        self.assertEqual(plot.width, 13.0*2.5)
        self.assertEqual(plot.length, 14.0*1.5)
        self.assertEqual(plot.current_tree().dbh, 3.5*12.0)
        self.assertEqual(plot.current_tree().height, 10.0 * 4.5)
        self.assertEqual(plot.current_tree().canopy_height, 11.0 * 5.5)


    def test_all_tree_data(self):
        s1_gsc = Species(symbol='S1G__', scientific_name='',family='',
                         genus='g1', species='s1', cultivar_name='c1')
        s1_gsc.save()

        csv = """
        | point x | point y | tree owner | tree steward | diameter | tree height |
        | 45.53   | 31.1    | jimmy      | jane         | 23.1     | 90.1        |
        """

        ieid = self.run_through_commit_views(csv)
        ie = TreeImportEvent.objects.get(pk=ieid)
        tree = ie.treeimportrow_set.all()[0].plot.current_tree()

        self.assertEqual(tree.tree_owner, 'jimmy')
        self.assertEqual(tree.steward_name, 'jane')
        self.assertEqual(tree.dbh, 23.1)
        self.assertEqual(tree.height, 90.1)

        csv = """
        | point x | point y | canopy height | genus | species | cultivar |
        | 45.59   | 31.1    | 112           |       |         |          |
        | 45.58   | 33.9    |               | g1    | s1      | c1       |
        """

        ieid = self.run_through_commit_views(csv)
        ie = TreeImportEvent.objects.get(pk=ieid)
        rows = ie.treeimportrow_set.order_by('idx').all()
        tree1 = rows[0].plot.current_tree()
        tree2 = rows[1].plot.current_tree()

        self.assertEqual(tree1.canopy_height, 112)
        self.assertIsNone(tree1.species)

        self.assertEqual(tree2.species.pk, s1_gsc.pk)

        csv = """
        | point x | point y | tree sponsor | date planted | read only | tree url    |
        | 45.12   | 55.12   | treeluvr     | 2012-02-03   | true      | http://spam |
        """

        ieid = self.run_through_commit_views(csv)
        ie = TreeImportEvent.objects.get(pk=ieid)
        tree = ie.treeimportrow_set.all()[0].plot.current_tree()

        dateplanted = date(2012,2,3)

        self.assertEqual(tree.sponsor, 'treeluvr')
        self.assertEqual(tree.date_planted, dateplanted)
        self.assertEqual(tree.readonly, True)
        self.assertEqual(tree.url, 'http://spam')

        valid_canopy_type = settings.CHOICES['canopy_conditions'][0][1]
        tgt_canopy_type = settings.CHOICES['canopy_conditions'][0][0]

        valid_cond_type = settings.CHOICES['conditions'][0][1]
        tgt_cond_type = settings.CHOICES['conditions'][0][0]

        valid_pest_type = settings.CHOICES['pests'][0][1]
        tgt_pest_type = settings.CHOICES['pests'][0][0]

        valid_lcl_type = settings.CHOICES['projects'][0][1]
        tgt_lcl_type = settings.CHOICES['projects'][0][0]

        csv = """
        | point x | point y | condition | canopy condition | pests and diseases | local projects |
        | 45.66   | 53.13   | %s        | %s               | %s                 | %s             |
        """ % (valid_cond_type, valid_canopy_type, valid_pest_type, valid_lcl_type)

        ieid = self.run_through_commit_views(csv)
        ie = TreeImportEvent.objects.get(pk=ieid)
        tree = ie.treeimportrow_set.all()[0].plot.current_tree()

        self.assertEqual(tree.condition, tgt_cond_type)
        self.assertEqual(tree.canopy_condition, tgt_canopy_type)
        self.assertEqual(tree.pests, tgt_pest_type)

        #TODO: Projects and Actions work differently...
        #      need to handle those cases
        # self.assertEqual(tree.projects, 'San Francisco Landmark')


    def test_all_plot_data(self):
        valid_plot_type = settings.CHOICES['plot_types'][0][1]
        tgt_plot_type = settings.CHOICES['plot_types'][0][0]

        csv = """
        | point x | point y | plot width | plot length | plot type | read only |
        | 45.53   | 31.1    | 19.2       | 13          | %s        | false     |
        """ % valid_plot_type

        ieid = self.run_through_commit_views(csv)
        ie = TreeImportEvent.objects.get(pk=ieid)
        plot = ie.treeimportrow_set.all()[0].plot

        self.assertEqual(int(plot.geometry.x*100), 4553)
        self.assertEqual(int(plot.geometry.y*100), 3110)
        self.assertEqual(plot.width, 19.2)
        self.assertEqual(plot.length, 13)
        self.assertEqual(plot.type, tgt_plot_type)
        self.assertEqual(plot.readonly, False)

        csv = """
        | point x | point y | sidewalk           | powerline conflict | notes |
        | 45.53   | 31.1    | Minor or No Damage | No                 | anote |
        """

        ieid = self.run_through_commit_views(csv)
        ie = TreeImportEvent.objects.get(pk=ieid)
        plot = ie.treeimportrow_set.all()[0].plot

        self.assertEqual(plot.sidewalk_damage, '1')
        self.assertEqual(plot.powerline_conflict_potential, '2')
        self.assertEqual(plot.owner_additional_properties, 'anote')

        csv = """
        | point x | point y | original id number | data source |
        | 45.53   | 31.1    | 443                | trees r us  |
        """

        ieid = self.run_through_commit_views(csv)
        ie = TreeImportEvent.objects.get(pk=ieid)
        plot = ie.treeimportrow_set.all()[0].plot

        self.assertEqual(plot.owner_orig_id, '443')
        self.assertEqual(plot.owner_additional_id, 'trees r us')

    def test_override_with_opentreemap_id(self):
        p1 = mkPlot(self.user, geom=Point(55.0,25.0))
        p1.save()

        csv = """
        | point x | point y | opentreemap id number | data source |
        | 45.53   | 31.1    | %s                    | trees r us  |
        """ % p1.pk

        self.run_through_commit_views(csv)

        p1b = Plot.objects.get(pk=p1.pk)
        self.assertEqual(int(p1b.geometry.x*100), 4553)
        self.assertEqual(int(p1b.geometry.y*100), 3110)

    def test_tree_present_works_as_expected(self):
        csv = """
        | point x | point y | tree present | diameter |
        | 45.53   | 31.1    | false        |          |
        | 45.63   | 32.1    | true         |          |
        | 45.73   | 33.1    | true         | 23       |
        | 45.93   | 33.1    | false        | 23       |
        """

        ieid = self.run_through_commit_views(csv)
        ie = TreeImportEvent.objects.get(pk=ieid)

        tests = [a.plot.current_tree() is not None
                 for a in ie.treeimportrow_set.order_by('idx').all()]

        self.assertEqual(tests,
                         [False, # No tree data and tree present is false
                          True,  # Force a tree in this spot (tree present=true)
                          True,  # Data, so ignore tree present settings
                          True])  # Data, so ignore tree present settings

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

from django.contrib import admin
admin.autodiscover()

urlpatterns = patterns(
    'importer.views',
    url(r'^$', 'list_imports', name='list_imports'),
    url(r'^create$', 'create', name='create'),
    url(r'^status/tree/(?P<import_event_id>\d+)$', 'show_tree_import_status', name='show_tree_import_status'),
    url(r'^status/species/(?P<import_event_id>\d+)$', 'show_species_import_status', name='show_species_import_status'),
    url(r'^update/(?P<import_event_row_id>\d+)$', 'update_row', name='update_row'),

    url(r'^export/species/all', 'export_all_species', name='export_all_species'),
    url(r'^export/species/(?P<import_event_id>\d+)$', 'export_single_species_import', name='export_single_species_import'),
    url(r'^export/tree/(?P<import_event_id>\d+)$', 'export_single_tree_import', name='export_single_tree_import'),

    # API
    url(r'^api/merge$', 'merge_species', name='merge'),
    url(r'^api/(?P<import_type>[a-z]+)/(?P<import_event_id>\d+)/results/(?P<subtype>[a-zA-Z]+)$', 'results', name='results'),
    url(r'^api/(?P<import_type>[a-z]+)/(?P<import_event_id>\d+)/commit$', 'commit', name='commit'),
    url(r'^api/(?P<import_type>[a-z]+)/(?P<import_event_id>\d+)/update$', 'update', name='update'),
    url(r'^api/species/(?P<import_event_id>\d+)/(?P<import_row_idx>\d+)/solve$', 'solve', name='solve'),
    url(r'^api/counts', 'counts', name='counts'),
    url(r'^api/species/similar', 'find_similar_species', name='find_similar_species'),
)

########NEW FILE########
__FILENAME__ = views
import csv
import json
from datetime import datetime

from django.db import transaction
from django.shortcuts import render_to_response
from django.template import RequestContext
from django.core.urlresolvers import reverse
from django.http import HttpResponse, HttpResponseRedirect
from django.conf import settings

from django.contrib.auth.decorators import login_required
from django.contrib.gis.geos import Point
from django.contrib.gis.measure import D
from django.contrib.auth.models import User

import fields
import io

from importer.tasks import run_import_event_validation,\
    commit_import_event

from treemap.models import Species, Neighborhood, Plot,\
    Tree, ExclusionMask, ImportEvent

from importer.models import TreeImportEvent, TreeImportRow,\
    SpeciesImportEvent, SpeciesImportRow, \
    GenericImportEvent, GenericImportRow

from importer import errors

def lowerkeys(h):
    h2 = {}
    for (k,v) in h.iteritems():
        k = k.lower().strip()
        if k != 'ignore':
            v = v.strip()
            if not isinstance(v, unicode):
                v = unicode(v, 'utf-8')

            h2[k] = v

    return h2

def find_similar_species(request):
    target = request.REQUEST['target']

    species = Species.objects\
                     .extra(
                         select={
                             'l': "levenshtein(genus || ' ' || species || ' ' || cultivar_name || ' ' || other_part_of_name, %s)"
                         },
                         select_params=(target,))\
                     .order_by('l')[0:2] # Take top 2

    output = [{fields.trees.GENUS: s.genus,
               fields.trees.SPECIES: s.species,
               fields.trees.CULTIVAR: s.cultivar_name,
               fields.trees.OTHER_PART_OF_NAME: s.other_part_of_name,
               'pk': s.pk} for s in species]

    return HttpResponse(
        json.dumps(output),
        content_type = 'application/json')

def counts(request):
    active_trees = TreeImportEvent\
        .objects\
        .order_by('id')\
        .exclude(status=GenericImportEvent.FINISHED_CREATING)\
        .exclude(status=GenericImportEvent.FINISHED_VERIFICATION)\
        .exclude(status=GenericImportEvent.FAILED_FILE_VERIFICATION)

    active_species = SpeciesImportEvent\
        .objects\
        .order_by('id')\
        .exclude(status=GenericImportEvent.FINISHED_CREATING)\
        .exclude(status=GenericImportEvent.FINISHED_VERIFICATION)\
        .exclude(status=GenericImportEvent.FAILED_FILE_VERIFICATION)

    output = {}
    output['trees'] = {t.pk: t.row_type_counts() for t in active_trees}
    output['species'] = {s.pk: s.row_type_counts() for s in active_species }

    return HttpResponse(
        json.dumps(output),
        content_type = 'application/json')

@login_required
def create(request):
    if request.REQUEST['type'] == 'tree':
        typ = 'tree'
        kwargs = {
            'fileconstructor': TreeImportEvent,

            'plot_length_conversion_factor':
            float(request.REQUEST.get('unit_plot_length', 1.0)),

            'plot_width_conversion_factor':
            float(request.REQUEST.get('unit_plot_width', 1.0)),

            'diameter_conversion_factor':
            float(request.REQUEST.get('unit_diameterh', 1.0)),

            'tree_height_conversion_factor':
            float(request.REQUEST.get('unit_tree_height', 1.0)),

            'canopy_height_conversion_factor':
            float(request.REQUEST.get('unit_canopy_height', 1.0))
        }
    elif request.REQUEST['type'] == 'species':
        typ = 'species'
        kwargs = {
            'fileconstructor': SpeciesImportEvent
        }

    pk = process_csv(request,**kwargs)

    return HttpResponseRedirect(reverse('importer:list_imports'))

@login_required
def list_imports(request):
    trees = TreeImportEvent.objects\
                           .order_by('id')

    active_trees = trees.exclude(
        status=GenericImportEvent.FINISHED_CREATING)

    finished_trees = trees.filter(
        status=GenericImportEvent.FINISHED_CREATING)

    species = SpeciesImportEvent.objects\
                                .order_by('id')

    active_species = species.exclude(
        status=GenericImportEvent.FINISHED_CREATING)

    finished_species = species.filter(
        status=GenericImportEvent.FINISHED_CREATING)

    all_species = Species.objects.all()
    all_species = sorted(all_species, key=lambda s: s.get_long_name())

    return render_to_response(
        'importer/list.html',
        RequestContext(
            request,
            {'trees_active': active_trees,
             'trees_finished': finished_trees,
             'species_active': active_species,
             'species_finished': finished_species,
             'all_species': all_species }))

@login_required
@transaction.commit_on_success
def merge_species(request):
    if not request.user.is_staff:
        raise Exception("Must be admin")

    species_to_delete_id = request.REQUEST['species_to_delete']
    species_to_replace_with_id = request.REQUEST['species_to_replace_with']

    species_to_delete = Species.objects.get(pk=species_to_delete_id)
    species_to_replace_with = Species.objects.get(pk=species_to_replace_with_id)

    if species_to_delete.pk == species_to_replace_with.pk:
        return HttpResponse(
            json.dumps({"error": "Must pick different species"}),
            content_type = 'application/json',
            status=400)

    Tree.objects.filter(species=species_to_delete)\
                .update(species=species_to_replace_with)

    species_to_delete.delete()

    # Force a tree count update
    species_to_replace_with.tree_count = 0
    species_to_replace_with.save()

    return HttpResponse(
        json.dumps({"status": "ok"}),
        content_type = 'application/json')

@login_required
def show_species_import_status(request, import_event_id):
    return show_import_status(request, import_event_id, SpeciesImportEvent)

@login_required
def show_tree_import_status(request, import_event_id):
    return show_import_status(request, import_event_id, TreeImportEvent)

@login_required
def show_import_status(request, import_event_id, Model):
    return render_to_response(
        'importer/status.html',
        RequestContext(
            request,
            {'event': Model.objects.get(pk=import_event_id)}))

@login_required
def update(request, import_type, import_event_id):
    if import_type == 'tree':
        Model = TreeImportEvent
    else:
        Model = SpeciesImportEvent

    rowdata = json.loads(request.REQUEST['row'])
    idx = rowdata['id']

    row = Model.objects.get(pk=import_event_id).rows().get(idx=idx)
    basedata = row.datadict

    for k,v in rowdata.iteritems():
        if k in basedata:
            basedata[k] = v

    row.datadict = basedata
    row.save()
    row.validate_row()

    return HttpResponse()


# TODO: Remove this method
@login_required
def update_row(request, import_event_row_id):
    update_keys = { key.split('update__')[1]
                    for key
                    in request.REQUEST.keys()
                    if key.startswith('update__') }

    row = TreeImportRow.objects.get(pk=import_event_row_id)

    basedata = row.datadict

    for key in update_keys:
        basedata[key] = request.REQUEST['update__%s' % key]

    row.datadict = basedata
    row.save()
    row.validate_row()

    return HttpResponseRedirect(reverse('importer:show_import_status',
                                        args=(row.import_event.pk,)))

@login_required
def results(request, import_event_id, import_type, subtype):
    """ Return a json array for each row of a given subtype
    where subtype is a valid status for a TreeImportRow
    """
    if import_type == 'tree':
        status_map = {
            'success': TreeImportRow.SUCCESS,
            'error': TreeImportRow.ERROR,
            'waiting': TreeImportRow.WAITING,
            'watch': TreeImportRow.WATCH,
            'verified': TreeImportRow.VERIFIED
        }

        Model = TreeImportEvent
    else:
        status_map = {
            'success': SpeciesImportRow.SUCCESS,
            'error': SpeciesImportRow.ERROR,
            'verified': SpeciesImportRow.VERIFIED,
        }
        Model = SpeciesImportEvent

    page_size = 10
    page = int(request.REQUEST.get('page', 0))
    page_start = page_size * page
    page_end = page_size * (page + 1)

    ie = Model.objects.get(pk=import_event_id)

    header = None
    output = {}

    if subtype == 'mergereq':
        query = ie.rows()\
                  .filter(merged=False)\
                  .exclude(status=SpeciesImportRow.ERROR)\
                  .order_by('idx')
    else:
        query = ie.rows()\
                  .filter(status=status_map[subtype])\
                  .order_by('idx')

    if import_type == 'species' and subtype == 'verified':
        query = query.filter(merged=True)

    count = query.count()
    total_pages = int(float(count) / page_size + 1)

    output['total_pages'] = total_pages
    output['count'] = count
    output['rows'] = []

    header_keys = None
    for row in query[page_start:page_end]:
        if header is None:
            header_keys = row.datadict.keys()

        data = {
            'row': row.idx,
            'errors': row.errors_as_array(),
            'data': [row.datadict[k] for k in header_keys]
        }


        # Generate diffs for merge requests
        if subtype == 'mergereq':
            # If errors.TOO_MANY_SPECIES we need to mine species
            # otherwise we can just do simple diff
            ecodes = dict([(e['code'],e['data']) for e in row.errors_as_array()])
            if errors.TOO_MANY_SPECIES[0] in ecodes:
                data['diffs'] = ecodes[errors.TOO_MANY_SPECIES[0]]
            elif errors.MERGE_REQ[0] in ecodes:
                data['diffs'] = [ecodes[errors.MERGE_REQ[0]]]

        if hasattr(row,'plot') and row.plot:
            data['plot_id'] = row.plot.pk

        if hasattr(row,'species') and row.species:
            data['species_id'] = row.species.pk

        output['rows'].append(data)

    output['field_order'] = [f.lower() for f \
                             in json.loads(ie.field_order)
                             if f != "ignore"]
    output['fields'] = header_keys or \
                       ie.rows()[0].datadict.keys()

    return HttpResponse(
        json.dumps(output),
        content_type = 'application/json')

def process_status(request, import_id, TheImportEvent):
    ie = TheImportEvent.objects.get(pk=import_id)

    resp = None
    if ie.errors:
        resp = {'status': 'file_error',
                'errors': json.loads(ie.errors)}
    else:
        errors = []
        for row in ie.rows():
            if row.errors:
                errors.append((row.idx, json.loads(row.errors)))

        if len(errors) > 0:
            resp = {'status': 'row_error',
                    'errors': dict(errors)}

    if resp is None:
        resp = {'status': 'success',
                'rows': ie.rows().count()}

    return HttpResponse(
        json.dumps(resp),
        content_type = 'application/json')

def solve(request, import_event_id, import_row_idx):
    ie = SpeciesImportEvent.objects.get(pk=import_event_id)
    row = ie.rows().get(idx=import_row_idx)

    data = dict(json.loads(request.REQUEST['data']))
    tgtspecies = request.REQUEST['species'];

    # Strip off merge errors
    merge_errors = { errors.TOO_MANY_SPECIES[0],
                     errors.MERGE_REQ[0] }


    ierrors = [e for e in row.errors_as_array()
               if e['code'] not in merge_errors];

    #TODO: Json handling is terrible.
    row.errors = json.dumps(ierrors)
    row.datadict = data

    if tgtspecies != 'new':
        row.species = Species.objects.get(pk=tgtspecies)

    row.merged = True
    row.save()

    rslt = row.validate_row()

    return HttpResponse(
        json.dumps({'status': 'ok',
                    'validates': rslt}),
        content_type = 'application/json')

@transaction.commit_manually
@login_required
def commit(request, import_event_id, import_type=None):
    #TODO:!!! NEED TO ADD TREES TO WATCH LIST
    #TODO:!!! Trees in the same import event should not cause
    #         proximity issues
    #TODO:!!! NEED TO INDICATE TREES TO BE ADDED TO WATCH LIST
    #TODO:!!! NEED TO CLEAR TILE CACHE
    #TODO:!!! If 'Plot' already exists on row *update* when changed
    if import_type == 'species':
        model = SpeciesImportEvent
    elif import_type == 'tree':
        model = TreeImportEvent
    else:
        raise Exception('invalid import type')

    ie = model.objects.get(pk=import_event_id)
    ie.status = GenericImportEvent.CREATING

    ie.save()
    ie.rows().update(status=GenericImportRow.WAITING)

    transaction.commit()

    commit_import_event.delay(ie)
    #TODO: Update tree counts for species

    return HttpResponse(
        json.dumps({'status': 'done'}),
        content_type = 'application/json')

@transaction.commit_manually
def process_csv(request, fileconstructor, **kwargs):
    files = request.FILES
    filename = files.keys()[0]
    fileobj = files[filename]

    fileobj = io.BytesIO(fileobj.read()\
                         .decode('latin1')\
                         .encode('utf-8'))


    owner = request.user
    ie = fileconstructor(file_name=filename,
                         owner=owner,
                         **kwargs)

    # If this is a tree import event it also needs an
    # 'old style' import event
    bie = ImportEvent(file_name=filename)
    bie.save()

    if hasattr(ie, 'base_import_event_id'):
        ie.base_import_event = bie

    ie.save()

    try:
        rows = create_rows_for_event(ie, fileobj)

        transaction.commit()

        if rows:
            run_import_event_validation.delay(ie)

    except Exception, e:
        raise
        ie.append_error(errors.GENERIC_ERROR, data=str(e))
        ie.status = GenericImportEvent.FAILED_FILE_VERIFICATION
        ie.save()

    return ie.pk


all_species_fields = (
    fields.species.GENUS,
    fields.species.SPECIES,
    fields.species.CULTIVAR,
    fields.species.OTHER_PART_OF_NAME,
    fields.species.COMMON_NAME,
    fields.species.USDA_SYMBOL,
    fields.species.ALT_SYMBOL,
    fields.species.ITREE_CODE,
    fields.species.FAMILY,
    fields.species.NATIVE_STATUS,
    fields.species.FALL_COLORS,
    fields.species.EDIBLE,
    fields.species.FLOWERING,
    fields.species.FLOWERING_PERIOD,
    fields.species.FRUIT_PERIOD,
    fields.species.WILDLIFE,
    fields.species.MAX_DIAMETER,
    fields.species.MAX_HEIGHT,
    fields.species.FACT_SHEET,
)

def _build_species_object(species, fieldmap, included_fields):
    obj = {}

    for k, v in fieldmap.iteritems():
        if v in included_fields:
            val = getattr(species, k)
            if not val is None:
                if isinstance(val, unicode):
                    newval = val.encode("utf-8")
                else:
                    newval = str(val)
                obj[v] = newval

    return obj


@login_required
def export_all_species(request):
    response = HttpResponse(mimetype='text/csv')

    # Maps [attr on species model] -> field name
    fieldmap = SpeciesImportRow.SPECIES_MAP

    include_extra_fields = request.GET.get('include_extra_fields', False)

    if include_extra_fields:
        extra_fields = (fields.species.ID,
                        fields.species.TREE_COUNT)
    else:
        extra_fields = tuple()

    included_fields = all_species_fields + extra_fields

    writer = csv.DictWriter(response, included_fields)
    writer.writeheader()

    for s in Species.objects.all():
        obj = _build_species_object(s, fieldmap, included_fields)
        writer.writerow(obj)

    response['Content-Disposition'] = 'attachment; filename=species.csv'

    return response

@login_required
def export_single_species_import(request, import_event_id):
    fieldmap = SpeciesImportRow.SPECIES_MAP

    ie = SpeciesImportEvent.objects.get(pk=import_event_id)

    response = HttpResponse(mimetype='text/csv')

    writer = csv.DictWriter(response, all_species_fields)
    writer.writeheader()

    for r in ie.rows():
        if r.species:
            obj = _build_species_object(r.species, fieldmap, all_species_fields)
        else:
            obj = lowerkeys(json.loads(r.data))

        writer.writerow(obj)

    response['Content-Disposition'] = 'attachment; filename=species.csv'

    return response

@login_required
def export_single_tree_import(request, import_event_id):
    plotmap = TreeImportRow.PLOT_MAP
    treemap = TreeImportRow.TREE_MAP

    all_fields = (
        fields.trees.POINT_X,
        fields.trees.POINT_Y,
        fields.trees.ADDRESS,
        fields.trees.PLOT_WIDTH,
        fields.trees.PLOT_LENGTH,
        fields.trees.PLOT_TYPE,
        fields.trees.POWERLINE_CONFLICT,
        fields.trees.SIDEWALK,
        fields.trees.READ_ONLY,
        fields.trees.OPENTREEMAP_ID_NUMBER,
        fields.trees.TREE_PRESENT,
        fields.trees.GENUS,
        fields.trees.SPECIES,
        fields.trees.CULTIVAR,
        fields.trees.OTHER_PART_OF_NAME,
        fields.trees.DIAMETER,
        fields.trees.TREE_HEIGHT,
        fields.trees.ORIG_ID_NUMBER,
        fields.trees.CANOPY_HEIGHT,
        fields.trees.DATE_PLANTED,
        fields.trees.TREE_CONDITION,
        fields.trees.CANOPY_CONDITION,
        fields.trees.ACTIONS,
        fields.trees.PESTS,
        fields.trees.URL,
        fields.trees.NOTES,
        fields.trees.OWNER,
        fields.trees.SPONSOR,
        fields.trees.STEWARD,
        fields.trees.LOCAL_PROJECTS,
        fields.trees.DATA_SOURCE)


    ie = TreeImportEvent.objects.get(pk=import_event_id)

    response = HttpResponse(mimetype='text/csv')

    writer = csv.DictWriter(response, all_fields)
    writer.writeheader()

    for r in ie.rows():
        if r.plot:
            obj = {}
            obj[fields.trees.POINT_X] = r.plot.geometry.x
            obj[fields.trees.POINT_Y] = r.plot.geometry.y

            obj[fields.trees.ADDRESS] = r.plot.address_street
            obj[fields.trees.PLOT_WIDTH] = r.plot.width
            obj[fields.trees.PLOT_LENGTH] = r.plot.length
            obj[fields.trees.READ_ONLY] = r.plot.readonly
            obj[fields.trees.OPENTREEMAP_ID_NUMBER] = r.plot.pk
            obj[fields.trees.ORIG_ID_NUMBER] = r.plot.owner_orig_id
            obj[fields.trees.DATA_SOURCE] = r.plot.owner_additional_id
            obj[fields.trees.NOTES] = r.plot.owner_additional_properties
            obj[fields.trees.SIDEWALK] = r.plot.sidewalk_damage
            obj[fields.trees.POWERLINE_CONFLICT] = r.plot.powerline_conflict_potential
            obj[fields.trees.PLOT_TYPE] = r.plot.type

            tree = r.plot.current_tree()

            obj[fields.trees.TREE_PRESENT] = tree is not None

            if tree:
                species = tree.species

                if species:
                    obj[fields.trees.GENUS] = species.genus
                    obj[fields.trees.SPECIES] = species.species
                    obj[fields.trees.CULTIVAR] = species.cultivar_name
                    obj[fields.trees.OTHER_PART_OF_NAME] = species.other_part_of_name


                obj[fields.trees.DIAMETER] = tree.dbh
                obj[fields.trees.TREE_HEIGHT] = tree.height
                obj[fields.trees.CANOPY_HEIGHT] = tree.canopy_height
                obj[fields.trees.DATE_PLANTED] = tree.date_planted
                obj[fields.trees.OWNER] = tree.tree_owner
                obj[fields.trees.SPONSOR] = tree.sponsor
                obj[fields.trees.STEWARD] = tree.steward_name
                obj[fields.trees.URL] = tree.url

                obj[fields.trees.TREE_CONDITION] = tree.condition
                obj[fields.trees.CANOPY_CONDITION] = tree.canopy_condition
                obj[fields.trees.PESTS] = tree.pests
                obj[fields.trees.LOCAL_PROJECTS] = tree.projects

        else:
            obj = lowerkeys(json.loads(r.data))

        writer.writerow(obj)

    response['Content-Disposition'] = 'attachment; filename=trees.csv'

    return response



def process_commit(request, import_id):
    ie = TreeImportEvent.objects.get(pk=import_id)

    rslt = commit_import_event(ie)

    # TODO: What to return here?
    return HttpResponse(
        json.dumps({'status': 'success'}),
        content_type = 'application/json')


def create_rows_for_event(importevent, csvfile):
    rows = []
    reader = csv.DictReader(csvfile)

    fieldnames = reader.fieldnames
    importevent.field_order = json.dumps(fieldnames)
    importevent.save()

    idx = 0
    for row in reader:
        rows.append(
            importevent.create_row(
                data=json.dumps(lowerkeys(row)),
                import_event=importevent, idx=idx))

        # First row
        if idx == 0:
            # Break out early if there was an error
            # with the basic file structure
            importevent.validate_main_file()
            if importevent.has_errors():
                return False

        idx += 1

    return rows

########NEW FILE########
__FILENAME__ = local_settings.example
import os

from choices import *

DATABASES = {
    'default': {
        'NAME': '{db_name}',
        'ENGINE': 'django.contrib.gis.db.backends.postgis',
        'USER': '{db_user}',                      # Not used with sqlite3.
        'PASSWORD': '{db_pass}',                  # Not used with sqlite3.
        'HOST': '{db_host}',                      # Set to empty string for localhost. Not used with sqlite3.
        'PORT': '{db_port}',
    }
}

STATIC_URL = '/static/'
FORCE_SCRIPT_NAME = ''
SITE_ROOT = '/'
MEDIA_URL = 'media/'

TILECACHE_URL = "{tc_url}"
TILECACHE_LAYER = "{tc_layer}"
TILECACHE_POLYGON_LAYER = "{tc_polygon_layer}"

GEOSERVER_GEO_LAYER = '{geo_layer}'
GEOSERVER_URL = '{geo_url}'
GEOSERVER_GEO_STYLE = "{geo_style}"

API_KEY_GOOGLE_ANALYTICS = "IGNORE"

OTM_VERSION="1.3"

SITE_LOCATION = 'New York'
COMPLETE_ARRAY = ['species','condition','sidewalk_damage','powerline_conflict_potential','canopy_height','canopy_condition','dbh','width','length','type']
REGION_NAME = 'New York'
PENDING_ON = False
MAP_CLICK_RADIUS = .0015 # in decimal degrees

BOUNDING_BOX = { # WKID 4326
    'left': -6.98318,
    'bottom': 49.864635,
    'right': 1.7689,
    'top': 58.078297
}

MAP_CENTER_LAT = 54.544
MAP_CENTER_LON = -2.79744

REPUTATION_SCORES = {
    'add tree': 25,
    'add plot': 25,
    'edit tree': 5,
    'edit plot': 5,
    'add stewardship': 5,
    'remove stewardship': -5,
    'edit verified': {
        'up': 5,
        'down': -10,
        'neutral': 1,
    },
}

EXTRAPOLATE_WITH_AVERAGE = True

#API_KEY_GOOGLE_MAP = ''
#API_KEY_GOOGLE_ANALYTICS = 'UA-23175691-1'

# pipeline minification settings
PIPELINE = False
PIPELINE_ROOT = os.path.dirname(__file__)
PIPELINE_URL = '/'
PIPELINE_YUI_BINARY = '/usr/bin/yui-compressor'
PIPELINE_YUI_JS_ARGUMENTS = '--nomunge'
PIPELINE_JS = {
    'base': {
        'source_filenames': (
            SITE_ROOT + 'static/js/jquery_mods.js',
            SITE_ROOT + 'static/treemap.js',
            SITE_ROOT + 'static/js/utils.js',
            SITE_ROOT + 'static/js/map.js',
            SITE_ROOT + 'static/js/map_init.js',
            SITE_ROOT + 'static/js/geocode.js',
            SITE_ROOT + 'static/js/page_init.js',
            SITE_ROOT + 'static/js/management.js',
            SITE_ROOT + 'static/js/comments.js',
        ),
        'output_filename': 'static/all_base.js',
    },
    'map': {
        'source_filenames': (
            SITE_ROOT + 'static/js/map.js',
            SITE_ROOT + 'static/js/threaded.js',
         ),
        'output_filename': 'static/all_map.js',
    }
}

ADMINS = (
    ('Admin1', 'you@know.who'),
)
MANAGERS = ADMINS
DEFAULT_FROM_EMAIL= 'who@are.you'
CONTACT_EMAILS = [DEFAULT_FROM_EMAIL]
EMAIL_MANAGERS = False

TILED_SEARCH_RESPONSE = False

# separate instance of tilecache for dynamic selection tiles
CACHE_SEARCH_TILES = True
CACHE_SEARCH_METHOD = 'disk' #'disk'
CACHE_SEARCH_DISK_PATH = os.path.join(os.path.dirname(__file__), 'local_tiles/')
MAPNIK_STYLESHEET = os.path.join(os.path.dirname(__file__), 'mapserver/stylesheet.xml')

CACHE_BACKEND = 'file:///tmp/trees_cache'

# django-registration
REGISTRATION_OPEN = True # defaults to True
ACCOUNT_ACTIVATION_DAYS = 5

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# If running in a Windows environment this must be set to the same as your
# system time zone.
TIME_ZONE = 'America/New_York'


SITE_ID = 1
ROOT_URL = ""

STATIC_ROOT = '/usr/local/otm/static'
MEDIA_ROOT = os.path.join(os.path.dirname(__file__), '..', 'media/')
MEDIA_URL = '/media/'
ADMIN_MEDIA_ROOT = os.path.join(os.path.dirname(__file__), '..', 'admin_media/')
ADMIN_MEDIA_PREFIX = '/admin_media/'

STATIC_DATA = os.path.join(os.path.dirname(__file__), '..', 'static/')

# Make this unique, and don't share it with anybody.
SECRET_KEY = 'insecure'

TEMPLATE_DIRS = (
    os.path.join(os.path.dirname(__file__), 'templates'),
    '/usr/local/otm/app/templates'
)

STATICFILES_DIRS = (
    '/usr/local/otm/app/static',
)

# required keys are addsame, add, edit and view. Values and order can change. Edit tree_add view to change/add allowed keys
ADD_FORM_TARGETS = [
    ('addsame', 'I want to add another tree using the same tree details'),
    ('add', 'I want to add another tree with new details'),
    ('edit','Let me continue editing this tree'),
    ('view', 'I\'m done!'),
]

ADD_FORM_TARGETS_DEFAULT = 'view'

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
from django.core.management import execute_manager
try:
    import settings # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n(If the file settings.py does indeed exist, it's causing an ImportError somehow.)\n" % __file__)
    sys.exit(1)

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = admin
from django.contrib.gis import admin
from polygons.models import TreeRegionPolygon, DBHClass, TreeRegionEntry

admin.site.register(DBHClass)
admin.site.register(TreeRegionEntry)

########NEW FILE########
__FILENAME__ = 0001_initial
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'TreeRegionPolygon'
        db.create_table('polygons_treeregionpolygon', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('region_id', self.gf('django.db.models.fields.FloatField')()),
            ('geometry', self.gf('django.contrib.gis.db.models.fields.PolygonField')()),
        ))
        db.send_create_signal('polygons', ['TreeRegionPolygon'])

        # Adding model 'DBHClass'
        db.create_table('polygons_dbhclass', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('label', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('dbh_min', self.gf('django.db.models.fields.FloatField')()),
            ('dbh_max', self.gf('django.db.models.fields.FloatField')()),
        ))
        db.send_create_signal('polygons', ['DBHClass'])

        # Adding model 'TreeRegionEntry'
        db.create_table('polygons_treeregionentry', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('polygon', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['polygons.TreeRegionPolygon'])),
            ('species', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['treemap.Species'])),
            ('dbhclass', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['polygons.DBHClass'])),
            ('count', self.gf('django.db.models.fields.IntegerField')()),
        ))
        db.send_create_signal('polygons', ['TreeRegionEntry'])


    def backwards(self, orm):
        # Deleting model 'TreeRegionPolygon'
        db.delete_table('polygons_treeregionpolygon')

        # Deleting model 'DBHClass'
        db.delete_table('polygons_dbhclass')

        # Deleting model 'TreeRegionEntry'
        db.delete_table('polygons_treeregionentry')


    models = {
        'polygons.dbhclass': {
            'Meta': {'object_name': 'DBHClass'},
            'dbh_max': ('django.db.models.fields.FloatField', [], {}),
            'dbh_min': ('django.db.models.fields.FloatField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'label': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'polygons.treeregionentry': {
            'Meta': {'object_name': 'TreeRegionEntry'},
            'count': ('django.db.models.fields.IntegerField', [], {}),
            'dbhclass': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['polygons.DBHClass']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'polygon': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['polygons.TreeRegionPolygon']"}),
            'species': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Species']"})
        },
        'polygons.treeregionpolygon': {
            'Meta': {'object_name': 'TreeRegionPolygon'},
            'geometry': ('django.contrib.gis.db.models.fields.PolygonField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'region_id': ('django.db.models.fields.FloatField', [], {})
        },
        'treemap.resource': {
            'Meta': {'object_name': 'Resource'},
            'aq_nox_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_nox_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_ozone_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_pm10_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_pm10_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_sox_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_sox_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_voc_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'bvoc_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_sequestered_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_storage_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'electricity_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'hydro_interception_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'meta_species': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'natural_gas_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'region': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'})
        },
        'treemap.species': {
            'Meta': {'object_name': 'Species'},
            'alternate_symbol': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'bloom_period': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'common_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'cultivar_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'fact_sheet': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'fall_conspicuous': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'family': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'flower_conspicuous': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'fruit_period': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'gender': ('django.db.models.fields.CharField', [], {'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'genus': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'itree_code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'native_status': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'other_part_of_name': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'palatable_human': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'plant_guide': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'resource': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['treemap.Resource']", 'null': 'True', 'symmetrical': 'False'}),
            'scientific_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'species': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'symbol': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'tree_count': ('django.db.models.fields.IntegerField', [], {'default': '0', 'db_index': 'True'}),
            'v_max_dbh': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'v_max_height': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'v_multiple_trunks': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'wildlife_value': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['polygons']
########NEW FILE########
__FILENAME__ = 0002_auto__add_field_treeregionpolygon_photo
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding field 'TreeRegionPolygon.photo'
        db.add_column('polygons_treeregionpolygon', 'photo',
                      self.gf('django.db.models.fields.files.ImageField')(max_length=100, null=True, blank=True),
                      keep_default=False)


    def backwards(self, orm):
        # Deleting field 'TreeRegionPolygon.photo'
        db.delete_column('polygons_treeregionpolygon', 'photo')


    models = {
        'polygons.dbhclass': {
            'Meta': {'object_name': 'DBHClass'},
            'dbh_max': ('django.db.models.fields.FloatField', [], {}),
            'dbh_min': ('django.db.models.fields.FloatField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'label': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'polygons.treeregionentry': {
            'Meta': {'object_name': 'TreeRegionEntry'},
            'count': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'dbhclass': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['polygons.DBHClass']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'polygon': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['polygons.TreeRegionPolygon']"}),
            'species': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Species']"})
        },
        'polygons.treeregionpolygon': {
            'Meta': {'object_name': 'TreeRegionPolygon'},
            'geometry': ('django.contrib.gis.db.models.fields.PolygonField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'photo': ('django.db.models.fields.files.ImageField', [], {'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'region_id': ('django.db.models.fields.FloatField', [], {})
        },
        'treemap.resource': {
            'Meta': {'object_name': 'Resource'},
            'aq_nox_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_nox_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_ozone_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_pm10_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_pm10_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_sox_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_sox_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_voc_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'bvoc_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_sequestered_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_storage_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'electricity_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'hydro_interception_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'meta_species': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'natural_gas_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'region': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'})
        },
        'treemap.species': {
            'Meta': {'object_name': 'Species'},
            'alternate_symbol': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'bloom_period': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'common_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'cultivar_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'fact_sheet': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'fall_conspicuous': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'family': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'flower_conspicuous': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'fruit_period': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'gender': ('django.db.models.fields.CharField', [], {'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'genus': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'itree_code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'native_status': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'other_part_of_name': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'palatable_human': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'plant_guide': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'resource': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['treemap.Resource']", 'null': 'True', 'symmetrical': 'False'}),
            'scientific_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'species': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'symbol': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'tree_count': ('django.db.models.fields.IntegerField', [], {'default': '0', 'db_index': 'True'}),
            'v_max_dbh': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'v_max_height': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'v_multiple_trunks': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'wildlife_value': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['polygons']
########NEW FILE########
__FILENAME__ = 0003_auto__add_treeregionentryaudit__add_treeregionpolygonaudit__add_field_
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'TreeRegionEntryAudit'
        db.create_table('polygons_treeregionentry_audit', (
            ('_audit_user_rep', self.gf('django.db.models.fields.IntegerField')()),
            ('_audit_diff', self.gf('django.db.models.fields.TextField')()),
            ('_audit_verified', self.gf('django.db.models.fields.IntegerField')()),
            ('polygon', self.gf('django.db.models.fields.related.ForeignKey')(related_name='_audit_treeregionentry', to=orm['polygons.TreeRegionPolygon'])),
            ('species', self.gf('django.db.models.fields.related.ForeignKey')(related_name='_audit_treeregionentry', to=orm['treemap.Species'])),
            ('dbhclass', self.gf('django.db.models.fields.related.ForeignKey')(related_name='_audit_treeregionentry', to=orm['polygons.DBHClass'])),
            ('count', self.gf('django.db.models.fields.IntegerField')(default=0)),
            ('last_updated', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, null=True, blank=True)),
            ('last_updated_by', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='_audit_treeregionentry_updated_by', null=True, to=orm['auth.User'])),
            ('_audit_id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('_audit_timestamp', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, db_index=True, blank=True)),
            ('_audit_change_type', self.gf('django.db.models.fields.CharField')(max_length=1)),
            ('id', self.gf('django.db.models.fields.IntegerField')(db_index=True)),
        ))
        db.send_create_signal('polygons', ['TreeRegionEntryAudit'])

        # Adding model 'TreeRegionPolygonAudit'
        db.create_table('polygons_treeregionpolygon_audit', (
            ('_audit_user_rep', self.gf('django.db.models.fields.IntegerField')()),
            ('_audit_diff', self.gf('django.db.models.fields.TextField')()),
            ('_audit_verified', self.gf('django.db.models.fields.IntegerField')()),
            ('region_id', self.gf('django.db.models.fields.FloatField')()),
            ('geometry', self.gf('django.contrib.gis.db.models.fields.PolygonField')()),
            ('photo', self.gf('django.db.models.fields.files.ImageField')(max_length=100, null=True, blank=True)),
            ('last_updated', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, null=True, blank=True)),
            ('last_updated_by', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='_audit_treeregionpolygon_updated_by', null=True, to=orm['auth.User'])),
            ('_audit_id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('_audit_timestamp', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, db_index=True, blank=True)),
            ('_audit_change_type', self.gf('django.db.models.fields.CharField')(max_length=1)),
            ('id', self.gf('django.db.models.fields.IntegerField')(db_index=True)),
        ))
        db.send_create_signal('polygons', ['TreeRegionPolygonAudit'])

        # Adding field 'TreeRegionEntry.last_updated'
        db.add_column('polygons_treeregionentry', 'last_updated',
                      self.gf('django.db.models.fields.DateTimeField')(auto_now=True, null=True, blank=True),
                      keep_default=False)

        # Adding field 'TreeRegionEntry.last_updated_by'
        db.add_column('polygons_treeregionentry', 'last_updated_by',
                      self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='treeregionentry_updated_by', null=True, to=orm['auth.User']),
                      keep_default=False)

        # Adding field 'TreeRegionPolygon.last_updated'
        db.add_column('polygons_treeregionpolygon', 'last_updated',
                      self.gf('django.db.models.fields.DateTimeField')(auto_now=True, null=True, blank=True),
                      keep_default=False)

        # Adding field 'TreeRegionPolygon.last_updated_by'
        db.add_column('polygons_treeregionpolygon', 'last_updated_by',
                      self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='treeregionpolygon_updated_by', null=True, to=orm['auth.User']),
                      keep_default=False)


    def backwards(self, orm):
        # Deleting model 'TreeRegionEntryAudit'
        db.delete_table('polygons_treeregionentry_audit')

        # Deleting model 'TreeRegionPolygonAudit'
        db.delete_table('polygons_treeregionpolygon_audit')

        # Deleting field 'TreeRegionEntry.last_updated'
        db.delete_column('polygons_treeregionentry', 'last_updated')

        # Deleting field 'TreeRegionEntry.last_updated_by'
        db.delete_column('polygons_treeregionentry', 'last_updated_by_id')

        # Deleting field 'TreeRegionPolygon.last_updated'
        db.delete_column('polygons_treeregionpolygon', 'last_updated')

        # Deleting field 'TreeRegionPolygon.last_updated_by'
        db.delete_column('polygons_treeregionpolygon', 'last_updated_by_id')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'polygons.dbhclass': {
            'Meta': {'object_name': 'DBHClass'},
            'dbh_max': ('django.db.models.fields.FloatField', [], {}),
            'dbh_min': ('django.db.models.fields.FloatField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'label': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'polygons.treeregionentry': {
            'Meta': {'object_name': 'TreeRegionEntry'},
            'count': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'dbhclass': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['polygons.DBHClass']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'null': 'True', 'blank': 'True'}),
            'last_updated_by': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'treeregionentry_updated_by'", 'null': 'True', 'to': "orm['auth.User']"}),
            'polygon': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['polygons.TreeRegionPolygon']"}),
            'species': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Species']"})
        },
        'polygons.treeregionentryaudit': {
            'Meta': {'ordering': "['-_audit_timestamp']", 'object_name': 'TreeRegionEntryAudit', 'db_table': "'polygons_treeregionentry_audit'"},
            '_audit_change_type': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
            '_audit_diff': ('django.db.models.fields.TextField', [], {}),
            '_audit_id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            '_audit_timestamp': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            '_audit_user_rep': ('django.db.models.fields.IntegerField', [], {}),
            '_audit_verified': ('django.db.models.fields.IntegerField', [], {}),
            'count': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'dbhclass': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'_audit_treeregionentry'", 'to': "orm['polygons.DBHClass']"}),
            'id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'null': 'True', 'blank': 'True'}),
            'last_updated_by': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'_audit_treeregionentry_updated_by'", 'null': 'True', 'to': "orm['auth.User']"}),
            'polygon': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'_audit_treeregionentry'", 'to': "orm['polygons.TreeRegionPolygon']"}),
            'species': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'_audit_treeregionentry'", 'to': "orm['treemap.Species']"})
        },
        'polygons.treeregionpolygon': {
            'Meta': {'object_name': 'TreeRegionPolygon'},
            'geometry': ('django.contrib.gis.db.models.fields.PolygonField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'null': 'True', 'blank': 'True'}),
            'last_updated_by': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'treeregionpolygon_updated_by'", 'null': 'True', 'to': "orm['auth.User']"}),
            'photo': ('django.db.models.fields.files.ImageField', [], {'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'region_id': ('django.db.models.fields.FloatField', [], {})
        },
        'polygons.treeregionpolygonaudit': {
            'Meta': {'ordering': "['-_audit_timestamp']", 'object_name': 'TreeRegionPolygonAudit', 'db_table': "'polygons_treeregionpolygon_audit'"},
            '_audit_change_type': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
            '_audit_diff': ('django.db.models.fields.TextField', [], {}),
            '_audit_id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            '_audit_timestamp': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            '_audit_user_rep': ('django.db.models.fields.IntegerField', [], {}),
            '_audit_verified': ('django.db.models.fields.IntegerField', [], {}),
            'geometry': ('django.contrib.gis.db.models.fields.PolygonField', [], {}),
            'id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'null': 'True', 'blank': 'True'}),
            'last_updated_by': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'_audit_treeregionpolygon_updated_by'", 'null': 'True', 'to': "orm['auth.User']"}),
            'photo': ('django.db.models.fields.files.ImageField', [], {'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'region_id': ('django.db.models.fields.FloatField', [], {})
        },
        'treemap.resource': {
            'Meta': {'object_name': 'Resource'},
            'aq_nox_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_nox_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_ozone_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_pm10_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_pm10_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_sox_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_sox_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_voc_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'bvoc_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_sequestered_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_storage_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'electricity_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'hydro_interception_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'meta_species': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'natural_gas_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'region': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'})
        },
        'treemap.species': {
            'Meta': {'object_name': 'Species'},
            'alternate_symbol': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'bloom_period': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'common_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'cultivar_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'fact_sheet': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'fall_conspicuous': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'family': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'flower_conspicuous': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'fruit_period': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'gender': ('django.db.models.fields.CharField', [], {'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'genus': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'itree_code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'native_status': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'other_part_of_name': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'palatable_human': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'plant_guide': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'resource': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['treemap.Resource']", 'null': 'True', 'symmetrical': 'False'}),
            'scientific_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'species': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'symbol': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'tree_count': ('django.db.models.fields.IntegerField', [], {'default': '0', 'db_index': 'True'}),
            'v_max_dbh': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'v_max_height': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'v_multiple_trunks': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'wildlife_value': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['polygons']
########NEW FILE########
__FILENAME__ = 0004_remove_nulls
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        us = orm['auth.User'].objects.all()

        if us.count() > 0:
            u = us[0]
        else:
            u = None

        def fixuptable(T):
            T.objects.filter(last_updated__isnull=True)\
                     .update(last_updated=datetime.datetime.now())
            T.objects.filter(last_updated_by__isnull=True)\
                     .update(last_updated_by=u)

        fixuptable(orm.TreeRegionEntryAudit)
        fixuptable(orm.TreeRegionEntry)
        fixuptable(orm.TreeRegionPolygon)
        fixuptable(orm.TreeRegionPolygonAudit)

    def backwards(self, orm):
        pass

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'polygons.dbhclass': {
            'Meta': {'object_name': 'DBHClass'},
            'dbh_max': ('django.db.models.fields.FloatField', [], {}),
            'dbh_min': ('django.db.models.fields.FloatField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'label': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'polygons.treeregionentry': {
            'Meta': {'object_name': 'TreeRegionEntry'},
            'count': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'dbhclass': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['polygons.DBHClass']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'null': 'True', 'blank': 'True'}),
            'last_updated_by': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'treeregionentry_updated_by'", 'null': 'True', 'to': "orm['auth.User']"}),
            'polygon': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['polygons.TreeRegionPolygon']"}),
            'species': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Species']"})
        },
        'polygons.treeregionentryaudit': {
            'Meta': {'ordering': "['-_audit_timestamp']", 'object_name': 'TreeRegionEntryAudit', 'db_table': "'polygons_treeregionentry_audit'"},
            '_audit_change_type': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
            '_audit_diff': ('django.db.models.fields.TextField', [], {}),
            '_audit_id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            '_audit_timestamp': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            '_audit_user_rep': ('django.db.models.fields.IntegerField', [], {}),
            '_audit_verified': ('django.db.models.fields.IntegerField', [], {}),
            'count': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'dbhclass': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'_audit_treeregionentry'", 'to': "orm['polygons.DBHClass']"}),
            'id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'null': 'True', 'blank': 'True'}),
            'last_updated_by': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'_audit_treeregionentry_updated_by'", 'null': 'True', 'to': "orm['auth.User']"}),
            'polygon': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'_audit_treeregionentry'", 'to': "orm['polygons.TreeRegionPolygon']"}),
            'species': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'_audit_treeregionentry'", 'to': "orm['treemap.Species']"})
        },
        'polygons.treeregionpolygon': {
            'Meta': {'object_name': 'TreeRegionPolygon'},
            'geometry': ('django.contrib.gis.db.models.fields.PolygonField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'null': 'True', 'blank': 'True'}),
            'last_updated_by': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'treeregionpolygon_updated_by'", 'null': 'True', 'to': "orm['auth.User']"}),
            'photo': ('django.db.models.fields.files.ImageField', [], {'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'region_id': ('django.db.models.fields.FloatField', [], {})
        },
        'polygons.treeregionpolygonaudit': {
            'Meta': {'ordering': "['-_audit_timestamp']", 'object_name': 'TreeRegionPolygonAudit', 'db_table': "'polygons_treeregionpolygon_audit'"},
            '_audit_change_type': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
            '_audit_diff': ('django.db.models.fields.TextField', [], {}),
            '_audit_id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            '_audit_timestamp': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            '_audit_user_rep': ('django.db.models.fields.IntegerField', [], {}),
            '_audit_verified': ('django.db.models.fields.IntegerField', [], {}),
            'geometry': ('django.contrib.gis.db.models.fields.PolygonField', [], {}),
            'id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'null': 'True', 'blank': 'True'}),
            'last_updated_by': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'_audit_treeregionpolygon_updated_by'", 'null': 'True', 'to': "orm['auth.User']"}),
            'photo': ('django.db.models.fields.files.ImageField', [], {'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'region_id': ('django.db.models.fields.FloatField', [], {})
        },
        'treemap.resource': {
            'Meta': {'object_name': 'Resource'},
            'aq_nox_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_nox_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_ozone_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_pm10_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_pm10_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_sox_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_sox_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_voc_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'bvoc_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_sequestered_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_storage_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'electricity_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'hydro_interception_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'meta_species': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'natural_gas_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'region': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'})
        },
        'treemap.species': {
            'Meta': {'object_name': 'Species'},
            'alternate_symbol': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'bloom_period': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'common_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'cultivar_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'fact_sheet': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'fall_conspicuous': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'family': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'flower_conspicuous': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'fruit_period': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'gender': ('django.db.models.fields.CharField', [], {'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'genus': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'itree_code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'native_status': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'other_part_of_name': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'palatable_human': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'plant_guide': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'resource': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['treemap.Resource']", 'null': 'True', 'symmetrical': 'False'}),
            'scientific_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'species': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'symbol': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'tree_count': ('django.db.models.fields.IntegerField', [], {'default': '0', 'db_index': 'True'}),
            'v_max_dbh': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'v_max_height': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'v_multiple_trunks': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'wildlife_value': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['polygons']

########NEW FILE########
__FILENAME__ = 0005_auto__chg_field_treeregionentryaudit_last_updated__chg_field_treeregio
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):

        # Changing field 'TreeRegionEntryAudit.last_updated'
        db.alter_column('polygons_treeregionentry_audit', 'last_updated', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, default=datetime.datetime(2013, 6, 21, 0, 0)))

        # Changing field 'TreeRegionEntryAudit.last_updated_by'
        db.alter_column('polygons_treeregionentry_audit', 'last_updated_by_id', self.gf('django.db.models.fields.related.ForeignKey')(default=None, to=orm['auth.User']))

        # Changing field 'TreeRegionEntry.last_updated'
        db.alter_column('polygons_treeregionentry', 'last_updated', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, default=datetime.datetime(2013, 6, 21, 0, 0)))

        # Changing field 'TreeRegionEntry.last_updated_by'
        db.alter_column('polygons_treeregionentry', 'last_updated_by_id', self.gf('django.db.models.fields.related.ForeignKey')(default=None, to=orm['auth.User']))

        # Changing field 'TreeRegionPolygonAudit.last_updated'
        db.alter_column('polygons_treeregionpolygon_audit', 'last_updated', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, default=datetime.datetime(2013, 6, 21, 0, 0)))

        # Changing field 'TreeRegionPolygonAudit.last_updated_by'
        db.alter_column('polygons_treeregionpolygon_audit', 'last_updated_by_id', self.gf('django.db.models.fields.related.ForeignKey')(default=None, to=orm['auth.User']))

        # Changing field 'TreeRegionPolygon.last_updated'
        db.alter_column('polygons_treeregionpolygon', 'last_updated', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, default=datetime.datetime(2013, 6, 21, 0, 0)))

        # Changing field 'TreeRegionPolygon.last_updated_by'
        db.alter_column('polygons_treeregionpolygon', 'last_updated_by_id', self.gf('django.db.models.fields.related.ForeignKey')(default=None, to=orm['auth.User']))

    def backwards(self, orm):

        # Changing field 'TreeRegionEntryAudit.last_updated'
        db.alter_column('polygons_treeregionentry_audit', 'last_updated', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, null=True))

        # Changing field 'TreeRegionEntryAudit.last_updated_by'
        db.alter_column('polygons_treeregionentry_audit', 'last_updated_by_id', self.gf('django.db.models.fields.related.ForeignKey')(null=True, to=orm['auth.User']))

        # Changing field 'TreeRegionEntry.last_updated'
        db.alter_column('polygons_treeregionentry', 'last_updated', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, null=True))

        # Changing field 'TreeRegionEntry.last_updated_by'
        db.alter_column('polygons_treeregionentry', 'last_updated_by_id', self.gf('django.db.models.fields.related.ForeignKey')(null=True, to=orm['auth.User']))

        # Changing field 'TreeRegionPolygonAudit.last_updated'
        db.alter_column('polygons_treeregionpolygon_audit', 'last_updated', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, null=True))

        # Changing field 'TreeRegionPolygonAudit.last_updated_by'
        db.alter_column('polygons_treeregionpolygon_audit', 'last_updated_by_id', self.gf('django.db.models.fields.related.ForeignKey')(null=True, to=orm['auth.User']))

        # Changing field 'TreeRegionPolygon.last_updated'
        db.alter_column('polygons_treeregionpolygon', 'last_updated', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, null=True))

        # Changing field 'TreeRegionPolygon.last_updated_by'
        db.alter_column('polygons_treeregionpolygon', 'last_updated_by_id', self.gf('django.db.models.fields.related.ForeignKey')(null=True, to=orm['auth.User']))

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'polygons.dbhclass': {
            'Meta': {'object_name': 'DBHClass'},
            'dbh_max': ('django.db.models.fields.FloatField', [], {}),
            'dbh_min': ('django.db.models.fields.FloatField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'label': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'polygons.treeregionentry': {
            'Meta': {'object_name': 'TreeRegionEntry'},
            'count': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'dbhclass': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['polygons.DBHClass']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'last_updated_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'treeregionentry_updated_by'", 'to': "orm['auth.User']"}),
            'polygon': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['polygons.TreeRegionPolygon']"}),
            'species': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Species']"})
        },
        'polygons.treeregionentryaudit': {
            'Meta': {'ordering': "['-_audit_timestamp']", 'object_name': 'TreeRegionEntryAudit', 'db_table': "'polygons_treeregionentry_audit'"},
            '_audit_change_type': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
            '_audit_diff': ('django.db.models.fields.TextField', [], {}),
            '_audit_id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            '_audit_timestamp': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            '_audit_user_rep': ('django.db.models.fields.IntegerField', [], {}),
            '_audit_verified': ('django.db.models.fields.IntegerField', [], {}),
            'count': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'dbhclass': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'_audit_treeregionentry'", 'to': "orm['polygons.DBHClass']"}),
            'id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'last_updated_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'_audit_treeregionentry_updated_by'", 'to': "orm['auth.User']"}),
            'polygon': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'_audit_treeregionentry'", 'to': "orm['polygons.TreeRegionPolygon']"}),
            'species': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'_audit_treeregionentry'", 'to': "orm['treemap.Species']"})
        },
        'polygons.treeregionpolygon': {
            'Meta': {'object_name': 'TreeRegionPolygon'},
            'geometry': ('django.contrib.gis.db.models.fields.PolygonField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'last_updated_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'treeregionpolygon_updated_by'", 'to': "orm['auth.User']"}),
            'photo': ('django.db.models.fields.files.ImageField', [], {'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'region_id': ('django.db.models.fields.FloatField', [], {})
        },
        'polygons.treeregionpolygonaudit': {
            'Meta': {'ordering': "['-_audit_timestamp']", 'object_name': 'TreeRegionPolygonAudit', 'db_table': "'polygons_treeregionpolygon_audit'"},
            '_audit_change_type': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
            '_audit_diff': ('django.db.models.fields.TextField', [], {}),
            '_audit_id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            '_audit_timestamp': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            '_audit_user_rep': ('django.db.models.fields.IntegerField', [], {}),
            '_audit_verified': ('django.db.models.fields.IntegerField', [], {}),
            'geometry': ('django.contrib.gis.db.models.fields.PolygonField', [], {}),
            'id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'last_updated_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'_audit_treeregionpolygon_updated_by'", 'to': "orm['auth.User']"}),
            'photo': ('django.db.models.fields.files.ImageField', [], {'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'region_id': ('django.db.models.fields.FloatField', [], {})
        },
        'treemap.resource': {
            'Meta': {'object_name': 'Resource'},
            'aq_nox_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_nox_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_ozone_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_pm10_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_pm10_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_sox_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_sox_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_voc_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'bvoc_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_sequestered_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_storage_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'electricity_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'hydro_interception_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'meta_species': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'natural_gas_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'region': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'})
        },
        'treemap.species': {
            'Meta': {'object_name': 'Species'},
            'alternate_symbol': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'bloom_period': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'common_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'cultivar_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'fact_sheet': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'fall_conspicuous': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'family': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'flower_conspicuous': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'fruit_period': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'gender': ('django.db.models.fields.CharField', [], {'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'genus': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'itree_code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'native_status': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'other_part_of_name': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'palatable_human': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'plant_guide': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'resource': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['treemap.Resource']", 'null': 'True', 'symmetrical': 'False'}),
            'scientific_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'species': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'symbol': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'tree_count': ('django.db.models.fields.IntegerField', [], {'default': '0', 'db_index': 'True'}),
            'v_max_dbh': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'v_max_height': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'v_multiple_trunks': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'wildlife_value': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['polygons']

########NEW FILE########
__FILENAME__ = models
from django.conf import settings
from django.contrib.gis.db import models

from treemap.models import Species, User
from treemap import audit

class TreeRegionPolygon(models.Model):
    region_id = models.FloatField()
    geometry = models.PolygonField(srid=4326)

    photo = models.ImageField(upload_to="polygons/%Y/%m/%d",null=True,blank=True)
    objects = models.GeoManager()

    # required for audit trail
    history = audit.AuditTrail()
    last_updated = models.DateTimeField(auto_now=True)
    last_updated_by = models.ForeignKey(User,
                                        related_name='treeregionpolygon_updated_by')

    def __unicode__(self):
        return u"Polygon #%s, Region ID: %s" % (self.pk, self.region_id)

class DBHClass(models.Model):
    label = models.CharField(max_length=255)
    dbh_min = models.FloatField()
    dbh_max = models.FloatField()

    def __unicode__(self):
        return u"DBH Class #%s: %s (%s - %s)" % \
            (self.pk, self.label, self.dbh_min, self.dbh_max)

class TreeRegionEntry(models.Model):
    polygon = models.ForeignKey(TreeRegionPolygon)
    species = models.ForeignKey(Species)
    dbhclass = models.ForeignKey(DBHClass)
    count = models.IntegerField(default=0)

    objects = models.GeoManager()

    # required for audit trail
    history = audit.AuditTrail()
    last_updated = models.DateTimeField(auto_now=True)
    last_updated_by = models.ForeignKey(User,
                                        related_name='treeregionentry_updated_by')

    def __unicode__(self):
        return u"%s, Species: %s, Count: %s" % \
            (str(self.polygon), str(self.species), self.count)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *
from views import *

urlpatterns = patterns('',
    (r'^search/$', polygon_search),
    (r'^recent/$', recent_edits),
    (r'^(?P<polygon_id>[0-9]+)/$', polygon_view),
    (r'^(?P<polygon_id>[0-9]+)/edit$', polygon_edit),
    (r'^(?P<polygon_id>[0-9]+)/update$', polygon_update),
    (r'^(?P<polygon_id>[0-9]+)/photo$', polygon_update_photo),
)

########NEW FILE########
__FILENAME__ = views
import json

from django.http import HttpResponse, HttpResponseRedirect
from django.template import RequestContext
from django.shortcuts import render_to_response
from django.core.urlresolvers import reverse
from django.core.exceptions import PermissionDenied
from django.core.files.base import ContentFile

from django.contrib.auth.decorators import login_required
from django.contrib.gis.geos import Point

from models import TreeRegionPolygon, TreeRegionEntry, DBHClass
from treemap.models import Species

def polygons2dict(polygons):
    polys = {}
    for polygon in polygons:
        entries = TreeRegionEntry.objects.filter(polygon=polygon)

        data = {e.species.pk: {} for e in entries}
        for entry in entries:
            species = data[entry.species.pk]
            species[entry.dbhclass.label] = entry.count

        polys[polygon.pk] = data

    return polys

def merge_histories(qs, to_dict_fn):
    edits_to_each_object = [object.history.all() for object in qs]

    merged_edits = []
    for edits in edits_to_each_object:
        for edit in edits:
            if edit._audit_diff:
                merged_edits.append(to_dict_fn(edit))
    return merged_edits

def entry_edit_to_dict(edit):
    return {
        'polygon': edit.polygon.id,
        'last_updated_by': edit.last_updated_by,
        'last_updated': edit.last_updated,
        'species': edit.species,
        'dbhclass': edit.dbhclass,
        'audit_diff': edit._audit_diff,
    }

def polygon_edit_to_dict(edit):
    return {
        'polygon': edit.id,
        'last_updated_by': edit.last_updated_by,
        'last_updated': edit.last_updated,
        'species': None,
        'dbhclass': None,
        'audit_diff': edit._audit_diff,
    }

def get_recent_edits_for_polygon(polygon_id):

    polygon = TreeRegionPolygon.objects.get(id=polygon_id)

    # first, get edits to the actual polygon
    # which should only be photo changes.
    polygon_edits = polygon.history.all()

    polygon_entries = TreeRegionEntry.objects.filter(polygon=polygon_id)

    entry_edits = merge_histories(polygon_entries, entry_edit_to_dict)

    all_edits = []

    all_edits += map(polygon_edit_to_dict, list(polygon_edits))

    all_edits += list(entry_edits)

    sort_by_recent_updates(all_edits)

    return all_edits

def sort_by_recent_updates(seq):
    seq.sort(key=(lambda x: x['last_updated']), reverse=True)

def polygon_search(request):
    id = request.GET.get('id', None)

    if id:
        polygons = TreeRegionPolygon.objects.filter(pk=id)
    else:
        lat = float(request.GET['lat'])
        lon = float(request.GET['lon'])

        point = Point(lon, lat, srid=4326)

        polygons = TreeRegionPolygon.objects.filter(geometry__contains=point)

    polys = {}

    for polygon in polygons:
        entries = TreeRegionEntry.objects.filter(polygon=polygon,count__gt=0)

        species = list({e.species.pk for e in entries})
        classes = {e.dbhclass.pk: e.dbhclass for e in entries}.values()

        sorted(classes, key=lambda a: a.dbh_min)

        polys[polygon.pk] = {"species": species,
                             "classes": [c.label for c in classes]}

    return HttpResponse(json.dumps(polys),
                        content_type='application/json')

@login_required
def polygon_update(request, polygon_id):
    rep = request.user.reputation

    if rep.reputation < 1000:
        raise PermissionDenied('%s cannot access this view because they do not have the required permission' % request.user.username)

    polygon = TreeRegionPolygon.objects.get(pk=polygon_id)

    all_species = []

    for key in request.POST.keys():
        if key.startswith('pval_'):
            new_data = key.split('_')[1:]
            (pgonid, speciesid, dbhid) = new_data
            if pgonid != polygon_id:
                raise Exception("Invalid polygon id: %s" % pgonid)

            species = Species.objects.get(pk=speciesid)

            t, created = TreeRegionEntry.objects.get_or_create(
                polygon=polygon,
                dbhclass=DBHClass.objects.get(pk=dbhid),
                species=species,
                last_updated_by=request.user)

            all_species.append(species)

            old_count = None if created else t.count
            new_count = int(request.POST[key])
            t.count = new_count

            if old_count != new_count:
                t._audit_diff = "Changed count from %s to %s" % (old_count, new_count)

            t.save()

    TreeRegionEntry.objects\
                   .filter(polygon=polygon)\
                   .exclude(species__in=all_species)\
                   .delete()

    return HttpResponseRedirect(
        reverse('polygons.views.polygon_view', args=(polygon_id,)))

@login_required
def polygon_edit(request, polygon_id):
    rep = request.user.reputation

    if rep.reputation < 1000:
        raise PermissionDenied('%s cannot access this view because they do not have the required permission' % request.user.username)

    return polygon_view(request, polygon_id, template='polygons/edit.html')

@login_required
def polygon_update_photo(request, polygon_id):
    polygon = TreeRegionPolygon.objects.get(pk=polygon_id)

    rfile = request.FILES['photo']
    file_content = ContentFile(rfile.read())
    fname = rfile.name

    polygon.photo.save(fname, file_content, save=False)

    polygon.last_updated_by = request.user
    polygon._audit_diff = "Uploaded a new photo"
    polygon.save()

    polygon_url = reverse('polygons.views.polygon_view', args=(polygon_id,))
    next_url = request.REQUEST.get('currentpage', polygon_url)

    return HttpResponseRedirect(next_url)


def polygon_view(request, polygon_id,template='polygons/view.html'):

    showedit = request.user.is_authenticated() and \
               request.user.reputation.reputation >= 1000

    polygon = TreeRegionPolygon.objects.get(pk=polygon_id)
    alldbhs = DBHClass.objects.order_by("dbh_min")

    poly = []
    for (species, dbhs) in polygons2dict([polygon])[polygon.pk].iteritems():
        s = Species.objects.get(pk=species)
        row = [[s.pk,s.scientific_name]]

        for dbh in alldbhs:
            row.append([dbh.pk , dbhs.get(dbh.label,"")])

        poly.append(row)

    recent_edits = get_recent_edits_for_polygon(polygon_id)[:5]

    return render_to_response(
        template,
        RequestContext(
            request,
            {'showedit': showedit,
             'polygonobj': polygon,
             'polygon': poly,
             'recent_edits': recent_edits,
             'classes': alldbhs}))

@login_required
def recent_edits(request):
    rep = request.user.reputation

    if rep.reputation < 1000:
        raise PermissionDenied('%s cannot access this view because they do not have the required permission' % request.user.username)

    recent_edits = []
    recent_entries = TreeRegionEntry.objects.order_by('-polygon__last_updated')[:100]
    recent_edits += merge_histories(recent_entries, entry_edit_to_dict)
    recent_photos = TreeRegionPolygon.objects.filter(last_updated__isnull=False).order_by('-last_updated')[:100]
    recent_edits += merge_histories(recent_photos, polygon_edit_to_dict)

    sort_by_recent_updates(recent_edits)
    return render_to_response('polygons/recent_edits.html',
                              RequestContext(request,
                                  {'recent_edits': recent_edits}))

########NEW FILE########
__FILENAME__ = admin
from django.contrib.gis import admin
from django.contrib.gis.admin.options import OSMGeoAdmin
from profiles.models import *

class UserProfileAdmin(OSMGeoAdmin):
    actions_on_top = False
    #list_display = ('user', 'full_name','email','account_activated','remove',)
    #list_filter = (' ',)

admin.site.register(UserProfile, UserProfileAdmin)

########NEW FILE########
__FILENAME__ = 0001_initial
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'UserProfile'
        db.create_table('profiles_userprofile', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'], unique=True)),
            ('volunteer', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('updates', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('zip_code', self.gf('django.db.models.fields.CharField')(max_length=6, null=True, blank=True)),
            ('photo', self.gf('django.db.models.fields.files.ImageField')(max_length=200, null=True, blank=True)),
            ('site_edits', self.gf('django.db.models.fields.IntegerField')(default=0)),
            ('uid', self.gf('django.db.models.fields.IntegerField')(null=True, blank=True)),
            ('active', self.gf('django.db.models.fields.BooleanField')(default=True)),
        ))
        db.send_create_signal('profiles', ['UserProfile'])


    def backwards(self, orm):
        # Deleting model 'UserProfile'
        db.delete_table('profiles_userprofile')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'profiles.userprofile': {
            'Meta': {'object_name': 'UserProfile'},
            'active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'photo': ('django.db.models.fields.files.ImageField', [], {'max_length': '200', 'null': 'True', 'blank': 'True'}),
            'site_edits': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'uid': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'updates': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'unique': 'True'}),
            'volunteer': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'zip_code': ('django.db.models.fields.CharField', [], {'max_length': '6', 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['profiles']
########NEW FILE########
__FILENAME__ = 0002_auto__chg_field_userprofile_zip_code
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):

        # Changing field 'UserProfile.zip_code'
        db.alter_column('profiles_userprofile', 'zip_code', self.gf('django.db.models.fields.CharField')(max_length=20, null=True))

    def backwards(self, orm):

        # Changing field 'UserProfile.zip_code'
        db.alter_column('profiles_userprofile', 'zip_code', self.gf('django.db.models.fields.CharField')(max_length=6, null=True))

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'profiles.userprofile': {
            'Meta': {'object_name': 'UserProfile'},
            'active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'photo': ('django.db.models.fields.files.ImageField', [], {'max_length': '200', 'null': 'True', 'blank': 'True'}),
            'site_edits': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'uid': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'updates': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'unique': 'True'}),
            'volunteer': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'zip_code': ('django.db.models.fields.CharField', [], {'max_length': '20', 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['profiles']
########NEW FILE########
__FILENAME__ = models
from operator import itemgetter
from django.contrib.auth.models import User, Group
from django.utils.translation import ugettext_lazy as _ # internationalization translate call
from django.contrib.gis.db import models
from treemap.models import Tree, Plot, TreeFlags, TreePhoto, TreePending, TreeStewardship, PlotStewardship
from django_reputation.models import UserReputationAction
from badges.models import Badge, BadgeToUser

import random

BOOLEAN_CHOICES =  (
                  (False, "No"),
                  (True, "Yes"),
                )

class UserProfile(models.Model):
    user = models.ForeignKey(User, unique=True, verbose_name=_('Username'))
    # not going to use volunteer, comment at a good moment...
    volunteer = models.BooleanField("Volunteer Opportunities",choices=BOOLEAN_CHOICES,default=False)
    updates = models.BooleanField('I would like to receive occasional email updates and newsletters',choices=BOOLEAN_CHOICES,default=False)
    zip_code = models.CharField(max_length=20,null=True,blank=True)
    photo = models.ImageField(upload_to='photos',height_field=None, width_field=None, max_length=200,null=True,blank=True)
    site_edits = models.IntegerField(_('Site Edits (to track activity)'),default=0,editable=False)
    uid = models.IntegerField(_('Random User ID'),null=True,blank=True,editable=False)
    active = models.BooleanField(choices=BOOLEAN_CHOICES,default=True)

    def __unicode__(self):
        name = self.user.get_full_name()
        if name:
            return unicode("%s" % self.user.get_full_name())
        else:
            return unicode("%s" % self.user.username)

    class Meta:
        verbose_name = _('Profile')
        verbose_name_plural = _('Profiles')

    # stripped-down recently_edited_trees to fix neighborhood display
    # in profiles/edit_profile.html and profile_detail.html

    def re_trees(self):
        trees = Tree.history.filter(last_updated_by=self.user, present=True).exclude(_audit_change_type="U",_audit_diff="").order_by('-last_updated')[:7]
        return(trees)

    def recently_edited_trees(self):
        trees = Tree.history.filter(last_updated_by=self.user, present=True).exclude(_audit_change_type="U",_audit_diff="").order_by('-last_updated')[:7]
        recent_edits = []
        for t in trees:
            recent_edits.append((t.species, t.date_planted, t.last_updated, t.id))
        return sorted(recent_edits, key=itemgetter(2), reverse=True)[:7]

    def recently_edited_plots(self):
        plots = Plot.history.filter(last_updated_by=self.user, present=True).exclude(_audit_change_type="U",_audit_diff="").order_by('-last_updated')[:7]
        recent_edits = []
        for p in plots:
            actual_plot = Plot.objects.get(pk=p.id)
            if actual_plot.current_tree():
                recent_edits.append((actual_plot.current_tree().species, actual_plot.current_tree().date_planted, p.last_updated, p.id))
            else:
                recent_edits.append(("", None, p.last_updated, p.id))
        return sorted(recent_edits, key=itemgetter(2), reverse=True)[:7]


    def recently_added_photos(self):
        return TreePhoto.objects.filter(reported_by=self.user, tree__present=True).order_by('-reported_by')[:7]

    def recently_changed_reputation(self):
        return UserReputationAction.objects.filter(user=self.user).order_by('-date_created')[:7]

    def recently_added_pends(self):
        return TreePending.objects.filter(submitted_by=self.user).order_by('-submitted')[:7]

    def recent_stewardship(self):
        tree_s = TreeStewardship.objects.filter(performed_by=self.user)[:7]
        plot_s = PlotStewardship.objects.filter(performed_by=self.user)[:7]
        recent_activity = []
        for t in tree_s:
            recent_activity.append((t.tree.species, t.get_activity(), t.performed_date, t.tree.plot.id))
        for p in plot_s:
            recent_activity.append((p.plot.current_tree().species, p.get_activity(), p.performed_date, p.plot.id))
        print recent_activity
        return sorted(recent_activity, key=itemgetter(2), reverse=True)[:7]


    def badges(self):
        return BadgeToUser.objects.filter(user=self)

    def badges_in_progress(self):
        return_badges = []
        for b in Badge.objects.all():
            if b.meta_badge.get_progress(self.user) > b.meta_badge.progress_start:
                if b.meta_badge.get_progress(self.user) < b.meta_badge.progress_finish:
                    return_badges.append((b, b.meta_badge.get_progress(self.user)))

        return return_badges

    def made_edit(self):
        self.site_edits += 1
        self.save()

    def username(self):
        return u"%s" % self.user.username

    def first_name(self):
        return u"%s" % self.user.first_name

    def last_name(self):
        return u"%s" % self.user.last_name

    def full_name(self):
        return u"%s %s" % (self.user.first_name, self.user.last_name)

    def email(self):
        return u"%s" % self.user.email

    def remove(self):
        return '<input type="button" value="Remove" onclick="location.href=\'%s/delete/\'" />' % (self.pk)

    remove.short_description = ''
    remove.allow_tags = True

    def get_absolute_url(self):
        return ('profiles_profile_detail', (), { 'username': self.user.username })
    get_absolute_url = models.permalink(get_absolute_url)

    def get_random_id(self):
        return random.randint(100000,999999)

    def account_activated(self):
        return self.user.is_active
    account_activated.boolean = True

    def account_diff(self):
        if self.user.is_active:
            return (self.user.date_joined - datetime.datetime.now())

    def save(self, force_insert=False, force_update=False, using='default'):
        if not self.id:
            self.uid = self.get_random_id()

        super(UserProfile, self).save()

########NEW FILE########
__FILENAME__ = tests
from django.contrib.auth.models import User
from django.test import TestCase
from django_reputation.models import UserReputationAction
from test_utils import setupTreemapEnv, teardownTreemapEnv, mkPlot, mkTree

from utils import change_reputation_for_user

class TestUtils(TestCase):

    def setUp(self):
        teardownTreemapEnv() # In case a previous tearDown did not run
        setupTreemapEnv()
        self.jim = User.objects.get(username="jim")
        self.amy = User.objects.get(username="amy")

    def tearDown(self):
        teardownTreemapEnv()

    def test_change_reputation_for_action(self):
        plot = mkPlot(self.jim)
        tree = mkTree(self.jim, plot=plot)

        reputation_count = UserReputationAction.objects.count()
        self.assertEqual(0, reputation_count)

        change_reputation_for_user(self.jim, 'add tree', tree)

        self.assertEqual(1, UserReputationAction.objects.count())
        reputation_action = UserReputationAction.objects.all()[0]

        self.assertEqual(self.jim.id, reputation_action.user.id)
        self.assertEqual(self.jim.id, reputation_action.originating_user.id)
        self.assertEqual(25, reputation_action.value)

    def test_change_reputation_for_action_with_sub_actions(self):
        plot = mkPlot(self.jim)
        tree = mkTree(self.jim, plot=plot)

        reputation_count = UserReputationAction.objects.count()
        self.assertEqual(0, reputation_count)

        change_reputation_for_user(self.amy, 'edit verified', tree, sub_action='down', change_initiated_by_user=self.jim)

        self.assertEqual(1, UserReputationAction.objects.count())
        reputation_action = UserReputationAction.objects.all()[0]

        self.assertEqual(self.amy.id, reputation_action.user.id)
        self.assertEqual(self.jim.id, reputation_action.originating_user.id)
        self.assertEqual(-10, reputation_action.value)

    def test_change_reputation_for_user_raises_when_user_is_none(self):
        plot = mkPlot(self.jim)
        self.assertRaises(Exception, change_reputation_for_user, None, 'add plot', plot)

    def test_change_reputation_for_user_raises_when_action_is_none(self):
        plot = mkPlot(self.jim)
        self.assertRaises(Exception, change_reputation_for_user, self.jim, None, plot)

    def test_change_reputation_for_user_raises_when_target_model_is_none(self):
        self.assertRaises(Exception, change_reputation_for_user, self.jim, 'add plot', None)

    def test_change_reputation_for_user_raises_when_action_is_invalid(self):
        plot = mkPlot(self.jim)
        self.assertRaises(Exception, change_reputation_for_user, self.jim, '!!DANCE!!', plot)

    def test_change_reputation_for_user_raises_action_is_specified_without_sub_action(self):
        plot = mkPlot(self.jim)
        self.assertRaises(Exception, change_reputation_for_user, self.jim, 'edit verified', plot)

    def test_change_reputation_for_user_raises_when_sub_action_is_invalid(self):
        plot = mkPlot(self.jim)
        self.assertRaises(Exception, change_reputation_for_user, self.jim, 'edit verified', plot, sub_action='!!DANCE!!')

    def test_change_reputation_for_user_raises_when_sub_action_is_specified_for_action_that_does_not_support_it(self):
        plot = mkPlot(self.jim)
        self.assertRaises(Exception, change_reputation_for_user, self.jim, 'add tree', plot, sub_action='up')


########NEW FILE########
__FILENAME__ = urls
"""
URLConf for Django user profile management.

Recommended usage is to use a call to ``include()`` in your project's
root URLConf to include this URLConf for any URL beginning with
'/profiles/'.

If the default behavior of the profile views is acceptable to you,
simply use a line like this in your root URLConf to set up the default
URLs for profiles::

    (r'^profiles/', include('profiles.urls')),

But if you'd like to customize the behavior (e.g., by passing extra
arguments to the various views) or split up the URLs, feel free to set
up your own URL patterns for these views instead. If you do, it's a
good idea to keep the name ``profiles_profile_detail`` for the pattern
which points to the ``profile_detail`` view, since several views use
``reverse()`` with that name to generate a default post-submission
redirect. If you don't use that name, remember to explicitly pass
``success_url`` to those views.

"""

from django.conf.urls.defaults import *

from profiles import views


urlpatterns = patterns('',
                       url(r'^create/$',
                           views.create_profile,
                           name='profiles_create_profile'),
                       url(r'^edit/$',
                           views.edit_profile,
                           name='profiles_edit_profile'),
                       url(r'^(?P<username>[a-zA-Z0-9.@_\-]+)/$',
                           views.profile_detail,
                           name='profiles_profile_detail'),
                       #url(r'^(?P<username>\w+)/delete/$',
                       #    views.profile_disable,
                       #    name='profiles_profile_disable'),
                       url(r'^(?P<username>[a-zA-Z0-9.@_\-]+)/photo/$',
                           views.edit_photo,
                           name='edit_photo'),
                       url(r'^$',
                           views.profile_list,
                           name='profiles_profile_list'),
                       )

########NEW FILE########
__FILENAME__ = utils
from django import forms
from django.conf import settings
from django.contrib.auth.models import User
from django.contrib.auth.models import SiteProfileNotAvailable
from django.db.models import get_model
from django.utils.translation import ugettext_lazy as _
from django_reputation.models import Reputation
from treemap.localization import PostalCodeField

def get_profile_model():
    """
    Return the model class for the currently-active user profile
    model, as defined by the ``AUTH_PROFILE_MODULE`` setting. If that
    setting is missing, raise
    ``django.contrib.auth.models.SiteProfileNotAvailable``.
    
    """
    if (not hasattr(settings, 'AUTH_PROFILE_MODULE')) or \
           (not settings.AUTH_PROFILE_MODULE):
        raise SiteProfileNotAvailable
    profile_mod = get_model(*settings.AUTH_PROFILE_MODULE.split('.'))
    if profile_mod is None:
        raise SiteProfileNotAvailable
    return profile_mod


def get_profile_form():
    """
    Return a form class (a subclass of the default ``ModelForm``)
    suitable for creating/editing instances of the site-specific user
    profile model, as defined by the ``AUTH_PROFILE_MODULE``
    setting. If that setting is missing, raise
    ``django.contrib.auth.models.SiteProfileNotAvailable``.
    
    """
    profile_mod = get_profile_model()
    class _ProfileForm(forms.ModelForm):
        email = forms.EmailField(widget=forms.TextInput(),label="Email address",required=False)
        zip_code = PostalCodeField(required=False)
        class Meta:
            model = profile_mod
            # planning to remove volunteer attr..
            exclude = ('user','volunteer',) # User will be filled in by the view.

        def clean_email(self):
            """
            Validate that the supplied email address is unique for the
            site.
            
            """
            if User.objects.filter(email__iexact=self.cleaned_data['email']):
                raise forms.ValidationError(_("This email address is already in use. Please supply a different email address."))
            return self.cleaned_data['email']

    return _ProfileForm

def get_reputation_change_amount_for_action(action, sub_action=None):
    if action not in settings.REPUTATION_SCORES.keys():
        raise Exception('The action "%s" does not have a score assigned in settings. Actions configured in REPUTATION_SCORES: %s', {action, settings.REPUTATION_SCORES.keys()})

    if sub_action is None:
        if isinstance(settings.REPUTATION_SCORES[action], int):
            return settings.REPUTATION_SCORES[action]
        else:
            raise Exception('A sub action must be specified for action "%s". Sub actions configured for %s in REPUTATION_SCORES: %s', (action, action, settings.REPUTATION_SCORES[action].keys()))
    else:
        sub_action_scores = settings.REPUTATION_SCORES[action]
        if type(sub_action_scores).__name__ == 'dict':
            if sub_action in sub_action_scores.keys():
                return sub_action_scores[sub_action]
            else:
                raise Exception('The sub action "%s" for "%s" does not have a score assigned in settings. Sub actions configured for "%s" in REPUTATION_SCORES: %s', {sub_action, action, action, sub_action_scores.keys()})
        else:
            raise Exception('The action %s does not have any sub actions assigned in settings' % action)

def change_reputation_for_user(user, action, model_object, sub_action=None, change_initiated_by_user=None):
    if user is None:
        raise Exception('The user argument cannot be none')

    if action is None:
        raise Exception('The action argument cannot be none')

    if model_object is None:
        raise Exception('The model_object argument cannot be none')

    if change_initiated_by_user is None:
        change_initiated_by_user = user

    reputation_change_amount = get_reputation_change_amount_for_action(action, sub_action)

    Reputation.objects.log_reputation_action(user, change_initiated_by_user, action, reputation_change_amount, model_object)

    return reputation_change_amount

########NEW FILE########
__FILENAME__ = views
"""
Views for creating, editing and viewing site-specific user profiles.

"""

from django.conf import settings

from django.contrib.auth.decorators import login_required
from django.contrib.auth.models import User
from django.core.exceptions import ObjectDoesNotExist
from django.core.urlresolvers import reverse
from django.http import Http404
from django.http import HttpResponseRedirect
from django.shortcuts import get_object_or_404
from django.shortcuts import render_to_response
from django.template import RequestContext
from django.views.generic.list_detail import object_list

from profiles import utils
from django import forms

class EditPhotoForm(forms.Form):
    photo = forms.ImageField()
        
@login_required
def edit_photo(request,username):
    user = get_object_or_404(User, username=username)
    if not user == request.user:
        raise Http404
        
    profile_obj = user.get_profile()

    if request.method == 'POST':
        form = EditPhotoForm(request.POST,request.FILES)
        if form.is_valid():
            profile_obj.photo = form.cleaned_data['photo']
            profile_obj.save()
            return HttpResponseRedirect('%sprofiles/%s/' % (settings.SITE_ROOT, username))
    else:
        form = EditPhotoForm()

    return render_to_response('add_edit_photos.html',RequestContext(request,{ 'instance': profile_obj, 'form': form }))
    
def render_to_json(j):
    response = HttpResponse()
    response.write('%s' % simplejson.dumps(j, indent=1))
    response['Content-length'] = str(len(response.content))
    response['Content-Type'] = 'text/plain'
    return response

# not yet hooked up...
def profile_disable(request,username):
    user = get_object_or_404(User, username=username)
    response = {'success':False}
    if user == request.user:
        try:
            profile_obj = user.get_profile()
        except ObjectDoesNotExist:
            raise Http404
        profile_obj.delete()
        response['success'] = True
    return render_to_json(response)

profile_disable = login_required(profile_disable)
        
def create_profile(request, form_class=None, success_url=None,
                   template_name='profiles/create_profile.html',
                   extra_context=None):
    """
    Create a profile for the current user, if one doesn't already
    exist.
    
    If the user already has a profile, as determined by
    ``request.user.get_profile()``, a redirect will be issued to the
    :view:`profiles.views.edit_profile` view. If no profile model has
    been specified in the ``AUTH_PROFILE_MODULE`` setting,
    ``django.contrib.auth.models.SiteProfileNotAvailable`` will be
    raised.
    
    **Optional arguments:**
    
    ``extra_context``
        A dictionary of variables to add to the template context. Any
        callable object in this dictionary will be called to produce
        the end result which appears in the context.

    ``form_class``
        The form class to use for validating and creating the user
        profile. This form class must define a method named
        ``save()``, implementing the same argument signature as the
        ``save()`` method of a standard Django ``ModelForm`` (this
        view will call ``save(commit=False)`` to obtain the profile
        object, and fill in the user before the final save). If the
        profile object includes many-to-many relations, the convention
        established by ``ModelForm`` of using a method named
        ``save_m2m()`` will be used, and so your form class should
        also define this method.
        
        If this argument is not supplied, this view will use a
        ``ModelForm`` automatically generated from the model specified
        by ``AUTH_PROFILE_MODULE``.
    
    ``success_url``
        The URL to redirect to after successful profile creation. If
        this argument is not supplied, this will default to the URL of
        :view:`profiles.views.profile_detail` for the newly-created
        profile object.
    
    ``template_name``
        The template to use when displaying the profile-creation
        form. If not supplied, this will default to
        :template:`profiles/create_profile.html`.
    
    **Context:**
    
    ``form``
        The profile-creation form.
    
    **Template:**
    
    ``template_name`` keyword argument, or
    :template:`profiles/create_profile.html`.
    
    """
    try:
        profile_obj = request.user.get_profile()
        return HttpResponseRedirect(reverse('profiles_edit_profile'))
    except ObjectDoesNotExist:
        pass
    
    #
    # We set up success_url here, rather than as the default value for
    # the argument. Trying to do it as the argument's default would
    # mean evaluating the call to reverse() at the time this module is
    # first imported, which introduces a circular dependency: to
    # perform the reverse lookup we need access to profiles/urls.py,
    # but profiles/urls.py in turn imports this module.
    #
    
    if success_url is None:
        success_url = reverse('profiles_profile_detail',
                              kwargs={ 'username': request.user.username })
    if form_class is None:
        form_class = utils.get_profile_form()
    if request.method == 'POST':
        form = form_class(data=request.POST, files=request.FILES)
        if form.is_valid():
            profile_obj = form.save(commit=False)
            profile_obj.user = request.user
            profile_obj.save()
            if hasattr(form, 'save_m2m'):
                form.save_m2m()
            return HttpResponseRedirect(success_url)
    else:
        form = form_class()
    
    if extra_context is None:
        extra_context = {}
    context = RequestContext(request)
    for key, value in extra_context.items():
        context[key] = callable(value) and value() or value
    
    return render_to_response(template_name,
                              { 'form': form },
                              context_instance=context)
create_profile = login_required(create_profile)

def edit_profile(request, form_class=None, success_url=None,
                 template_name='profiles/edit_profile.html',
                 extra_context=None):
    """
    Edit the current user's profile.
    
    If the user does not already have a profile (as determined by
    ``User.get_profile()``), a redirect will be issued to the
    :view:`profiles.views.create_profile` view; if no profile model
    has been specified in the ``AUTH_PROFILE_MODULE`` setting,
    ``django.contrib.auth.models.SiteProfileNotAvailable`` will be
    raised.
    
    **Optional arguments:**
    
    ``extra_context``
        A dictionary of variables to add to the template context. Any
        callable object in this dictionary will be called to produce
        the end result which appears in the context.

    ``form_class``
        The form class to use for validating and editing the user
        profile. This form class must operate similarly to a standard
        Django ``ModelForm`` in that it must accept an instance of the
        object to be edited as the keyword argument ``instance`` to
        its constructor, and it must implement a method named
        ``save()`` which will save the updates to the object. If this
        argument is not specified, this view will use a ``ModelForm``
        generated from the model specified in the
        ``AUTH_PROFILE_MODULE`` setting.
    
    ``success_url``
        The URL to redirect to following a successful edit. If not
        specified, this will default to the URL of
        :view:`profiles.views.profile_detail` for the profile object
        being edited.
    
    ``template_name``
        The template to use when displaying the profile-editing
        form. If not specified, this will default to
        :template:`profiles/edit_profile.html`.
    
    **Context:**
    
    ``form``
        The form for editing the profile.
        
    ``profile``
         The user's current profile.
    
    **Template:**
    
    ``template_name`` keyword argument or
    :template:`profiles/edit_profile.html`.
    
    """
    try:
        profile_obj = request.user.get_profile()
    except ObjectDoesNotExist:
        return HttpResponseRedirect(reverse('profiles_create_profile'))
    
    #
    # See the comment in create_profile() for discussion of why
    # success_url is set up here, rather than as a default value for
    # the argument.
    #
    
    if success_url is None:
        success_url = reverse('profiles_profile_detail',
                              kwargs={ 'username': request.user.username })
    if form_class is None:
        form_class = utils.get_profile_form()
    if request.method == 'POST':
        form = form_class(data=request.POST, files=request.FILES, instance=profile_obj)
        if form.is_valid():
            form.save()
            if form.cleaned_data.get('email'):
                profile_obj.user.email = form.cleaned_data['email']
                profile_obj.user.save()
            return HttpResponseRedirect(success_url)
    else:
        form = form_class(instance=profile_obj)
    
    if extra_context is None:
        extra_context = {}
    context = RequestContext(request)
    for key, value in extra_context.items():
        context[key] = callable(value) and value() or value
    
    return render_to_response(template_name,
                              { 'form': form,
                                'profile': profile_obj, },
                              context_instance=context)
edit_profile = login_required(edit_profile)

def profile_detail(request, username, public_profile_field=None,
                   template_name='profiles/profile_detail.html',
                   extra_context=None):
    """
    Detail view of a user's profile.
    
    If no profile model has been specified in the
    ``AUTH_PROFILE_MODULE`` setting,
    ``django.contrib.auth.models.SiteProfileNotAvailable`` will be
    raised.
    
    If the user has not yet created a profile, ``Http404`` will be
    raised.
    
    **Required arguments:**
    
    ``username``
        The username of the user whose profile is being displayed.
    
    **Optional arguments:**

    ``extra_context``
        A dictionary of variables to add to the template context. Any
        callable object in this dictionary will be called to produce
        the end result which appears in the context.

    ``public_profile_field``
        The name of a ``BooleanField`` on the profile model; if the
        value of that field on the user's profile is ``False``, the
        ``profile`` variable in the template will be ``None``. Use
        this feature to allow users to mark their profiles as not
        being publicly viewable.
        
        If this argument is not specified, it will be assumed that all
        users' profiles are publicly viewable.
    
    ``template_name``
        The name of the template to use for displaying the profile. If
        not specified, this will default to
        :template:`profiles/profile_detail.html`.
    
    **Context:**
    
    ``profile``
        The user's profile, or ``None`` if the user's profile is not
        publicly viewable (see the description of
        ``public_profile_field`` above).
    
    **Template:**
    
    ``template_name`` keyword argument or
    :template:`profiles/profile_detail.html`.
    
    """
    user = get_object_or_404(User, username=username)
    try:
        profile_obj = user.get_profile()
    except ObjectDoesNotExist:
        #raise Http404
        # sftrees customization by dane...
        return HttpResponseRedirect(reverse('profiles_create_profile'))
    
    # only let actual user view an inactive profile...
    if not profile_obj.active:
        if not profile_obj.user == request.user:
            raise Http404
    
    if public_profile_field is not None and \
       not getattr(profile_obj, public_profile_field):
        profile_obj = None
    
    if extra_context is None:
        extra_context = {}
    context = RequestContext(request)
    for key, value in extra_context.items():
        context[key] = callable(value) and value() or value
    
    return render_to_response(template_name,
                              { 'profile': profile_obj },
                              context_instance=context)

def profile_list(request, public_profile_field=None,
                 template_name='profiles/profile_list.html', **kwargs):
    """
    A list of user profiles.
    
    If no profile model has been specified in the
    ``AUTH_PROFILE_MODULE`` setting,
    ``django.contrib.auth.models.SiteProfileNotAvailable`` will be
    raised.

    **Optional arguments:**

    ``public_profile_field``
        The name of a ``BooleanField`` on the profile model; if the
        value of that field on a user's profile is ``False``, that
        profile will be excluded from the list. Use this feature to
        allow users to mark their profiles as not being publicly
        viewable.
        
        If this argument is not specified, it will be assumed that all
        users' profiles are publicly viewable.
    
    ``template_name``
        The name of the template to use for displaying the profiles. If
        not specified, this will default to
        :template:`profiles/profile_list.html`.

    Additionally, all arguments accepted by the
    :view:`django.views.generic.list_detail.object_list` generic view
    will be accepted here, and applied in the same fashion, with one
    exception: ``queryset`` will always be the ``QuerySet`` of the
    model specified by the ``AUTH_PROFILE_MODULE`` setting, optionally
    filtered to remove non-publicly-viewable proiles.
    
    **Context:**
    
    Same as the :view:`django.views.generic.list_detail.object_list`
    generic view.
    
    **Template:**
    
    ``template_name`` keyword argument or
    :template:`profiles/profile_list.html`.
    
    """
    profile_model = utils.get_profile_model()
    queryset = profile_model._default_manager.filter(active=True)
    if public_profile_field is not None:
        queryset = queryset.filter(**{ public_profile_field: True })
    kwargs['queryset'] = queryset
    return object_list(request, template_name=template_name, **kwargs)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *
from qs_tiles import views

urlpatterns = patterns('',
    (r'^qs_tiles%s' % views.tile_request_pat, views.get_tile),
)
    

########NEW FILE########
__FILENAME__ = views
# Django 
from django.conf import settings
from django.http import HttpResponse

# TileCache 
#import TileCache.Layer as Layer
from TileCache.Service import Service
from TileCache.Caches.Disk import Disk
from TileCache.Caches.Memcached import Memcached
from TileCache.Layer import Tile
from TileCache.Layers.Mapnik import Mapnik as MapnikLayer

from treemap.views import _build_tree_search_result

# http://bitbucket.org/springmeyer/djmapnik/
from djmapnik.adapter import qs_to_map

try:
    import mapnik2 as mapnik
except:
    import mapnik

# todo - remove <layername>, and remove 'foo' from url in static/treemap.js
tile_request_pat = r'/(?P<version>\d{1,2}\.\d{1,3}\.\d{1,3})/(?P<layername>[a-z]{1,64})/(?P<z>\d{1,10})/(?P<x>\d{1,10})/(?P<y>\d{1,10})\.(?P<extension>(?:png|jpg|gif))'

# hackish way to grab style obj and avoid parsing XML each request...
m = mapnik.Map(1,1)
mapnik.load_map(m,settings.MAPNIK_STYLESHEET)
style = m.find_style('style')
del m

srv = None

if settings.CACHE_SEARCH_METHOD == 'mem':
    srv = Service(
      Memcached(),
      {}, # layers are dynamic
    )
else:
    srv = Service(
      Disk(settings.CACHE_SEARCH_DISK_PATH),
      {}, # layers are dynamic
    )

query_hash = {}

class TileResponse(object):
    def __init__(self, tile_bytes):
        self.tile_bytes = tile_bytes

    def __call__(self, extension='png'):
        if self.tile_bytes:
            # mod_python handler in django borkes unless mimetype is string
            return HttpResponse(self.tile_bytes, mimetype=str('image/%s' % extension))
        else:
            raise Http404

def strip_name(name):
    if '&advanced=open' in name:
        return name.replace('&advanced=open','')
    elif 'advanced=open' in name:
        return name.replace('advanced=open','')
    return name

def get_tile(request, version, layername, z, x, y, extension='png'):
    global style
    image = None
    name = request.META['QUERY_STRING'] or 'all'
    name = strip_name(name)
    mapnik_layer = MapnikLayer(
                 name,
                 'foo',# mapfile skipped as we dynamically assign map object
                 spherical_mercator = 'true',
                 extension = "png",
                 tms_type = 'google',
                 paletted = 'true',
                 debug=False
                 )
    srv.layers[name] = mapnik_layer
    z, x, y = int(z), int(x), int(y)
    if mapnik_layer.tms_type == "google":
        res = mapnik_layer.resolutions[z]
        maxY = int(
          round(
            (mapnik_layer.bbox[3] - mapnik_layer.bbox[1]) / 
            (res * mapnik_layer.size[1])
           )
        ) - 1
        tile  = Tile(mapnik_layer, x, maxY - y, z)
    else:
        tile = Tile(mapnik_layer, x, y, z)
    if settings.CACHE_SEARCH_TILES:
        image = srv.cache.get(tile)
    if not image:
        # cached map - must be run multiprocess to avoid potential race condition
        m = query_hash.get(name)
        if not m:
            trees, geog_obj = _build_tree_search_result(request)
            trees = trees.only('geometry')
            styles=[{'name':'style','obj':style}]
            m = qs_to_map(trees,styles=styles)
            query_hash[name] = m
        # push the actual mapnik map into the TC MapnikLayer
        mapnik_layer.mapnik = m
        if settings.CACHE_SEARCH_TILES:
            # render and cache
            image = srv.renderTile(tile)[1]
        else:
            # render directly from layer, not service, therefore bypassing saving to cache
            image = mapnik_layer.renderTile(tile)
    response = TileResponse(image)    
    return response(extension)

########NEW FILE########
__FILENAME__ = settings
import os
import djcelery

djcelery.setup_loader()

# The following settings should be overriden in your
# local_settings.py or impl_settings.py file if needed
ADD_INITIAL_DEFAULTS = {}
ADD_FORM_TARGETS = [
    ('addsame', 'I want to add another tree using the same tree details'),
    ('add', 'I want to add another tree with new details'),
    ('edit','Let me continue editing this tree'),
    ('view', "I'm done!"),
]
ADD_FORM_TARGETS_DEFAULT = 'view'
API_KEY_GOOGLE_MAP = '' # Can be empty
API_KEY_GOOGLE_ANALYTICS = 'your-key-here'

POSTAL_CODE_FIELD = "USZipCodeField"
DBH_TO_INCHES_FACTOR = 1.0

ITREE_REGION = 'NoEastXXX'
MULTI_REGION_ITREE_ENABLED = False

PENDING_REQUIRED_FOR_PUBLIC_EDITING_PUBLIC_TREES = False
ADVANCED_USERS_CAN_ACCEPT_PENDING = False

# Certain email servers (most, all?) prohibit traffic
# that appears to be routed from someone on the network
#
# For instance, if all mail from an OTM site is going to
# jane@company.com and jim ("jim@company.com") sends feedback
# the message structure will look like:
# From: jim@company.com
# To: jane@company.com
# ....
# But mail.company.com will *reject* the email since it is
# actually originating from otm's servers and masquerading
# as company.com
FORCE_MAIL_TO_BE_FROM = None

SHOW_ADMIN_EDITS_IN_RECENT_EDITS = False

DEBUG = True

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.admin',
    'django.contrib.databrowse',
    'django.contrib.gis',
    'django.contrib.humanize',
    'django.contrib.webdesign',
    'django.contrib.markup',
    'django.contrib.flatpages',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'threadedcomments',
    'treemap',
    'api',
    'registration',
    'template_utils',
    'profiles',
    'django_reputation',
    'tagging',
    'south',
    'sorl.thumbnail',
    'classfaves',
    'qs_tiles',
    'treekey',
    'badges',
    'pagination',
    'django_sorting',
    'pipeline',
    'importer',
    'djcelery',
    'polygons'
)

try:
   from impl_settings import *
except ImportError, e:
   pass

OTM_VERSION = "1.2"
API_VERSION = "0.1"

TEMPLATE_DEBUG = DEBUG

# sorl thumbnail settings
THUMBNAIL_DEBUG = True
THUMBNAIL_SUBDIR = '_thumbs'

AUTH_PROFILE_MODULE = 'profiles.userprofile'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en-us'

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = False

ROOT_URLCONF = 'urls'

# celery config
BROKER_URL = 'redis://localhost:6379/0'

TEST_RUNNER = 'djcelery.contrib.test_runner.CeleryTestSuiteRunner'

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.load_template_source',
)

from django.conf.global_settings import TEMPLATE_CONTEXT_PROCESSORS
TEMPLATE_CONTEXT_PROCESSORS += (
    #"django.core.context_processors.auth",
    "django.contrib.auth.context_processors.auth",
    "django.core.context_processors.debug",
    "django.core.context_processors.i18n",
    "django.core.context_processors.media",
    'django.core.context_processors.request',
    'django.contrib.messages.context_processors.messages',
    'treemap.context_processors.site_root'
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.middleware.transaction.TransactionMiddleware',
    'django.contrib.csrf.middleware.CsrfViewMiddleware',
    'django.contrib.csrf.middleware.CsrfResponseMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.flatpages.middleware.FlatpageFallbackMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django_reputation.middleware.ReputationMiddleware',
    'pagination.middleware.PaginationMiddleware',
    'django_sorting.middleware.SortingMiddleware',

)

CLIMATE_ZONE_MAPPINGS = {
   'Inland Empire': 'InlEmpCLM',
   'Northeast': 'NoEastXXX',
   'Pacific Northwest': 'PacfNWLOG',
   'South': 'PiedmtCLT',
   'Midwest': 'MidWstMSP',
   'Northern California Coast': 'CaNCCoJBK',
   'Lower Midwest': 'LoMidWXXX',
   'North': 'NMtnPrFNL',
   'Inland Valleys': 'InlValMOD',
   'Southern California Coast': 'SoCalCSMA',
   'Southwest Desert': 'SWDsrtGDL',
   'Coastal Plain': 'GulfCoCHS',
   'Central Florida': 'CenFlaXXX',
   'Interior West':  'InterWABQ',
   'Tropical': 'TropicPacXXX',
   'Temperate Interior West': 'TpIntWBOI'
}


try:
    from local_settings import *
except ImportError, exp:
    pass

if SITE_ROOT is not "/":
    LOGIN_URL = "%s/accounts/login" % SITE_ROOT
else:
    LOGIN_URL = "/accounts/login"

########NEW FILE########
__FILENAME__ = settings_audit
from django.db import models

def get_user_rep(instance):
    if hasattr(instance, 'reported_by'):  #a TreeItem instance
        return instance.reported_by.reputation.reputation
    else:  #a Tree instance
        return instance.last_updated_by.reputation.reputation
        
def get_diff(instance):
    #get the previous change of this object
    if hasattr(instance, '_audit_diff'):
        return instance._audit_diff
    return ''

# Populate the fields that every Audit model in this app will use.
GLOBAL_TRACK_FIELDS = (
    ('_audit_user_rep', models.IntegerField(), get_user_rep),
    ('_audit_diff', models.TextField(), get_diff),
    ('_audit_verified', models.IntegerField(), 0)
)

########NEW FILE########
__FILENAME__ = admin
from treekey.models import Node, Species, SpeciesImage, NodeImage, SpeciesLink
from django.contrib import admin


class SpeciesImageInline(admin.TabularInline):
    model = SpeciesImage
    extra = 0

class SpeciesLinkInline(admin.TabularInline):
    model = SpeciesLink
    extra = 0

class SpeciesInline(admin.TabularInline):
    model = Species

class NodeImageInline(admin.TabularInline):
    model = NodeImage
    extra = 0

class NodeAdmin(admin.ModelAdmin):
    inlines = [NodeImageInline]
    list_display = ('name', 'description')
    
class SpeciesAdmin(admin.ModelAdmin):
    inlines = [SpeciesImageInline, SpeciesLinkInline]
    list_display = ('genus', 'species', 'common_name')
    

admin.site.register(Node, NodeAdmin)
admin.site.register(Species, SpeciesAdmin)
########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.conf import settings

# Species identification info for the key
# try to focus on what sets this species apart
class Species(models.Model):
    genus = models.CharField(max_length=200)
    species = models.CharField(max_length=200, blank=True)
    variety = models.CharField(max_length=200, blank=True)
    common_name = models.CharField(max_length=200)
    symbol = models.CharField(max_length=10, blank=True)
    feature = models.CharField(max_length=500)
    type = models.CharField(max_length=200, blank=True)
    form = models.CharField(max_length=500, blank=True)
    leaf = models.CharField(max_length=500, blank=True)
    flower = models.CharField(max_length=500, blank=True)
    bark = models.CharField(max_length=500, blank=True)
    fruit = models.CharField(max_length=500, blank=True)
    other = models.CharField(max_length=200, blank=True)
    
    class Meta:
        verbose_name_plural = "Species"
    
    def __unicode__(self):
        return self.common_name
        
    # Pull the first image for the node display
    def first_image_url(self):
        if self.speciesimage_set.count() == 0:
            return settings.STATIC_URL + "/Species/tree_not_found.png"
        si_list = self.speciesimage_set.all()
        return si_list[0].image.url
            
# Each species can have more than one image
# The first image entered should be iconic or aid in identification
class SpeciesImage(models.Model):
    image = models.FileField(upload_to='Species')
    caption = models.CharField(max_length=200)
    species = models.ForeignKey(Species)
    attrib_text = models.CharField(max_length=200, blank=True)
    attrib_link = models.CharField(max_length=200, blank=True)

    def __unicode__(self):
        return self.species.common_name

# Link to outside resources for a spieces
class SpeciesLink(models.Model):
    text = models.CharField(max_length=200)
    url = models.CharField(max_length=200)
    species = models.ForeignKey(Species)

# Nodes are decision points in a key and have a child view and parent page
# A node can point up to either another node (though their parent_node fields)
#    or point down to one or more species, and may do both
class Node(models.Model):
    name = models.CharField(max_length=200)  
    description = models.CharField(max_length=500)  #longer description for the child display
    question = models.CharField(max_length=500)  #short quesiton choice for the parent display
    parent_node = models.ForeignKey('self', blank=True, null=True, related_name='child_set')
    species = models.ManyToManyField(Species, null=True, blank=True)

    def __unicode__(self):
        return self.name
        
    def has_children(self):
        return self.child_set.count() > 0
        
    def has_parent(self):
        return self.parent_node != None

# An iconic image to help users at the child display of this node. 
# There should only be one per node, but this is not enforced
class NodeImage(models.Model):
    image = models.FileField(upload_to='Nodes')
    caption = models.CharField(max_length=200)
    node = models.ForeignKey(Node)
    attrib_text = models.CharField(max_length=200, blank=True)
    attrib_link = models.CharField(max_length=200, blank=True)

    def __unicode__(self):
        return self.node.name        

########NEW FILE########
__FILENAME__ = tests
"""
This file demonstrates two different styles of tests (one doctest and one
unittest). These will both pass when you run "manage.py test".

Replace these with more appropriate tests for your application.
"""

from django.test import TestCase

class SimpleTest(TestCase):
    def test_basic_addition(self):
        """
        Tests that 1 + 1 always equals 2.
        """
        self.failUnlessEqual(1 + 1, 2)

__test__ = {"doctest": """
Another way to test that 1 + 1 is equal to 2.

>>> 1 + 1 == 2
True
"""}


########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

# Uncomment the next two lines to enable the admin:
from django.contrib import admin
admin.autodiscover()

urlpatterns = patterns('django.views.generic.simple',    
    ('^$', 'redirect_to', {'url': './start'}),
)


urlpatterns += patterns('treekey.views',
    (r'^node/(?P<node_id>\d+)/$', 'node'),
    (r'^leaf/(?P<node_id>\d+)/$', 'node'),
    (r'^start/$', 'first_node'),
    (r'^species/(?P<species_id>\d+)/$', 'species'),
    (r'^browse/$', 'browse'),
    
    (r'^admin/', include(admin.site.urls)),
)

########NEW FILE########
__FILENAME__ = views
from django.template import RequestContext
from django.http import HttpResponse
from django.shortcuts import render_to_response, get_object_or_404
from django.template import Context, Template, RequestContext
from django.template.loader import render_to_string
from treekey.models import Node, Species

# Create a tree heirarchy to display node relationships
def nodes(request):
    return render_to_response('treekey/base.html', RequestContext(request, {'display': index_maker()}))

# Warning! Recursion here! Tread carefully!
# Recursively generates a tree of nodes in their parent-child relationships
def index_maker(request):
    rootnode = Node.objects.order_by('id')[0]
    def _index(node):
        for child in node.child_set.all():
            if child.has_children():
                yield render_to_string('treekey/list_branch.html',
                                           {'node': child,
                                           'leaves': _index(child)}, RequestContext(request))
                continue

            yield render_to_string('treekey/list_branch.html',
                {'node': child,
                'leaves': None}, RequestContext(request))
    return _index(rootnode)

# Warning! Inner-loop reassignment here! Tread carefully!
# Generates a bread-crumb trail from a node up the parent tree to the start
def trail_maker(n):
    node_trail = []
    while n.has_parent():
        node_trail.insert(0, n)
        n = n.parent_node
        
    return node_trail

# Returns the starting node for the key. Must be the first record in the database.
def first_node(request):
    f = Node.objects.order_by('id')[0]
    return render_to_response('treekey/node.html', RequestContext(request, {'request': request, 'node':f, 'display':index_maker(request), 'trail':trail_maker(f)}))

# Returns a node or leaf depending on the child objects
def node(request, node_id):
    n = get_object_or_404(Node, pk=node_id)
    if n.has_children():
        return render_to_response('treekey/node.html', RequestContext(request, {'request': request, 'node':n, 'display':index_maker(request), 'trail':trail_maker(n)}))
    return render_to_response('treekey/leaf.html', RequestContext(request, {request: request, 'leaf':n, 'display':index_maker(request), 'trail':trail_maker(n)}))
# Returns species information with parent node trail/index information
def species(request, species_id):
    s = get_object_or_404(Species, pk=species_id)
    n = s.node_set.all()[0];
    return render_to_response('treekey/species.html', RequestContext(request, {'request': request, 'species':s, 'display':index_maker(request), 'trail':trail_maker(n)}))
    
def browse(request):
    f = Node.objects.order_by('id')[0]
    species = Species.objects.all().order_by('common_name')
    return render_to_response('treekey/browse.html', RequestContext(request, {'request': request, 'species':species, 'display':index_maker(request), 'trail':trail_maker(f)}))
    

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from django.contrib.gis.admin.options import GeoModelAdmin

from django.contrib.auth.models import User, Group
from django.contrib.auth.admin import UserAdmin, GroupAdmin
from django.db import models as dmodels
import models

mods = [x for x in models.__dict__.values() if issubclass(type(x), dmodels.base.ModelBase)]

admins = []
#for each model in our models module, prepare an admin class
#that will edit our model (Admin<model_name>, model)
for c in mods:
    if not c._meta.abstract:
        admins.append(("%sAdmin"%c.__name__, c))

#create the admin class and register it
for (ac, c) in admins:
    try: #pass gracefully on duplicate registration errors
        if ac != 'SpeciesAdmin':
            admin.site.register(c, type(ac, (GeoModelAdmin,), dict()))
    except:
        pass

class SpeciesAdmin(admin.ModelAdmin):
    list_per_page = 500

    list_display = ('genus', 'species', 'cultivar_name', 'other_part_of_name')

admin.site.register(models.Species, SpeciesAdmin)

########NEW FILE########
__FILENAME__ = audit
from django.dispatch import dispatcher
from django.contrib.gis.db import models
from django.core.exceptions import ImproperlyConfigured
from django.contrib import admin
import copy
import re
import types
try:
    import settings_audit
except ImportError:
    settings_audit = None
value_error_re = re.compile("^.+'(.+)'$")

class AuditTrail(object):
    def __init__(self, show_in_admin=False, save_change_type=True, audit_deletes=True,
                 track_fields=None):
        self.opts = {}
        self.opts['show_in_admin'] = show_in_admin
        self.opts['save_change_type'] = save_change_type
        self.opts['audit_deletes'] = audit_deletes
        if track_fields:
            self.opts['track_fields'] = track_fields
        else:
            self.opts['track_fields'] = []

    def contribute_to_class(self, cls, name):
        # This should only get added once the class is otherwise complete
        def _contribute(sender, **kwargs):
            model = create_audit_model(sender, **self.opts)
            if self.opts['show_in_admin']:
                # Enable admin integration
                # If ModelAdmin needs options or different base class, find
                # some way to make the commented code work
                #   cls_admin_name = cls.__name__ + 'Admin'
                #   clsAdmin = type(cls_admin_name, (admin.ModelAdmin,),{})
                #   admin.site.register(cls, clsAdmin)
                # Otherwise, register class with default ModelAdmin
                admin.site.register(model)
            descriptor = AuditTrailDescriptor(model._default_manager, sender._meta.pk.attname)
            setattr(sender, name, descriptor)

            def _audit_track(instance, field_arr, **kwargs):
                field_name = field_arr[0]
                try:
                    return getattr(instance, field_name)
                except:
                    if len(field_arr) > 2:
                        if callable(field_arr[2]):
                            fn = field_arr[2]
                            return fn(instance)
                        else:
                            return field_arr[2]

            def _audit(sender, instance, created, **kwargs):
                # Write model changes to the audit model.
                # instance is the current (non-audit) model.
                kwargs = {}
                for field in sender._meta.fields:
                    #kwargs[field.attname] = getattr(instance, field.attname)
                    kwargs[field.name] = getattr(instance, field.name)
                if self.opts['save_change_type']:
                    if created:
                        kwargs['_audit_change_type'] = 'I'
                    else:
                        kwargs['_audit_change_type'] = 'U'
                for field_arr in model._audit_track:
                    kwargs[field_arr[0]] = _audit_track(instance, field_arr)
                model._default_manager.create(**kwargs)
            ## Uncomment this line for pre r8223 Django builds
            #dispatcher.connect(_audit, signal=models.signals.post_save, sender=cls, weak=False)
            ## Comment this line for pre r8223 Django builds
            models.signals.post_save.connect(_audit, sender=cls, weak=False)

            if self.opts['audit_deletes']:
                def _audit_delete(sender, instance, **kwargs):
                    # Write model changes to the audit model
                    kwargs = {}
                    for field in sender._meta.fields:
                        kwargs[field.name] = getattr(instance, field.name)
                    if self.opts['save_change_type']:
                        kwargs['_audit_change_type'] = 'D'
                    for field_arr in model._audit_track:
                        kwargs[field_arr[0]] = _audit_track(instance, field_arr)
                    model._default_manager.create(**kwargs)
                ## Uncomment this line for pre r8223 Django builds
                #dispatcher.connect(_audit_delete, signal=models.signals.pre_delete, sender=cls, weak=False)
                ## Comment this line for pre r8223 Django builds
                models.signals.pre_delete.connect(_audit_delete, sender=cls, weak=False)
        
        ## Uncomment this line for pre r8223 Django builds
        #dispatcher.connect(_contribute, signal=models.signals.class_prepared, sender=cls, weak=False)
        ## Comment this line for pre r8223 Django builds
        models.signals.class_prepared.connect(_contribute, sender=cls, weak=False)

class AuditTrailDescriptor(object):
    def __init__(self, manager, pk_attribute):
        self.manager = manager
        self.pk_attribute = pk_attribute

    def __get__(self, instance=None, owner=None):
        if instance == None:
            #raise AttributeError, "Audit trail is only accessible via %s instances." % type.__name__
            return create_audit_manager_class(self.manager)
        else:
            return create_audit_manager_with_pk(self.manager, self.pk_attribute, instance._get_pk_val())

    def __set__(self, instance, value):
        raise AttributeError, "Audit trail may not be edited in this manner."

def create_audit_manager_with_pk(manager, pk_attribute, pk):
    """Create an audit trail manager based on the current object"""
    class AuditTrailWithPkManager(manager.__class__):
        def __init__(self, *arg, **kw):
            super(AuditTrailWithPkManager, self).__init__(*arg, **kw)
            self.model = manager.model

        def get_query_set(self):
            qs = super(AuditTrailWithPkManager, self).get_query_set().filter(**{pk_attribute: pk})
            if self._db is not None:
                qs = qs.using(self._db)
            return qs
    return AuditTrailWithPkManager()

def create_audit_manager_class(manager):
    """Create an audit trail manager based on the current object"""
    class AuditTrailManager(manager.__class__):
        def __init__(self, *arg, **kw):
            super(AuditTrailManager, self).__init__(*arg, **kw)
            self.model = manager.model
    return AuditTrailManager()

def create_audit_model(cls, **kwargs):
    """Create an audit model for the specific class"""
    name = cls.__name__ + 'Audit'

    class Meta:
        db_table = '%s_audit' % cls._meta.db_table
        app_label = cls._meta.app_label
        verbose_name_plural = '%s audit trail' % cls._meta.verbose_name
        ordering = ['-_audit_timestamp']

    # Set up a dictionary to simulate declarations within a class
    attrs = {
        '__module__': cls.__module__,
        'Meta': Meta,
        '_audit_id': models.AutoField(primary_key=True),
        '_audit_timestamp': models.DateTimeField(auto_now_add=True, db_index=True),
        '_audit__str__': cls.__str__.im_func,
        '__str__': lambda self: '%s as of %s' % (self._audit__str__(), self._audit_timestamp),
        '_audit_track': _track_fields(track_fields=kwargs['track_fields'], unprocessed=True)
    }

    if 'save_change_type' in kwargs and kwargs['save_change_type']:
        attrs['_audit_change_type'] = models.CharField(max_length=1)

    # Copy the fields from the existing model to the audit model
    for field in cls._meta.fields:
        #if field.attname in attrs:
        if field.name in attrs:
            raise ImproperlyConfigured, "%s cannot use %s as it is needed by AuditTrail." % (cls.__name__, field.attname)
        if isinstance(field, models.AutoField):
            # Audit models have a separate AutoField
            attrs[field.name] = models.IntegerField(db_index=True, editable=False)
        else:
            attrs[field.name] = copy.copy(field)
            # If 'unique' is in there, we need to remove it, otherwise the index
            # is created and multiple audit entries for one item fail.
            attrs[field.name]._unique = False
            # If a model has primary_key = True, a second primary key would be
            # created in the audit model. Set primary_key to false.
            attrs[field.name].primary_key = False

            # Rebuild and replace the 'rel' object to avoid foreign key clashes.
            # Borrowed from the Basie project - please check if adding this is allowed by the license.
            if isinstance(field, models.ForeignKey):
                rel = copy.copy(field.rel)
                rel.related_name = '_audit_' + field.related_query_name()
                attrs[field.name].rel = rel
            if isinstance(field, models.PointField):
                attrs['objects'] = models.GeoManager()

    for track_field in _track_fields(kwargs['track_fields']):
        if track_field['name'] in attrs:
            raise NameError('Field named "%s" already exists in audit version of %s' % (track_field['name'], cls.__name__))
        attrs[track_field['name']] = copy.copy(track_field['field'])
    
    return type(name, (models.Model,), attrs)

def _build_track_field(track_item):
    track = {}
    track['name'] = track_item[0]
    if isinstance(track_item[1], models.Field):
        track['field'] = track_item[1]
    elif issubclass(track_item[1], models.Model):
        track['field'] = models.ForeignKey(track_item[1])
    else:
        raise TypeError('Track fields only support items that are Fields or Models.')
    return track

def _track_fields(track_fields=None, unprocessed=False):
    # Add in the fields from the Audit class "track" attribute.
    tracks_found = []
    
    if settings_audit:
        global_track_fields = getattr(settings_audit, 'GLOBAL_TRACK_FIELDS', [])
        for track_item in global_track_fields:
            if unprocessed:
                tracks_found.append(track_item)
            else:
                tracks_found.append(_build_track_field(track_item))
    
    if track_fields:
        for track_item in track_fields:
            if unprocessed:
                tracks_found.append(track_item)
            else:
                tracks_found.append(_build_track_field(track_item))
    return tracks_found

########NEW FILE########
__FILENAME__ = context_processors
from django.conf import settings

def site_root(context):
    return {
        'GEOSERVER_GEO_LAYER': settings.GEOSERVER_GEO_LAYER,
        'GEOSERVER_GEO_STYLE': settings.GEOSERVER_GEO_STYLE,
        'SITE_ROOT': settings.SITE_ROOT,
        'GEOSERVER_URL': settings.GEOSERVER_URL,
        'TILECACHE_URL': settings.TILECACHE_URL,
        'TILECACHE_LAYER': settings.TILECACHE_LAYER,
        'TILECACHE_POLYGON_LAYER': settings.TILECACHE_POLYGON_LAYER,
        'API_KEY_GOOGLE_MAP': settings.API_KEY_GOOGLE_MAP,
        'API_KEY_GOOGLE_ANALYTICS': settings.API_KEY_GOOGLE_ANALYTICS
    }

########NEW FILE########
__FILENAME__ = custom_admin

########NEW FILE########
__FILENAME__ = eco_benefits
from treemap.localization import convert_dbh_to_inches
from django.conf import settings
from eco import benefits

RESOURCE_NAMES = {'Hydro interception': 'hydro_interception',
                  'AQ Ozone dep': 'aq_ozone_dep',
                  'AQ NOx dep': 'aq_nox_dep',
                  'AQ PM10 dep': 'aq_pm10_dep',
                  'AQ SOx dep': 'aq_sox_dep',
                  'AQ NOx avoided': 'aq_nox_avoided',
                  'AQ PM10 avoided': 'aq_pm10_avoided',
                  'AQ SOx avoided': 'aq_sox_avoided',
                  'AQ VOC avoided': 'aq_voc_avoided',
                  'BVOC': 'bvoc',
                  'CO2 sequestered': 'co2_sequestered',
                  'CO2 avoided': 'co2_avoided',
                  'Natural Gas': 'natural_gas',
                  'Electricity': 'electricity',
                  'CO2 Storage': 'co2_storage'}

INCHES_PER_CM = 2.54

def set_environmental_summaries(tree):
    from treemap.models import TreeResource, ClimateZone

    species = tree.species
    dbh = tree.dbh

    if not species or not dbh:
        return None

    dbh_cm = convert_dbh_to_inches(dbh) * INCHES_PER_CM

    tr = TreeResource.objects.filter(tree=tree)

    # Determine which region the tree is currently in:
    if settings.MULTI_REGION_ITREE_ENABLED:
        target_region = tree.plot.itree_region()

        if target_region is None:
            return False

        resources = species.resource.filter(region=target_region)
    else:
        resources = species.resource.all()

    if not resources:
        if tr:
            tr.delete()

        return False

    region = resources[0].region
    code = resources[0].meta_species

    if tr:
        tr = tr[0]
    else:
        tr = TreeResource(tree=tree)

    base_resources = calc_base_resources(code, dbh_cm, RESOURCE_NAMES, region)
    results = calc_resource_summaries(base_resources)

    if not results:
        if tr.id:
            tr.delete()
        return None

    for k,v in results.items():
        setattr(tr, k, v)

    tr.save()
    return True


def calc_base_resources(itree_code, dbh_cm, resource_list, region=None):
    if region is None:
        region = settings.ITREE_REGION

    results = {}
    for tr_key, resource_key in resource_list.iteritems():
        fname = "%s_dbh" % tr_key.lower().replace(' ','_')

        results[fname] = benefits.get_factor_for_trees(
            region, resource_key, [(itree_code, dbh_cm)])

    return results


def calc_resource_summaries(br):
    summaries = {}
    summaries['annual_stormwater_management'] = br['hydro_interception_dbh'] * 264.1
    summaries['annual_electricity_conserved'] = br['electricity_dbh']
    # http://sftrees.securemaps.com/ticket/25#comment:7
    summaries['annual_natural_gas_conserved'] = br['natural_gas_dbh'] * 0.293
    summaries['annual_air_quality_improvement'] = (
        br['aq_ozone_dep_dbh'] +
        br['aq_nox_dep_dbh'] +
        br['aq_pm10_dep_dbh'] +
        br['aq_sox_dep_dbh'] +
        br['aq_nox_avoided_dbh'] +
        br['aq_pm10_avoided_dbh'] +
        br['aq_sox_avoided_dbh'] +
        br['aq_voc_avoided_dbh'] +
        br['bvoc_dbh']) * 2.2
    summaries['annual_ozone'] = br['aq_ozone_dep_dbh'] * 2.2
    summaries['annual_nox'] = br['aq_nox_dep_dbh'] + br['aq_nox_avoided_dbh'] * 2.2
    summaries['annual_pm10'] = br['aq_pm10_dep_dbh'] + br['aq_pm10_avoided_dbh'] * 2.2
    summaries['annual_sox'] = br['aq_sox_dep_dbh'] + br['aq_sox_avoided_dbh'] * 2.2
    summaries['annual_voc'] = br['aq_voc_avoided_dbh'] * 2.2
    summaries['annual_bvoc'] = br['bvoc_dbh'] * 2.2
    summaries['annual_co2_sequestered'] = br['co2_sequestered_dbh'] * 2.2
    summaries['annual_co2_avoided'] = br['co2_avoided_dbh'] * 2.2
    summaries['annual_co2_reduced'] = (br['co2_sequestered_dbh'] + br['co2_avoided_dbh']) * 2.2
    summaries['total_co2_stored'] = br['co2_storage_dbh'] * 2.2
    summaries['annual_energy_conserved'] = br['electricity_dbh'] + br['natural_gas_dbh'] * 0.293
    return summaries

########NEW FILE########
__FILENAME__ = export
# 
# This module contains functions to be used for
# exporting data to various formats using ogr2ogr
#

import re

def sanitize_raw_sql(query):
    """
    Takes a raw sql string and performs some sql surgery to
    make queries valid on postgres
    """
    new_query = query

    new_query = _sanitize_native_status_field(new_query)


    for qualified_field in ('U0."last_updated"',
                            '"treemap_tree"."last_updated"',
                            '"treemap_plot"."last_updated"'):
        new_query = _sanitize_date_comparison_field(qualified_field, new_query)

    for qualified_field in ('U0."username"',
                  'U0."tree_owner"',
                  '"treemap_tree"."tree_owner"',
                  '"treemap_tree"."sponsor"'):
        new_query = _sanitize_string_like_upper_field(qualified_field, new_query)

    for field in ("sidewalk_damage",
                  "condition",
                  "canopy_condition",
                  "pests"):
        new_query = _sanitize_membership_test_field(field, new_query)

    return new_query

####################################
## PRIVATE FUNCTIONS
####################################

def _quote_integers_in_pattern(pattern, query):
    def quote_integer(matchobj):
        return "'" + matchobj.group() + "'"

    def quote_integers(matchobj):
        return re.sub(r'(\d)', quote_integer, matchobj.group())

    return re.sub(pattern, quote_integers, query)

def _sanitize_native_status_field(query):
    return query.replace('"native_status" = True', '"native_status" = \'True\'')

def _sanitize_membership_test_field(field_name, query):
    pattern = '"%s" IN \([0-9, ]+\)' % field_name
    return _quote_integers_in_pattern(pattern, query)

def _sanitize_string_like_upper_field(qualified_field_name, query):
    pattern = 'UPPER\({}::text\) LIKE UPPER\(%([\w.@+-]+)%\)'.format(qualified_field_name)
    replacement = r"""UPPER({}::text) LIKE UPPER('%\1%')""".format(qualified_field_name)
    return re.sub(pattern, replacement, query)

def _sanitize_date_comparison_field(qualified_field_name, query):
    pattern = '%s (>=|<=) (\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})' % qualified_field_name
    replacement = r"""{} \1 '\2'""".format(qualified_field_name)
    return re.sub(pattern, replacement, query)

########NEW FILE########
__FILENAME__ = forms
from django import forms
from models import Tree, Plot, Species, TreePhoto, TreeAlert, TreeAction, Neighborhood, ZipCode, ImportEvent, status_choices
from shortcuts import get_add_initial
from django.conf import settings
from django.contrib.auth.models import User
from treemap.localization import PostalCodeField
from django.contrib.gis.geos import Point
from django.contrib.gis.measure import D
from datetime import datetime
import math


class ContactForm(forms.Form):
    name = forms.CharField(max_length=100, 
           help_text="Full Name", widget=forms.TextInput(attrs={'size':'40'}),required=False)
    subject = forms.CharField(max_length=100, 
              help_text="Subject of your message", widget=forms.TextInput(attrs={'size':'40'}))
    sender = forms.EmailField(
              help_text="Your email address", widget=forms.TextInput(attrs={'size':'40'}),required=True)
    message = forms.CharField(
              help_text="Please enter as much text as you would like", 
              widget=forms.Textarea(attrs={'rows':'12','cols':'60'}))
    cc_myself = forms.BooleanField(required=False, 
                help_text="Send yourself a copy of this message")
                
class TreeEditPhotoForm(forms.ModelForm):
    class Meta:
        model = TreePhoto
        exclude = ('reported_by',)
        fields = ('title','photo',)

class TreeAddForm(forms.Form):
    edit_address_street = forms.CharField(max_length=200, required=True, initial=get_add_initial('address'))
    geocode_address = forms.CharField(widget=forms.HiddenInput, max_length=255, required=True)
    edit_address_city = forms.CharField(max_length=200, required=False, initial=get_add_initial('city'))
    edit_address_zip = PostalCodeField(required=False)
    lat = forms.FloatField(widget=forms.HiddenInput,required=True)
    lon = forms.FloatField(widget=forms.HiddenInput,required=True)
    initial_map_location = forms.CharField(max_length=200, required=False, widget=forms.HiddenInput)
    species_name = forms.CharField(required=False, initial=get_add_initial('species_full'))
    species_other1 = forms.CharField(required=False, initial=get_add_initial('genus'))
    species_other2 = forms.CharField(required=False, initial=get_add_initial('species'))
    species_id = forms.CharField(widget=forms.HiddenInput, required=False)
    dbh = forms.FloatField(required=False, label="Trunk size", initial=get_add_initial('dbh'))
    dbh_type = forms.ChoiceField(required=False, widget=forms.RadioSelect, choices=[('diameter', 'Diameter'), ('circumference', 'Circumference')])
    height = forms.FloatField(required=False, label="Tree height", initial=get_add_initial('height'))
    canopy_height = forms.IntegerField(required=False, initial=get_add_initial('canopy'))
    plot_width = forms.ChoiceField(required=False, choices=[('1','1'),('2','2'),('3','3'),('4','4'),('5','5'),('6','6'),('7','7'),('8','8'),('9','9'),('10','10'),('11','11'),('12','12'),('13','13'),('14','14'),('15','15'),('99','15+')])
    plot_length = forms.ChoiceField(required=False, choices=[('1','1'),('2','2'),('3','3'),('4','4'),('5','5'),('6','6'),('7','7'),('8','8'),('9','9'),('10','10'),('11','11'),('12','12'),('13','13'),('14','14'),('15','15'),('99','15+')])
    plot_width_in = forms.ChoiceField(required=False, choices=[('1','1'),('2','2'),('3','3'),('4','4'),('5','5'),('6','6'),('7','7'),('8','8'),('9','9'),('10','10'),('11','11')])
    plot_length_in = forms.ChoiceField(required=False, choices=[('1','1'),('2','2'),('3','3'),('4','4'),('5','5'),('6','6'),('7','7'),('8','8'),('9','9'),('10','10'),('11','11')])
    pests = forms.ChoiceField(choices=settings.CHOICES['pests'], required=False)
    plot_type = forms.TypedChoiceField(choices=settings.CHOICES["plot_types"], required=False)
    power_lines = forms.TypedChoiceField(choices=settings.CHOICES["powerlines"], required=False)
    sidewalk_damage = forms.ChoiceField(choices=settings.CHOICES["sidewalks"], required=False)
    condition = forms.ChoiceField(choices=settings.CHOICES["conditions"], required=False)
    canopy_condition = forms.ChoiceField(choices=settings.CHOICES["canopy_conditions"], required=False)
    target = forms.ChoiceField(required=False, choices=settings.ADD_FORM_TARGETS, initial=settings.ADD_FORM_TARGETS_DEFAULT, widget=forms.RadioSelect)        
    owner_additional_id = forms.CharField(required=False, initial=get_add_initial('owner'))

    def __init__(self, *args, **kwargs):
        super(TreeAddForm, self).__init__(*args, **kwargs)
        if not self.fields['plot_type'].choices[0][0] == '':        
            self.fields['pests'].choices.insert(0, ('','Select One...' ) )
            self.fields['plot_type'].choices.insert(0, ('','Select One...' ) )
            self.fields['power_lines'].choices.insert(0, ('','Select One...' ) )
            self.fields['sidewalk_damage'].choices.insert(0, ('','Select One...' ) )
            self.fields['condition'].choices.insert(0, ('','Select One...' ) )
            self.fields['canopy_condition'].choices.insert(0, ('','Select One...' ) )
            self.fields['plot_width'].choices.insert(0, ('','Select Feet...' ) )
            self.fields['plot_width_in'].choices.insert(0, ('','Select Inches...' ) )
            self.fields['plot_length'].choices.insert(0, ('','Select Feet...' ) )
            self.fields['plot_length_in'].choices.insert(0, ('','Select Inches...' ) )


    def clean(self):        
        cleaned_data = self.cleaned_data 
        height = cleaned_data.get('height')
        canopy_height = cleaned_data.get('canopy_height') 
        try:
            point = Point(cleaned_data.get('lon'),cleaned_data.get('lat'),srid=4326)  
            nbhood = Neighborhood.objects.filter(geometry__contains=point)
        except:
            raise forms.ValidationError("This tree is missing a location. Enter an address in Step 1 and update the map to add a location for this tree.") 
        
        if nbhood.count() < 1:
            raise forms.ValidationError("The selected location is outside our area. Please specify a location within " + settings.REGION_NAME)
        
        if height > 300:
            raise forms.ValidationError("Height is too large.")
        if canopy_height > 300:
            raise forms.ValidationError("Canopy height is too large.")

        if canopy_height and height and canopy_height > height:
            raise forms.ValidationError("Canopy height cannot be larger than tree height.")

        # initial_map_location is an optional field so only trigger the validation if it was specified
        if cleaned_data.get('initial_map_location'):
            initial_map_location = cleaned_data.get('initial_map_location').split(',')
            initial_point = Point(float(initial_map_location[1]), float(initial_map_location[0]),srid=4326)
            if point == initial_point:
                raise forms.ValidationError("We need a more precise location for the tree. Please move the tree marker from the default location for this address to the specific location of the tree planting site. ")

        return cleaned_data 
        
    def save(self,request):
        from django.contrib.gis.geos import Point

        plot = Plot()
        plot.data_owner = request.user

        address = self.cleaned_data.get('edit_address_street')
        if address:
            plot.address_street = address
            plot.geocoded_address = address
        city = self.cleaned_data.get('edit_address_city')
        geo_address = self.cleaned_data.get('geocode_address')
        if geo_address:
            plot.geocoded_address = geo_address
        if city:
            plot.address_city = city
        zip_ = self.cleaned_data.get('edit_address_zip')
        if zip_:
            plot.address_zip = zip_
        
        plot_width = self.cleaned_data.get('plot_width')
        plot_width_in = self.cleaned_data.get('plot_width_in')
        if plot_width:
            plot.width = float(plot_width)
        if plot_width_in:
            plot.width = plot.width + (float(plot_width_in) / 12)
        plot_length = self.cleaned_data.get('plot_length')
        plot_length_in = self.cleaned_data.get('plot_length_in')
        if plot_length:
            plot.length = float(plot_length)
        if plot_length_in:
            plot.length = plot.length + (float(plot_length_in) / 12)
        plot_type = self.cleaned_data.get('plot_type')
        if plot_type:
            plot.type = plot_type
        power_lines = self.cleaned_data.get('power_lines')
        if power_lines != "":
            plot.powerline_conflict_potential = power_lines
        sidewalk_damage = self.cleaned_data.get('sidewalk_damage')
        if sidewalk_damage:
            plot.sidewalk_damage = sidewalk_damage
        owner_additional_id = self.cleaned_data.get('owner_additional_id')
        if owner_additional_id:
            plot.owner_additional_id = owner_additional_id

        import_event, created = ImportEvent.objects.get_or_create(file_name='site_add',)
        plot.import_event = import_event

        pnt = Point(self.cleaned_data.get('lon'),self.cleaned_data.get('lat'),srid=4326)
        plot.geometry = pnt
        plot.last_updated_by = request.user
        plot.save()

        species = self.cleaned_data.get('species_id')
        species_other1 = self.cleaned_data.get('species_other1')
        species_other2 = self.cleaned_data.get('species_other2')
        height = self.cleaned_data.get('height')
        canopy_height = self.cleaned_data.get('canopy_height')
        dbh = self.cleaned_data.get('dbh')
        dbh_type = self.cleaned_data.get('dbh_type')
        condition = self.cleaned_data.get('condition')
        canopy_condition = self.cleaned_data.get('canopy_condition')

        #TODO: fix this
        pests = self.cleaned_data.get('pests')
        if species or height or canopy_height or dbh or \
           condition or canopy_condition or pests:
           # print species, height, canopy_height, dbh, condition, canopy_condition
            if species:
                spp = Species.objects.filter(id=species)
                if spp:
                    new_tree = Tree(species=spp[0])
                else:
                    new_tree = Tree()
            else:
                new_tree = Tree()

            new_tree.pests = pests

            if species_other1:
                new_tree.species_other1 = species_other1
            if species_other2:
                new_tree.species_other2 = species_other2
            if height:
                new_tree.height = height
            if canopy_height:
                new_tree.canopy_height = canopy_height
            if dbh:
                if dbh_type == 'circumference':
                    new_tree.dbh = dbh / math.pi
                else:
                    new_tree.dbh = dbh
            if condition:
                new_tree.condition = condition
            if canopy_condition:
                new_tree.canopy_condition = canopy_condition
            
            new_tree.import_event = import_event            
            new_tree.last_updated_by = request.user
            new_tree.plot = plot
            new_tree.save()
            #print new_tree.__dict__
        
        return plot
     

########NEW FILE########
__FILENAME__ = localization
from django.conf import settings

def PostalCodeField(*args, **kwargs):
    if settings.POSTAL_CODE_FIELD == "GBPostcodeField":
        from django.contrib.localflavor.uk.forms import UKPostcodeField
        return UKPostcodeField(*args, **kwargs)
    else:
        from django.contrib.localflavor.us.forms import USZipCodeField
        return USZipCodeField(*args, **kwargs)

def convert_dbh_to_inches(dbh):
    return float(dbh) * settings.DBH_TO_INCHES_FACTOR


########NEW FILE########
__FILENAME__ = audit_export
from django.core.management.base import BaseCommand

from optparse import make_option

from treemap.models import Tree, Plot
import json

# this was selectively copied from the migrating code on the otm2 side.
# where possible, notes are made for differences.
MODELS = {
    'tree': {
        'model_class': Tree,
        'common_fields': {'plot', 'species', 'readonly', 'canopy_height',
                          'date_planted', 'date_removed', 'height'},
        'renamed_fields': {'dbh': 'diameter',
                           'species_id': 'species', # NOT included in otm2 counterpart
                       },
        'removed_fields': {'tree_owner', 'steward_name', 'sponsor',
                           'species_other1', 'species_other2',
                           'orig_species', 'present', 'last_updated',
                           'last_updated_by', 's_order', 'photo_count',
                           'projects', 'condition', 'canopy_condition',
                           'url', 'pests', 'steward_user'},
        # NOT included in otm2 counterpart
        'foreign_events': {'Fruit or Nuts Harvested',
                           'Watered', 'Inspected', 'Pruned'}
    },
    'plot': {
        'common_fields': {'width', 'length', 'address_street', 'address_zip',
                          'address_city', 'owner_orig_id', 'readonly'},
        'renamed_fields': {'geometry': 'geom'},
        'undecided_fields': {'import_event'},
        'removed_fields': {'type', 'powerline_conflict_potential',
                           'sidewalk_damage', 'neighborhood',
                           'neighborhoods', 'zipcode', 'geocoded_accuracy',
                           'geocoded_address', 'geocoded_lat', 'geocoded_lon',
                           'present', 'last_updated', 'last_updated_by',
                           'data_owner', 'owner_additional_id',
                           'owner_additional_properties'},
    },
}

AUDIT_TYPES = {
    'I': 1,
    'D': 2,
    'U': 3
}

class AuditParseException(Exception):
    pass

def _nested_insert(d, key, nestedkey, value):
    if key in d:
        d[key][nestedkey] = value
    else:
        d[key] = { nestedkey: value }


def get_old_new_pairs(flat_hash):
    """
    Split previous ('old_' keys) and current values into nested hashes.

    otm1 audits are serialized dictionaries with keys that are either
    field names, or field names prefixed with 'old_'. This function
    splits these out to nested hashes of 'previous'/'current' values
    on a per-field basis.

    To further complicate matters, some foreign key event records are
    stored as double pairs in the format:
    {'old_key':u'', 'old_value':u'None',
     'key':'{{ event record name }}', 'value':'{{ event date }}'}
    these are homogenized and stored as pairs as described above.
    """
    clean_hash = {k: v for k, v in flat_hash.items()
                  if k not in ('value', 'old_value') }
    newhash = {}

    for k in clean_hash:
        if k == 'key':
            newkey = flat_hash['key']
            nestedkey = 'current'
            v = flat_hash['value']
        elif k == 'old_key':
            newkey = flat_hash['key']
            nestedkey = 'previous'
            v = flat_hash['old_value']
        elif k.startswith('old_'):
            newkey = k[4:]
            nestedkey = 'previous'
            v = flat_hash[k]
        else:
            newkey = k
            nestedkey = 'current'
            v = flat_hash[k]

        _nested_insert(newhash, newkey, nestedkey, v)

    return newhash

def _parse_diff(audit, model):
    """
    Turn _audit_diff field into a list of sanitized
    (field, previous, current) tuples.

    This is the main processing function of this module.
    Validate format against audit type, deserialize from JSON,
    iterate over changed values, filter out unused fields,
    sanitize values.
    """

    diff_j = audit._audit_diff

    # process record level changes
    if diff_j == '':
        if audit._audit_change_type == 'I':
            return [('id', None, audit.id)]
        elif audit._audit_change_type == 'D':
            return [('id', audit.id, None)]
        else:
            raise AuditParseException('No diff on an update?')

    # process field level changes
    else:
        diff = json.loads(diff_j)
        paired_diff = get_old_new_pairs(diff)
        model_rules = MODELS[model]

        changes = []
        for k, v in paired_diff.iteritems():

            # TODO: Sanitize values in a centralized place
            v = None if v == 'None' else v

            if k in model_rules['removed_fields']:
                # drop these values.
                # TODO: log these
                pass

            elif k in model_rules['renamed_fields']:
                changes.append(
                    (model_rules['renamed_fields'][k], v.get('previous', None), v.get('current', None)))

            elif k in model_rules['common_fields']:
                changes.append(
                    (k, v.get('previous', None), v.get('current', None)))

            elif k == 'new photo':
                # TODO: figure out how to support these and add them
                self.stdout.write("SKIPPING UNHANDLED NEW PHOTO: '{%s: %s}'" % (k, v))
            elif k in model_rules.get('foreign_events', set()):
                # TODO: figure out how to support these and add them
                self.stdout.write("SKIPPING UNHANDLED FOREIGN EVENT: '{%s: %s}'" % (k, v))
            else:
                raise Exception("ERROR: UNHANDLED DIFF KEY - '{%s: %s}'" % (k, v))

        return changes

def get_audit_dicts(qs, model_name, audit_count):
    lowercase_model_name = model_name.lower()
    audit_dicts = []
    skipped = 0
    for model in qs:
        history = model.history.order_by('_audit_timestamp')
        for audit in history:
            try:
                changes = _parse_diff(audit, lowercase_model_name)
                for field, previous_value, current_value in changes:
                    audit_dict = {
                        'pk': audit_count + 1,
                        'model': 'treemap.audit',
                        'fields': {
                            'model': model_name,
                            'model_id': model.pk,
                            'field': field,
                            'previous_value': previous_value,
                            'current_value': current_value,
                            'user': model.last_updated_by.pk,
                            'action': AUDIT_TYPES[audit._audit_change_type],
                            'requires_auth': False,
                            'ref': None,
                            'created': audit._audit_timestamp.isoformat(),
                            'updated': audit._audit_timestamp.isoformat()
                        }
                    }
                    audit_dicts.append(audit_dict)
                    audit_count += 1
            except AuditParseException:
                skipped += 1

    return audit_dicts, skipped, audit_count

class Command(BaseCommand):

    option_list = BaseCommand.option_list + (
        make_option('-o', '--outfile',
                    action='store',
                    type='string',
                    dest='outfile',
                    help='path to export the data to'),
    )

    def handle(self, *args, **options):
        audit_count = 1
        trees = Tree.objects.all()
        plots = Plot.objects.all()

        tree_hashes, tree_skipped, audit_count = get_audit_dicts(trees, 'Tree', audit_count)
        plot_hashes, plot_skipped, audit_count = get_audit_dicts(plots, 'Plot', audit_count)

        skipped = tree_skipped + plot_skipped

        self.stdout.write("EXPORTED: %s audits" % audit_count - 1)
        self.stdout.write("SKIPPED: %s audits" % skipped)
        output = open(options['outfile'], 'w+b')
        json.dump(tree_hashes + plot_hashes, output)

########NEW FILE########
__FILENAME__ = build_exports
import datetime
from django.core.management.base import BaseCommand, CommandError
from django.db import connection, transaction
from UrbanForestMap import settings
from UrbanForestMap.treemap import models
from UrbanForestMap.treemap.spreadsheet import queryset_to_excel_file 
from django.template import loader
from django.contrib.gis.shortcuts import compress_kml

class Command(BaseCommand):
   
    def handle(self, *args, **options):
        print "Getting all trees..."
        trees = models.Tree.objects.filter(present=True)
        print "Writing %i trees to CSV" % trees.count()
        queryset_to_excel_file(trees, "All_Trees",force_csv=True)
        print "Getting kml strings..."        
        trees = trees.kml()
        output = file('All_Trees.kmz','wb')
        print "Writing %i trees to KML" % trees.count()
        output.write(compress_kml(loader.render_to_string("treemap/kml_output.kml", {'trees': trees,'root_url':settings.ROOT_URL})))
        output.close()




    def write_csv(self, trees):
        clip_length = 5000
        current_clip = 5000
        tree_clip = trees[:current_clip]
        output = file('All_Trees.csv','ab')
        output.truncate(0)
        while tree_clip:
            data = list(tree_clip.values())
            for row in data:
                out_row = []
                for value in row:
                    if not isinstance(value, basestring):
                        value = unicode(value)
                    value = value.encode(encoding)
                    out_row.append(value.replace('"', '""'))
                output.write('"%s"\n' %
                             '","'.join(out_row))
            tree_clip = trees[current_clip+1:current_clip + clip_length]
            current_clip = current_clip + clip_length
        output.close()

########NEW FILE########
__FILENAME__ = dumpdata_iter
from django.core.exceptions import ImproperlyConfigured
from django.core.management.base import BaseCommand, CommandError
from django.core import serializers
from django.db import connections, router, DEFAULT_DB_ALIAS
from django.utils.datastructures import SortedDict

from django.core.serializers.python import Serializer as PythonSerializer

from optparse import make_option

class Command(BaseCommand):
    option_list = BaseCommand.option_list + (
        make_option('--format', default='json', dest='format',
            help='Specifies the output serialization format for fixtures.'),
        make_option('--indent', default=None, dest='indent', type='int',
            help='Specifies the indent level to use when pretty-printing output'),
        make_option('--database', action='store', dest='database',
            default=DEFAULT_DB_ALIAS, help='Nominates a specific database to load '
                'fixtures into. Defaults to the "default" database.'),
        make_option('-e', '--exclude', dest='exclude',action='append', default=[],
            help='An appname or appname.ModelName to exclude (use multiple --exclude to exclude multiple apps/models).'),
        make_option('-n', '--natural', action='store_true', dest='use_natural_keys', default=False,
            help='Use natural keys if they are available.'),
        make_option('-a', '--all', action='store_true', dest='use_base_manager', default=False,
            help="Use Django's base manager to dump all models stored in the database, including those that would otherwise be filtered or modified by a custom manager."),
    )
    help = ("Output the contents of the database as a fixture of the given "
            "format (using each model's default manager unless --all is "
            "specified).")
    args = '[appname appname.ModelName ...]'

    def handle(self, *app_labels, **options):
        from django.db.models import get_app, get_apps, get_models, get_model

        format = options.get('format','json')
        indent = options.get('indent',None)
        using = options.get('database', DEFAULT_DB_ALIAS)
        connection = connections[using]
        excludes = options.get('exclude',[])
        show_traceback = options.get('traceback', False)
        use_natural_keys = options.get('use_natural_keys', False)
        use_base_manager = options.get('use_base_manager', False)

        excluded_apps = set()
        excluded_models = set()
        for exclude in excludes:
            if '.' in exclude:
                app_label, model_name = exclude.split('.', 1)
                model_obj = get_model(app_label, model_name)
                if not model_obj:
                    raise CommandError('Unknown model in excludes: %s' % exclude)
                excluded_models.add(model_obj)
            else:
                try:
                    app_obj = get_app(exclude)
                    excluded_apps.add(app_obj)
                except ImproperlyConfigured:
                    raise CommandError('Unknown app in excludes: %s' % exclude)

        if len(app_labels) == 0:
            app_list = SortedDict((app, None) for app in get_apps() if app not in excluded_apps)
        else:
            app_list = SortedDict()
            for label in app_labels:
                try:
                    app_label, model_label = label.split('.')
                    try:
                        app = get_app(app_label)
                    except ImproperlyConfigured:
                        raise CommandError("Unknown application: %s" % app_label)
                    if app in excluded_apps:
                        continue
                    model = get_model(app_label, model_label)
                    if model is None:
                        raise CommandError("Unknown model: %s.%s" % (app_label, model_label))

                    if app in app_list.keys():
                        if app_list[app] and model not in app_list[app]:
                            app_list[app].append(model)
                    else:
                        app_list[app] = [model]
                except ValueError:
                    # This is just an app - no model qualifier
                    app_label = label
                    try:
                        app = get_app(app_label)
                    except ImproperlyConfigured:
                        raise CommandError("Unknown application: %s" % app_label)
                    if app in excluded_apps:
                        continue
                    app_list[app] = None

        # Check that the serialization format exists; this is a shortcut to
        # avoid collating all the objects and _then_ failing.
        if format not in serializers.get_public_serializer_formats():
            raise CommandError("Unknown serialization format: %s" % format)

        try:
            serializers.get_serializer(format)
        except KeyError:
            raise CommandError("Unknown serialization format: %s" % format)

        def get_objects():
        # Now collate the objects to be serialized.
            for model in sort_dependencies(app_list.items()):
                if model in excluded_models:
                    continue
                if not model._meta.proxy and router.allow_syncdb(using, model):
                    if use_base_manager:
                        objects = model._base_manager
                    else:
                        objects = model._default_manager
                for obj in objects.using(using).order_by(model._meta.pk.name).iterator():
                    yield obj

        try:
            return serializers.serialize(format, get_objects(), indent=indent,
                                         use_natural_keys=use_natural_keys, stream=self.stdout)
        except Exception, e:
            if show_traceback:
                raise
            raise CommandError("Unable to serialize database: %s" % e)

def sort_dependencies(app_list):
    """Sort a list of app,modellist pairs into a single list of models.

    The single list of models is sorted so that any model with a natural key
    is serialized before a normal model, and any model with a natural key
    dependency has it's dependencies serialized first.
    """
    from django.db.models import get_model, get_models
    # Process the list of models, and get the list of dependencies
    model_dependencies = []
    models = set()
    for app, model_list in app_list:
        if model_list is None:
            model_list = get_models(app)

        for model in model_list:
            models.add(model)
            # Add any explicitly defined dependencies
            if hasattr(model, 'natural_key'):
                deps = getattr(model.natural_key, 'dependencies', [])
                if deps:
                    deps = [get_model(*d.split('.')) for d in deps]
            else:
                deps = []

            # Now add a dependency for any FK or M2M relation with
            # a model that defines a natural key
            for field in model._meta.fields:
                if hasattr(field.rel, 'to'):
                    rel_model = field.rel.to
                    if hasattr(rel_model, 'natural_key'):
                        deps.append(rel_model)
            for field in model._meta.many_to_many:
                rel_model = field.rel.to
                if hasattr(rel_model, 'natural_key'):
                    deps.append(rel_model)
            model_dependencies.append((model, deps))

    model_dependencies.reverse()
    # Now sort the models to ensure that dependencies are met. This
    # is done by repeatedly iterating over the input list of models.
    # If all the dependencies of a given model are in the final list,
    # that model is promoted to the end of the final list. This process
    # continues until the input list is empty, or we do a full iteration
    # over the input models without promoting a model to the final list.
    # If we do a full iteration without a promotion, that means there are
    # circular dependencies in the list.
    model_list = []
    while model_dependencies:
        skipped = []
        changed = False
        while model_dependencies:
            model, deps = model_dependencies.pop()

            # If all of the models in the dependency list are either already
            # on the final model list, or not on the original serialization list,
            # then we've found another model with all it's dependencies satisfied.
            found = True
            for candidate in ((d not in models or d in model_list) for d in deps):
                if not candidate:
                    found = False
            if found:
                model_list.append(model)
                changed = True
            else:
                skipped.append((model, deps))
        if not changed:
            raise CommandError("Can't resolve dependencies for %s in serialized app list." %
                ', '.join('%s.%s' % (model._meta.app_label, model._meta.object_name)
                for model, deps in sorted(skipped, key=lambda obj: obj[0].__name__))
            )
        model_dependencies = skipped

    return model_list

########NEW FILE########
__FILENAME__ = itree_import
from os.path import dirname
import operator
from decimal import *
import csv
import os.path
import os
from datetime import datetime
from dbfpy import dbf
from optparse import make_option
from django.core.management.base import BaseCommand, CommandError
from treemap.models import Resource

class Command(BaseCommand):
    args = '<input_file_name, column_name>'
    option_list = BaseCommand.option_list + (
        make_option('--verbose',
            action='store_true',
            dest='verbose',
            default=False,
            help='Show verbose debug text'),
    )

    def write_headers_if_needed(self):
        if not self.wrote_headers:
            self.err_writer.writerow(self.headers)
            self.wrote_headers = True

    def get_dbf_rows(self, in_file):
        reader = dbf.Dbf(in_file)
        print 'Opening input file: %s ' % in_file

        self.headers = reader.fieldNames
        
        print 'Converting input file to dictionary'
        rows = []
        for dbf_row in reader:
            d = {}
            for name in self.headers:
                d[name] = dbf_row[name]
            rows.append(d)
        return rows
    
    def get_csv_rows(self, in_file):
        reader = csv.DictReader(open(in_file, 'r' ), restval=123)
        print 'Opening input file: %s ' % in_file

        rows = list(reader)
                
        self.headers = reader.fieldnames
                
        return rows
    
    def name2column(self, name):
        match_dict = {
            "AQ_NOx_avoided.csv": "aq_nox_avoided_dbh",
            "AQ_PM10_avoided.csv": "aq_pm10_avoided_dbh",
            "AQ_SOx_dep.csv": "aq_sox_dep_dbh",
            "CO2_avoided.csv": "co2_avoided_dbh",
            "Electricity.csv": "electricity_dbh",
            "AQ_NOx_dep.csv": "aq_nox_dep_dbh",
            "AQ_PM10_dep.csv": "aq_pm10_dep_dbh",
            "AQ_VOC_avoided.csv": "aq_voc_avoided_dbh",
            "CO2_sequestered.csv": "co2_sequestered_dbh",
            "Hydro_Interception.csv": "hydro_interception_dbh",
            "AQ_Ozone_dep.csv": "aq_ozone_dep_dbh",
            "AQ_SOx_avoided.csv": "aq_sox_avoided_dbh",
            "BVOC.csv": "bvoc_dbh",
            "CO2_storage.csv": "co2_storage_dbh",
            "Natural_Gas.csv": "natural_gas_dbh" }

        if name in match_dict:
            return match_dict[name]
        else:
            raise Exception("You must either provide a standard "
                            "itree name (see below) or provide the "
                            "database column to write to. \n\n"
                            "Possible csv names: %s\n" % match_dict.keys() +
                            "Possible columns: %s\n" % match_dict.values())



    def handle(self, *args, **options):
        try:                
            self.verbose = options.get('verbose')            

            self.file_name = args[0]

            if os.path.isdir(self.file_name):
                self.process_dir(self.file_name)
            else:
                if len(args) == 1:
                    self.column_name = self.name2column(os.path.split(self.file_name)[1])
                else:
                    self.column_name = args[1]

                self.process_file(self.file_name)
        except Exception, e:
            raise
            print "Arguments:  Input_File_Name.[dbf|csv], column name"
            print "Options:    --verbose"

    def process_dir(self, adir):
        for f in os.listdir(adir):
            try:
                if f.endswith(".csv"):
                    f = adir + f
                    self.column_name = self.name2column(os.path.split(f)[1])
                    self.file_name = f
                    print "Processing %s (%s)" % (f, self.column_name)
                    self.process_file(f)
            except Exception, e:
                raise
                pass            

    def process_file(self, in_file):
        self.wrote_headers = False
        in_file = self.file_name
        err_file = in_file + ".err"
        
        self.err_writer = csv.writer(open(err_file, 'wb'))
        
        if self.file_name.endswith('.csv'):
            rows = self.get_csv_rows(in_file)
        if self.file_name.endswith('.dbf'):
            rows = self.get_dbf_rows(in_file)
        
        print 'Importing %d species' % len(rows)
        for i, row in enumerate(rows):
            self.handle_row(row)
            
            j = i + 1
            if j % 50 == 0:
               print 'Loaded %d...' % j
            self.log_verbose("item %d" % i)
        
        print "Finished data load. "
    
    def log_verbose(self, msg):
        if self.verbose: print msg
    
    def log_error(self, msg, row):
        print "ERROR: %s" % msg
        columns = [row[s] for s in self.headers]

        self.write_headers_if_needed(self)
        self.err_writer.writerow(columns)
    
    def check_resource(self, row):
        # locate the species and instanciate the tree instance
        
        if not row["code"]:            
            self.log_verbose("  No code column found")
            return (False, None)

        code = row['code']
       
        self.log_verbose("  Looking for species code: %s" % code)
        found = Resource.objects.filter(meta_species__iexact=code)
    
        if found: #species match found
            self.log_verbose("  Found species code %r" % found[0])
            return (True, found[0])
            
        #species data but no match, add it
        self.log_verbose("  Adding unknown species code %s " % code) 
        resource = Resource(meta_species=code, region="NorthernCalifornia")
        return (True, resource)

    
    def handle_row(self, row):
        self.log_verbose(row)
        
        # check the species (if any)
        ok, resource = self.check_resource(row)
        if not ok: return
        
        dbh_list = [3.81,11.43,22.86,38.10,53.34,68.58,83.82,99.06,114.3]
        if len(row)-1 > 10:
            dbh_list = [2.54,5.08,7.62,10.16,12.7,15.24,17.78,20.32,22.86,25.4,27.94,30.48,33.02,35.56,38.1,40.64,43.18,45.72,48.26,50.8,53.34,55.88,58.42,60.96,63.5,66.04,68.58,71.12,73.66,76.2,78.74,81.28,83.82,86.36,88.9,91.44,93.98,96.52,99.06,101.6,104.14,106.68,109.22,111.76,114.3]
        data = []
        for dbh in dbh_list:
            for value in row:
                if value == 'code': continue
                test = float(value)
                if dbh == test:
                    data.append(float(row[value]))
        self.log_verbose("  Final data %s" % data)    
        setattr(resource, self.column_name, data.__str__())
        
        resource.save()


########NEW FILE########
__FILENAME__ = resave_trees
import datetime
from django.core.management.base import BaseCommand, CommandError
from django.db import connection, transaction
from django.db.models import Count, Sum
from treemap.models import Tree


class Command(BaseCommand):
   
    def handle(self, *args, **options):
        for t in Tree.objects.all():
            print t.id
            t.save()


########NEW FILE########
__FILENAME__ = speciesimport
from os.path import dirname
import csv
from datetime import datetime
from dbfpy import dbf
from optparse import make_option
from django.core.management.base import BaseCommand, CommandError
from treemap.models import Species, Resource

class Command(BaseCommand):
    args = '<input_file_name>'
    option_list = BaseCommand.option_list + (
        make_option('--verbose',
            action='store_true',
            dest='verbose',
            default=False,
            help='Show verbose debug text'),
    )

    def write_headers_if_needed(self):
        if not self.wrote_headers:
            self.err_writer.writerow(self.headers)
            self.wrote_headers = True

    def get_dbf_rows(self, in_file):
        reader = dbf.Dbf(in_file)
        print 'Opening input file: %s ' % in_file

        self.headers = reader.fieldNames
        
        print 'Converting input file to dictionary'
        rows = []
        for dbf_row in reader:
            d = {}
            for name in self.headers:
                d[name] = dbf_row[name]
            rows.append(d)
        return rows
    
    def get_csv_rows(self, in_file):
        reader = csv.DictReader(open(in_file, 'r' ), restval=123)
        print 'Opening input file: %s ' % in_file

        rows = list(reader)
                
        self.headers = reader.fieldnames
                
        return rows
    
    def handle(self, *args, **options):
        try:    
            self.wrote_headers = False
            self.file_name = args[0]
            in_file = self.file_name
            err_file = in_file + ".err"
            self.verbose = options.get('verbose')
        except:
            print "Arguments:  Input_File_Name.[dbf|csv]"
            print "Options:    --verbose"
            return
        
        self.err_writer = csv.writer(open(err_file, 'wb'))
        
        if self.file_name.endswith('.csv'):
            rows = self.get_csv_rows(in_file)
        if self.file_name.endswith('.dbf'):
            rows = self.get_dbf_rows(in_file)
        
        print 'Importing %d species' % len(rows)
        for i, row in enumerate(rows):
            self.handle_row(row)
            
            j = i + 1
            if j % 50 == 0:
               print 'Loaded %d...' % j
            self.log_verbose("item %d" % i)
        
        print "Finished data load. "
    
    def log_verbose(self, msg):
        if self.verbose: print msg
    
    def log_error(self, msg, row):
        print "ERROR: %s" % msg
        columns = [row[s.lower()] for s in self.headers]
        self.write_headers_if_needed()
        self.err_writer.writerow(columns)
    
    def check_species(self, row):
        # locate the species and instanciate the tree instance        

        if not row["genus"]:            
            self.log_verbose("  No genus information")
            return (False, None)

        genus = str(row['genus']).strip()
        name = '%s' % genus
        species = ''
        cultivar = ''
	gender = ''
        if row.get('species'):
            species = str(row['species']).strip()
            name += " %s" % species
        if row.get('cultivar'):
            cultivar = str(row['cultivar']).strip()
            name += " %s" % cultivar
	if row.get('gender'): 
	    gender = str(row['gender']).strip()
	    name += " %s" % gender

        self.log_verbose("  Looking for species: %s" % name)
        found = Species.objects.filter(genus__iexact=genus).filter(species__iexact=species).filter(cultivar_name__iexact=cultivar).filter(gender__iexact=gender)
    
        if found: #species match found
            self.log_verbose("  Found species %r" % found[0])
            return (True, found[0])
            
        #species data but no match, add it
        self.log_verbose("  Adding unknown species %s %s %s" % (genus, species, cultivar)) 
        species = Species(genus=genus, species=species, cultivar_name=cultivar, scientific_name=name, gender=gender)
        return (True, species)

    
    def handle_row(self, row):
        self.log_verbose(row)
        
        row = dict((k.lower(),v) for (k,v) in row.items())

        # check the species (if any)
        ok, species = self.check_species(row)
        if not ok: return

        
        if row.get('common_name'):
            species.common_name = row['common_name']

        if row.get('usda_code'):
            species.symbol = row['usda_code']
        if row.get('itree_code'):
            species.itree_code = row['itree_code']
        if row.get('flowering'):
            species.flower_conspicuous = row['flowering'].lower() == 'yes'
        if row.get('flower_time'):
            species.bloom_period = row['flower_time']
        if row.get('fall_color'):
            species.fall_conspicuous = row['fall_color'].lower() == 'yes'
        if row.get('edible'):
            species.palatable_human = row['edible'].lower() == 'yes'
        if row.get('fruiting_time'):
            species.fruit_period = row['fruiting_time']
        if row.get('wildlife'):
            species.wildlife_value = row['wildlife'].lower() == 'yes'
        if row.get('native'):
            species.native_status = row['native'].lower() == 'yes'
        if row.get('webpage_link'):
            species.fact_sheet = row['webpage_link']
        
        species.save()
        self.log_verbose("After Save: ")
        self.log_verbose("---Common Name: %s" % species.common_name)
        self.log_verbose("---Symbol: %s" % species.symbol)
        self.log_verbose("---Itree Code: %s" % species.itree_code)
        self.log_verbose("---Flower Conspicuous: %s" % species.flower_conspicuous)
        self.log_verbose("---Bloom Period: %s" % species.bloom_period)
        self.log_verbose("---Fall Conspicuous: %s" % species.fall_conspicuous)
        self.log_verbose("---Edible: %s" % species.palatable_human)
        self.log_verbose("---Fruiting Time: %s" % species.fruit_period)
        self.log_verbose("---Wildlife Value: %s" % species.wildlife_value)
        self.log_verbose("---Native: %s" % species.native_status)
        self.log_verbose("---Link: %s" % species.fact_sheet)

        try:
            resource = Resource.objects.get(meta_species=species.itree_code)
            if resource:
                species.resource.clear()
                species.resource.add(resource)
            else:
                self.log_error("WARNING: No resource found for code %s" % species.itree_code, row)
        except:
            self.log_error("WARNING: No resource found for code %s" % species.itree_code, row)

########NEW FILE########
__FILENAME__ = testimports
import os

from subprocess import Popen, PIPE, STDOUT
from django.core.management.base import BaseCommand, CommandError
from OpenTreeMap.treemap.models import Tree, Plot
# ID - number
# POINT_X - EPSG:4326
# POINT_Y - EPSG:4326
# SCIENTIFIC - Genus species (ex: Tilia americana) must exist in DB
# ADDRESS - Geocodable street address
# PLOTTYPE - one of the DB plot choices, case insensitive
# PLOTLENGTH - number, feet
# PLOTWIDTH - number, feet
# POWERLINE - True/False
# OWNER - property or tree owner name, not a site user
# DATEPLANTED - postgres-recognizable format
# DIAMETER - number, inches
# HEIGHT - number, feet
# CANOPYHEIGHT - number, feet
# CONDITION - one of the db condition choices, case sensitive
# CANOPYCONDITION - one of the DB canopy condition choices, case sensitive

# POINT_X,POINT_Y,SCIENTIFIC,ADDRESS,PLOTTYPE,PLOTLENGTH,PLOTWIDTH,POWERLINE,OWNER,DATEPLANTED,DIAMETER,HEIGHT,CANOPYHEIGHT,CONDITION,CANOPYCONDITION

# -75.154724121093,39.910583496096,Tilia americana,,,,,,,2000-10-20,12,20,,,

class TestCase(object):
    def __init__(self, name, infiles, Pnum, Tnum):
        self.name = name
        self.infiles = infiles
        self.Pnum = Pnum
        self.Tnum = Tnum
        
    def run(self, uid):
        Tree.objects.all().delete()
        Plot.objects.all().delete()

        for name in self.infiles:
            path = os.path.join("testdata", name)
            cmd = ['python', 'manage.py', 'uimport', path, str(uid), '--verbose']
            p = Popen(cmd, stdout=PIPE)
            output = p.stdout.read()
            print "OUTPUT", output
            p.wait()

        n = len(Plot.objects.all())
        t = len(Tree.objects.all())
        if self.Pnum == n and self.Tnum == t:
            print "%-20s PASSED" % self.name
        else:
            print "%-20s FAILED Plots:(%d != %d) or Trees:(%d != %d)" % (self.name, n, self.Pnum, t, self.Tnum)

class Command(BaseCommand):
    args = '<test_case_name, verbose>'
    option_list = BaseCommand.option_list
    
    tests = [
        #TestCase("single", ['test1.csv'], 35),
        TestCase("duplicates", ['sparse.csv', 'sparse.csv'], 1, 0),
        TestCase("sparse-update", ['rich.csv', 'sparse.csv'], 1, 1),
        TestCase("rich-update", ['sparse.csv', 'rich.csv'], 1, 1),
        TestCase("sparse-11ft", ['sparse.csv', 'sparseoff11.csv'], 2, 0),    
        TestCase("sparse-9ft", ['sparse.csv', 'sparseoff9.csv'], 1, 0),        
        TestCase("sparse-4ft", ['sparse.csv', 'sparseoff4.csv'], 1, 0),
        TestCase("unknown_collisions", ['speciespairs.csv', 'unk_species.csv'], 12, 8),
        TestCase("species_collisions", ['speciespairs.csv', 'A_species.csv'], 12, 8),
    ]

    def handle(self, *args, **options):
        if args and args[0]:
            for t in self.tests:
                if t.name == args[0]: t.run(1)
        else:
            for t in self.tests:
                t.run(1)

########NEW FILE########
__FILENAME__ = uimport
from os.path import dirname
import csv
from datetime import datetime
from dbfpy import dbf
from optparse import make_option
from django.core.management.base import BaseCommand, CommandError
from django.contrib.gis.geos import Point
from django.contrib.gis.gdal import SpatialReference, CoordTransform
from django.contrib.auth.models import User
from treemap.models import Species, Tree, Plot, Neighborhood, ZipCode, TreeFlags, ImportEvent

# Change explicit value of plot.address_street (see 'TODO' below) as desired.
# Load CHOICES from your implementation-specific file (e.g. "from choices_SanDiego import *")
from choices import CHOICES as choices

class Command(BaseCommand):
    args = '<input_file_name, data_owner_id, base_srid, read_only>'
    option_list = BaseCommand.option_list + (
        make_option('--verbose',
            action='store_true',
            dest='verbose',
            default=False,
            help='Show verbose debug text'),
    )

    def write_headers_if_needed(self):
        if not self.wrote_headers:
            self.err_writer.writerow(self.headers)
            self.wrote_headers = True

    def get_dbf_rows(self, in_file):
        reader = dbf.Dbf(in_file)
        print 'Opening input file: %s ' % in_file

        self.headers = reader.fieldNames

        print 'Converting input file to dictionary'
        rows = []
        for dbf_row in reader:
            d = {}
            for name in self.headers:
                d[name] = dbf_row[name]
            rows.append(d)
        return rows

    def get_csv_rows(self, in_file):
        reader = csv.DictReader(open(in_file, 'r' ), restval=123)
        print 'Opening input file: %s ' % in_file

        rows = list(reader)

        self.headers = reader.fieldnames

        return rows

    def handle(self, *args, **options):
        self.wrote_headers = False
        try:
            self.file_name = args[0]
            in_file = self.file_name
            err_file = in_file + ".err"
            self.verbose = options.get('verbose')
            self.user_id = args[1]
            if len(args) > 2:
                self.base_srid = int(args[2])
                self.tf = CoordTransform(SpatialReference(self.base_srid), SpatialReference(4326))
                print "Using transformation object: %s" % self.tf
            else:
                self.base_srid = 4326
            if len(args) > 3:
                self.readonly = bool(args[3])
                print "Setting readonly flag to %s" % self.readonly
            else:
                self.readonly = False
        except:
            print "Arguments:  Input_File_Name.[dbf|csv] Data_Owner_User_Id (Optional: Base_SRID ReadOnly-bool)"
            print "Options:    --verbose"
            return

        self.err_writer = csv.writer(open(err_file, 'wb'))

        if self.file_name.endswith('.csv'):
            rows = self.get_csv_rows(in_file)
        if self.file_name.endswith('.dbf'):
            rows = self.get_dbf_rows(in_file)

        self.data_owner = User.objects.get(pk=self.user_id)
        self.updater = User.objects.get(pk=1)

        self.import_event = ImportEvent(file_name=self.file_name)
        self.import_event.save()

        print 'Importing %d records' % len(rows)
        for i, row in enumerate(rows):
            self.handle_row(row)

            j = i + 1
            if j % 50 == 0:
               print 'Loaded %d...' % j
            self.log_verbose("item %d" % i)

        print "Finished data load. "

        print "Calculating new species tree counts... "
        for s in Species.objects.all():
            s.save()
        print "Done."

    def log_verbose(self, msg):
        if self.verbose: print msg

    def log_error(self, msg, row):
        print "ERROR: %s" % msg
        columns = [row[s] for s in self.headers]
        self.write_headers_if_needed()
        self.err_writer.writerow(columns)

    def check_coords(self, row):
        try:
            x = float(row.get('POINT_X', 0))
            y = float(row.get('POINT_Y', 0))
        except:
            self.log_error("  Invalid coords, might not be numbers", row)
            return (False, 0, 0)

        ok = x and y
        if not ok:
            self.log_error("  Invalid coords", row)
        self.log_verbose("  Passed coordinate check")
        return (ok, x, y)

    def check_species(self, row):
        # locate the species and instanciate the tree instance
        if not row.get('SCIENTIFIC') and not row.get('GENUS'):
            self.log_verbose("  No species information")
            return (True, None)

        if row.get('SCIENTIFIC'):
            name = str(row['SCIENTIFIC']).strip()
            species_obj = Species.objects.filter(scientific_name__iexact=name)
            self.log_verbose("  Looking for species: %s" % name)
        else:
            genus = str(row['GENUS']).strip()
            species_field = ''
            cultivar = ''
            gender = ''
            name = genus
            if row.get('SPECIES'):
                species_field = str(row['SPECIES']).strip()
                name = name + " " + species_field
            if row.get('CULTIVAR'):
                cultivar = str(row['CULTIVAR']).strip()
                name = name + " " + cultivar
            if row.get('GENDER'):
                gender = str(row['GENDER']).strip()
                name = name + " " + gender
            species_obj = Species.objects.filter(genus__iexact=genus,species__iexact=species_field,cultivar_name__iexact=cultivar,gender__iexact=gender)
            self.log_verbose("  Looking for species: %s" % name)


        if species_obj: #species match found
            self.log_verbose("  Found species %r" % species_obj[0])
            return (True, species_obj)

        #species data but no match, check it manually
        self.log_error("ERROR:  Unknown species %r" % name, row)
        return (False, None)

    def check_tree_info(self, row):
        tree_info = False
        fields = ['STEWARD', 'SPONSOR', 'DATEPLANTED', 'DIAMETER', 'HEIGHT', 'CANOPYHEIGHT',
                  'CONDITION', 'CANOPYCONDITION', 'PROJECT_1', 'PROJECT_2', 'PROJECT_3', 'OWNER']

        for f in fields:
            # field exists and there's something in it
            if row.get(f) and str(row[f]).strip():
                tree_info = True
                self.log_verbose('  Found tree data in field %s, creating a tree' % f)
                break

        return tree_info

    def check_proximity(self, plot, tree, species, row):
        # check for nearby plots
        collisions = plot.validate_proximity(True, 0)

        # if there are no collisions, then proceed as planned
        if not collisions:
            self.log_verbose("  No collisions found")
            return (True, plot, tree)
        self.log_verbose("  Initial proximity test count: %d" % collisions.count())

        # exclude collisions from the same file we're working in
        collisions = collisions.exclude(import_event=self.import_event)
        if not collisions:
            self.log_verbose("  All collisions are from this import file")
            return (True, plot, tree)
        self.log_verbose("  Secondary proximity test count: %d" % collisions.count())

        # if we have multiple collitions, check for same species or unknown species
        # and try to associate with one of them otherwise abort
        if collisions.count() > 1:
            # get existing trees for the plots that we collided with
            tree_ids = []
            for c in collisions:
                if c.current_tree():
                    tree_ids.append(c.current_tree().id)

            trees = Tree.objects.filter(id__in=tree_ids)

            # Precedence: single same species, single unknown
            # return false for all others and log
            if species:
                same = trees.filter(species=species[0])
                if same.count() == 1 and same[0].species == species[0]:
                    self.log_verbose("  Using single nearby plot with tree of same species")
                    return (True, c, same[0])

            unk = trees.filter(species=None)

            if unk.count() == 1:
                self.log_verbose("  Using single nearby plot with tree of unknown species")
                return (True, c,  unk[0])

            self.log_error("ERROR:  Proximity test failed (near %d plots)" % collisions.count(), row)
            return (False, None, None)

        # one nearby match found, use it as base
        plot = collisions[0]
        plot_tree = plot.current_tree()
        self.log_verbose("  Found one tree nearby")

        # if the nearby plot doesn't have a tree, don't bother doing species matching
        if not plot_tree:
            self.log_verbose("  No tree found for plot, using %d as base plot record" % plot.id)
            return (True, plot, tree)

        # if neither have a species, then we're done and we need to use
        # the tree we collided with.
        if not plot_tree.species and not species:
            self.log_verbose("  No species info for either record, using %d as base tree record" % plot_tree.id)
            return (True, plot, plot_tree)

        # if only the new one has a species, update the tree we collided
        # with and then return it
        if not plot_tree.species:
            # we need to update the collision tree with the new species
            plot_tree.set_species(species[0].id, False) # save later
            self.log_verbose("  Species match, using update file species: %s" % species[0])
            return (True, plot, plot_tree)

        # if only the collision tree has a species, we're done.
        if not species or species.count() == 0:
            self.log_verbose("  No species info for import record, using %d as base record" % plot_tree.id)
            return (True, plot, plot_tree)

        # in this case, both had a species. we should check to see if
        # the species are the same.
        if plot_tree.species != species[0]:
            # now that we have a new species, we want to update the
            # collision tree's species and delete all the old status
            # information.
            self.log_verbose("  Species do not match, using update file species: %s" % species[0])
            plot_tree.set_species(species[0].id, False)
            plot_tree.dbh = None
            plot_tree.height = None
            plot_tree.canopy_height = None
            plot_tree.condition = None
            plot_tree.canopy_condition = None
        return (True, plot, plot_tree)

    def handle_row(self, row):
        self.log_verbose(row)

        # check the physical location
        ok, x, y = self.check_coords(row)
        if not ok: return

        plot = Plot()

        try:
            if self.base_srid != 4326:
                geom = Point(x, y, srid=self.base_srid)
                geom.transform(self.tf)
                self.log_verbose(geom)
                plot.geometry = geom
            else:
                plot.geometry = Point(x, y, srid=4326)
        except:
            self.log_error("ERROR: Geometry failed to transform", row)
            return

        # check the species (if any)
        ok, species = self.check_species(row)
        if not ok: return

        # check for tree info, should we create a tree or just a plot
        if species or self.check_tree_info(row):
            tree = Tree(plot=plot)
        else:
            tree = None

        if tree and species:
            tree.species = species[0]


        # check the proximity (try to match up with existing trees)
        # this may return a different plot/tree than created just above,
        # so don't set anything else on either until after this point
        ok, plot, tree = self.check_proximity(plot, tree, species, row)
        if not ok: return


        if row.get('ADDRESS') and not plot.address_street:
            plot.address_street = str(row['ADDRESS']).title()
            plot.geocoded_address = str(row['ADDRESS']).title()

        if not plot.geocoded_address:
            plot.geocoded_address = ""

        # FIXME: get this from the config?
        plot.address_state = 'CA'
        plot.import_event = self.import_event
        plot.last_updated_by = self.updater
        plot.data_owner = self.data_owner
        plot.readonly = self.readonly

        if row.get('PLOTTYPE'):
            for k, v in choices['plot_types']:
                if v == row['PLOTTYPE']:
                    plot.type = k
                    break;

        if row.get('PLOTLENGTH'):
            plot.length = row['PLOTLENGTH']

        if row.get('PLOTWIDTH'):
            plot.width = row['PLOTWIDTH']

        if row.get('ID'):
            plot.owner_orig_id = row['ID']

        if row.get('ORIGID'):
            plot.owner_additional_properties = "ORIGID=" + str(row['ORIGID'])

        if row.get('OWNER_ADDITIONAL_PROPERTIES'):
            plot.owner_additional_properties = str(plot.owner_additional_properties) + " " + str(row['OWNER_ADDITIONAL_PROPERTIES'])

        if row.get('OWNER_ADDITIONAL_ID'):
            plot.owner_additional_id = str(row['OWNER_ADDITIONAL_ID'])

        if row.get('POWERLINE'):
            for k, v in choices['powerlines']:
                if v == row['POWERLINE']:
                    plot.powerline_conflict_potential = k
                    break;

        sidewalk_damage = row.get('SIDEWALK')
        if sidewalk_damage is None or sidewalk_damage.strip() == "":
            pass
        elif sidewalk_damage is True or sidewalk_damage.lower() == "true" or sidewalk_damage.lower() == 'yes':
            plot.sidewalk_damage = 2
        else:
            plot.sidewalk_damage = 1

        plot.quick_save()

        pnt = plot.geometry
        n = Neighborhood.objects.filter(geometry__contains=pnt)
        z = ZipCode.objects.filter(geometry__contains=pnt)

        plot.neighborhoods = ""
        plot.neighborhood.clear()
        plot.zipcode = None

        if n:
            for nhood in n:
                if nhood:
                    plot.neighborhoods = plot.neighborhoods + " " + nhood.id.__str__()
                    plot.neighborhood.add(nhood)

        if z: plot.zipcode = z[0]

        plot.quick_save()

        if tree:
            tree.plot = plot
            tree.readonly = self.readonly
            tree.import_event = self.import_event
            tree.last_updated_by = self.updater

            if row.get('OWNER'):
                tree.tree_owner = str(row["OWNER"])

            if row.get('STEWARD'):
                tree.steward_name = str(row["STEWARD"])

            if row.get('SPONSOR'):
                tree.sponsor = str(row["SPONSOR"])

            if row.get('DATEPLANTED'):
                date_string = str(row['DATEPLANTED'])
                try:
                    date = datetime.strptime(date_string, "%m/%d/%Y")
                except:
                    pass
                try:
                    date = datetime.strptime(date_string, "%Y/%m/%d")
                except:
                    pass
                if not date:
                    raise ValueError("Date strings must be in mm/dd/yyyy or yyyy/mm/dd format")

                tree.date_planted = date.strftime("%Y-%m-%d")

            if row.get('DIAMETER'):
                tree.dbh = float(row['DIAMETER'])

            if row.get('HEIGHT'):
                tree.height = float(row['HEIGHT'])

            if row.get('CANOPYHEIGHT'):
                tree.canopy_height = float(row['CANOPYHEIGHT'])

            if row.get('CONDITION'):
                for k, v in choices['conditions']:
                    if v == row['CONDITION']:
                        tree.condition = k
                        break;

            if row.get('CANOPYCONDITION'):
                for k, v in choices['canopy_conditions']:
                    if v == row['CANOPYCONDITION']:
                        tree.canopy_condition = k
                        break;

            tree.quick_save()

            if row.get('PROJECT_1'):
                for k, v in Choices().get_field_choices('local'):
                    if v == row['PROJECT_1']:
                        local = TreeFlags(key=k,tree=tree,reported_by=self.updater)
                        local.save()
                        break;
            if row.get('PROJECT_2'):
                for k, v in Choices().get_field_choices('local'):
                    if v == row['PROJECT_2']:
                        local = TreeFlags(key=k,tree=tree,reported_by=self.updater)
                        local.save()
                        break;
            if row.get('PROJECT_3'):
                for k, v in Choices().get_field_choices('local'):
                    if v == row['PROJECT_3']:
                        local = TreeFlags(key=k,tree=tree,reported_by=self.updater)
                        local.save()
                        break;

            # rerun validation tests and store results
            tree.validate_all()

########NEW FILE########
__FILENAME__ = update_aggregates
import datetime
import time
from django.core.management.base import BaseCommand, CommandError
from django.db import connection, transaction
from django.db.models import Count, Sum, Q
from OpenTreeMap.treemap import models 


class Command(BaseCommand):
   
    def handle(self, *args, **options):
        self.update_all_aggregates()


    def update_aggregates(self, base_model, ag_model):
        """
        Updates the aggregate tables.  TODO:  don't just overwrite old summaries
        example: update_aggregates(Neighborhood, AggregateNeighborhood)
        """
        start_time = time.time()
        ns = base_model.objects.all()
        field_names = [x.name for x in models.ResourceSummaryModel._meta.fields 
            if not x.name == 'id']
        for n in ns:
            print n
            agg =  ag_model.objects.filter(location=n)
            if agg:
                agg = agg[0]
            else:
                agg = ag_model(location=n)
            trees = models.Tree.objects.filter(plot__geometry__within=n.geometry)
            plots = models.Plot.objects.filter(geometry__within=n.geometry)
            agg.total_trees = trees.count()
            agg.total_plots = plots.count()
            #agg.distinct_species = len(trees.values("species").annotate(Count("id")).order_by("species"))
            #TODO figure out how to summarize diff stratum stuff
            trees = trees.exclude( Q(dbh=None) | Q(dbh=0.0) ).exclude(species=None)
            for f in field_names:
                if agg.total_trees == 0:
                    s = 0.0
                else:
                    fn = 'treeresource__' + f   
                    s = trees.aggregate(Sum(fn))[fn + '__sum'] or 0.0
                print agg,f,s
                setattr(agg,f,s)
            agg.save()
        end_time = time.time()
        print "done in ", float(end_time) - float(start_time), "seconds"

    def cache_search_aggs(self, query_pairs=({'trees':models.Tree.objects.all(),'query':''},),return_first=False):
        #fields = ['annual_stormwater_management', 'annual_electricity_conserved', 
        #          'annual_natural_gas_conserved', 'annual_air_quality_improvement', 
        #          'annual_co2_sequestered', 'total_co2_stored', 
        #          'annual_co2_avoided'
        #          ]
                  #'total_trees', 'distinct_species'
        for q in query_pairs:
            agg = models.AggregateSearchResult.objects.filter(key=q['query'])
            if agg:
                agg = agg[0]
            else:
                agg = models.AggregateSearchResult(key=q['query'])
            #if not new:
            #    agg.key = 
            trees = q['trees']
            # call len seems to cause deep crashing in python threads...
            #agg.total_trees = len(trees)
            #agg.distinct_species = len(trees.values("species").annotate(Count("id")).order_by("species"))
            agg.total_trees = trees.count()
            #agg.distinct_species = trees.values("species").annotate(Count("id")).order_by("species").count()

            #TODO figure out how to summarize diff stratum stuff
            fields = [x.name for x in models.ResourceSummaryModel._meta.fields 
                if not x.name in ['id','aggregatesummarymodel_ptr','key','resourcesummarymodel_ptr','last_updated']]
            for f in fields:
                    fn = 'treeresource__' + f
                    s = trees.aggregate(Sum(fn))[fn + '__sum'] or 0.0
                    print agg,f,s
                    setattr(agg,f,s)
            agg.save()
            print 'saving', agg
            if return_first:
                return agg


    def update_all_aggregates(self, verbose=False):
        #if not tree_geom: return
        self.update_aggregates(models.Neighborhood, models.AggregateNeighborhood)
        self.update_aggregates(models.ZipCode, models.AggregateZipCode)
        #cache_search_aggs()

########NEW FILE########
__FILENAME__ = meta_badges
import badges
from django.contrib.auth.models import User
from profiles.models import UserProfile

class TrustedUser(badges.MetaBadge):
    id = 'trusteduser'
    model = User
    one_time_only = True
    
    title = "Trusted User"
    description = "Contibuted significantly to the site"
    level = "2"
    
    progress_start = 0
    progress_finish = 1000
    
    def get_user(self, instance):
        return instance

    def get_progress(self, user):
        return user.reputation.reputation
        
    def check_reputation(self, instance):
        if hasattr(instance, 'reputation'):
            if instance.reputation.reputation > 999:
                return True
        return False

class ProfileComplete(badges.MetaBadge):
    id = 'profilecomplete'
    model = UserProfile
    one_time_only = True
    
    title = "Profile Complete"
    description = "Profile is completed"
    level = "1"

    progress_start = 0
    progress_finish = 5
    
    def get_user(self, instance):
        return instance.user

    def get_progress(self, user):
        photo = 1 if user.get_profile().photo else 0
        f_name = 1 if user.first_name else 0
        l_name = 1 if user.last_name else 0
        zip = 1 if user.get_profile().zip_code else 0
        email = 1 if user.email else 0
        
        return photo + f_name + l_name + zip + email
    
    def check_photo(self, instance):
        return instance.photo
    
    def check_name(self, instance):
        return instance.first_name and instance.last_name
    
    def check_zip(self, instance):
        return instance.zip_code
    
    def check_email(self, instance):
        return instance.email
########NEW FILE########
__FILENAME__ = 0001_initial
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'BenefitValues'
        db.create_table('treemap_benefitvalues', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('area', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('stormwater', self.gf('django.db.models.fields.FloatField')()),
            ('electricity', self.gf('django.db.models.fields.FloatField')()),
            ('natural_gas', self.gf('django.db.models.fields.FloatField')()),
            ('co2', self.gf('django.db.models.fields.FloatField')()),
            ('ozone', self.gf('django.db.models.fields.FloatField')()),
            ('nox', self.gf('django.db.models.fields.FloatField')()),
            ('pm10', self.gf('django.db.models.fields.FloatField')()),
            ('sox', self.gf('django.db.models.fields.FloatField')()),
            ('voc', self.gf('django.db.models.fields.FloatField')()),
            ('bvoc', self.gf('django.db.models.fields.FloatField')()),
        ))
        db.send_create_signal('treemap', ['BenefitValues'])

        # Adding model 'CommentFlag'
        db.create_table('treemap_commentflag', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('flagged', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('flagged_date', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('comment', self.gf('django.db.models.fields.related.ForeignKey')(related_name='comment_flags', to=orm['threadedcomments.ThreadedComment'])),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'])),
        ))
        db.send_create_signal('treemap', ['CommentFlag'])

        # Adding model 'Neighborhood'
        db.create_table('treemap_neighborhood', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('region_id', self.gf('django.db.models.fields.IntegerField')()),
            ('city', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('county', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('state', self.gf('django.db.models.fields.CharField')(max_length=2)),
            ('geometry', self.gf('django.contrib.gis.db.models.fields.MultiPolygonField')()),
        ))
        db.send_create_signal('treemap', ['Neighborhood'])

        # Adding model 'SupervisorDistrict'
        db.create_table('treemap_supervisordistrict', (
            ('id', self.gf('django.db.models.fields.IntegerField')(primary_key=True)),
            ('supervisor', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('geometry', self.gf('django.contrib.gis.db.models.fields.MultiPolygonField')()),
        ))
        db.send_create_signal('treemap', ['SupervisorDistrict'])

        # Adding model 'ZipCode'
        db.create_table('treemap_zipcode', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('zip', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('geometry', self.gf('django.contrib.gis.db.models.fields.MultiPolygonField')()),
        ))
        db.send_create_signal('treemap', ['ZipCode'])

        # Adding model 'ExclusionMask'
        db.create_table('treemap_exclusionmask', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('geometry', self.gf('django.contrib.gis.db.models.fields.MultiPolygonField')()),
            ('type', self.gf('django.db.models.fields.CharField')(max_length=50, null=True, blank=True)),
        ))
        db.send_create_signal('treemap', ['ExclusionMask'])

        # Adding model 'Factoid'
        db.create_table('treemap_factoid', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('category', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('header', self.gf('django.db.models.fields.CharField')(max_length=100)),
            ('fact', self.gf('django.db.models.fields.TextField')(max_length=500)),
        ))
        db.send_create_signal('treemap', ['Factoid'])

        # Adding model 'Resource'
        db.create_table('treemap_resource', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('meta_species', self.gf('django.db.models.fields.CharField')(max_length=150, null=True, blank=True)),
            ('region', self.gf('django.db.models.fields.CharField')(max_length=150, null=True, blank=True)),
            ('hydro_interception_dbh', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
            ('aq_ozone_dep_dbh', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
            ('aq_nox_dep_dbh', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
            ('aq_pm10_dep_dbh', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
            ('aq_sox_dep_dbh', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
            ('aq_nox_avoided_dbh', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
            ('aq_pm10_avoided_dbh', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
            ('aq_sox_avoided_dbh', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
            ('aq_voc_avoided_dbh', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
            ('bvoc_dbh', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
            ('co2_sequestered_dbh', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
            ('co2_avoided_dbh', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
            ('natural_gas_dbh', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
            ('electricity_dbh', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
            ('co2_storage_dbh', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
        ))
        db.send_create_signal('treemap', ['Resource'])

        # Adding model 'Species'
        db.create_table('treemap_species', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('symbol', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('alternate_symbol', self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True)),
            ('itree_code', self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True)),
            ('scientific_name', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('genus', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('species', self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True)),
            ('cultivar_name', self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True)),
            ('gender', self.gf('django.db.models.fields.CharField')(max_length=50, null=True, blank=True)),
            ('common_name', self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True)),
            ('native_status', self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True)),
            ('bloom_period', self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True)),
            ('fruit_period', self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True)),
            ('fall_conspicuous', self.gf('django.db.models.fields.NullBooleanField')(null=True, blank=True)),
            ('flower_conspicuous', self.gf('django.db.models.fields.NullBooleanField')(null=True, blank=True)),
            ('palatable_human', self.gf('django.db.models.fields.NullBooleanField')(null=True, blank=True)),
            ('wildlife_value', self.gf('django.db.models.fields.NullBooleanField')(null=True, blank=True)),
            ('fact_sheet', self.gf('django.db.models.fields.URLField')(max_length=255, null=True, blank=True)),
            ('plant_guide', self.gf('django.db.models.fields.URLField')(max_length=255, null=True, blank=True)),
            ('tree_count', self.gf('django.db.models.fields.IntegerField')(default=0, db_index=True)),
            ('v_max_dbh', self.gf('django.db.models.fields.IntegerField')(null=True, blank=True)),
            ('v_max_height', self.gf('django.db.models.fields.IntegerField')(null=True, blank=True)),
            ('v_multiple_trunks', self.gf('django.db.models.fields.NullBooleanField')(null=True, blank=True)),
        ))
        db.send_create_signal('treemap', ['Species'])

        # Adding M2M table for field resource on 'Species'
        db.create_table('treemap_species_resource', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('species', models.ForeignKey(orm['treemap.species'], null=False)),
            ('resource', models.ForeignKey(orm['treemap.resource'], null=False))
        ))
        db.create_unique('treemap_species_resource', ['species_id', 'resource_id'])

        # Adding model 'GeocodeCache'
        db.create_table('treemap_geocodecache', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('address_street', self.gf('django.db.models.fields.CharField')(max_length=256)),
            ('geocoded_address', self.gf('django.db.models.fields.CharField')(max_length=256)),
            ('geocoded_lat', self.gf('django.db.models.fields.FloatField')(null=True)),
            ('geocoded_lon', self.gf('django.db.models.fields.FloatField')(null=True)),
            ('geocoded_accuracy', self.gf('django.db.models.fields.IntegerField')(null=True)),
            ('geocoded_geometry', self.gf('django.contrib.gis.db.models.fields.PointField')(null=True)),
            ('geometry', self.gf('django.contrib.gis.db.models.fields.PointField')(null=True)),
        ))
        db.send_create_signal('treemap', ['GeocodeCache'])

        # Adding model 'ImportEvent'
        db.create_table('treemap_importevent', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('file_name', self.gf('django.db.models.fields.CharField')(max_length=256)),
            ('import_date', self.gf('django.db.models.fields.DateField')(auto_now=True, blank=True)),
        ))
        db.send_create_signal('treemap', ['ImportEvent'])

        # Adding model 'PlotAudit'
        db.create_table('treemap_plot_audit', (
            ('_audit_user_rep', self.gf('django.db.models.fields.IntegerField')()),
            ('_audit_diff', self.gf('django.db.models.fields.TextField')()),
            ('_audit_verified', self.gf('django.db.models.fields.IntegerField')()),
            ('present', self.gf('django.db.models.fields.BooleanField')(default=True)),
            ('width', self.gf('django.db.models.fields.FloatField')(null=True, blank=True)),
            ('length', self.gf('django.db.models.fields.FloatField')(null=True, blank=True)),
            ('type', self.gf('django.db.models.fields.CharField')(max_length=256, null=True, blank=True)),
            ('powerline_conflict_potential', self.gf('django.db.models.fields.CharField')(default='3', max_length=256, null=True, blank=True)),
            ('sidewalk_damage', self.gf('django.db.models.fields.CharField')(max_length=256, null=True, blank=True)),
            ('address_street', self.gf('django.db.models.fields.CharField')(max_length=256, null=True, blank=True)),
            ('address_city', self.gf('django.db.models.fields.CharField')(max_length=256, null=True, blank=True)),
            ('address_zip', self.gf('django.db.models.fields.CharField')(max_length=30, null=True, blank=True)),
            ('neighborhoods', self.gf('django.db.models.fields.CharField')(max_length=150, null=True, blank=True)),
            ('zipcode', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='_audit_plot', null=True, to=orm['treemap.ZipCode'])),
            ('geocoded_accuracy', self.gf('django.db.models.fields.IntegerField')(null=True, blank=True)),
            ('geocoded_address', self.gf('django.db.models.fields.CharField')(max_length=256, null=True, blank=True)),
            ('geocoded_lat', self.gf('django.db.models.fields.FloatField')(null=True, blank=True)),
            ('geocoded_lon', self.gf('django.db.models.fields.FloatField')(null=True, blank=True)),
            ('geometry', self.gf('django.contrib.gis.db.models.fields.PointField')()),
            ('last_updated', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('last_updated_by', self.gf('django.db.models.fields.related.ForeignKey')(related_name='_audit_plot_updated_by', to=orm['auth.User'])),
            ('import_event', self.gf('django.db.models.fields.related.ForeignKey')(related_name='_audit_plot', to=orm['treemap.ImportEvent'])),
            ('data_owner', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='_audit_owner', null=True, to=orm['auth.User'])),
            ('owner_orig_id', self.gf('django.db.models.fields.CharField')(max_length=256, null=True, blank=True)),
            ('owner_additional_id', self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True)),
            ('owner_additional_properties', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
            ('readonly', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('_audit_id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('_audit_timestamp', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, db_index=True, blank=True)),
            ('_audit_change_type', self.gf('django.db.models.fields.CharField')(max_length=1)),
            ('id', self.gf('django.db.models.fields.IntegerField')(db_index=True)),
        ))
        db.send_create_signal('treemap', ['PlotAudit'])

        # Adding model 'Plot'
        db.create_table('treemap_plot', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('present', self.gf('django.db.models.fields.BooleanField')(default=True)),
            ('width', self.gf('django.db.models.fields.FloatField')(null=True, blank=True)),
            ('length', self.gf('django.db.models.fields.FloatField')(null=True, blank=True)),
            ('type', self.gf('django.db.models.fields.CharField')(max_length=256, null=True, blank=True)),
            ('powerline_conflict_potential', self.gf('django.db.models.fields.CharField')(default='3', max_length=256, null=True, blank=True)),
            ('sidewalk_damage', self.gf('django.db.models.fields.CharField')(max_length=256, null=True, blank=True)),
            ('address_street', self.gf('django.db.models.fields.CharField')(max_length=256, null=True, blank=True)),
            ('address_city', self.gf('django.db.models.fields.CharField')(max_length=256, null=True, blank=True)),
            ('address_zip', self.gf('django.db.models.fields.CharField')(max_length=30, null=True, blank=True)),
            ('neighborhoods', self.gf('django.db.models.fields.CharField')(max_length=150, null=True, blank=True)),
            ('zipcode', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['treemap.ZipCode'], null=True, blank=True)),
            ('geocoded_accuracy', self.gf('django.db.models.fields.IntegerField')(null=True, blank=True)),
            ('geocoded_address', self.gf('django.db.models.fields.CharField')(max_length=256, null=True, blank=True)),
            ('geocoded_lat', self.gf('django.db.models.fields.FloatField')(null=True, blank=True)),
            ('geocoded_lon', self.gf('django.db.models.fields.FloatField')(null=True, blank=True)),
            ('geometry', self.gf('django.contrib.gis.db.models.fields.PointField')()),
            ('last_updated', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('last_updated_by', self.gf('django.db.models.fields.related.ForeignKey')(related_name='plot_updated_by', to=orm['auth.User'])),
            ('import_event', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['treemap.ImportEvent'])),
            ('data_owner', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='owner', null=True, to=orm['auth.User'])),
            ('owner_orig_id', self.gf('django.db.models.fields.CharField')(max_length=256, null=True, blank=True)),
            ('owner_additional_id', self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True)),
            ('owner_additional_properties', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
            ('readonly', self.gf('django.db.models.fields.BooleanField')(default=False)),
        ))
        db.send_create_signal('treemap', ['Plot'])

        # Adding M2M table for field neighborhood on 'Plot'
        db.create_table('treemap_plot_neighborhood', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('plot', models.ForeignKey(orm['treemap.plot'], null=False)),
            ('neighborhood', models.ForeignKey(orm['treemap.neighborhood'], null=False))
        ))
        db.create_unique('treemap_plot_neighborhood', ['plot_id', 'neighborhood_id'])

        # Adding model 'TreeAudit'
        db.create_table('treemap_tree_audit', (
            ('_audit_user_rep', self.gf('django.db.models.fields.IntegerField')()),
            ('_audit_diff', self.gf('django.db.models.fields.TextField')()),
            ('_audit_verified', self.gf('django.db.models.fields.IntegerField')()),
            ('plot', self.gf('django.db.models.fields.related.ForeignKey')(related_name='_audit_tree', to=orm['treemap.Plot'])),
            ('tree_owner', self.gf('django.db.models.fields.CharField')(max_length=256, null=True, blank=True)),
            ('steward_name', self.gf('django.db.models.fields.CharField')(max_length=256, null=True, blank=True)),
            ('steward_user', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='_audit_steward', null=True, to=orm['auth.User'])),
            ('sponsor', self.gf('django.db.models.fields.CharField')(max_length=256, null=True, blank=True)),
            ('species', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='_audit_tree', null=True, to=orm['treemap.Species'])),
            ('species_other1', self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True)),
            ('species_other2', self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True)),
            ('orig_species', self.gf('django.db.models.fields.CharField')(max_length=256, null=True, blank=True)),
            ('dbh', self.gf('django.db.models.fields.FloatField')(null=True, blank=True)),
            ('height', self.gf('django.db.models.fields.FloatField')(null=True, blank=True)),
            ('canopy_height', self.gf('django.db.models.fields.FloatField')(null=True, blank=True)),
            ('date_planted', self.gf('django.db.models.fields.DateField')(null=True, blank=True)),
            ('date_removed', self.gf('django.db.models.fields.DateField')(null=True, blank=True)),
            ('present', self.gf('django.db.models.fields.BooleanField')(default=True)),
            ('last_updated', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('last_updated_by', self.gf('django.db.models.fields.related.ForeignKey')(related_name='_audit_updated_by', to=orm['auth.User'])),
            ('s_order', self.gf('django.db.models.fields.IntegerField')(null=True, blank=True)),
            ('photo_count', self.gf('django.db.models.fields.IntegerField')(null=True, blank=True)),
            ('projects', self.gf('django.db.models.fields.CharField')(max_length=20, null=True, blank=True)),
            ('import_event', self.gf('django.db.models.fields.related.ForeignKey')(related_name='_audit_tree', to=orm['treemap.ImportEvent'])),
            ('condition', self.gf('django.db.models.fields.CharField')(max_length=256, null=True, blank=True)),
            ('canopy_condition', self.gf('django.db.models.fields.CharField')(max_length=256, null=True, blank=True)),
            ('readonly', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('_audit_id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('_audit_timestamp', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, db_index=True, blank=True)),
            ('_audit_change_type', self.gf('django.db.models.fields.CharField')(max_length=1)),
            ('id', self.gf('django.db.models.fields.IntegerField')(db_index=True)),
        ))
        db.send_create_signal('treemap', ['TreeAudit'])

        # Adding model 'Tree'
        db.create_table('treemap_tree', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('plot', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['treemap.Plot'])),
            ('tree_owner', self.gf('django.db.models.fields.CharField')(max_length=256, null=True, blank=True)),
            ('steward_name', self.gf('django.db.models.fields.CharField')(max_length=256, null=True, blank=True)),
            ('steward_user', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='steward', null=True, to=orm['auth.User'])),
            ('sponsor', self.gf('django.db.models.fields.CharField')(max_length=256, null=True, blank=True)),
            ('species', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['treemap.Species'], null=True, blank=True)),
            ('species_other1', self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True)),
            ('species_other2', self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True)),
            ('orig_species', self.gf('django.db.models.fields.CharField')(max_length=256, null=True, blank=True)),
            ('dbh', self.gf('django.db.models.fields.FloatField')(null=True, blank=True)),
            ('height', self.gf('django.db.models.fields.FloatField')(null=True, blank=True)),
            ('canopy_height', self.gf('django.db.models.fields.FloatField')(null=True, blank=True)),
            ('date_planted', self.gf('django.db.models.fields.DateField')(null=True, blank=True)),
            ('date_removed', self.gf('django.db.models.fields.DateField')(null=True, blank=True)),
            ('present', self.gf('django.db.models.fields.BooleanField')(default=True)),
            ('last_updated', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('last_updated_by', self.gf('django.db.models.fields.related.ForeignKey')(related_name='updated_by', to=orm['auth.User'])),
            ('s_order', self.gf('django.db.models.fields.IntegerField')(null=True, blank=True)),
            ('photo_count', self.gf('django.db.models.fields.IntegerField')(null=True, blank=True)),
            ('projects', self.gf('django.db.models.fields.CharField')(max_length=20, null=True, blank=True)),
            ('import_event', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['treemap.ImportEvent'])),
            ('condition', self.gf('django.db.models.fields.CharField')(max_length=256, null=True, blank=True)),
            ('canopy_condition', self.gf('django.db.models.fields.CharField')(max_length=256, null=True, blank=True)),
            ('readonly', self.gf('django.db.models.fields.BooleanField')(default=False)),
        ))
        db.send_create_signal('treemap', ['Tree'])

        # Adding model 'Pending'
        db.create_table('treemap_pending', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('field', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('value', self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True)),
            ('text_value', self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True)),
            ('submitted', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('submitted_by', self.gf('django.db.models.fields.related.ForeignKey')(related_name='pend_submitted_by', to=orm['auth.User'])),
            ('status', self.gf('django.db.models.fields.CharField')(max_length=10)),
            ('updated', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('updated_by', self.gf('django.db.models.fields.related.ForeignKey')(related_name='pend_updated_by', to=orm['auth.User'])),
        ))
        db.send_create_signal('treemap', ['Pending'])

        # Adding model 'TreePending'
        db.create_table('treemap_treepending', (
            ('pending_ptr', self.gf('django.db.models.fields.related.OneToOneField')(to=orm['treemap.Pending'], unique=True, primary_key=True)),
            ('tree', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['treemap.Tree'])),
        ))
        db.send_create_signal('treemap', ['TreePending'])

        # Adding model 'PlotPending'
        db.create_table('treemap_plotpending', (
            ('pending_ptr', self.gf('django.db.models.fields.related.OneToOneField')(to=orm['treemap.Pending'], unique=True, primary_key=True)),
            ('plot', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['treemap.Plot'])),
            ('geometry', self.gf('django.contrib.gis.db.models.fields.PointField')(null=True, blank=True)),
        ))
        db.send_create_signal('treemap', ['PlotPending'])

        # Adding model 'TreeWatch'
        db.create_table('treemap_treewatch', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('key', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('value', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('tree', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['treemap.Tree'])),
            ('severity', self.gf('django.db.models.fields.IntegerField')(default=0)),
            ('valid', self.gf('django.db.models.fields.BooleanField')(default=False)),
        ))
        db.send_create_signal('treemap', ['TreeWatch'])

        # Adding model 'TreeFavorite'
        db.create_table('treemap_treefavorite', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'])),
            ('date_created', self.gf('django.db.models.fields.DateTimeField')(default=datetime.datetime.now)),
            ('tree', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['treemap.Tree'])),
        ))
        db.send_create_signal('treemap', ['TreeFavorite'])

        # Adding model 'Stewardship'
        db.create_table('treemap_stewardship', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('performed_by', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'])),
            ('performed_date', self.gf('django.db.models.fields.DateTimeField')()),
        ))
        db.send_create_signal('treemap', ['Stewardship'])

        # Adding model 'TreeStewardship'
        db.create_table('treemap_treestewardship', (
            ('stewardship_ptr', self.gf('django.db.models.fields.related.OneToOneField')(to=orm['treemap.Stewardship'], unique=True, primary_key=True)),
            ('activity', self.gf('django.db.models.fields.CharField')(max_length=256, null=True, blank=True)),
            ('tree', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['treemap.Tree'])),
        ))
        db.send_create_signal('treemap', ['TreeStewardship'])

        # Adding model 'PlotStewardship'
        db.create_table('treemap_plotstewardship', (
            ('stewardship_ptr', self.gf('django.db.models.fields.related.OneToOneField')(to=orm['treemap.Stewardship'], unique=True, primary_key=True)),
            ('activity', self.gf('django.db.models.fields.CharField')(max_length=256, null=True, blank=True)),
            ('plot', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['treemap.Plot'])),
        ))
        db.send_create_signal('treemap', ['PlotStewardship'])

        # Adding model 'TreeFlags'
        db.create_table('treemap_treeflags', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('reported', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('reported_by', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'])),
            ('tree', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['treemap.Tree'])),
            ('comment', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('key', self.gf('django.db.models.fields.CharField')(max_length=256)),
            ('value', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
        ))
        db.send_create_signal('treemap', ['TreeFlags'])

        # Adding model 'TreePhoto'
        db.create_table('treemap_treephoto', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('reported', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('reported_by', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'])),
            ('tree', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['treemap.Tree'])),
            ('comment', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('title', self.gf('django.db.models.fields.CharField')(max_length=256, null=True, blank=True)),
            ('photo', self.gf('sorl.thumbnail.fields.ImageField')(max_length=100)),
        ))
        db.send_create_signal('treemap', ['TreePhoto'])

        # Adding model 'TreeAlert'
        db.create_table('treemap_treealert', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('reported', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('reported_by', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'])),
            ('tree', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['treemap.Tree'])),
            ('comment', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('key', self.gf('django.db.models.fields.CharField')(max_length=256)),
            ('value', self.gf('django.db.models.fields.DateTimeField')()),
            ('solved', self.gf('django.db.models.fields.BooleanField')(default=False)),
        ))
        db.send_create_signal('treemap', ['TreeAlert'])

        # Adding model 'TreeAction'
        db.create_table('treemap_treeaction', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('reported', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('reported_by', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'])),
            ('tree', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['treemap.Tree'])),
            ('comment', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('key', self.gf('django.db.models.fields.CharField')(max_length=256)),
            ('value', self.gf('django.db.models.fields.DateTimeField')()),
        ))
        db.send_create_signal('treemap', ['TreeAction'])

        # Adding model 'ResourceSummaryModel'
        db.create_table('treemap_resourcesummarymodel', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('annual_stormwater_management', self.gf('django.db.models.fields.FloatField')()),
            ('annual_electricity_conserved', self.gf('django.db.models.fields.FloatField')()),
            ('annual_energy_conserved', self.gf('django.db.models.fields.FloatField')()),
            ('annual_natural_gas_conserved', self.gf('django.db.models.fields.FloatField')()),
            ('annual_air_quality_improvement', self.gf('django.db.models.fields.FloatField')()),
            ('annual_co2_sequestered', self.gf('django.db.models.fields.FloatField')()),
            ('annual_co2_avoided', self.gf('django.db.models.fields.FloatField')()),
            ('annual_co2_reduced', self.gf('django.db.models.fields.FloatField')()),
            ('total_co2_stored', self.gf('django.db.models.fields.FloatField')()),
            ('annual_ozone', self.gf('django.db.models.fields.FloatField')()),
            ('annual_nox', self.gf('django.db.models.fields.FloatField')()),
            ('annual_pm10', self.gf('django.db.models.fields.FloatField')()),
            ('annual_sox', self.gf('django.db.models.fields.FloatField')()),
            ('annual_voc', self.gf('django.db.models.fields.FloatField')()),
            ('annual_bvoc', self.gf('django.db.models.fields.FloatField')()),
        ))
        db.send_create_signal('treemap', ['ResourceSummaryModel'])

        # Adding model 'TreeResource'
        db.create_table('treemap_treeresource', (
            ('resourcesummarymodel_ptr', self.gf('django.db.models.fields.related.OneToOneField')(to=orm['treemap.ResourceSummaryModel'], unique=True)),
            ('tree', self.gf('django.db.models.fields.related.OneToOneField')(to=orm['treemap.Tree'], unique=True, primary_key=True)),
        ))
        db.send_create_signal('treemap', ['TreeResource'])

        # Adding model 'AggregateSummaryModel'
        db.create_table('treemap_aggregatesummarymodel', (
            ('resourcesummarymodel_ptr', self.gf('django.db.models.fields.related.OneToOneField')(to=orm['treemap.ResourceSummaryModel'], unique=True, primary_key=True)),
            ('last_updated', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('total_trees', self.gf('django.db.models.fields.IntegerField')()),
            ('total_plots', self.gf('django.db.models.fields.IntegerField')()),
        ))
        db.send_create_signal('treemap', ['AggregateSummaryModel'])

        # Adding model 'AggregateSearchResult'
        db.create_table('treemap_aggregatesearchresult', (
            ('aggregatesummarymodel_ptr', self.gf('django.db.models.fields.related.OneToOneField')(to=orm['treemap.AggregateSummaryModel'], unique=True, primary_key=True)),
            ('key', self.gf('django.db.models.fields.CharField')(unique=True, max_length=256)),
        ))
        db.send_create_signal('treemap', ['AggregateSearchResult'])

        # Adding model 'AggregateNeighborhood'
        db.create_table('treemap_aggregateneighborhood', (
            ('aggregatesummarymodel_ptr', self.gf('django.db.models.fields.related.OneToOneField')(to=orm['treemap.AggregateSummaryModel'], unique=True, primary_key=True)),
            ('location', self.gf('django.db.models.fields.related.OneToOneField')(related_name='aggregates', unique=True, to=orm['treemap.Neighborhood'])),
        ))
        db.send_create_signal('treemap', ['AggregateNeighborhood'])

        # Adding model 'AggregateSupervisorDistrict'
        db.create_table('treemap_aggregatesupervisordistrict', (
            ('aggregatesummarymodel_ptr', self.gf('django.db.models.fields.related.OneToOneField')(to=orm['treemap.AggregateSummaryModel'], unique=True, primary_key=True)),
            ('location', self.gf('django.db.models.fields.related.OneToOneField')(related_name='aggregates', unique=True, to=orm['treemap.SupervisorDistrict'])),
        ))
        db.send_create_signal('treemap', ['AggregateSupervisorDistrict'])

        # Adding model 'AggregateZipCode'
        db.create_table('treemap_aggregatezipcode', (
            ('aggregatesummarymodel_ptr', self.gf('django.db.models.fields.related.OneToOneField')(to=orm['treemap.AggregateSummaryModel'], unique=True, primary_key=True)),
            ('location', self.gf('django.db.models.fields.related.OneToOneField')(related_name='aggregates', unique=True, to=orm['treemap.ZipCode'])),
        ))
        db.send_create_signal('treemap', ['AggregateZipCode'])


    def backwards(self, orm):
        # Deleting model 'BenefitValues'
        db.delete_table('treemap_benefitvalues')

        # Deleting model 'CommentFlag'
        db.delete_table('treemap_commentflag')

        # Deleting model 'Neighborhood'
        db.delete_table('treemap_neighborhood')

        # Deleting model 'SupervisorDistrict'
        db.delete_table('treemap_supervisordistrict')

        # Deleting model 'ZipCode'
        db.delete_table('treemap_zipcode')

        # Deleting model 'ExclusionMask'
        db.delete_table('treemap_exclusionmask')

        # Deleting model 'Factoid'
        db.delete_table('treemap_factoid')

        # Deleting model 'Resource'
        db.delete_table('treemap_resource')

        # Deleting model 'Species'
        db.delete_table('treemap_species')

        # Removing M2M table for field resource on 'Species'
        db.delete_table('treemap_species_resource')

        # Deleting model 'GeocodeCache'
        db.delete_table('treemap_geocodecache')

        # Deleting model 'ImportEvent'
        db.delete_table('treemap_importevent')

        # Deleting model 'PlotAudit'
        db.delete_table('treemap_plot_audit')

        # Deleting model 'Plot'
        db.delete_table('treemap_plot')

        # Removing M2M table for field neighborhood on 'Plot'
        db.delete_table('treemap_plot_neighborhood')

        # Deleting model 'TreeAudit'
        db.delete_table('treemap_tree_audit')

        # Deleting model 'Tree'
        db.delete_table('treemap_tree')

        # Deleting model 'Pending'
        db.delete_table('treemap_pending')

        # Deleting model 'TreePending'
        db.delete_table('treemap_treepending')

        # Deleting model 'PlotPending'
        db.delete_table('treemap_plotpending')

        # Deleting model 'TreeWatch'
        db.delete_table('treemap_treewatch')

        # Deleting model 'TreeFavorite'
        db.delete_table('treemap_treefavorite')

        # Deleting model 'Stewardship'
        db.delete_table('treemap_stewardship')

        # Deleting model 'TreeStewardship'
        db.delete_table('treemap_treestewardship')

        # Deleting model 'PlotStewardship'
        db.delete_table('treemap_plotstewardship')

        # Deleting model 'TreeFlags'
        db.delete_table('treemap_treeflags')

        # Deleting model 'TreePhoto'
        db.delete_table('treemap_treephoto')

        # Deleting model 'TreeAlert'
        db.delete_table('treemap_treealert')

        # Deleting model 'TreeAction'
        db.delete_table('treemap_treeaction')

        # Deleting model 'ResourceSummaryModel'
        db.delete_table('treemap_resourcesummarymodel')

        # Deleting model 'TreeResource'
        db.delete_table('treemap_treeresource')

        # Deleting model 'AggregateSummaryModel'
        db.delete_table('treemap_aggregatesummarymodel')

        # Deleting model 'AggregateSearchResult'
        db.delete_table('treemap_aggregatesearchresult')

        # Deleting model 'AggregateNeighborhood'
        db.delete_table('treemap_aggregateneighborhood')

        # Deleting model 'AggregateSupervisorDistrict'
        db.delete_table('treemap_aggregatesupervisordistrict')

        # Deleting model 'AggregateZipCode'
        db.delete_table('treemap_aggregatezipcode')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'threadedcomments.threadedcomment': {
            'Meta': {'ordering': "('-date_submitted',)", 'object_name': 'ThreadedComment'},
            'comment': ('django.db.models.fields.TextField', [], {}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'date_approved': ('django.db.models.fields.DateTimeField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'date_modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'date_submitted': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'ip_address': ('django.db.models.fields.IPAddressField', [], {'max_length': '15', 'null': 'True', 'blank': 'True'}),
            'is_approved': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'markup': ('django.db.models.fields.IntegerField', [], {'default': '5', 'null': 'True', 'blank': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'related_name': "'children'", 'null': 'True', 'blank': 'True', 'to': "orm['threadedcomments.ThreadedComment']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'treemap.aggregateneighborhood': {
            'Meta': {'object_name': 'AggregateNeighborhood', '_ormbases': ['treemap.AggregateSummaryModel']},
            'aggregatesummarymodel_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.AggregateSummaryModel']", 'unique': 'True', 'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'aggregates'", 'unique': 'True', 'to': "orm['treemap.Neighborhood']"})
        },
        'treemap.aggregatesearchresult': {
            'Meta': {'object_name': 'AggregateSearchResult', '_ormbases': ['treemap.AggregateSummaryModel']},
            'aggregatesummarymodel_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.AggregateSummaryModel']", 'unique': 'True', 'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '256'})
        },
        'treemap.aggregatesummarymodel': {
            'Meta': {'object_name': 'AggregateSummaryModel', '_ormbases': ['treemap.ResourceSummaryModel']},
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'resourcesummarymodel_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.ResourceSummaryModel']", 'unique': 'True', 'primary_key': 'True'}),
            'total_plots': ('django.db.models.fields.IntegerField', [], {}),
            'total_trees': ('django.db.models.fields.IntegerField', [], {})
        },
        'treemap.aggregatesupervisordistrict': {
            'Meta': {'object_name': 'AggregateSupervisorDistrict', '_ormbases': ['treemap.AggregateSummaryModel']},
            'aggregatesummarymodel_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.AggregateSummaryModel']", 'unique': 'True', 'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'aggregates'", 'unique': 'True', 'to': "orm['treemap.SupervisorDistrict']"})
        },
        'treemap.aggregatezipcode': {
            'Meta': {'object_name': 'AggregateZipCode', '_ormbases': ['treemap.AggregateSummaryModel']},
            'aggregatesummarymodel_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.AggregateSummaryModel']", 'unique': 'True', 'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'aggregates'", 'unique': 'True', 'to': "orm['treemap.ZipCode']"})
        },
        'treemap.benefitvalues': {
            'Meta': {'object_name': 'BenefitValues'},
            'area': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'bvoc': ('django.db.models.fields.FloatField', [], {}),
            'co2': ('django.db.models.fields.FloatField', [], {}),
            'electricity': ('django.db.models.fields.FloatField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'natural_gas': ('django.db.models.fields.FloatField', [], {}),
            'nox': ('django.db.models.fields.FloatField', [], {}),
            'ozone': ('django.db.models.fields.FloatField', [], {}),
            'pm10': ('django.db.models.fields.FloatField', [], {}),
            'sox': ('django.db.models.fields.FloatField', [], {}),
            'stormwater': ('django.db.models.fields.FloatField', [], {}),
            'voc': ('django.db.models.fields.FloatField', [], {})
        },
        'treemap.commentflag': {
            'Meta': {'object_name': 'CommentFlag'},
            'comment': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'comment_flags'", 'to': "orm['threadedcomments.ThreadedComment']"}),
            'flagged': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'flagged_date': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'treemap.exclusionmask': {
            'Meta': {'object_name': 'ExclusionMask'},
            'geometry': ('django.contrib.gis.db.models.fields.MultiPolygonField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'type': ('django.db.models.fields.CharField', [], {'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        'treemap.factoid': {
            'Meta': {'object_name': 'Factoid'},
            'category': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'fact': ('django.db.models.fields.TextField', [], {'max_length': '500'}),
            'header': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'treemap.geocodecache': {
            'Meta': {'object_name': 'GeocodeCache'},
            'address_street': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'geocoded_accuracy': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'geocoded_address': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'geocoded_geometry': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'geocoded_lat': ('django.db.models.fields.FloatField', [], {'null': 'True'}),
            'geocoded_lon': ('django.db.models.fields.FloatField', [], {'null': 'True'}),
            'geometry': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'treemap.importevent': {
            'Meta': {'object_name': 'ImportEvent'},
            'file_name': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'import_date': ('django.db.models.fields.DateField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        'treemap.neighborhood': {
            'Meta': {'object_name': 'Neighborhood'},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'county': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'geometry': ('django.contrib.gis.db.models.fields.MultiPolygonField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'region_id': ('django.db.models.fields.IntegerField', [], {}),
            'state': ('django.db.models.fields.CharField', [], {'max_length': '2'})
        },
        'treemap.pending': {
            'Meta': {'object_name': 'Pending'},
            'field': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'status': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'submitted': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'submitted_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pend_submitted_by'", 'to': "orm['auth.User']"}),
            'text_value': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'updated_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pend_updated_by'", 'to': "orm['auth.User']"}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'})
        },
        'treemap.plot': {
            'Meta': {'object_name': 'Plot'},
            'address_city': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'address_street': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'address_zip': ('django.db.models.fields.CharField', [], {'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'data_owner': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'owner'", 'null': 'True', 'to': "orm['auth.User']"}),
            'geocoded_accuracy': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'geocoded_address': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'geocoded_lat': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'geocoded_lon': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'geometry': ('django.contrib.gis.db.models.fields.PointField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'import_event': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.ImportEvent']"}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'last_updated_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'plot_updated_by'", 'to': "orm['auth.User']"}),
            'length': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'neighborhood': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['treemap.Neighborhood']", 'null': 'True', 'symmetrical': 'False'}),
            'neighborhoods': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'owner_additional_properties': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'owner_orig_id': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'owner_additional_id': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'powerline_conflict_potential': ('django.db.models.fields.CharField', [], {'default': "'3'", 'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'present': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'readonly': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'sidewalk_damage': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'type': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'width': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'zipcode': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.ZipCode']", 'null': 'True', 'blank': 'True'})
        },
        'treemap.plotaudit': {
            'Meta': {'ordering': "['-_audit_timestamp']", 'object_name': 'PlotAudit', 'db_table': "'treemap_plot_audit'"},
            '_audit_change_type': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
            '_audit_diff': ('django.db.models.fields.TextField', [], {}),
            '_audit_id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            '_audit_timestamp': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            '_audit_user_rep': ('django.db.models.fields.IntegerField', [], {}),
            '_audit_verified': ('django.db.models.fields.IntegerField', [], {}),
            'address_city': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'address_street': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'address_zip': ('django.db.models.fields.CharField', [], {'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'data_owner': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'_audit_owner'", 'null': 'True', 'to': "orm['auth.User']"}),
            'geocoded_accuracy': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'geocoded_address': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'geocoded_lat': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'geocoded_lon': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'geometry': ('django.contrib.gis.db.models.fields.PointField', [], {}),
            'id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True'}),
            'import_event': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'_audit_plot'", 'to': "orm['treemap.ImportEvent']"}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'last_updated_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'_audit_plot_updated_by'", 'to': "orm['auth.User']"}),
            'length': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'neighborhoods': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'owner_additional_properties': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'owner_orig_id': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'owner_additional_id': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'powerline_conflict_potential': ('django.db.models.fields.CharField', [], {'default': "'3'", 'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'present': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'readonly': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'sidewalk_damage': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'type': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'width': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'zipcode': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'_audit_plot'", 'null': 'True', 'to': "orm['treemap.ZipCode']"})
        },
        'treemap.plotpending': {
            'Meta': {'object_name': 'PlotPending', '_ormbases': ['treemap.Pending']},
            'geometry': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True', 'blank': 'True'}),
            'pending_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.Pending']", 'unique': 'True', 'primary_key': 'True'}),
            'plot': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Plot']"})
        },
        'treemap.plotstewardship': {
            'Meta': {'object_name': 'PlotStewardship', '_ormbases': ['treemap.Stewardship']},
            'activity': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'plot': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Plot']"}),
            'stewardship_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.Stewardship']", 'unique': 'True', 'primary_key': 'True'})
        },
        'treemap.resource': {
            'Meta': {'object_name': 'Resource'},
            'aq_nox_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_nox_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_ozone_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_pm10_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_pm10_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_sox_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_sox_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_voc_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'bvoc_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_sequestered_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_storage_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'electricity_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'hydro_interception_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'meta_species': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'natural_gas_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'region': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'})
        },
        'treemap.resourcesummarymodel': {
            'Meta': {'object_name': 'ResourceSummaryModel'},
            'annual_air_quality_improvement': ('django.db.models.fields.FloatField', [], {}),
            'annual_bvoc': ('django.db.models.fields.FloatField', [], {}),
            'annual_co2_avoided': ('django.db.models.fields.FloatField', [], {}),
            'annual_co2_reduced': ('django.db.models.fields.FloatField', [], {}),
            'annual_co2_sequestered': ('django.db.models.fields.FloatField', [], {}),
            'annual_electricity_conserved': ('django.db.models.fields.FloatField', [], {}),
            'annual_energy_conserved': ('django.db.models.fields.FloatField', [], {}),
            'annual_natural_gas_conserved': ('django.db.models.fields.FloatField', [], {}),
            'annual_nox': ('django.db.models.fields.FloatField', [], {}),
            'annual_ozone': ('django.db.models.fields.FloatField', [], {}),
            'annual_pm10': ('django.db.models.fields.FloatField', [], {}),
            'annual_sox': ('django.db.models.fields.FloatField', [], {}),
            'annual_stormwater_management': ('django.db.models.fields.FloatField', [], {}),
            'annual_voc': ('django.db.models.fields.FloatField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'total_co2_stored': ('django.db.models.fields.FloatField', [], {})
        },
        'treemap.species': {
            'Meta': {'object_name': 'Species'},
            'alternate_symbol': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'bloom_period': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'common_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'cultivar_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'fact_sheet': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'fall_conspicuous': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'flower_conspicuous': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'fruit_period': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'gender': ('django.db.models.fields.CharField', [], {'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'genus': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'itree_code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'native_status': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'palatable_human': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'plant_guide': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'resource': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['treemap.Resource']", 'null': 'True', 'symmetrical': 'False'}),
            'scientific_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'species': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'symbol': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'tree_count': ('django.db.models.fields.IntegerField', [], {'default': '0', 'db_index': 'True'}),
            'v_max_dbh': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'v_max_height': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'v_multiple_trunks': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'wildlife_value': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'})
        },
        'treemap.stewardship': {
            'Meta': {'object_name': 'Stewardship'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'performed_by': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'performed_date': ('django.db.models.fields.DateTimeField', [], {})
        },
        'treemap.supervisordistrict': {
            'Meta': {'object_name': 'SupervisorDistrict'},
            'geometry': ('django.contrib.gis.db.models.fields.MultiPolygonField', [], {}),
            'id': ('django.db.models.fields.IntegerField', [], {'primary_key': 'True'}),
            'supervisor': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'treemap.tree': {
            'Meta': {'object_name': 'Tree'},
            'canopy_condition': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'canopy_height': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'condition': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'date_planted': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date_removed': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'dbh': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'height': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'import_event': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.ImportEvent']"}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'last_updated_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'updated_by'", 'to': "orm['auth.User']"}),
            'orig_species': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'photo_count': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'plot': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Plot']"}),
            'present': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'projects': ('django.db.models.fields.CharField', [], {'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'readonly': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            's_order': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'species': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Species']", 'null': 'True', 'blank': 'True'}),
            'species_other1': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'species_other2': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'sponsor': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'steward_name': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'steward_user': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'steward'", 'null': 'True', 'to': "orm['auth.User']"}),
            'tree_owner': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'})
        },
        'treemap.treeaction': {
            'Meta': {'object_name': 'TreeAction'},
            'comment': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'reported': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'reported_by': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"}),
            'value': ('django.db.models.fields.DateTimeField', [], {})
        },
        'treemap.treealert': {
            'Meta': {'object_name': 'TreeAlert'},
            'comment': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'reported': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'reported_by': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'solved': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"}),
            'value': ('django.db.models.fields.DateTimeField', [], {})
        },
        'treemap.treeaudit': {
            'Meta': {'ordering': "['-_audit_timestamp']", 'object_name': 'TreeAudit', 'db_table': "'treemap_tree_audit'"},
            '_audit_change_type': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
            '_audit_diff': ('django.db.models.fields.TextField', [], {}),
            '_audit_id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            '_audit_timestamp': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            '_audit_user_rep': ('django.db.models.fields.IntegerField', [], {}),
            '_audit_verified': ('django.db.models.fields.IntegerField', [], {}),
            'canopy_condition': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'canopy_height': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'condition': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'date_planted': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date_removed': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'dbh': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'height': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True'}),
            'import_event': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'_audit_tree'", 'to': "orm['treemap.ImportEvent']"}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'last_updated_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'_audit_updated_by'", 'to': "orm['auth.User']"}),
            'orig_species': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'photo_count': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'plot': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'_audit_tree'", 'to': "orm['treemap.Plot']"}),
            'present': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'projects': ('django.db.models.fields.CharField', [], {'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'readonly': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            's_order': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'species': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'_audit_tree'", 'null': 'True', 'to': "orm['treemap.Species']"}),
            'species_other1': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'species_other2': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'sponsor': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'steward_name': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'steward_user': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'_audit_steward'", 'null': 'True', 'to': "orm['auth.User']"}),
            'tree_owner': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'})
        },
        'treemap.treefavorite': {
            'Meta': {'object_name': 'TreeFavorite'},
            'date_created': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'treemap.treeflags': {
            'Meta': {'object_name': 'TreeFlags'},
            'comment': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'reported': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'reported_by': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"}),
            'value': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        'treemap.treepending': {
            'Meta': {'object_name': 'TreePending', '_ormbases': ['treemap.Pending']},
            'pending_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.Pending']", 'unique': 'True', 'primary_key': 'True'}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"})
        },
        'treemap.treephoto': {
            'Meta': {'object_name': 'TreePhoto'},
            'comment': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'photo': ('sorl.thumbnail.fields.ImageField', [], {'max_length': '100'}),
            'reported': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'reported_by': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"})
        },
        'treemap.treeresource': {
            'Meta': {'object_name': 'TreeResource', '_ormbases': ['treemap.ResourceSummaryModel']},
            'resourcesummarymodel_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.ResourceSummaryModel']", 'unique': 'True'}),
            'tree': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.Tree']", 'unique': 'True', 'primary_key': 'True'})
        },
        'treemap.treestewardship': {
            'Meta': {'object_name': 'TreeStewardship', '_ormbases': ['treemap.Stewardship']},
            'activity': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'stewardship_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.Stewardship']", 'unique': 'True', 'primary_key': 'True'}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"})
        },
        'treemap.treewatch': {
            'Meta': {'object_name': 'TreeWatch'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'severity': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"}),
            'valid': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'treemap.zipcode': {
            'Meta': {'object_name': 'ZipCode'},
            'geometry': ('django.contrib.gis.db.models.fields.MultiPolygonField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'zip': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        }
    }

    complete_apps = ['treemap']
########NEW FILE########
__FILENAME__ = 0002_add_url_and_pests
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Deleting model 'Factoid'
        db.delete_table('treemap_factoid')

        # Adding field 'TreeAudit.url'
        db.add_column('treemap_tree_audit', 'url',
                      self.gf('django.db.models.fields.URLField')(max_length=255, null=True, blank=True),
                      keep_default=False)

        # Adding field 'TreeAudit.pests'
        db.add_column('treemap_tree_audit', 'pests',
                      self.gf('django.db.models.fields.CharField')(max_length=256, null=True, blank=True),
                      keep_default=False)

        # Adding field 'Tree.url'
        db.add_column('treemap_tree', 'url',
                      self.gf('django.db.models.fields.URLField')(max_length=255, null=True, blank=True),
                      keep_default=False)

        # Adding field 'Tree.pests'
        db.add_column('treemap_tree', 'pests',
                      self.gf('django.db.models.fields.CharField')(max_length=256, null=True, blank=True),
                      keep_default=False)


    def backwards(self, orm):
        # Adding model 'Factoid'
        db.create_table('treemap_factoid', (
            ('category', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('header', self.gf('django.db.models.fields.CharField')(max_length=100)),
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('fact', self.gf('django.db.models.fields.TextField')(max_length=500)),
        ))
        db.send_create_signal('treemap', ['Factoid'])

        # Deleting field 'TreeAudit.url'
        db.delete_column('treemap_tree_audit', 'url')

        # Deleting field 'TreeAudit.pests'
        db.delete_column('treemap_tree_audit', 'pests')

        # Deleting field 'Tree.url'
        db.delete_column('treemap_tree', 'url')

        # Deleting field 'Tree.pests'
        db.delete_column('treemap_tree', 'pests')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'threadedcomments.threadedcomment': {
            'Meta': {'ordering': "('-date_submitted',)", 'object_name': 'ThreadedComment'},
            'comment': ('django.db.models.fields.TextField', [], {}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'date_approved': ('django.db.models.fields.DateTimeField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'date_modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'date_submitted': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'ip_address': ('django.db.models.fields.IPAddressField', [], {'max_length': '15', 'null': 'True', 'blank': 'True'}),
            'is_approved': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'markup': ('django.db.models.fields.IntegerField', [], {'default': '5', 'null': 'True', 'blank': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'related_name': "'children'", 'null': 'True', 'blank': 'True', 'to': "orm['threadedcomments.ThreadedComment']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'treemap.aggregateneighborhood': {
            'Meta': {'object_name': 'AggregateNeighborhood', '_ormbases': ['treemap.AggregateSummaryModel']},
            'aggregatesummarymodel_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.AggregateSummaryModel']", 'unique': 'True', 'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'aggregates'", 'unique': 'True', 'to': "orm['treemap.Neighborhood']"})
        },
        'treemap.aggregatesearchresult': {
            'Meta': {'object_name': 'AggregateSearchResult', '_ormbases': ['treemap.AggregateSummaryModel']},
            'aggregatesummarymodel_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.AggregateSummaryModel']", 'unique': 'True', 'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '256'})
        },
        'treemap.aggregatesummarymodel': {
            'Meta': {'object_name': 'AggregateSummaryModel', '_ormbases': ['treemap.ResourceSummaryModel']},
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'resourcesummarymodel_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.ResourceSummaryModel']", 'unique': 'True', 'primary_key': 'True'}),
            'total_plots': ('django.db.models.fields.IntegerField', [], {}),
            'total_trees': ('django.db.models.fields.IntegerField', [], {})
        },
        'treemap.aggregatesupervisordistrict': {
            'Meta': {'object_name': 'AggregateSupervisorDistrict', '_ormbases': ['treemap.AggregateSummaryModel']},
            'aggregatesummarymodel_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.AggregateSummaryModel']", 'unique': 'True', 'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'aggregates'", 'unique': 'True', 'to': "orm['treemap.SupervisorDistrict']"})
        },
        'treemap.aggregatezipcode': {
            'Meta': {'object_name': 'AggregateZipCode', '_ormbases': ['treemap.AggregateSummaryModel']},
            'aggregatesummarymodel_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.AggregateSummaryModel']", 'unique': 'True', 'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'aggregates'", 'unique': 'True', 'to': "orm['treemap.ZipCode']"})
        },
        'treemap.benefitvalues': {
            'Meta': {'object_name': 'BenefitValues'},
            'area': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'bvoc': ('django.db.models.fields.FloatField', [], {}),
            'co2': ('django.db.models.fields.FloatField', [], {}),
            'electricity': ('django.db.models.fields.FloatField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'natural_gas': ('django.db.models.fields.FloatField', [], {}),
            'nox': ('django.db.models.fields.FloatField', [], {}),
            'ozone': ('django.db.models.fields.FloatField', [], {}),
            'pm10': ('django.db.models.fields.FloatField', [], {}),
            'sox': ('django.db.models.fields.FloatField', [], {}),
            'stormwater': ('django.db.models.fields.FloatField', [], {}),
            'voc': ('django.db.models.fields.FloatField', [], {})
        },
        'treemap.commentflag': {
            'Meta': {'object_name': 'CommentFlag'},
            'comment': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'comment_flags'", 'to': "orm['threadedcomments.ThreadedComment']"}),
            'flagged': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'flagged_date': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'treemap.exclusionmask': {
            'Meta': {'object_name': 'ExclusionMask'},
            'geometry': ('django.contrib.gis.db.models.fields.MultiPolygonField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'type': ('django.db.models.fields.CharField', [], {'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        'treemap.geocodecache': {
            'Meta': {'object_name': 'GeocodeCache'},
            'address_street': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'geocoded_accuracy': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'geocoded_address': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'geocoded_geometry': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'geocoded_lat': ('django.db.models.fields.FloatField', [], {'null': 'True'}),
            'geocoded_lon': ('django.db.models.fields.FloatField', [], {'null': 'True'}),
            'geometry': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'treemap.importevent': {
            'Meta': {'object_name': 'ImportEvent'},
            'file_name': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'import_date': ('django.db.models.fields.DateField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        'treemap.neighborhood': {
            'Meta': {'object_name': 'Neighborhood'},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'county': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'geometry': ('django.contrib.gis.db.models.fields.MultiPolygonField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'region_id': ('django.db.models.fields.IntegerField', [], {}),
            'state': ('django.db.models.fields.CharField', [], {'max_length': '2'})
        },
        'treemap.pending': {
            'Meta': {'object_name': 'Pending'},
            'field': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'status': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'submitted': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'submitted_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pend_submitted_by'", 'to': "orm['auth.User']"}),
            'text_value': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'updated_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pend_updated_by'", 'to': "orm['auth.User']"}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'})
        },
        'treemap.plot': {
            'Meta': {'object_name': 'Plot'},
            'address_city': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'address_street': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'address_zip': ('django.db.models.fields.CharField', [], {'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'data_owner': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'owner'", 'null': 'True', 'to': "orm['auth.User']"}),
            'geocoded_accuracy': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'geocoded_address': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'geocoded_lat': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'geocoded_lon': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'geometry': ('django.contrib.gis.db.models.fields.PointField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'import_event': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.ImportEvent']"}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'last_updated_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'plot_updated_by'", 'to': "orm['auth.User']"}),
            'length': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'neighborhood': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['treemap.Neighborhood']", 'null': 'True', 'symmetrical': 'False'}),
            'neighborhoods': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'owner_additional_id': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'owner_additional_properties': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'owner_orig_id': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'powerline_conflict_potential': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'present': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'readonly': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'sidewalk_damage': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'type': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'width': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'zipcode': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.ZipCode']", 'null': 'True', 'blank': 'True'})
        },
        'treemap.plotaudit': {
            'Meta': {'ordering': "['-_audit_timestamp']", 'object_name': 'PlotAudit', 'db_table': "'treemap_plot_audit'"},
            '_audit_change_type': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
            '_audit_diff': ('django.db.models.fields.TextField', [], {}),
            '_audit_id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            '_audit_timestamp': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            '_audit_user_rep': ('django.db.models.fields.IntegerField', [], {}),
            '_audit_verified': ('django.db.models.fields.IntegerField', [], {}),
            'address_city': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'address_street': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'address_zip': ('django.db.models.fields.CharField', [], {'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'data_owner': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'_audit_owner'", 'null': 'True', 'to': "orm['auth.User']"}),
            'geocoded_accuracy': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'geocoded_address': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'geocoded_lat': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'geocoded_lon': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'geometry': ('django.contrib.gis.db.models.fields.PointField', [], {}),
            'id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True'}),
            'import_event': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'_audit_plot'", 'to': "orm['treemap.ImportEvent']"}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'last_updated_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'_audit_plot_updated_by'", 'to': "orm['auth.User']"}),
            'length': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'neighborhoods': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'owner_additional_id': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'owner_additional_properties': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'owner_orig_id': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'powerline_conflict_potential': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'present': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'readonly': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'sidewalk_damage': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'type': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'width': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'zipcode': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'_audit_plot'", 'null': 'True', 'to': "orm['treemap.ZipCode']"})
        },
        'treemap.plotpending': {
            'Meta': {'object_name': 'PlotPending', '_ormbases': ['treemap.Pending']},
            'geometry': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True', 'blank': 'True'}),
            'pending_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.Pending']", 'unique': 'True', 'primary_key': 'True'}),
            'plot': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Plot']"})
        },
        'treemap.plotstewardship': {
            'Meta': {'ordering': "['performed_date']", 'object_name': 'PlotStewardship', '_ormbases': ['treemap.Stewardship']},
            'activity': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'plot': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Plot']"}),
            'stewardship_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.Stewardship']", 'unique': 'True', 'primary_key': 'True'})
        },
        'treemap.resource': {
            'Meta': {'object_name': 'Resource'},
            'aq_nox_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_nox_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_ozone_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_pm10_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_pm10_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_sox_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_sox_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_voc_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'bvoc_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_sequestered_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_storage_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'electricity_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'hydro_interception_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'meta_species': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'natural_gas_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'region': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'})
        },
        'treemap.resourcesummarymodel': {
            'Meta': {'object_name': 'ResourceSummaryModel'},
            'annual_air_quality_improvement': ('django.db.models.fields.FloatField', [], {}),
            'annual_bvoc': ('django.db.models.fields.FloatField', [], {}),
            'annual_co2_avoided': ('django.db.models.fields.FloatField', [], {}),
            'annual_co2_reduced': ('django.db.models.fields.FloatField', [], {}),
            'annual_co2_sequestered': ('django.db.models.fields.FloatField', [], {}),
            'annual_electricity_conserved': ('django.db.models.fields.FloatField', [], {}),
            'annual_energy_conserved': ('django.db.models.fields.FloatField', [], {}),
            'annual_natural_gas_conserved': ('django.db.models.fields.FloatField', [], {}),
            'annual_nox': ('django.db.models.fields.FloatField', [], {}),
            'annual_ozone': ('django.db.models.fields.FloatField', [], {}),
            'annual_pm10': ('django.db.models.fields.FloatField', [], {}),
            'annual_sox': ('django.db.models.fields.FloatField', [], {}),
            'annual_stormwater_management': ('django.db.models.fields.FloatField', [], {}),
            'annual_voc': ('django.db.models.fields.FloatField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'total_co2_stored': ('django.db.models.fields.FloatField', [], {})
        },
        'treemap.species': {
            'Meta': {'object_name': 'Species'},
            'alternate_symbol': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'bloom_period': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'common_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'cultivar_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'fact_sheet': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'fall_conspicuous': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'flower_conspicuous': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'fruit_period': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'gender': ('django.db.models.fields.CharField', [], {'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'genus': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'itree_code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'native_status': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'palatable_human': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'plant_guide': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'resource': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['treemap.Resource']", 'null': 'True', 'symmetrical': 'False'}),
            'scientific_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'species': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'symbol': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'tree_count': ('django.db.models.fields.IntegerField', [], {'default': '0', 'db_index': 'True'}),
            'v_max_dbh': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'v_max_height': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'v_multiple_trunks': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'wildlife_value': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'})
        },
        'treemap.stewardship': {
            'Meta': {'ordering': "['performed_date']", 'object_name': 'Stewardship'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'performed_by': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'performed_date': ('django.db.models.fields.DateTimeField', [], {})
        },
        'treemap.supervisordistrict': {
            'Meta': {'object_name': 'SupervisorDistrict'},
            'geometry': ('django.contrib.gis.db.models.fields.MultiPolygonField', [], {}),
            'id': ('django.db.models.fields.IntegerField', [], {'primary_key': 'True'}),
            'supervisor': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'treemap.tree': {
            'Meta': {'object_name': 'Tree'},
            'canopy_condition': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'canopy_height': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'condition': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'date_planted': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date_removed': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'dbh': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'height': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'import_event': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.ImportEvent']"}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'last_updated_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'updated_by'", 'to': "orm['auth.User']"}),
            'orig_species': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'pests': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'photo_count': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'plot': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Plot']"}),
            'present': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'projects': ('django.db.models.fields.CharField', [], {'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'readonly': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            's_order': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'species': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Species']", 'null': 'True', 'blank': 'True'}),
            'species_other1': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'species_other2': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'sponsor': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'steward_name': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'steward_user': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'steward'", 'null': 'True', 'to': "orm['auth.User']"}),
            'tree_owner': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'})
        },
        'treemap.treeaction': {
            'Meta': {'object_name': 'TreeAction'},
            'comment': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'reported': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'reported_by': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"}),
            'value': ('django.db.models.fields.DateTimeField', [], {})
        },
        'treemap.treealert': {
            'Meta': {'object_name': 'TreeAlert'},
            'comment': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'reported': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'reported_by': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'solved': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"}),
            'value': ('django.db.models.fields.DateTimeField', [], {})
        },
        'treemap.treeaudit': {
            'Meta': {'ordering': "['-_audit_timestamp']", 'object_name': 'TreeAudit', 'db_table': "'treemap_tree_audit'"},
            '_audit_change_type': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
            '_audit_diff': ('django.db.models.fields.TextField', [], {}),
            '_audit_id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            '_audit_timestamp': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            '_audit_user_rep': ('django.db.models.fields.IntegerField', [], {}),
            '_audit_verified': ('django.db.models.fields.IntegerField', [], {}),
            'canopy_condition': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'canopy_height': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'condition': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'date_planted': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date_removed': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'dbh': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'height': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True'}),
            'import_event': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'_audit_tree'", 'to': "orm['treemap.ImportEvent']"}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'last_updated_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'_audit_updated_by'", 'to': "orm['auth.User']"}),
            'orig_species': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'pests': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'photo_count': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'plot': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'_audit_tree'", 'to': "orm['treemap.Plot']"}),
            'present': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'projects': ('django.db.models.fields.CharField', [], {'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'readonly': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            's_order': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'species': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'_audit_tree'", 'null': 'True', 'to': "orm['treemap.Species']"}),
            'species_other1': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'species_other2': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'sponsor': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'steward_name': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'steward_user': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'_audit_steward'", 'null': 'True', 'to': "orm['auth.User']"}),
            'tree_owner': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'})
        },
        'treemap.treefavorite': {
            'Meta': {'object_name': 'TreeFavorite'},
            'date_created': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'treemap.treeflags': {
            'Meta': {'object_name': 'TreeFlags'},
            'comment': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'reported': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'reported_by': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"}),
            'value': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        'treemap.treepending': {
            'Meta': {'object_name': 'TreePending', '_ormbases': ['treemap.Pending']},
            'pending_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.Pending']", 'unique': 'True', 'primary_key': 'True'}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"})
        },
        'treemap.treephoto': {
            'Meta': {'object_name': 'TreePhoto'},
            'comment': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'photo': ('sorl.thumbnail.fields.ImageField', [], {'max_length': '100'}),
            'reported': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'reported_by': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"})
        },
        'treemap.treeresource': {
            'Meta': {'object_name': 'TreeResource', '_ormbases': ['treemap.ResourceSummaryModel']},
            'resourcesummarymodel_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.ResourceSummaryModel']", 'unique': 'True'}),
            'tree': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.Tree']", 'unique': 'True', 'primary_key': 'True'})
        },
        'treemap.treestewardship': {
            'Meta': {'ordering': "['performed_date']", 'object_name': 'TreeStewardship', '_ormbases': ['treemap.Stewardship']},
            'activity': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'stewardship_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.Stewardship']", 'unique': 'True', 'primary_key': 'True'}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"})
        },
        'treemap.treewatch': {
            'Meta': {'object_name': 'TreeWatch'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'severity': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"}),
            'valid': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'treemap.zipcode': {
            'Meta': {'object_name': 'ZipCode'},
            'geometry': ('django.contrib.gis.db.models.fields.MultiPolygonField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'zip': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        }
    }

    complete_apps = ['treemap']
########NEW FILE########
__FILENAME__ = 0003_auto__add_field_species_family__add_field_species_other_part_of_name
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding field 'Species.family'
        db.add_column('treemap_species', 'family',
                      self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True),
                      keep_default=False)

        # Adding field 'Species.other_part_of_name'
        db.add_column('treemap_species', 'other_part_of_name',
                      self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True),
                      keep_default=False)


    def backwards(self, orm):
        # Deleting field 'Species.family'
        db.delete_column('treemap_species', 'family')

        # Deleting field 'Species.other_part_of_name'
        db.delete_column('treemap_species', 'other_part_of_name')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'threadedcomments.threadedcomment': {
            'Meta': {'ordering': "('-date_submitted',)", 'object_name': 'ThreadedComment'},
            'comment': ('django.db.models.fields.TextField', [], {}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'date_approved': ('django.db.models.fields.DateTimeField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'date_modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'date_submitted': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'ip_address': ('django.db.models.fields.IPAddressField', [], {'max_length': '15', 'null': 'True', 'blank': 'True'}),
            'is_approved': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'markup': ('django.db.models.fields.IntegerField', [], {'default': '5', 'null': 'True', 'blank': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'related_name': "'children'", 'null': 'True', 'blank': 'True', 'to': "orm['threadedcomments.ThreadedComment']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'treemap.aggregateneighborhood': {
            'Meta': {'object_name': 'AggregateNeighborhood', '_ormbases': ['treemap.AggregateSummaryModel']},
            'aggregatesummarymodel_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.AggregateSummaryModel']", 'unique': 'True', 'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'aggregates'", 'unique': 'True', 'to': "orm['treemap.Neighborhood']"})
        },
        'treemap.aggregatesearchresult': {
            'Meta': {'object_name': 'AggregateSearchResult', '_ormbases': ['treemap.AggregateSummaryModel']},
            'aggregatesummarymodel_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.AggregateSummaryModel']", 'unique': 'True', 'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '256'})
        },
        'treemap.aggregatesummarymodel': {
            'Meta': {'object_name': 'AggregateSummaryModel', '_ormbases': ['treemap.ResourceSummaryModel']},
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'resourcesummarymodel_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.ResourceSummaryModel']", 'unique': 'True', 'primary_key': 'True'}),
            'total_plots': ('django.db.models.fields.IntegerField', [], {}),
            'total_trees': ('django.db.models.fields.IntegerField', [], {})
        },
        'treemap.aggregatesupervisordistrict': {
            'Meta': {'object_name': 'AggregateSupervisorDistrict', '_ormbases': ['treemap.AggregateSummaryModel']},
            'aggregatesummarymodel_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.AggregateSummaryModel']", 'unique': 'True', 'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'aggregates'", 'unique': 'True', 'to': "orm['treemap.SupervisorDistrict']"})
        },
        'treemap.aggregatezipcode': {
            'Meta': {'object_name': 'AggregateZipCode', '_ormbases': ['treemap.AggregateSummaryModel']},
            'aggregatesummarymodel_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.AggregateSummaryModel']", 'unique': 'True', 'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'aggregates'", 'unique': 'True', 'to': "orm['treemap.ZipCode']"})
        },
        'treemap.benefitvalues': {
            'Meta': {'object_name': 'BenefitValues'},
            'area': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'bvoc': ('django.db.models.fields.FloatField', [], {}),
            'co2': ('django.db.models.fields.FloatField', [], {}),
            'electricity': ('django.db.models.fields.FloatField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'natural_gas': ('django.db.models.fields.FloatField', [], {}),
            'nox': ('django.db.models.fields.FloatField', [], {}),
            'ozone': ('django.db.models.fields.FloatField', [], {}),
            'pm10': ('django.db.models.fields.FloatField', [], {}),
            'sox': ('django.db.models.fields.FloatField', [], {}),
            'stormwater': ('django.db.models.fields.FloatField', [], {}),
            'voc': ('django.db.models.fields.FloatField', [], {})
        },
        'treemap.commentflag': {
            'Meta': {'object_name': 'CommentFlag'},
            'comment': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'comment_flags'", 'to': "orm['threadedcomments.ThreadedComment']"}),
            'flagged': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'flagged_date': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'treemap.exclusionmask': {
            'Meta': {'object_name': 'ExclusionMask'},
            'geometry': ('django.contrib.gis.db.models.fields.MultiPolygonField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'type': ('django.db.models.fields.CharField', [], {'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        'treemap.geocodecache': {
            'Meta': {'object_name': 'GeocodeCache'},
            'address_street': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'geocoded_accuracy': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'geocoded_address': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'geocoded_geometry': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'geocoded_lat': ('django.db.models.fields.FloatField', [], {'null': 'True'}),
            'geocoded_lon': ('django.db.models.fields.FloatField', [], {'null': 'True'}),
            'geometry': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'treemap.importevent': {
            'Meta': {'object_name': 'ImportEvent'},
            'file_name': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'import_date': ('django.db.models.fields.DateField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        'treemap.neighborhood': {
            'Meta': {'object_name': 'Neighborhood'},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'county': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'geometry': ('django.contrib.gis.db.models.fields.MultiPolygonField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'region_id': ('django.db.models.fields.IntegerField', [], {}),
            'state': ('django.db.models.fields.CharField', [], {'max_length': '2'})
        },
        'treemap.pending': {
            'Meta': {'object_name': 'Pending'},
            'field': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'status': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'submitted': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'submitted_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pend_submitted_by'", 'to': "orm['auth.User']"}),
            'text_value': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'updated_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pend_updated_by'", 'to': "orm['auth.User']"}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'})
        },
        'treemap.plot': {
            'Meta': {'object_name': 'Plot'},
            'address_city': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'address_street': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'address_zip': ('django.db.models.fields.CharField', [], {'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'data_owner': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'owner'", 'null': 'True', 'to': "orm['auth.User']"}),
            'geocoded_accuracy': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'geocoded_address': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'geocoded_lat': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'geocoded_lon': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'geometry': ('django.contrib.gis.db.models.fields.PointField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'import_event': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.ImportEvent']"}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'last_updated_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'plot_updated_by'", 'to': "orm['auth.User']"}),
            'length': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'neighborhood': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['treemap.Neighborhood']", 'null': 'True', 'symmetrical': 'False'}),
            'neighborhoods': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'owner_additional_id': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'owner_additional_properties': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'owner_orig_id': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'powerline_conflict_potential': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'present': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'readonly': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'sidewalk_damage': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'type': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'width': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'zipcode': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.ZipCode']", 'null': 'True', 'blank': 'True'})
        },
        'treemap.plotaudit': {
            'Meta': {'ordering': "['-_audit_timestamp']", 'object_name': 'PlotAudit', 'db_table': "'treemap_plot_audit'"},
            '_audit_change_type': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
            '_audit_diff': ('django.db.models.fields.TextField', [], {}),
            '_audit_id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            '_audit_timestamp': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            '_audit_user_rep': ('django.db.models.fields.IntegerField', [], {}),
            '_audit_verified': ('django.db.models.fields.IntegerField', [], {}),
            'address_city': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'address_street': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'address_zip': ('django.db.models.fields.CharField', [], {'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'data_owner': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'_audit_owner'", 'null': 'True', 'to': "orm['auth.User']"}),
            'geocoded_accuracy': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'geocoded_address': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'geocoded_lat': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'geocoded_lon': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'geometry': ('django.contrib.gis.db.models.fields.PointField', [], {}),
            'id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True'}),
            'import_event': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'_audit_plot'", 'to': "orm['treemap.ImportEvent']"}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'last_updated_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'_audit_plot_updated_by'", 'to': "orm['auth.User']"}),
            'length': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'neighborhoods': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'owner_additional_id': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'owner_additional_properties': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'owner_orig_id': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'powerline_conflict_potential': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'present': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'readonly': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'sidewalk_damage': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'type': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'width': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'zipcode': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'_audit_plot'", 'null': 'True', 'to': "orm['treemap.ZipCode']"})
        },
        'treemap.plotpending': {
            'Meta': {'object_name': 'PlotPending', '_ormbases': ['treemap.Pending']},
            'geometry': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True', 'blank': 'True'}),
            'pending_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.Pending']", 'unique': 'True', 'primary_key': 'True'}),
            'plot': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Plot']"})
        },
        'treemap.plotstewardship': {
            'Meta': {'ordering': "['performed_date']", 'object_name': 'PlotStewardship', '_ormbases': ['treemap.Stewardship']},
            'activity': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'plot': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Plot']"}),
            'stewardship_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.Stewardship']", 'unique': 'True', 'primary_key': 'True'})
        },
        'treemap.resource': {
            'Meta': {'object_name': 'Resource'},
            'aq_nox_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_nox_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_ozone_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_pm10_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_pm10_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_sox_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_sox_dep_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'aq_voc_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'bvoc_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_avoided_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_sequestered_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'co2_storage_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'electricity_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'hydro_interception_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'meta_species': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'natural_gas_dbh': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'region': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'})
        },
        'treemap.resourcesummarymodel': {
            'Meta': {'object_name': 'ResourceSummaryModel'},
            'annual_air_quality_improvement': ('django.db.models.fields.FloatField', [], {}),
            'annual_bvoc': ('django.db.models.fields.FloatField', [], {}),
            'annual_co2_avoided': ('django.db.models.fields.FloatField', [], {}),
            'annual_co2_reduced': ('django.db.models.fields.FloatField', [], {}),
            'annual_co2_sequestered': ('django.db.models.fields.FloatField', [], {}),
            'annual_electricity_conserved': ('django.db.models.fields.FloatField', [], {}),
            'annual_energy_conserved': ('django.db.models.fields.FloatField', [], {}),
            'annual_natural_gas_conserved': ('django.db.models.fields.FloatField', [], {}),
            'annual_nox': ('django.db.models.fields.FloatField', [], {}),
            'annual_ozone': ('django.db.models.fields.FloatField', [], {}),
            'annual_pm10': ('django.db.models.fields.FloatField', [], {}),
            'annual_sox': ('django.db.models.fields.FloatField', [], {}),
            'annual_stormwater_management': ('django.db.models.fields.FloatField', [], {}),
            'annual_voc': ('django.db.models.fields.FloatField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'total_co2_stored': ('django.db.models.fields.FloatField', [], {})
        },
        'treemap.species': {
            'Meta': {'object_name': 'Species'},
            'alternate_symbol': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'bloom_period': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'common_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'cultivar_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'fact_sheet': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'fall_conspicuous': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'family': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'flower_conspicuous': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'fruit_period': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'gender': ('django.db.models.fields.CharField', [], {'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'genus': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'itree_code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'native_status': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'other_part_of_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'palatable_human': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'plant_guide': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'resource': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['treemap.Resource']", 'null': 'True', 'symmetrical': 'False'}),
            'scientific_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'species': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'symbol': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'tree_count': ('django.db.models.fields.IntegerField', [], {'default': '0', 'db_index': 'True'}),
            'v_max_dbh': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'v_max_height': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'v_multiple_trunks': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'wildlife_value': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'})
        },
        'treemap.stewardship': {
            'Meta': {'ordering': "['performed_date']", 'object_name': 'Stewardship'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'performed_by': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'performed_date': ('django.db.models.fields.DateTimeField', [], {})
        },
        'treemap.supervisordistrict': {
            'Meta': {'object_name': 'SupervisorDistrict'},
            'geometry': ('django.contrib.gis.db.models.fields.MultiPolygonField', [], {}),
            'id': ('django.db.models.fields.IntegerField', [], {'primary_key': 'True'}),
            'supervisor': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'treemap.tree': {
            'Meta': {'object_name': 'Tree'},
            'canopy_condition': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'canopy_height': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'condition': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'date_planted': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date_removed': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'dbh': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'height': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'import_event': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.ImportEvent']"}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'last_updated_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'updated_by'", 'to': "orm['auth.User']"}),
            'orig_species': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'pests': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'photo_count': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'plot': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Plot']"}),
            'present': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'projects': ('django.db.models.fields.CharField', [], {'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'readonly': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            's_order': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'species': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Species']", 'null': 'True', 'blank': 'True'}),
            'species_other1': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'species_other2': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'sponsor': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'steward_name': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'steward_user': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'steward'", 'null': 'True', 'to': "orm['auth.User']"}),
            'tree_owner': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'})
        },
        'treemap.treeaction': {
            'Meta': {'object_name': 'TreeAction'},
            'comment': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'reported': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'reported_by': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"}),
            'value': ('django.db.models.fields.DateTimeField', [], {})
        },
        'treemap.treealert': {
            'Meta': {'object_name': 'TreeAlert'},
            'comment': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'reported': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'reported_by': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'solved': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"}),
            'value': ('django.db.models.fields.DateTimeField', [], {})
        },
        'treemap.treeaudit': {
            'Meta': {'ordering': "['-_audit_timestamp']", 'object_name': 'TreeAudit', 'db_table': "'treemap_tree_audit'"},
            '_audit_change_type': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
            '_audit_diff': ('django.db.models.fields.TextField', [], {}),
            '_audit_id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            '_audit_timestamp': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            '_audit_user_rep': ('django.db.models.fields.IntegerField', [], {}),
            '_audit_verified': ('django.db.models.fields.IntegerField', [], {}),
            'canopy_condition': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'canopy_height': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'condition': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'date_planted': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date_removed': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'dbh': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'height': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True'}),
            'import_event': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'_audit_tree'", 'to': "orm['treemap.ImportEvent']"}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'last_updated_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'_audit_updated_by'", 'to': "orm['auth.User']"}),
            'orig_species': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'pests': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'photo_count': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'plot': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'_audit_tree'", 'to': "orm['treemap.Plot']"}),
            'present': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'projects': ('django.db.models.fields.CharField', [], {'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'readonly': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            's_order': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'species': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'_audit_tree'", 'null': 'True', 'to': "orm['treemap.Species']"}),
            'species_other1': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'species_other2': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'sponsor': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'steward_name': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'steward_user': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'_audit_steward'", 'null': 'True', 'to': "orm['auth.User']"}),
            'tree_owner': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'})
        },
        'treemap.treefavorite': {
            'Meta': {'object_name': 'TreeFavorite'},
            'date_created': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'treemap.treeflags': {
            'Meta': {'object_name': 'TreeFlags'},
            'comment': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'reported': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'reported_by': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"}),
            'value': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        'treemap.treepending': {
            'Meta': {'object_name': 'TreePending', '_ormbases': ['treemap.Pending']},
            'pending_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.Pending']", 'unique': 'True', 'primary_key': 'True'}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"})
        },
        'treemap.treephoto': {
            'Meta': {'object_name': 'TreePhoto'},
            'comment': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'photo': ('sorl.thumbnail.fields.ImageField', [], {'max_length': '100'}),
            'reported': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'reported_by': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"})
        },
        'treemap.treeresource': {
            'Meta': {'object_name': 'TreeResource', '_ormbases': ['treemap.ResourceSummaryModel']},
            'resourcesummarymodel_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.ResourceSummaryModel']", 'unique': 'True'}),
            'tree': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.Tree']", 'unique': 'True', 'primary_key': 'True'})
        },
        'treemap.treestewardship': {
            'Meta': {'ordering': "['performed_date']", 'object_name': 'TreeStewardship', '_ormbases': ['treemap.Stewardship']},
            'activity': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'stewardship_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.Stewardship']", 'unique': 'True', 'primary_key': 'True'}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"})
        },
        'treemap.treewatch': {
            'Meta': {'object_name': 'TreeWatch'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'severity': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"}),
            'valid': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'treemap.zipcode': {
            'Meta': {'object_name': 'ZipCode'},
            'geometry': ('django.contrib.gis.db.models.fields.MultiPolygonField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'zip': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        }
    }

    complete_apps = ['treemap']
########NEW FILE########
__FILENAME__ = 0004_auto__del_field_resource_electricity_dbh__del_field_resource_co2_avoid
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Deleting field 'Resource.electricity_dbh'
        db.delete_column('treemap_resource', 'electricity_dbh')

        # Deleting field 'Resource.co2_avoided_dbh'
        db.delete_column('treemap_resource', 'co2_avoided_dbh')

        # Deleting field 'Resource.aq_pm10_dep_dbh'
        db.delete_column('treemap_resource', 'aq_pm10_dep_dbh')

        # Deleting field 'Resource.aq_voc_avoided_dbh'
        db.delete_column('treemap_resource', 'aq_voc_avoided_dbh')

        # Deleting field 'Resource.aq_pm10_avoided_dbh'
        db.delete_column('treemap_resource', 'aq_pm10_avoided_dbh')

        # Deleting field 'Resource.aq_ozone_dep_dbh'
        db.delete_column('treemap_resource', 'aq_ozone_dep_dbh')

        # Deleting field 'Resource.aq_nox_avoided_dbh'
        db.delete_column('treemap_resource', 'aq_nox_avoided_dbh')

        # Deleting field 'Resource.co2_storage_dbh'
        db.delete_column('treemap_resource', 'co2_storage_dbh')

        # Deleting field 'Resource.aq_sox_avoided_dbh'
        db.delete_column('treemap_resource', 'aq_sox_avoided_dbh')

        # Deleting field 'Resource.aq_sox_dep_dbh'
        db.delete_column('treemap_resource', 'aq_sox_dep_dbh')

        # Deleting field 'Resource.bvoc_dbh'
        db.delete_column('treemap_resource', 'bvoc_dbh')

        # Deleting field 'Resource.co2_sequestered_dbh'
        db.delete_column('treemap_resource', 'co2_sequestered_dbh')

        # Deleting field 'Resource.aq_nox_dep_dbh'
        db.delete_column('treemap_resource', 'aq_nox_dep_dbh')

        # Deleting field 'Resource.hydro_interception_dbh'
        db.delete_column('treemap_resource', 'hydro_interception_dbh')

        # Deleting field 'Resource.natural_gas_dbh'
        db.delete_column('treemap_resource', 'natural_gas_dbh')


    def backwards(self, orm):
        # Adding field 'Resource.electricity_dbh'
        db.add_column('treemap_resource', 'electricity_dbh',
                      self.gf('django.db.models.fields.TextField')(null=True, blank=True),
                      keep_default=False)

        # Adding field 'Resource.co2_avoided_dbh'
        db.add_column('treemap_resource', 'co2_avoided_dbh',
                      self.gf('django.db.models.fields.TextField')(null=True, blank=True),
                      keep_default=False)

        # Adding field 'Resource.aq_pm10_dep_dbh'
        db.add_column('treemap_resource', 'aq_pm10_dep_dbh',
                      self.gf('django.db.models.fields.TextField')(null=True, blank=True),
                      keep_default=False)

        # Adding field 'Resource.aq_voc_avoided_dbh'
        db.add_column('treemap_resource', 'aq_voc_avoided_dbh',
                      self.gf('django.db.models.fields.TextField')(null=True, blank=True),
                      keep_default=False)

        # Adding field 'Resource.aq_pm10_avoided_dbh'
        db.add_column('treemap_resource', 'aq_pm10_avoided_dbh',
                      self.gf('django.db.models.fields.TextField')(null=True, blank=True),
                      keep_default=False)

        # Adding field 'Resource.aq_ozone_dep_dbh'
        db.add_column('treemap_resource', 'aq_ozone_dep_dbh',
                      self.gf('django.db.models.fields.TextField')(null=True, blank=True),
                      keep_default=False)

        # Adding field 'Resource.aq_nox_avoided_dbh'
        db.add_column('treemap_resource', 'aq_nox_avoided_dbh',
                      self.gf('django.db.models.fields.TextField')(null=True, blank=True),
                      keep_default=False)

        # Adding field 'Resource.co2_storage_dbh'
        db.add_column('treemap_resource', 'co2_storage_dbh',
                      self.gf('django.db.models.fields.TextField')(null=True, blank=True),
                      keep_default=False)

        # Adding field 'Resource.aq_sox_avoided_dbh'
        db.add_column('treemap_resource', 'aq_sox_avoided_dbh',
                      self.gf('django.db.models.fields.TextField')(null=True, blank=True),
                      keep_default=False)

        # Adding field 'Resource.aq_sox_dep_dbh'
        db.add_column('treemap_resource', 'aq_sox_dep_dbh',
                      self.gf('django.db.models.fields.TextField')(null=True, blank=True),
                      keep_default=False)

        # Adding field 'Resource.bvoc_dbh'
        db.add_column('treemap_resource', 'bvoc_dbh',
                      self.gf('django.db.models.fields.TextField')(null=True, blank=True),
                      keep_default=False)

        # Adding field 'Resource.co2_sequestered_dbh'
        db.add_column('treemap_resource', 'co2_sequestered_dbh',
                      self.gf('django.db.models.fields.TextField')(null=True, blank=True),
                      keep_default=False)

        # Adding field 'Resource.aq_nox_dep_dbh'
        db.add_column('treemap_resource', 'aq_nox_dep_dbh',
                      self.gf('django.db.models.fields.TextField')(null=True, blank=True),
                      keep_default=False)

        # Adding field 'Resource.hydro_interception_dbh'
        db.add_column('treemap_resource', 'hydro_interception_dbh',
                      self.gf('django.db.models.fields.TextField')(null=True, blank=True),
                      keep_default=False)

        # Adding field 'Resource.natural_gas_dbh'
        db.add_column('treemap_resource', 'natural_gas_dbh',
                      self.gf('django.db.models.fields.TextField')(null=True, blank=True),
                      keep_default=False)


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'threadedcomments.threadedcomment': {
            'Meta': {'ordering': "('-date_submitted',)", 'object_name': 'ThreadedComment'},
            'comment': ('django.db.models.fields.TextField', [], {}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'date_approved': ('django.db.models.fields.DateTimeField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'date_modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'date_submitted': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'ip_address': ('django.db.models.fields.IPAddressField', [], {'max_length': '15', 'null': 'True', 'blank': 'True'}),
            'is_approved': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'markup': ('django.db.models.fields.IntegerField', [], {'default': '5', 'null': 'True', 'blank': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'related_name': "'children'", 'null': 'True', 'blank': 'True', 'to': "orm['threadedcomments.ThreadedComment']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'treemap.aggregateneighborhood': {
            'Meta': {'object_name': 'AggregateNeighborhood', '_ormbases': ['treemap.AggregateSummaryModel']},
            'aggregatesummarymodel_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.AggregateSummaryModel']", 'unique': 'True', 'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'aggregates'", 'unique': 'True', 'to': "orm['treemap.Neighborhood']"})
        },
        'treemap.aggregatesearchresult': {
            'Meta': {'object_name': 'AggregateSearchResult', '_ormbases': ['treemap.AggregateSummaryModel']},
            'aggregatesummarymodel_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.AggregateSummaryModel']", 'unique': 'True', 'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '256'})
        },
        'treemap.aggregatesummarymodel': {
            'Meta': {'object_name': 'AggregateSummaryModel', '_ormbases': ['treemap.ResourceSummaryModel']},
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'resourcesummarymodel_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.ResourceSummaryModel']", 'unique': 'True', 'primary_key': 'True'}),
            'total_plots': ('django.db.models.fields.IntegerField', [], {}),
            'total_trees': ('django.db.models.fields.IntegerField', [], {})
        },
        'treemap.aggregatesupervisordistrict': {
            'Meta': {'object_name': 'AggregateSupervisorDistrict', '_ormbases': ['treemap.AggregateSummaryModel']},
            'aggregatesummarymodel_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.AggregateSummaryModel']", 'unique': 'True', 'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'aggregates'", 'unique': 'True', 'to': "orm['treemap.SupervisorDistrict']"})
        },
        'treemap.aggregatezipcode': {
            'Meta': {'object_name': 'AggregateZipCode', '_ormbases': ['treemap.AggregateSummaryModel']},
            'aggregatesummarymodel_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.AggregateSummaryModel']", 'unique': 'True', 'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'aggregates'", 'unique': 'True', 'to': "orm['treemap.ZipCode']"})
        },
        'treemap.benefitvalues': {
            'Meta': {'object_name': 'BenefitValues'},
            'area': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'bvoc': ('django.db.models.fields.FloatField', [], {}),
            'co2': ('django.db.models.fields.FloatField', [], {}),
            'electricity': ('django.db.models.fields.FloatField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'natural_gas': ('django.db.models.fields.FloatField', [], {}),
            'nox': ('django.db.models.fields.FloatField', [], {}),
            'ozone': ('django.db.models.fields.FloatField', [], {}),
            'pm10': ('django.db.models.fields.FloatField', [], {}),
            'sox': ('django.db.models.fields.FloatField', [], {}),
            'stormwater': ('django.db.models.fields.FloatField', [], {}),
            'voc': ('django.db.models.fields.FloatField', [], {})
        },
        'treemap.commentflag': {
            'Meta': {'object_name': 'CommentFlag'},
            'comment': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'comment_flags'", 'to': "orm['threadedcomments.ThreadedComment']"}),
            'flagged': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'flagged_date': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'treemap.exclusionmask': {
            'Meta': {'object_name': 'ExclusionMask'},
            'geometry': ('django.contrib.gis.db.models.fields.MultiPolygonField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'type': ('django.db.models.fields.CharField', [], {'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        'treemap.geocodecache': {
            'Meta': {'object_name': 'GeocodeCache'},
            'address_street': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'geocoded_accuracy': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'geocoded_address': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'geocoded_geometry': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'geocoded_lat': ('django.db.models.fields.FloatField', [], {'null': 'True'}),
            'geocoded_lon': ('django.db.models.fields.FloatField', [], {'null': 'True'}),
            'geometry': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'treemap.importevent': {
            'Meta': {'object_name': 'ImportEvent'},
            'file_name': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'import_date': ('django.db.models.fields.DateField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        'treemap.neighborhood': {
            'Meta': {'object_name': 'Neighborhood'},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'county': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'geometry': ('django.contrib.gis.db.models.fields.MultiPolygonField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'region_id': ('django.db.models.fields.IntegerField', [], {}),
            'state': ('django.db.models.fields.CharField', [], {'max_length': '2'})
        },
        'treemap.pending': {
            'Meta': {'object_name': 'Pending'},
            'field': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'status': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'submitted': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'submitted_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pend_submitted_by'", 'to': "orm['auth.User']"}),
            'text_value': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'updated_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pend_updated_by'", 'to': "orm['auth.User']"}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'})
        },
        'treemap.plot': {
            'Meta': {'object_name': 'Plot'},
            'address_city': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'address_street': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'address_zip': ('django.db.models.fields.CharField', [], {'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'data_owner': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'owner'", 'null': 'True', 'to': "orm['auth.User']"}),
            'geocoded_accuracy': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'geocoded_address': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'geocoded_lat': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'geocoded_lon': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'geometry': ('django.contrib.gis.db.models.fields.PointField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'import_event': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.ImportEvent']"}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'last_updated_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'plot_updated_by'", 'to': "orm['auth.User']"}),
            'length': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'neighborhood': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['treemap.Neighborhood']", 'null': 'True', 'symmetrical': 'False'}),
            'neighborhoods': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'owner_additional_id': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'owner_additional_properties': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'owner_orig_id': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'powerline_conflict_potential': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'present': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'readonly': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'sidewalk_damage': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'type': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'width': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'zipcode': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.ZipCode']", 'null': 'True', 'blank': 'True'})
        },
        'treemap.plotaudit': {
            'Meta': {'ordering': "['-_audit_timestamp']", 'object_name': 'PlotAudit', 'db_table': "'treemap_plot_audit'"},
            '_audit_change_type': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
            '_audit_diff': ('django.db.models.fields.TextField', [], {}),
            '_audit_id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            '_audit_timestamp': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            '_audit_user_rep': ('django.db.models.fields.IntegerField', [], {}),
            '_audit_verified': ('django.db.models.fields.IntegerField', [], {}),
            'address_city': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'address_street': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'address_zip': ('django.db.models.fields.CharField', [], {'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'data_owner': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'_audit_owner'", 'null': 'True', 'to': "orm['auth.User']"}),
            'geocoded_accuracy': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'geocoded_address': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'geocoded_lat': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'geocoded_lon': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'geometry': ('django.contrib.gis.db.models.fields.PointField', [], {}),
            'id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True'}),
            'import_event': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'_audit_plot'", 'to': "orm['treemap.ImportEvent']"}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'last_updated_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'_audit_plot_updated_by'", 'to': "orm['auth.User']"}),
            'length': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'neighborhoods': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'owner_additional_id': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'owner_additional_properties': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'owner_orig_id': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'powerline_conflict_potential': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'present': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'readonly': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'sidewalk_damage': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'type': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'width': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'zipcode': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'_audit_plot'", 'null': 'True', 'to': "orm['treemap.ZipCode']"})
        },
        'treemap.plotpending': {
            'Meta': {'object_name': 'PlotPending', '_ormbases': ['treemap.Pending']},
            'geometry': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True', 'blank': 'True'}),
            'pending_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.Pending']", 'unique': 'True', 'primary_key': 'True'}),
            'plot': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Plot']"})
        },
        'treemap.plotstewardship': {
            'Meta': {'ordering': "['performed_date']", 'object_name': 'PlotStewardship', '_ormbases': ['treemap.Stewardship']},
            'activity': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'plot': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Plot']"}),
            'stewardship_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.Stewardship']", 'unique': 'True', 'primary_key': 'True'})
        },
        'treemap.resource': {
            'Meta': {'object_name': 'Resource'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'meta_species': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'region': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'})
        },
        'treemap.resourcesummarymodel': {
            'Meta': {'object_name': 'ResourceSummaryModel'},
            'annual_air_quality_improvement': ('django.db.models.fields.FloatField', [], {}),
            'annual_bvoc': ('django.db.models.fields.FloatField', [], {}),
            'annual_co2_avoided': ('django.db.models.fields.FloatField', [], {}),
            'annual_co2_reduced': ('django.db.models.fields.FloatField', [], {}),
            'annual_co2_sequestered': ('django.db.models.fields.FloatField', [], {}),
            'annual_electricity_conserved': ('django.db.models.fields.FloatField', [], {}),
            'annual_energy_conserved': ('django.db.models.fields.FloatField', [], {}),
            'annual_natural_gas_conserved': ('django.db.models.fields.FloatField', [], {}),
            'annual_nox': ('django.db.models.fields.FloatField', [], {}),
            'annual_ozone': ('django.db.models.fields.FloatField', [], {}),
            'annual_pm10': ('django.db.models.fields.FloatField', [], {}),
            'annual_sox': ('django.db.models.fields.FloatField', [], {}),
            'annual_stormwater_management': ('django.db.models.fields.FloatField', [], {}),
            'annual_voc': ('django.db.models.fields.FloatField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'total_co2_stored': ('django.db.models.fields.FloatField', [], {})
        },
        'treemap.species': {
            'Meta': {'object_name': 'Species'},
            'alternate_symbol': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'bloom_period': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'common_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'cultivar_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'fact_sheet': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'fall_conspicuous': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'family': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'flower_conspicuous': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'fruit_period': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'gender': ('django.db.models.fields.CharField', [], {'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'genus': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'itree_code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'native_status': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'other_part_of_name': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'palatable_human': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'plant_guide': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'resource': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['treemap.Resource']", 'null': 'True', 'symmetrical': 'False'}),
            'scientific_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'species': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'symbol': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'tree_count': ('django.db.models.fields.IntegerField', [], {'default': '0', 'db_index': 'True'}),
            'v_max_dbh': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'v_max_height': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'v_multiple_trunks': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'wildlife_value': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'})
        },
        'treemap.stewardship': {
            'Meta': {'ordering': "['performed_date']", 'object_name': 'Stewardship'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'performed_by': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'performed_date': ('django.db.models.fields.DateTimeField', [], {})
        },
        'treemap.supervisordistrict': {
            'Meta': {'object_name': 'SupervisorDistrict'},
            'geometry': ('django.contrib.gis.db.models.fields.MultiPolygonField', [], {}),
            'id': ('django.db.models.fields.IntegerField', [], {'primary_key': 'True'}),
            'supervisor': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'treemap.tree': {
            'Meta': {'object_name': 'Tree'},
            'canopy_condition': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'canopy_height': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'condition': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'date_planted': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date_removed': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'dbh': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'height': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'import_event': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.ImportEvent']"}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'last_updated_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'updated_by'", 'to': "orm['auth.User']"}),
            'orig_species': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'pests': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'photo_count': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'plot': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Plot']"}),
            'present': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'projects': ('django.db.models.fields.CharField', [], {'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'readonly': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            's_order': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'species': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Species']", 'null': 'True', 'blank': 'True'}),
            'species_other1': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'species_other2': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'sponsor': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'steward_name': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'steward_user': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'steward'", 'null': 'True', 'to': "orm['auth.User']"}),
            'tree_owner': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'})
        },
        'treemap.treeaction': {
            'Meta': {'object_name': 'TreeAction'},
            'comment': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'reported': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'reported_by': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"}),
            'value': ('django.db.models.fields.DateTimeField', [], {})
        },
        'treemap.treealert': {
            'Meta': {'object_name': 'TreeAlert'},
            'comment': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'reported': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'reported_by': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'solved': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"}),
            'value': ('django.db.models.fields.DateTimeField', [], {})
        },
        'treemap.treeaudit': {
            'Meta': {'ordering': "['-_audit_timestamp']", 'object_name': 'TreeAudit', 'db_table': "'treemap_tree_audit'"},
            '_audit_change_type': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
            '_audit_diff': ('django.db.models.fields.TextField', [], {}),
            '_audit_id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            '_audit_timestamp': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            '_audit_user_rep': ('django.db.models.fields.IntegerField', [], {}),
            '_audit_verified': ('django.db.models.fields.IntegerField', [], {}),
            'canopy_condition': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'canopy_height': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'condition': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'date_planted': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date_removed': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'dbh': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'height': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True'}),
            'import_event': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'_audit_tree'", 'to': "orm['treemap.ImportEvent']"}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'last_updated_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'_audit_updated_by'", 'to': "orm['auth.User']"}),
            'orig_species': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'pests': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'photo_count': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'plot': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'_audit_tree'", 'to': "orm['treemap.Plot']"}),
            'present': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'projects': ('django.db.models.fields.CharField', [], {'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'readonly': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            's_order': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'species': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'_audit_tree'", 'null': 'True', 'to': "orm['treemap.Species']"}),
            'species_other1': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'species_other2': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'sponsor': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'steward_name': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'steward_user': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'_audit_steward'", 'null': 'True', 'to': "orm['auth.User']"}),
            'tree_owner': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'})
        },
        'treemap.treefavorite': {
            'Meta': {'object_name': 'TreeFavorite'},
            'date_created': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'treemap.treeflags': {
            'Meta': {'object_name': 'TreeFlags'},
            'comment': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'reported': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'reported_by': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"}),
            'value': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        'treemap.treepending': {
            'Meta': {'object_name': 'TreePending', '_ormbases': ['treemap.Pending']},
            'pending_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.Pending']", 'unique': 'True', 'primary_key': 'True'}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"})
        },
        'treemap.treephoto': {
            'Meta': {'object_name': 'TreePhoto'},
            'comment': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'photo': ('sorl.thumbnail.fields.ImageField', [], {'max_length': '100'}),
            'reported': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'reported_by': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"})
        },
        'treemap.treeresource': {
            'Meta': {'object_name': 'TreeResource', '_ormbases': ['treemap.ResourceSummaryModel']},
            'resourcesummarymodel_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.ResourceSummaryModel']", 'unique': 'True'}),
            'tree': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.Tree']", 'unique': 'True', 'primary_key': 'True'})
        },
        'treemap.treestewardship': {
            'Meta': {'ordering': "['performed_date']", 'object_name': 'TreeStewardship', '_ormbases': ['treemap.Stewardship']},
            'activity': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'stewardship_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.Stewardship']", 'unique': 'True', 'primary_key': 'True'}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"})
        },
        'treemap.treewatch': {
            'Meta': {'object_name': 'TreeWatch'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'severity': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"}),
            'valid': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'treemap.zipcode': {
            'Meta': {'object_name': 'ZipCode'},
            'geometry': ('django.contrib.gis.db.models.fields.MultiPolygonField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'zip': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        }
    }

    complete_apps = ['treemap']
########NEW FILE########
__FILENAME__ = 0005_auto__add_climatezone
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'ClimateZone'
        db.create_table('treemap_climatezone', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('itree_region', self.gf('django.db.models.fields.CharField')(max_length=40)),
            ('geometry', self.gf('django.contrib.gis.db.models.fields.MultiPolygonField')()),
        ))
        db.send_create_signal('treemap', ['ClimateZone'])


    def backwards(self, orm):
        # Deleting model 'ClimateZone'
        db.delete_table('treemap_climatezone')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'threadedcomments.threadedcomment': {
            'Meta': {'ordering': "('-date_submitted',)", 'object_name': 'ThreadedComment'},
            'comment': ('django.db.models.fields.TextField', [], {}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'date_approved': ('django.db.models.fields.DateTimeField', [], {'default': 'None', 'null': 'True', 'blank': 'True'}),
            'date_modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'date_submitted': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'ip_address': ('django.db.models.fields.IPAddressField', [], {'max_length': '15', 'null': 'True', 'blank': 'True'}),
            'is_approved': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'markup': ('django.db.models.fields.IntegerField', [], {'default': '5', 'null': 'True', 'blank': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'related_name': "'children'", 'null': 'True', 'blank': 'True', 'to': "orm['threadedcomments.ThreadedComment']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'treemap.aggregateneighborhood': {
            'Meta': {'object_name': 'AggregateNeighborhood', '_ormbases': ['treemap.AggregateSummaryModel']},
            'aggregatesummarymodel_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.AggregateSummaryModel']", 'unique': 'True', 'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'aggregates'", 'unique': 'True', 'to': "orm['treemap.Neighborhood']"})
        },
        'treemap.aggregatesearchresult': {
            'Meta': {'object_name': 'AggregateSearchResult', '_ormbases': ['treemap.AggregateSummaryModel']},
            'aggregatesummarymodel_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.AggregateSummaryModel']", 'unique': 'True', 'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '256'})
        },
        'treemap.aggregatesummarymodel': {
            'Meta': {'object_name': 'AggregateSummaryModel', '_ormbases': ['treemap.ResourceSummaryModel']},
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'resourcesummarymodel_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.ResourceSummaryModel']", 'unique': 'True', 'primary_key': 'True'}),
            'total_plots': ('django.db.models.fields.IntegerField', [], {}),
            'total_trees': ('django.db.models.fields.IntegerField', [], {})
        },
        'treemap.aggregatesupervisordistrict': {
            'Meta': {'object_name': 'AggregateSupervisorDistrict', '_ormbases': ['treemap.AggregateSummaryModel']},
            'aggregatesummarymodel_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.AggregateSummaryModel']", 'unique': 'True', 'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'aggregates'", 'unique': 'True', 'to': "orm['treemap.SupervisorDistrict']"})
        },
        'treemap.aggregatezipcode': {
            'Meta': {'object_name': 'AggregateZipCode', '_ormbases': ['treemap.AggregateSummaryModel']},
            'aggregatesummarymodel_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.AggregateSummaryModel']", 'unique': 'True', 'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'aggregates'", 'unique': 'True', 'to': "orm['treemap.ZipCode']"})
        },
        'treemap.benefitvalues': {
            'Meta': {'object_name': 'BenefitValues'},
            'area': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'bvoc': ('django.db.models.fields.FloatField', [], {}),
            'co2': ('django.db.models.fields.FloatField', [], {}),
            'electricity': ('django.db.models.fields.FloatField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'natural_gas': ('django.db.models.fields.FloatField', [], {}),
            'nox': ('django.db.models.fields.FloatField', [], {}),
            'ozone': ('django.db.models.fields.FloatField', [], {}),
            'pm10': ('django.db.models.fields.FloatField', [], {}),
            'sox': ('django.db.models.fields.FloatField', [], {}),
            'stormwater': ('django.db.models.fields.FloatField', [], {}),
            'voc': ('django.db.models.fields.FloatField', [], {})
        },
        'treemap.climatezone': {
            'Meta': {'object_name': 'ClimateZone'},
            'geometry': ('django.contrib.gis.db.models.fields.MultiPolygonField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'itree_region': ('django.db.models.fields.CharField', [], {'max_length': '40'})
        },
        'treemap.commentflag': {
            'Meta': {'object_name': 'CommentFlag'},
            'comment': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'comment_flags'", 'to': "orm['threadedcomments.ThreadedComment']"}),
            'flagged': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'flagged_date': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'treemap.exclusionmask': {
            'Meta': {'object_name': 'ExclusionMask'},
            'geometry': ('django.contrib.gis.db.models.fields.MultiPolygonField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'type': ('django.db.models.fields.CharField', [], {'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        'treemap.geocodecache': {
            'Meta': {'object_name': 'GeocodeCache'},
            'address_street': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'geocoded_accuracy': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'geocoded_address': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'geocoded_geometry': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'geocoded_lat': ('django.db.models.fields.FloatField', [], {'null': 'True'}),
            'geocoded_lon': ('django.db.models.fields.FloatField', [], {'null': 'True'}),
            'geometry': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'treemap.importevent': {
            'Meta': {'object_name': 'ImportEvent'},
            'file_name': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'import_date': ('django.db.models.fields.DateField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        'treemap.neighborhood': {
            'Meta': {'object_name': 'Neighborhood'},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'county': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'geometry': ('django.contrib.gis.db.models.fields.MultiPolygonField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'region_id': ('django.db.models.fields.IntegerField', [], {}),
            'state': ('django.db.models.fields.CharField', [], {'max_length': '2'})
        },
        'treemap.pending': {
            'Meta': {'object_name': 'Pending'},
            'field': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'status': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'submitted': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'submitted_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pend_submitted_by'", 'to': "orm['auth.User']"}),
            'text_value': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'updated_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pend_updated_by'", 'to': "orm['auth.User']"}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'})
        },
        'treemap.plot': {
            'Meta': {'object_name': 'Plot'},
            'address_city': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'address_street': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'address_zip': ('django.db.models.fields.CharField', [], {'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'data_owner': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'owner'", 'null': 'True', 'to': "orm['auth.User']"}),
            'geocoded_accuracy': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'geocoded_address': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'geocoded_lat': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'geocoded_lon': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'geometry': ('django.contrib.gis.db.models.fields.PointField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'import_event': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.ImportEvent']"}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'last_updated_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'plot_updated_by'", 'to': "orm['auth.User']"}),
            'length': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'neighborhood': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['treemap.Neighborhood']", 'null': 'True', 'symmetrical': 'False'}),
            'neighborhoods': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'owner_additional_id': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'owner_additional_properties': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'owner_orig_id': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'powerline_conflict_potential': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'present': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'readonly': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'sidewalk_damage': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'type': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'width': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'zipcode': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.ZipCode']", 'null': 'True', 'blank': 'True'})
        },
        'treemap.plotaudit': {
            'Meta': {'ordering': "['-_audit_timestamp']", 'object_name': 'PlotAudit', 'db_table': "'treemap_plot_audit'"},
            '_audit_change_type': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
            '_audit_diff': ('django.db.models.fields.TextField', [], {}),
            '_audit_id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            '_audit_timestamp': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            '_audit_user_rep': ('django.db.models.fields.IntegerField', [], {}),
            '_audit_verified': ('django.db.models.fields.IntegerField', [], {}),
            'address_city': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'address_street': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'address_zip': ('django.db.models.fields.CharField', [], {'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'data_owner': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'_audit_owner'", 'null': 'True', 'to': "orm['auth.User']"}),
            'geocoded_accuracy': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'geocoded_address': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'geocoded_lat': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'geocoded_lon': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'geometry': ('django.contrib.gis.db.models.fields.PointField', [], {}),
            'id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True'}),
            'import_event': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'_audit_plot'", 'to': "orm['treemap.ImportEvent']"}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'last_updated_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'_audit_plot_updated_by'", 'to': "orm['auth.User']"}),
            'length': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'neighborhoods': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'owner_additional_id': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'owner_additional_properties': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'owner_orig_id': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'powerline_conflict_potential': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'present': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'readonly': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'sidewalk_damage': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'type': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'width': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'zipcode': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'_audit_plot'", 'null': 'True', 'to': "orm['treemap.ZipCode']"})
        },
        'treemap.plotpending': {
            'Meta': {'object_name': 'PlotPending', '_ormbases': ['treemap.Pending']},
            'geometry': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True', 'blank': 'True'}),
            'pending_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.Pending']", 'unique': 'True', 'primary_key': 'True'}),
            'plot': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Plot']"})
        },
        'treemap.plotstewardship': {
            'Meta': {'ordering': "['performed_date']", 'object_name': 'PlotStewardship', '_ormbases': ['treemap.Stewardship']},
            'activity': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'plot': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Plot']"}),
            'stewardship_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.Stewardship']", 'unique': 'True', 'primary_key': 'True'})
        },
        'treemap.resource': {
            'Meta': {'object_name': 'Resource'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'meta_species': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'region': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'})
        },
        'treemap.resourcesummarymodel': {
            'Meta': {'object_name': 'ResourceSummaryModel'},
            'annual_air_quality_improvement': ('django.db.models.fields.FloatField', [], {}),
            'annual_bvoc': ('django.db.models.fields.FloatField', [], {}),
            'annual_co2_avoided': ('django.db.models.fields.FloatField', [], {}),
            'annual_co2_reduced': ('django.db.models.fields.FloatField', [], {}),
            'annual_co2_sequestered': ('django.db.models.fields.FloatField', [], {}),
            'annual_electricity_conserved': ('django.db.models.fields.FloatField', [], {}),
            'annual_energy_conserved': ('django.db.models.fields.FloatField', [], {}),
            'annual_natural_gas_conserved': ('django.db.models.fields.FloatField', [], {}),
            'annual_nox': ('django.db.models.fields.FloatField', [], {}),
            'annual_ozone': ('django.db.models.fields.FloatField', [], {}),
            'annual_pm10': ('django.db.models.fields.FloatField', [], {}),
            'annual_sox': ('django.db.models.fields.FloatField', [], {}),
            'annual_stormwater_management': ('django.db.models.fields.FloatField', [], {}),
            'annual_voc': ('django.db.models.fields.FloatField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'total_co2_stored': ('django.db.models.fields.FloatField', [], {})
        },
        'treemap.species': {
            'Meta': {'object_name': 'Species'},
            'alternate_symbol': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'bloom_period': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'common_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'cultivar_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'fact_sheet': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'fall_conspicuous': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'family': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'flower_conspicuous': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'fruit_period': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'gender': ('django.db.models.fields.CharField', [], {'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'genus': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'itree_code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'native_status': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'other_part_of_name': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'palatable_human': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'plant_guide': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'resource': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['treemap.Resource']", 'null': 'True', 'symmetrical': 'False'}),
            'scientific_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'species': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'symbol': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'tree_count': ('django.db.models.fields.IntegerField', [], {'default': '0', 'db_index': 'True'}),
            'v_max_dbh': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'v_max_height': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'v_multiple_trunks': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'wildlife_value': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'})
        },
        'treemap.stewardship': {
            'Meta': {'ordering': "['performed_date']", 'object_name': 'Stewardship'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'performed_by': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'performed_date': ('django.db.models.fields.DateTimeField', [], {})
        },
        'treemap.supervisordistrict': {
            'Meta': {'object_name': 'SupervisorDistrict'},
            'geometry': ('django.contrib.gis.db.models.fields.MultiPolygonField', [], {}),
            'id': ('django.db.models.fields.IntegerField', [], {'primary_key': 'True'}),
            'supervisor': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'treemap.tree': {
            'Meta': {'object_name': 'Tree'},
            'canopy_condition': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'canopy_height': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'condition': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'date_planted': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date_removed': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'dbh': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'height': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'import_event': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.ImportEvent']"}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'last_updated_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'updated_by'", 'to': "orm['auth.User']"}),
            'orig_species': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'pests': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'photo_count': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'plot': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Plot']"}),
            'present': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'projects': ('django.db.models.fields.CharField', [], {'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'readonly': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            's_order': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'species': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Species']", 'null': 'True', 'blank': 'True'}),
            'species_other1': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'species_other2': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'sponsor': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'steward_name': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'steward_user': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'steward'", 'null': 'True', 'to': "orm['auth.User']"}),
            'tree_owner': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'})
        },
        'treemap.treeaction': {
            'Meta': {'object_name': 'TreeAction'},
            'comment': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'reported': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'reported_by': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"}),
            'value': ('django.db.models.fields.DateTimeField', [], {})
        },
        'treemap.treealert': {
            'Meta': {'object_name': 'TreeAlert'},
            'comment': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'reported': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'reported_by': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'solved': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"}),
            'value': ('django.db.models.fields.DateTimeField', [], {})
        },
        'treemap.treeaudit': {
            'Meta': {'ordering': "['-_audit_timestamp']", 'object_name': 'TreeAudit', 'db_table': "'treemap_tree_audit'"},
            '_audit_change_type': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
            '_audit_diff': ('django.db.models.fields.TextField', [], {}),
            '_audit_id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            '_audit_timestamp': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            '_audit_user_rep': ('django.db.models.fields.IntegerField', [], {}),
            '_audit_verified': ('django.db.models.fields.IntegerField', [], {}),
            'canopy_condition': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'canopy_height': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'condition': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'date_planted': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date_removed': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'dbh': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'height': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True'}),
            'import_event': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'_audit_tree'", 'to': "orm['treemap.ImportEvent']"}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'last_updated_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'_audit_updated_by'", 'to': "orm['auth.User']"}),
            'orig_species': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'pests': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'photo_count': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'plot': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'_audit_tree'", 'to': "orm['treemap.Plot']"}),
            'present': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'projects': ('django.db.models.fields.CharField', [], {'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'readonly': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            's_order': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'species': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'_audit_tree'", 'null': 'True', 'to': "orm['treemap.Species']"}),
            'species_other1': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'species_other2': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'sponsor': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'steward_name': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'steward_user': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'_audit_steward'", 'null': 'True', 'to': "orm['auth.User']"}),
            'tree_owner': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'})
        },
        'treemap.treefavorite': {
            'Meta': {'object_name': 'TreeFavorite'},
            'date_created': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'treemap.treeflags': {
            'Meta': {'object_name': 'TreeFlags'},
            'comment': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'reported': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'reported_by': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"}),
            'value': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        'treemap.treepending': {
            'Meta': {'object_name': 'TreePending', '_ormbases': ['treemap.Pending']},
            'pending_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.Pending']", 'unique': 'True', 'primary_key': 'True'}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"})
        },
        'treemap.treephoto': {
            'Meta': {'object_name': 'TreePhoto'},
            'comment': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'photo': ('sorl.thumbnail.fields.ImageField', [], {'max_length': '100'}),
            'reported': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'reported_by': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"})
        },
        'treemap.treeresource': {
            'Meta': {'object_name': 'TreeResource', '_ormbases': ['treemap.ResourceSummaryModel']},
            'resourcesummarymodel_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.ResourceSummaryModel']", 'unique': 'True'}),
            'tree': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.Tree']", 'unique': 'True', 'primary_key': 'True'})
        },
        'treemap.treestewardship': {
            'Meta': {'ordering': "['performed_date']", 'object_name': 'TreeStewardship', '_ormbases': ['treemap.Stewardship']},
            'activity': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'stewardship_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['treemap.Stewardship']", 'unique': 'True', 'primary_key': 'True'}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"})
        },
        'treemap.treewatch': {
            'Meta': {'object_name': 'TreeWatch'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'severity': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'tree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['treemap.Tree']"}),
            'valid': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'treemap.zipcode': {
            'Meta': {'object_name': 'ZipCode'},
            'geometry': ('django.contrib.gis.db.models.fields.MultiPolygonField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'zip': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        }
    }

    complete_apps = ['treemap']
########NEW FILE########
__FILENAME__ = models
import os
import math
import re
from decimal import *
from datetime import datetime
from itertools import chain
from operator import itemgetter
from django.conf import settings
from django.contrib.gis.db import models
from django.contrib.gis.db.models import Sum, Q
from django.contrib.gis.measure import D
from django.contrib.auth.models import User, Group
from django.core.exceptions import ValidationError, PermissionDenied
from django.db import transaction

import audit
from classfaves.models import FavoriteBase
import logging
import simplejson
from sorl.thumbnail import ImageField
from threadedcomments.models import ThreadedComment

from treemap.eco_benefits import set_environmental_summaries

status_choices = (
        ('height','Height (in feet)'),
        ('dbh','Diameter (in inches)'),
        ('condition','Condition'),
        ('sidewalk_damage','Sidewalk Damage'),
        ('canopy_height', 'Canopy Height (in feet)'),
        ('canopy_condition', 'Canopy Condition')
    )

choices_choices = (
    ('factoid', 'Factoid'),
    ('plot', 'Plot'),
    ('alert', 'Alert'),
    ('action', 'Action'),
    ('local', 'Local'),
    ('sidewalk_damage', 'Sidewalk Damage'),
    ('condition', 'Condition'),
    ('canopy_condition', 'Canopy Condition')
)
watch_choices = {
    "height_dbh": "Height to DBH Ratio",
    "proximity": "Trees Nearby",
    "canopy_condition": "Canopy-Condition Matching",
    "max_height": "Species Height",
    "max_dbh": "Species DBH",
}
watch_tests = {
    "height_dbh": 'validate_height_dbh',
    "proximity": 'validate_proximity',
    "canopy_condition": 'validate_canopy_condition',
    "max_height": 'validate_max_dbh',
    "max_dbh": 'validate_max_height',
}

data_types = (
    ('text', 'text'),
    ('int', 'int'),
    ('float', 'float'),
    ('bool', 'bool'),
    ('geo', 'geo'),
)

class BenefitValues(models.Model):
    area = models.CharField(max_length=255)
    stormwater = models.FloatField()
    electricity = models.FloatField()
    natural_gas = models.FloatField()
    co2 = models.FloatField()
    ozone = models.FloatField()
    nox = models.FloatField()
    pm10 = models.FloatField()
    sox = models.FloatField()
    voc = models.FloatField()
    bvoc = models.FloatField()

    def __unicode__(self): return u'%s' % (self.area)


class CommentFlag(models.Model):
    flagged = models.BooleanField(default=False)
    flagged_date = models.DateTimeField(auto_now=True)

    comment = models.ForeignKey(ThreadedComment, related_name="comment_flags")
    user = models.ForeignKey(User)

def sorted_nicely(l, key):
    """ Sort the given iterable in the way that humans expect."""
    convert = lambda text: int(text) if text.isdigit() else text
    alphanum_key = lambda item: [ convert(c) for c in re.split('([0-9]+)', key(item)) ]
    return sorted(l, key = alphanum_key)


# GEOGRAPHIES #
class Neighborhood(models.Model):
    """
    Restricts point placement to within these boundaries.
    """
    name = models.CharField(max_length=255)
    region_id = models.IntegerField()
    city = models.CharField(max_length=255)
    county = models.CharField(max_length=255)
    state = models.CharField(max_length=2)
    geometry = models.MultiPolygonField(srid=4326)
    objects=models.GeoManager()

    def __unicode__(self): return u'%s' % self.name


class SupervisorDistrict(models.Model):
    """
    not used currently
    """
    id = models.IntegerField(primary_key=True)
    supervisor = models.CharField(max_length=255)
    geometry = models.MultiPolygonField(srid=4326)
    objects=models.GeoManager()

    def __unicode__(self): return u'%s (%s)' % (self.id, self.supervisor)


class ZipCode(models.Model):
    """
    Display and searching only
    """
    zip = models.CharField(max_length=255)
    geometry = models.MultiPolygonField(srid=4326)
    objects=models.GeoManager()

    def __unicode__(self): return u'%s' % (self.zip)


class ExclusionMask(models.Model):
    """
    Further restrict point placement if settings.MASKING_ON = True
    """
    geometry = models.MultiPolygonField(srid=4326)
    type = models.CharField(max_length=50, blank=True, null=True)
    objects=models.GeoManager()


class Resource(models.Model):
    """
    For use in STRATUM - a Resource can have many species,
    and has different values for each dbh/resource combo.
    """
    meta_species = models.CharField(max_length=150, null=True, blank=True)
    region = models.CharField(max_length=150, null=True, blank=True)

    def __unicode__(self): return u'%s' % (self.meta_species)


class ClimateZone(models.Model):
    itree_region = models.CharField(max_length=40)
    geometry = models.MultiPolygonField(srid=4326)

    objects = models.GeoManager()

class Species(models.Model):
    """
        http://plants.usda.gov/java/AdvancedSearchServlet?pfa=na&statefips=us
        &statefips=usterr&statefips=CAN&grwhabt=Tree&dsp_symbol=on
        &dsp_vernacular=on&dsp_pfa=on&dsp_statefips=on&dsp_grwhabt=on
        &dsp_nativestatuscode=on&dsp_fed_nox_status_ind=on&dsp_state_nox_status=on
        &dsp_invasive_pubs=on&dsp_fed_te_status=on&dsp_state_te_status=on
        &dsp_nat_wet_ind=on&dsp_wet_region=on&dsp_fall_cspc_ind=on
        &dsp_fire_resist_ind=on&dsp_flwr_cspc_ind=on&dsp_bloom_prd_cd=on
        &dsp_frut_seed_abund_cd=on&dsp_frut_seed_start_cd=on&dsp_frut_seed_end_cd=on
        &dsp_frut_body_suit_ind=on&dsp_palat_human_ind=on&Synonyms=all&viewby=sciname
    """
    symbol = models.CharField(max_length=255)
    alternate_symbol = models.CharField(max_length=255, null=True, blank=True)
    itree_code = models.CharField(max_length=255, null=True, blank=True)
    scientific_name = models.CharField(max_length=255)
    genus = models.CharField(max_length=255)
    species = models.CharField(max_length=255, null=True, blank=True) #sometimes we just have genus/cultivar combo
    cultivar_name = models.CharField(max_length=255, null=True, blank=True)
    gender = models.CharField(max_length=50, null=True, blank=True)
    common_name = models.CharField(max_length=255, null=True, blank=True)
    family = models.CharField(max_length=255,null=True,blank=True)
    other_part_of_name = models.CharField(max_length=255,null=True,
                                          blank=True,default='')

    native_status = models.CharField(max_length=255, null=True, blank=True)
    bloom_period = models.CharField(max_length=255, null=True, blank=True)
    fruit_period = models.CharField(max_length=255, null=True, blank=True)
    fall_conspicuous = models.NullBooleanField()
    flower_conspicuous = models.NullBooleanField()
    palatable_human = models.NullBooleanField()
    wildlife_value = models.NullBooleanField()

    fact_sheet = models.URLField(max_length=255, null=True, blank=True)
    plant_guide = models.URLField(max_length=255, null=True, blank=True)

    tree_count = models.IntegerField(default=0, db_index=True)

    v_max_dbh = models.IntegerField(null=True, blank=True)
    v_max_height = models.IntegerField(null=True, blank=True)
    v_multiple_trunks = models.NullBooleanField()

    resource = models.ManyToManyField(Resource, null=True)
    objects = models.GeoManager()

    def get_long_name(self):
        sn = self.scientific_name
        if not sn:
            sn = self.species.genus
        if self.cultivar_name:
            sn += " '%s'" % self.cultivar_name
        if self.other_part_of_name:
            sn += " " + self.other_part_of_name
        return sn


    #tree_count should always be set on tree update..
    def save(self,*args,**kwargs):
        self.tree_count = self.tree_set.filter(present=True).count()
        name = '%s' % self.genus
        if self.species and self.species != '':
            name += " %s" % self.species
        #if self.cultivar_name and self.cultivar_name != '':
        #    name += " %s" % self.cultivar_name
        self.scientific_name = name
        super(Species, self).save(*args,**kwargs)

    def __unicode__(self):
        if self.cultivar_name:
            return u"%s, '%s'" % (self.common_name,self.cultivar_name)
        else:
            return u'%s' % (self.common_name)


class GeocodeCache(models.Model):
    address_street = models.CharField(max_length=256)
    geocoded_address = models.CharField(max_length=256)
    geocoded_lat = models.FloatField(null=True)
    geocoded_lon  = models.FloatField(null=True)
    geocoded_accuracy = models.IntegerField(null=True)
    geocoded_geometry = models.PointField(null=True, srid=4326)
    geometry = models.PointField(null=True, srid=4326)
    objects = models.GeoManager()

class ImportEvent(models.Model):
    file_name = models.CharField(max_length=256)
    import_date = models.DateField(auto_now=True)

class PlotLocateManager(models.GeoManager):

    def with_geometry(self, geom, distance=0, max_plots=1, species_preferenece=None,
                      native=None, flowering=None, fall=None, edible=None, pests=None,
                      dbhmin=None, dbhmax=None, species=None, sort_recent=None,
                      sort_pending=None, has_tree=None, has_species=None, has_dbh=None):
        '''
        Return a QuerySet with trees near a Point geometry or intersecting a Polygon geometry
        '''
        plots = Plot.objects.filter(present=True)

        if geom.geom_type == 'Point':
            plots = plots.filter(geometry__dwithin=(geom, float(distance))).distance(geom).order_by('distance')
        else:
            plots = plots.filter(geometry__intersects=geom)

        if species_preferenece:
            plots_filtered_by_species_preference = plots.filter(tree__species__id=species_preferenece, tree__present=True)
            # If a species_preferenece is specified then any nearby trees with that species_preferenece will be
            # returned. If there are no trees for that species_preferenece, the nearest tree from any
            # species_preferenece will be returned.
            if len(plots_filtered_by_species_preference) > 0:
                plots = plots_filtered_by_species_preference

        if species: # Note that, unlike "preference", these values are forced
            plots = plots.filter(tree__species__pk=species, tree__present=True)

        if native is not None:
            if native:
                native = "True"
            else:
                native = ""

            plots = plots.filter(tree__species__native_status=native, tree__present=True)

        if flowering is not None:
            plots = plots.filter(tree__species__flower_conspicuous=flowering, tree__present=True)

        if fall is not None:
            plots = plots.filter(tree__species__fall_conspicuous=fall, tree__present=True)

        if edible is not None:
            plots = plots.filter(tree__species__palatable_human=edible, tree__present=True)

        if dbhmin is not None:
            plots = plots.filter(tree__dbh__gte=dbhmin, tree__present=True)

        if dbhmax is not None:
            plots = plots.filter(tree__dbh__lte=dbhmax, tree__present=True)

        if pests is not None:
            plots = plots.filter(tree__pests=pests)

        has_filter_q = None
        def filter_or(f,has):
            if has:
                return f | has
            else:
                return f

        if has_tree is not None:
            q_has_tree = Q(tree__present=True)
            if not has_tree:
                q_has_tree = ~q_has_tree

            has_filter_q = filter_or(q_has_tree, has_filter_q)

        if has_species is not None:
            if has_species:
                q_has_species = Q(tree__species__isnull=False,tree__present=True)
            else:
                # Note that Q(tree__present=False) seems to exlucde too
                # many records. Instead ~Q(tree__present=True) selects
                # all plots without tree records and those with trees
                # that are marked as not present
                q_has_species = Q(tree__species__isnull=True,tree__present=True)|(~Q(tree__present=True))

            has_filter_q = filter_or(q_has_species, has_filter_q)

        if has_dbh is not None:
            q_has_dbh = Q(tree__dbh__isnull=(not has_dbh))
            has_filter_q = filter_or(q_has_dbh, has_filter_q)

        if has_filter_q:
            plots = plots.filter(has_filter_q)

        if sort_recent:
            plots = plots.order_by('-last_updated')

        if sort_pending:
            plots_tree_pending = plots.filter(Q(tree__treepending__status='pending'))
            plots_plot_pending = plots.filter(Q(plotpending__status='pending'))

            if max_plots:
                plots = list(plots_tree_pending) + list(plots_plot_pending)
                # Uniquify
                plots_hash = {}
                for p in plots:
                    plots_hash[p.pk] = p

                plots = plots_hash.values()

                plots = sorted(plots, key=lambda z: z.distance)

                plots = plots[:max_plots]

                extent = self.calc_extent(plots)

        else:
            if max_plots:
                plots = plots[:max_plots]

            if plots.count() > 0:
                extent = plots.extent()
            else:
                extent = []

        return plots, extent

    def calc_extent(self, plots):
        if not plots:
            return []

        xs = [plot.geometry.x for plot in plots]
        ys = [plot.geometry.y for plot in plots]

        return (min(xs),min(ys),max(xs),max(ys))

class ManagementMixin(object):
    """
    Methods that relate to checking editabilty, usable in either Tree or Plot models
    """
    def _created_by(self):
        insert_event_set = self.history.filter(_audit_change_type='I')
        if insert_event_set.count() == 0:
            # If there is no audit event with type 'I' then the user who created the model cannot be determined
            return None
        else:
            # The 'auth.change_user' permission is a proxy for 'is the user a manager'
            return insert_event_set[0].last_updated_by
    created_by = property(_created_by)

    def _was_created_by_a_manager(self):
        if self.created_by:
            return self.created_by.has_perm('auth.change_user')
        else:
            # If created_by is None, the author of the instance could not be
            # determined (bulk loaded data, perhaps). In this case we assume, for
            # for safety, that the instance was created by a manager
            return True
    was_created_by_a_manager = property(_was_created_by_a_manager)

class PendingMixin(object):
    """
    Methods that relate to pending edit management for either Tree or Plot models
    """
    def get_active_pends(self):
        raise Exception('PendingMixin expects subclasses to implement get_active_pends')

    def get_active_pend_dictionary(self):
        """
        Create a dictionary of active pends keyed by field name.

        {
          'field1': {
            'latest_value': 4,
            'pends': [
              <Pending>,
              <Pending>
            ]
          },
          'field2': {
            'latest_value': 'oak',
            'pends': [
              <Pending>
            ]
          }
        }
        """
        pends = self.get_active_pends().order_by('-submitted')

        result = {}
        for pend in pends:
            if pend.field in result:
                result[pend.field]['pending_edits'].append(pend)
            else:
                result[pend.field] = {'latest_value': pend.value, 'pending_edits': [pend]}
        return result


class Plot(models.Model, ManagementMixin, PendingMixin):
    present = models.BooleanField(default=True)
    width = models.FloatField(null=True, blank=True, error_messages={'invalid': "Error: This value must be a number."})
    length = models.FloatField(null=True, blank=True, error_messages={'invalid': "Error: This value must be a number."})

    type = models.CharField(max_length=256, null=True, blank=True, choices=settings.CHOICES["plot_types"])
    powerline_conflict_potential = models.CharField(max_length=256, choices=settings.CHOICES["powerlines"],
        help_text = "Are there overhead powerlines present?",null=True, blank=True)
    sidewalk_damage = models.CharField(max_length=256, null=True, blank=True, choices=settings.CHOICES["sidewalks"])

    address_street = models.CharField(max_length=256, blank=True, null=True)
    address_city = models.CharField(max_length=256, blank=True, null=True)
    address_zip = models.CharField(max_length=30,blank=True, null=True)
    neighborhood = models.ManyToManyField(Neighborhood, null=True)
    neighborhoods = models.CharField(max_length=150, null=True, blank=True) # Really this should be 'blank=True' and null=False
    zipcode = models.ForeignKey(ZipCode, null=True, blank=True) # Because it is calculated in the save method

    geocoded_accuracy = models.IntegerField(null=True, blank=True)
    geocoded_address = models.CharField(max_length=256, null=True, blank=True)
    geocoded_lat = models.FloatField(null=True, blank=True)
    geocoded_lon  = models.FloatField(null=True, blank=True)

    geometry = models.PointField(srid=4326)

    #geocoded_geometry = models.PointField(null=True, srid=4326)
    #owner_geometry = models.PointField(null=True, srid=4326) #should we keep this?

    last_updated = models.DateTimeField(auto_now=True)
    last_updated_by = models.ForeignKey(User, related_name='plot_updated_by') # TODO set to current user

    history = audit.AuditTrail()
    import_event = models.ForeignKey(ImportEvent)
    objects = models.GeoManager()
    # The locate Manager encapsulates plot search functionality
    locate = PlotLocateManager()

    #original data to help owners associate back to their own db
    data_owner = models.ForeignKey(User, related_name="owner", null=True, blank=True)
    owner_orig_id = models.CharField(max_length=256, null=True, blank=True)
    owner_additional_id = models.CharField(max_length=255, null=True, blank=True)
    owner_additional_properties = models.TextField(null=True, blank=True, help_text = "Additional Properties (not searchable)")

    readonly = models.BooleanField(default=False)

    def itree_region(self):
        zone = ClimateZone.objects.filter(geometry__contains=self.geometry)

        if len(zone) == 0:
            return None
        else:
            return zone[0].itree_region

    def validate(self):
        self.full_clean()
        em = ExclusionMask.objects.filter(geometry__contains=self.geometry)
        if em.count() > 0:
            raise ValidationError("Geometry may not be within an exclusion zone.")


    def get_plot_type_display(self):
        for key, value in settings.CHOICES["plot_types"]:
            if key == self.type:
                return value
        return None

    def get_plot_size(self):
        length = self.length
        width = self.width
        if length == None: length = 'Missing'
        elif length == 99: length = '15+ ft'
        else: length = '%.2f ft' % length
        if width == None: width = 'Missing'
        elif width == 99: width = '15+ ft'
        else: width = '%.2f ft' % width
        #print length, width
        return '%s x %s' % (length, width)

    def get_sidewalk_damage_display(self):
        for key, value in settings.CHOICES["sidewalks"]:
            if key == self.sidewalk_damage:
                return value
        return None

    def get_powerline_conflict_display(self):
        for key, value in settings.CHOICES["powerlines"]:
            if key == self.powerline_conflict_potential:
                return value
        return None


    def get_stewardship_count(self):
        return len(self.plotstewardship_set.all())

    def current_tree(self):
        trees = self.tree_set.filter(present=True)
        if trees.count() > 0:
            return trees[0]
        else:
            return None

    def get_active_pends(self):
        pends = self.plotpending_set.filter(status='pending')
        return pends

    def get_active_geopends(self):
        pends = self.plotpending_set.filter(status='pending').exclude(geometry=None)
        return pends

    def get_active_pends_with_tree_pends(self):
        plot_pends = self.plotpending_set.filter(status='pending')
        if self.current_tree():
            tree_pends = self.current_tree().get_active_pends()
        else:
            tree_pends = []
        pends = list(chain(plot_pends, tree_pends))
        return pends

    def get_plot_size(self):
        length = self.length
        width = self.width
        if length == None: length = 'Missing'
        elif length == 99: length = '15+ ft'
        else: length = '%.2f ft' % length
        if width == None: width = 'Missing'
        elif width == 99: width = '15+ ft'
        else: width = '%.2f ft' % width
        return '%s x %s' % (length, width)

    def quick_save(self, *args, **kwargs):
        super(Plot, self).save(*args,**kwargs)

    def save(self, *args, **kwargs):
        self.validate()

        pnt = self.geometry

        n = Neighborhood.objects.filter(geometry__contains=pnt)
        z = ZipCode.objects.filter(geometry__contains=pnt)

        if n:
            oldns = self.neighborhoods
            new_nhoods = []
            for nhood in n:
                if nhood:
                    new_nhoods.append(nhood.id.__str__())
            self.neighborhoods = " ".join(new_nhoods)
        else:
            self.neighborhoods = ""
            oldns = None

        if self.id:
            oldn = self.neighborhood.all()
            oldz = self.zipcode
        else:
            oldn = []
            oldz = None

        super(Plot, self).save(*args,**kwargs)
        if n:
            self.neighborhood.clear()
            for nhood in n:
                if nhood:
                    self.neighborhood.add(nhood)
        else:
            self.neighborhood.clear()
        if z: self.zipcode = z[0]
        else: self.zipcode = None

        if self.current_tree():
            set_environmental_summaries(self.current_tree())

        super(Plot, self).save(*args,**kwargs)

        if self.neighborhoods != oldns:
            done = []
            if n:
                for nhood in n:
                    if nhood.id in done: continue
                    if self.current_tree():
                        self.current_tree().update_aggregate(AggregateNeighborhood, nhood)
                    else:
                        self.update_aggregate(AggregateNeighborhood, nhood)
                    done.append(nhood.id)
            if oldn:
                for nhood in oldn:
                    if nhood.id in done: continue
                    if self.current_tree():
                        self.current_tree().update_aggregate(AggregateNeighborhood, nhood)
                    else:
                        self.update_aggregate(AggregateNeighborhood, nhood)
                    done.append(nhood.id)

        if self.current_tree() and z and z[0] != oldz:
            if z: self.current_tree().update_aggregate(AggregateZipCode, z[0])
            if oldz: self.current_tree().update_aggregate(AggregateZipCode, oldz)

    def update_aggregate(self, ag_model, location):
        agg =  ag_model.objects.filter(location=location)
        if agg:
            agg = agg[0]
        else:
            agg = ag_model(location=location)
        #print agg.__dict__
        #summaries = []
        trees = Tree.objects.filter(plot__geometry__within=location.geometry)
        plots = Plot.objects.filter(geometry__within=location.geometry)
        #print trees
        agg.total_trees = trees.count()
        agg.total_plots = plots.count()

        agg.save()

    def validate_proximity(self, return_trees=False, max_count=1):
        if not self.geometry:
            return None
        nearby = Plot.objects.filter(present=True, geometry__distance_lte=(self.geometry, D(ft=10.0)))
        if nearby.count() > max_count:
            if return_trees:
                return nearby
            return (nearby.count()-max_count).__str__() #number greater than max_count allows
        return None

    def remove(self):
        """
        Mark the plot and its associated objects as not present.
        """
        if self.current_tree():
            tree = self.current_tree()
            tree.remove()

        self.present = False
        self.save()

        for audit_trail_record in self.history.all():
            audit_trail_record.present = False
            audit_trail_record.save()

class Tree(models.Model, ManagementMixin, PendingMixin):
    def __init__(self, *args, **kwargs):
        super(Tree, self).__init__(*args, **kwargs)  #save, in order to get ID for the tree
    #owner properties based on wiki/DatabaseQuestions
    plot = models.ForeignKey(Plot)
    tree_owner = models.CharField(max_length=256, null=True, blank=True)
    steward_name = models.CharField(max_length=256, null=True, blank=True) #only modifyable by admin
    steward_user = models.ForeignKey(User, null=True, blank=True, related_name="steward") #only modifyable by admin
    sponsor = models.CharField(max_length=256, null=True, blank=True) #only modifyable by us

    species = models.ForeignKey(Species,verbose_name="Scientific name",null=True, blank=True)
    species_other1 = models.CharField(max_length=255, null=True, blank=True)
    species_other2 = models.CharField(max_length=255, null=True, blank=True)
    orig_species = models.CharField(max_length=256, null=True, blank=True)
    dbh = models.FloatField(null=True, blank=True) #gets auto-set on save
    height = models.FloatField(null=True, blank=True, error_messages={'invalid': "Error: This value must be a number."})
    canopy_height = models.FloatField(null=True, blank=True, error_messages={'invalid': "Error: This value must be a number."})
    date_planted = models.DateField(null=True, blank=True)
    date_removed = models.DateField(null=True, blank=True)
    present = models.BooleanField(default=True)

    last_updated = models.DateTimeField(auto_now=True)
    last_updated_by = models.ForeignKey(User, related_name='updated_by') # TODO set to current user

    s_order = models.IntegerField(null=True, blank=True)
    photo_count = models.IntegerField(null=True, blank=True)

    objects = models.GeoManager()
    history = audit.AuditTrail()
    projects = models.CharField(max_length=20, null=True, blank=True)

    import_event = models.ForeignKey(ImportEvent)

    condition = models.CharField(max_length=256, null=True, blank=True, choices=settings.CHOICES["conditions"])
    canopy_condition = models.CharField(max_length=256, null=True, blank=True, choices=settings.CHOICES["canopy_conditions"])

    readonly = models.BooleanField(default=False)
    url = models.URLField(max_length=255, null=True, blank=True)
    pests = models.CharField(max_length=256, null=True, blank=True, choices=settings.CHOICES["pests"])

    def has_common_attributes(self):
        if self.get_flag_count > 0:
            return True
        if self.species:
            spp = self.species
            if spp.flower_conspicuous or spp.fall_conspicuous or spp.palatable_human or spp.native_status:
                return True
        return False

    def get_absolute_url(self):
        return "/trees/%i/" % self.id


    def get_display(self, choices, val):
        for key, value in settings.CHOICES[choices]:
            if key == val:
                return value
        return None

    def get_condition_display(self):
        return self.get_display("conditions", self.condition)

    def get_canopy_condition_display(self):
        return self.get_display("canopy_condition", self.canopy_condition)

    def get_pests_display(self):
        return self.get_display("pests",self.pests)

    def get_scientific_name(self):
        if self.species:
            sn = self.species.scientific_name
            if not sn:
                sn = self.species.genus
            if self.species.cultivar_name:
                sn += " '%s'" % self.species.cultivar_name
            return sn
        else:
            return 'unavailable'

    def get_common_name(self):
        if self.species:
            return self.species.common_name
        return 'unavailable'

    def get_eco_impact(self):
        tr =  TreeResource.objects.filter(tree=self)
        if tr:
            return "%0.2f" % tr[0].total_benefit()

    def get_action_count(self):
        return len(self.treeaction_set.all())

    def get_alert_count(self):
        return len(self.treealert_set.all())

    def get_flag_count(self):
        return len(self.treeflags_set.all())

    def get_stewardship_count(self):
        return len(self.treestewardship_set.all())

    def get_active_pends(self):
        pends = self.treepending_set.filter(status='pending')
        return pends

    def is_complete(self):
        if self.species >= 0 and self.dbh:
            return True
        else:
            return False

    def set_species(self, species_id, commit=True):
        """
        sets the species, and updates the species tree count
        """
        self.old_species = self.species
        new_species = Species.objects.get(id=species_id)
        self.species = new_species
        if commit:
            self.save()

    def save(self,*args,**kwargs):
        #save new neighborhood/zip connections if needed
        self.photo_count = self.treephoto_set.count()

        self.projects = ""
        for fl in self.treeflags_set.all():
            self.projects = self.projects + " " + fl.key


        super(Tree, self).save(*args,**kwargs)

        self.quick_save(*args, **kwargs)

    def quick_save(self,*args,**kwargs):
        super(Tree, self).save(*args,**kwargs)
        set_environmental_summaries(self)
        #set new species counts
        if hasattr(self,'old_species') and self.old_species:
            self.old_species.save()
        if hasattr(self,'species') and self.species:
            self.species.save()

        self.plot.last_updated = self.last_updated
        self.plot.save()

    def update_aggregate(self, ag_model, location):
        agg =  ag_model.objects.filter(location=location)
        if agg:
            agg = agg[0]
        else:
            agg = ag_model(location=location)
        #print agg.__dict__
        #summaries = []
        trees = Tree.objects.filter(plot__geometry__within=location.geometry)
        plots = Plot.objects.filter(geometry__within=location.geometry)
        #print trees
        agg.total_trees = trees.count()
        agg.total_plots = plots.count()

        trees = trees.exclude( Q(dbh=None) | Q(dbh=0.0) ).exclude(species=None)
        #print agg.total_trees
        #TODO figure out how to summarize diff stratum stuff
        field_names = [x.name for x in ResourceSummaryModel._meta.fields
            if not x.name == 'id']

        if agg.total_trees == 0:
            for f in field_names:
                setattr(agg, f, 0.0)
        else:
        #TODO speed this up
            for f in field_names:
                fn = 'treeresource__' + f
                s = trees.aggregate(Sum(fn))[fn + '__sum'] or 0.0
                setattr(agg,f,s)
        agg.save()


    def percent_complete(self):
        has = 0
        attr = settings.COMPLETE_ARRAY
        for item in attr:
            if hasattr(self,item):
                if getattr(self,item):
                    has +=1
            elif hasattr(self.plot, item):
                if getattr(self.plot, item):
                    has +=1
        return has/float(len(attr))*100

    def validate_all(self):
        #print watch_tests
        for test, method in watch_tests.iteritems():
            #print test
            result = getattr(self, method)()
            #print result

            # check for results and save - passed tests return None
            if not result:
                TreeWatch.objects.filter(tree=self, key=watch_choices[test]).delete()
                continue
            # if identical watch already exists skip it
            if TreeWatch.objects.filter(tree=self, key=watch_choices[test], value=result):
                continue

            TreeWatch.objects.filter(tree=self, key=watch_choices[test]).delete()
            self.treewatch_set.create(
                key=watch_choices[test],
                value=result,
            )

    def validate_proximity(self, return_trees=False, max_count=1):
        if not self.plot.geometry:
            return None
        return self.plot.validate_proximity()


    # Disallowed combinations:
    #   Dead + 0% loss, Dead + 25% loss, Dead + 50% loss, Dead + 75% loss
    #   Excellent + 100% loss, Excellent + 75% loss
    def validate_canopy_condition(self):
        if not self.canopy_condition or not self.condition:
            return None

        cond = self.condition
        c_cond = self.canopy_condition
        if cond == 'Dead':
            if not c_cond == 'Little or None (up to 100% missing)' and not c_cond == 'None' :
                return cond + ", " + c_cond

        elif cond == 'Excellent':
            if c_cond == 'Little or None (up to 100% missing)' or c_cond == 'Large Gaps (up to 75% missing)':
                return cond + ", " + c_cond

        return None

    # discussions: http://www.nativetreesociety.org/measure/tdi/diameter_height_ratio.htm
    def validate_height_dbh(self):
        if not self.height or not self.dbh:
            return None
        getcontext().prec = 3
        cbh = self.dbh * math.pi
        cbh_feet = cbh * .75 / 9
        float_ratio = self.height / cbh_feet
        hd_ratio = Decimal(float_ratio.__str__())
        #print hd_ratio
        if hd_ratio < 100:
            return None
        return round(hd_ratio, 2).__str__()

    def validate_max_dbh(self):
        if not self.dbh or not self.species or not self.species.v_max_dbh:
            return None
        if self.dbh > self.species.v_max_dbh:
            return "%s (species max: %s )" % (str(self.dbh), str(self.species.v_max_dbh))
        return None

    def validate_max_height(self):
        if not self.height or not self.species or not self.species.v_max_height:
            return None
        if self.height > self.species.v_max_height:
            return "%s (species max: %s)" % (str(self.height), str(self.species.v_max_height))
        return None

    def remove(self):
        """
        Mark the tree and its associated objects as not present.
        """
        self.present = False
        self.save()
        for audit_trail_record in self.history.all():
            audit_trail_record.present = False
            audit_trail_record.save()

    def __unicode__(self):
        if self.species:
            return u'%s, %s, %s' % (self.species.common_name or '', self.species.scientific_name, self.plot.geocoded_address)
        else:
            return self.plot.geocoded_address

status_types = (
    ('pending', 'Pending'),
    ('approved', 'Approved'),
    ('rejected', 'Rejected')
)

class Pending(models.Model):
    field = models.CharField(max_length=255)
    value = models.CharField(max_length=255, blank=True, null=True)
    text_value = models.CharField(max_length=255, blank=True, null=True)
    submitted = models.DateTimeField(auto_now_add=True)
    submitted_by = models.ForeignKey(User, related_name="pend_submitted_by")
    status = models.CharField(max_length=10, choices=status_types)
    updated = models.DateTimeField(auto_now=True)
    updated_by = models.ForeignKey(User, related_name="pend_updated_by")

    # These properties make 'django sorting' work
    # they really shouldn't be needed...?
    @property
    def species(self):
        if self.tree:
            return self.tree.species
        else:
            return None

    @property
    def address_street(self):
        if self.tree:
            return self.tree.address_street
        else:
            return None

    def set_create_attributes(self, user, field_name, field_value):
        self.field = field_name
        self.value = field_value
        self.submitted_by = user
        self.status = 'pending'
        self.updated_by = user

        if  field_name in settings.CHOICES:
            for choice_key, choice_value in settings.CHOICES[field_name]:
                if str(choice_key) == str(field_value):
                    self.text_value = choice_value
                    break

    def approve(self, updating_user):
        if self.status != 'pending':
            raise ValidationError('The Pending instance is not in the "pending" status and cannot be approved.')
        self.updated_by = updating_user
        self.status = 'approved'
        self.save()

    def reject(self, updating_user):
        if self.status != 'pending':
            raise ValidationError('The Pending instance is not in the "pending" status and cannot be rejected.')
        self.status = 'rejected'
        self.updated_by = updating_user
        self.save()

class TreePending(Pending):
    tree = models.ForeignKey(Tree)

    def _approve(self, updating_user):
        super(TreePending, self).approve(updating_user)
        update = {}
        update['old_' + self.field] = getattr(self.tree, self.field).__str__()
        update[self.field] = self.value.__str__()

        setattr(self.tree, self.field, self.value)
        self.tree.last_updated_by = self.submitted_by
        self.tree._audit_diff = simplejson.dumps(update)
        self.tree.save()

    def set_create_attributes(self, user, field_name, field_value):
        super(TreePending, self).set_create_attributes(user, field_name, field_value)
        if field_name == 'species_id':
            self.text_value = Species.objects.get(id=field_value).scientific_name

    @transaction.commit_on_success
    def approve_and_reject_other_active_pends_for_the_same_field(self, updating_user):
        self._approve(updating_user)
        for active_pend in self.tree.get_active_pends():
            if active_pend != self and active_pend.field == self.field:
                active_pend.reject(updating_user)

class PlotPending(Pending):
    plot = models.ForeignKey(Plot)

    geometry = models.PointField(srid=4326, blank=True, null=True)
    objects = models.GeoManager()

    @property
    def tree(self):
        return self.plot.current_tree()

    def _approve(self, updating_user):
        super(PlotPending, self).approve(updating_user)
        update = {}
        if self.geometry:
            update['old_geometry'] = simplejson.loads(self.plot.geometry.geojson)
            update['geometry'] = simplejson.loads(self.geometry.geojson)
            self.plot.geometry = self.geometry
        else:
            update['old_' + self.field] = getattr(self.plot, self.field).__str__()
            update[self.field] = self.value.__str__()
            setattr(self.plot, self.field, self.value)

        self.plot.last_updated_by = self.submitted_by
        self.plot._audit_diff = simplejson.dumps(update)
        self.plot.save()

    def set_create_attributes(self, user, field_name, field_value):
        super(PlotPending, self).set_create_attributes(user, field_name, field_value)
        if field_name == 'geometry':
            self.geometry = field_value
        else:
            # Omit the geometry so that PlotPending.approve will use the text value
            self.geometry = None

    @transaction.commit_on_success
    def approve_and_reject_other_active_pends_for_the_same_field(self, updating_user):
        self._approve(updating_user)
        for active_pend in self.plot.get_active_pends():
            if active_pend != self and active_pend.field == self.field:
                active_pend.reject(updating_user)

class TreeWatch(models.Model):
    key = models.CharField(max_length=255, choices=watch_choices.iteritems())
    value = models.CharField(max_length=255)
    tree = models.ForeignKey(Tree)
    severity = models.IntegerField(default=0)
    valid = models.BooleanField(default=False)

class TreeFavorite(FavoriteBase):
    tree = models.ForeignKey(Tree)

class Stewardship(models.Model):
    performed_by = models.ForeignKey(User)
    performed_date = models.DateTimeField()

    @classmethod
    def thing_with_activities(clazz, actions, idfld):
        count = len(actions)
        actions = ",".join(["'%s'" % z for z in actions])

        from django.db import connection, transaction
        cursor = connection.cursor()

        cursor.execute(
            """
            SELECT %(tree_or_plot)s_id
            FROM treemap_%(tree_or_plot)sstewardship
            WHERE activity in ( %(activities)s )
            GROUP BY %(tree_or_plot)s_id
            HAVING COUNT(DISTINCT activity) = %(count)d
            """ % {
                "tree_or_plot": idfld,
                "activities": actions,
                "count": count
            })

        return [k[0] for k in cursor.fetchall()]

    @classmethod
    def trees_with_activities(clazz, actions):
        return Stewardship.thing_with_activities(actions, "tree")

    @classmethod
    def plots_with_activities(clazz, actions):
        return Stewardship.thing_with_activities(actions, "plot")

    class Meta:
        ordering = ["performed_date"]

class TreeStewardship(Stewardship):
    activity = models.CharField(max_length=256, null=True, blank=True, choices=settings.CHOICES["tree_stewardship"])
    tree = models.ForeignKey(Tree)

    def get_activity(self):
        for key, value in settings.CHOICES["tree_stewardship"]:
            if key == self.activity:
                return value
        return None

class PlotStewardship(Stewardship):
    activity = models.CharField(max_length=256, null=True, blank=True, choices=settings.CHOICES["plot_stewardship"])
    plot = models.ForeignKey(Plot)

    def get_activity(self):
        for key, value in settings.CHOICES["plot_stewardship"]:
            if key == self.activity:
                return value
        return None

class TreeItem(models.Model):
    """
    generic model for TreeAlert, TreeAction, and TreeStatus.  Classes
    inheriting from here should have a "key" charField with a set of choices
    and a 'value' field which might be a Float (boolean would be 0.0 or 1.0) or a DateTime, depending
    """
    reported = models.DateTimeField(auto_now=True)
    reported_by = models.ForeignKey(User)
    tree = models.ForeignKey(Tree)
    comment = models.TextField(blank=True)

    class Meta:
        abstract=True

    def validate_all(self):
        if self.tree:
            return self.tree.validate_all()

    def __unicode__(self):
        return u'%s, %s, %s' % (self.reported, self.tree, self.key)

def get_parent_id(instance):
    return instance.key

class TreeFlags(TreeItem):
    key = models.CharField(max_length=256, choices=settings.CHOICES["projects"])
    value = models.DateTimeField(auto_now=True)


class TreePhoto(TreeItem):
    def get_photo_path(instance, filename):
        test_path = os.path.join(settings.SITE_ROOT, settings.MEDIA_ROOT, 'photos', str(instance.tree_id), filename)
        extra = 1
        while os.path.exists(test_path):
           extra += 1
           test_path = os.path.join(settings.SITE_ROOT, settings.MEDIA_ROOT, 'photos', str(instance.tree_id), str(extra) + '_' + filename)
        path = os.path.join('photos', str(instance.tree_id), str(extra) + '_' + filename)
        return path

    title = models.CharField(max_length=256,null=True,blank=True)
    photo = ImageField(upload_to=get_photo_path)


    def save(self,*args,**kwargs):
        super(TreeItem, self).save(*args,**kwargs)
        self.tree._audit_diff = '{"new photo": "' + self.title + '"}'
        self.tree.save()

    def __unicode__(self):
        return u'%s, %s, %s' % (self.reported, self.tree, self.title)


class TreeAlert(TreeItem):
    """
    status of attributes that we want to track changes over time.
    sidwalk damage might be scale of 0 thru 5, where dbh or height might be an arbitrary float
    """
    key = models.CharField(max_length=256, choices=settings.CHOICES["alerts"])
    value = models.DateTimeField()
    solved = models.BooleanField(default=False)

#Should be removed in favor of stewardship activities
class TreeAction(TreeItem):
    key = models.CharField(max_length=256, choices=settings.CHOICES["actions"])
    value = models.DateTimeField()

class ResourceSummaryModel(models.Model):
    annual_stormwater_management = models.FloatField(help_text="gallons")
    annual_electricity_conserved = models.FloatField(help_text="kWh")
    annual_energy_conserved = models.FloatField(help_text="kWh")
    annual_natural_gas_conserved = models.FloatField(help_text="kWh")
    annual_air_quality_improvement = models.FloatField(help_text="lbs")
    annual_co2_sequestered = models.FloatField(help_text="lbs")
    annual_co2_avoided = models.FloatField(help_text="lbs")
    annual_co2_reduced = models.FloatField(help_text="lbs")
    total_co2_stored = models.FloatField(help_text="lbs")
    annual_ozone = models.FloatField(help_text="lbs")
    annual_nox = models.FloatField(help_text="lbs")
    annual_pm10 = models.FloatField(help_text="lbs")
    annual_sox = models.FloatField(help_text="lbs")
    annual_voc = models.FloatField(help_text="lbs")
    annual_bvoc = models.FloatField(help_text="lbs")


    def benefits(self):
        d = {}
        b = BenefitValues.objects.all()[0]
        d['water'] = (self.annual_stormwater_management * b.stormwater)

        d['energy'] = (self.annual_energy_conserved * b.electricity)

        d['air_quality'] = abs((self.annual_ozone * b.ozone) \
                            + (self.annual_nox * b.nox) \
                            + (self.annual_pm10 * b.pm10) \
                            + (self.annual_sox * b.sox) \
                            + (self.annual_voc * b.voc) \
                            + (self.annual_bvoc * b.bvoc)
                            )

        d['natural_gas'] = self.annual_natural_gas_conserved * b.natural_gas
        d['co2_reduced'] = (self.annual_co2_sequestered * b.co2) + (self.annual_co2_avoided * b.co2)
        d['co2_stored'] = self.total_co2_stored * b.co2
        d['greenhouse'] = (self.annual_co2_sequestered + self.annual_co2_avoided) * b.co2

        return d

    def total_benefit(self):
        b = self.benefits()
        return b['water'] + b['energy'] + b['air_quality'] + b['greenhouse']

    def get_benefits(self):
        benefits = self.benefits()
        benefits['total'] = self.total_benefit()
        return benefits


class TreeResource(ResourceSummaryModel):
    """
    resource results for a specific tree.  should get updated whenever a tree does.
    """
    tree = models.OneToOneField(Tree, primary_key=True)
    def __unicode__(self): return u'%s' % (self.tree)


class AggregateSummaryModel(ResourceSummaryModel):
    last_updated = models.DateTimeField(auto_now=True)
    total_trees = models.IntegerField()
    total_plots = models.IntegerField()
    #distinct_species = models.IntegerField()

    def ensure_recent(self, current_tree_count = 0):
      if current_tree_count == self.total_trees and (datetime.now() - self.last_updated).seconds < 7200:
          return True

      self.delete()
      return False

# to cache large searches via GET params
class AggregateSearchResult(AggregateSummaryModel):
    key = models.CharField(max_length=256,unique=True)

class AggregateNeighborhood(AggregateSummaryModel):
    location = models.OneToOneField(Neighborhood, related_name='aggregates')

class AggregateSupervisorDistrict(AggregateSummaryModel):
    location = models.OneToOneField(SupervisorDistrict, related_name='aggregates')

class AggregateZipCode(AggregateSummaryModel):
    location = models.OneToOneField(ZipCode, related_name='aggregates')

#import meta_badges

########NEW FILE########
__FILENAME__ = search
from models import *
from django.contrib.gis.geos import Point

class Search (object):
    def __init__(self, trees, plots, tile_query, geog_obj, aggr_obj):
        self.trees = trees
        self.plots = plots
        self.tile_query = tile_query
        self.geog_obj = geog_obj
        self.aggr_obj = aggr_obj

def apply_location_filter(request, search):
    geog_obj = None
    if 'location' in request:
        loc = request['location']
        z = ZipCode.objects.filter(zip=loc)
        if z.count():
            search.trees = search.trees.filter(plot__zipcode = z[0])
            search.plots = search.plots.filter(zipcode = z[0])
            search.geog_obj = z[0]
            search.tile_query.append("zipcode_id = %d" % z[0].id)
    elif 'distance' in request:
        # geographic search handled in the plot_location_search function
        pass
    else:
        if 'geoName' in request or \
           'hood' in request or \
           'lat' in request:

            ns = Neighborhood.objects.all().order_by('id')
            hood = None

            if 'geoName' in request:
                ns = ns.filter(name=request['geoName'])
            elif 'hood' in request:
                ns = ns.filter(name__icontains=request['hood'])
            elif 'lat' in request and 'lon' in request:
                pnt = Point(float(request['lon']), float(request['lat']))
                ns = ns.filter(geometry__contains=pnt)

            try:
                hood = ns[0]
            except IndexError, e: # In case our location isn't on the map
                return search

            search.trees = search.trees.filter(plot__neighborhood = hood)
            search.plots = search.plots.filter(neighborhood = hood)
            search.geog_obj = hood
            search.tile_query.append(
                "(neighborhoods = '%(id)d' OR "
                "neighborhoods LIKE '%% %(id)d' OR "
                "neighborhoods LIKE '%(id)d %%')" % { "id": hood.id })

    return search


def apply_plot_size_filter(request, search):
    """ This filter supports both a "missing" and "actual" value """
    if 'missing_plot_size' in request:
        search.trees = search.trees.filter(Q(plot__length__isnull=True) |
                                           Q(plot__width__isnull=True))

        search.plots = search.plots.filter(Q(length__isnull=True) |
                                           Q(width__isnull=True))

        search.tile_query.append(
            "(plot_length IS NULL OR plot_width IS NULL)")

    elif 'plot_range' in request:
        sizemin, sizemax = [float(z) for z in request['plot_range'].split("-")]

        search.trees = search.trees.filter(
            Q(plot__length__gte=sizemin) | Q(plot__width__gte=sizemin))

        search.plots = search.plots.filter(
            Q(length__gte=sizemin) | Q(width__gte=sizemin))

        # TODO: Hardcoded in UI, may need to change
        # (From original, should be <= 15?)
        if sizemax != 15:
            search.trees = search.trees.filter(
                Q(plot__length__lte=sizemax) | Q(plot__width__lte=sizemax))

            search.plots = search.plots.filter(
                Q(length__lte=sizemax) | Q(width__lte=sizemax))

        search.tile_query.append(
            "( (plot_length BETWEEN %(min)d AND %(max)d ) OR "
            "  (plot_width  BETWEEN %(min)d AND %(max)d ) )" \
            % { "min": sizemin, "max": sizemax })

    return search

def apply_stewardship_filter(request, search):
    stewardship_reverse = request.get('stewardship_reverse',False) == "true"

    if 'stewardship_range' in request:
        (start_date, end_date) = [datetime.utcfromtimestamp(float(z))
                                  for z in request['stewardship_range'].split('-')]

    def tile_query_for_stewardship_actions(actions, tree_or_plot):
        tq = []
        for a in actions:
            if stewardship_reverse:
                tq.append(
                    "%s_stewardship_%s IS NOT NULL" % (tree_or_plot,a))
            else:
                tq.append(
                    "%s_stewardship_%s IS NOT NULL" % (tree_or_plot,a))

                if start_date and end_date:
                    tq.append(
                        "%(tree)s_stewardship_%(action)s AFTER %(start)sZ AND "
                        "%(tree)s_stewardship_%(action)s BEFORE %(end)sZ" %
                        { "action": a,
                          "start": start_date.isoformat(),
                          "end": end_date.isoformat(),
                          "tree": tree_or_plot })
        return tq

    if 'tree_stewardship' in request:
        tree_stewardship = request['tree_stewardship']
        actions = tree_stewardship.split(',')

        steward_ids = Stewardship.trees_with_activities(actions)
        search.tile_query += tile_query_for_stewardship_actions(actions, "tree")

        if stewardship_reverse:
            search.trees = search.trees.filter(id__in=steward_ids)
        else:
            search.trees = search.trees.exclude(id__in=steward_ids)

        if start_date and end_date:
            search.trees = search.trees.exclude(
                treestewardship__performed_date__lte=start_date,
                treestewardship__performed_date__gte=end_date)

        # Also not clear why this goes here...
        # reset plots search?
        search.plots = Plot.objects.filter(present=True).filter(tree__in=search.trees)

    if 'plot_stewardship' in request:
        plot_stewardship = request["plot_stewardship"]
        actions = plot_stewardship.split(',')

        steward_ids = Stewardship.plots_with_activities(actions)
        search.tile_query += tile_query_for_stewardship_actions(actions, "plot")

        if stewardship_reverse:
            search.plots = search.plots.filter(id__in=steward_ids)
        else:
            search.plots = search.plots.exclude(id__in=steward_ids)

        if start_date and end_date:
            search.plots = search.plots.exclude(
                plotstewardship__performed_date__lte=start_date,
                plotstewardship__performed_date__gte=end_date)

        # Not sure why this goes in under the plot_stewardship
        # if block....
        search.trees = Tree.objects.filter(present=True).filter(plot__in=search.plots)

    return search

def apply_missing_plot_filter(fld, search, cqlfld=None, cql=None):
    return apply_missing_filter(fld, False, search, cqlfld=cqlfld, cql=cql)

def apply_missing_tree_filter(fld, search, cqlfld=None, cql=None):
    return apply_missing_filter(fld, True, search, cqlfld=cqlfld, cql=cql)

def apply_missing_filter(fld, istree, search, cqlfld=None, cql=None):
    if istree:
        treefld = "%s__isnull" % fld
        plotfld = "tree__%s__isnull" % fld
    else:
        plotfld = "%s__isnull" % fld
        treefld = "plot__%s__isnull" % fld

    if not cqlfld:
        cqlfld = fld

    kwtree = { treefld: True }
    kwplot = { plotfld: True }

    search.trees = search.trees.filter(**kwtree)
    search.plots = search.plots.filter(**kwplot)

    if cql:
        search.tile_query.append(cql)
    else:
        search.tile_query.append("%s IS NULL" % cqlfld)

    return search

def extract_choices(request, key):
    selected = []
    for k, v in settings.CHOICES[key]:
        if v.lower().replace(' ', '_').replace('/','') in request:
            selected.append((k,v))

    return selected

def apply_plot_type_filter(request, search):
    if request.get('missing_plot_type', False):
        search = apply_missing_plot_filter("type", search, cqlfld="plot_type")
    else:
        ids = [k for (k,v) in extract_choices(request, 'plot_types')]
        cqltypes = ["plot_type = %s" % t for t in ids]

        if ids:
            search.trees = search.trees.filter(plot__type__in=ids)
            search.plots = search.plots.filter(type__in=ids)
            search.tile_query.append(
                "( %s )" % " OR ".join(cqltypes))

    return search

def apply_sidewalk_damage_filter(request, search):
    if request.get("missing_sidewalk", False):
        search = apply_missing_plot_filter(
            "sidewalk_damage", search, cql="sidewalk_damage")
    else:
        ids = [k for (k,v) in extract_choices(request, 'sidewalks')]
        cqltypes = ["sidewalk_damage = %s" % t for t in ids]

        if ids:
            search.trees = search.trees.filter(plot__sidewalk_damage__in=ids)
            search.plots = search.plots.filter(sidewalk_damage__in=ids)
            search.tile_query.append(
                "( %s )" % " OR ".join(cqltypes))

    return search

def apply_pests_filter(request, search):
    pests = [k.split("_")[1] for (k,v) in request.items() if "pests_" in k and v]
    if pests:
        pests_cql = ["pests = %s" % k for k in pests]

        search.trees = search.trees.filter(pests__in=pests)
        search.plots = search.plots.filter(tree__pests__in=pests)

        search.tile_query.append(
            "( %s )" % " OR ".join(pests_cql))

    return search

def apply_powerlines_filter(request, search):
    if request.get('missing_powerlines', False):
        search = apply_missing_plot_filter(
            "powerline_conflict_potential", search)
    else:
        ids = [k for (k,v) in extract_choices(request, 'powerlines')]
        cqltypes = ["powerline_conflict_potential = %s" % t for t in ids]

        if ids:
            search.trees = search.trees.filter(
                plot__powerline_conflict_potential__in=ids)

            search.plots = search.plots.filter(
                powerline_conflict_potential__in=ids)

            search.tile_query.append(
                "( %s )" % " OR ".join(cqltypes))

    return search


def apply_owner_filter(request, search):
    if 'owner' in request:
        owner = request['owner']
        users = User.objects.filter(username__icontains=owner)

        search.trees = search.trees.filter(plot__data_owner__in=users)
        search.plots = search.plots.filter(data_owner__in=users)

        cql_users = ['data_owner_id = %s' % u.id for u in users]

        search.tile_query.append(
            "( %s )" % " OR ".join(cql_users))

    return search

def apply_updated_by_filter(request, search):
    if 'updated_by' in request:
        updated_by = request['updated_by']
        users = User.objects.filter(username__icontains=updated_by)

        search.trees = search.trees.filter(last_updated_by__in=users)
        search.plots = search.plots.filter(last_updated_by__in=users)

        cql_users = ['last_updated_by_id = %d' % u.id for u in users]

        search.tile_query.append(
            "( %s )" % " OR ".join(cql_users))

    return search

def apply_updated_range_filter(request, search):
    if 'updated_range' in request:
        mindate, maxdate = [datetime.utcfromtimestamp(float(z))
                            for z in request['updated_range'].split("-")]

        search.trees = search.trees.filter(last_updated__gte=mindate,
                             last_updated__lte=maxdate)

        search.plots = search.plots.filter(last_updated__gte=mindate,
                             last_updated__lte=maxdate)

        search.tile_query.append(
            "last_updated AFTER %sZ AND "
            "last_updated BEFORE %sZ" %
            (mindate.isoformat(), maxdate.isoformat()))

    return search

def apply_projects_filter(request, search):
    pids = [k for (k,v) in extract_choices(request, 'projects')]
    cql_projects = ["projects LIKE '%%%s%%'" % p for p in pids]

    if pids:
        search.trees = search.trees.filter(treeflags__key__in=pids)
        search.plots = search.plots.filter(tree__treeflags__key__in=pids)

        search.tile_query.append(
            "( %s )" % " OR ".join(cql_projects))

    return search

def apply_missing_species_filter(request, search):
    if request.get('missing_species',False):
        search = apply_missing_tree_filter("species",search,cqlfld="species_id")

    return search

def apply_dbh_filter(request, search):
    if request.get('missing_diameter', False):
        search.trees = search.trees.filter(Q(dbh__isnull=True) | Q(dbh=0))
        search.plots = search.plots.filter(Q(tree__dbh__isnull=True) | Q(tree__dbh=0))

        search.tile_query.append("(dbh IS NULL OR dbh = 0)")

    elif 'diameter_range' in request:
        dmin, dmax = [float(d) for d in request['diameter_range'].split('-')]

        search.trees = search.trees.filter(dbh__gte=dmin)
        search.plots = search.plots.filter(tree__dbh__gte=dmin)
        # TODO: Hardcoded in UI, shouldn't be
        # ^^^^ previous comment, not too sure what this
        # means and why it is different than
        # the tile_query thing below (should it be < 50?)
        if dmax != 50:
            search.trees = search.trees.filter(dbh__lte=dmax)
            search.plots = search.plots.filter(tree__dbh__lte=dmax)

        search.tile_query.append(
            "dbh BETWEEN %d AND %d" % (dmin,dmax))

    return search

def apply_tree_height_filter(request, search):
    if request.get('missing_height', False):
        search.trees = search.trees.filter(
            Q(height__isnull=True) |
            Q(height=0))

        search.plots = search.plots.filter(
            Q(tree__height__isnull=True) |
            Q(tree__height=0))

        search.tile_query.append("(height IS NULL OR height = 0)")

    elif 'height_range' in request:
        hmin, hmax = [float(z) for z in request['height_range'].split('-')]

        search.trees = search.trees.filter(height__gte=hmin)
        search.plots = search.plots.filter(tree__height__gte=hmin)

        # TODO: Hardcoded in UI, may need to change
        # Same old same old....
        if max != 200:
            search.trees = search.trees.filter(height__lte=hmax)
            search.plots = search.plots.filter(tree__height__lte=hmax)

        search.tile_query.append(
            "(height BETWEEN %d AND %d)" % (hmin, hmax))

    return search


def apply_tree_condition_filter(request, search):
    if request.get("missing_condition", False):
        search = apply_missing_tree_filter('condition', search)
    else:
        ids = [k for (k,v) in extract_choices(request, 'conditions')]
        cqls = ["condition = %s" % i for i in ids]

        if ids:
            search.trees = search.trees.filter(condition__in=ids)
            search.plots = search.plots.filter(tree__condition__in=ids)

            search.tile_query.append(
                "( %s )" % " OR ".join(cqls))

    return search

def apply_canopy_condition_filter(request, search):
    if request.get("missing_canopy_condition", False):
        search = apply_missing_tree_filter("canopy_condition", search)
    else:
        ids = []
        # This is the new (preferred?) style of using
        # a_n where {a} is a choices key and {n} is the id
        # so: canopy_conditions_5 or pests_9
        for k, v in settings.CHOICES["canopy_conditions"]:
            if ("canopy_%s" % k) in request:
                ids.append(k)


        cqls = ["canopy_condition = '%s'" % d for d in ids]

        if ids:
            search.trees = search.trees.filter(canopy_condition__in=ids)
            search.plots = search.plots.filter(tree__canopy_condition__in=ids)

            search.tile_query.append(
                "( %s )" % " OR ".join(cqls))

    return search

def apply_tree_owner_filter(request, search):
    if request.get("tree_owner", False):
        tree_owner = request["tree_owner"]

        search.trees = search.trees.filter(
            tree_owner__icontains=tree_owner)

        search.plots = search.plots.filter(
            tree__tree_owner__icontains=tree_owner)

        search.tile_query.append(
            "tree_owner LIKE '%%%s%%'" % tree_owner)

    return search

def apply_photos_filter(request, search):
    if request.get("missing_photos", False):
        search = apply_missing_tree_filter(
            "treephoto", search,
            cql="(photo_count IS NULL OR photo_count = 0)")

    elif 'photos' in request:
        search.trees = search.trees.filter(treephoto__isnull=False)
        search.plots = search.plots.filter(tree__treephoto__isnull=False)
        search.tile_query.append("photo_count > 0")

    return search

def apply_steward_filter(request, search):
    if 'steward' in request:
        steward = request['steward']
        users = User.objects.filter(username__icontains=steward)

        search.trees = search.trees.filter(
            Q(steward_user__in=users) |
            Q(steward_name__icontains=steward))

        search.plots = search.plots.filter(
            Q(tree__steward_user__in=users) |
            Q(tree__steward_name__icontains=steward))

        cqls = ["steward_user_id = %d" % u.id for u in users]
        cql = " OR ".join(cqls)

        search.tile_query.append(
            "( %s OR steward_name LIKE '%%%s%%' )" %
            (cql, steward))

    return search

def apply_funding_filter(request, search):
    if 'funding' in request:
        funding = request['funding']

        search.trees = search.trees.filter(
            sponsor__icontains=funding)

        search.plots = search.plots.filter(
            tree__sponsor__icontains=funding)

        search.tile_query.append(
            "sponsor LIKE '%%%s%%'" % funding)

    return search

def apply_planted_range_filter(request, search):
    if 'planted_range' in request:
        mind, maxd = [int(z) for z in request['planted_range'].split('-')]

        # Because this isn't sketchy at all
        mind = "%d-01-01" % mind
        maxd = "%d-12-31" % maxd

        search.trees = search.trees.filter(
            date_planted__gte=mind,
            date_planted__lte=maxd)

        search.plots = search.plots.filter(
            tree__date_planted__gte=mind,
            tree__date_planted__lte=maxd)

        search.tile_query.append(
            "date_planted AFTER %sT00:00:00Z AND "
            "date_planted BEFORE %sT00:00:00Z" %
            (mind, maxd))

    return search

def apply_species_filters(request, search):
    species = Species.objects.filter(tree_count__gt=0)

    species_criteria = {'native' : 'native_status',
                        'edible' : 'palatable_human',
                        'color' : 'fall_conspicuous',
                        'flowering' : 'flower_conspicuous',
                        'wildlife' : 'wildlife_value'}

    found_species = False

    # Wouldn't want to make these the same...?
    # These handle the boolean fields
    for (requestparam, dbname) in species_criteria.items():
        if requestparam in request:
            found_species = True
            filterparam = { dbname: True }

            species = species.filter(**filterparam)

    if 'species' in request:
        found_species = True
        species = species.filter(id=request['species'])

    if found_species:
        search.trees = search.trees.filter(species__in=species)
        search.plots = search.plots.filter(tree__species__in=species)

        cqls = ["species_id = %d" % s.id for s in species]
        search.tile_query.append(
            "( %s )" % " OR ".join(cqls))

    return search


DEFAULT_FILTERS = [apply_location_filter,
                   apply_plot_size_filter,
                   apply_plot_type_filter,
                   apply_sidewalk_damage_filter,
                   apply_pests_filter,
                   apply_powerlines_filter,
                   apply_owner_filter,
                   apply_updated_by_filter,
                   apply_updated_range_filter,
                   apply_projects_filter,
                   apply_missing_species_filter,
                   apply_dbh_filter,
                   apply_tree_height_filter,
                   apply_tree_condition_filter,
                   apply_canopy_condition_filter,
                   apply_tree_owner_filter,
                   apply_photos_filter,
                   apply_steward_filter,
                   apply_funding_filter,
                   apply_planted_range_filter,
                   apply_species_filters,
                   apply_stewardship_filter]

def search(request, filters):
    tile_query = []
    trees = Tree.objects.filter(present=True)
    plots = Plot.objects.filter(present=True)

    trees = trees.extra(
        select= {
            'geometry':
            """
            SELECT treemap_plot.geometry
            FROM treemap_plot
            WHERE treemap_tree.plot_id = treemap_plot.id
            """ })

    s = Search(trees, plots, tile_query, None, None)

    return apply_filters(request, s, filters)

def apply_filters(request, search, filters):
    for f in filters:
        search = f(request, search)

    return search

########NEW FILE########
__FILENAME__ = shortcuts
from django.contrib.gis.db.models.fields import GeometryField
from django.contrib.gis.geos import Point
from django.utils import simplejson
from django.core.serializers import json 
from django.http import HttpResponse
from django.core.exceptions import ValidationError
from django.forms.forms import NON_FIELD_ERRORS

from django.conf import settings

def validate_form(form, request):
    if form.is_valid():
        try:
            new_stuff = form.save(request)
            form.result = new_stuff
            return True
        except ValidationError, e:
            form._errors[NON_FIELD_ERRORS] = form.error_class(e.messages)
            return False
    else:
        return False


import re

def get_pt_or_bbox(rg):
    """
    parse out lat/lon or bbox from request.get and return geos geom
    """
    dec_num_re = "(\d+?(\.\d+))"
    bbox_re = '%s,%s.*?%s,%s' % (dec_num_re,dec_num_re,dec_num_re,dec_num_re)

    lat = rg.get('lat','')
    lon = rg.get('lon','')
    if lat and lon: 
        return Point(float(lon), float(lat), srid=4326)
    bbox = rg.get('bbox','')
    if bbox:
        b = re.search(rg.get('bbox',''), bbox_re).groups()
        p1 = Point((b[2],b[0]))
        p2 = Point((b[6],b[4]))
        return p1.union(p2).envelope
    return None

ADD_INITIAL_DEFAULTS = {
    'address': "Enter an Address or Intersection", 
    'city': "Enter a City", 
    'species_full': "Enter a Species Name", 
    'genus': "", 
    'species': "", 
    'dbh': "", 
    'height': "", 
    'canopy': "", 
    'owner': ""
}
def get_add_initial(setting_name):
    if settings.ADD_INITIAL_DEFAULTS and set([setting_name]).issubset(settings.ADD_INITIAL_DEFAULTS):
        return settings.ADD_INITIAL_DEFAULTS[setting_name]
    else:
        return ADD_INITIAL_DEFAULTS[setting_name]

def render_to_geojson(query_set, geom_field=None, mimetype='text/plain', pretty_print=True, excluded_fields=[], simplify='', additional_data=None, model=None, extent=None):
    '''
    
    Shortcut to render a GeoJson FeatureCollection from a Django QuerySet.
    Currently computes a bbox and adds a crs member as a sr.org link
    
    '''
    collection = {}

    if not model:
        model = query_set.model

    if not extent and query_set:
        extent = query_set.extent()

    fields = model._meta.fields
    geo_fields = [f for f in fields if isinstance(f, GeometryField)]
    
    #attempt to assign geom_field that was passed in
    if geom_field:
        geo_fieldnames = [x.name for x in geo_fields]
        try:
            geo_field = geo_fields[geo_fieldnames.index(geom_field)]
        except:
            raise Exception('%s is not a valid geometry on this model' % geom_field)
    else:
        geo_field = geo_fields[0] # no support yet for multiple geometry fields
        
        
    #remove other geom fields from showing up in attributes    
    if len(geo_fields) > 1:
        for gf in geo_fields:
            if gf.name not in excluded_fields: excluded_fields.append(gf.name)
        excluded_fields.remove(geo_field.name)    
    # Gather the projection information
    crs = {}
    crs['type'] = "link"
    crs_properties = {}
    crs_properties['href'] = 'http://spatialreference.org/ref/epsg/%s/' % geo_field.srid
    crs_properties['type'] = 'proj4'
    crs['properties'] = crs_properties 
    collection['crs'] = crs
    
    
    # Build list of features
    features = []
    if query_set:
      for item in query_set:
        feat = {}
        feat['type'] = 'Feature'
        d = {}
        
        #special attribs for trees:
        if  model.__name__ == 'Tree':
            if item.species:
                d['scientific_name'] = item.species.scientific_name
                d['common_name'] = item.species.common_name
                d['flowering'] = item.species.flower_conspicuous
                d['native'] = item.species.native_status
        elif model.__name__ == 'Plot':
            tree = item.current_tree()
            if tree:
                if tree.species:
                    d['scientific_name'] = tree.species.scientific_name
                    d['common_name'] = tree.species.common_name
                d['dbh'] = tree.dbh
                d['height'] = tree.height
                d['tree'] = True
            else:
                d['tree'] = False
                
        if hasattr(item, 'distance'):
            d['distance'] = getattr(item,'distance').ft
                
        g = getattr(item,geo_field.name)
        if simplify:
            g = g.simplify(simplify)
        for field in item._meta.fields:
            if field.name not in excluded_fields:
                d[field.name] = str(getattr(item, field.name))

        feat['geometry'] = simplejson.loads(g.geojson)
        feat['properties'] = d
        features.append(feat)
    else:
        pass #features.append({'type':'Feature','geometry': {},'properties':{}})

    # Label as FeatureCollection and add Features
    collection['type'] = "FeatureCollection"    
    collection['features'] = features
    
    # Attach extent of all features
    if query_set:
        collection['bbox'] = [x for x in extent]
    
    if additional_data:
        collection.update(additional_data)
    # Return response
    response = HttpResponse()
    if pretty_print:
        response.write('%s' % simplejson.dumps(collection, indent=1, cls=json.DateTimeAwareJSONEncoder))

    else:
        response.write('%s' % simplejson.dumps(collection, cls=json.DateTimeAwareJSONEncoder))    
    response['Content-length'] = str(len(response.content))
    response['Content-Type'] = mimetype
    return response

########NEW FILE########
__FILENAME__ = comment_tags
from treemap.models import CommentFlag
from django import template

register = template.Library()

@register.filter
def is_flagged(comment, user):
    return len(CommentFlag.objects.filter(user=user, comment=comment)) > 0

########NEW FILE########
__FILENAME__ = dynamic_attribute
from django import template
register = template.Library()

def get(target_obj, attr):
    if attr:
        #if '.' in attr:
        if isinstance(target_obj,dict):
            return target_obj.get(attr)
        if hasattr(target_obj,attr):
            return getattr(target_obj,attr)
        elif target_obj.__dict__.get(attr):
            return target_obj.__dict__.get(attribute)

register.filter('get',get)
########NEW FILE########
__FILENAME__ = tree_tags
import os
import random
import posixpath
from django.conf import settings
from django.template import Library, Node
from django.db.models import get_model
from treemap.views import user_is_authorized_to_update_pending_edits

register = Library()

def unit_or_expression(value, unit, failure_expression):
    """Helper function for formatting non-zero measurements

    Note that zero values will be coerced to failures to
    support legacy behavior."""
    if value:
        formatted_value = "%.2f" % float(value)
        if unit:
            formatted_value += " " + unit
        return formatted_value
    else:
        return failure_expression

@register.filter
def subtract(value, arg):
    return value - arg

@register.filter
def can_approve_pending(user):
    return user_is_authorized_to_update_pending_edits(user)

@register.filter
def gal2litres(value):
    if value:
        return value * 3.78541
    else:
        return value

@register.filter
def lbs2kgs(value):
    if value:
        return value * 0.453592
    else:
        return value

@register.filter
def unit_or_missing(value, unit=None):
    return unit_or_expression(value, unit, "Missing")

@register.filter
def unit_or_empty(value, unit=None):
    return unit_or_expression(value, unit, "")

@register.filter
def unit_or_zero(value, unit=None):
    zero_expression = "%.2f" % 0.00
    return unit_or_expression(value, unit, zero_expression)

@register.filter
def unit_or_unknown(value, unit=None):
    return unit_or_expression(value, unit, "Unknown")

@register.filter
def single_quote(value):
    if value:
        return "'" + value + "'"
    else:
        return ""

########NEW FILE########
__FILENAME__ = tests
import os

# Note that test_utils forces some settings to reasonable values
# and should be imported before any other django based things
from api.test_utils import setupTreemapEnv, teardownTreemapEnv, mkTree, mkPlot
from treemap.test_choices import *
from django.conf import settings

settings.CHOICES = CHOICES
settings.POSTAL_CODE_FIELD = "USZipCodeField"

from django import forms
from django.test import TestCase, TransactionTestCase
from django.db import connection

from django.contrib.gis.geos import MultiPolygon, Polygon, Point
from django.contrib.auth.models import User, UserManager, Permission as P

from treemap.models import Neighborhood, ZipCode, ExclusionMask
from treemap.models import Plot, ImportEvent, Species, Tree, TreeFlags
from treemap.models import BenefitValues, Resource, AggregateNeighborhood
from treemap.views import *
from treemap.shortcuts import get_add_initial

from registration_backend import MINIMUM_PASSWORD_LENGTH

from profiles.models import UserProfile
from django_reputation.models import Reputation, ReputationAction

from simplejson import loads
from datetime import timedelta, datetime, date
from time import mktime

from test_util import set_auto_now

from export import _sanitize_native_status_field, _sanitize_membership_test_field, sanitize_raw_sql

import django.shortcuts
import tempfile
import zipfile
import shutil

class EcoBenefitTests(TestCase):

    def setUp(self):
        setupTreemapEnv()

        self.u = User.objects.get(username="jim")

        ExclusionMask.objects.all().delete()

    def tearDown(self):
        settings.MULTI_REGION_ITREE_ENABLED = False

    def _resource_as_dict(self, tr):
        things = ['annual_stormwater_management',
                  'annual_electricity_conserved',
                  'annual_energy_conserved',
                  'annual_natural_gas_conserved',
                  'annual_air_quality_improvement',
                  'annual_co2_sequestered',
                  'annual_co2_avoided',
                  'annual_co2_reduced',
                  'total_co2_stored',
                  'annual_ozone',
                  'annual_nox',
                  'annual_pm10',
                  'annual_sox',
                  'annual_voc',
                  'annual_bvoc']

        return {thing: getattr(tr, thing) for thing in things}

    def test_simple_eco_generation(self):
        species = Species.objects.get(symbol="s1")

        plot = mkPlot(self.u,)
        tree = mkTree(self.u, plot, species=species)
        tree.dbh = 23.0

        tree.save()

        tr = TreeResource.objects.get(tree=tree)

        for benefit_value in self._resource_as_dict(tr).values():
            self.assertTrue(benefit_value is not None and
                            benefit_value != 0.0)


    def test_location_based_itree_benefits(self):
        settings.MULTI_REGION_ITREE_ENABLED = True
        pt1 = Point(5,5)
        pt2 = Point(-5, -5)

        p1 = Polygon( ((0, 0), (10, 0), (10, 10), (0, 10), (0, 0)) )
        p2 = Polygon( ((0, 0), (-10, 0), (-10, -10), (0, -10), (0, 0)) )

        p1 = MultiPolygon(p1)
        p2 = MultiPolygon(p2)

        c1 = ClimateZone(geometry=p1, itree_region='CaNCCoJBK')
        c2 = ClimateZone(geometry=p2, itree_region='CenFlaXXX')

        c1.save()
        c2.save()

        rsrc1 = Resource(meta_species="BDM OTHER", region="CaNCCoJBK")
        rsrc2 = Resource(meta_species="BDM OTHER", region="CenFlaXXX")
        rsrc1.save()
        rsrc2.save()

        species = Species.objects.get(symbol="s1")
        species.resource = [rsrc1, rsrc2]
        species.save()

        plot = mkPlot(self.u)
        plot.geometry = pt1
        plot.save()

        self.assertEqual(plot.itree_region(), 'CaNCCoJBK')

        tree = mkTree(self.u, plot, species=species)
        tree.dbh = 23.0
        tree.save()

        tr1 = self._resource_as_dict(TreeResource.objects.get(tree=tree))

        plot.geometry = pt2
        plot.save()

        self.assertEqual(plot.itree_region(), 'CenFlaXXX')

        tree = Tree.objects.get(pk=tree.pk)

        tr2 = self._resource_as_dict(TreeResource.objects.get(tree=tree))

        self.assertNotEqual(tr1, tr2)



# Needs to be a TransactionTestCase because
# we use ogr2ogr externally for csv generation
class SpeciesViewTests(TransactionTestCase):

    #TODO: Remove what we don't need here...
    def setUp(self):
        setupTreemapEnv()

        self.z1 = ZipCode.objects.get(zip="19107")
        self.n1 = Neighborhood.objects.get(name="n1")

        self.u = User.objects.get(username="jim")

        p1_no_tree = mkPlot(self.u,)
        p2_tree = mkPlot(self.u)
        p3_tree_species1 = mkPlot(self.u)
        p4_tree_species2 = mkPlot(self.u)

        self.s1 = Species.objects.get(symbol="s1")
        self.s2 = Species.objects.get(symbol="s2")
        self.s3 = Species.objects.get(symbol="s3")

        t1 = mkTree(self.u, p2_tree, species=None)
        t2 = mkTree(self.u, p3_tree_species1, self.s1)
        t3 = mkTree(self.u, p4_tree_species2, self.s2)

        self.p1_no_tree = p1_no_tree
        self.p2_tree = p2_tree
        self.p3_tree_species1 = p3_tree_species1;
        self.p4_tree_species2 = p4_tree_species2;

        self.plots = [p1_no_tree, p2_tree, p3_tree_species1, p4_tree_species2]

        self.t1 = t1
        self.t2 = t2
        self.t3 = t3

        self.ie = ImportEvent.objects.get(file_name='site_add')

    def test_full_species_list(self):
        """
        different ways to get the full list:
        - no args
        - all

        With and without 'json'
        """

        # With no additional params, we expect to render an
        # html page. That page should get a context object
        # of species
        response = self.client.get("/species/")
        self.assertTemplateUsed(response, 'treemap/species.html')

        context_ids = set([s.pk for s in response.context["species"]])
        db_ids = set([s.pk for s in Species.objects.all()])

        self.assertEquals(context_ids, db_ids)

        # I guess this just returns the same thing?
        response = self.client.get("/species/all/")
        self.assertTemplateUsed(response, 'treemap/species.html')

        context_ids = set([s.pk for s in response.context["species"]])
        self.assertEquals(context_ids, db_ids)

        # With 'json' in the query, do the same thing but return
        # JSON
        response = self.client.get("/species/all/json/")
        json_species = loads(response.content)

        json_ids = set([j['id'] for j in json_species])
        self.assertEqual(json_ids, db_ids)

        response = self.client.get("/species/json/")
        json_species = loads(response.content)

        json_ids = set([j['id'] for j in json_species])
        self.assertEqual(json_ids, db_ids)


    def test_inuse_species(self):
        # Start from a clean slate
        # Note- is it a bug that calling 'delete' on trees
        # doesn't update the species count?
        for t in Tree.objects.all():
            t.present = False
            t.save()
        for p in Plot.objects.all():
            p.present = False
            p.save()

        self.assertEqual(self.make_request("/species/in-use/"),
                         set([]))

        mkTree(self.u, species=self.s1)
        mkTree(self.u, species=self.s1)
        mkTree(self.u, species=self.s1)

        self.assertEqual(self.make_request("/species/in-use/"),
                         set([(self.s1.pk,3)]))

        mkTree(self.u, species=self.s1)
        mkTree(self.u, species=self.s2)
        mkTree(self.u, species=self.s3)
        mkTree(self.u, species=self.s3)

        self.assertEqual(self.make_request("/species/in-use/"),
                         set([(self.s1.pk,4),
                              (self.s2.pk,1),
                              (self.s3.pk,2)]))

    def make_request(self, url, body=None):
        # Force a commit for ogr2ogr conversions
        transaction.commit()

        if body is None:
            body = {}

        response_html = self.client.get(url, body)

        html_ids = set([(s.pk,s.tree_count) \
                        for s in response_html.context["species"]])
        response_json = self.client.get("%sjson/" % url, body)

        json_species = loads(response_json.content)
        json_ids = set([(s['id'],s['count']) for s in json_species])

        response_csv = self.client.get("%scsv/" % url, body)

        self.assertEqual(response_csv.status_code, 200)
        self.assertEqual(response_csv['content-type'], 'application/zip')
        self.assertEqual(response_csv['content-disposition'],
                         'attachment; filename=species.zip')

        from zipfile import ZipFile
        from StringIO import StringIO
        from csv import DictReader

        zipdata = ZipFile(StringIO(response_csv.content))
        csv_ids = []
        for row in DictReader(zipdata.open('species./species..csv')):
            csv_ids.append((int(row['id']), int(row['tree_count'])))

        csv_ids = set(csv_ids)

        self.assertEqual(html_ids, json_ids)
        self.assertEqual(html_ids, csv_ids)
        return html_ids


    def test_nearby_species(self):
        # Start from a clean slate
        for t in Tree.objects.all():
            t.present = False
            t.save()
        for p in Plot.objects.all():
            p.present = False
            p.save()


        # If you don't specify a 'location' param you
        # get a 404....
        response = self.client.get("/species/nearby/")
        self.assertEqual(response.status_code, 404)

        def loc_request(x,y):
            url = "/species/nearby/"
            location = {'location': '%s,%s' % (x,y)}

            return self.make_request(url, location)

        def makeIt(x,y,s):
            mkTree(self.u,
                   plot=mkPlot(self.u,geom=Point(x,y)),
                   species=s)

        makeIt(35.00001,5.0,self.s1)
        makeIt(35.00002,5.0,self.s1)
        makeIt(35.00102,5.0,self.s1)
        makeIt(35.00102,5.0,self.s2)
        makeIt(45.00000,5.0,self.s2)
        makeIt(45.00000,5.0,self.s3)

        s1 = self.s1.pk
        s2 = self.s2.pk
        s3 = self.s3.pk

        self.assertEqual(loc_request(6,6),
                         set([]))

        # It appears that 'tree_count' is the entire
        # species count, even when doing a nearby query... not sure
        # if this is intentional but this encodes that specific logic
        self.assertEqual(loc_request(35.0,5.0),
                         set([(s1, 3)]))

        self.assertEqual(loc_request(35.0005,5.0),
                         set([(s1, 3),
                              (s2, 2)]))

        # Just FYI, There is a hardcoded constant of 0.001 for distance
        # so this test encodes that logic as well
        self.assertEqual(loc_request(35.000019,5.0),
                         set([(s1, 3)]))


class ViewTests(TestCase):

    def setUp(self):
        setupTreemapEnv()

        self.z1 = ZipCode.objects.get(zip="19107")
        self.n1 = Neighborhood.objects.get(name="n1")

        self.u = User.objects.get(username="jim")

        p1_no_tree = mkPlot(self.u, geom=Point(50,50))
        p2_tree = mkPlot(self.u, geom=Point(51,51))
        p3_tree_species1 = mkPlot(self.u, geom=Point(50,100))
        p4_tree_species2 = mkPlot(self.u, geom=Point(50,150))

        self.s1 = Species.objects.get(symbol="s1")
        self.s2 = Species.objects.get(symbol="s2")
        self.s3 = Species.objects.get(symbol="s3")

        t1 = mkTree(self.u, p2_tree, species=None)
        t2 = mkTree(self.u, p3_tree_species1, self.s1)
        t3 = mkTree(self.u, p4_tree_species2, self.s2)

        self.p1_no_tree = p1_no_tree
        self.p2_tree = p2_tree
        self.p3_tree_species1 = p3_tree_species1;
        self.p4_tree_species2 = p4_tree_species2;

        self.plots = [p1_no_tree, p2_tree, p3_tree_species1, p4_tree_species2]

        self.t1 = t1
        self.t2 = t2
        self.t3 = t3

        self.ie = ImportEvent.objects.get(file_name='site_add')



##############################################
#  Stewardship raw sql tests

    def test_stewardship(self):
        TreeStewardship.objects.create(activity="test",
                               tree=self.t1,
                               performed_by=self.u,
                               performed_date=datetime.now())

        # Two actions at different times
        TreeStewardship.objects.create(activity="test",
                               tree=self.t1,
                               performed_by=self.u,
                               performed_date=datetime.now())

        trees = Stewardship.trees_with_activities(["test2"])

        self.assertEqual(
            set(trees),
            set())

        TreeStewardship.objects.create(activity="test2",
                               tree=self.t1,
                               performed_by=self.u,
                               performed_date=datetime.now())

        trees = Stewardship.trees_with_activities(["test2"])

        TreeStewardship.objects.create(activity="test2",
                               tree=self.t2,
                               performed_by=self.u,
                               performed_date=datetime.now())

        trees = Stewardship.trees_with_activities(["test2"])

        self.assertEqual(
            set(trees),
            set([self.t1.pk, self.t2.pk]))

        trees = Stewardship.trees_with_activities(["test"])

        self.assertEqual(
            set(trees),
            set([self.t1.pk]))



##############################################
#  Assertion helpers

    def assert_geojson_has_ids(self, geojson, ids):
        return self.assertEqual(self.geojson_ft2id(geojson), ids)


    def assert_point_in_nhood(self, point, nhood):
        test_set = Neighborhood.objects.filter(geometry__contains=point)
        for t in test_set:
            if t == nhood:
                return
        self.fail("Point not in Neighborhood: %s" % nhood.name)



##############################################
#  Data conversion helpers

    def geojson_ft2id(self,geojson):
        if geojson and "features" in geojson:
            return set([int(ft["properties"]["id"]) for ft in geojson["features"]])
        else:
            return set()

#############################################
#  shortcut tests

    def test_add_initial_defaults(self):
        settings.ADD_INITIAL_DEFAULTS = {
            'dbh': "Size",
        }
        # the changed setting should show up
        self.assertEqual(get_add_initial('dbh'), 'Size')
        # an unchanged settings should be the default still
        self.assertEqual(get_add_initial('height'), '')

#############################################
#  page setup tests

    def test_homepage_feeds(self):
        response = self.client.get("/home/")
        self.assertTemplateUsed(response, 'treemap/index.html')
        response = self.client.get("/home/feeds/")
        self.assertTemplateUsed(response, 'treemap/index.html')
        feeds = response.context["feeds"]
        self.assertNotEqual(len(feeds["active_nhoods"]), 0)
        self.assertIsInstance(feeds["active_nhoods"][0], Neighborhood)
        self.assertNotEqual(len(feeds["species"]), 0)
        self.assertIsInstance(feeds["species"][0], Species)
        self.assertEqual(len(feeds["recent_photos"]), 0)
        self.assertNotEqual(len(feeds["recent_edits"]), 0)
        self.assertEqual(feeds["recent_edits"][0][0], u'jim')
        self.assertIsInstance(feeds["recent_edits"][0][1], datetime)

        response = self.client.get("/home/feeds/json/")
        json = loads(response.content)
        self.assertNotEqual(len(json["species"]), 0)
        self.assertNotEqual(len(json["active_nhoods"]), 0)


    def test_get_choices(self):
        response = self.client.get("/choices/")
        choices = loads(response.content)
        self.assertNotEqual(len(choices['plot_types']), 0)


#############################################
#  Geocoder Tests

    def test_geocoder(self):
        response = self.client.get("/geocode/")
        json = loads(response.content)
        self.assertFalse(json["success"])
        self.assertIn("No geocoder", json["error"])

        form = {}
        form["geocoder_name"] = "CitizenAtlas"
        response = self.client.get("/geocode/", form)
        json = loads(response.content)
        self.assertFalse(json["success"])
        self.assertIn("No address", json["error"])

        form["address"] = "100 somewhere"
        response = self.client.get("/geocode/", form)
        json = loads(response.content)
        self.assertFalse(json["success"])
        self.assertIn("No results", json["error"])

        form["address"] = "100 10th St SE"
        response = self.client.get("/geocode/", form)
        json = loads(response.content)
        self.assertTrue(json["success"])
        self.assertIn("10TH", json["place"])
        self.assertIn("20003", json["place"])
        self.assertAlmostEqual(float(json['lat']), 38.88857251)
        self.assertAlmostEqual(float(json['lng']), -76.99244160)

        #############################################
        #  reverse geocoding

        response = self.client.get("/geocode/reverse/")
        json = loads(response.content)
        self.assertFalse(json["success"])
        self.assertIn("No geocoder", json["error"])

        form = {}
        form["geocoder_name"] = "CitizenAtlas"
        response = self.client.get("/geocode/reverse/", form)
        json = loads(response.content)
        self.assertFalse(json["success"])
        self.assertIn("No point", json["error"])

        form["lat"] = "abc"
        form["lng"] = "def"
        response = self.client.get("/geocode/reverse/", form)
        json = loads(response.content)
        self.assertFalse(json["success"])
        self.assertIn("could not convert", json["error"])

        form["lat"] = 38.88857251
        form["lng"] = -76.99244160
        response = self.client.get("/geocode/reverse/", form)
        json = loads(response.content)
        self.assertTrue(json["success"])
        self.assertIn("10TH", json["place"])
        self.assertIn("20003", json["place"])
        self.assertAlmostEqual(float(json['lat']), form['lat'])
        self.assertAlmostEqual(float(json['lng']), form['lng'])


#############################################
#  Search Tests

    def test_plot_location_search_error_cases(self):
        """ Test error cases for plot location search """
         # The following errors should all be 400 -> Malformed Request

        # Error case -> Missing get data
        # Requires lat,lon or bbox
        response = self.client.get("/plots/location/")
        self.assertEqual(response.status_code, 400)

        response = self.client.get("/plots/location/?lat=-77")
        self.assertEqual(response.status_code, 400)

        response = self.client.get("/plots/location/?lon=-32")
        self.assertEqual(response.status_code, 400)


    def test_plot_location_search_pt(self):
        """ Test searching for plot by pt """
        reqstr = "/plots/location/?lat=%s&lon=%s&distance=%s&max_plots=%s"

        ##################################################################
        # Limit max plots to 1 - expect to get only 1 plot back
        response = self.client.get(reqstr % (50,50,1000,1))
        geojson = loads(response.content)

        self.assert_geojson_has_ids(geojson, set([self.p1_no_tree.pk]))

        ##################################################################
        # Limit distance to 5, expect to get only two (50,50) and (51,51) back
        response = self.client.get(reqstr % (50,50,5,100))
        geojson = loads(response.content)

        exp = set([self.p1_no_tree.pk, self.p2_tree.pk])

        self.assert_geojson_has_ids(geojson, exp)

        ##################################################################
        # Effective unlimited distance should return all plots
        response = self.client.get(reqstr % (50,50,10000,100))
        geojson = loads(response.content)

        self.assert_geojson_has_ids(geojson, set([p.pk for p in self.plots]))

        ##################################################################
        # Species filter tests
        #
        # The following business rules apply:
        # -> If (as above) no species if specified, return all plots
        # -> If a species is specifed:
        #      AND results in matching one or more (based on distance)
        #      THEN return only those plots with trees with the given species

        reqstr = "/plots/location/?lat=50&lon=50&distance=1000&max_plots=100&species=%s"

        response = self.client.get(reqstr % (self.s1.pk))
        geojson = loads(response.content)

        self.assert_geojson_has_ids(geojson, set([self.p3_tree_species1.pk]))

        response = self.client.get(reqstr % (self.s2.pk))
        geojson = loads(response.content)

        self.assert_geojson_has_ids(geojson, set([self.p4_tree_species2.pk]))

        ##################################################################
        # -> If a species is specified:
        #      AND results in NO distance matches
        #      THEN return the original results, unfiltered
        #

        response = self.client.get(reqstr % (1000000))
        geojson = loads(response.content)

        self.assert_geojson_has_ids(geojson, set([p.pk for p in self.plots]))

    def test_result_map(self):
        ##################################################################
        # Test main result map page
        # Note -> This page does not depend at all on the request
        #

        p1 = Plot(geometry=Point(50,50), last_updated_by=self.u, import_event=self.ie,present=True, width=100, length=100, data_owner=self.u)
        p2 = Plot(geometry=Point(60,50), last_updated_by=self.u, import_event=self.ie,present=True, width=90, length=110, data_owner=self.u)

        p1.save()
        p2.save()

        # For max/min plot size
        p3 = Plot(geometry=Point(50,50), last_updated_by=self.u, import_event=self.ie,present=True, width=80, length=120, data_owner=self.u)
        p4 = Plot(geometry=Point(60,50), last_updated_by=self.u, import_event=self.ie,present=True, width=70, length=130, data_owner=self.u)
        p5 = Plot(geometry=Point(60,50), last_updated_by=self.u, import_event=self.ie,present=True, width=60, length=70, data_owner=self.u)

        p3.save()
        p4.save()
        p5.save()

        t3 = Tree(plot=p3, species=None, last_updated_by=self.u, import_event=self.ie,present=True)
        t3.save()

        t4 = Tree(plot=p4, species=None, last_updated_by=self.u, import_event=self.ie,present=True)
        t4.save()

        t5 = Tree(plot=p5, species=None, last_updated_by=self.u, import_event=self.ie,present=True)
        t5.save()

        t1 = Tree(plot=p1, species=None, last_updated_by=self.u, import_event=self.ie)
        t1.present = True

        current_year = datetime.now().year
        t1.date_planted = date(1999,9,9)

        t2 = Tree(plot=p2, species=None, last_updated_by=self.u, import_event=self.ie)
        t1.present = True

        t1.save()
        t2.save()

        set_auto_now(t1, "last_updated", False)
        t1.last_updated = date(1999,9,9)
        t1.save()

        response = self.client.get("/map/")
        req = response.context


        set_auto_now(t1, "last_updated", True)

        # t1 and t2 should not be in the latest trees/plots because it excludes superuser edits
        exp = set([])
        got = set([t.pk for t in req['latest_trees']])

        self.assertTrue(exp <= got)

        got = set([t.pk for t in req['latest_plots']])
        self.assertTrue(exp <= got)

        # Check to verify platting dates
        self.assertEquals(int(req['min_year']), 1999)
        self.assertEquals(int(req['current_year']), current_year)

        # Correct min/max plot sizes
        self.assertEqual(int(req['min_plot']), 60)
        self.assertEqual(int(req['max_plot']), 130)

        min_updated = mktime(t1.last_updated.timetuple())
        max_updated = mktime(t2.last_updated.timetuple())

        self.assertEqual(req['min_updated'], min_updated)
        self.assertEqual(req['max_updated'], max_updated)
        # 'min_updated': min_updated,
        # 'max_updated': max_updated,

    def test_search_results(self):
        ##################################################################
        # Test search result view
        #

        def assert_counts(tree_count, plot_count, req):
            self.assertEqual(req['summaries']['total_trees'], tree_count)
            self.assertEqual(req['summaries']['total_plots'], plot_count)

        def assert_benefits(req, isEmpty=False):
            if isEmpty:
                self.assertEqual(req['benefits']['total'], 0.0)
            else:
                self.assertNotEqual(req['benefits']['total'], 0.0)

        def to_search_string(choice_name):
            return choice_name.lower().replace(" ", "_").replace('/','')

        oneDay = timedelta(days=1)
        oneYear = timedelta(days=365)
        date_min = datetime.utcnow() - oneDay
        date_max = datetime.utcnow()
        qs_date_min = time.mktime(date_min.timetuple())
        qs_date_max = time.mktime(date_max.timetuple())

        plot_type_choices = CHOICES['plot_types']
        sidewalk_choices = CHOICES['sidewalks']
        powerline_choices = CHOICES['powerlines']
        tsteward_choices = CHOICES['tree_stewardship']
        psteward_choices = CHOICES['plot_stewardship']
        condition_choices = CHOICES['conditions']
        flag_choices = CHOICES['projects']

        p1 = Plot(geometry=Point(50,50), last_updated_by=self.u, import_event=self.ie, type=plot_type_choices[0][0],width=1, length=1, data_owner=self.u)
        p2 = Plot(geometry=Point(60,50), last_updated_by=self.u, import_event=self.ie, type=plot_type_choices[1][0], width=3, length=5, data_owner=self.u)
        p3 = Plot(geometry=Point(50,50), last_updated_by=self.u, import_event=self.ie, width=10, length=15, data_owner=self.u)
        p4 = Plot(geometry=Point(60,50), last_updated_by=self.u, import_event=self.ie, sidewalk_damage=sidewalk_choices[0][0], data_owner=self.u)
        p5 = Plot(geometry=Point(60,50), last_updated_by=self.u, import_event=self.ie, powerline_conflict_potential=powerline_choices[1][0], data_owner=self.u)
        p6 = Plot(geometry=Point(60,50), last_updated_by=self.u, import_event=self.ie, data_owner=self.u)

        save_this = [p1,p2,p3,p4,p5,p6]
        for obj in save_this: obj.save()

        t1 = Tree(plot=p1, last_updated_by=self.u, import_event=self.ie, dbh=4, condition=condition_choices[0][0], date_planted=datetime.utcnow()-oneYear)
        t2 = Tree(plot=p2, last_updated_by=self.u, import_event=self.ie, dbh=10, species=self.s1, condition=condition_choices[1][0])
        t3 = Tree(plot=p3, last_updated_by=self.u, import_event=self.ie, dbh=40, species=self.s1, height=150, sponsor=self.u.username, date_planted=date_min)
        t4 = Tree(plot=p4, last_updated_by=self.u, import_event=self.ie, height=30, species=self.s3, condition=condition_choices[3][0], steward_user=self.u)
        t5 = Tree(plot=p6, last_updated_by=self.u, import_event=self.ie, dbh=30, species=self.s3)

        ps1 = PlotStewardship(performed_by=self.u, performed_date=datetime.now(), plot=p1, activity=psteward_choices[0][0])
        ps2 = PlotStewardship(performed_by=self.u, performed_date=datetime.now(), plot=p2, activity=psteward_choices[1][0])
        ps3 = PlotStewardship(performed_by=self.u, performed_date=datetime.now(), plot=p2, activity=psteward_choices[2][0])

        save_this = [ps1,ps2,ps3, t1,t2,t3,t4,t5]
        for obj in save_this: obj.save()

        tf1 = TreeFlags(reported_by=self.u, tree=t1, key=flag_choices[0][0])
        tf2 = TreeFlags(reported_by=self.u, tree=t4, key=flag_choices[0][0])

        ts1 = TreeStewardship(performed_by=self.u, performed_date=datetime.now(), tree=t1, activity=tsteward_choices[0][0])
        ts2 = TreeStewardship(performed_by=self.u, performed_date=datetime.now(), tree=t2, activity=tsteward_choices[1][0])
        ts3 = TreeStewardship(performed_by=self.u, performed_date=datetime.now(), tree=t2, activity=tsteward_choices[2][0])

        save_this = [tf1,tf2, ts1,ts2,ts3]
        for obj in save_this: obj.save()

        response = self.client.get("/search/")
        req = loads(response.content)

        present_trees = Tree.objects.filter(present=True)
        present_plots = Plot.objects.filter(present=True)

        assert_counts(present_trees.count(), present_plots.count(), req)
        assert_benefits(req)
        self.assertEqual(req['full_tree_count'], present_trees.count())
        self.assertEqual(req['full_plot_count'], present_plots.count())
        self.assertEqual(req['tile_query'], '')
        self.assertEqual(req['geography'], None)

        ##################################################################
        # Test geographic searches
        #    neighborhood, zipcode, lat/lon
        #
        response = self.client.get("/search/?geoName=%s" % self.n1.name )
        req = loads(response.content)
        trees = present_trees.filter(plot__neighborhood=self.n1)
        plots = present_plots.filter(neighborhood=self.n1)
        assert_counts(trees.count(), plots.count(), req)
        assert_benefits(req)
        self.assertEqual(req['geography']['type'], 'Polygon')
        self.assertEqual(req['geography']['name'], self.n1.name)
        self.assertTrue('neighborhoods' in req['tile_query'])

        response = self.client.get("/search/?location=%s" % self.z1.zip)
        req = loads(response.content)
        trees = present_trees.filter(plot__zipcode=self.z1)
        plots = present_plots.filter(zipcode=self.z1)
        assert_counts(trees.count(), plots.count(), req)
        assert_benefits(req)
        self.assertEqual(req['geography']['type'], 'Polygon')
        self.assertEqual(req['geography']['name'], self.z1.zip)
        self.assertTrue('zipcode' in req['tile_query'])

        response = self.client.get("/search/?lat=%d&lon=%d" % (25.0,25.0))
        req = loads(response.content)
        nbhood = Neighborhood.objects.filter(geometry__contains=Point(25,25))[0]
        trees = present_trees.filter(plot__zipcode=nbhood)
        plots = present_plots.filter(zipcode=nbhood)
        assert_counts(trees.count(), plots.count(), req)
        assert_benefits(req)
        self.assertEqual(req['geography']['type'], 'Polygon')
        self.assertEqual(req['geography']['name'], nbhood.name)
        self.assertTrue('neighborhoods' in req['tile_query'])

        ##################################################################
        # Test plot data searches
        #    plot type, plot size, sidewalk damage, powerlines, owner,
        #    plot stewardship
        #
        plot_list = [1, 2]
        plot_name_list = [to_search_string(plot_type_choices[0][1]),to_search_string(plot_type_choices[1][1])]
        response = self.client.get("/search/?%s=true&%s=true" % (plot_name_list[0], plot_name_list[1]))
        req = loads(response.content)
        trees = present_trees.filter(plot__type__in=plot_list)
        plots = present_plots.filter(type__in=plot_list)

        assert_counts(trees.count(), plots.count(), req)
        assert_benefits(req)
        self.assertTrue('plot_type' in req['tile_query'])

        plot_range = [3, 11]
        response = self.client.get("/search/?plot_range=%s-%s" % (plot_range[0], plot_range[1]) )
        req = loads(response.content)
        trees = present_trees.filter(Q(plot__length__gte=plot_range[0]) | Q(plot__width__gte=plot_range[0])).filter(Q(plot__length__lte=plot_range[1]) | Q(plot__width__lte=plot_range[1]))
        plots = present_plots.filter(Q(length__gte=plot_range[0]) | Q(width__gte=plot_range[0])).filter(Q(length__lte=plot_range[1]) | Q(width__lte=plot_range[1]))

        assert_counts(trees.count(), plots.count(), req)
        assert_benefits(req)
        self.assertTrue('plot_width' in req['tile_query'])
        self.assertTrue('plot_length' in req['tile_query'])

        sidewalk_list = [1]
        response = self.client.get("/search/?%s=true" % (to_search_string(sidewalk_choices[0][1])) )
        req = loads(response.content)
        trees = present_trees.filter(plot__sidewalk_damage__in=sidewalk_list)
        plots = present_plots.filter(sidewalk_damage__in=sidewalk_list)

        assert_counts(trees.count(), plots.count(), req)
        assert_benefits(req, True)
        self.assertTrue('sidewalk_damage' in req['tile_query'])

        powerline_list = [2]
        response = self.client.get("/search/?%s=true" % (to_search_string(powerline_choices[1][1])) )
        req = loads(response.content)
        trees = present_trees.filter(plot__powerline_conflict_potential__in=powerline_list)
        plots = present_plots.filter(powerline_conflict_potential__in=powerline_list)

        assert_counts(trees.count(), plots.count(), req)
        assert_benefits(req, True)
        self.assertTrue('powerline' in req['tile_query'])

        response = self.client.get("/search/?owner=%s" % self.u.username)
        req = loads(response.content)
        users = User.objects.filter(username__icontains=self.u.username)
        trees = present_trees.filter(plot__data_owner__in=users)
        plots = present_plots.filter(data_owner__in=users)

        assert_counts(trees.count(), plots.count(), req)
        assert_benefits(req)
        self.assertTrue('data_owner' in req['tile_query'])

        plot_stewardship_list = [1,2]
        response = self.client.get("/search/?plot_stewardship=%s,%s&stewardship_range=%s-%s&stewardship_reverse=true" % (plot_stewardship_list[0], plot_stewardship_list[1], qs_date_min, qs_date_max) )
        req = loads(response.content)
        steward_ids = [s.plot_id for s in PlotStewardship.objects.order_by("plot__id").distinct("plot__id")]
        for ps in plot_stewardship_list:
            steward_ids = [s.plot_id for s in PlotStewardship.objects.filter(plot__id__in=steward_ids).filter(activity=ps)]
        plots = present_plots.filter(id__in=steward_ids).exclude(plotstewardship__performed_date__lte=date_min).exclude(plotstewardship__performed_date__gte=date_max)
        trees = present_trees.filter(plot__in=plots)

        assert_counts(trees.count(), plots.count(), req)
        assert_benefits(req, True)
        self.assertTrue('plot_stewardship' in req['tile_query'])

        response = self.client.get("/search/?plot_stewardship=%s,%s&stewardship_range=%s-%s&stewardship_reverse=false" % (plot_stewardship_list[0],plot_stewardship_list[1], qs_date_min, qs_date_max) )
        req = loads(response.content)
        plots = present_plots.exclude(id__in=steward_ids).exclude(plotstewardship__performed_date__lte=date_min).exclude(plotstewardship__performed_date__gte=date_max)
        trees = present_trees.filter(plot__in=plots)

        assert_counts(trees.count(), plots.count(), req)
        assert_benefits(req)
        self.assertTrue('plot_stewardship' in req['tile_query'])

        ##################################################################
        # Test tree data searches
        #    diameter, height, condition, photos, steward, sponsor
        #    projects, planted date range, tree stewardship
        #
        diameter_list = [11,25]
        response = self.client.get("/search/?diameter_range=%s-%s" % (diameter_list[0],diameter_list[1]) )
        req = loads(response.content)
        trees = present_trees.filter(dbh__gte=diameter_list[0]).filter(dbh__lte=diameter_list[1])
        plots = present_plots.filter(tree__dbh__gte=diameter_list[0]).filter(tree__dbh__lte=diameter_list[1])

        assert_counts(trees.count(), plots.count(), req)
        assert_benefits(req, True)
        self.assertTrue('dbh' in req['tile_query'])

        height_list = [0,50]
        response = self.client.get("/search/?height_range=%s-%s" % (height_list[0],height_list[1]) )
        req = loads(response.content)
        trees = present_trees.filter(height__gte=height_list[0]).filter(height__lte=height_list[1])
        plots = present_plots.filter(tree__height__gte=height_list[0]).filter(tree__height__lte=height_list[1])

        assert_counts(trees.count(), plots.count(), req)
        assert_benefits(req, True)
        self.assertTrue('height' in req['tile_query'])

        condition_list = [1,2]
        response = self.client.get("/search/?%s=true&%s=true" % (to_search_string(condition_choices[0][1]), to_search_string(condition_choices[1][1])) )
        req = loads(response.content)
        trees = present_trees.filter(condition__in=condition_list)
        plots = present_plots.filter(tree__condition__in=condition_list)

        assert_counts(trees.count(), plots.count(), req)
        assert_benefits(req)
        self.assertTrue('condition' in req['tile_query'])

        response = self.client.get("/search/?photos=true" )
        req = loads(response.content)
        trees = present_trees.filter(treephoto__isnull=False)
        plots = present_plots.filter(tree__treephoto__isnull=False)

        assert_counts(trees.count(), plots.count(), req)
        assert_benefits(req, True)
        self.assertTrue('photo_count' in req['tile_query'])

        response = self.client.get("/search/?steward=%s" % self.u.username)
        req = loads(response.content)
        users = User.objects.filter(username__icontains=self.u.username)
        trees = present_trees.filter(Q(steward_user__in=users) | Q(steward_name__icontains=self.u.username))
        plots = present_plots.filter(Q(tree__steward_user__in=users) | Q(tree__steward_name__icontains=self.u.username))

        assert_counts(trees.count(), plots.count(), req)
        assert_benefits(req, True)
        self.assertTrue('steward_user_id' in req['tile_query'])
        self.assertTrue('steward_name' in req['tile_query'])

        response = self.client.get("/search/?funding=%s" % self.u.username)
        req = loads(response.content)
        trees = present_trees.filter(sponsor__icontains=self.u.username)
        plots = present_plots.filter(tree__sponsor__icontains=self.u.username)

        assert_counts(trees.count(), plots.count(), req)
        assert_benefits(req)
        self.assertTrue('sponsor' in req['tile_query'])

        planted_range_list = ["2010-01-01","2012-12-31"]
        response = self.client.get("/search/?planted_range=2010-2012" )
        req = loads(response.content)
        trees = present_trees.filter(date_planted__gte=planted_range_list[0], date_planted__lte=planted_range_list[1])
        plots = present_plots.filter(tree__date_planted__gte=planted_range_list[0], tree__date_planted__lte=planted_range_list[1])

        assert_counts(trees.count(), plots.count(), req)
        # This test is broken. A tree without a species cannot
        # have an ecobenefit, so this assertion is broken:
        # assert_benefits(req)
        self.assertTrue('date_planted' in req['tile_query'])

        local_list = [1, 2]
        response = self.client.get("/search/?%s=true&%s=true" % (to_search_string(flag_choices[0][1]), to_search_string(flag_choices[1][1])) )
        req = loads(response.content)
        trees = present_trees.filter(treeflags__key__in=local_list)
        plots = present_plots.filter(tree__treeflags__key__in=local_list)

        assert_counts(trees.count(), plots.count(), req)
        assert_benefits(req, True)
        self.assertTrue('projects' in req['tile_query'])

        tree_stewardship_list = [1,2]
        response = self.client.get("/search/?tree_stewardship=%s,%s&stewardship_range=%s-%s&stewardship_reverse=true" % (tree_stewardship_list[0], tree_stewardship_list[1], qs_date_min, qs_date_max) )
        req = loads(response.content)
        steward_ids = [s.tree_id for s in TreeStewardship.objects.order_by("tree__id").distinct("tree__id")]
        for ts in tree_stewardship_list:
            steward_ids = [s.tree_id for s in TreeStewardship.objects.filter(tree__id__in=steward_ids).filter(activity=ts)]
        trees = present_trees.filter(id__in=steward_ids).exclude(treestewardship__performed_date__lte=date_min).exclude(treestewardship__performed_date__gte=date_max)
        plots = present_plots.filter(tree__in=trees)

        assert_counts(trees.count(), plots.count(), req)
        assert_benefits(req, True)
        self.assertTrue('tree_stewardship' in req['tile_query'])

        response = self.client.get("/search/?tree_stewardship=%s,%s&stewardship_range=%s-%s&stewardship_reverse=false" % (tree_stewardship_list[0],tree_stewardship_list[1], qs_date_min, qs_date_max) )
        req = loads(response.content)
        trees = present_trees.exclude(id__in=steward_ids).exclude(treestewardship__performed_date__lte=date_min).exclude(treestewardship__performed_date__gte=date_max)
        plots = present_plots.filter(tree__in=trees)

        assert_counts(trees.count(), plots.count(), req)
        assert_benefits(req)
        self.assertTrue('tree_stewardship' in req['tile_query'])

        ##################################################################
        # Test species data searches
        #    id, native, edible, fall color, flowering, wildlife
        #
        present_species = Species.objects.filter(tree_count__gt=0)
        def check_species(species_list, req):
            max_species = present_species.count()
            trees = present_trees.filter(species__in=species_list)
            plots = present_plots.filter(tree__species__in=species_list)

            assert_counts(trees.count(), plots.count(), req)
            if max_species != species_list.count():
                self.assertTrue('species_id' in req['tile_query'])

        response = self.client.get("/search/?species=%s" % self.s1.id )
        req = loads(response.content)
        species = present_species.filter(id=self.s1.id)
        check_species(species, req)
        assert_benefits(req)

        response = self.client.get("/search/?native=true" )
        req = loads(response.content)
        species = present_species.filter(native_status='True')
        check_species(species, req)
        assert_benefits(req)

        response = self.client.get("/search/?edible=true" )
        req = loads(response.content)
        species = present_species.filter(palatable_human=True)
        check_species(species, req)
        assert_benefits(req)

        response = self.client.get("/search/?color=true" )
        req = loads(response.content)
        species = present_species.filter(fall_conspicuous=True)
        check_species(species, req)
        assert_benefits(req)

        response = self.client.get("/search/?flowering=true" )
        req = loads(response.content)
        species = present_species.filter(flower_conspicuous=True)
        check_species(species, req)
        assert_benefits(req)

        response = self.client.get("/search/?wildlife=true" )
        req = loads(response.content)
        species = present_species.filter(wildlife_value=True)
        check_species(species, req)
        assert_benefits(req)

        ##################################################################
        # Test plot/tree data searches
        #    updated by, updated range
        #    - These test search both trees and plots in the same way
        #
        response = self.client.get("/search/?updated_by=%s" % self.u.username)
        req = loads(response.content)
        users = User.objects.filter(username__icontains=self.u.username)
        trees = present_trees.filter(last_updated_by__in=users)
        plots = present_plots.filter(last_updated_by__in=users)

        assert_counts(trees.count(), plots.count(), req)
        assert_benefits(req)
        self.assertTrue('last_updated_by' in req['tile_query'])

        response = self.client.get("/search/?updated_range=%s-%s" % (qs_date_min, qs_date_max) )
        req = loads(response.content)
        trees = present_trees.filter(last_updated__gte=date_min, last_updated__lte=date_max)
        plots = present_plots.filter(last_updated__gte=date_min, last_updated__lte=date_max)

        assert_counts(trees.count(), plots.count(), req)
        assert_benefits(req)
        self.assertTrue('last_updated' in req['tile_query'])


        ##################################################################
        # Test missing data searches
        #    species, diameter, height, plot type, plot size, condition,
        #    sidewalk damage, powerlines, photos
        #    - Some searches count 0 values as 'missing'
        #
        response = self.client.get("/search/?missing_species=true")
        req = loads(response.content)

        trees = present_trees.filter(species__isnull=True)
        plots = present_plots.filter(tree__species__isnull=True)
        assert_counts(trees.count(), plots.count(), req)
        assert_benefits(req, True)
        self.assertTrue('species_id' in req['tile_query'])

        response = self.client.get("/search/?missing_diameter=true")
        req = loads(response.content)
        trees = present_trees.filter(Q(dbh__isnull=True) | Q(dbh=0))
        plots = present_plots.filter(Q(tree__dbh__isnull=True) | Q(tree__dbh=0))

        assert_counts(trees.count(), plots.count(), req)
        assert_benefits(req, True)
        self.assertTrue('dbh' in req['tile_query'])

        response = self.client.get("/search/?missing_height=true")
        req = loads(response.content)
        trees = present_trees.filter(Q(height__isnull=True) | Q(height=0))
        plots = present_plots.filter(Q(tree__height__isnull=True) | Q(tree__height=0))

        assert_counts(trees.count(), plots.count(), req)
        assert_benefits(req)
        self.assertTrue('height' in req['tile_query'])

        response = self.client.get("/search/?missing_plot_type=true")
        req = loads(response.content)
        trees = present_trees.filter(plot__type__isnull=True)
        plots = present_plots.filter(type__isnull=True)

        assert_counts(trees.count(), plots.count(), req)
        assert_benefits(req)
        self.assertTrue('plot_type' in req['tile_query'])

        response = self.client.get("/search/?missing_plot_size=true")
        req = loads(response.content)
        trees = present_trees.filter(Q(plot__length__isnull=True) | Q(plot__width__isnull=True))
        plots = present_plots.filter(Q(length__isnull=True) | Q(width__isnull=True))

        assert_counts(trees.count(), plots.count(), req)
        assert_benefits(req)
        self.assertTrue('plot_length' in req['tile_query'])

        response = self.client.get("/search/?missing_condition=true")
        req = loads(response.content)
        trees = present_trees.filter(condition__isnull=True)
        plots = present_plots.filter(tree__condition__isnull=True)

        assert_counts(trees.count(), plots.count(), req)
        assert_benefits(req)
        self.assertTrue('condition' in req['tile_query'])

        response = self.client.get("/search/?missing_sidewalk=true")
        req = loads(response.content)
        trees = present_trees.filter(plot__sidewalk_damage__isnull=True)
        plots = present_plots.filter(sidewalk_damage__isnull=True)

        assert_counts(trees.count(), plots.count(), req)
        assert_benefits(req)
        self.assertTrue('sidewalk_damage' in req['tile_query'])

        response = self.client.get("/search/?missing_powerlines=true")
        req = loads(response.content)
        trees = present_trees.filter(plot__powerline_conflict_potential__isnull=True)
        plots = present_plots.filter(powerline_conflict_potential__isnull=True)

        assert_counts(trees.count(), plots.count(), req)
        assert_benefits(req)
        self.assertTrue('powerline_conflict_potential' in req['tile_query'])

        response = self.client.get("/search/?missing_photos=true")
        req = loads(response.content)
        trees = present_trees.filter(treephoto__isnull=True)
        plots = present_plots.filter(tree__treephoto__isnull=True)

        assert_counts(trees.count(), plots.count(), req)
        assert_benefits(req)
        self.assertTrue('photo_count' in req['tile_query'])

        ##################################################################
        # Test searching precedance rules
        #    - Missing data search trumps data search
        #    - Missing species + species id = 0 results
        #
        response = self.client.get("/search/?missing_plot_type=true&tree_pit=true")
        req = loads(response.content)
        trees = present_trees.filter(plot__type__isnull=True)
        plots = present_plots.filter(type__isnull=True)

        assert_counts(trees.count(), plots.count(), req)
        assert_benefits(req)
        self.assertTrue('plot_type' in req['tile_query'])

        response = self.client.get("/search/?missing_species=true&species=%s" % self.s1.id)
        req = loads(response.content)

        assert_counts(0,0, req)
        assert_benefits(req, True)
        self.assertTrue('species_id' in req['tile_query'])


#############################################
#  New Plot Tests

    def test_add_plot(self):
        self.client.login(username='jim',password='jim')
        form = {}
        form['target']="view"
        form['initial_map_location'] = "20,20"
        ##################################################################
        # Test required information:
        #     lat,lon,entered address and geocoded address

        form['lat'] = 1000
        form['lon'] = 1000
        self.assertTemplateUsed(self.client.post("/trees/add/", form), 'treemap/tree_add.html')
        del form['lat']
        del form['lon']
        form['lat'] = 50
        self.assertTemplateUsed(self.client.post("/trees/add/", form), 'treemap/tree_add.html')
        form['lon'] = 50
        self.assertTemplateUsed(self.client.post("/trees/add/", form), 'treemap/tree_add.html')
        form['edit_address_street'] = "100 N Broad"
        self.assertTemplateUsed(self.client.post("/trees/add/", form), 'treemap/tree_add.html')
        del form['edit_address_street']
        form['geocode_address'] = "100 N Broad St"
        self.assertTemplateUsed(self.client.post("/trees/add/", form), 'treemap/tree_add.html')
        form['edit_address_street'] = "100 N Broad"

        response = self.client.post("/trees/add/", form)
        self.assertEquals(response.status_code, 302)
        self.assertTrue(response["Location"].endswith('/trees/new/%i/' % self.u.id), "Expected Location header to end with /trees/new/\d+ but instead it was %s" % response["Location"])

        response = self.client.get('/trees/new/%i/' % self.u.id)
        self.assertNotEqual(len(response.context['plots']), 0)
        new_plot = response.context['plots'][0]
        self.assertTrue(new_plot.geocoded_address, form['geocode_address'])

        response = self.client.get('/trees/new/%i/geojson/' % self.u.id)
        json_plots = loads(response.content)
        self.assertEqual(json_plots[0]['id'], new_plot.id)

        new_plot = None

        ##################################################################
        # Test plot-only creation:
        #     Info in these fields creates a plot object, and does not
        #     create a tree object

        form['edit_address_city'] = "Philadelphia"
        form['edit_address_zip'] = "19107"
        form['plot_width'] = "50"   #bad
        form['plot_width_in'] = "0"
        form['plot_length'] = "6"
        form['plot_length_in'] = "6"
        form['plot_type'] = "Open"
        form['power_lines'] = 1
        form['sidewalk_damage'] = 1

        # plot width < 15
        self.assertTemplateUsed(self.client.post("/trees/add/", form), 'treemap/tree_add.html')
        form['plot_width'] = "5"
        # plot width inches < 12
        form['plot_width_in'] = "20"
        self.assertTemplateUsed(self.client.post("/trees/add/", form), 'treemap/tree_add.html')
        form['plot_width_in'] = "6"
        # plot type in type list
        form['plot_type'] = "Blargh"
        self.assertTemplateUsed(self.client.post("/trees/add/", form), 'treemap/tree_add.html')
        form['plot_type'] = 1
        # powerlines = 1, 2, or 3
        form['power_lines'] = 15
        self.assertTemplateUsed(self.client.post("/trees/add/", form), 'treemap/tree_add.html')
        form['power_lines'] = 1
        # sidewalk damage = 1, 2, or 3
        form['sidewalk_damage'] = 15
        self.assertTemplateUsed(self.client.post("/trees/add/", form), 'treemap/tree_add.html')
        form['sidewalk_damage'] = 1
        form['owner_additional_id'] = 111

        response = self.client.post("/trees/add/", form)
        self.assertRedirects(response, '/trees/new/%i/' % self.u.id)

        response = self.client.get('/trees/new/%i/' % self.u.id)
        new_plot = response.context['plots'][0]
        self.assertAlmostEqual(new_plot.width, 5.5)
        self.assertAlmostEqual(new_plot.length, 6.5)
        self.assertEqual(new_plot.current_tree(), None)
        self.assertEqual(new_plot.zipcode, self.z1)
        self.assert_point_in_nhood(new_plot.geometry, self.n1)

        new_plot = None

        ##################################################################
        # Test exclusion zones:
        #     Turn on exclusions in the settings and move point into exclusion zone

        form['lat'] = 20
        form['lon'] = 20
        self.assertTemplateUsed(self.client.post("/trees/add/", form), 'treemap/tree_add.html')

        form['lat'] = 50
        form['lon'] = 50

        ##################################################################
        # Test tree creation:
        #     Info in the rest of the fields creates a tree object as well as a plot

        form['species_id'] = self.s1.id
        form['species_other1'] = 'newgenus'
        form['species_other2'] = 'newspecies'
        form['height'] = 50
        form['canopy_height'] = 40
        form['dbh'] = 2
        form['dbh_type'] = "circumference"
        form['condition'] = "Good"
        form['canopy_condition'] = "Full - No Gaps"

        # height <= 300
        form['height'] = 500
        self.assertTemplateUsed(self.client.post("/trees/add/", form), 'treemap/tree_add.html')
        form['height'] = 60
        # canopy height <= 300
        form['canopy_height'] = 550
        self.assertTemplateUsed(self.client.post("/trees/add/", form), 'treemap/tree_add.html')
        # canopy height <= height
        form['canopy_height'] = 80
        self.assertTemplateUsed(self.client.post("/trees/add/", form), 'treemap/tree_add.html')
        form['canopy_height'] = 40
        # condition in list
        form['condition'] = "Blah"
        self.assertTemplateUsed(self.client.post("/trees/add/", form), 'treemap/tree_add.html')
        form['condition'] = 1
        # canopy condition in list
        form['canopy_condition'] = "Blah"
        self.assertTemplateUsed(self.client.post("/trees/add/", form), 'treemap/tree_add.html')
        form['canopy_condition'] = 1

        response = self.client.post("/trees/add/", form)
        self.assertRedirects(response, '/trees/new/%i/' % self.u.id)

        # diameter instead
        del form['dbh_type']
        # no species
        del form['species_id']

        response = self.client.post("/trees/add/", form)
        self.assertRedirects(response, '/trees/new/%i/' % self.u.id)

        form['species_id'] = self.s1.pk

        response = self.client.post("/trees/add/", form)
        self.assertRedirects(response, '/trees/new/%i/' % self.u.id)

        response = self.client.get('/trees/new/%i/' % self.u.id)
        new_plot = response.context['plots'][2]   #first one created
        new_tree = new_plot.current_tree()
        self.assertNotEqual(new_tree, None)
        self.assertEqual(new_tree.species.genus, "testus1")
        self.assertAlmostEqual(new_tree.dbh, 2/math.pi)
        self.assertEqual(new_tree.plot, new_plot)

        # make sure the tree created benefit data and that it's not empty
        tr = TreeResource.objects.get(tree=new_tree)
        self.assertNotEqual(tr, None)
        self.assertNotEqual(tr.get_benefits()['total'], 0.0)

    def test_add_empty_tree(self):
        c = self.client
        c.login(username='jim',password='jim')
        orig_rep = User.objects.filter(username='jim')[0].reputation.reputation

        response = c.get("/plots/%i/addtree/" % self.p1_no_tree.id)
        json_status = loads(response.content)
        self.assertEquals(json_status['status'], "success")
        self.assertNotEquals(orig_rep, User.objects.filter(username='jim')[0].reputation.reputation)
        self.assertNotEquals(self.p1_no_tree.current_tree(), None)
        tree = self.p1_no_tree.current_tree()
        self.assertEquals(tree.last_updated_by.username, "jim")
        self.assertEquals(tree.species, None)


    def test_update_plot_no_pending(self):
        settings.PENDING_ON = False
        ##################################################################
        # Test edit page
        #
        # Expected POST params:
        # JSON dictionary of key-value pairs to update on a given plot object

        c = self.client

        p = self.p1_no_tree

        #
        # Test - Login redirect required
        #
        response = c.get("/plots/%s/update/" % p.pk)
        self.assertEqual(response.status_code, 302)

        login = c.login(username="jim",password="jim")

        #
        # Test - not sending a POST should fail
        #
        response = c.get("/plots/%s/update/" % p.pk)

        self.assertEqual(response.status_code, 405)

        #
        # Test - update all 'valid' fields
        #
        p.present = True
        p.width = 100
        p.length = 200
        p.type = "1"
        p.powerline_conflict_potential = "1"
        p.sidewalk_damange = "1"
        p.address_street = "100 Beach St"
        p.address_city = "Philadelphia"
        p.address_zip = "19103"
        p.save()

        response = c.post("/plots/%s/update/" % p.pk, { "width": "150", "length": "240",
                                                        "type": "4", "present": "False",
                                                        "powerline_conflict_potential": "3",
                                                        "sidewalk_damage": "2",
                                                        "address_street": "200 Lake Ave",
                                                        "address_city": "Avondale",
                                                        "address_zip": "23323" })

        p = Plot.objects.get(pk=p.pk)

        self.assertEqual(p.present, False)
        self.assertEqual(p.width, 150)
        self.assertEqual(p.length, 240)
        self.assertEqual(p.type, "4")
        self.assertEqual(p.powerline_conflict_potential, "3")
        self.assertEqual(p.sidewalk_damage, "2")
        self.assertEqual(p.address_street, "200 Lake Ave")
        self.assertEqual(p.address_city, "Avondale")
        self.assertEqual(p.address_zip, "23323")

        #
        # Test - update an invalid field and a valid field
        # verify neither gets written
        #
        p.present = True
        p.width = 120
        p.save()

        response = c.post("/plots/%s/update/" % p.pk, { "present": False,
                                                        "width": 200,
                                                        "geocoded_address": "blah" })

        self.assertEqual(p.present, True)
        self.assertEqual(p.width, 120)


        response_dict = loads(response.content)
        self.assertEqual(len(response_dict["errors"]), 1)
        self.assertTrue("geocoded_address" in response_dict["errors"][0])

        #
        # Test - validation error
        # verify neither gets written
        #
        p.present = True
        p.width = 120
        p.length = 220
        p.save()

        response = c.post("/plots/%s/update/" % p.pk, { "present": False,
                                                        "width": "200",
                                                        "length": "test" })

        self.assertEqual(p.present, True)
        self.assertEqual(p.width, 120)
        self.assertEqual(p.length, 220)

        response_dict = loads(response.content)
        self.assertEqual(len(response_dict["errors"]), 1)
        self.assertTrue("length" in response_dict["errors"][0])

    def test_update_plot_pending(self):
        settings.PENDING_ON = True
        ##################################################################
        # Test edit page
        #
        # Expected POST params:
        # -> model  - name of the model to update
        # -> id     - record id to update
        # -> update - dict of fields to update with value
        # -> parent - model/id the posted data should be added to

        c = self.client
        c.login(username='amy',password='amy')

        p = self.p1_no_tree

        #
        # Test - update all 'valid' fields and nothing
        # will be saved (instead pending records will be created)
        #
        p.present = True
        p.width = 100
        p.length = 200
        p.type = "1"
        p.powerline_conflict_potential = "1"
        p.sidewalk_damage = "1"
        p.address_street = "100 Beach St"
        p.address_city = "Philadelphia"
        p.address_zip = "19103"
        p.save()

        response = c.post("/plots/%s/update/" % p.pk, { "width": "150", "length": "240",
                                                        "type": "4", "present": "False",
                                                        "powerline_conflict_potential": "3",
                                                        "sidewalk_damage": "2",
                                                        "address_street": "200 Lake Ave",
                                                        "address_city": "Avondale",
                                                        "address_zip": "23323" })

        p = Plot.objects.get(pk=p.pk)

        self.assertTrue(len(p.get_active_pends()) > 0, 'Pends were created')

        self.assertEqual(p.present, True)
        self.assertEqual(p.width, 100)
        self.assertEqual(p.length, 200)
        self.assertEqual(p.type, "1")
        self.assertEqual(p.powerline_conflict_potential, "1")
        self.assertEqual(p.sidewalk_damage, "1")
        self.assertEqual(p.address_street, "100 Beach St")
        self.assertEqual(p.address_city, "Philadelphia")
        self.assertEqual(p.address_zip, "19103")

    def test_approve_plot_pending(self):
        settings.PENDING_ON = True

        p = self.p1_no_tree
        p.width = 100
        p.save()

        c = self.client
        c.login(username='amy', password='amy')

        response = c.post("/plots/%s/update/" % p.pk, { "width": "150"})
        self.assertEqual(response.status_code, 200, "Non 200 response when updating plot")

        p = Plot.objects.get(pk=p.pk)
        self.assertEqual(p.width, 100)

        pend = p.get_active_pends()[0]

        c.login(username='jim', password='jim')
        response = c.post("/trees/pending/%s/approve/" % pend.pk)
        self.assertEqual(response.status_code, 200, "Non 200 response when approving the pend")
        self.assertEqual(0, len(list(p.get_active_pends())), "Expected there to be zero pending edits after approval")

    def test_approve_plot_pending_with_mutiple_pending_edits(self):
        settings.PENDING_ON = True

        p = self.p1_no_tree
        p.width = 100
        p.length = 50
        p.save()

        c = self.client
        c.login(username='amy', password='amy')

        # First pending edit
        response = c.post("/plots/%s/update/" % p.pk, { "width": "150"})
        self.assertEqual(response.status_code, 200, "Non 200 response when updating plot")

        # Second pending edit to the same field
        response = c.post("/plots/%s/update/" % p.pk, { "width": "175"})
        self.assertEqual(response.status_code, 200, "Non 200 response when updating plot")

        # pending edit to a different field
        response = c.post("/plots/%s/update/" % p.pk, { "length": "25"})
        self.assertEqual(response.status_code, 200, "Non 200 response when updating plot")

        p = Plot.objects.get(pk=p.pk)
        self.assertEqual(3, len(list(p.get_active_pends())), "Expected three pending edits")

        pend = p.get_active_pends()[0]
        approved_pend_id = pend.id

        c.login(username='jim', password='jim')
        response = c.post("/trees/pending/%s/approve/" % pend.pk)
        self.assertEqual(response.status_code, 200, "Non 200 response when approving the pend")
        self.assertEqual(1, len(list(p.get_active_pends())), "Expected there to be 1 pending edits after approval, the length pend.")

        for plot_pending in PlotPending.objects.all():
            if plot_pending.id == approved_pend_id:
                self.assertEqual('approved', plot_pending.status, 'The status of the approved pend should be "approved"')
            elif plot_pending.field == 'width':
                self.assertEqual('rejected', plot_pending.status, 'The status of the non-approved width pends should be "rejected"')
            else: # plot_pending.id != approved_pend_id and plot_pending.field != 'width'
                self.assertEqual('pending', plot_pending.status, 'The status of pends not on the width field should still be "pending"')

    def test_need_permission_to_approve_pending(self):
        settings.PENDING_ON = True

        p = self.p1_no_tree
        p.width = 100
        p.save()

        c = self.client
        c.login(username='amy', password='amy')

        response = c.post("/plots/%s/update/" % p.pk, { "width": "150"})
        self.assertEqual(response.status_code, 200, "Non 200 response when updating plot")

        p = Plot.objects.get(pk=p.pk)
        self.assertEqual(p.width, 100)

        pend = p.get_active_pends()[0]

        response = c.post("/trees/pending/%s/approve/" % pend.pk)
        self.assertEqual(response.status_code, 403, "The request should have returned 403 forbidden")

##################################################################
# ogr conversion tests
#
    def assert_zip_response_contains_files(self, response, files):
        tmp_dir = tempfile.mkdtemp()
        tmp_file = os.path.join(tmp_dir, "attachment.zip")
        f = open(tmp_file, 'w')
        f.write(response.content)
        f.close()
        is_zipfile = zipfile.is_zipfile(tmp_file)
        self.assertTrue(is_zipfile, msg='error: %s does not look like a zip file.' % tmp_file)

        zf = zipfile.ZipFile(tmp_file, 'r')

        file_lists_match = (sorted(files) == sorted(zf.namelist()))
        self.assertTrue(file_lists_match,
            msg="error: file list in %s is: %s but I expected: %s" % (tmp_file, sorted(zf.namelist()), sorted(files)))

        zf.close()

        if (file_lists_match and is_zipfile): # leave the tmp file in case of an error.
            shutil.rmtree(tmp_dir)

        return


    def test_ogr_search_csv(self):
        response = self.client.get("/search/csv/")
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response['content-type'], 'application/zip')
        self.assertEqual(response['content-disposition'], 'attachment; filename=trees.zip')
        self.assertNotEqual(len(response.content), 0)
        self.assert_zip_response_contains_files(response, ["eco.csv", "trees.csv", "plots.csv", 'species.csv'])

    def test_ogr_search_kml(self):
        response = self.client.get("/search/kml/")
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response['content-type'], 'application/zip')
        self.assertEqual(response['content-disposition'], 'attachment; filename=trees.zip')
        self.assertNotEqual(len(response.content), 0)
        self.assert_zip_response_contains_files(response, ["eco.kml", "trees.kml", "plots.kml"])

    def test_ogr_search_shp(self):
        response = self.client.get("/search/shp/")
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response['content-type'], 'application/zip')
        self.assertEqual(response['content-disposition'], 'attachment; filename=trees.zip')
        self.assertNotEqual(len(response.content), 0)
        self.assert_zip_response_contains_files(response, [
                "eco.dbf", "eco.prj", "eco.shp", "eco.shx",
                "plots.dbf", "plots.prj", "plots.shp",
                "plots.shx", "trees.dbf", "trees.prj",
                ])

    def test_ogr_comments_all_csv(self):
        # Test the admin-only exports
        c = self.client
        login = c.login(username="jim",password="jim")

        response = c.get("/comments/all/csv/")
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response['content-type'], 'application/zip')
        self.assertEqual(response['content-disposition'], 'attachment; filename=comments.zip')
        self.assertNotEqual(len(response.content), 0)
        self.assert_zip_response_contains_files(response, ["comments.csv"])

    def test_ogr_users_optin_csv(self):
        # Test the admin-only exports
        c = self.client
        login = c.login(username="jim",password="jim")
        response = c.get("/users/opt-in/csv/")
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response['content-type'], 'application/zip')
        self.assertEqual(response['content-disposition'], 'attachment; filename=emails.zip')
        self.assertNotEqual(len(response.content), 0)
        self.assert_zip_response_contains_files(response, ["emails.csv"])

##################################################################
# Tree/Plot Detail tests
#

    def test_tree_details(self):
        response = self.client.get('/trees/%i/' % 9999)
        self.assertEqual(response.status_code, 404)

        response = self.client.get('/trees/%i/' % self.t3.id)
        self.assertTemplateUsed(response, 'treemap/tree_detail.html')
        self.assertIs(type(response.context['tree']), Tree)
        self.assertIs(type(response.context['plot']), Plot)
        self.assertEqual(response.context['tree'].id, self.t3.id)
        self.assertEqual(response.context['plot'].id, self.t3.plot.id)

    def test_plot_details(self):
        response = self.client.get('/plots/')
        self.assertEqual(response.status_code, 404)
        response = self.client.get('/plots/%i/' % 9999)
        self.assertEqual(response.status_code, 404)

        response = self.client.get('/plots/%i/' % self.p2_tree.id)
        self.assertTemplateUsed(response, 'treemap/tree_detail.html')
        self.assertIs(type(response.context['tree']), Tree)
        self.assertIs(type(response.context['plot']), Plot)
        self.assertEqual(response.context['tree'].id, self.p2_tree.current_tree().id)
        self.assertEqual(response.context['plot'].id, self.p2_tree.id)

        plot_format = {'format':'popup'}
        response = self.client.get('/plots/%i/' % self.p2_tree.id, plot_format)
        self.assertTemplateUsed(response, 'treemap/plot_detail_infowindow.html')
        self.assertIs(type(response.context['tree']), Tree)
        self.assertIs(type(response.context['plot']), Plot)
        self.assertEqual(response.context['tree'].id, self.p2_tree.current_tree().id)
        self.assertEqual(response.context['plot'].id, self.p2_tree.id)


    def test_get_choice_values(self):

        tree_url = ('/trees/%i/edit/choices/' % self.p2_tree.current_tree().id) + '%s/'
        plot_url = ('/plots/%i/edit/choices/' % self.p2_tree.id) + '%s/'

        response = self.client.get(tree_url % 'conditions')
        choices = loads(response.content)
        self.assertEquals(CHOICES['conditions'][0][1], choices[CHOICES['conditions'][0][0]] )
        response = self.client.get(tree_url % 'canopy_conditions')
        choices = loads(response.content)
        self.assertEquals(CHOICES['canopy_conditions'][0][1], choices[CHOICES['canopy_conditions'][0][0]] )
        response = self.client.get(tree_url % 'actions')
        choices = loads(response.content)
        self.assertEquals(CHOICES['actions'][0][1], choices[CHOICES['actions'][0][0]] )

        response = self.client.get(plot_url % 'sidewalks')
        choices = loads(response.content)
        self.assertEquals(CHOICES['sidewalks'][0][1], choices[CHOICES['sidewalks'][0][0]] )
        response = self.client.get(plot_url % 'powerlines')
        choices = loads(response.content)
        self.assertEquals(CHOICES['powerlines'][0][1], choices[CHOICES['powerlines'][0][0]] )


##################################################################
# stewardship tests
#

    def test_add_and_remove_stewardship_activities(self):
        c = self.client
        c.login(username='jim',password='jim')

        response = c.post("/trees/%s/stewardship/" % self.p2_tree.current_tree().pk, { "activity": 1, "performed_date": "01/01/2012" })
        response_dict = loads(response.content)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response_dict["success"], True)

        response = c.post("/plots/%s/stewardship/" % self.p2_tree.pk, { "activity": 1, "performed_date": "01/01/2012" })
        response_dict = loads(response.content)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response_dict["success"], True)

        p = Plot.objects.get(pk=self.p2_tree.pk)
        t = p.current_tree()
        self.assertEqual(p.plotstewardship_set.count(), 1)
        self.assertEqual(t.treestewardship_set.count(), 1)

        plot_activities = PlotStewardship.objects.filter(plot=p)
        tree_activities = TreeStewardship.objects.filter(tree=t)

        response = c.get("/trees/%s/stewardship/%s/delete/" % (t.pk, tree_activities[0].pk))
        self.assertEqual(response.status_code, 200)

        response = c.get("/plots/%s/stewardship/%s/delete/" % (p.pk, plot_activities[0].pk))
        self.assertEqual(response.status_code, 200)

        self.assertEqual(p.plotstewardship_set.count(), 0)
        self.assertEqual(t.treestewardship_set.count(), 0)

    def test_plot_delete(self):
        c = self.client
        c.login(username='jim',password='jim')

        plot_id = self.p2_tree.pk
        tree_id = self.p2_tree.current_tree().pk

        response = c.get("/plots/%d/delete/" % plot_id)
        self.assertEqual(200, response.status_code, "Expected 200 status code after delete")
        response_dict = loads(response.content)
        self.assertTrue('success' in response_dict, 'Expected a json object response with a "success" key')
        self.assertTrue(response_dict['success'], 'Expected a json object response with a "success" key set to True')

        plot = Plot.objects.get(pk=plot_id)
        tree = Tree.objects.get(pk=tree_id)

        self.assertFalse(plot.present, 'Expected "present" to be False on a deleted plot')
        for audit_trail_record in plot.history.all():
            self.assertFalse(audit_trail_record.present, 'Expected "present" to be False for all audit trail records for a deleted plot')

        self.assertFalse(tree.present, 'Expected "present" to be False on tree associated with a deleted plot')
        for audit_trail_record in tree.history.all():
            self.assertFalse(audit_trail_record.present, 'Expected "present" to be False for all audit trail records for tree associated with a deleted plot')

    def test_tree_delete(self):
        c = self.client
        c.login(username='jim',password='jim')

        plot_id = self.p2_tree.pk
        tree_id = self.p2_tree.current_tree().pk

        response = c.get("/trees/%d/delete/" % tree_id)
        self.assertEqual(200, response.status_code, "Expected 200 status code after delete")
        response_dict = loads(response.content)
        self.assertTrue('success' in response_dict, 'Expected a json object response with a "success" key')
        self.assertTrue(response_dict['success'], 'Expected a json object response with a "success" key set to True')

        plot = Plot.objects.get(pk=plot_id)
        tree = Tree.objects.get(pk=tree_id)

        self.assertTrue(plot.present, 'Expected "plot.present" to be True after deleting a tree from a plot')
        for audit_trail_record in plot.history.all():
            self.assertTrue(audit_trail_record.present, 'Expected "plot.present" to be True for all plot audit trail records after deleting the tree from the plot')

        self.assertFalse(tree.present, 'Expected "present" to be False on a deleted tree')
        for audit_trail_record in tree.history.all():
            self.assertFalse(audit_trail_record.present, 'Expected "present" to be False for all audit trail records for a deleted tree')


##################################################################
# Management page tests
#

    def test_watch_list(self):
        c = self.client
        c.login(username='jim',password='jim')

        response = c.post('/trees/watch/')
        self.assertTemplateUsed(response, 'treemap/watch_list.html')

    def test_user_rep_list(self):
        c = self.client
        c.login(username='jim',password='jim')

        response = c.get('/users/activity/')
        self.assertTemplateUsed(response, 'treemap/rep_changes.html')

    def test_comments_list(self):
        c = self.client
        c.login(username='jim',password='jim')

        response = c.get('/comments/all/')
        self.assertTemplateUsed(response, 'comments/edit.html')

    def test_flagged_comments_list(self):
        c = self.client
        c.login(username='jim',password='jim')

        response = c.get('/comments/moderate/')
        self.assertTemplateUsed(response, 'comments/edit_flagged.html')

    def test_images_list(self):
        c = self.client
        c.login(username='jim',password='jim')

        response = c.get('/images/')
        self.assertTemplateUsed(response, 'treemap/images.html')

class ExportModuleTests(TestCase):
    def setUp(self):
        self.raw_condition_query = \
            'SELECT * FROM "treemap_treeresource" '\
            'WHERE "treemap_treeresource"."tree_id" IN '\
            '(SELECT U0."id" FROM "treemap_tree" U0 '\
            'WHERE  AND U0."condition" IN (3, 5, 7))'

        self.correct_condition_query = \
            'SELECT * FROM "treemap_treeresource" '\
            'WHERE "treemap_treeresource"."tree_id" IN '\
            '(SELECT U0."id" FROM "treemap_tree" U0 '\
            'WHERE  AND U0."condition" IN (\'3\', \'5\', \'7\'))'

        self.raw_condition_characteristic_query = \
            'SELECT * FROM "treemap_tree" '\
            'WHERE ("treemap_tree"."condition" IN (2, 3, 4, 5, 6, 7) AND '\
           '"treemap_tree"."species_id" IN '\
            '(SELECT U0."id" FROM "treemap_species" U0 WHERE U0."native_status" = True ))'

        self.correct_condition_characteristic_query = \
            'SELECT * FROM "treemap_tree" '\
            'WHERE ("treemap_tree"."condition" IN (\'2\', \'3\', \'4\', \'5\', \'6\', \'7\') AND '\
           '"treemap_tree"."species_id" IN '\
            '(SELECT U0."id" FROM "treemap_species" U0 WHERE U0."native_status" = \'True\' ))'


    def test_multiple_fields_query(self):

        condition_characteristic_query = sanitize_raw_sql(self.raw_condition_characteristic_query)

        self.assertEqual(condition_characteristic_query,
                         self.correct_condition_characteristic_query)

    def test_condition_query(self):
        condition_query = sanitize_raw_sql(self.raw_condition_query)

        self.assertEqual(condition_query, self.correct_condition_query)


class RegistrationTest(TestCase):
    """
    Test local modifications to django registration

    OTM adds an additional validation method to ensure that passwords
    meet a minimum length requirement.
    """
    def test_registration_password_acceptable_length(self):
        """
        Test that a password of length six redirects to an approval page.
        """

        # generate a password of acceptable length
        password = 'x' * MINIMUM_PASSWORD_LENGTH

        response = self.client.post('/accounts/register/',
                                    {'username': 'foo',
                                     'password1': password,
                                     'password2': password,
                                     'email': 'foo@bar.com'})
        self.assertEqual(response.status_code, 302)

    def test_registration_password_too_short(self):
        """
        Test that a password of length six does not redirect to an approval
        page.
        """
        # generate a password of acceptable length
        password = 'x' * (MINIMUM_PASSWORD_LENGTH - 1)

        response = self.client.post('/accounts/register/',
                                    {'username': 'foo',
                                     'password1': password,
                                     'password2': password,
                                     'email': 'foo@bar.com'})
        self.assertEqual(response.status_code, 200)

########NEW FILE########
__FILENAME__ = test_choices
CHOICES = {
            'alerts': [
                ("1", "Needs Watering"), 
                ("2", "Needs Pruning"), 
                ("3", "Should be Removed"), 
                ("4", "Pest Or Disease Present"), 
                ("5", "Guard Should Be Removed"), 
                ("6", "Stakes And Ties Should Be Removed"), 
                ("7", "Construction Work In The Area"), 
                ("8", "Touching Wires"), 
                ("9", "Blocking Signs or Traffic Signals"), 
                ("10", "Improperly Pruned or Topped")
            ],
            'actions': [
                ("1", "test"),
                ("2", "test2")
            ],
            'projects': [
                ("1", "2010 Ash borer Treatment"),
                ("2", "test2")
            ],
            'sidewalks': [
                ("1", "Minor or No Damage"),
                ("2", "Raised More Than 3/4 Inch")
            ],
            'powerlines': [
                ("1", "Yes"),
                ("2", "No"),
                ("3", "Unknown")
            ],
            'conditions': [
                ("1", "Excellent"),
                ("2", "Very Good"),
                ("3", "Good"),
                ("4", "Fair"),
                ("5", "Poor"),
                ("6", "Critical"),
                ("7", "Dead")
            ],
            'canopy_conditions': [
                ("1", "Full - No Gaps"),
                ("2", "Small Gaps (up to 25% missing)"),
                ("3", "Moderate Gaps (up to 50% missing)"),
                ("4", "Large Gaps (up to 75% missing)"),
                ("5", "Little or None (up to 100% missing)")
            ],
            'plot_types': [
                ("1", "Well or Pit"),
                ("2", "Median"),
                ("3", "Tree Lawn"),
                ("4", "Island"),
                ("5", "Planter"),
                ("6", "Open"),
                ("7", "Other"),
                ("8", "Natural Area")
            ],
            'plot_stewardship': [
                ("1","Watering"),
                ("2","Pruning"),
                ("3","Mulching, Adding Compost or Amending Soil"),
                ("4","Removing Debris or Trash")
            ],
            'tree_stewardship': [
                ("1","Enlarging the Planting Area"),
                ("2","Adding a Guard"),
                ("3","Removing a Guard"),
                ("4","Herbaceous Planting")
            ],
            'pests': [
                ("1", "Devil of Doom"),
                ("2", "Spidermonkey")
            ]
    }



########NEW FILE########
__FILENAME__ = test_util

def set_auto_now(clazz, field_name, val):
    for field in clazz._meta.local_fields:
        if field.name == field_name:
            field.auto_now = val

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *
from views import *
from treemap.models import Neighborhood, SupervisorDistrict, Tree, TreeFavorite
from classfaves.views import CreateFavorite, DeleteFavorite, UserFavorites
from django.views.generic.simple import direct_to_template

create_favorite = CreateFavorite(TreeFavorite, Tree)
delete_favorite = DeleteFavorite(TreeFavorite, Tree)
most_recent = lambda qs: qs.order_by('-date_created')
user_favorites = UserFavorites(TreeFavorite, Tree, extra_filter=most_recent)

urlpatterns = patterns('',
    #(r'^$', direct_to_template, {'template':'under_construction.html'}),
    (r'^$', home_feeds),
    (r'^home/$', home_feeds),
    (r'^home/feeds/$', home_feeds),
    (r'^home/feeds/json/$', json_home_feeds),
    (r'^robots.txt/$', static, {'template':'robots.txt'}),

    # This is intentionally _not_ attached to the start of the url with ^
    # allowing a template rendered at any depth to always include a simple
    # <script> tag with src="treemap_settings.js" to include this global
    # settings file
    (r'treemap_settings\.js$', treemap_settings_js),

    (r'^export/csv$', get_all_csv),
    (r'^export/kmz$', get_all_kmz),

    (r'^map/$', result_map),

    (r'^geocode/$', get_geocode),
    (r'^geocode/reverse/$', get_reverse_geocode),

    (r'^neighborhoods/$', geographies, {'model' : Neighborhood}),
    (r'^neighborhoods/list/$', list_neighborhoods),
    (r'^neighborhoods/(?P<id>\d+)/$', geographies, {'model' : Neighborhood}),
    (r'^zipcodes/$', zips),
    (r'^zipcodes/(?P<id>\d+)/$', zips),

    (r'^update/$', object_update),

    (r'^choices/$', get_choices),

    url(r'^plots/(?P<plot_id>\d+)/$', plot_detail, name="treemap_plot_detail"),
    (r'^plots/(?P<plot_id>\d+)/addtree/$', plot_add_tree),
    (r'^plots/(?P<plot_id>\d+)/edit/$', plot_edit),
    (r'^plots/(?P<plot_id>\d+)/delete/$', plot_delete),
    (r'^plots/location/$', plot_location_search),
    (r'^plots/location/update/$', plot_location_update),
    (r'^plots/(?P<plot_id>\d+)/edit/choices/(?P<type_>[a-z_]*)/$', plot_edit_choices),
    (r'^plots/(?P<plot_id>\d+)/update/$', update_plot),
    (r'^plots/(?P<plot_id>\d+)/stewardship/$', add_plot_stewardship),
    (r'^plots/(?P<plot_id>\d+)/stewardship/(?P<activity_id>\d+)/delete/$', delete_plot_stewardship),

    (r'^trees/$', trees),
    (r'^trees/add/$', tree_add),
    url(r'^trees/(?P<tree_id>\d+)/edit/$', tree_edit, name="treemap_tree_edit"),
    url(r'^trees/(?P<tree_id>\d+)/photos/$', tree_add_edit_photos, name="treemap_add_edit_photos"),
    (r'^trees/(?P<tree_id>\d+)/edit/choices/(?P<type_>[a-z_]*)/$', tree_edit_choices),
    (r'^trees/(?P<tree_id>\d+)/delete/$', tree_delete),
    (r'^trees/(?P<tree_id>\d+)/deletephoto/(?P<photo_id>\d+)$', photo_delete),
    (r'^trees/(?P<tree_id>\d+)/ecosystem/$', trees),
    (r'^trees/(?P<tree_id>\d+)/stewardship/$', add_tree_stewardship),
    (r'^trees/(?P<tree_id>\d+)/stewardship/(?P<activity_id>\d+)/delete/$', delete_tree_stewardship),
    url(r'^trees/(?P<tree_id>\d+)/$', trees, name="treemap_tree_detail"),
    (r'^trees/new/$', added_today_list),
    (r'^trees/new/(?P<format>(geojson))/$', added_today_list),
    (r'^trees/new/(?P<user_id>\d+)/$', added_today_list),
    (r'^trees/new/(?P<user_id>\d+)/(?P<format>(geojson))/$', added_today_list),

    (r'^trees/pending/$', view_pends),
    (r'^trees/pending/(?P<pend_id>\d+)/approve/?$', approve_pend),
    (r'^trees/pending/(?P<pend_id>\d+)/reject/?$', reject_pend),

    (r'^trees/watch/$', watch_list),
    (r'^watch/validate/$', validate_watch),

    url(r'^trees/favorites/create/(?P<pk>\d+)/$', create_favorite, name='treeemap_favorite_create'),
    url(r'^trees/favorites/delete/(?P<pk>\d+)/$', delete_favorite, name='treeemap_favorite_delete'),
    url(r'^trees/favorites/$', user_favorites, name='treeemap_my_favorites'),
    url(r'^trees/favorites/(?P<username>[a-zA-Z0-9_-]+)/$', user_favorites, name='treeemap_user_favorites'),
    url(r'^trees/favorites/(?P<username>[a-zA-Z0-9_-]+)/geojson/$', favorites),

    (r'^species/$', species),
    (r'^species/(?P<format>(json|html|csv))/$', species),
    (r'^species/(?P<selection>(all|in-use|nearby))/$', species),
    (r'^species/(?P<selection>(all|in-use|nearby))/(?P<format>(json|html|csv))/$', species),
    (r'^species/(?P<code>[-\w]+)/$', species),

    (r'^search/$', advanced_search),
    (r'^search/geo$', geo_search),
    (r'^search/(?P<format>.*)/$', advanced_search),

    (r'^check_username/$', check_username),
    (r'^users/$', edit_users),
    (r'^users/update/$', update_users),
    (r'^users/ban/$', ban_user),
    (r'^users/activate/$', unban_user),
    (r'^users/activity/$', user_rep_changes),
    (r'^users/opt-in/$', user_opt_in_list),
    (r'^users/opt-in/(?P<format>.*)/$', user_opt_export),
    (r'^profiles/(?P<username>[a-zA-Z0-9_-]+)/deletephoto/', userphoto_delete),

    (r'^comments/flag/(?P<comment_id>[0-9]+)/$', add_flag),
    (r'^comments/moderate/$', view_flagged),
    (r'^comments/all/$', view_comments),
    (r'^comments/all/(?P<format>.*)/$', export_comments),
    (r'^comments/hide/$', hide_comment),
    (r'^comments/unflag/$', remove_flag),

    (r'^contact/$', contact),
    (r'^contact/thanks/$', static, {'template':'contact_thanks.html'}),

    url(r'^verify/$', verify_edits, name='treemap_verify_edits'),
    url(r'^verify/(?P<change_type>[a-z_]*)/(?P<change_id>\d+)/(?P<rep_dir>(up|neutral|down))', verify_rep_change),

    (r'^stewardship/', view_stewardship),

    (r'^images/$', view_images),

)

########NEW FILE########
__FILENAME__ = views
import os
import time
import sys
from time import mktime, strptime
from datetime import timedelta, datetime
import tempfile
import zipfile
from contextlib import closing
import subprocess
from operator import itemgetter, attrgetter
from itertools import chain
import simplejson
import json
from functools import wraps
from collections import namedtuple

from django.conf import settings
from django.shortcuts import render_to_response, get_object_or_404
from django.template import RequestContext
from django.http import HttpResponse, HttpResponseRedirect, HttpResponseForbidden, Http404, HttpResponseBadRequest, HttpResponseNotAllowed

from django.core.paginator import Paginator
from django.core.exceptions import ValidationError

from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.contrib.gis.feeds import Feed
from django.contrib.gis.geos import Point, GEOSGeometry

from django.views.decorators.cache import cache_page
from django.views.decorators.csrf import csrf_view_exempt
from django.views.decorators.http import require_http_methods

from django.db.models.loading import get_model
from django.db.models import Count, Sum, Q, Min, Max
from django.db import transaction

from django.contrib.gis.shortcuts import render_to_kml
from django.utils.datastructures import SortedDict
from django.utils.decorators import available_attrs
from django.core.exceptions import PermissionDenied
# formsets
from django.forms.formsets import formset_factory
from django.forms.models import inlineformset_factory, modelformset_factory

from threadedcomments.models import ThreadedComment

from search import search, DEFAULT_FILTERS
from export import sanitize_raw_sql
from models import *
from forms import *
from profiles.models import UserProfile
from profiles.utils import change_reputation_for_user
from shortcuts import render_to_geojson, get_pt_or_bbox, validate_form

from registration.signals import user_activated
from django_reputation.models import Reputation, Permission, UserReputationAction, ReputationAction

try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO

def redirect(rel):
    # Trim off slash
    if rel[0] == "/":
        rel = rel[1:]

    return HttpResponseRedirect('%s%s' % (settings.SITE_ROOT, rel))

def render_to_json(j):
    response = HttpResponse()
    response.write('%s' % simplejson.dumps(j))
    response['Content-length'] = str(len(response.content))
    response['Content-Type'] = 'text/plain'
    return response

def user_activated_callback(sender, **kwargs):
    rep = Reputation.objects.reputation_for_user(kwargs['user'])
    #print rep
user_activated.connect(user_activated_callback)

def list_neighborhoods(request):
    n = Neighborhood.objects.all().defer('geometry').order_by('state','county','name')
    ns = []
    for hood in n:
        ns.append({
            'id': hood.pk,
            'name': hood.name,
            'region_id': hood.region_id,
            'city': hood.city,
            'county': hood.county,
            'state': hood.state })

    return render_to_json(ns)

#@cache_page(60*5)
# Static pages have user information in them, so caching them doesn't work.
def static(request, template, subdir="treemap"):
    if not template:
        template = "index.html"
    template = template.rstrip("/")
    if not template.endswith(".html") and not template.endswith(".css") \
            and not template.endswith(".js") and not template.endswith(".txt"):
        template += ".html"
    if subdir:
        template = os.path.join(subdir, template)
    return render_to_response(template, RequestContext(request,{}))

def user_is_authorized_to_update_pending_edits(user):
   adv = settings.ADVANCED_USERS_CAN_ACCEPT_PENDING
   rep = user.reputation

   if user.has_perm("treemap.change_pending"):
      return True
   elif adv and rep and rep.reputation >= 1000:
      return True
   else:
      return False

def has_pending_permission_or_403_forbidden(view_func):
    @wraps(view_func, assigned=available_attrs(view_func))
    def _wrapped_view(request, *args, **kwargs):
        if user_is_authorized_to_update_pending_edits(request.user):
            return view_func(request, *args, **kwargs)
        else:
            raise PermissionDenied('%s cannot access this view because they do not have the required permission' % request.user.username)
    return _wrapped_view

def permission_required_or_403_forbidden(perm):
    """
    Decorator for views that checks that the user has the specified permission
    and raises a PermissionDenied exception if they do not, which Django coverts
    to a 403 HTTP response.
    """
    def decorator(view_func):
        @wraps(view_func, assigned=available_attrs(view_func))
        def _wrapped_view(request, *args, **kwargs):
            if request.user.has_perm(perm):
                return view_func(request, *args, **kwargs)
            else:
                raise PermissionDenied('%s cannot access this view because they do not have the %s permission' % (request.user.username, perm))
        return _wrapped_view
    return decorator

def location_map(request):
    pass

def json_home_feeds(request):
    feeds = {}
    feeds['species'] = [(s.id, s.common_name) for s in Species.objects.order_by('-tree_count')[0:4]]
    feeds['active_nhoods'] = [(n.id, n.name, n.aggregates.total_trees) for n in Neighborhood.objects.order_by('-aggregates__total_trees')[0:6]]
    return render_to_json(feeds)

def home_feeds(request):
    def total_eco_benefits():
        request = namedtuple('Data', ['GET', 'META'])({}, {'QUERY_STRING': None})
        result = advanced_search(request)

        data = json.loads(result.content)
        if 'benefits' in data:
            benefits = data['benefits']
            if 'total' in benefits:
                try:
                    return int(benefits['total'])
                except ValueError:
                    pass

        return '$0'

    feeds = {}
    recent_trees = Tree.history.filter(present=True).order_by("-last_updated")[0:3]

    feeds['recent_edits'] = unified_history(recent_trees)
    feeds['recent_photos'] = TreePhoto.objects.exclude(tree__present=False).order_by("-reported")[0:7]
    feeds['species'] = Species.objects.order_by('-tree_count')[0:4]

    #TODO: change from most populated neighborhood to most updates in neighborhood
    feeds['active_nhoods'] = Neighborhood.objects.order_by('-aggregates__total_trees')[0:6]
    feeds['eco'] = total_eco_benefits

    return render_to_response('treemap/index.html', RequestContext(request,{'feeds': feeds}))

def get_all_csv(request):
    csv_f = open(os.path.join(os.path.dirname(__file__), '../All_Trees.csv'))
    response = HttpResponse(csv_f, mimetype='text/csv')
    response['Content-Disposition'] = 'attachment; filename=All_Trees.csv'
    return response

def get_all_kmz(request):
    csv_f = open(os.path.join(os.path.dirname(__file__), '../All_Trees.kmz'))
    response = HttpResponse(csv_f, mimetype='application/vnd.google-earth.kmz')
    response['Content-Disposition'] = 'attachment; filename=All_Trees.kmz'
    return response

@require_http_methods(["GET", "HEAD"])
def get_geocode(request):
    address = request.GET.get("address")
    geocoder_name = request.GET.get("geocoder_name")
    js = {}
    if geocoder_name == "CitizenAtlas":
        from geopy_extensions.geocoders.CitizenAtlas import CitizenAtlas
        g = CitizenAtlas(format_string="%s, Washington DC", threshold=80)
    else:
        js["success"] = False
        js["error"] = "No geocoder found for name: %s" % geocoder_name
        return render_to_json(js)
    if address:
        try:
            place, (lat, lng) = g.geocode(address)
            js["success"] = True
            js["place"] = place
            js["lat"] = lat
            js["lng"] = lng
        except Exception as error:
            js["success"] = False
            js["error"] = str(error)
    else:
        js["success"] = False
        js["error"] = "No address specified"
    return render_to_json(js)

@require_http_methods(["GET", "HEAD"])
def get_reverse_geocode(request):
    lat = request.GET.get("lat")
    lng = request.GET.get("lng")
    geocoder_name = request.GET.get("geocoder_name")
    js = {}
    if geocoder_name == "CitizenAtlas":
        from geopy_extensions.geocoders.CitizenAtlas import CitizenAtlas
        g = CitizenAtlas(format_string="%s, Washington DC", threshold=80)
    else:
        js["success"] = False
        js["error"] = "No geocoder found for name: %s" % geocoder_name
        return render_to_json(js)

    if lat and lng:
        try:
            point = (lat, lng)
            place, new_point = g.reverse(point)
            js["success"] = True
            js["place"] = place
            js["lat"] = new_point[0]
            js["lng"] = new_point[1]
        except Exception as error:
            js["success"] = False
            js["error"] = str(error)
    else:
        js["success"] = False
        js["error"] = "No point specified"
    return render_to_json(js)

def get_choices(request):
    choices_list = {}
    choices_obj = settings.CHOICES

    return render_to_json(choices_obj)

#@cache_page(60*1)
def result_map(request):
    # get enviro attributes for 'selected' trees
    min_year = 1970

    min_tree_year = Tree.objects.exclude(date_planted=None).exclude(present=False).aggregate(Min("date_planted"))

    if "date_planted__min" in min_tree_year and min_tree_year['date_planted__min']:
        min_year = min_tree_year['date_planted__min'].year

    current_year = datetime.now().year

    # TODO: Fix this to include updates to treeflag objects
    min_updated = 0
    max_updated = 0

    updated = Tree.objects.exclude(last_updated=None, present=False).aggregate(Max("last_updated"), Min("last_updated"))

    if "last_updated__min" in updated and updated["last_updated__min"]:
        min_updated = mktime(updated['last_updated__min'].timetuple())

    if "last_updated__max" in updated and updated["last_updated__max"]:
        max_updated = mktime(updated['last_updated__max'].timetuple())


    minmax_plot = Tree.objects.exclude(last_updated=None, present=False).filter(plot__width__isnull=False)
    minmax_plot = minmax_plot.aggregate(Max('plot__width'), Max('plot__length'), Min('plot__width'), Min('plot__length'))

    max_plot = 0
    min_plot = sys.maxint

    if "plot__length__max" in minmax_plot and minmax_plot["plot__length__max"]:
        max_plot = minmax_plot["plot__length__max"]
    if "plot__width__max" in minmax_plot and minmax_plot["plot__width__max"]:
        max_plot = max(max_plot, minmax_plot["plot__width__max"])

    if "plot__length__min" in minmax_plot and minmax_plot["plot__length__min"]:
        min_plot = minmax_plot["plot__length__min"]
    if "plot__width__min" in minmax_plot and minmax_plot["plot__width__min"]:
        min_plot = min(min_plot, minmax_plot["plot__width__min"])

    if min_plot == sys.maxint:
        min_plot = 0

    recent_trees = Tree.objects.filter(present=True).exclude(last_updated_by__is_superuser=True).order_by("-last_updated")[0:3]
    recent_plots = Plot.objects.filter(present=True).exclude(last_updated_by__is_superuser=True).order_by("-last_updated")[0:3]
    latest_photos = TreePhoto.objects.exclude(tree__present=False).order_by("-reported")[0:8]

    return render_to_response('treemap/results.html',RequestContext(request,{
                'latest_trees': recent_trees,
                'latest_plots' : recent_plots,
                'latest_photos': latest_photos,
                'min_year': min_year,
                'current_year': current_year,
                'min_updated': min_updated,
                'max_updated': max_updated,
                'min_plot': min_plot,
                'max_plot': max_plot,
                }))


def plot_location_search(request):
    geom = get_pt_or_bbox(request.GET)
    if not geom:
        return HttpResponseBadRequest()

    distance = request.GET.get('distance', settings.MAP_CLICK_RADIUS)
    max_plots = int(request.GET.get('max_plots', 1))

    if max_plots > 500: max_plots = 500

    orig_trees, orig_plots, geog_obj, agg_object, tile_query = _build_tree_search_result(request, False)

    if geom.geom_type == 'Point':
        orig_plots = orig_plots.filter(geometry__dwithin=(geom, float(distance))).distance(geom).order_by('distance')
        if orig_plots.count() > 0:
            plots = orig_plots
        else:
            plots = Plot.objects.filter(present=True).filter(geometry__dwithin=(geom, float(distance))).distance(geom).order_by('distance')
    else:
        orig_plots = orig_plots.filter(geometry__intersects=geom)
        if orig_plots.count() > 0:
            plots = orig_plots
        else:
            plots = Plot.objects.filter(present=True).filter(geometry__intersects=geom)

    if plots:
        extent = plots.extent()
    else:
        extent = []

    if len(plots) > 0:
        plots = plots[:max_plots]

    return render_to_geojson(plots,
                             geom_field='geometry',
                             excluded_fields=['sidewalk_damage',
                             'address_city',
                             'address_street',
                             'address_zip',
                             'neighborhood',
                             'neighborhoods',
                             'length',
                             'distance',
                             'geometry',
                             'geocoded_address',
                             'last_updated_by',
                             'last_updated',
                             'present',
                             'powerline_conflict_potential',
                             'width',
                             'geocoded_lat',
                             'geocoded_lon',
                             'type',
                             'import_event',
                             'address_zip',
                             'owner_additional_properties',
                             'owner_additional_id',
                             'geocoded_accuracy',
                             'data_owner',
                             'owner_orig_id',
                             'owner_additional_id',
                             'owner_additional_properties',
                             'zipcode_id'
                             ],
                             model=Plot,
                             extent=extent)

#@cache_page(60*60*4)
def species(request, selection='all', format='html'):
    """
    return list of species
     - selection:  'in-use',  'page' or 'nearby'
     url params
     - page: # (only used with 'all' which is paginated)
     - format:  html or json (defaults to html) #todo add csv
     - nearby: return 5 closest species
    """
    page = 0

    species = Species.objects.all()
    if selection == 'in-use':
        species = species.filter(tree_count__gt=0).order_by('-tree_count')

    if selection == 'nearby':
        location = request.GET.get('location','')
        if not location:
            raise Http404
        coord = map(float,location.split(','))
        pt = Point(coord[0], coord[1])
        trees =  Tree.objects.filter(present=True).filter(plot__geometry__dwithin = (pt,.001))#.distance(pt).order_by('distance').count()
        species = Species.objects.filter(tree__in=trees)

    if selection == 'all':
        species = Species.objects.all().order_by('common_name')

    if format == 'json':
        res = [{"symbol":unicode(x.symbol or ''),
                "cname":unicode(x.common_name or ''),
                "cultivar":unicode(x.cultivar_name or ''),
                "sname":unicode(x.scientific_name or x.genus),
                "species": x.species,
                "genus": x.genus,
                "cultivar": x.cultivar_name,
                "family": x.family,
                "other_part": x.other_part_of_name,
                "id": int(x.id),
                "count": int(x.tree_count)} for x in species]
        return render_to_response('treemap/basic.json',{'json':simplejson.dumps(res)})

    if format == 'csv':
        sql_object =  [{
            "name":"species",
            "sql":str(species.query),
            "srs":'EPSG:4326'
        }]

        return ogr_conversion('CSV', sql_object, "", name="species", geo=False)

    #render to html
    return render_to_response('treemap/species.html',RequestContext(request,{
        'species' : species,
        'page' : page #so template can do next page kind of stuff
        }))

def favorites(request, username):
    faves = User.objects.get(username=username).treefavorite_set.filter(tree__present=True)
    js = [{
       'id':f.tree.id,
       'coords':[f.tree.plot.geometry.x, f.tree.plot.geometry.y]} for f in faves]
    return render_to_json(js)

def trees(request, tree_id=''):
    # testing - to match what you get in /location query and in map tiles.
    favorite = False
    recent_edits = []
    trees = Tree.objects.all()
    if tree_id:
        trees = trees.filter(pk=tree_id)

        if trees.count() == 0:
            raise Http404

        plot = trees[0].plot
        if trees[0].present == False:
            if plot.present == False:
                raise Http404
            else:
                return redirect('plots/%s/' % plot.id)

        # get the last 5 edits to each tree piece
        history = trees[0].history.order_by('-last_updated')[:5]
        history = list(chain(history, plot.history.order_by('-last_updated')[:5]))

        recent_edits = unified_history(history)

        if request.user.is_authenticated():
            favorite = TreeFavorite.objects.filter(user=request.user,
                tree=trees[0], tree__present=True).count() > 0
    else:
        #TODO: do we ever call this w/o id???
        trees = Tree.objects.filter(present=True)

    if request.GET.get('format','') == 'json':
        return render_to_geojson(trees, geom_field='geometry')
    first = None
    if trees.exists():
        first = trees[0]
    else:
        raise Http404
    if request.GET.get('format','') == 'base_infowindow':
        raise Http404
    #TODO: is this used anymore now that the plot info window is called from the map page?
    if request.GET.get('format','') == 'eco_infowindow':
        return render_to_response('treemap/tree_detail_eco_infowindow.html',RequestContext(request,{'tree':first}))
    else:
        return render_to_response('treemap/tree_detail.html',RequestContext(request,{'favorite': favorite, 'tree':first, 'plot': first.plot, 'recent': recent_edits}))

def plot_detail(request, plot_id=''):
    plots = Plot.objects.filter(present=True)

    if not plot_id:
       raise HttpResponseBadRequest

    plots = plots.filter(pk=plot_id)

    if not plots.exists():
        raise Http404

    plot = plots[0]

    if request.GET.get('format','') == 'popup':
        return render_to_response('treemap/plot_detail_infowindow.html',RequestContext(request,{
            'plot': plot,
            'tree': plot.current_tree()
        }))
    else:
        current_tree = plot.current_tree()
        history = plot.history.order_by('-last_updated')[:5]
        if current_tree:
            history = list(chain(history, current_tree.history.order_by('-last_updated')[:5]))
        recent_edits = unified_history(history)
        if request.user.is_authenticated() and current_tree:
            favorite = TreeFavorite.objects.filter(user=request.user, tree=current_tree).count() > 0
        else:
            favorite = None
        return render_to_response('treemap/tree_detail.html',RequestContext(request,{'favorite': favorite, 'tree':current_tree, 'plot': plot, 'recent': recent_edits}))

@login_required
def plot_add_tree(request, plot_id):
    user = request.user
    tree = Tree()
    plot = Plot.objects.get(pk=plot_id)
    tree.plot = plot
    import_event, created = ImportEvent.objects.get_or_create(file_name='site_add',)
    tree.import_event = import_event
    tree.last_updated_by = request.user
    tree.save()

    history = plot.history.order_by('-last_updated')[:5]
    if tree:
        history = list(chain(history, tree.history.order_by('-last_updated')[:5]))
    recent_edits = unified_history(history)

    change_reputation_for_user(user, 'add tree', tree)
    return render_to_json({'status':'success'})

def unified_history(trees, plots=[]):
    recent_edits = []
    for t in trees:
        if t._audit_change_type == "I":
            edit = "New Tree"
        else:
            if t._audit_diff:
                edit = clean_key_names(t._audit_diff)
            else:
                edit = ""
        recent_edits.append((t.last_updated_by.username, t.last_updated, edit))

    for p in plots:
        if p._audit_change_type == "I":
            edit = "New Plot"
        else:
            if p._audit_diff:
                edit = clean_key_names(p.audit_diff)
            else:
                edit = ""
        recent_edits.append((p.last_updated_by.username, p.last_updated, edit))


    # sort by the date descending
    return sorted(recent_edits, key=itemgetter(1), reverse=True)


def tree_edit_choices(request, tree_id, type_):
    tree = get_object_or_404(Tree, pk=tree_id)
    choices = settings.CHOICES[type_]
    data = SortedDict(choices)
    if hasattr(tree, type_):
        val = getattr(tree, type_)
        data['selected'] = val
    else:
        #TODO: this code looks to be defunct after switch to choices.py archetecture
        if type_ == "condition":
            sidewalks = tree.treestatus_set.filter(key="condition").order_by("-reported")
            if sidewalks.count():
                data['selected'] = str(int(sidewalks[0].value))
        if type_ == "canopy_condition":
            sidewalks = tree.treestatus_set.filter(key="canopy_condition").order_by("-reported")
            if sidewalks.count():
                data['selected'] = str(int(sidewalks[0].value))
    return HttpResponse(simplejson.dumps(data))


def plot_edit_choices(request, plot_id, type_):
    plot = get_object_or_404(Plot, pk=plot_id)
    choices = settings.CHOICES[type_]
    data = SortedDict(choices)
    if hasattr(plot, type_):
        val = getattr(plot, type_)
        data['selected'] = val
    else:
        #TODO: this code looks to be defunct after switch to choices.py archetecture
        if type_ == "sidewalk_damage":
            sidewalks = plot.treestatus_set.filter(key="sidewalk_damage").order_by("-reported")
            if sidewalks.count():
                data['selected'] = str(int(sidewalks[0].value))
    return HttpResponse(simplejson.dumps(data))

#http://docs.djangoproject.com/en/dev/topics/forms/modelforms/#model-formsets
# todo - convert into formsets, to allow adding many photos
# todo - allow editing/deleting existing photos
@login_required
def tree_add_edit_photos(request, tree_id = ''):

    tree = get_object_or_404(Tree, pk=tree_id)
    # allowing non-owners to edit
    # http://sftrees.securemaps.com/ticket/140
    #if not request.user in (tree.data_owner, tree.tree_owner) and not request.user.is_superuser:
    #    return render_to_response("not_allowed.html", {'user' : request.user, "error_message":"You are not the owner of this tree."})
    if request.method == 'POST':
        form = TreeEditPhotoForm(request.POST,request.FILES)
        if form.is_valid():
            photo = form.save(commit=False)
            photo.reported_by = request.user
            # gets saved at the right time when calling add()
            #photo.save()
            tree.treephoto_set.add(photo)
            return redirect('trees/%s/edit/' % tree.id)
    else:
        form = TreeEditPhotoForm(instance=tree)

    return render_to_response('add_edit_photos.html',RequestContext(request,{ 'instance': tree, 'form': form }))


@login_required
def tree_edit(request, tree_id = ''):

    tree = get_object_or_404(Tree, pk=tree_id, present=True)
    #if not request.user in (tree.data_owner, tree.tree_owner) and not request.user.is_superuser:
    #    return render_to_response("not_allowed.html", {'user' : request.user, "error_message":"You are not the owner of this tree."})

    reputation = {
        "base_edit": Permission.objects.get(name = 'can_edit_condition'),
        "user_rep": Reputation.objects.reputation_for_user(request.user)
    }

    return render_to_response('treemap/tree_edit.html',RequestContext(request,{ 'tree': tree, 'plot': tree.plot, 'reputation': reputation, 'user': request.user}))

@login_required
def plot_edit(request, plot_id = ''):
    plot = get_object_or_404(Plot, pk=plot_id, present=True)
    reputation = {
        "base_edit": Permission.objects.get(name = 'can_edit_condition'),
        "user_rep": Reputation.objects.reputation_for_user(request.user)
    }

    return render_to_response('treemap/tree_edit.html',RequestContext(request,{ 'tree': plot.current_tree(), 'plot': plot, 'reputation': reputation, 'user': request.user}))

@transaction.commit_on_success
def tree_delete(request, tree_id):
    tree = Tree.objects.get(pk=tree_id)
    tree.remove()

    return HttpResponse(
        simplejson.dumps({'success':True}, sort_keys=True, indent=4),
        content_type = 'text/plain'
    )

@transaction.commit_on_success
def plot_delete(request, plot_id):
    plot = Plot.objects.get(pk=plot_id)
    plot.remove()

    return HttpResponse(
        simplejson.dumps({'success':True}, sort_keys=True, indent=4),
        content_type = 'text/plain'
    )

def photo_delete(request, tree_id, photo_id):
    tree = Tree.objects.get(pk=tree_id)
    photo = TreePhoto.objects.get(pk=photo_id)
    photo.delete()

    return HttpResponse(
        simplejson.dumps({'success':True}, sort_keys=True, indent=4),
        content_type = 'text/plain'
    )

def userphoto_delete(request, username):
    profile = UserProfile.objects.get(user__username=username)
    profile.photo = ""
    profile.save()

    return HttpResponse(
        simplejson.dumps({'success':True}, sort_keys=True, indent=4),
        content_type = 'text/plain'
    )

from django.contrib.auth.decorators import permission_required

@login_required
@permission_required('auth.change_user')
def edit_users(request):
    users = User.objects.all()
    if 'username' in request.GET:
        users = users.filter(username__icontains=request.GET['username'])
    if 'name' in request.GET:
        users = users.filter(Q(first_name__icontains=request.GET['name']) | Q(last_name__icontains=request.GET['name']) | Q(email__icontains=request.GET['name']))
    if 'group' in request.GET:
        g = Group.objects.filter(name__icontains=request.GET['group'])
        if g.count() == 1:
            users = users.filter(groups=g)
        else:
            users = users.filter(groups__in=g)

    groups = Group.objects.all()
    return render_to_response('treemap/user_edit.html',RequestContext(request, {'users': users, 'groups': groups}))

@permission_required('auth.change_user')
def update_users(request):
    response_dict = {}
    if request.method == 'POST':
        post = simplejson.loads(request.raw_post_data)

    if post.get('rep_total'):
        id = post.get('user_id')
        user = User.objects.get(pk=id)
        user.reputation.reputation = int(post.get('rep_total'))
        user.reputation.save()
        response_dict['success'] = True
    elif post.get('group_id'):
        id = post.get('user_id')
        gid = post.get('group_id')
        user = User.objects.get(pk=id)
        try:
            group = Group.objects.get(pk=gid)
            user.groups.clear()
            user.groups.add(group)
            rep = Reputation.objects.reputation_for_user(user)
            #increase rep if now part of an 'admin' group and too low
            if user.has_perm('django_reputation.change_reputation') and rep.reputation < 1000:
                user.reputation.reputation = 1001
                user.reputation.save()
                response_dict['new_rep'] = user.reputation.reputation
                response_dict['user_id'] = user.id
        except Exception:
            user.groups.clear()

        response_dict['success'] = True
    else:
        raise Http404

    return HttpResponse(
        simplejson.dumps(response_dict, sort_keys=True, indent=4),
        content_type = 'text/plain'
    )

@permission_required('auth.change_user')
def user_opt_in_list(request):
    users = UserProfile.objects.filter(active=True)
    if 'username' in request.GET:
        users = users.filter(user__username__icontains=request.GET['username'])
    if 'email' in request.GET:
        users = users.filter(user__email__icontains=request.GET['email'])
    if 'status' in request.GET:
        update_bool = request.GET['status'].lower() == "true"
        users = users.filter(updates=update_bool)

    return render_to_response('treemap/admin_emails.html',RequestContext(request, {'users': users}))

@permission_required('auth.change_user')
def user_opt_export(request, format):
    users = UserProfile.objects.filter(active=True)
    where = []
    if 'username' in request.GET:
        users = users.filter(user__username__icontains=request.GET['username'])
        where.append(" a.username ilike '%" + request.GET['username'] + "%' ")
    if 'email' in request.GET:
        users = users.filter(user__email__icontains=request.GET['email'])
        where.append(" a.email ilike '%" + request.GET['email'] + "%' ")
    if 'status' in request.GET:
        update_bool = request.GET['status'].lower() == "true"
        users = users.filter(updates=update_bool)
        where.append(" b.updates is " + str(update_bool) + " ")

    sql = "select a.username, a.email, case when b.updates = 't' then 'True' when b.updates = 'f' then 'False' end as \"opt-in\" from auth_user as a, profiles_userprofile as b where b.user_id = a.id"
    if len(where) > 0:
        sql = sql + " and " + ' and '.join(where)

    return ogr_conversion('CSV', [{'name':'emails', 'sql':sql}], name="emails", geo=False)

@permission_required('auth.change_user')
def ban_user(request):
    response_dict = {}
    if request.method == 'POST':
        post = simplejson.loads(request.raw_post_data)
        user = User.objects.get(pk=post.get('user_id'))
        user.is_active = False
        user.save()
        response_dict['user_id'] = user.id

    response_dict['success'] = True

    return HttpResponse(
        simplejson.dumps(response_dict, sort_keys=True, indent=4),
        content_type = 'text/plain'
    )

@permission_required('auth.change_user')
def unban_user(request):
    response_dict = {}
    if request.method == 'POST':
        post = simplejson.loads(request.raw_post_data)
        user = User.objects.get(pk=post.get('user_id'))
        user.is_active = True
        user.save()
        response_dict['user_id'] = user.id

    response_dict['success'] = True

    return HttpResponse(
        simplejson.dumps(response_dict, sort_keys=True, indent=4),
        content_type = 'text/plain'
    )

def get_tree_pend_or_plot_pend_by_id_or_404_not_found(pend_id):
    try:
        pend = TreePending.objects.get(pk=pend_id)
        model_name = 'Tree'
    except TreePending.DoesNotExist:
        pend = None
        model_name = None

    if not pend:
        try:
            pend = PlotPending.objects.get(pk=pend_id)
            model_name = 'Plot'
        except PlotPending.DoesNotExist:
            pend = None
            model_name = None

    if not pend:
        raise Http404

    return pend, model_name

@login_required
@has_pending_permission_or_403_forbidden
def approve_pend(request, pend_id):
    pend, model = get_tree_pend_or_plot_pend_by_id_or_404_not_found(pend_id)

    pend.approve_and_reject_other_active_pends_for_the_same_field(request.user)

    if model == 'Tree':
        change_reputation_for_user(pend.submitted_by, 'edit tree', pend.tree, change_initiated_by_user=pend.updated_by)
    else: # model == 'Plot'
        change_reputation_for_user(pend.submitted_by, 'edit plot', pend.plot, change_initiated_by_user=pend.updated_by)

    return HttpResponse(
        simplejson.dumps({'success': True, 'pend_id': pend_id}, sort_keys=True, indent=4),
        content_type = 'text/plain'
    )

@login_required
@has_pending_permission_or_403_forbidden
def reject_pend(request, pend_id):
    pend, model = get_tree_pend_or_plot_pend_by_id_or_404_not_found(pend_id)
    pend.reject(request.user)
    return HttpResponse(
        simplejson.dumps({'success': True, 'pend_id': pend_id}, sort_keys=True, indent=4),
        content_type = 'text/plain'
    )

@login_required
@has_pending_permission_or_403_forbidden
def view_pends(request):
    npk = None
    nname = None

    tree_pends = TreePending.objects.all()
    plot_pends = PlotPending.objects.all()
    if 'username' in request.GET:
        u = User.objects.filter(username__icontains=request.GET['username'])
        tree_pends = tree_pends.filter(submitted_by__in=u)
        plot_pends = plot_pends.filter(submitted_by__in=u)
    if 'address' in request.GET:
        tree_pends = tree_pends.filter(tree__plot__address_street__icontains=request.GET['address'])
        plot_pends = plot_pends.filter(address_street__icontains=request.GET['address'])
    if 'nhood' in request.GET:
        try:
            n = Neighborhood.objects.get(pk=int(request.GET['nhood']))
        except ValueError, e:
            n = Neighborhood.objects.get(name=request.GET['nhood'])

        nname = n.name
        npk = n.pk
        tree_pends = tree_pends.filter(tree__plot__neighborhood=n)
        plot_pends = plot_pends.filter(plot__neighborhood=n)
    if 'status' in request.GET:
        tree_pends = tree_pends.filter(status=request.GET['status'])
        plot_pends = plot_pends.filter(status=request.GET['status'])

    pends = list(chain(tree_pends, plot_pends))
    pends.sort(key=lambda z: z.updated)
    return render_to_response(
        'treemap/admin_pending.html',
        RequestContext(request,
                       {'pends': pends,
                        'neighborhood_id': npk,
                        'neighborhood': nname }))

@login_required
@permission_required('auth.change_user')
def view_stewardship(request):
    tree_activity = TreeStewardship.objects.all()
    plot_activity = PlotStewardship.objects.all()
    if 'username' in request.GET:
        u = User.objects.filter(username__icontains=request.GET['username'])
        tree_activity = tree_activity.filter(performed_by__in=u)
        plot_activity = plot_activity.filter(performed_by__in=u)
    if 'address' in request.GET:
        tree_activity = tree_activity.filter(tree__plot__address_street__icontains=request.GET['address'])
        plot_activity = plot_activity.filter(plot__address_street__icontains=request.GET['address'])
    if 'nhood' in request.GET:
        n = Neighborhood.objects.filter(name=request.GET['nhood'])
        tree_activity = tree_activity.filter(tree__plot__neighborhood=n)
        plot_activity = plot_activity.filter(plot__neighborhood=n)
    if 'status' in request.GET:
        tree_activity = tree_activity.filter(activity=request.GET['status'])
        plot_activity = plot_activity.filter(activity=request.GET['status'])
    if 'target' in request.GET:
        if request.GET['target'] == 'plot':
            tree_activity = TreeStewardship.objects.none()
        if request.GET['target'] == 'tree':
            plot_activity = PlotStewardship.objects.none()

    activities = list(chain(tree_activity, plot_activity)) # chain comes from itertools
    activities = sorted(activities, key=attrgetter('performed_date'))
    return render_to_response('treemap/admin_stewardship.html',RequestContext(request,{'activities': activities}))

@login_required
@transaction.commit_manually
@csrf_view_exempt
def object_update(request):
    """
    Generic record and row based update view.

    Accepts POST data only, consisting of:

      model: model name,
      id: record id,
      update: dict of fields to update with value,
      parent: model/id the posted data should be added to

    """

    response_dict = {'success': False, 'errors': []}

    parent_instance = None
    post = {}

    if request.method == 'POST':
        if request.META['SERVER_NAME'] == 'testserver':
            post = request.POST
        else:
            post = simplejson.loads(request.raw_post_data)
    else:
        response_dict['errors'].append('Please POST data')

    app_models = {'UserProfile':'profiles','User':'auth'}

    if post.get('model'):
        mod_name = post['model']
        model_object = get_model(app_models.get(mod_name, 'treemap'),mod_name)
        if not model_object:
            response_dict['errors'].append('Model %s not found' % post['model'])
        else:
            if post.get('id'):
                # assume if passed an 'id' we are
                # updating a model instance/record
                instance = model_object._default_manager.get(pk=int(post['id']))
                if not instance:
                    response_dict['errors'].append('Record id %s not found' % int(post['id']))
            else:
                # if not passed an 'id' assume we
                # are creating a new instance/record
                instance = model_object()

            update = post.get('update')
            delete = post.get('delete')
            parent = post.get('parent')

            if delete:
                response_dict['delete'] = {}
                parent_object = get_model('treemap',parent['model'])
                parent_instance = parent_object._default_manager.get(pk=int(parent['id']))
                all = model_object.objects.filter(tree=parent_instance)
                exc = []
                if request.user.is_superuser:
                    all = all.filter(reported_by=request.user)
                for k,v in delete.items():
                    all = all.filter(**{str(k):v})
                ids = [x.id for x in all]
                if all.count():
                    all.delete()
                    response_dict['delete']['ids'] = ids



            if update:
                response_dict['update'] = {}

                is_plot_or_tree = post['model'] == "Tree" or post['model'] == "Plot"

                # Short circuit pending updates here
                if is_plot_or_tree and requires_pending_record(instance, request.user):
                    for k,v in update.items():
                        fld = instance._meta.get_field(k.replace('_id',''))
                        try:
                            cleaned = fld.clean(v,instance)
                            response_dict['pending'] = 'true'
                            response_dict['update']['old_' + k] = getattr(instance,k).__str__()
                            response_dict['update'][k] = 'Pending'

                            if post['model'] == "Tree":
                                pend = TreePending(tree=instance)
                            else: # post['model'] == "Plot":
                                pend = PlotPending(plot=instance)
                                if k == 'geometry':
                                    pend.geometry = cleaned
                                else:
                                    # Omit the geometry so that
                                    # PlotPending.approve will use
                                    # the text value
                                    pend.geometry = None

                            pend.field = k
                            pend.value = cleaned
                            pend.submitted_by = request.user
                            pend.status = 'pending'
                            pend.updated_by = request.user

                            if k == 'species_id':
                                pend.text_value = Species.objects.get(id=v).scientific_name

                            for field in instance._meta.fields:
                                if str(field.name) == str(fld.name):
                                    for choice in field.choices:
                                        if str(choice[0]) == str(cleaned):
                                            pend.text_value = choice[1]
                                            break
                                    break

                            pend.save()

                        except ValidationError,e:
                            response_dict['errors'].append(e.messages[0])
                        except Exception,e:
                            response_dict['errors'].append('Error editing %s: %s' % (k,str(e)))
                        if len(response_dict['errors']):
                            transaction.rollback()
                        else:
                            transaction.commit()
                            response_dict['success'] = True

                    return HttpResponse(
                            simplejson.dumps(response_dict, sort_keys=True, indent=4),
                            content_type = 'text/plain'
                            )

                for k,v in update.items():
                    if hasattr(instance,k):
                        #print k,v
                        fld = instance._meta.get_field(k.replace('_id',''))
                        try:
                            if k == 'species_id':
                                response_dict['update']['old_' + k] = instance.get_scientific_name()
                                instance.set_species(v,commit=False)
                            else:
                                # old value for non-status objects only, status objects return None
                                # and are handled after parent model is set
                                response_dict['update']['old_' + k] = getattr(instance,k).__str__()
                                cleaned = fld.clean(v,instance)
                                setattr(instance,k,cleaned)
                        except ValidationError,e:
                            response_dict['errors'].append(e.messages[0])
                        except Exception,e:
                            response_dict['errors'].append('Error editing %s: %s' % (k,str(e)))

                        if hasattr(instance,'display'):
                            value = getattr(instance,'display')
                        elif hasattr(instance,'get_%s_display' % k):
                            value = getattr(instance,'get_%s_display' % k)()
                        else:
                            value = getattr(instance, k)

                        if isinstance(value,datetime):
                            value = value.strftime('%b %d %Y')
                        elif not isinstance(value, basestring):
                            value = unicode(value)

                        if k == "key" and value == "None":
                            for s in status_choices:
                                if v == s[0]: value = s[1]
                        response_dict['update'][k] = value
                    else:
                        response_dict['errors'].append("%s does not have a '%s' attribute" % (instance,k))

            # todo - try to make this more generic...
            # needs to be set on Tree model
            if hasattr(instance,'last_updated_by_id'):
                instance.last_updated_by = request.user
            # needs to be set on models inheriting from TreeItem
            if hasattr(instance,'reported_by_id'):
                instance.reported_by = request.user

            if parent and not delete:
                parent_object = get_model('treemap',parent['model'])
                if not parent_object:
                    response_dict['errors'].append('Parent model "%s" not found' % parent['model'])
                else:
                    # TODO - can't assume parent is Tree model...
                    parent_instance = parent_object._default_manager.get(pk=int(parent['id']))
                    if not parent_instance:
                        response_dict['errors'].append('Parent object #%s not found' % parent['id'])
                    else:
                        parent_instance.last_updated = datetime.now()
                        parent_instance.last_updated_by = request.user
                        try:
                            # get the foreignkey related manager of the parent to be able to
                            # add the new instance back to the parent object
                            # eg. Tree.objects.all()[1].treestatus_set
                            set = getattr(parent_instance,post['model'].lower() + '_set')
                            set.add(instance)
                            #if response_dict['update'].has_key('old_value'):
                            #    history = model_object.history.filter(tree__id__exact=instance.tree.id).filter(key__exact=instance.key).filter(_audit_change_type__exact="U").order_by('-reported')
                            #    if history.count() == 0:
                            #        history = model_object.history.filter(tree__id__exact=instance.tree.id).filter(key__exact=instance.key).filter(_audit_change_type__exact="I").order_by('reported')
                            #    if history.count() > 0:
                            #        if isinstance(history[0].value, datetime):
                            #            response_dict['update']['old_value'] = history[0].value.strftime("%b %d %Y")
                            #        else:
                            #            response_dict['update']['old_value'] = history[0].value.__str__()
                        except Exception, e:
                            response_dict['errors'].append('Error setting related obj: %s: %s' % (sys.exc_type,str(e)))

            # finally save the instance...
            try:
                if not delete:
                    instance._audit_diff = simplejson.dumps(response_dict["update"])
                    instance.save()
                    if post['model'] in  ["Tree", "TreeFlags", "Plot"] :
                        if post['model'] == 'Plot':
                            action_name = 'edit plot'
                        else:
                            action_name = 'edit tree'
                        change_reputation_for_user(request.user, action_name, instance)
                    if hasattr(instance, 'validate_all'):
                        instance.validate_all()
                if parent_instance:
                    #pass
                    parent_instance._audit_diff = simplejson.dumps(response_dict["update"])
                    parent_instance.save()
                    #print "instance parent save"
                    #print parent_instance, instance
            except Exception, e:
                response_dict['errors'].append('Related - %s: %s' % (sys.exc_type,str(e)))

    if len(response_dict['errors']):
        transaction.rollback()
    else:
        transaction.commit()
        response_dict['success'] = True

    return HttpResponse(
            simplejson.dumps(response_dict, sort_keys=True, indent=4),
            content_type = 'text/plain'
            )


def create_pending_records(plot_base, plot_new_flds, user):
    pends = []
    for fld, new_field_val in plot_new_flds.iteritems():
        if getattr(plot_base, fld) is not new_field_val:
            pend = PlotPending(plot=plot_base, field=fld, value=new_field_val, status='pending')
            pend.submitted_by = pend.updated_by = user

            if fld == 'geometry':
                pend.geometry = plot_new_flds

            for field in Plot._meta.fields:
                if str(field.name) == str(fld):
                    for choice in field.choices:
                        if str(choice[0]) == str(new_field_val):
                            pend.text_value = choice[1]
                            break
                    break

            pends.append(pend)

    return pends

def parse_post(request):
    if request.META['SERVER_NAME'] == 'testserver':
        post = request.POST
    else:
        post = simplejson.loads(request.raw_post_data)

    return post

@login_required
@csrf_view_exempt
def add_tree_stewardship(request, tree_id):
    """ Add stewardship activity to a tree """
    response_dict = {'success': False, 'errors': []}

    post = {}
    if request.method != 'POST':
        return HttpResponseNotAllowed(['POST'])

    post = parse_post(request)
    tree = get_object_or_404(Tree, pk=tree_id)

    try:
        date = datetime.strptime(post['performed_date'],'%m/%d/%Y')
        activity = TreeStewardship(performed_by=request.user, tree=tree, activity=post['activity'], performed_date=date)
        activity.save()
        change_reputation_for_user(request.user, 'add stewardship', activity)
    except ValidationError, e:
        if hasattr(e, 'message_dict'):
            for (fld,msgs) in e.message_dict.items():
                msg = reduce(lambda (a,b): a + b, msgs)
                response_dict["errors"].append("%s: %s" % (fld, msg))
        else:
            response_dict["errors"] += e.messages

    if len(response_dict["errors"]) == 0:
        response_dict['success'] = True
        response_dict['update'] = {}
        response_dict['update']['activity'] = activity.activity
        response_dict['update']['performed_date'] = activity.performed_date.strftime("%m/%d/%Y")

    return HttpResponse(
            simplejson.dumps(response_dict),
            content_type = 'application/json')

@login_required
@csrf_view_exempt
def add_plot_stewardship(request, plot_id):
    """ Add stewardship activity to a plot """
    response_dict = {'success': False, 'errors': []}

    post = {}
    if request.method != 'POST':
        return HttpResponseNotAllowed(['POST'])

    post = parse_post(request)
    plot = get_object_or_404(Plot, pk=plot_id)

    try:
        date = datetime.strptime(post['performed_date'],'%m/%d/%Y')
        activity = PlotStewardship(performed_by=request.user, plot=plot, activity=post['activity'], performed_date=date)
        activity.save()
        change_reputation_for_user(request.user, 'add stewardship', activity)
    except ValidationError, e:
        if hasattr(e, 'message_dict'):
            for (fld,msgs) in e.message_dict.items():
                msg = reduce(lambda (a,b): a + b, msgs)
                response_dict["errors"].append("%s: %s" % (fld, msg))
        else:
            response_dict["errors"] += e.messages

    if len(response_dict["errors"]) == 0:
        response_dict['success'] = True
        response_dict['update'] = {}
        response_dict['update']['activity'] = activity.activity
        response_dict['update']['performed_date'] = activity.performed_date.strftime("%m/%d/%Y")

    return HttpResponse(
            simplejson.dumps(response_dict),
            content_type = 'application/json')

@login_required
@csrf_view_exempt
def delete_tree_stewardship(request, tree_id, activity_id):
    activity = get_object_or_404(TreeStewardship, pk=activity_id)
    activity.delete()
    change_reputation_for_user(request.user, 'remove stewardship', activity)
    return HttpResponse(
            simplejson.dumps({'success': True}),
            content_type = 'application/json')

@login_required
@csrf_view_exempt
def delete_plot_stewardship(request, plot_id, activity_id):
    activity = get_object_or_404(PlotStewardship, pk=activity_id)
    activity.delete()
    change_reputation_for_user(request.user, 'remove stewardship', activity)
    return HttpResponse(
            simplejson.dumps({'success': True}),
            content_type = 'application/json')

def user_is_manager(user):
    return user.has_perm('auth.change_user')

def requires_pending_record(plot_or_tree, user):
    created_by_manager = plot_or_tree.was_created_by_a_manager
    user_is_not_a_manager = not user_is_manager(user)

    plot_or_tree_created_by_user = plot_or_tree.created_by == user

    if settings.PENDING_ON and not plot_or_tree_created_by_user:
       if settings.PENDING_REQUIRED_FOR_PUBLIC_EDITING_PUBLIC_TREES:
          # trigger for *all* non-manager edits
          return user_is_not_a_manager
       else:
          # only trigger if the tree was created by a manager
          return created_by_manager and user_is_not_a_manager
    else:
       return False

@login_required
@csrf_view_exempt
def update_plot(request, plot_id):
    """ Update items for a given plot """
    response_dict = {'success': False, 'errors': []}
    valid_fields = ["present","width","length","type","powerline_conflict_potential",
                    "sidewalk_damage","address_street","address_city","address_zip",
                    "owner_additional_id" ]

    post = {}

    if request.method != 'POST':
        return HttpResponseNotAllowed(['POST'])

    post = parse_post(request)
    plot = get_object_or_404(Plot, pk=plot_id)

    # Update fields
    for k,v in post.items():
        if hasattr(plot, k) and k in valid_fields:
            setattr(plot, k, v)
        else:
            response_dict["errors"].append("Unknown or invalid update field: %s" % k)

    pendingused = False

    try:
        plot.validate()

        if requires_pending_record(plot, request.user):
            pendingused = True
            # Get a clean plot object
            plot = get_object_or_404(Plot, pk=plot_id)

            for r in create_pending_records(plot, post, request.user):
                r.save()
        else:
            plot.last_updated_by = request.user

            # finally save the instance...
            plot._audit_diff = simplejson.dumps(post)
            plot.save()
            change_reputation_for_user(request.user, 'edit plot', plot)

    except ValidationError, e:
        if hasattr(e, 'message_dict'):
            for (fld,msgs) in e.message_dict.items():
                msg = reduce(lambda (a,b): a + b, msgs)
                response_dict["errors"].append("%s: %s" % (fld, msg))
        else:
            response_dict["errors"] += e.messages

    if len(response_dict["errors"]) == 0:
        response_dict['success'] = True
        response_dict['update'] = {}

        plot = get_object_or_404(Plot, pk=plot_id)
        for k,v in post.items():
            response_dict['update'][k] = get_attr_or_display(plot,k)
            if pendingused:
                response_dict['update'][k] = "Pending"

    return HttpResponse(
            simplejson.dumps(response_dict),
            content_type = 'application/json')

#TODO: This should be fixed by providing a "__dict__" method on the plot
def get_attr_or_display(model, attr):
    disp = "get_%s_display" % attr
    if hasattr(model, disp):
        return getattr(model, disp)()
    else:
        return getattr(model, attr)

#for auto reverse-geocode saving of new address, from search page map click
def plot_location_update(request):
    response_dict = {}
    post = simplejson.loads(request.raw_post_data)
    plot = Plot.objects.filter(pk=post.get('plot_id'))[0]
    plot.address_street = post.get('address').split(',')[0]
    plot.geocoded_address = post.get('address')
    plot.address_city = post.get('city')
    plot.quick_save()

    response_dict['success'] = True

    return HttpResponse(
        simplejson.dumps(response_dict, sort_keys=True, indent=4),
        content_type = 'text/plain'
    )

@login_required
def tree_add(request, tree_id = ''):

    if request.method == 'POST':
        form = TreeAddForm(request.POST,request.FILES)

        if validate_form(form, request):
            new_tree = form.result

            change_reputation_for_user(request.user, 'add tree', new_tree)

            if form.cleaned_data.get('target') == "add":
                form = TreeAddForm()
                messages.success(request, "Your tree was successfully added!")
            elif form.cleaned_data.get('target') == "addsame":
                messages.success(request, "Your tree was successfully added!")
                pass
            elif form.cleaned_data.get('target') == "view":
                return redirect("trees/new/%i/" % request.user.id)
            elif form.cleaned_data.get('target') == "edit":
                return redirect("plots/%i/edit/" % new_tree.id)
            else:
                return redirect("plots/%i/" % new_tree.id)
    else:
        form = TreeAddForm()
    return render_to_response('treemap/tree_add.html', RequestContext(request,{
        'user' : request.user,
        'form' : form }))

def added_today_list(request, user_id=None, format=None):
    user = None
    past_date = timedelta(hours=24)
    start_date = datetime.now() - past_date
    end_date = datetime.now()
    new_plots = Plot.history.filter(present=True).filter(_audit_change_type__exact='I').filter(_audit_timestamp__range=(start_date, end_date))
    if user_id:
        user = User.objects.get(pk=user_id)
        new_plots = new_plots.filter(last_updated_by=user)
    plots = []
    for plot in new_plots:
        plots.append(Plot.objects.get(pk=plot.id))
    if format == 'geojson':
        plot_json = [{
           'id':plot.id,
           'coords':[plot.geometry.x, plot.geometry.y]} for plot in plots]
        return render_to_json(plot_json)
    return render_to_response('treemap/added_today.html', RequestContext(request,{
        'plots' : plots,
        'user': user}))

def _build_tree_search_result(request, with_benefits=True):
    s = search(request.GET, DEFAULT_FILTERS)

    trees = s.trees
    plots = s.plots
    tile_query = s.tile_query
    geog_obj = s.geog_obj

    agg_object = None

    if with_benefits:
        q = request.META['QUERY_STRING'] or ''
        cached_search_agg = AggregateSearchResult.objects.filter(key=q)
        if cached_search_agg.exists() and cached_search_agg[0].ensure_recent(trees.count()):
            agg_object = cached_search_agg[0]
        else:
            fields = [x.name for x in ResourceSummaryModel._meta.fields if not x.name in ['id','aggregatesummarymodel_ptr','key','resourcesummarymodel_ptr','last_updated']]
            with_out_resources = trees.filter(treeresource=None).count()
            with_resources = trees.count() - with_out_resources

            agg_object = AggregateSearchResult(key=q)
            agg_object.total_trees = trees.count()
            agg_object.total_plots = plots.count()
            for f in fields:
                fn = 'treeresource__' + f
                s = trees.aggregate(Sum(fn))[fn + '__sum'] or 0.0
                if settings.EXTRAPOLATE_WITH_AVERAGE and with_resources > 0:
                    avg = float(s)/with_resources
                    s += avg * with_out_resources
                setattr(agg_object,f,s)
            try:
                agg_object.save()
            except:
                # another thread has already likely saved the same object...
                pass

    return trees, plots, geog_obj, agg_object, ' AND '.join(tile_query)



def zip_files(file_paths,archive_name):
        buffer = StringIO()
        with closing(zipfile.ZipFile(buffer, 'w', zipfile.ZIP_DEFLATED)) as z:
            for path in file_paths:
                for root, dirs, files in os.walk(path):
                    for f in files:
                        abs_file = os.path.join(root, f)
                        zipf = abs_file[len(path) + len(os.sep):]
                        zipf = zipf.replace('sql_statement', root.split("/")[-1]) # should be trees or plots
                        z.write(abs_file, zipf)

        z.close()
        buffer.flush()
        zip_stream = buffer.getvalue()
        buffer.close()
        return zip_stream

def ogr_conversion(output_type, named_sql, extension=None, name="trees", geo=True):
    """
    given  an output type such as CSV, "ESRI ShapeFile" or KML

    plus a list of named_sql in the form of
       named_sql =  [{
            "name":"trees",
            "sql":"SELECT * from treemap_tree...",
            "srs":'EPSG:4326' #optional, srs default=EPSG:4236
        },
         {
          "name":"plots",
          "sql":"SELECT * from treemap_plot...",
          "srs":'EPSG:4326'
         }]

    renders a response with the appropriate zip file attachment.

    requires gdal/ogr2ogr
    """

    dbsettings = settings.DATABASES['default']
    host = dbsettings['HOST']
    port = dbsettings['PORT']
    if host == '':
        host = 'localhost'
    if port == '':
        port = 5432

    tmp_dirs = []
    done = 0
    for s in named_sql:
        sql_name = s["name"]
        sql = s["sql"]
        srs = s["srs"] if "srs" in s else 'EPSG:4326'

        tmp_dir = os.path.join(tempfile.mkdtemp(), sql_name)
        tmp_dirs.append(tmp_dir)

        if extension != None:
            os.mkdir(tmp_dir)
            tmp_name = os.path.join(tmp_dir, sql_name + "." + extension)
        else:
            tmp_name = tmp_dir

        #command is about to get the db password, careful.
        command = ['ogr2ogr', '-sql', sql, '-a_srs', srs, '-f', output_type, tmp_name,
            'PG:dbname=%s host=%s port=%s password=%s user=%s' % (dbsettings['NAME'], host, port,
            dbsettings['PASSWORD'], dbsettings['USER'])]

        if output_type == 'CSV' and geo:
            command.append('-lco')
            command.append('GEOMETRY=AS_WKT')
        elif output_type == 'ESRI Shapefile' and (sql_name == 'trees'):
            command.append('-nlt')
            command.append('NONE')
        elif output_type == 'ESRI Shapefile' and (sql_name == 'plots'):
            command.append('-nlt')
            command.append('POINT')

        done = None

        try:
            done = subprocess.call(command)
        except:
            raise Exception("ogr2ogr2 command failed (are the gdal binaries installed?)")

        if done != 0:
            return render_to_json({'status':'error'})

    zipfile = zip_files(tmp_dirs, name)

    response = HttpResponse(zipfile, mimetype='application/zip')
    response['Content-Disposition'] = 'attachment; filename=' + name + '.zip'
    return response

#TODO: not sure this is used anymore
def geo_search(request):
    """
    Given a simple polygon in format: x1 y1,x2 y2,x3 y3,...,x1 y1
    return basic info about trees
    """
    if 'polygon' not in request.REQUEST:
        h = HttpResponse("Expected 'polygon' parameter")
        h.status_code = 500
        return h

    polyWkt = "POLYGON ((%s))" % request.REQUEST['polygon']

    try:
        poly = GEOSGeometry(polyWkt)
    except ValueError:
        h = HttpResponse("Polygon input must be in the format: 'x1 y1,x2 y2,x3 y3,x1 y1'")
        h.status_code = 500
        return h

    #TODO - Generate count?
    trees = Tree.objects.filter(plot__geometry__within=poly, species__isnull=False, dbh__isnull=False).all()

    pruned = []
    for tree in trees:
        prune = { "id": tree.pk,
                  "dbh": tree.dbh }

        if tree.species and tree.dbh:
            prune["itree_code"] = tree.species.itree_code,
            prune["species"] = tree.species.scientific_name

            pruned.append(prune)

    json = { "count": len(trees), "trees": pruned }

    jsonstr = simplejson.dumps(json)

    if "callback" in request.REQUEST:
        jsonstr = "%s(%s);" % (request.REQUEST["callback"], jsonstr)

    return HttpResponse(jsonstr, mimetype='application/json')

def advanced_search(request, format='json'):
    """
        formats: json (default), geojson, shp, kml, csv
    """
    response = {}

    trees, plots, geog_object, agg_object, tile_query = _build_tree_search_result(request, True)
    tree_count = trees.count()
    plot_count = plots.count()
    if tree_count == 0:
        tree_query = "SELECT * FROM treemap_tree LIMIT 0";
        eco_query = "SELECT * FROM treemap_treeresource LIMIT 0";
    else:
        tree_query = sanitize_raw_sql(str(trees.query))
        eco_query = sanitize_raw_sql(str(TreeResource.objects.filter(tree__in=trees).query))

    if plot_count == 0:
        plot_query = "SELECT * FROM treemap_plot LIMIT 0";
    else:
        plot_query = sanitize_raw_sql(str(plots.query))

    species_query = "SELECT * FROM treemap_species order by id asc"

    trees   = { 'name': 'trees', 'sql': tree_query }
    plots   = { 'name': 'plots', 'sql': plot_query }
    species = { 'name': 'species', 'sql': species_query }
    eco     = { 'name': 'eco', 'sql': eco_query }

    if format == "shp":
        return ogr_conversion('ESRI Shapefile', [trees, plots, eco])
    elif format == "kml":
        return ogr_conversion('KML', [trees, plots, eco], 'kml')
    elif format == "csv":
        return ogr_conversion('CSV', [trees, plots, species, eco])

    full_count = Tree.objects.filter(present=True).count()
    full_plot_count = Plot.objects.filter(present=True).count()

    summaries, benefits = {}, {}
    if agg_object:
        benefits = agg_object.get_benefits()
        for field in agg_object._meta.get_all_field_names():
            if field.startswith('total') or field.startswith('annual'):
                summaries[field] = getattr(agg_object, field)

    if format == "geojson":     #still used anywhere?
        return render_to_geojson(trees, geom_field='geometry', additional_data={'summaries': summaries, 'benefits': benefits})

    geography = None
    if geog_object:
        if hasattr(geog_object, 'geometry'):
            geography = simplejson.loads(geog_object.geometry.simplify(.0001).geojson)
            geography['name'] = str(geog_object)

    response.update({'tile_query' : tile_query, 'summaries' : summaries, 'benefits': benefits, 'geography' : geography, 'initial_tree_count' : tree_count, 'full_tree_count': full_count, 'full_plot_count': full_plot_count})
    return render_to_json(response)


def summaries(request, model, id=''):
    location = request.GET.get('location','')
    coords = map(float,location.split(','))
    pt = Point(coords)
    ns = ns.filter(geometry__contains=pt)
    [x.name for x in AggregateSummaryModel._meta.fields if 'id' not in x.name]


def check_username(request):
    name = request.GET.get('u')
    if name:
        names = User.objects.filter(username__iexact=name)
        if names.exists():
            return render_to_json({'status':'username "%s" not available' % name})
    return render_to_json({'status':''})

#@cache_page(60*5)
def geographies(request, model, id=''):
    """
    return list of nhbds and resource attrs, possibly in json format
    """
    format = request.GET.get('format','html')
    location = request.GET.get('location','')
    name = request.GET.get('name', '')
    list = request.GET.get('list', '')

    ns = model.objects.all().order_by('state','county','name')
    if location:
        coords = map(float,location.split(','))
        pt = Point(coords)
        ns = ns.filter(geometry__contains=pt)

    if id:
        ns = ns.filter(id=id)
    if name:
        ns = ns.filter(name__iexact=name)[:1]
        #print ns
    if list:
        ns = ns.exclude(aggregates__total_plots=0)
    if format.lower() == 'json':
        #print ns
        return render_to_geojson(ns, simplify=.0005)
    if id:
        if format.lower() == 'infowindow':
            return render_to_response('treemap/geography_detail_infowindow.html',RequestContext(request,{'object':ns[0]}))
        return render_to_response('treemap/geography_detail.html',RequestContext(request,{'object':ns[0]}))
    return render_to_response('treemap/geography.html',RequestContext(request,{'objects':ns}))
#make some atom feeds

@cache_page(60*5)
def zips(request):
    """
    return list of nhbds and resource attrs, possibly in json format
    """
    name = request.GET.get('name', '')
    list = request.GET.get('list', '')
    #print list

    ns = ZipCode.objects.all()

    if name:
        ns = ns.filter(zip__iexact=name)
    return render_to_geojson(ns, simplify=.0005)

def contact(request):
    if request.method == 'POST':
        form = ContactForm(request.POST)
        if form.is_valid():
            subject = form.cleaned_data['subject']
            sender = form.cleaned_data['sender']
            message = 'The following feedback was submitted from %s  \n\n' % sender
            message += form.cleaned_data['message']
            cc_myself = form.cleaned_data['cc_myself']

            if settings.FORCE_MAIL_TO_BE_FROM:
                sender = settings.FORCE_MAIL_TO_BE_FROM

            recipients = tuple(settings.CONTACT_EMAILS)
            if cc_myself or settings.FORCE_MAIL_TO_BE_FROM:
                recipients += (sender,)

            from django.core.mail import send_mail
            send_mail(subject, message, sender, recipients)

            return redirect("contact/thanks")
    else:
        form = ContactForm() # An unbound form

    return render_to_response('treemap/contact.html', {
        'form': form,
    }, RequestContext(request))

def is_number(s):
    try:
        float(s)
        return True
    except ValueError:
        return False

def clean_diff(jsonstr):
    #print jsonstr
    diff = simplejson.JSONDecoder().decode(jsonstr)
    diff_no_old = {}
    for key in diff:
        if not key.startswith('old_'):
            diff_no_old[key] = diff[key]
    return diff_no_old

def clean_key_names(jsonstr):
    if not jsonstr: return ""
    diff = simplejson.JSONDecoder().decode(jsonstr)
    diff_clean = {}
    for key in diff:
        diff_clean[key.replace('_', ' ').title()] = diff[key]
    return diff_clean

from django.core import serializers
@login_required
def verify_edits(request, audit_type='tree'):

    changes = []
    trees = Tree.history.filter(present=True)\
                        .filter(_audit_change_type__exact='U')\
                        .exclude(_audit_diff__exact='')\
                        .filter(_audit_verified__exact=0)

    newtrees = Tree.history.filter(present=True)\
                           .filter(_audit_change_type__exact='I')\
                           .filter(_audit_verified__exact=0)

    plots = Plot.history.filter(present=True)\
                        .filter(_audit_change_type__exact='U')\
                        .exclude(_audit_diff__exact='')\
                        .filter(_audit_verified__exact=0)

    newplots = Plot.history.filter(present=True)\
                           .filter(_audit_change_type__exact='I')\
                           .filter(_audit_verified__exact=0)

    if settings.SHOW_ADMIN_EDITS_IN_RECENT_EDITS is False:
        trees = trees.filter(_audit_user_rep__lt=1000)
        newtrees = newtrees.filter(_audit_user_rep__lt=1000)
        plots = plots.filter(_audit_user_rep__lt=1000)
        newplots = newplots.filter(_audit_user_rep__lt=1000)

    treeactions = []
    n = None

    if 'username' in request.GET:
        u = User.objects.filter(username__icontains=request.GET['username'])
        trees = trees.filter(last_updated_by__in=u)
        plots = plots.filter(last_updated_by__in=u)
        newtrees = newtrees.filter(last_updated_by__in=u)
        newplots = newplots.filter(last_updated_by__in=u)
    if 'address' in request.GET:
        trees = trees.filter(plot__address_street__icontains=request.GET['address'])
        plots = plots.filter(address_street__icontains=request.GET['address'])
        newtrees = newtrees.filter(plot__address_street__icontains=request.GET['address'])
        newplots = newplots.filter(address_street__icontains=request.GET['address'])
    if 'nhood' in request.GET:
        n = Neighborhood.objects.filter(id=request.GET['nhood'])[0]
        geo_trees = Tree.objects.filter(plot__geometry__within=n.geometry)
        ids = [t.id for t in geo_trees]
        trees = trees.filter(id__in=ids)
        plots = plots.filter(geometry__within=n.geometry)
        newtrees = newtrees.filter(id__in=ids)
        newplots = newplots.filter(geometry__within=n.geometry)

    for plot in plots[0:50]:
        species = 'no species name'
        actual_plot = Plot.objects.get(pk=plot.id)
        if actual_plot.current_tree():
            species_obj = actual_plot.current_tree().species
            if species_obj:
                species = species_obj.common_name
        changes.append({
            'id': actual_plot.id,
            'species': species,
            'address_street': actual_plot.address_street,
            'last_updated_by': plot.last_updated_by.username,
            'last_updated': plot.last_updated,
            'change_description': clean_key_names(plot._audit_diff),
            'change_id': plot._audit_id,
            'type': 'plot'
        })
    for plot in newplots[0:50]:
        species = 'no species name'
        actual_plot = Plot.objects.get(pk=plot.id)
        if actual_plot.current_tree():
            species_obj = actual_plot.current_tree().species
            if species_obj:
                species = species_obj.common_name
        changes.append({
            'id': actual_plot.id,
            'species': species,
            'address_street': actual_plot.address_street,
            'last_updated_by': plot.last_updated_by.username,
            'last_updated': plot.last_updated,
            'change_description': clean_key_names(plot._audit_diff),
            'change_id': plot._audit_id,
            'type': 'plot'
        })
    for tree in trees[0:50]:
        species = 'no species name'
        actual_tree = Tree.objects.get(pk=tree.id)
        if actual_tree.species:
            species = actual_tree.species.common_name
        changes.append({
            'id': actual_tree.id,
            'species': species,
            'address_street': actual_tree.plot.address_street,
            'last_updated_by': tree.last_updated_by.username,
            'last_updated': tree.last_updated,
            'change_description': clean_key_names(tree._audit_diff),
            'change_id': tree._audit_id,
            'type': 'tree'
        })
    for tree in newtrees[0:50]:
        species = 'no species name'
        actual_tree = Tree.objects.get(pk=tree.id)
        if actual_tree.species:
            species = actual_tree.species.common_name
        changes.append({
            'id': actual_tree.id,
            'species': species,
            'address_street': actual_tree.plot.address_street,
            'last_updated_by': tree.last_updated_by,
            'last_updated': tree.last_updated,
            'change_description': 'New Tree',
            'change_id': tree._audit_id,
            'type': 'tree'
        })

    changes.sort(lambda x,y: cmp(x['last_updated'], y['last_updated']))

    return render_to_response('treemap/verify_edits.html',RequestContext(request,{'changes':changes, "geometry":n}))

@login_required
@permission_required('auth.change_user') #proxy for group users
def watch_list(request):
    watch_failures = TreeWatch.objects.filter(valid=False)
    n = None
    if 'username' in request.GET:
        u = User.objects.filter(username__icontains=request.GET['username'])
        watch_failures = watch_failures.filter(tree__last_updated_by__in=u)
    if 'address' in request.GET:
        watch_failures = watch_failures.filter(tree__address_street__icontains=request.GET['address'])
    if 'test' in request.GET:
        for watch in watch_choices.iteritems():
            if watch[0] == request.GET['test']:
                key = watch[1]
                watch_failures = watch_failures.filter(key=key)
                break;
    if 'nhood' in request.GET:
        n = Neighborhood.objects.filter(id=request.GET['nhood'])
        watch_failures = watch_failures.filter(tree__plot__neighborhood=n)

    return render_to_response('treemap/watch_list.html', RequestContext(request,{'test_names':watch_choices.iteritems(), "watches": watch_failures, "geography": n}))

@login_required
@permission_required('auth.change_user') #proxy for group users
def validate_watch(request):
    if request.method == 'POST':
        post = simplejson.loads(request.raw_post_data)
    watch_id = post.get('watch_id')
    watch = TreeWatch.objects.get(pk=watch_id)
    watch.valid = True
    watch.save()

    response_dict = {}
    response_dict['success'] = True
    return HttpResponse(
        simplejson.dumps(response_dict, sort_keys=True, indent=4),
        content_type = 'text/plain'
    )
@login_required
@permission_required('auth.change_user')
def user_rep_changes(request):
    aggs = []
    distinct_dates = UserReputationAction.objects.dates('date_created', 'day', order='DESC')
    for date in distinct_dates.iterator():
        start_time = date.replace(hour = 0, minute = 0, second = 0)
        end_time = date.replace(hour = 23, minute = 59, second = 59)

        date_users = UserReputationAction.objects.filter(date_created__range=(start_time, end_time)).values('user').distinct('user')

        if 'username' in request.GET:
            u = User.objects.filter(username__icontains=request.GET['username'])
            date_users = date_users.filter(user__in=u)
        if 'group' in request.GET:
            g = Group.objects.filter(name__icontains=request.GET['group'])
            date_users = date_users.filter(user__groups__in=g)

        for user_id in date_users:
            user = User.objects.get(pk=user_id['user'])
            user_date_newtrees = Tree.history.filter(present=True, last_updated_by=user, _audit_change_type__exact='I', _audit_timestamp__range=(start_time, end_time))
            user_date_treeupdate = Tree.history.filter(present=True, last_updated_by=user, _audit_change_type__exact='U', _audit_timestamp__range=(start_time, end_time)).exclude(_audit_diff__exact='')

            aggs.append({
                'user':user.username,
                'new':user_date_newtrees.count(),
                'update': user_date_treeupdate.count(),
                'date':date
            })
    return render_to_response('treemap/rep_changes.html',RequestContext(request,{'rep':aggs}))


@login_required
def verify_rep_change(request, change_type, change_id, rep_dir):
    #parse change type and retrieve change object
    if change_type == 'tree':
        change = Tree.history.filter(_audit_id__exact=change_id)[0]
        user = get_object_or_404(User, pk=change.last_updated_by_id)
        obj = get_object_or_404(Tree, pk=change.id)
    elif change_type == 'plot':
        change = Plot.history.filter(_audit_id__exact=change_id)[0]
        user = get_object_or_404(User, pk=change.last_updated_by_id)
        obj = get_object_or_404(Plot, pk=change.id)
    elif change_type == 'action':
        change = TreeAction.history.filter(_audit_id__exact=change_id)[0]
        user = get_object_or_404(User, pk=change.reported_by_id)
        obj = get_object_or_404(TreeAction, pk=change.id)
    elif change_type == 'alert':
        change = TreeAlert.history.filter(_audit_id__exact=change_id)[0]
        user = get_object_or_404(User, pk=change.reported_by_id)
        obj = get_object_or_404(TreeAlert, pk=change.id)
    elif change_type == 'flag':
        change = TreeFlags.history.filter(_audit_id__exact=change_id)[0]
        user = get_object_or_404(User, pk=change.reported_by_id)
        obj = get_object_or_404(TreeFlags, pk=change.id)

    change_reputation_for_user(user, 'edit verified', obj, sub_action=rep_dir, change_initiated_by_user=request.user)
    change._audit_verified = 1
    change.save()
    return render_to_json({'change_type': change_type, 'change_id': change_id})

@login_required
@permission_required('threadedcomments.change_threadedcomment')
def view_flagged(request):
    comments = ThreadedComment.objects.annotate(num_flags=Count('comment_flags__id')).filter(is_public=True, num_flags__gt=0)
    n = None
    if 'username' in request.GET:
        u = User.objects.filter(username__icontains=request.GET['username'])
        comments = comments.filter(user__in=u)
    if 'text' in request.GET:
        comments = comments.filter(comment__icontains=request.GET['text'])
    if 'nhood' in request.GET:
        n = Neighborhood.objects.get(id=request.GET['nhood'])
        comment_list = []
        loop_list = list(comments)
        for comment in loop_list:
            plot = Plot.objects.get(pk=comment.object_id)
            if n in plot.neighborhood.all():
                comment_list.append(comment)
        return render_to_response('comments/edit.html',RequestContext(request,{'comments':comment_list, "geometry":n}))

    return render_to_response('comments/edit_flagged.html',RequestContext(request,{'comments': comments, "geometry":n}))

@login_required
@permission_required('threadedcomments.change_threadedcomment')
def view_comments(request):
    comments = ThreadedComment.objects.filter(is_public=True)
    n = None
    if 'username' in request.GET:
        u = User.objects.filter(username__icontains=request.GET['username'])
        comments = comments.filter(user__in=u)
    if 'text' in request.GET:
        comments = comments.filter(comment__icontains=request.GET['text'])
    if 'nhood' in request.GET:
        n = Neighborhood.objects.get(id=request.GET['nhood'])
        comment_list = []
        loop_list = list(comments)
        for comment in loop_list:
            plot = Plot.objects.get(pk=comment.object_id)
            if n in plot.neighborhood.all():
                comment_list.append(comment)
        return render_to_response('comments/edit.html',RequestContext(request,{'comments':comment_list, "geometry":n}))

    return render_to_response('comments/edit.html',RequestContext(request,{'comments':comments, "geometry":n}))

@login_required
@permission_required('threadedcomments.change_threadedcomment')
def export_comments(request, format):
    users = UserProfile.objects.filter(active=True)
    where = []
    if 'username' in request.GET:
        users = users.filter(user__username__icontains=request.GET['username'])
        where.append(" a.username ilike '%" + request.GET['username'] + "%' ")
    if 'text' in request.GET:
        where.append(" b.comment ilike '%" + request.GET['text'] + "%' ")
    if 'nhood' in request.GET:
        n = Neighborhood.objects.get(id=request.GET['nhood'])
        comment_list = []
        loop_list = list(ThreadedComments.objects.all())
        for comment in loop_list:
            plot = Plot.objects.get(pk=comment.object_id)
            if n in plot.neighborhood.all():
                comment_list.append(comment)
        where.append("b.id in " + [c.id for c in comment_list] + " ")

    sql = "select a.username, b.date_submitted as date, b.comment as comment, b.object_id as plot_id from auth_user as a, threadedcomments_threadedcomment as b where b.user_id = a.id"
    if len(where) > 0:
        sql = sql + " and " + ' and '.join(where)

    return ogr_conversion('CSV', [{'name':'comments', 'sql':sql}], name="comments", geo=False)



def hide_comment(request):
    response_dict = {}
    post = simplejson.loads(request.raw_post_data)
    flag_id = post.get('flag_id')
    try:
        comment = CommentFlag.objects.get(id=flag_id).comment
    except:
        comment = ThreadedComment.objects.get(id=flag_id)

    comment.is_public = False
    comment.save()
    response_dict['success'] = True

    return HttpResponse(
        simplejson.dumps(response_dict, sort_keys=True, indent=4),
        content_type = 'text/plain'
    )

@login_required
def add_flag(request, comment_id):
    user = request.user
    comment = ThreadedComment.objects.get(pk=comment_id)
    comment_flags = CommentFlag.objects.filter(comment=comment, user=user).all()

    if comment_flags and len(comment_flags) > 0:
        comment_flags[0].flagged = True
        comment_flags[0].save()
    else:
        comment_flag = CommentFlag(comment=comment, flagged=True, user=user)
        comment_flag.save()

    return HttpResponseRedirect(request.REQUEST["next"])


def remove_flag(request):
    response_dict = {}
    post = simplejson.loads(request.raw_post_data)
    flag_id = post.get('flag_id')

    flag = CommentFlag.objects.get(comment__id=flag_id)
    flag.delete()
    response_dict['success'] = True

    return HttpResponse(
        simplejson.dumps(response_dict, sort_keys=True, indent=4),
        content_type = 'text/plain'
    )

@login_required
@permission_required('auth.change_user') #proxy for group users
def view_images(request):
    user_images = UserProfile.objects.exclude(photo="").order_by("-user__last_login")
    tree_images = TreePhoto.objects.all().order_by("-reported")
    return render_to_response('treemap/images.html',RequestContext(request, {'user_images':user_images, 'tree_images':tree_images}))

def treemap_settings_js(request):

    context = {
        'map_center_lat': settings.MAP_CENTER_LAT,
        'map_center_lon': settings.MAP_CENTER_LON,
        'bounding_box_left': settings.BOUNDING_BOX['left'],
        'bounding_box_bottom': settings.BOUNDING_BOX['bottom'],
        'bounding_box_top': settings.BOUNDING_BOX['top'],
        'bounding_box_right': settings.BOUNDING_BOX['right'],
    }

    response = render_to_response('treemap/treemap_settings.js', RequestContext(request,context))
    response['Content-Type'] = 'application/javascript'
    return response

########NEW FILE########
__FILENAME__ = urls
from django.conf import settings
from django.conf.urls.defaults import *

from django.contrib import databrowse

from django.contrib import admin
admin.autodiscover()


from registration.views import register

urlpatterns = patterns('',
    (r'^_admin_/', include(admin.site.urls)),
    (r'^databrowse/(.*)', databrowse.site.root),

    (r'^static/css/images/(?P<path>.*)$', 'django.views.static.serve',
        {'document_root': settings.STATIC_DATA + "/images/" + settings.SITE_LOCATION}),

    (r'^static/css/(?P<path>.*)$', 'django.views.static.serve',
        {'document_root': settings.STATIC_DATA + "/css/" + settings.SITE_LOCATION}),
    (r'^static/images/(?P<path>.*)$', 'django.views.static.serve',
        {'document_root': settings.STATIC_DATA + "/images/" + settings.SITE_LOCATION}),
    #(r'^static/js/(?P<path>.*)$', 'django.views.static.serve',
    #    {'document_root': settings.STATIC_DATA + "/js/" + settings.SITE_LOCATION}),

    (r'^static/(?P<path>.*)$', 'django.views.static.serve',
        {'document_root': settings.STATIC_DATA}),
    (r'^Nodes/(?P<path>.*)$', 'django.views.static.serve',
        {'document_root': settings.MEDIA_ROOT + "/Nodes"}),
    (r'^media/(?P<path>.*)$', 'django.views.static.serve',
        {'document_root': settings.MEDIA_ROOT}),
    (r'^admin_media/(?P<path>.*)$', 'django.views.static.serve',
        {'document_root': settings.ADMIN_MEDIA_ROOT}),
    (r'^comments/', include('threadedcomments.urls')),

    (r'^', include('treemap.urls')),
    (r'^importer/', include('importer.urls', namespace='importer')),
    #(r'^', include('qs_tiles.urls')),

    # using new 0.8 beta with "backends" support
    # http://docs.b-list.org/django-registration/0.8/
    # override just the /register view to customize form and save actions...
    url(r'^accounts/register/$',register,
       { 'backend': 'registration_backend.TreeBackend' },
       name='registration_register'),
    # dispatch the remainder of the urls to the default backend...
    (r'^accounts/', include('registration.backends.default.urls')),
    (r'^profiles/', include('profiles.urls')),
    (r'^treekey/', include('treekey.urls')),
    (r'^api/v0.1/', include('api.urls')),
)

if 'polygons' in settings.INSTALLED_APPS:
    urlpatterns += patterns('',
        (r'^polygons/', include('polygons.urls')),
    )

########NEW FILE########
__FILENAME__ = tc_invalid
import math
import sys
import os
import time
import urllib
import memcache
if len(sys.argv) < 3:
    print "Usage: %s <path to settings module> <settings module name>" % sys.argv[0]
    sys.exit()    
class KeyboardException: pass
sys.path = [sys.argv[1]] + sys.path
os.environ['DJANGO_SETTINGS_MODULE'] = sys.argv[2] 
from profiles.models import *
from treemap.models import PointUpdate, TreePhoto

#tilecache_base = "http://tilecache.urbanforestmap.org/tiles/trees/1.0.0/"
tilecache_base = "http://tilecache.urbanforestmap.org/tiles/1.0.0/trees"

def lon_lat_to_xy(lon, lat):
    x = lon * 20037508.34 / 180
    y = math.log(math.tan((90 + lat) * math.pi / 360)) / (math.pi / 180)
    y = y * 20037508.34 / 180
    return [x, y]

def tile_ids(xy, min_zoom=7, max_zoom=20):
    input = xy 
    max_res = 156543.0339
    max_extent = [-20037508.34,-20037508.34,20037508.34,20037508.34]
    levels = range(min_zoom,max_zoom)
    # regen highest zooms first
    levels.reverse()
    for zoom in levels:
        x_diff = input[0] - max_extent[0]
        x = int(math.floor(x_diff/(max_res/(2**zoom))/256))
        y_diff = max_extent[3] - input[1] 
        y = int(math.floor(y_diff/(max_res/(2**zoom))/256))
        yield zoom, x, y

def refresh_tile(z,x,y):
    global tilecache_base
    # was hitting:
    # http://tilecache.urbanforestmap.org/tiles/trees/1.0.0//1.0.0/18/41930/101350.jpg?FORCE=true
    # now should hit:
    # http://tilecache.urbanforestmap.org/tiles/1.0.0/trees/Map/12/656/1585.png
    # todo - pull these dynamically
    layers = ['Map','Terrain','Satellite','Hybrid']
    for l in layers:
        url = "%s/%s/%s/%s/%s.png?FORCE=true" % (tilecache_base, l, z, x, y)
        print url
        urllib.urlopen(url)    


def run():
    mc = memcache.Client(['127.0.0.1:11211'])
    while True:
        points = PointUpdate.objects.all()
        if points.count():
            try:
                point = points[0]
                for i in tile_ids(lon_lat_to_xy(point.lon, point.lat)):
                    refresh_tile(*i)
                mc.flush_all()
                print "Finished with %s" % point.id
                point.delete()  
            except Exception, E:
                print "Error occurred (%s)" % E
        time.sleep(1)     

if __name__ == "__main__":  
    run() 

########NEW FILE########
