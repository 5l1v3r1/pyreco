__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# PredictionIO-Python-SDK documentation build configuration file, created by
# sphinx-quickstart on Sat Sep 22 16:14:26 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))
sys.path.append("..")

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'PredictionIO Python SDK'
copyright = u'2013, TappingStone, Inc.'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.7'
# The full version, including alpha/beta/rc tags.
release = '0.7.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
#html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'PredictionIO-Python-SDKdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'PredictionIO-Python-SDK.tex', u'PredictionIO-Python-SDK Documentation',
   u'TappingStone', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'predictionio-python-sdk', u'PredictionIO-Python-SDK Documentation',
     [u'TappingStone'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'PredictionIO-Python-SDK', u'PredictionIO-Python-SDK Documentation',
   u'TappingStone', 'PredictionIO-Python-SDK', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

autodoc_member_order = 'bysource'

########NEW FILE########
__FILENAME__ = appdata

import datetime
from operator import itemgetter, attrgetter

# can get sample data here:
# wget http://www.grouplens.org/system/files/ml-100k.zip
# app data file config
APPDATA_DIRNAME = "ml-100k"
USERS_FILENAME = "u.user"
USERS_FILE_DELIMITER = "|"
ITEMS_FILENAME = "u.item"
ITEMS_FILE_DELIMITER = "|"
RATE_ACTIONS_FILENAME = "u.data"
RATE_ACTIONS_DELIMITER = "\t"


class User:
  def __init__(self, uid):
    self.uid = uid
    self.rec = [] # recommendations, list of iid

  def __str__(self):
    return "User[uid=%s,rec=%s]" % (self.uid, self.rec)

class Item:
  def __init__(self, iid, name):
    self.iid = iid
    self.name = name

  def __str__(self):
    return "Item[iid=%s,name=%s]" % (self.iid, self.name)

class RateAction:
  def __init__(self, uid, iid, rating, t):
    self.uid = uid
    self.iid = iid
    self.rating = rating
    self.t = t

  def __str__(self):
    return "RateAction[uid=%s,iid=%s,rating=%s,t=%s]" % (self.uid, self.iid, self.rating, self.t)


class AppData:

  def __init__(self):
    self._users = {} # dict of User obj
    self._items = {} # dict of Item obj
    self._rate_actions = [] # list of RateAction obj

    self._users_file = "%s/%s" % (APPDATA_DIRNAME, USERS_FILENAME)
    self._items_file = "%s/%s" % (APPDATA_DIRNAME, ITEMS_FILENAME)
    self._rate_actions_file = "%s/%s" % (APPDATA_DIRNAME, RATE_ACTIONS_FILENAME)
    self.__init_users()
    self.__init_items()
    self.__init_rate_actions()

  def __init_users(self):
    """
    uid|
    """
    print "[Info] Initializing users..."
    f = open(self._users_file, 'r')
    for line in f:
      data = line.rstrip('\r\n').split(USERS_FILE_DELIMITER)
      self.add_user(User(data[0]))
    f.close()
    print "[Info] %s users were initialized." % len(self._users)

  def __init_items(self):
    """
    iid|name
    """
    print "[Info] Initializing items..."
    f = open(self._items_file, 'r')
    for line in f:
      data = line.rstrip('\r\n').split(ITEMS_FILE_DELIMITER)
      self.add_item(Item(data[0], data[1]))
    f.close()
    print "[Info] %s items were initialized." % len(self._items)

  def __init_rate_actions(self):
    """
    uid|iid|rating|timestamp
    """
    print "[Info] Initializing rate actions..."
    f = open(self._rate_actions_file, 'r')
    for line in f:
      data = line.rstrip('\r\n').split(RATE_ACTIONS_DELIMITER)
      t = datetime.datetime.utcfromtimestamp(int(data[3])).isoformat()
      self.add_rate_action(RateAction(data[0], data[1], data[2], t))
    f.close()
    print "[Info] %s rate actions were initialized." % len(self._rate_actions)

  def add_user(self, user):
    self._users[user.uid] = user

  def add_item(self, item):
    self._items[item.iid] = item

  def add_rate_action(self, action):
    self._rate_actions.append(action)

  def get_users(self):
    return self._users

  def get_items(self):
    return self._items

  def get_rate_actions(self):
    return self._rate_actions

  def get_user(self, uid):
    """return single user
    """
    if uid in self._users:
      return self._users[uid]
    else:
      return None

  def get_item(self, iid):
    """return single item
    """
    if iid in self._items:
      return self._items[iid]
    else:
      return None

  def get_top_rated_items(self, uid, n):
    """get top n rated iids by this uid
    """
    if uid in self._users:
      actions = filter(lambda u: u.uid==uid, self._rate_actions)
      top = sorted(actions, key=attrgetter('rating'), reverse=True)
      topn_iids = map(lambda a: a.iid, top[:n])
      return topn_iids
    else:
      return None

  def get_top_rate_actions(self, uid, n):
    """get top n rated actions by this uid
    """
    if uid in self._users:
      actions = filter(lambda u: u.uid==uid, self._rate_actions)
      top = sorted(actions, key=attrgetter('rating'), reverse=True)
      return top[:n]
    else:
      return None

########NEW FILE########
__FILENAME__ = app_config
APP_KEY = 'uJKTKyUAFNZYQQO5yxkdrSo3XIlaf9LXejI63CWE0mtZVEYF89hyVtOwpMKfXXXX'
API_URL = 'http://localhost:8000'

########NEW FILE########
__FILENAME__ = batch_import
from appdata import AppData
import predictionio
import sys

from app_config import APP_KEY, API_URL

def batch_import_task(app_data, client, all_info=False):

  print "[Info] Importing users to PredictionIO..."
  count = 0 
  for k, v in app_data.get_users().iteritems():
    count += 1
    if all_info:
      print "[Info] Importing %s..." % v
    else:
      if (count % 32 == 0):
        sys.stdout.write('\r[Info] %s' % count)
        sys.stdout.flush()

    client.create_user(v.uid)
  
  sys.stdout.write('\r[Info] %s users were imported.\n' % count)
  sys.stdout.flush()

  print "[Info] Importing items to PredictionIO..."
  count = 0
  for k, v in app_data.get_items().iteritems():
    count += 1
    if all_info:
      print "[Info] Importing %s..." % v
    else:
      if (count % 32 == 0):
        sys.stdout.write('\r[Info] %s' % count)
        sys.stdout.flush()

    client.create_item(v.iid, ("movie",))
  
  sys.stdout.write('\r[Info] %s items were imported.\n' % count)
  sys.stdout.flush()

  print "[Info] Importing rate actions to PredictionIO..."
  count = 0
  for v in app_data.get_rate_actions():
    count += 1
    if all_info:
      print "[Info] Importing %s..." % v
    else:
      if (count % 32 == 0):
        sys.stdout.write('\r[Info] %s' % count)
        sys.stdout.flush()

    client.identify(v.uid)
    client.record_action_on_item("rate", v.iid, { "pio_rate": v.rating, "pio_t": v.t })

  sys.stdout.write('\r[Info] %s rate actions were imported.\n' % count)
  sys.stdout.flush()


if __name__ == '__main__':

  app_data = AppData()
  client = predictionio.Client(APP_KEY, 1, API_URL)
  batch_import_task(app_data, client)
  client.close()


########NEW FILE########
__FILENAME__ = movie_rec_app
# To run this example app
#
# Please execute all commands from repository root.
#
# Step 1. Get sample data and unzip it.
# > wget http://www.grouplens.org/system/files/ml-100k.zip
# > unzip ml-100k.zip
#
# Step 2. Configurate examples/itemrec/movies/appdata.py
#
# Step 3. Run this app:
# python -m examples.itemrec.movies.movie_rec_app

from appdata import AppData
import predictionio
import sys

from app_config import APP_KEY, API_URL

ENGINE_NAME = 'movie-rec'

class App:

  def __init__(self):
    self._app_data = AppData()
    self._client = predictionio.Client(APP_KEY, 1, API_URL)

  def run(self):
    state = "[Main Menu]"

    prompt = "\n"\
      "%s\n"\
      "%s\n"\
      "Please input selection:\n"\
      " 0: Quit application.\n"\
      " 1: Get Recommendations from PredictionIO.\n"\
      " 2: Display user's data." % (state, '-'*len(state))

    while True:
      print prompt
      choice = raw_input().lower()
      if choice == '0':
        print "\nGood Bye!\n"
        break
      elif choice == '1':
        self.recommend_task(state)
      elif choice == '2':
        self.display_user_task(state)
      else:
        print '[Error] \'%s\' is not a valid selection.' % choice

    self._client.close()

  def recommend_task(self, prev_state):
    state = prev_state + " / [Get Recommendations]"
    prompt = "\n"\
      "%s\n"\
      "%s\n"\
      "Please enter user id:" % (state, '-'*len(state))

    while True:
      print prompt
      choice = raw_input().lower()
      u = self._app_data.get_user(choice)
      if u:
        n = 10
        print "[Info] Getting top %s item recommendations for user %s..." % (n, u.uid)
        try:
          self._client.identify(u.uid)
          rec = self._client.get_itemrec_topn(ENGINE_NAME, n)
          u.rec = rec['pio_iids']
          self.display_items(u.rec)
        except predictionio.ItemRecNotFoundError:
          print "[Info] Recommendation not found"

        print "[Info] Go back to previous menu..."
        break
      else:
        print "[Error] invalid user id %s. Go back to previous menu..." % choice
        break

  def display_user_task(self, prev_state):
    state = prev_state + " / [Display User]"
    prompt = "\n"\
      "%s\n"\
      "%s\n"\
      "Please enter user id:" % (state, '-'*len(state))

    while True:
      print prompt
      choice = raw_input().lower()
      u = self._app_data.get_user(choice)
      if u:
        print "[Info] User %s:" % u.uid
        n = 10
        topn_rate_actions = self._app_data.get_top_rate_actions(u.uid, n)
        print "\n[Info] Top %s movies rated by this user:" % n
        self.display_rate_actions(topn_rate_actions)

        print "\n[Info] Movies recommended to this user:"
        self.display_items(u.rec)

        self.wait_for_ack()
        print "\n[Info] Go back to previous menu..."
        break
      else:
        print "[Error] invalid user id %s. Go back to previous menu..." % choice
        break
  
  def display_items(self, iids, all_info=False):
    """print item info for each iid in the list
    """
    if iids:
      for iid in iids:
        item = self._app_data.get_item(iid)
        if item:
          if all_info:
            print "[Info] %s" % item
          else:
            print "[Info] %s" % item.name
        else:
          print "[Error] Invalid item id %s" % iid
    else:
      print "[Info] Empty."

  def display_rate_actions(self, actions):
    """print iid and rating
    """
    if actions:
      for a in actions:
        item = self._app_data.get_item(a.iid)
        if item:
          print "[Info] %s, rating = %s" % (item.name, a.rating)
        else:
          print "[Error] Invalid item id %s" % a.iid
    else:
      print "[Info] Empty."

  def wait_for_ack(self):

    prompt = "\nPress enter to continue..."
    print prompt
    choice = raw_input().lower()


if __name__ == '__main__':

  print "\nWelcome To PredictionIO Python-SDK Demo App!"
  print "============================================\n"
  
  my_app = App()
  my_app.run()

########NEW FILE########
__FILENAME__ = connection

try:
  import Queue
except ImportError:
  # pylint: disable=F0401
  # http is a Python3 module, replacing httplib. Ditto.
  import queue as Queue
import threading

try:
  import httplib
except ImportError:
  # pylint: disable=F0401
  from http import client as httplib

try:
  from urllib import urlencode
except ImportError:
  # pylint: disable=F0401,E0611
  from urllib.parse import urlencode

import datetime
import logging

# use generators for python2 and python3
try:
  xrange
except NameError:
  xrange = range

# some constants
MAX_RETRY = 1  # 0 means no retry


# logger
logger = None
DEBUG_LOG = False


def enable_log(filename=None):
  global logger
  global DEBUG_LOG
  timestamp = datetime.datetime.today()
  if not filename:
    logfile = "./log/predictionio_%s.log" % timestamp.strftime(
      "%Y-%m-%d_%H:%M:%S.%f")
  else:
    logfile = filename
  logging.basicConfig(filename=logfile,
            filemode='w',
            level=logging.DEBUG,
            format='[%(levelname)s] %(name)s (%(threadName)s) %(message)s')
  logger = logging.getLogger(__name__)
  DEBUG_LOG = True


class PredictionIOAPIError(Exception):
  pass


class NotSupportMethodError(PredictionIOAPIError):
  pass


class ProgramError(PredictionIOAPIError):
  pass


class AsyncRequest(object):

  """AsyncRequest object

  """

  def __init__(self, method, path, **params):
    self.method = method  # "GET" "POST" etc
    # the sub path eg. POST /v1/users.json  GET /v1/users/1.json
    self.path = path
    # dictionary format eg. {"appkey" : 123, "id" : 3}
    self.params = params
    # use queue to implement response, store AsyncResponse object
    self.response_q = Queue.Queue(1)
    self.qpath = "%s?%s" % (self.path, urlencode(self.params))
    self._response = None
    # response function to be called to handle the response
    self.rfunc = None

  def __str__(self):
    return "%s %s %s %s" % (self.method, self.path, self.params,
                self.qpath)

  def set_rfunc(self, func):
    self.rfunc = func

  def set_response(self, response):
    """ store the response

    NOTE: Must be only called once
    """
    self.response_q.put(response)

  def get_response(self):
    """get the response

    """
    if self._response is None:
      self._response = self.response_q.get(True)  # NOTE: blocking

    return self._response


class AsyncResponse(object):

  """AsyncResponse object.

  Store the response of asynchronous request

  when get the response, user should check if error is None (which means no
  Exception happens)
  if error is None, then should check if the status is expected

  Attributes:
    error: exception object if any happens
    version: int
    status: int
    reason: str
    headers: dict
    body: str (NOTE: not necessarily can be converted to JSON,
        eg, for GET request to /v1/status)
    request: the corresponding AsyncRequest object
  """

  def __init__(self):
    self.error = None
    self.version = None
    self.status = None
    self.reason = None
    self.headers = None
    self.body = None
    self.request = None  # point back to the request object

  def __str__(self):
    return "e:%s v:%s s:%s r:%s h:%s b:%s" % (self.error, self.version,
                          self.status, self.reason,
                          self.headers, self.body)

  def set_resp(self, version, status, reason, headers, body):
    self.version = version
    self.status = status
    self.reason = reason
    self.headers = headers
    self.body = body

  def set_error(self, error):
    self.error = error

  def set_request(self, request):
    self.request = request


class PredictionIOHttpConnection(object):

  def __init__(self, host, https=True, timeout=5):
    if https:  # https connection
      self._connection = httplib.HTTPSConnection(host, timeout=timeout)
    else:
      self._connection = httplib.HTTPConnection(host, timeout=timeout)

  def connect(self):
    self._connection.connect()

  def close(self):
    self._connection.close()

  def request(self, method, url, body={}, headers={}):
    """
    http request wrapper function, with retry capability in case of error.
    catch error exception and store it in AsyncResponse object
    return AsyncResponse object

    Args:
      method: http method, type str
      url: url path, type str
      body: http request body content, type dict
      header: http request header , type dict
    """

    response = AsyncResponse()

    try:
      # number of retry in case of error (minimum 0 means no retry)
      retry_limit = MAX_RETRY
      mod_headers = dict(headers)  # copy the headers
      mod_headers["Connection"] = "keep-alive"
      enc_body = None
      if body:  # if body is not empty
        enc_body = urlencode(body)
        mod_headers[
          "Content-type"] = "application/x-www-form-urlencoded"
        #mod_headers["Accept"] = "text/plain"
    except Exception as e:
      response.set_error(e)
      return response

    if DEBUG_LOG:
      logger.debug("Request m:%s u:%s h:%s b:%s", method, url,
             mod_headers, enc_body)
    # retry loop
    for i in xrange(retry_limit + 1):
      try:
        if i != 0:
          if DEBUG_LOG:
            logger.debug("retry request %s times" % i)
        if self._connection.sock is None:
          self._connection.connect()
        self._connection.request(method, url, enc_body, mod_headers)
      except Exception as e:
        self._connection.close()
        if i == retry_limit:
          # new copy of e created everytime??
          response.set_error(e)
      else:  # NOTE: this is try's else clause
        # connect() and request() OK
        try:
          resp = self._connection.getresponse()
        except Exception as e:
          self._connection.close()
          if i == retry_limit:
            response.set_error(e)
        else:  # NOTE: this is try's else clause
          # getresponse() OK
          resp_version = resp.version  # int
          resp_status = resp.status  # int
          resp_reason = resp.reason  # str
          # resp.getheaders() returns list of tuples
          # converted to dict format
          resp_headers = dict(resp.getheaders())
          # NOTE: have to read the response before sending out next
          # http request
          resp_body = resp.read()  # str
          response.set_resp(version=resp_version, status=resp_status,
                    reason=resp_reason, headers=resp_headers,
                    body=resp_body)
          break  # exit retry loop
    # end of retry loop
    if DEBUG_LOG:
      logger.debug("Response %s", response)
    return response  # AsyncResponse object


def connection_worker(host, request_queue, https=True, timeout=5, loop=True):
  """worker function which establishes connection and wait for request jobs
  from the request_queue

  Args:
    request_queue: the request queue storing the AsyncRequest object
      valid requests:
        GET
        POST
        DELETE
        KILL
    https: HTTPS (True) or HTTP (False)
    timeout: timeout for HTTP connection attempts and requests in seconds
    loop: This worker function stays in a loop waiting for request
      For testing purpose only. should always be set to True.
  """

  connect = PredictionIOHttpConnection(host, https, timeout)

  # loop waiting for job form request queue
  killed = not loop

  while True:
    # print "thread %s waiting for request" % thread.get_ident()
    request = request_queue.get(True)  # NOTE: blocking get
    # print "get request %s" % request
    method = request.method
    if method == "GET":
      path = request.qpath
      d = connect.request("GET", path)
    elif method == "POST":
      path = request.path
      body = request.params
      d = connect.request("POST", path, body)
    elif method == "DELETE":
      path = request.qpath
      d = connect.request("DELETE", path)
    elif method == "KILL":
      # tell the thread to kill the connection
      killed = True
      d = AsyncResponse()
    else:
      d = AsyncResponse()
      d.set_error(NotSupportMethodError(
        "Don't Support the method %s" % method))

    d.set_request(request)
    request.set_response(d)
    request_queue.task_done()
    if killed:
      break

  # end of while loop
  connect.close()


class Connection(object):

  """abstract object for connection with server

  spawn multiple connection_worker threads to handle jobs in the queue q
  """

  def __init__(self, host, threads=1, qsize=0, https=True, timeout=5):
    """constructor

    Args:
      host: host of the server.
      threads: type int, number of threads to be spawn
      qsize: size of the queue q
      https: indicate it is httpS (True) or http connection (False)
      timeout: timeout for HTTP connection attempts and requests in
        seconds
    """
    self.host = host
    self.https = https
    self.q = Queue.Queue(qsize)  # if qsize=0, means infinite
    self.threads = threads
    self.timeout = timeout
    # start thread based on threads number
    self.tid = {}  # dictionary of thread object

    for i in xrange(threads):
      tname = "PredictionIOThread-%s" % i  # thread name
      self.tid[i] = threading.Thread(
        target=connection_worker, name=tname,
        kwargs={'host': self.host, 'request_queue': self.q,
            'https': self.https, 'timeout': self.timeout})
      self.tid[i].setDaemon(True)
      self.tid[i].start()

  def make_request(self, request):
    """put the request into the q
    """
    self.q.put(request)

  def pending_requests(self):
    """number of pending requests in the queue
    """
    return self.q.qsize()

  def close(self):
    """close this Connection. Call this when main program exits
    """
    # set kill message to q
    for i in xrange(self.threads):
      self.make_request(AsyncRequest("KILL", ""))

    self.q.join()  # wait for q empty

    for i in xrange(self.threads):  # wait for all thread finish
      self.tid[i].join()

########NEW FILE########
__FILENAME__ = conversion_test
import timeit
import json

if __name__ == "__main__":
	a = True

	t = timeit.Timer("json.dumps(True)", "import json")

	t_bool2json = t.timeit(1000)/1000
	print "bool 2 json"
	print t_bool2json

	t = timeit.Timer("str(True).lower()", "")

	t_bool2string = t.timeit(1000)/1000
	print "bool 2 string"
	print t_bool2string







########NEW FILE########
__FILENAME__ = import_testdata
"""
Import simple test data for testing getting itemrec
"""
import predictionio

APP_KEY = "tGgZ7bJDpSyxLndJUBWgyAUwfBgVSTjO6KkhjnMpzCi7vSgPoYnXYptyVlg3vjLH"
API_URL = "http://localhost:8000"

MIN_VERSION = '0.5.0'
if predictionio.__version__ < MIN_VERSION:
    err = "Require PredictionIO Python SDK version >= %s" % MIN_VERSION
    raise Exception(err)

if __name__ == "__main__":
	client = predictionio.Client(APP_KEY, 1, API_URL)

	client.create_user("u0")
	client.create_user("u1")
	client.create_user("u2")
	client.create_user("u3")

	client.create_item("i0", ("t1",), {"custom1": "i0c1"})
	client.create_item("i1", ("t1","t2"), {"custom1": "i1c1", "custom2": "i1c2"})
	client.create_item("i2", ("t1","t2"), {"custom2": "i2c2"})
	client.create_item("i3", ("t1",))

	client.identify("u0")
	client.record_action_on_item("rate", "i0", { "pio_rate": 2 })
	client.record_action_on_item("rate", "i1", { "pio_rate": 3 })
	client.record_action_on_item("rate", "i2", { "pio_rate": 4 })
	
	client.identify("u1")
	client.record_action_on_item("rate", "i2", { "pio_rate": 4 })
	client.record_action_on_item("rate", "i3", { "pio_rate": 1 })

	client.identify("u2")
	client.record_action_on_item("rate", "i1", { "pio_rate": 2 })
	client.record_action_on_item("rate", "i2", { "pio_rate": 1 })
	client.record_action_on_item("rate", "i3", { "pio_rate": 3 })

	client.identify("u3")
	client.record_action_on_item("rate", "i0", { "pio_rate": 5 })
	client.record_action_on_item("rate", "i1", { "pio_rate": 3 })
	client.record_action_on_item("rate", "i3", { "pio_rate": 2 })

	client.close()
	

	




########NEW FILE########
__FILENAME__ = import_testdata_id_mismatch
"""
Import simple test data for testing getting itemrec
"""
import predictionio

APP_KEY = "7zwXYnroz52gemLdHEU20Nn8c2SyobFpnrzoTGOolCe8ZRH2zmGyhVknj9Sa7P6x"
API_URL = "http://localhost:8000"

MIN_VERSION = '0.5.0'
if predictionio.__version__ < MIN_VERSION:
    err = "Require PredictionIO Python SDK version >= %s" % MIN_VERSION
    raise Exception(err)

if __name__ == "__main__":
	client = predictionio.Client(APP_KEY, 1, API_URL)

	client.create_user("u0")
	client.create_user("u1")
	client.create_user("u2")
	client.create_user("u3")

	client.create_item("i0", ("t1",), {"custom1": "i0c1"})
	client.create_item("i1", ("t1","t2"), {"custom1": "i1c1", "custom2": "i1c2"})
	client.create_item("i2", ("t1","t2"), {"custom2": "i2c2"})
	client.create_item("i3", ("t1",))

	client.identify("u0x")
	client.record_action_on_item("rate", "i0", { "pio_rate": 2 })
	client.record_action_on_item("rate", "i1", { "pio_rate": 3 })
	client.record_action_on_item("rate", "i2", { "pio_rate": 4 })
	
	client.identify("u1x")
	client.record_action_on_item("rate", "i2", { "pio_rate": 4 })
	client.record_action_on_item("rate", "i3", { "pio_rate": 1 })

	client.identify("u2x")
	client.record_action_on_item("rate", "i1", { "pio_rate": 2 })
	client.record_action_on_item("rate", "i2", { "pio_rate": 1 })
	client.record_action_on_item("rate", "i3", { "pio_rate": 3 })

	client.identify("u3x")
	client.record_action_on_item("rate", "i0", { "pio_rate": 5 })
	client.record_action_on_item("rate", "i1", { "pio_rate": 3 })
	client.record_action_on_item("rate", "i3", { "pio_rate": 2 })

	client.close()
	

	




########NEW FILE########
__FILENAME__ = import_testdata_special_char
"""
Import simple test data (id with special characters) for testing getting itemrec
"""
import predictionio

APP_KEY = "GToKwk78As0LBp2fAx2YNUBPZFZvtwy6MJkGwRASiD6Q77JjBnTaXBxzBTd52ICE"
API_URL = "http://localhost:8000"

MIN_VERSION = '0.5.0'
if predictionio.__version__ < MIN_VERSION:
    err = "Require PredictionIO Python SDK version >= %s" % MIN_VERSION
    raise Exception(err)

if __name__ == "__main__":
	client = predictionio.Client(APP_KEY, 1, API_URL)

	client.create_user("u0@u.n")
	client.create_user("u1@u.n")
	client.create_user("http://u2.com")
	client.create_user("u3@u.n")

	client.create_item("http://i0.com", ("t1",), {"custom1": "i0c1"})
	client.create_item("i1@i1", ("t1","t2"), {"custom1": "i1c1", "custom2": "i1c2"})
	client.create_item("i2.org", ("t1","t2"), {"custom2": "i2c2"})
	client.create_item("i3", ("t1",))

	client.identify("u0@u.n")
	client.record_action_on_item("rate", "http://i0.com", { "pio_rate": 2 })
	client.record_action_on_item("rate", "i1@i1", { "pio_rate": 3 })
	client.record_action_on_item("rate", "i2.org", { "pio_rate": 4 })
	
	client.identify("u1@u.n")
	client.record_action_on_item("rate", "i2.org", { "pio_rate": 4 })
	client.record_action_on_item("rate", "i3", { "pio_rate": 1 })

	client.identify("http://u2.com")
	client.record_action_on_item("rate", "i1@i1", { "pio_rate": 2 })
	client.record_action_on_item("rate", "i2.org", { "pio_rate": 1 })
	client.record_action_on_item("rate", "i3", { "pio_rate": 3 })

	client.identify("u3@u.n")
	client.record_action_on_item("rate", "http://i0.com", { "pio_rate": 5 })
	client.record_action_on_item("rate", "i1@i1", { "pio_rate": 3 })
	client.record_action_on_item("rate", "i3", { "pio_rate": 2 })

	client.close()
	

	




########NEW FILE########
__FILENAME__ = predictionio_itemrec_test
"""
Test getting itemrec after algo training completes.
"""
import predictionio
import unittest
import time

APP_KEY = "y2Fk4BACEGYeJnqBF4zL9TmrIBdF9va3gyFaLsnM7PVyUNf0G00zC8vCnyBx5hdA" # replace this with your AppKey
API_URL = "http://localhost:8000" # PredictoinIO Server

DEBUG = True

MIN_VERSION = '0.6.0'
if predictionio.__version__ < MIN_VERSION:
	err = "Require PredictionIO Python SDK version >= %s" % MIN_VERSION
	raise Exception(err)

class TestPredictionIO(unittest.TestCase):
	def setUp(self):
		pass

	def tearDown(self):
		pass

	def test_get_itemrec_exception_deprecated(self):
		client = predictionio.Client(APP_KEY, 1, API_URL)

		try:
			itemrec = client.get_itemrec("uidwithoutrec", 10, "python-itemrec-engine")
		except predictionio.ItemRecNotFoundError as e:
			pass # expected exception
		except:
			raise

		client.close()

	def test_get_itemrec_exception(self):
		client = predictionio.Client(APP_KEY, 1, API_URL)

		client.identify("uidwithoutrec")

		try:
			itemrec = client.get_itemrec_topn("python-itemrec-engine", 10)
		except predictionio.ItemRecNotFoundError as e:
			pass # expected exception
		except:
			raise

		try:
			itemrec = client.get_itemrec_topn("python-itemrec-engine", 10, { "pio_itypes": ("t1",), "pio_latlng": [1.34, 5.67], "pio_within": 5.0, "pio_unit": "km", "pio_attributes": ["custom1", "custom2"]  })
		except predictionio.ItemRecNotFoundError as e:
			pass # expected exception
		except:
			raise

		client.close()

	def test_get_itemrec_deprecated(self):
		client = predictionio.Client(APP_KEY, 1, API_URL)

		# request more
		try:
			itemrec = client.get_itemrec("u0", 10, "python-itemrec-engine")
		except predictionio.ItemRecNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemrec
		self.assertEqual(itemrec, {"pio_iids": ["i2", "i3", "i1", "i0"]})

		try:
			itemrec = client.get_itemrec("u1", 10, "python-itemrec-engine")
		except predictionio.ItemRecNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemrec
		self.assertTrue( (itemrec == {"pio_iids": ["i2", "i1", "i0", "i3"]}) or 
						 (itemrec == {"pio_iids": ["i2", "i0", "i1", "i3"]}) )

		try:
			itemrec = client.get_itemrec("u2", 10, "python-itemrec-engine")
		except predictionio.ItemRecNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemrec
		self.assertTrue( (itemrec == {"pio_iids": ["i3", "i0", "i1", "i2"]}) or
						 (itemrec == {"pio_iids": ["i3", "i1", "i0", "i2"]}) )

		try:
			itemrec = client.get_itemrec("u3", 6, "python-itemrec-engine")
		except predictionio.ItemRecNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemrec
		self.assertTrue( (itemrec == {"pio_iids": ["i0", "i1", "i2", "i3"]}) or
						 (itemrec == {"pio_iids": ["i0", "i2", "i1", "i3"]}) )

		# request less
		try:
			itemrec = client.get_itemrec("u0", 1, "python-itemrec-engine")
		except predictionio.ItemRecNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemrec
		self.assertEqual(itemrec, {"pio_iids": ["i2"]})

		try:
			itemrec = client.get_itemrec("u0", 2, "python-itemrec-engine")
		except predictionio.ItemRecNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemrec
		self.assertEqual(itemrec, {"pio_iids": ["i2", "i3"]})

		# request with optional attributes

		# pio_itypes
		try:
			itemrec = client.get_itemrec("u0", 10, "python-itemrec-engine", pio_itypes=("t1","t2"))
		except predictionio.ItemRecNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemrec
		self.assertEqual(itemrec, {"pio_iids": ["i2", "i3", "i1", "i0"]})

		# subset itypes
		try:
			itemrec = client.get_itemrec("u0", 10, "python-itemrec-engine", pio_itypes=("t2",))
		except predictionio.ItemRecNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemrec
		self.assertEqual(itemrec, {"pio_iids": ["i2", "i1"]})

		# nonexisting itypes
		try:
			itemrec = client.get_itemrec("u0", 10, "python-itemrec-engine", pio_itypes=("other-itype",))
		except predictionio.ItemRecNotFoundError as e:
			pass # expected no recommendation
		except:
			raise

		# pio_attributes
		try:
			itemrec = client.get_itemrec("u0", 10, "python-itemrec-engine", pio_itypes=("t1",), pio_attributes=["custom1", "custom2"])
		except predictionio.ItemRecNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemrec
		self.assertEqual(itemrec, {"pio_iids": ["i2", "i3", "i1", "i0"], "custom1": [None, None, "i1c1", "i0c1"], "custom2": ["i2c2", None, "i1c2", None]})

		client.close()


	def test_get_itemrec(self):
		client = predictionio.Client(APP_KEY, 1, API_URL)

		# request more
		client.identify("u0")
		try:
			itemrec = client.get_itemrec_topn("python-itemrec-engine", 10)
		except predictionio.ItemRecNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemrec
		self.assertEqual(itemrec, {"pio_iids": ["i2", "i3", "i1", "i0"]})

		client.identify("u1")
		try:
			itemrec = client.get_itemrec_topn("python-itemrec-engine", 10)
		except predictionio.ItemRecNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemrec
		self.assertTrue( (itemrec == {"pio_iids": ["i2", "i1", "i0", "i3"]}) or 
						 (itemrec == {"pio_iids": ["i2", "i0", "i1", "i3"]}) )

		client.identify("u2")
		try:
			itemrec = client.get_itemrec_topn("python-itemrec-engine", 10)
		except predictionio.ItemRecNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemrec
		self.assertTrue( (itemrec == {"pio_iids": ["i3", "i0", "i1", "i2"]}) or
						 (itemrec == {"pio_iids": ["i3", "i1", "i0", "i2"]}) )

		client.identify("u3")
		try:
			itemrec = client.get_itemrec_topn("python-itemrec-engine", 6)
		except predictionio.ItemRecNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemrec
		self.assertTrue( (itemrec == {"pio_iids": ["i0", "i1", "i2", "i3"]}) or
						 (itemrec == {"pio_iids": ["i0", "i2", "i1", "i3"]}) )

		# request less
		client.identify("u0")
		try:
			itemrec = client.get_itemrec_topn("python-itemrec-engine", 1)
		except predictionio.ItemRecNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemrec
		self.assertEqual(itemrec, {"pio_iids": ["i2"]})

		client.identify("u0")
		try:
			itemrec = client.get_itemrec_topn("python-itemrec-engine", 2)
		except predictionio.ItemRecNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemrec
		self.assertEqual(itemrec, {"pio_iids": ["i2", "i3"]})

		# request with optional attributes

		# pio_itypes
		client.identify("u0")
		try:
			itemrec = client.get_itemrec_topn("python-itemrec-engine", 10, {"pio_itypes": ("t1","t2")})
		except predictionio.ItemRecNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemrec
		self.assertEqual(itemrec, {"pio_iids": ["i2", "i3", "i1", "i0"]})

		# subset itypes
		client.identify("u0")
		try:
			itemrec = client.get_itemrec_topn("python-itemrec-engine", 10, {"pio_itypes": ("t2",)})
		except predictionio.ItemRecNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemrec
		self.assertEqual(itemrec, {"pio_iids": ["i2", "i1"]})

		# nonexisting itypes
		client.identify("u0")
		try:
			itemrec = client.get_itemrec_topn("python-itemrec-engine", 10, {"pio_itypes": ("other-itype",)})
		except predictionio.ItemRecNotFoundError as e:
			pass # expected no recommendation
		except:
			raise

		# pio_attributes
		client.identify("u0")
		try:
			itemrec = client.get_itemrec_topn("python-itemrec-engine", 10, {"pio_itypes": ("t1",), "pio_attributes": ["custom1", "custom2"]})
		except predictionio.ItemRecNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemrec
		self.assertEqual(itemrec, {"pio_iids": ["i2", "i3", "i1", "i0"], "custom1": [None, None, "i1c1", "i0c1"], "custom2": ["i2c2", None, "i1c2", None]})

		# TODO pio_latlng
		# TODO pio_within
		# TODO pio_unit

		client.close()

if __name__ == "__main__" :
	unittest.main()

########NEW FILE########
__FILENAME__ = predictionio_itemrec_test_special_char
"""
Test getting itemrec after algo training completes.
"""
import predictionio
import unittest
import time

APP_KEY = "GToKwk78As0LBp2fAx2YNUBPZFZvtwy6MJkGwRASiD6Q77JjBnTaXBxzBTd52ICE" # replace this with your AppKey
API_URL = "http://localhost:8000" # PredictoinIO Server

DEBUG = True

MIN_VERSION = '0.6.0'
if predictionio.__version__ < MIN_VERSION:
	err = "Require PredictionIO Python SDK version >= %s" % MIN_VERSION
	raise Exception(err)

class TestPredictionIO(unittest.TestCase):
	def setUp(self):
		pass

	def tearDown(self):
		pass

	def test_get_itemrec_deprecated(self):
		client = predictionio.Client(APP_KEY, 1, API_URL)

		uid0 = "u0@u.n"
		uid1 = "u1@u.n"
		uid2 = "http://u2.com"
		uid3 = "u3@u.n"

		iid0 = "http://i0.com"
		iid1 = "i1@i1"
		iid2 = "i2.org"
		iid3 = "i3"

		engine_name = "itemrec"

		# request more
		try:
			itemrec = client.get_itemrec(uid0, 10, engine_name)
		except predictionio.ItemRecNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemrec
		self.assertEqual(itemrec, {"pio_iids": [iid2, iid3, iid1, iid0]})

		try:
			itemrec = client.get_itemrec(uid1, 10, engine_name)
		except predictionio.ItemRecNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemrec
		self.assertTrue( (itemrec == {"pio_iids": [iid2, iid1, iid0, iid3]}) or 
						 (itemrec == {"pio_iids": [iid2, iid0, iid1, iid3]}) )

		try:
			itemrec = client.get_itemrec(uid2, 10, engine_name)
		except predictionio.ItemRecNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemrec
		self.assertTrue( (itemrec == {"pio_iids": [iid3, iid0, iid1, iid2]}) or
						 (itemrec == {"pio_iids": [iid3, iid1, iid0, iid2]}) )

		try:
			itemrec = client.get_itemrec(uid3, 6, engine_name)
		except predictionio.ItemRecNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemrec
		self.assertTrue( (itemrec == {"pio_iids": [iid0, iid1, iid2, iid3]}) or
						 (itemrec == {"pio_iids": [iid0, iid2, iid1, iid3]}) )

		# request less
		try:
			itemrec = client.get_itemrec(uid0, 1, engine_name)
		except predictionio.ItemRecNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemrec
		self.assertEqual(itemrec, {"pio_iids": [iid2]})

		try:
			itemrec = client.get_itemrec(uid0, 2, engine_name)
		except predictionio.ItemRecNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemrec
		self.assertEqual(itemrec, {"pio_iids": [iid2, iid3]})

		# request with optional attributes

		# pio_itypes
		try:
			itemrec = client.get_itemrec(uid0, 10, engine_name, pio_itypes=("t1","t2"))
		except predictionio.ItemRecNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemrec
		self.assertEqual(itemrec, {"pio_iids": [iid2, iid3, iid1, iid0]})

		# subset itypes
		try:
			itemrec = client.get_itemrec(uid0, 10, engine_name, pio_itypes=("t2",))
		except predictionio.ItemRecNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemrec
		self.assertEqual(itemrec, {"pio_iids": [iid2, iid1]})

		# nonexisting itypes
		try:
			itemrec = client.get_itemrec(uid0, 10, engine_name, pio_itypes=("other-itype",))
		except predictionio.ItemRecNotFoundError as e:
			pass # expected no recommendation
		except:
			raise

		# pio_attributes
		try:
			itemrec = client.get_itemrec(uid0, 10, engine_name, pio_itypes=("t1",), pio_attributes=["custom1", "custom2"])
		except predictionio.ItemRecNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemrec
		self.assertEqual(itemrec, {"pio_iids": [iid2, iid3, iid1, iid0], "custom1": [None, None, "i1c1", "i0c1"], "custom2": ["i2c2", None, "i1c2", None]})

		client.close()


	def test_get_itemrec(self):
		client = predictionio.Client(APP_KEY, 1, API_URL)

		uid0 = "u0@u.n"
		uid1 = "u1@u.n"
		uid2 = "http://u2.com"
		uid3 = "u3@u.n"

		iid0 = "http://i0.com"
		iid1 = "i1@i1"
		iid2 = "i2.org"
		iid3 = "i3"

		engine_name = "itemrec"
		
		# request more
		client.identify(uid0)
		try:
			itemrec = client.get_itemrec_topn(engine_name, 10)
		except predictionio.ItemRecNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemrec
		self.assertEqual(itemrec, {"pio_iids": [iid2, iid3, iid1, iid0]})

		client.identify(uid1)
		try:
			itemrec = client.get_itemrec_topn(engine_name, 10)
		except predictionio.ItemRecNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemrec
		self.assertTrue( (itemrec == {"pio_iids": [iid2, iid1, iid0, iid3]}) or 
						 (itemrec == {"pio_iids": [iid2, iid0, iid1, iid3]}) )

		client.identify(uid2)
		try:
			itemrec = client.get_itemrec_topn(engine_name, 10)
		except predictionio.ItemRecNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemrec
		self.assertTrue( (itemrec == {"pio_iids": [iid3, iid0, iid1, iid2]}) or
						 (itemrec == {"pio_iids": [iid3, iid1, iid0, iid2]}) )

		client.identify(uid3)
		try:
			itemrec = client.get_itemrec_topn(engine_name, 6)
		except predictionio.ItemRecNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemrec
		self.assertTrue( (itemrec == {"pio_iids": [iid0, iid1, iid2, iid3]}) or
						 (itemrec == {"pio_iids": [iid0, iid2, iid1, iid3]}) )

		# request less
		client.identify(uid0)
		try:
			itemrec = client.get_itemrec_topn(engine_name, 1)
		except predictionio.ItemRecNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemrec
		self.assertEqual(itemrec, {"pio_iids": [iid2]})

		client.identify(uid0)
		try:
			itemrec = client.get_itemrec_topn(engine_name, 2)
		except predictionio.ItemRecNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemrec
		self.assertEqual(itemrec, {"pio_iids": [iid2, iid3]})

		# request with optional attributes

		# pio_itypes
		client.identify(uid0)
		try:
			itemrec = client.get_itemrec_topn(engine_name, 10, {"pio_itypes": ("t1","t2")})
		except predictionio.ItemRecNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemrec
		self.assertEqual(itemrec, {"pio_iids": [iid2, iid3, iid1, iid0]})

		# subset itypes
		client.identify(uid0)
		try:
			itemrec = client.get_itemrec_topn(engine_name, 10, {"pio_itypes": ("t2",)})
		except predictionio.ItemRecNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemrec
		self.assertEqual(itemrec, {"pio_iids": [iid2, iid1]})

		# nonexisting itypes
		client.identify(uid0)
		try:
			itemrec = client.get_itemrec_topn(engine_name, 10, {"pio_itypes": ("other-itype",)})
		except predictionio.ItemRecNotFoundError as e:
			pass # expected no recommendation
		except:
			raise

		# pio_attributes
		client.identify(uid0)
		try:
			itemrec = client.get_itemrec_topn(engine_name, 10, {"pio_itypes": ("t1",), "pio_attributes": ["custom1", "custom2"]})
		except predictionio.ItemRecNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemrec
		self.assertEqual(itemrec, {"pio_iids": [iid2, iid3, iid1, iid0], "custom1": [None, None, "i1c1", "i0c1"], "custom2": ["i2c2", None, "i1c2", None]})

		# TODO pio_latlng
		# TODO pio_within
		# TODO pio_unit

		client.close()

if __name__ == "__main__" :
	unittest.main()

########NEW FILE########
__FILENAME__ = predictionio_itemsim_test
"""
Test getting itemsim after algo training completes (pdio-itemsimcf with cosine sim).
"""
import predictionio
import unittest
import time

APP_KEY = "y2Fk4BACEGYeJnqBF4zL9TmrIBdF9va3gyFaLsnM7PVyUNf0G00zC8vCnyBx5hdA" # replace this with your AppKey
API_URL = "http://localhost:8000" # PredictoinIO Server

DEBUG = True

MIN_VERSION = '0.6.0'
if predictionio.__version__ < MIN_VERSION:
	err = "Require PredictionIO Python SDK version >= %s" % MIN_VERSION
	raise Exception(err)

class TestPredictionIO(unittest.TestCase):
	def setUp(self):
		pass

	def tearDown(self):
		pass

	def test_get_itemsim_exception(self):
		client = predictionio.Client(APP_KEY, 1, API_URL)

		try:
			itemsim = client.get_itemsim_topn("python-itemsim-engine", "iidwithoutsim", 10)
		except predictionio.ItemSimNotFoundError as e:
			pass # expected exception
		except:
			raise

		try:
			itemsim = client.get_itemsim_topn("python-itemsim-engine", "iidwithoutsim", 10, { "pio_itypes": ("t1",), "pio_latlng": [1.34, 5.67], "pio_within": 5.0, "pio_unit": "km", "pio_attributes": ["custom1", "custom2"]  })
		except predictionio.ItemSimNotFoundError as e:
			pass # expected exception
		except:
			raise

		client.close()

	def test_get_itemsim(self):
		client = predictionio.Client(APP_KEY, 1, API_URL)

		# request more than what is available
		try:
			itemsim = client.get_itemsim_topn("python-itemsim-engine", "i0", 10)
		except predictionio.ItemSimNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemsim
		self.assertTrue( (itemsim == {"pio_iids": ["i1", "i2", "i3"]}) or
						 (itemsim == {"pio_iids": ["i1", "i3", "i2"]}) )

		try:
			itemsim = client.get_itemsim_topn("python-itemsim-engine", "i1", 10)
		except predictionio.ItemSimNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemsim
		self.assertTrue( (itemsim == {"pio_iids": ["i2", "i3", "i0"]}) )

		try:
			itemsim = client.get_itemsim_topn("python-itemsim-engine", "i2", 10)
		except predictionio.ItemSimNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemsim
		self.assertTrue( (itemsim == {"pio_iids": ["i1", "i3", "i0"]}) )

		try:
			itemsim = client.get_itemsim_topn("python-itemsim-engine", "i3", 10)
		except predictionio.ItemSimNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemsim
		self.assertTrue( (itemsim == {"pio_iids": ["i1", "i2", "i0"]}) )

		# request less
		try:
			itemsim = client.get_itemsim_topn("python-itemsim-engine", "i1", 1)
		except predictionio.ItemSimNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemsim
		self.assertEqual(itemsim, {"pio_iids": ["i2"]})

		try:
			itemsim = client.get_itemsim_topn("python-itemsim-engine", "i1", 2)
		except predictionio.ItemSimNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemsim
		self.assertEqual(itemsim, {"pio_iids": ["i2", "i3"]})

		# request with optional attributes

		# pio_itypes
		try:
			itemsim = client.get_itemsim_topn("python-itemsim-engine", "i1", 10, {"pio_itypes": ("t1","t2")})
		except predictionio.ItemSimNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemsim
		self.assertEqual(itemsim, {"pio_iids": ["i2", "i3", "i0"]})

		# subset itypes
		try:
			itemsim = client.get_itemsim_topn("python-itemsim-engine", "i1", 10, {"pio_itypes": ("t2",)})
		except predictionio.ItemSimNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemsim
		self.assertEqual(itemsim, {"pio_iids": ["i2"]})

		# nonexisting itypes
		try:
			itemsim = client.get_itemsim_topn("python-itemsim-engine", "i0", 10, {"pio_itypes": ("other-itype",)})
		except predictionio.ItemSimNotFoundError as e:
			pass # expected no recommendation
		except:
			raise

		# pio_attributes
		try:
			itemsim = client.get_itemsim_topn("python-itemsim-engine", "i1", 10, {"pio_itypes": ("t1",), "pio_attributes": ["custom1", "custom2"]})
		except predictionio.ItemSimNotFoundError as e:
			print "ERROR: have you run import_testdata.py and then wait for the algorithm training completion?"
			raise
		except:
			raise
		if DEBUG: print itemsim
		self.assertEqual(itemsim, {"pio_iids": ["i2", "i3", "i0"], "custom1": [None, None, "i0c1"], "custom2": ["i2c2", None, None]})

		# TODO pio_latlng
		# TODO pio_within
		# TODO pio_unit

		client.close()

if __name__ == "__main__" :
	unittest.main()

########NEW FILE########
__FILENAME__ = predictionio_test
"""
Test Python SDK
"""
import predictionio
import unittest
import time

APP_KEY = "GToKwk78As0LBp2fAx2YNUBPZFZvtwy6MJkGwRASiD6Q77JjBnTaXBxzBTd52ICE" # replace this with your AppKey
API_URL = "http://localhost:8000" # PredictoinIO Server

MIN_VERSION = '0.6.0'
if predictionio.__version__ < MIN_VERSION:
    err = "Require PredictionIO Python SDK version >= %s" % MIN_VERSION
    raise Exception(err)

#print predictionio.__version__
#predictionio.connection.enable_log()

class TestPredictionIO(unittest.TestCase):

    def setUp(self):
        pass

    def tearDown(self):
        pass

    def test_status(self):
        client = predictionio.Client(APP_KEY, 1, API_URL)
        status = client.get_status()
        self.assertEqual(status, "PredictionIO Output API is online.")
        client.close()

    def _test_user(self, uids):
        client = predictionio.Client(APP_KEY, 1, API_URL)

        uid1 = uids[0]
        uid2 = uids[1]
        uid3 = uids[2]
        uid4 = uids[3]
        uid5 = uids[4]

        # create users and get them back
        client.create_user(uid1)
        # create user with optional attributes
        client.create_user(uid2, { "pio_latlng": [1.2,33.3] })
        client.create_user(uid3, { "pio_latlng": [4.5,67.8], "pio_inactive": True } )
        # create user with custom attributes
        client.create_user(uid4, { "pio_latlng": [1.2,33.3], "custom1": "value1", "custom2": "value2" })
        client.create_user(uid5, { "custom1": "u5c1", "custom2": "u5c2" })

        user1 = client.get_user(uid1)
        user2 = client.get_user(uid2)
        user3 = client.get_user(uid3)
        user4 = client.get_user(uid4)
        user5 = client.get_user(uid5)

        self.assertEqual(user1, {"pio_uid" : uid1})
        self.assertEqual(user2, {"pio_uid" : uid2, "pio_latlng": [1.2,33.3]})
        self.assertEqual(user3, {"pio_uid" : uid3, "pio_latlng" : [4.5,67.8], "pio_inactive" : True})
        self.assertEqual(user4, {"pio_uid" : uid4, "pio_latlng": [1.2,33.3], "custom1": "value1", "custom2": "value2" })
        self.assertEqual(user5, {"pio_uid" : uid5, "custom1": "u5c1", "custom2": "u5c2"  })

        # delete user and then try to get it
        client.delete_user(uid1)

        try:
            user = client.get_user(uid1)
        except predictionio.UserNotFoundError as e:
            pass # expected exception
        except:
            raise

        # other users still exist
        user2 = client.get_user(uid2)
        self.assertEqual(user2, {"pio_uid" : uid2, "pio_latlng": [1.2,33.3]})

        # read, modify, write
        user3 = client.get_user(uid3)
        self.assertEqual(user3, {"pio_uid" : uid3, "pio_latlng" : [4.5,67.8], "pio_inactive" : True})
        del user3["pio_uid"]
        user3["pio_latlng"] = [5.6,10.11]
        user3["pio_inactive"] = False
        user3["custom1"] = "food"
        client.create_user(uid3, user3)
        updated_user3 = client.get_user(uid3)
        self.assertEqual(updated_user3, {"pio_uid" : uid3, "pio_latlng" : [5.6,10.11], "pio_inactive" : False, "custom1" : "food"} )

        user4 = client.get_user(uid4)
        self.assertEqual(user4, {"pio_uid" : uid4, "pio_latlng": [1.2,33.3], "custom1": "value1", "custom2": "value2" })
        del user4["pio_uid"]
        user4["custom1"] = "new value"
        client.create_user(uid4, user4)
        updated_user4 = client.get_user(uid4)
        self.assertEqual(updated_user4, {"pio_uid" : uid4, "pio_latlng": [1.2,33.3], "custom1": "new value", "custom2": "value2" })

        client.close()

    def test_user(self):
        self._test_user(["u1", "u2", "u3", "u4", "u5"])
        # test special characters in uid
        self._test_user(["u1@a.com", "u2@ap/ple", "u3@foo.bar", "u4/a/b", "&^%$()u5"])

    def _test_item(self, iids):
        client = predictionio.Client(APP_KEY, 1, API_URL)

        iid1 = iids[0]
        iid2 = iids[1]
        iid3 = iids[2]
        iid4 = iids[3]
        iid5 = iids[4]

        # create items and read back
        client.create_item(iid1, ("t1","t2","t3"))
        client.create_item(iid2, ("t1",))
        client.create_item(iid3, ("t2",), {"pio_price": 4.99, "pio_profit": 2.0, "pio_startT": 12345667, "pio_endT": 4567788, "pio_latlng": [1.345, 9.876], "pio_inactive": True })
        client.create_item(iid4, ("t2",), {"pio_latlng": [1.2345, 10.11], "custom1": "value1"})
        client.create_item(iid5, ("t1", "t2"), {"custom1": "i5value1", "custom2": "i5value2"} )

        item1 = client.get_item(iid1)
        item2 = client.get_item(iid2)
        item3 = client.get_item(iid3)
        item4 = client.get_item(iid4)
        item5 = client.get_item(iid5)

        del item1["pio_startT"] # pio_startT is automatically inserted, don't compare
        self.assertEqual(item1, {"pio_iid": iid1, "pio_itypes": ("t1", "t2", "t3") } )
        del item2["pio_startT"]
        self.assertEqual(item2, {"pio_iid": iid2, "pio_itypes": ("t1",)} )
        self.assertEqual(item3, {"pio_iid": iid3, "pio_itypes": ("t2",), "pio_price": 4.99, "pio_profit": 2.0, "pio_startT": 12345667, "pio_endT": 4567788, "pio_latlng": [1.345, 9.876], "pio_inactive": True } )
        del item4["pio_startT"]
        self.assertEqual(item4, {"pio_iid": iid4, "pio_itypes": ("t2",), "pio_latlng": [1.2345, 10.11], "custom1": "value1"})
        del item5["pio_startT"]
        self.assertEqual(item5, {"pio_iid": iid5, "pio_itypes": ("t1","t2"), "custom1": "i5value1", "custom2": "i5value2"})

        # delete and then try to get it
        client.delete_item(iid2)

        try:
          item2 = client.get_item(iid2)
        except predictionio.ItemNotFoundError as e:
            pass # expected exception
        except:
            raise

        # others still exist
        item3 = client.get_item(iid3)
        self.assertEqual(item3, {"pio_iid": iid3, "pio_itypes": ("t2",), "pio_price": 4.99, "pio_profit": 2.0, "pio_startT": 12345667, "pio_endT": 4567788, "pio_latlng": [1.345, 9.876], "pio_inactive": True } )

        # read, modify, write
        del item3["pio_iid"]
        item3_itypes = item3.pop("pio_itypes")
        item3["pio_price"] = 6.99
        item3["custom1"] = "some value"
        client.create_item(iid3, item3_itypes, item3)
        updated_item3 = client.get_item(iid3)
        self.assertEqual(updated_item3, {"pio_iid": iid3, "pio_itypes": ("t2",), "pio_price": 6.99, "pio_profit": 2.0, "pio_startT": 12345667, "pio_endT": 4567788, "pio_latlng": [1.345, 9.876], "pio_inactive": True, "custom1": "some value" } )

        client.close()

    def test_item(self):
        self._test_item(["i1", "i2", "i3", "i4", "i5"])
        # test special characters in iid
        self._test_item(["i1@abc.com", "i2/f/bar//@@foo", "$$i3%%$~~", "http://www.i4.com", "``i5/apple/"])

    def test_u2iAction_deprecated(self):
        client = predictionio.Client(APP_KEY, 1, API_URL)

        client.user_like_item("u1", "i1")
        client.user_dislike_item("u2", "i2")
        client.user_view_item("u3", "i3")
        client.user_rate_item("u4", "i4", 4)
        client.user_conversion_item("u5", "i5")

        client.close()

    def test_u2iAction(self):
        client = predictionio.Client(APP_KEY, 1, API_URL)

        client.identify("u101")

        # required param
        client.record_action_on_item("like", "i1")
        client.record_action_on_item("dislike", "i2")
        client.record_action_on_item("view", "i3")
        client.record_action_on_item("rate", "i4", { "pio_rate": 1 })
        client.record_action_on_item("conversion", "i5")

        client.identify("u102")

        # with optional param
        client.record_action_on_item("like", "i1", { "pio_latlng": [1.23, 4.56] })
        client.record_action_on_item("dislike", "i2", { "pio_t": 1234567689 })
        client.record_action_on_item("view", "i3", { "pio_latlng": [4.67, 1.44], "pio_t": 3445566778})
        client.record_action_on_item("rate", "i4", { "pio_rate": 1, "pio_latlng": [66.78, 9.10] })
        client.record_action_on_item("conversion", "i5", { "pio_price" : 12.5 })


        # uid and iid with special characters
        client.identify("u1@a.com")
        client.record_action_on_item("view", "i3@bb.com")
        client.record_action_on_item("view", "http://www.yahoo.com")

        client.close()


    def test_pending_requests(self):
        client = predictionio.Client(APP_KEY, 1, API_URL)

        client.identify("u111")
        for i in range(100):
            client.arecord_action_on_item("like", str(i))

        n = 1
        while n > 0:
            n = client.pending_requests()
            time.sleep(0.1)
            #print n

        client.close()

    def test_qsize(self):
        client = predictionio.Client(APP_KEY, 1, API_URL, qsize=10)

        client.identify("u222")
        for i in range(100):
            client.arecord_action_on_item("like", str(i))

        n = 1
        while n > 0:
            n = client.pending_requests()
            time.sleep(0.1)
            #print n

        client.close()



"""
to run individual test:
$ python -m unittest predictionio_test.TestPredictionIO.test_user

to run ALL tests:
% python predictionio_test.py
"""
if __name__ == "__main__" :
    unittest.main()

########NEW FILE########
