__FILENAME__ = fix_def_iteritems
"""Fixer for iteritems -> items methods."""
# Author: Valentin Lorentz

# Code modified from fix_nonzero by Collin Winter

from lib2to3 import fixer_base
from lib2to3.fixer_util import Name, syms

class FixDefIteritems(fixer_base.BaseFix):
    BM_compatible = True
    PATTERN = """
    classdef< 'class' any+ ':'
              suite< any*
                     funcdef< 'def' name='iteritems'
                              parameters< '(' NAME ')' > any+ >
                     any* > >
    """

    def transform(self, node, results):
        name = results["name"]
        new = Name("items", prefix=name.prefix)
        name.replace(new)

########NEW FILE########
__FILENAME__ = fix_def_iterkeys
"""Fixer for iterkeys -> keys methods."""
# Author: Valentin Lorentz

# Code modified from fix_nonzero by Collin Winter

from lib2to3 import fixer_base
from lib2to3.fixer_util import Name, syms

class FixDefIterkeys(fixer_base.BaseFix):
    BM_compatible = True
    PATTERN = """
    classdef< 'class' any+ ':'
              suite< any*
                     funcdef< 'def' name='iterkeys'
                              parameters< '(' NAME ')' > any+ >
                     any* > >
    """

    def transform(self, node, results):
        name = results["name"]
        new = Name("keys", prefix=name.prefix)
        name.replace(new)

########NEW FILE########
__FILENAME__ = fix_def_itervalues
"""Fixer for itervalues -> values methods."""
# Author: Valentin Lorentz

# Code modified from fix_nonzero by Collin Winter

from lib2to3 import fixer_base
from lib2to3.fixer_util import Name, syms

class FixDefItervalues(fixer_base.BaseFix):
    BM_compatible = True
    PATTERN = """
    classdef< 'class' any+ ':'
              suite< any*
                     funcdef< 'def' name='itervalues'
                              parameters< '(' NAME ')' > any+ >
                     any* > >
    """

    def transform(self, node, results):
        name = results["name"]
        new = Name("values", prefix=name.prefix)
        name.replace(new)

########NEW FILE########
__FILENAME__ = fix_import
"""Fixer for import statements.
If spam is being imported from the local directory, this import:
    from spam import eggs
Becomes:
    from .spam import eggs

And this import:
    import spam
Becomes:
    from . import spam
"""

# Local imports
from lib2to3 import fixer_base
from os.path import dirname, join, exists, sep, split, isdir
from os import listdir
from lib2to3.fixer_util import FromImport, syms, token


def traverse_imports(names):
    """
    Walks over all the names imported in a dotted_as_names node.
    """
    pending = [names]
    while pending:
        node = pending.pop()
        if node.type == token.NAME:
            yield node.value
        elif node.type == syms.dotted_name:
            yield "".join([ch.value for ch in node.children])
        elif node.type == syms.dotted_as_name:
            pending.append(node.children[0])
        elif node.type == syms.dotted_as_names:
            pending.extend(node.children[::-2])
        else:
            raise AssertionError("unkown node type")


class FixImport(fixer_base.BaseFix):
    BM_compatible = True

    PATTERN = """
    import_from< 'from' imp=any 'import' ['('] any [')'] >
    |
    import_name< 'import' imp=any >
    """

    def start_tree(self, tree, name):
        super(FixImport, self).start_tree(tree, name)
        self.skip = "absolute_import" in tree.future_features

    def transform(self, node, results):
        if self.skip:
            return
        imp = results['imp']

        if node.type == syms.import_from:
            # Some imps are top-level (eg: 'import ham')
            # some are first level (eg: 'import ham.eggs')
            # some are third level (eg: 'import ham.eggs as spam')
            # Hence, the loop
            while not hasattr(imp, 'value'):
                imp = imp.children[0]
            if self.probably_a_local_import(imp.value):
                imp.value = "." + imp.value
                imp.changed()
        else:
            have_local = False
            have_absolute = False
            for mod_name in traverse_imports(imp):
                if self.probably_a_local_import(mod_name):
                    have_local = True
                else:
                    have_absolute = True
            if have_absolute:
                if have_local:
                    # We won't handle both sibling and absolute imports in the
                    # same statement at the moment.
                    self.warning(node, "absolute and local imports together")
                return

            new = FromImport(".", [imp])
            new.prefix = node.prefix
            return new

    def probably_a_local_import(self, imp_name):
        if imp_name.startswith("."):
            # Relative imports are certainly not local imports.
            return False
        imp_name = imp_name.split(".", 1)[0]
        base_path = dirname(self.filename)
        base_path = join(base_path, imp_name)
        # If there is no __init__.py next to the file its not in a package
        # so can't be a relative import.
        if not exists(join(dirname(base_path), "__init__.py")):
            return False
        (path, filename) = split(base_path)
        if isdir(base_path) and filename in listdir(path):
            # We use listdir too because of case-insensitivity on Windows
            return True
        for ext in [".py", ".pyc", ".so", ".sl", ".pyd"]:
            if (filename + ext) in listdir(path):
                # We use this instead of os.path.exists because of case-insensitivity
                # on Windows
                return True
        return False

########NEW FILE########
__FILENAME__ = fix_reload
# Based on fix_intern.py. Original copyright:
# Copyright 2006 Georg Brandl.
# Licensed to PSF under a Contributor Agreement.

"""Fixer for intern().

intern(s) -> sys.intern(s)"""

# Local imports
from lib2to3 import pytree
from lib2to3 import fixer_base
from lib2to3.fixer_util import Name, Attr, touch_import


class FixReload(fixer_base.BaseFix):
    BM_compatible = True
    order = "pre"

    PATTERN = """
    power< 'reload'
           after=any*
    >
    """

    def transform(self, node, results):
        touch_import('imp', 'reload', node)
        return node

########NEW FILE########
__FILENAME__ = run
#!/usr/bin/env python
import os
import sys
import shutil
from glob import glob
try:
    from lib2to3.main import main
except ImportError:
    print('Error: you need the 2to3 tool to run this script.')
os.chdir(os.path.join(os.path.dirname(__file__), '..'))
try:
    os.unlink('src/version.py')
except OSError:
    pass
try:
    shutil.rmtree('py3k')
except OSError:
    pass
os.mkdir('py3k')
for dirname in ('locales', 'docs', 'plugins', 'src', 'test', 'scripts'):
    shutil.copytree(dirname, os.path.join('py3k', dirname))
for filename in ('setup.py',):
    shutil.copyfile(filename, os.path.join('py3k', filename))
os.chdir('py3k')

files = ['run.py', 'src', 'plugins', 'test', 'setup.py'] + glob('scripts/*')
args = ['-wn']
fixers = []
for fix in ['all', 'def_iteritems', 'def_itervalues', 'def_iterkeys', 'reload', 'import']:
    fixers += ['-f', fix]
sys.argv = files + args + fixers + sys.argv
sys.argc = len(sys.argv)

from . import fix_def_iteritems, fix_def_itervalues, fix_def_iterkeys, fix_reload, fix_import

# Hacks
sys.modules['lib2to3.fixes.fix_def_iteritems'] = fix_def_iteritems
sys.modules['lib2to3.fixes.fix_def_itervalues'] = fix_def_itervalues
sys.modules['lib2to3.fixes.fix_def_iterkeys'] = fix_def_iterkeys
sys.modules['lib2to3.fixes.fix_reload'] = fix_reload
sys.modules['lib2to3.fixes.fix_import'] = fix_import

sys.exit(main("lib2to3.fixes"))

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Supybot documentation build configuration file, created by
# sphinx-quickstart on Sat Feb 27 12:42:30 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.append(os.path.abspath('../src'))
#sys.path.append(os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Supybot'
copyright = u'2010, Jeremiah Fincher and James McCoy'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.83.4.1'
# The full version, including alpha/beta/rc tags.
release = '0.83.4.1+git+fr3'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
modindex_common_prefix = ['supybot']


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'Supybotdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Supybot.tex', u'Supybot Documentation',
   u'Jeremiah Fincher and James McCoy', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

########NEW FILE########
__FILENAME__ = fr
# -*- encoding: utf8 -*-
###
# Copyright (c) 2010, Valentin Lorentz
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

"""
Supybot utility functions localization in French.
"""

def pluralize(s):
    """Returns the plural of s.
    """
    lowered = s.lower()
    if lowered.endswith('ou') and \
        lowered in ['bijou', 'caillou', 'chou', 'genou', 'hibou', 'joujou',
                    'pou']:
        return s + 'x'
    elif lowered.endswith('al') and \
        lowered not in ['bal', 'carnaval', 'chacal', 'festival', 'récital',
                  'régal', 'cal', 'étal', 'aval', 'caracal', 'val', 'choral',
                  'corral', 'galgal', 'gayal']:
        return s[0:-2] + 'aux'
    elif lowered.endswith('ail') and \
        lowered not in ['bail', 'corail', 'émail', 'soupirail', 'travail',
                        'ventail', 'vitrail', 'aspirail', 'fermail']:
        return s[0:-3] + 'aux'
    elif lowered.endswith('eau'):
        return s + 'x'
    elif lowered == 'pare-feu':
        return s
    elif lowered.endswith('eu') and \
        lowered not in ['bleu', 'pneu', 'émeu', 'enfeu']:
        # Note: when 'lieu' is a fish, it has a 's' ; else, it has a 'x'
        return s + 'x'
    else:
        return s + 's'

def depluralize(s):
    """Returns the singular of s."""
    lowered = s.lower()
    if lowered.endswith('aux') and \
        lowered in ['baux', 'coraux', 'émaux', 'soupiraux', 'travaux',
                        'ventaux', 'vitraux', 'aspiraux', 'fermaux']:
        return s[0:-3] + 'ail'
    elif lowered.endswith('aux'):
        return s[0:-3] + 'al'
    else:
        return s[0:-1]

def ordinal(i):
    """Returns i + the ordinal indicator for the number.

    Example: ordinal(3) => '3ème'
    """
    i = int(i)
    if i == 1:
        return '1er'
    else:
        return '%sème' % i

def be(i):
    """Returns the form of the verb 'être' based on the number i."""
    # Note: this function is used only for the third person
    if i == 1:
        return 'est'
    else:
        return 'sont'

def has(i):
    """Returns the form of the verb 'avoir' based on the number i."""
    # Note: this function is used only for the third person
    if i == 1:
        return 'a'
    else:
        return 'ont'

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2004-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###


import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Admin')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Admin', True)


Admin = conf.registerPlugin('Admin')
# This is where your configuration variables (if any) should go.  For example:
# conf.registerGlobalValue(Admin, 'someConfigVariableName',
#     registry.Boolean(False, """Help for someConfigVariableName."""))

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# Copyright (c) 2010, Valentin Lorentz
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import sys
import time

import supybot.conf as conf
import supybot.ircdb as ircdb
import supybot.utils as utils
from supybot.commands import *
import supybot.ircmsgs as ircmsgs
import supybot.ircutils as ircutils
import supybot.schedule as schedule
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Admin')

class Admin(callbacks.Plugin):
    def __init__(self, irc):
        self.__parent = super(Admin, self)
        self.__parent.__init__(irc)
        self.joins = {}
        self.pendingNickChanges = {}

    @internationalizeDocstring
    def do437(self, irc, msg):
        """Nick/channel temporarily unavailable."""
        target = msg.args[0]
        if irc.isChannel(target): # We don't care about nicks.
            t = time.time() + 30
            # Let's schedule a rejoin.
            networkGroup = conf.supybot.networks.get(irc.network)
            def rejoin():
                irc.queueMsg(networkGroup.channels.join(target))
                # We don't need to schedule something because we'll get another
                # 437 when we try to join later.
            schedule.addEvent(rejoin, t)
            self.log.info('Scheduling a rejoin to %s at %s; '
                          'Channel temporarily unavailable.', target, t)

    def do471(self, irc, msg):
        try:
            channel = msg.args[1]
            (irc, msg) = self.joins.pop(channel)
            irc.error(_('Cannot join %s, it\'s full.') % channel)
        except KeyError:
            self.log.debug('Got 471 without Admin.join being called.')

    def do473(self, irc, msg):
        try:
            channel = msg.args[1]
            (irc, msg) = self.joins.pop(channel)
            irc.error(_('Cannot join %s, I was not invited.') % channel)
        except KeyError:
            self.log.debug('Got 473 without Admin.join being called.')

    def do474(self, irc, msg):
        try:
            channel = msg.args[1]
            (irc, msg) = self.joins.pop(channel)
            irc.error(_('Cannot join %s, I am banned.') % channel)
        except KeyError:
            self.log.debug('Got 474 without Admin.join being called.')

    def do475(self, irc, msg):
        try:
            channel = msg.args[1]
            (irc, msg) = self.joins.pop(channel)
            irc.error(_('Cannot join %s, my keyword was wrong.') % channel)
        except KeyError:
            self.log.debug('Got 475 without Admin.join being called.')

    def do477(self, irc, msg):
        try:
            channel = msg.args[1]
            (irc,msg) = self.joins.pop(channel)
            irc.error(_('Cannot join %s, I\'m not identified with '
                      'NickServ.') % channel)
        except KeyError:
            self.log.debug('Got 477 without Admin.join being called.')

    def do515(self, irc, msg):
        try:
            channel = msg.args[1]
            (irc, msg) = self.joins.pop(channel)
            irc.error(_('Cannot join %s, I\'m not identified with '
                      'NickServ.') % channel)
        except KeyError:
            self.log.debug('Got 515 without Admin.join being called.')

    def doJoin(self, irc, msg):
        if msg.prefix == irc.prefix:
            try:
                del self.joins[msg.args[0]]
            except KeyError:
                s = 'Joined a channel without Admin.join being called.'
                self.log.debug(s)

    def doInvite(self, irc, msg):
        channel = msg.args[1]
        if channel not in irc.state.channels:
            if conf.supybot.alwaysJoinOnInvite.get(channel)() or \
               ircdb.checkCapability(msg.prefix, 'admin'):
                self.log.info('Invited to %s by %s.', channel, msg.prefix)
                networkGroup = conf.supybot.networks.get(irc.network)
                irc.queueMsg(networkGroup.channels.join(channel))
                conf.supybot.networks.get(irc.network).channels().add(channel)
            else:
                self.log.warning('Invited to %s by %s, but '
                                 'supybot.alwaysJoinOnInvite was False and '
                                 'the user lacked the "admin" capability.',
                                 channel, msg.prefix)

    @internationalizeDocstring
    def join(self, irc, msg, args, channel, key):
        """<channel> [<key>]

        Tell the bot to join the given channel.  If <key> is given, it is used
        when attempting to join the channel.
        """
        if not irc.isChannel(channel):
            irc.errorInvalid('channel', channel, Raise=True)
        networkGroup = conf.supybot.networks.get(irc.network)
        networkGroup.channels().add(channel)
        if key:
            networkGroup.channels.key.get(channel).setValue(key)
        maxchannels = irc.state.supported.get('maxchannels', sys.maxsize)
        if len(irc.state.channels) + 1 > maxchannels:
            irc.error(_('I\'m already too close to maximum number of '
                      'channels for this network.'), Raise=True)
        irc.queueMsg(networkGroup.channels.join(channel))
        irc.noReply()
        self.joins[channel] = (irc, msg)
    join = wrap(join, ['validChannel', additional('something')])

    @internationalizeDocstring
    def channels(self, irc, msg, args):
        """takes no arguments

        Returns the channels the bot is on.  Must be given in private, in order
        to protect the secrecy of secret channels.
        """
        L = irc.state.channels.keys()
        if L:
            utils.sortBy(ircutils.toLower, L)
            irc.reply(format('%L', L))
        else:
            irc.reply(_('I\'m not currently in any channels.'))
    channels = wrap(channels, ['private'])

    def do484(self, irc, msg):
        irc = self.pendingNickChanges.get(irc, None)
        if irc is not None:
            irc.error(_('My connection is restricted, I can\'t change nicks.'))
        else:
            self.log.debug('Got 484 without Admin.nick being called.')

    def do433(self, irc, msg):
        irc = self.pendingNickChanges.get(irc, None)
        if irc is not None:
            irc.error(_('Someone else is already using that nick.'))
        else:
            self.log.debug('Got 433 without Admin.nick being called.')

    def do435(self, irc, msg):
        irc = self.pendingNickChanges.get(irc, None)
        if irc is not None:
            irc.error(_('That nick is currently banned.'))
        else:
            self.log.debug('Got 435 without Admin.nick being called.')

    def do438(self, irc, msg):
        irc = self.pendingNickChanges.get(irc, None)
        if irc is not None:
            irc.error(format(_('I can\'t change nicks, the server said %q.'),
                      msg.args[2]), private=True)
        else:
            self.log.debug('Got 438 without Admin.nick being called.')

    def doNick(self, irc, msg):
        if msg.nick == irc.nick or msg.args[0] == irc.nick:
            try:
                del self.pendingNickChanges[irc]
            except KeyError:
                self.log.debug('Got NICK without Admin.nick being called.')

    @internationalizeDocstring
    def nick(self, irc, msg, args, nick, network):
        """[<nick>] [<network>]

        Changes the bot's nick to <nick>.  If no nick is given, returns the
        bot's current nick.
        """
        network = network or irc.network
        if nick:
            group = getattr(conf.supybot.networks, network)
            group.nick.setValue(nick)
            irc.queueMsg(ircmsgs.nick(nick))
            self.pendingNickChanges[irc.getRealIrc()] = irc
        else:
            irc.reply(irc.nick)
    nick = wrap(nick, [additional('nick'), additional('something')])

    @internationalizeDocstring
    def part(self, irc, msg, args, channel, reason):
        """[<channel>] [<reason>]

        Tells the bot to part the list of channels you give it.  <channel> is
        only necessary if you want the bot to part a channel other than the
        current channel.  If <reason> is specified, use it as the part
        message.
        """
        if channel is None:
            if irc.isChannel(msg.args[0]):
                channel = msg.args[0]
            else:
                irc.error(Raise=True)
        try:
            network = conf.supybot.networks.get(irc.network)
            network.channels().remove(channel)
        except KeyError:
            pass
        if channel not in irc.state.channels:
            irc.error(_('I\'m not in %s.') % channel, Raise=True)
        irc.queueMsg(ircmsgs.part(channel, reason or msg.nick))
        if msg.nick in irc.state.channels[channel].users:
            irc.noReply()
        else:
            irc.replySuccess()
    part = wrap(part, [optional('validChannel'), additional('text')])

    class capability(callbacks.Commands):

        @internationalizeDocstring
        def add(self, irc, msg, args, user, capability):
            """<name|hostmask> <capability>

            Gives the user specified by <name> (or the user to whom <hostmask>
            currently maps) the specified capability <capability>
            """
            # Ok, the concepts that are important with capabilities:
            #
            ### 1) No user should be able to elevate their privilege to owner.
            ### 2) Admin users are *not* superior to #channel.ops, and don't
            ###    have God-like powers over channels.
            ### 3) We assume that Admin users are two things: non-malicious and
            ###    and greedy for power.  So they'll try to elevate their
            ###    privilege to owner, but they won't try to crash the bot for
            ###    no reason.

            # Thus, the owner capability can't be given in the bot.  Admin
            # users can only give out capabilities they have themselves (which
            # will depend on supybot.capabilities and its child default) but
            # generally means they can't mess with channel capabilities.
            if ircutils.strEqual(capability, 'owner'):
                irc.error(_('The "owner" capability can\'t be added in the '
                          'bot.  Use the supybot-adduser program (or edit the '
                          'users.conf file yourself) to add an owner '
                          'capability.'))
                return
            if ircdb.isAntiCapability(capability) or \
               ircdb.checkCapability(msg.prefix, capability):
                user.addCapability(capability)
                ircdb.users.setUser(user)
                irc.replySuccess()
            else:
                irc.error(_('You can\'t add capabilities you don\'t have.'))
        add = wrap(add, ['otherUser', 'lowered'])

        @internationalizeDocstring
        def remove(self, irc, msg, args, user, capability):
            """<name|hostmask> <capability>

            Takes from the user specified by <name> (or the user to whom
            <hostmask> currently maps) the specified capability <capability>
            """
            if ircdb.checkCapability(msg.prefix, capability) or \
               ircdb.isAntiCapability(capability):
                try:
                    user.removeCapability(capability)
                    ircdb.users.setUser(user)
                    irc.replySuccess()
                except KeyError:
                    irc.error(_('That user doesn\'t have that capability.'))
            else:
                s = _('You can\'t remove capabilities you don\'t have.')
                irc.error(s)
        remove = wrap(remove, ['otherUser','lowered'])

    class ignore(callbacks.Commands):

        @internationalizeDocstring
        def add(self, irc, msg, args, hostmask, expires):
            """<hostmask|nick> [<expires>]

            This will set a persistent ignore on <hostmask> or the hostmask
            currently associated with <nick>. <expires> is an optional argument
            specifying when (in "seconds from now") the ignore will expire; if
            it isn't given, the ignore will never automatically expire.
            """
            ircdb.ignores.add(hostmask, expires)
            irc.replySuccess()
        add = wrap(add, ['hostmask', additional('expiry', 0)])

        @internationalizeDocstring
        def remove(self, irc, msg, args, hostmask):
            """<hostmask|nick>

            This will remove the persistent ignore on <hostmask> or the
            hostmask currently associated with <nick>.
            """
            try:
                ircdb.ignores.remove(hostmask)
                irc.replySuccess()
            except KeyError:
                irc.error(_('%s wasn\'t in the ignores database.') % hostmask)
        remove = wrap(remove, ['hostmask'])

        @internationalizeDocstring
        def list(self, irc, msg, args):
            """takes no arguments

            Lists the hostmasks that the bot is ignoring.
            """
            # XXX Add the expirations.
            if ircdb.ignores.hostmasks:
                irc.reply(format('%L', (list(map(repr,ircdb.ignores.hostmasks)))))
            else:
                irc.reply(_('I\'m not currently globally ignoring anyone.'))
        list = wrap(list)

    def clearq(self, irc, msg, args):
        """takes no arguments

        Clears the current send queue for this network.
        """
        irc.queue.reset()
        irc.replySuccess()
    clearq = wrap(clearq)



Class = Admin

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

class AdminTestCase(PluginTestCase):
    plugins = ('Admin',)
    def testChannels(self):
        def getAfterJoinMessages():
            m = self.irc.takeMsg()
            self.assertEqual(m.command, 'MODE')
            m = self.irc.takeMsg()
            self.assertEqual(m.command, 'MODE')
            m = self.irc.takeMsg()
            self.assertEqual(m.command, 'WHO')
        self.assertRegexp('channels', 'not.*in any')
        self.irc.feedMsg(ircmsgs.join('#foo', prefix=self.prefix))
        getAfterJoinMessages()
        self.assertRegexp('channels', '#foo')
        self.irc.feedMsg(ircmsgs.join('#bar', prefix=self.prefix))
        getAfterJoinMessages()
        self.assertRegexp('channels', '#bar and #foo')
        self.irc.feedMsg(ircmsgs.join('#Baz', prefix=self.prefix))
        getAfterJoinMessages()
        self.assertRegexp('channels', '#bar, #Baz, and #foo')

    def testIgnoreAddRemove(self):
        self.assertNotError('admin ignore add foo!bar@baz')
        self.assertError('admin ignore add alsdkfjlasd')
        self.assertNotError('admin ignore remove foo!bar@baz')
        self.assertError('admin ignore remove foo!bar@baz')

    def testIgnoreList(self):
        self.assertNotError('admin ignore list')
        self.assertNotError('admin ignore add foo!bar@baz')
        self.assertNotError('admin ignore list')
        self.assertNotError('admin ignore add foo!bar@baz')
        self.assertRegexp('admin ignore list', 'foo')

    def testCapabilityAdd(self):
        self.assertError('capability add foo bar')
        u = ircdb.users.newUser()
        u.name = 'foo'
        ircdb.users.setUser(u)
        self.assertNotError('capability add foo bar')
        self.assertError('addcapability foo baz')
        self.assert_('bar' in u.capabilities)
        ircdb.users.delUser(u.id)

    def testCapabilityRemove(self):
        self.assertError('capability remove foo bar')
        u = ircdb.users.newUser()
        u.name = 'foo'
        ircdb.users.setUser(u)
        self.assertNotError('capability add foo bar')
        self.assert_('bar' in u.capabilities)
        self.assertError('removecapability foo bar')
        self.assertNotError('capability remove foo bar')
        self.assert_(not 'bar' in u.capabilities)
        ircdb.users.delUser(u.id)

    def testJoin(self):
        m = self.getMsg('join #foo')
        self.assertEqual(m.command, 'JOIN')
        self.assertEqual(m.args[0], '#foo')
        m = self.getMsg('join #foo key')
        self.assertEqual(m.command, 'JOIN')
        self.assertEqual(m.args[0], '#foo')
        self.assertEqual(m.args[1], 'key')

    def testPart(self):
        def getAfterJoinMessages():
            m = self.irc.takeMsg()
            self.assertEqual(m.command, 'MODE')
            m = self.irc.takeMsg()
            self.assertEqual(m.command, 'MODE')
            m = self.irc.takeMsg()
            self.assertEqual(m.command, 'WHO')
        self.assertError('part #foo')
        self.assertRegexp('part #foo', 'not in')
        self.irc.feedMsg(ircmsgs.join('#foo', prefix=self.prefix))
        getAfterJoinMessages()
        m = self.getMsg('part #foo')
        self.assertEqual(m.command, 'PART')
        self.irc.feedMsg(ircmsgs.join('#foo', prefix=self.prefix))
        getAfterJoinMessages()
        m = self.getMsg('part #foo reason')
        self.assertEqual(m.command, 'PART')
        self.assertEqual(m.args[0], '#foo')
        self.assertEqual(m.args[1], 'reason')

    def testNick(self):
        original = conf.supybot.nick()
        try:
            m = self.getMsg('nick foobar')
            self.assertEqual(m.command, 'NICK')
            self.assertEqual(m.args[0], 'foobar')
        finally:
            conf.supybot.networks.test.nick.setValue('')

    def testAddCapabilityOwner(self):
        self.assertError('admin capability add %s owner' % self.nick)

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:


########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2013, Valentin Lorentz
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

###

import supybot.conf as conf
import supybot.registry as registry
try:
    from supybot.i18n import PluginInternationalization
    _ = PluginInternationalization('Aka')
except:
    # Placeholder that allows to run the plugin on a bot
    # without the i18n module
    _ = lambda x:x

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Aka', True)


Aka = conf.registerPlugin('Aka')
# This is where your configuration variables (if any) should go.  For example:
# conf.registerGlobalValue(Aka, 'someConfigVariableName',
#     registry.Boolean(False, _("""Help for someConfigVariableName.""")))
conf.registerGlobalValue(Aka, 'maximumWordsInName',
    registry.Integer(5, _("""The maximum number of words allowed in a
    command name. Setting this to an high value may slow down your bot
    on long commands.""")))


# vim:set shiftwidth=4 tabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2013, Valentin Lorentz
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

###

import re
import os
import sys
import datetime
import operator

import supybot.conf as conf
import supybot.utils as utils
import supybot.ircdb as ircdb
from supybot.commands import *
import supybot.plugins as plugins
import supybot.ircutils as ircutils
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization
_ = PluginInternationalization('Aka')

try:
    import sqlite3
except ImportError:
    sqlite3 = None
try:
    import sqlalchemy
    import sqlalchemy.ext
    import sqlalchemy.ext.declarative
except ImportError:
    sqlalchemy = None

if not (sqlite3 or sqlalchemy):
    raise callbacks.Error('You have to install python-sqlite3 or '
            'python-sqlalchemy in order to load this plugin.')

available_db = {}

class Alias(object):
    __slots__ = ('name', 'alias', 'locked', 'locked_by', 'locked_at')
    def __init__(self, name, alias):
        self.name = name
        self.alias = alias
        self.locked = False
        self.locked_by = None
        self.locked_at = None
    def __repr__(self):
        return "<Alias('%r', '%r')>" % (self.name, self.alias)
if sqlite3:
    class SQLiteAkaDB(object):
        __slots__ = ('engines', 'filename', 'dbs',)
        def __init__(self, filename):
            self.engines = ircutils.IrcDict()
            self.filename = filename.replace('sqlite3', 'sqlalchemy')

        def close(self):
            self.dbs.clear()

        def get_db(self, channel):
            if channel in self.engines:
                engine = self.engines[channel]
            else:
                filename = plugins.makeChannelFilename(self.filename, channel)
                exists = os.path.exists(filename)
                engine = sqlite3.connect(filename, check_same_thread=False)
                if not exists:
                    cursor = engine.cursor()
                    cursor.execute("""CREATE TABLE aliases (
                            id INTEGER NOT NULL,
                            name VARCHAR NOT NULL,
                            alias VARCHAR NOT NULL,
                            locked BOOLEAN NOT NULL,
                            locked_by VARCHAR,
                            locked_at DATETIME,
                            PRIMARY KEY (id),
                            UNIQUE (name))""")
                    engine.commit()
                self.engines[channel] = engine
            assert engine.execute("select 1").fetchone() == (1,)
            return engine


        def has_aka(self, channel, name):
            name = callbacks.canonicalName(name, preserve_spaces=True)
            if sys.version_info[0] < 3 and isinstance(name, str):
                name = name.decode('utf8')
            db = self.get_db(channel)
            return self.get_db(channel).cursor() \
                    .execute("""SELECT COUNT() as count
                                FROM aliases WHERE name = ?;""", (name,)) \
                    .fetchone()[0]

        def get_aka_list(self, channel):
            cursor = self.get_db(channel).cursor()
            cursor.execute("""SELECT name FROM aliases;""")
            list_ = cursor.fetchall()
            return list_

        def get_alias(self, channel, name):
            name = callbacks.canonicalName(name, preserve_spaces=True)
            if sys.version_info[0] < 3 and isinstance(name, str):
                name = name.decode('utf8')
            cursor = self.get_db(channel).cursor()
            cursor.execute("""SELECT alias FROM aliases
                              WHERE name = ?;""", (name,))
            r = cursor.fetchone()
            if r:
                return r[0]
            else:
                return None

        def add_aka(self, channel, name, alias):
            name = callbacks.canonicalName(name, preserve_spaces=True)
            if self.has_aka(channel, name):
                raise AkaError(_('This Aka already exists.'))
            if sys.version_info[0] < 3:
                if isinstance(name, str):
                    name = name.decode('utf8')
                if isinstance(alias, str):
                    alias = alias.decode('utf8')
            db = self.get_db(channel)
            cursor = db.cursor()
            cursor.execute("""INSERT INTO aliases VALUES (
                NULL, ?, ?, 0, NULL, NULL);""", (name, alias))
            db.commit()

        def remove_aka(self, channel, name):
            name = callbacks.canonicalName(name, preserve_spaces=True)
            if sys.version_info[0] < 3 and isinstance(name, str):
                name = name.decode('utf8')
            db = self.get_db(channel)
            db.cursor().execute('DELETE FROM aliases WHERE name = ?', (name,))
            db.commit()

        def lock_aka(self, channel, name, by):
            name = callbacks.canonicalName(name, preserve_spaces=True)
            if sys.version_info[0] < 3 and isinstance(name, str):
                name = name.decode('utf8')
            db = self.get_db(channel)
            cursor = db.cursor().execute("""UPDATE aliases
                    SET locked=1, locked_at=?, locked_by=? WHERE name = ?""",
                    (datetime.datetime.now(), by, name))
            if cursor.rowcount == 0:
                raise AkaError(_('This Aka does not exist'))
            db.commit()

        def unlock_aka(self, channel, name, by):
            name = callbacks.canonicalName(name, preserve_spaces=True)
            if sys.version_info[0] < 3 and isinstance(name, str):
                name = name.decode('utf8')
            db = self.get_db(channel)
            cursor = db.cursor()
            cursor.execute("""UPDATE aliases SET locked=0, locked_at=?
                              WHERE name = ?""", (datetime.datetime.now(), name))
            if cursor.rowcount == 0:
                raise AkaError(_('This Aka does not exist'))
            db.commit()

        def get_aka_lock(self, channel, name):
            name = callbacks.canonicalName(name, preserve_spaces=True)
            if sys.version_info[0] < 3 and isinstance(name, str):
                name = name.decode('utf8')
            cursor = self.get_db(channel).cursor()
            cursor.execute("""SELECT locked, locked_by, locked_at
                              FROM aliases WHERE name = ?;""", (name,))
            r = cursor.fetchone()
            if r:
                return (bool(r[0]), r[1], r[2])
            else:
                raise AkaError(_('This Aka does not exist'))
    available_db.update({'sqlite3': SQLiteAkaDB})
elif sqlalchemy:
    Base = sqlalchemy.ext.declarative.declarative_base()
    class SQLAlchemyAlias(Alias, Base):
        __slots__ = ()
        __tablename__ = 'aliases'

        id = sqlalchemy.Column(sqlalchemy.Integer, primary_key=True)
        name = sqlalchemy.Column(sqlalchemy.String, unique=True, nullable=False)
        alias = sqlalchemy.Column(sqlalchemy.String, nullable=False)

        locked = sqlalchemy.Column(sqlalchemy.Boolean, nullable=False)
        locked_by = sqlalchemy.Column(sqlalchemy.String, nullable=True)
        locked_at = sqlalchemy.Column(sqlalchemy.DateTime, nullable=True)

    # TODO: Add table for usage statistics

    class SqlAlchemyAkaDB(object):
        __slots__ = ('engines', 'filename', 'sqlalchemy', 'dbs')
        def __init__(self, filename):
            self.engines = ircutils.IrcDict()
            self.filename = filename
            self.sqlalchemy = sqlalchemy

        def close(self):
            self.dbs.clear()

        def get_db(self, channel):
            if channel in self.engines:
                engine = self.engines[channel]
            else:
                filename = plugins.makeChannelFilename(self.filename, channel)
                exists = os.path.exists(filename)
                engine = sqlalchemy.create_engine('sqlite:///' + filename)
                if not exists:
                    Base.metadata.create_all(engine)
                self.engines[channel] = engine
            assert engine.execute("select 1").scalar() == 1
            Session = sqlalchemy.orm.sessionmaker()
            Session.configure(bind=engine)
            return Session()


        def has_aka(self, channel, name):
            name = callbacks.canonicalName(name, preserve_spaces=True)
            if sys.version_info[0] < 3 and isinstance(name, str):
                name = name.decode('utf8')
            count = self.get_db(channel).query(SQLAlchemyAlias) \
                    .filter(SQLAlchemyAlias.name == name) \
                    .count()
            return bool(count)
        def get_aka_list(self, channel):
            list_ = list(self.get_db(channel).query(SQLAlchemyAlias.name))
            return list_

        def get_alias(self, channel, name):
            name = callbacks.canonicalName(name, preserve_spaces=True)
            if sys.version_info[0] < 3 and isinstance(name, str):
                name = name.decode('utf8')
            try:
                return self.get_db(channel).query(SQLAlchemyAlias.alias) \
                        .filter(SQLAlchemyAlias.name == name).one()[0]
            except sqlalchemy.orm.exc.NoResultFound:
                return None

        def add_aka(self, channel, name, alias):
            name = callbacks.canonicalName(name, preserve_spaces=True)
            if self.has_aka(channel, name):
                raise AkaError(_('This Aka already exists.'))
            if sys.version_info[0] < 3:
                if isinstance(name, str):
                    name = name.decode('utf8')
                if isinstance(alias, str):
                    alias = alias.decode('utf8')
            db = self.get_db(channel)
            db.add(SQLAlchemyAlias(name, alias))
            db.commit()

        def remove_aka(self, channel, name):
            name = callbacks.canonicalName(name, preserve_spaces=True)
            if sys.version_info[0] < 3 and isinstance(name, str):
                name = name.decode('utf8')
            db = self.get_db(channel)
            db.query(SQLAlchemyAlias).filter(SQLAlchemyAlias.name == name).delete()
            db.commit()

        def lock_aka(self, channel, name, by):
            name = callbacks.canonicalName(name, preserve_spaces=True)
            if sys.version_info[0] < 3 and isinstance(name, str):
                name = name.decode('utf8')
            db = self.get_db(channel)
            try:
                aka = db.query(SQLAlchemyAlias) \
                        .filter(SQLAlchemyAlias.name == name).one()
            except sqlalchemy.orm.exc.NoResultFound:
                raise AkaError(_('This Aka does not exist'))
            if aka.locked:
                raise AkaError(_('This Aka is already locked.'))
            aka.locked = True
            aka.locked_by = by
            aka.locked_at = datetime.datetime.now()
            db.commit()

        def unlock_aka(self, channel, name, by):
            name = callbacks.canonicalName(name, preserve_spaces=True)
            if sys.version_info[0] < 3 and isinstance(name, str):
                name = name.decode('utf8')
            db = self.get_db(channel)
            try:
                aka = db.query(SQLAlchemyAlias) \
                        .filter(SQLAlchemyAlias.name == name).one()
            except sqlalchemy.orm.exc.NoResultFound:
                raise AkaError(_('This Aka does not exist'))
            if not aka.locked:
                raise AkaError(_('This Aka is already unlocked.'))
            aka.locked = False
            aka.locked_by = by
            aka.locked_at = datetime.datetime.now()
            db.commit()

        def get_aka_lock(self, channel, name):
            name = callbacks.canonicalName(name, preserve_spaces=True)
            if sys.version_info[0] < 3 and isinstance(name, str):
                name = name.decode('utf8')
            try:
                return self.get_db(channel) \
                        .query(SQLAlchemyAlias.locked, SQLAlchemyAlias.locked_by, SQLAlchemyAlias.locked_at)\
                        .filter(SQLAlchemyAlias.name == name).one()
            except sqlalchemy.orm.exc.NoResultFound:
                raise AkaError(_('This Aka does not exist'))

    available_db.update({'sqlalchemy': SqlAlchemyAkaDB})


def getArgs(args, required=1, optional=0, wildcard=0):
    if len(args) < required:
        raise callbacks.ArgumentError
    if len(args) < required + optional:
        ret = list(args) + ([''] * (required + optional - len(args)))
    elif len(args) >= required + optional:
        if not wildcard:
            ret = list(args[:required + optional - 1])
            ret.append(' '.join(args[required + optional - 1:]))
        else:
            ret = list(args)
    return ret

class AkaError(Exception):
    pass

class RecursiveAlias(AkaError):
    pass

dollarRe = re.compile(r'\$(\d+)')
def findBiggestDollar(alias):
    dollars = dollarRe.findall(alias)
    dollars = list(map(int, dollars))
    dollars.sort()
    if dollars:
        return dollars[-1]
    else:
        return 0

atRe = re.compile(r'@(\d+)')
def findBiggestAt(alias):
    ats = atRe.findall(alias)
    ats = list(map(int, ats))
    ats.sort()
    if ats:
        return ats[-1]
    else:
        return 0

AkaDB = plugins.DB('Aka', available_db)

class Aka(callbacks.Plugin):
    """Add the help for "@plugin help Aka" here
    This should describe *how* to use this plugin."""

    def __init__(self, irc):
        self.__parent = super(Aka, self)
        self.__parent.__init__(irc)
        self._db = AkaDB()

    def isCommandMethod(self, name):
        args = name.split(' ')
        if '|' in args:
            return False
        if len(args) > 1 and \
                callbacks.canonicalName(args[0]) != self.canonicalName():
            for cb in dynamic.irc.callbacks: # including this plugin
                if cb.isCommandMethod(' '.join(args[0:-1])):
                    return False
        if sys.version_info[0] < 3 and isinstance(name, str):
            name = name.decode('utf8')
        channel = dynamic.channel or 'global'
        return self._db.has_aka(channel, name) or \
                self._db.has_aka('global', name) or \
                self.__parent.isCommandMethod(name)
    isCommand = isCommandMethod

    def listCommands(self):
        channel = dynamic.channel or 'global'
        return list(set(list(map(callbacks.formatCommand,
                            self._db.get_aka_list(channel) +
                            self._db.get_aka_list('global'))) +
                ['add', 'remove', 'lock', 'unlock', 'importaliasdatabase']))

    def getCommand(self, args, check_other_plugins=True):
        canonicalName = callbacks.canonicalName
        # All the code from here to the 'for' loop is copied from callbacks.py
        assert args == list(map(canonicalName, args))
        first = args[0]
        for cb in self.cbs:
            if first == cb.canonicalName():
                return cb.getCommand(args[1:])
        if first == self.canonicalName() and len(args) > 1:
            ret = self.getCommand(args[1:], False)
            if ret:
                return [first] + ret
        max_length = self.registryValue('maximumWordsInName')
        for i in xrange(1, min(len(args)+1, max_length)):
            if self.isCommandMethod(callbacks.formatCommand(args[0:i])):
                return args[0:i]
        return []

    def getCommandMethod(self, command):
        if len(command) == 1 or command[0] == self.canonicalName():
            try:
                return self.__parent.getCommandMethod(command)
            except AttributeError:
                pass
        name = callbacks.formatCommand(command)
        channel = dynamic.channel or 'global'
        original = self._db.get_alias(channel, name)
        if not original:
            original = self._db.get_alias('global', name)
        biggestDollar = findBiggestDollar(original)
        biggestAt = findBiggestAt(original)
        wildcard = '$*' in original
        def f(irc, msg, args):
            tokens = callbacks.tokenize(original)
            if biggestDollar or biggestAt:
                args = getArgs(args, required=biggestDollar, optional=biggestAt,
                                wildcard=wildcard)
            max_len = conf.supybot.reply.maximumLength()
            args = list([x[:max_len] for x in args])
            def regexpReplace(m):
                idx = int(m.group(1))
                return args[idx-1]
            def replace(tokens, replacer):
                for (i, token) in enumerate(tokens):
                    if isinstance(token, list):
                        replace(token, replacer)
                    else:
                        tokens[i] = replacer(token)
            replace(tokens, lambda s: dollarRe.sub(regexpReplace, s))
            if biggestAt:
                assert not wildcard
                args = args[biggestDollar:]
                replace(tokens, lambda s: atRe.sub(regexpReplace, s))
            if wildcard:
                assert not biggestAt
                # Gotta remove the things that have already been subbed in.
                i = biggestDollar
                while i:
                    args.pop(0)
                    i -= 1
                def everythingReplace(tokens):
                    for (i, token) in enumerate(tokens):
                        if isinstance(token, list):
                            if everythingReplace(token):
                                return
                        if token == '$*':
                            tokens[i:i+1] = args
                            return True
                        elif '$*' in token:
                            tokens[i] = token.replace('$*', ' '.join(args))
                            return True
                    return False
                everythingReplace(tokens)
            maxNesting = conf.supybot.commands.nested.maximum()
            if maxNesting and irc.nested+1 > maxNesting:
                irc.error(_('You\'ve attempted more nesting than is '
                      'currently allowed on this bot.'), Raise=True)
            self.Proxy(irc, msg, tokens)
        if biggestDollar and (wildcard or biggestAt):
            flexargs = _(' at least')
        else:
            flexargs = ''
        try:
            lock = self._db.get_aka_lock(channel, name)
        except AkaError:
            lock = self._db.get_aka_lock('global', name)
        (locked, locked_by, locked_at) = lock
        if locked:
            lock = ' ' + _('Locked by %s at %s') % (locked_by, locked_at)
        else:
            lock = ''
        doc = format(_('<an alias,%s %n>\n\nAlias for %q.%s'),
                    flexargs, (biggestDollar, _('argument')), original, lock)
        f = utils.python.changeFunctionName(f, name, doc)
        return f

    def _add_aka(self, channel, name, alias):
        if self.__parent.isCommandMethod(name):
            raise AkaError(_('You can\'t overwrite commands in '
                    'this plugin.'))
        if self._db.has_aka(channel, name):
            raise AkaError(_('This Aka already exists.'))
        if len(name.split(' ')) > self.registryValue('maximumWordsInName'):
            raise AkaError(_('This Aka has too many spaces in its name.'))
        biggestDollar = findBiggestDollar(alias)
        biggestAt = findBiggestAt(alias)
        wildcard = '$*' in alias
        if biggestAt and wildcard:
            raise AkaError(_('Can\'t mix $* and optional args (@1, etc.)'))
        if alias.count('$*') > 1:
            raise AkaError(_('There can be only one $* in an alias.'))
        self._db.add_aka(channel, name, alias)

    def _remove_aka(self, channel, name, evenIfLocked=False):
        if not evenIfLocked:
            (locked, by, at) = self._db.get_aka_lock(channel, name)
            if locked:
                raise AkaError(_('This Aka is locked.'))
        self._db.remove_aka(channel, name)

    def add(self, irc, msg, args, optlist, name, alias):
        """[--channel <#channel>] <name> <command>

        Defines an alias <name> that executes <command>.  The <command>
        should be in the standard "command argument [nestedcommand argument]"
        arguments to the alias; they'll be filled with the first, second, etc.
        arguments.  $1, $2, etc. can be used for required arguments.  @1, @2,
        etc. can be used for optional arguments.  $* simply means "all
        arguments that have not replaced $1, $2, etc.", ie. it will also
        include optional arguments.
        """
        channel = 'global'
        for (option, arg) in optlist:
            if option == 'channel':
                if not ircutils.isChannel(arg):
                    irc.error(_('%r is not a valid channel.') % arg,
                            Raise=True)
                channel = arg
        if ' ' not in alias:
            # If it's a single word, they probably want $*.
            alias += ' $*'
        try:
            self._add_aka(channel, name, alias)
            self.log.info('Adding Aka %r for %r (from %s)',
                          name, alias, msg.prefix)
            irc.replySuccess()
        except AkaError as e:
            irc.error(str(e))
    add = wrap(add, [getopts({
                                'channel': 'somethingWithoutSpaces',
                            }), 'something', 'text'])

    def remove(self, irc, msg, args, optlist, name):
        """[--channel <#channel>] <name>

        Removes the given alias, if unlocked.
        """
        channel = 'global'
        for (option, arg) in optlist:
            if option == 'channel':
                if not ircutils.isChannel(arg):
                    irc.error(_('%r is not a valid channel.') % arg,
                            Raise=True)
                channel = arg
        try:
            self._remove_aka(channel, name)
            self.log.info('Removing Aka %r (from %s)', name, msg.prefix)
            irc.replySuccess()
        except AkaError as e:
            irc.error(str(e))
    remove = wrap(remove, [getopts({
                                'channel': 'somethingWithoutSpaces',
                            }), 'something'])

    def _checkManageCapabilities(self, irc, msg, channel):
        """Check if the user has any of the required capabilities to manage
        the regexp database."""
        if channel != 'global':
            capability = ircdb.makeChannelCapability(channel, 'op')
        else:
            capability = 'admin'
        if not ircdb.checkCapability(msg.prefix, capability):
            irc.errorNoCapability(capability, Raise=True)

    def lock(self, irc, msg, args, optlist, user, name):
        """[--channel <#channel>] <alias>

        Locks an alias so that no one else can change it.
        """
        channel = 'global'
        for (option, arg) in optlist:
            if option == 'channel':
                if not ircutils.isChannel(arg):
                    irc.error(_('%r is not a valid channel.') % arg,
                            Raise=True)
                channel = arg
        self._checkManageCapabilities(irc, msg, channel)
        try:
            self._db.lock_aka(channel, name, user.name)
        except AkaError as e:
            irc.error(str(e))
        else:
            irc.replySuccess()
    lock = wrap(lock, [getopts({
                                'channel': 'somethingWithoutSpaces',
                            }), 'user', 'something'])

    def unlock(self, irc, msg, args, optlist, user, name):
        """[--channel <#channel>] <alias>

        Unlocks an alias so that people can define new aliases over it.
        """
        channel = 'global'
        for (option, arg) in optlist:
            if option == 'channel':
                if not ircutils.isChannel(arg):
                    irc.error(_('%r is not a valid channel.') % arg,
                            Raise=True)
                channel = arg
        self._checkManageCapabilities(irc, msg, channel)
        try:
            self._db.unlock_aka(channel, name, user.name)
        except AkaError as e:
            irc.error(str(e))
        else:
            irc.replySuccess()
    unlock = wrap(unlock, [getopts({
                                'channel': 'somethingWithoutSpaces',
                            }), 'user', 'something'])

    def importaliasdatabase(self, irc, msg, args):
        """takes no arguments

        Imports the Alias database into Aka's, and clean the former."""
        alias_plugin = irc.getCallback('Alias')
        if alias_plugin is None:
            irc.error(_('Alias plugin is not loaded.'), Raise=True)
        errors = {}
        for (name, (command, locked, func)) in alias_plugin.aliases.items():
            try:
                self._add_aka('global', name, command)
            except AkaError as e:
                errors[name] = e.args[0]
            else:
                alias_plugin.removeAlias(name, evenIfLocked=True)
        if errors:
            irc.error(format(_('Error occured when importing the %n: %L'),
                (len(errors), 'following', 'command'),
                ['%s (%s)' % x for x in errors.items()]))
        else:
            irc.replySuccess()
    importaliasdatabase = wrap(importaliasdatabase, ['owner'])


Class = Aka


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
# -*- coding: utf8 -*-
###
# Copyright (c) 2002-2004, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

import supybot.conf as conf
import supybot.plugin as plugin
import supybot.registry as registry

import plugin as Aka

class FunctionsTest(SupyTestCase):
    def testFindBiggestDollar(self):
        self.assertEqual(Aka.findBiggestDollar(''), 0)
        self.assertEqual(Aka.findBiggestDollar('foo'), 0)
        self.assertEqual(Aka.findBiggestDollar('$0'), 0)
        self.assertEqual(Aka.findBiggestDollar('$1'), 1)
        self.assertEqual(Aka.findBiggestDollar('$2'), 2)
        self.assertEqual(Aka.findBiggestDollar('$2 $10'), 10)
        self.assertEqual(Aka.findBiggestDollar('$3'), 3)
        self.assertEqual(Aka.findBiggestDollar('$3 $2 $1'), 3)
        self.assertEqual(Aka.findBiggestDollar('foo bar $1'), 1)
        self.assertEqual(Aka.findBiggestDollar('foo $2 $1'), 2)
        self.assertEqual(Aka.findBiggestDollar('foo $0 $1'), 1)
        self.assertEqual(Aka.findBiggestDollar('foo $1 $3'), 3)
        self.assertEqual(Aka.findBiggestDollar('$10 bar $1'), 10)

class AkaChannelTestCase(ChannelPluginTestCase):
    plugins = ('Aka', 'Conditional', 'Filter', 'Math', 'Utilities',
            'Format', 'Reply')

    def testDoesNotOverwriteCommands(self):
        # We don't have dispatcher commands anymore
        #self.assertError('aka add aka "echo foo bar baz"')
        self.assertError('aka add add "echo foo bar baz"')
        self.assertError('aka add remove "echo foo bar baz"')
        self.assertError('aka add lock "echo foo bar baz"')
        self.assertError('aka add unlock "echo foo bar baz"')

    def testAkaHelp(self):
        self.assertNotError('aka add slashdot foo')
        self.assertRegexp('help slashdot', "Alias for .*foo")
        self.assertNotError('aka add nonascii echo éé')
        self.assertRegexp('help nonascii', "Alias for .*echo éé")

    def testRemove(self):
        self.assertNotError('aka add foo echo bar')
        self.assertResponse('foo', 'bar')
        self.assertNotError('aka remove foo')
        self.assertError('foo')

    def testDollars(self):
        self.assertNotError('aka add rot26 "rot13 [rot13 $1]"')
        self.assertResponse('rot26 foobar', 'foobar')

    def testMoreDollars(self):
        self.assertNotError('aka add rev "echo $3 $2 $1"')
        self.assertResponse('rev foo bar baz', 'baz bar foo')

    def testAllArgs(self):
        self.assertNotError('aka add swap "echo $2 $1 $*"')
        self.assertResponse('swap 1 2 3 4 5', '2 1 3 4 5')
        self.assertError('aka add foo "echo $1 @1 $*"')
        self.assertNotError('aka add moo echo $1 $*')
        self.assertError('moo')
        self.assertResponse('moo foo', 'foo')
        self.assertResponse('moo foo bar', 'foo bar')

        self.assertNotError('aka add spam "echo [echo $*]"')
        self.assertResponse('spam egg', 'egg')
        self.assertResponse('spam egg bacon', 'egg bacon')
    
    def testChannel(self):
        self.assertNotError('aka add channel echo $channel')
        self.assertResponse('aka channel', self.channel)

    def testAddRemoveAka(self):
        cb = self.irc.getCallback('Aka')
        cb._add_aka('global', 'foobar', 'echo sbbone')
        cb._db.lock_aka('global', 'foobar', 'evil_admin')
        self.assertResponse('foobar', 'sbbone')
        self.assertRegexp('list Aka', 'foobar')
        self.assertRaises(Aka.AkaError, cb._remove_aka, 'global', 'foobar')
        cb._remove_aka('global', 'foobar', evenIfLocked=True)
        self.assertNotRegexp('list Aka', 'foobar')
        self.assertError('foobar')

    def testOptionalArgs(self):
        self.assertNotError('aka add myrepr "repr @1"')
        self.assertResponse('myrepr foo', '"foo"')
        self.assertResponse('myrepr ""', '""')

    def testNoExtraSpaces(self):
        self.assertNotError('aka add foo "action takes $1\'s money"')
        self.assertResponse('foo bar', '\x01ACTION takes bar\'s money\x01')

    def testNoExtraQuotes(self):
        self.assertNotError('aka add myre "echo s/$1/$2/g"')
        self.assertResponse('myre foo bar', 's/foo/bar/g')

    def testSimpleAkaWithoutArgsImpliesDollarStar(self):
        self.assertNotError('aka add exo echo')
        self.assertResponse('exo foo bar baz', 'foo bar baz')

    def testChannelPriority(self):
        self.assertNotError('aka add spam "echo foo"')
        self.assertNotError('aka add --channel %s spam "echo bar"' %
                self.channel)
        self.assertResponse('spam', 'bar')

        self.assertNotError('aka add --channel %s egg "echo baz"' %
                self.channel)
        self.assertNotError('aka add egg "echo qux"')
        self.assertResponse('egg', 'baz')

    def testComplicatedNames(self):
        self.assertNotError(u'aka add café "echo coffee"')
        self.assertResponse(u'café', 'coffee')

        self.assertNotError('aka add "foo bar" "echo spam"')
        self.assertResponse('foo bar', 'spam')
        self.assertNotError('aka add "foo" "echo egg"')
        self.assertResponse('foo', 'egg')
        # You could expect 'spam' here, but in fact, this is dangerous.
        # Just imagine this session:
        # <evil_user> aka add "echo foo" quit
        # <bot> The operation succeeded.
        # ...
        # <owner> echo foo
        # * bot has quit
        self.assertResponse('foo bar', 'egg')

    def testNoOverride(self):
        self.assertNotError('aka add "echo foo" "echo bar"')
        self.assertResponse('echo foo', 'foo')
        self.assertNotError('aka add foo "echo baz"')
        self.assertNotError('aka add "foo bar" "echo qux"')
        self.assertResponse('foo bar', 'baz')

    def testRecursivity(self):
        self.assertNotError('aka add fact '
                r'"cif [nceq $1 0] \"echo 1\" '
                r'\"calc $1 * [fact [calc $1 - 1]]\""')
        self.assertResponse('fact 4', '24')
        self.assertRegexp('fact 50', 'more nesting')

    def testDollarStarNesting(self):
        self.assertNotError('aka add alias aka $*')
        self.assertNotError('alias add a+ aka add $*')

class AkaTestCase(PluginTestCase):
    plugins = ('Aka', 'Alias', 'User', 'Utilities')

    def testMaximumLength(self):
        self.assertNotError('aka add "foo bar baz qux quux" "echo test"')
        self.assertError('aka add "foo bar baz qux quux corge" "echo test"')

    def testAkaLockedHelp(self):
        self.assertNotError('register evil_admin foo')

        self.assertNotError('aka add slashdot foo')
        self.assertRegexp('help aka slashdot', "Alias for .*foo")
        self.assertNotRegexp('help aka slashdot', 'Locked by')
        self.assertNotError('aka lock slashdot')
        self.assertRegexp('help aka slashdot', 'Locked by evil_admin')
        self.assertNotError('aka unlock slashdot')
        self.assertNotRegexp('help aka slashdot', 'Locked by')

    def testAliasImport(self):
        self.assertNotError('alias add foo "echo bar"')
        self.assertNotError(u'alias add baz "echo café"')
        self.assertNotError('aka add qux "echo quux"')
        self.assertResponse('alias foo', 'bar')
        self.assertResponse('alias baz', 'café')
        self.assertRegexp('aka foo', 'there is no command named')
        self.assertResponse('aka qux', 'quux')

        self.assertNotError('aka importaliasdatabase')

        self.assertRegexp('alias foo', 'there is no command named')
        self.assertResponse('aka foo', 'bar')
        self.assertResponse('aka baz', 'café')
        self.assertResponse('aka qux', 'quux')

        self.assertNotError('alias add foo "echo test"')
        self.assertNotError('alias add spam "echo egg"')
        self.assertNotError('alias lock spam')

        self.assertRegexp('aka importaliasdatabase',
            r'the 1 following command: foo \(This Aka already exists.\)$')
        self.assertResponse('aka foo', 'bar')
        self.assertResponse('alias foo', 'test')
        self.assertRegexp('alias spam', 'there is no command named')
        self.assertResponse('aka spam', 'egg')


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Alias')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Alias', True)

Alias = conf.registerPlugin('Alias')
conf.registerGroup(Alias, 'aliases')
conf.registerGroup(Alias, 'escapedaliases')

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2002-2004, Jeremiah Fincher
# Copyright (c) 2009-2010, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import re
import sys
import types

import supybot.conf as conf
import supybot.utils as utils
from supybot.commands import *
import supybot.ircutils as ircutils
import supybot.registry as registry
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Alias')

# Copied from the old privmsgs.py.
def getChannel(msg, args=()):
    """Returns the channel the msg came over or the channel given in args.

    If the channel was given in args, args is modified (the channel is
    removed).
    """
    if args and ircutils.isChannel(args[0]):
        if conf.supybot.reply.requireChannelCommandsToBeSentInChannel():
            if args[0] != msg.args[0]:
                s = 'Channel commands must be sent in the channel to which ' \
                    'they apply; if this is not the behavior you desire, ' \
                    'ask the bot\'s administrator to change the registry ' \
                    'variable ' \
                    'supybot.reply.requireChannelCommandsToBeSentInChannel ' \
                    'to False.'
                raise callbacks.Error(s)
        return args.pop(0)
    elif ircutils.isChannel(msg.args[0]):
        return msg.args[0]
    else:
        raise callbacks.Error('Command must be sent in a channel or ' \
                               'include a channel in its arguments.')

def getArgs(args, required=1, optional=0, wildcard=0):
    if len(args) < required:
        raise callbacks.ArgumentError
    if len(args) < required + optional:
        ret = list(args) + ([''] * (required + optional - len(args)))
    elif len(args) >= required + optional:
        if not wildcard:
            ret = list(args[:required + optional - 1])
            ret.append(' '.join(args[required + optional - 1:]))
        else:
            ret = list(args)
    return ret

class AliasError(Exception):
    pass

class RecursiveAlias(AliasError):
    pass

dollarRe = re.compile(r'\$(\d+)')
def findBiggestDollar(alias):
    dollars = dollarRe.findall(alias)
    dollars = list(map(int, dollars))
    dollars.sort()
    if dollars:
        return dollars[-1]
    else:
        return 0

atRe = re.compile(r'@(\d+)')
def findBiggestAt(alias):
    ats = atRe.findall(alias)
    ats = list(map(int, ats))
    ats.sort()
    if ats:
        return ats[-1]
    else:
        return 0

def escapeAlias(alias):
    """Encodes [a-z0-9.]+ into [a-z][a-z0-9].
    Format: a<number of escaped chars>a(<index>d)+<word without dots>."""
    prefix = ''
    new_alias = ''
    prefixes = 0
    for index, char in enumerate(alias):
        if char == '.':
            prefix += '%sd' % index
            prefixes += 1
        elif char == '|':
            prefix += '%sp' % index
            prefixes += 1
        else:
            new_alias += char
    pre_prefix = 'a%ia' % prefixes
    return pre_prefix + prefix + new_alias

def unescapeAlias(alias):
    alias = alias[1:] # Strip the leading 'a'
    escaped_nb = ''
    while alias[0] in '0123456789':
        escaped_nb += alias[0]
        alias = alias[1:]
    alias = alias[1:]
    escaped_nb = int(escaped_nb)
    escaped_chars = []
    while alias[0] in '0123456789':
        current_group = ''
        while alias[0] in '0123456789':
            current_group += alias[0]
            alias = alias[1:]
        if alias[0] == 'd':
            char = '.'
        elif alias[0] == 'p':
            char = '|'
        else:
            char = alias[0]
        alias = alias[1:]
        escaped_chars.append((int(current_group), char))
        if len(escaped_chars) == escaped_nb:
            break
    new_alias = ''
    index = 0
    for char in alias:
        if escaped_chars and index == escaped_chars[0][0]:
            new_alias += escaped_chars[0][1]
            escaped_chars.pop(0)
            index += 1
        new_alias += char
        index += 1
    return new_alias

def makeNewAlias(name, alias):
    original = alias
    biggestDollar = findBiggestDollar(original)
    biggestAt = findBiggestAt(original)
    wildcard = '$*' in original
    if biggestAt and wildcard:
        raise AliasError('Can\'t mix $* and optional args (@1, etc.)')
    if original.count('$*') > 1:
        raise AliasError('There can be only one $* in an alias.')
    testTokens = callbacks.tokenize(original)
    if testTokens and isinstance(testTokens[0], list):
        raise AliasError('Commands may not be the result of nesting.')
    def f(self, irc, msg, args):
        alias = original.replace('$nick', msg.nick)
        if '$channel' in original:
            channel = getChannel(msg, args)
            alias = alias.replace('$channel', channel)
        tokens = callbacks.tokenize(alias)
        if biggestDollar or biggestAt:
            args = getArgs(args, required=biggestDollar, optional=biggestAt,
                            wildcard=wildcard)
        max_len = conf.supybot.reply.maximumLength()
        args = list([x[:max_len] for x in args])
        def regexpReplace(m):
            idx = int(m.group(1))
            return args[idx-1]
        def replace(tokens, replacer):
            for (i, token) in enumerate(tokens):
                if isinstance(token, list):
                    replace(token, replacer)
                else:
                    tokens[i] = replacer(token)
        replace(tokens, lambda s: dollarRe.sub(regexpReplace, s))
        if biggestAt:
            assert not wildcard
            args = args[biggestDollar:]
            replace(tokens, lambda s: atRe.sub(regexpReplace, s))
        if wildcard:
            assert not biggestAt
            # Gotta remove the things that have already been subbed in.
            i = biggestDollar
            while i:
                args.pop(0)
                i -= 1
            def everythingReplace(tokens):
                for (i, token) in enumerate(tokens):
                    if isinstance(token, list):
                        if everythingReplace(token):
                            return
                    if token == '$*':
                        tokens[i:i+1] = args
                        return True
                    elif '$*' in token:
                        tokens[i] = token.replace('$*', ' '.join(args))
                        return True
                return False
            everythingReplace(tokens)
        maxNesting = conf.supybot.commands.nested.maximum()
        if maxNesting and irc.nested+1 > maxNesting:
            irc.error(_('You\'ve attempted more nesting than is '
                  'currently allowed on this bot.'), Raise=True)
        self.Proxy(irc, msg, tokens, nested=irc.nested+1)
    flexargs = ''
    if biggestDollar and (wildcard or biggestAt):
        flexargs = _(' at least')
    try:
        doc = format(_('<an alias,%s %n>\n\nAlias for %q.'),
                    flexargs, (biggestDollar, _('argument')), alias)
    except UnicodeDecodeError:
        if sys.version_info[0] == 2:
            alias = alias.decode('utf8')
        doc = format(_('<an alias,%s %n>\n\nAlias for %q.'),
                    flexargs, (biggestDollar, _('argument')), alias)
    f = utils.python.changeFunctionName(f, name, doc)
    return f

class Alias(callbacks.Plugin):
    def __init__(self, irc):
        self.__parent = super(Alias, self)
        self.__parent.__init__(irc)
        # Schema: {alias: [command, locked, commandMethod]}
        self.aliases = {}
        # XXX This should go.  aliases should be a space separate list, etc.
        group = conf.supybot.plugins.Alias.aliases
        group2 = conf.supybot.plugins.Alias.escapedaliases
        for (name, alias) in registry._cache.iteritems():
            name = name.lower()
            if name.startswith('supybot.plugins.alias.aliases.'):
                name = name[len('supybot.plugins.alias.aliases.'):]
                if '.' in name:
                    continue
                conf.registerGlobalValue(group, name, registry.String('', ''))
                conf.registerGlobalValue(group.get(name), 'locked',
                                         registry.Boolean(False, ''))
            elif name.startswith('supybot.plugins.alias.escapedaliases.'):
                name = name[len('supybot.plugins.alias.escapedaliases.'):]
                if '.' in name:
                    continue
                conf.registerGlobalValue(group2, name,
                        registry.String('', ''))
                conf.registerGlobalValue(group2.get(name),
                    'locked', registry.Boolean(False, ''))
        for (name, value) in group.getValues(fullNames=False):
            name = name.lower() # Just in case.
            command = value()
            locked = value.locked()
            self.aliases[name] = [command, locked, None]
        for (name, value) in group2.getValues(fullNames=False):
            name = name.lower() # Just in case.
            command = value()
            locked = value.locked()
            self.aliases[unescapeAlias(name)] = [command, locked, None]
        for (alias, (command, locked, _)) in self.aliases.items():
            try:
                self.addAlias(irc, alias, command, locked)
            except Exception as e:
                self.log.exception('Exception when trying to add alias %s.  '
                                   'Removing from the Alias database.', alias)
                del self.aliases[alias]

    def isCommandMethod(self, name):
        if not self.__parent.isCommandMethod(name):
            if name in self.aliases:
                return True
            else:
                return False
        else:
            return True

    def listCommands(self):
        return self.__parent.listCommands(self.aliases.keys())

    def getCommandMethod(self, command):
        try:
            return self.__parent.getCommandMethod(command)
        except AttributeError:
            return self.aliases[command[0]][2]

    @internationalizeDocstring
    def lock(self, irc, msg, args, name):
        """<alias>

        Locks an alias so that no one else can change it.
        """
        if name in self.aliases and self.isCommandMethod(name):
            self.aliases[name][1] = True
            conf.supybot.plugins.Alias.aliases.get(name).locked.setValue(True)
            irc.replySuccess()
        else:
            irc.error(_('There is no such alias.'))
    lock = wrap(lock, [('checkCapability', 'admin'), 'commandName'])

    @internationalizeDocstring
    def unlock(self, irc, msg, args, name):
        """<alias>

        Unlocks an alias so that people can define new aliases over it.
        """
        if name in self.aliases and self.isCommandMethod(name):
            self.aliases[name][1] = False
            conf.supybot.plugins.Alias.aliases.get(name).locked.setValue(False)
            irc.replySuccess()
        else:
            irc.error(_('There is no such alias.'))
    unlock = wrap(unlock, [('checkCapability', 'admin'), 'commandName'])

    _validNameRe = re.compile(r'^[a-z.|!?][a-z0-9.|!]*$')
    def addAlias(self, irc, name, alias, lock=False):
        if not self._validNameRe.search(name):
            raise AliasError('Names can only contain alphanumerical '
                    'characters, dots, pipes, and '
                    'exclamation/interrogatin marks '
                    '(and the first character cannot be a number).')
        realName = callbacks.canonicalName(name)
        if name != realName:
            s = format(_('That name isn\'t valid.  Try %q instead.'), realName)
            raise AliasError(s)
        name = realName
        if self.isCommandMethod(name):
            if realName not in self.aliases:
                s = 'You can\'t overwrite commands in this plugin.'
                raise AliasError(s)
        if name in self.aliases:
            (currentAlias, locked, _) = self.aliases[name]
            if locked and currentAlias != alias:
                raise AliasError(format('Alias %q is locked.', name))
        try:
            f = makeNewAlias(name, alias)
            f = types.MethodType(f, self)
        except RecursiveAlias:
            raise AliasError('You can\'t define a recursive alias.')
        if '.' in name or '|' in name:
            aliasGroup = self.registryValue('escapedaliases', value=False)
            confname = escapeAlias(name)
        else:
            aliasGroup = self.registryValue('aliases', value=False)
            confname = name
        if name in self.aliases:
            # We gotta remove it so its value gets updated.
            aliasGroup.unregister(confname)
        conf.registerGlobalValue(aliasGroup, confname,
                                 registry.String(alias, ''))
        conf.registerGlobalValue(aliasGroup.get(confname), 'locked',
                                 registry.Boolean(lock, ''))
        self.aliases[name] = [alias, lock, f]

    def removeAlias(self, name, evenIfLocked=False):
        name = callbacks.canonicalName(name)
        if name in self.aliases and self.isCommandMethod(name):
            if evenIfLocked or not self.aliases[name][1]:
                del self.aliases[name]
                if '.' in name or '|' in name:
                    conf.supybot.plugins.Alias.escapedaliases.unregister(
                            escapeAlias(name))
                else:
                    conf.supybot.plugins.Alias.aliases.unregister(name)
            else:
                raise AliasError('That alias is locked.')
        else:
            raise AliasError('There is no such alias.')

    @internationalizeDocstring
    def add(self, irc, msg, args, name, alias):
        """<name> <command>

        Defines an alias <name> that executes <command>.  The <command>
        should be in the standard "command argument [nestedcommand argument]"
        arguments to the alias; they'll be filled with the first, second, etc.
        arguments.  $1, $2, etc. can be used for required arguments.  @1, @2,
        etc. can be used for optional arguments.  $* simply means "all
        remaining arguments," and cannot be combined with optional arguments.
        """
        if ' ' not in alias:
            # If it's a single word, they probably want $*.
            alias += ' $*'
        try:
            self.addAlias(irc, name, alias)
            self.log.info('Adding alias %q for %q (from %s)',
                          name, alias, msg.prefix)
            irc.replySuccess()
        except AliasError as e:
            irc.error(str(e))
    add = wrap(add, ['commandName', 'text'])

    @internationalizeDocstring
    def remove(self, irc, msg, args, name):
        """<name>

        Removes the given alias, if unlocked.
        """
        try:
            self.removeAlias(name)
            self.log.info('Removing alias %q (from %s)', name, msg.prefix)
            irc.replySuccess()
        except AliasError as e:
            irc.error(str(e))
    remove = wrap(remove, ['commandName'])


Class = Alias

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
# -*- coding: utf8 -*-
###
# Copyright (c) 2002-2004, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

import supybot.conf as conf
import supybot.plugin as plugin
import supybot.registry as registry

import plugin as Alias

class FunctionsTest(SupyTestCase):
    def testFindBiggestDollar(self):
        self.assertEqual(Alias.findBiggestDollar(''), 0)
        self.assertEqual(Alias.findBiggestDollar('foo'), 0)
        self.assertEqual(Alias.findBiggestDollar('$0'), 0)
        self.assertEqual(Alias.findBiggestDollar('$1'), 1)
        self.assertEqual(Alias.findBiggestDollar('$2'), 2)
        self.assertEqual(Alias.findBiggestDollar('$2 $10'), 10)
        self.assertEqual(Alias.findBiggestDollar('$3'), 3)
        self.assertEqual(Alias.findBiggestDollar('$3 $2 $1'), 3)
        self.assertEqual(Alias.findBiggestDollar('foo bar $1'), 1)
        self.assertEqual(Alias.findBiggestDollar('foo $2 $1'), 2)
        self.assertEqual(Alias.findBiggestDollar('foo $0 $1'), 1)
        self.assertEqual(Alias.findBiggestDollar('foo $1 $3'), 3)
        self.assertEqual(Alias.findBiggestDollar('$10 bar $1'), 10)


class AliasTestCase(ChannelPluginTestCase):
    plugins = ('Alias', 'Filter', 'Utilities', 'Format', 'Reply')
    def testNoAliasWithNestedCommandName(self):
        self.assertError('alias add foo "[bar] baz"')

    def testDoesNotOverwriteCommands(self):
        # We don't have dispatcher commands anymore
        #self.assertError('alias add alias "echo foo bar baz"')
        self.assertError('alias add add "echo foo bar baz"')
        self.assertError('alias add remove "echo foo bar baz"')
        self.assertError('alias add lock "echo foo bar baz"')
        self.assertError('alias add unlock "echo foo bar baz"')

    def testAliasHelp(self):
        self.assertNotError('alias add slashdot foo')
        self.assertRegexp('help slashdot', "Alias for .*foo")
        self.assertNotError('alias add nonascii echo éé')
        self.assertRegexp('help nonascii', "Alias for .*echo éé")

    def testRemove(self):
        self.assertNotError('alias add foo echo bar')
        self.assertResponse('foo', 'bar')
        self.assertNotError('alias remove foo')
        self.assertError('foo')

    def testDollars(self):
        self.assertNotError('alias add rot26 "rot13 [rot13 $1]"')
        self.assertResponse('rot26 foobar', 'foobar')

    def testMoreDollars(self):
        self.assertNotError('alias add rev "echo $3 $2 $1"')
        self.assertResponse('rev foo bar baz', 'baz bar foo')

    def testAllArgs(self):
        self.assertNotError('alias add swap "echo $2 $1 $*"')
        self.assertResponse('swap 1 2 3 4 5', '2 1 3 4 5')
        self.assertError('alias add foo "echo $1 @1 $*"')
        self.assertNotError('alias add moo echo $1 $*')
        self.assertError('moo')
        self.assertResponse('moo foo', 'foo')
        self.assertResponse('moo foo bar', 'foo bar')
    
    def testChannel(self):
        self.assertNotError('alias add channel echo $channel')
        self.assertResponse('alias channel', self.channel)

    def testNick(self):
        self.assertNotError('alias add sendingnick "rot13 [rot13 $nick]"')
        self.assertResponse('sendingnick', self.nick)

    def testAddRemoveAlias(self):
        cb = self.irc.getCallback('Alias')
        cb.addAlias(self.irc, 'foobar', 'echo sbbone', lock=True)
        self.assertResponse('foobar', 'sbbone')
        self.assertRaises(Alias.AliasError, cb.removeAlias, 'foobar')
        cb.removeAlias('foobar', evenIfLocked=True)
        self.failIf('foobar' in cb.aliases)
        self.assertError('foobar')

        self.assertRegexp('alias add café ignore', 'Error.*can only contain')
        self.assertRegexp('alias add 1abc ignore', 'Error.*can only contain')

    def testOptionalArgs(self):
        self.assertNotError('alias add myrepr "repr @1"')
        self.assertResponse('myrepr foo', '"foo"')
        self.assertResponse('myrepr ""', '""')

    def testNoExtraSpaces(self):
        self.assertNotError('alias add foo "action takes $1\'s money"')
        self.assertResponse('foo bar', '\x01ACTION takes bar\'s money\x01')

    def testNoExtraQuotes(self):
        self.assertNotError('alias add myre "echo s/$1/$2/g"')
        self.assertResponse('myre foo bar', 's/foo/bar/g')

    def testSimpleAliasWithoutArgsImpliesDollarStar(self):
        self.assertNotError('alias add exo echo')
        self.assertResponse('exo foo bar baz', 'foo bar baz')

class EscapedAliasTestCase(ChannelPluginTestCase):
    plugins = ('Alias', 'Utilities')
    def setUp(self):
        registry._cache.update(
            {'supybot.plugins.Alias.escapedaliases.a1a3dfoobar': 'echo baz',
            'supybot.plugins.Alias.escapedaliases.a1a3dfoobar.locked': 'False'})
        super(EscapedAliasTestCase, self).setUp()

    def testReadDatabase(self):
        self.assertResponse('foo.bar', 'baz')

    def testAdd(self):
        self.assertNotError('alias add spam.egg echo hi')
        self.assertResponse('spam.egg', 'hi')

        self.assertNotError('alias add spam|egg echo hey')
        self.assertResponse('spam|egg', 'hey')

        self.assertNotError('alias remove spam.egg')
        self.assertError('spam.egg')
        self.assertNotError('spam|egg')
        self.assertNotError('alias remove spam|egg')
        self.assertError('spam.egg')
        self.assertError('spam|egg')

    def testWriteDatabase(self):
        self.assertNotError('alias add fooo.spam echo egg')
        self.assertResponse('fooo.spam', 'egg')
        self.failUnless(hasattr(conf.supybot.plugins.Alias.escapedaliases,
            'a1a4dfooospam'))
        self.assertEqual(conf.supybot.plugins.Alias.escapedaliases.a1a4dfooospam(),
                'echo egg')

        self.assertNotError('alias add foo.spam.egg echo supybot')
        self.assertResponse('foo.spam.egg', 'supybot')
        self.failUnless(hasattr(conf.supybot.plugins.Alias.escapedaliases,
            'a2a3d8dfoospamegg'))
        self.assertEqual(conf.supybot.plugins.Alias.escapedaliases.a2a3d8dfoospamegg(),
                'echo supybot')
        self.assertEqual(Alias.unescapeAlias('a2a3d8dfoospamegg'),
            'foo.spam.egg')

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2005, Daniel DiPaolo
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Anonymous')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Anonymous', True)


Anonymous = conf.registerPlugin('Anonymous')
# This is where your configuration variables (if any) should go.  For example:
# conf.registerGlobalValue(Anonymous, 'someConfigVariableName',
#     registry.Boolean(False, """Help for someConfigVariableName."""))
conf.registerChannelValue(conf.supybot.plugins.Anonymous,
    'requirePresenceInChannel', registry.Boolean(True, _("""Determines whether
    the bot should require people trying to use this plugin to be in the
    channel they wish to anonymously send to.""")))
conf.registerChannelValue(conf.supybot.plugins.Anonymous, 'requireRegistration',
    registry.Boolean(True, _("""Determines whether the bot should require
    people trying to use this plugin to be registered.""")))
conf.registerChannelValue(conf.supybot.plugins.Anonymous, 'requireCapability',
    registry.String('', _("""Determines what capability (if any) the bot should
    require people trying to use this plugin to have.""")))
conf.registerGlobalValue(conf.supybot.plugins.Anonymous, 'allowPrivateTarget',
    registry.Boolean(False, _("""Determines whether the bot will require 
    targets of the "say" command to be public (i.e., channels).  If this is
    True, the bot will allow people to use the "say" command to send private
    messages to other users.""")))


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2005, Daniel DiPaolo
# Copyright (c) 2010, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.ircdb as ircdb
import supybot.utils as utils
from supybot.commands import *
import supybot.ircmsgs as ircmsgs
import supybot.callbacks as callbacks
import supybot.ircutils as ircutils
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Anonymous')

class Anonymous(callbacks.Plugin):
    """This plugin allows users to act through the bot anonymously.  The 'do'
    command has the bot perform an anonymous action in a given channel, and
    the 'say' command allows other people to speak through the bot.  Since
    this can be fairly well abused, you might want to set
    supybot.plugins.Anonymous.requireCapability so only users with that
    capability can use this plugin.  For extra security, you can require that
    the user be *in* the channel they are trying to address anonymously with
    supybot.plugins.Anonymous.requirePresenceInChannel, or you can require
    that the user be registered by setting
    supybot.plugins.Anonymous.requireRegistration.
    """
    def _preCheck(self, irc, msg, target, action):
        if self.registryValue('requireRegistration', target):
            try:
                foo = ircdb.users.getUser(msg.prefix)
            except KeyError:
                irc.errorNotRegistered(Raise=True)
        capability = self.registryValue('requireCapability', target)
        if capability:
            if not ircdb.checkCapability(msg.prefix, capability):
                irc.errorNoCapability(capability, Raise=True)
        if irc.isChannel(target):
            if self.registryValue('requirePresenceInChannel', target) and \
               msg.nick not in irc.state.channels[target].users:
                irc.error(format(_('You must be in %s to %q in there.'),
                                 target, action), Raise=True)
            c = ircdb.channels.getChannel(target)
            if c.lobotomized:
                irc.error(format(_('I\'m lobotomized in %s.'), target),
                          Raise=True)
            if not c._checkCapability(self.name()):
                irc.error(_('That channel has set its capabilities so as to '
                          'disallow the use of this plugin.'), Raise=True)
        elif action == 'say' and not self.registryValue('allowPrivateTarget'):
            irc.error(format(_('%q cannot be used to send private messages.'),
                             action),
                      Raise=True)

    @internationalizeDocstring
    def say(self, irc, msg, args, target, text):
        """<channel|nick> <text>

        Sends <text> to <channel|nick>.  Can only send to <nick> if
        supybot.plugins.Anonymous.allowPrivateTarget is True.
        """
        self._preCheck(irc, msg, target, 'say')
        self.log.info('Saying %q to %s due to %s.',
                      text, target, msg.prefix)
        irc.reply(text, to=target, prefixNick=False,
                     private=not ircutils.isChannel(target))
    say = wrap(say, [first('nick', 'inChannel'), 'text'])

    @internationalizeDocstring
    def do(self, irc, msg, args, channel, text):
        """<channel> <action>

        Performs <action> in <channel>.
        """
        self._preCheck(irc, msg, channel, 'do')
        self.log.info('Performing %q in %s due to %s.',
                      text, channel, msg.prefix)
        irc.reply(text, action=True, to=channel)
    do = wrap(do, ['inChannel', 'text'])
Anonymous = internationalizeDocstring(Anonymous)

Class = Anonymous


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2005, Daniel DiPaolo
# Copyright (c) 2010, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

class AnonymousTestCase(ChannelPluginTestCase):
    plugins = ('Anonymous',)
    def testSay(self):
        self.assertError('anonymous say %s I love you!' % self.channel)
        self.assertError('anonymous say %s I love you!' % self.nick)
        origreg = conf.supybot.plugins.Anonymous.requireRegistration()
        origpriv = conf.supybot.plugins.Anonymous.allowPrivateTarget()
        try:
            conf.supybot.plugins.Anonymous.requireRegistration.setValue(False)
            m = self.assertNotError('anonymous say %s foo!' % self.channel)
            self.assertEqual(m.args[1], 'foo!')
            conf.supybot.plugins.Anonymous.allowPrivateTarget.setValue(True)
            m = self.assertNotError('anonymous say %s foo!' % self.nick)
            self.assertEqual(m.args[1], 'foo!')
        finally:
            conf.supybot.plugins.Anonymous.requireRegistration.setValue(origreg)
            conf.supybot.plugins.Anonymous.allowPrivateTarget.setValue(origpriv)

    def testAction(self):
        m = self.assertError('anonymous do %s loves you!' % self.channel)
        try:
            orig = conf.supybot.plugins.Anonymous.requireRegistration()
            conf.supybot.plugins.Anonymous.requireRegistration.setValue(False)
            m = self.assertNotError('anonymous do %s loves you!'%self.channel)
            self.assertEqual(m.args, ircmsgs.action(self.channel,
                                                    'loves you!').args)
        finally:
            conf.supybot.plugins.Anonymous.requireRegistration.setValue(orig)


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('AutoMode')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('AutoMode', True)


AutoMode = conf.registerPlugin('AutoMode')
conf.registerChannelValue(AutoMode, 'enable',
    registry.Boolean(True, _("""Determines whether this plugin is enabled.
    """)))
conf.registerGlobalValue(AutoMode, 'owner',
    registry.Boolean(False, _("""Determines whether this plugin will automode
    owners even if they don't have op/halfop/voice/whatever capability.""")))
conf.registerChannelValue(AutoMode, 'alternativeCapabilities',
    registry.Boolean(False, _("""Determines whether the bot will
    check for 'alternative capabilities' (ie. autoop, autohalfop,
    autovoice) in addition to/instead of classic ones.""")))
conf.registerChannelValue(AutoMode, 'fallthrough',
    registry.Boolean(True, _("""Determines whether the bot will "fall
    through" to halfop/voicing when auto-opping is turned off but
    auto-halfopping/voicing are turned on.""")))
conf.registerChannelValue(AutoMode, 'op',
    registry.Boolean(False, _("""Determines whether the bot will automatically
    op people with the <channel>,op capability when they join the channel.
    """)))
conf.registerChannelValue(AutoMode, 'halfop',
    registry.Boolean(False, _("""Determines whether the bot will automatically
    halfop people with the <channel>,halfop capability when they join the
    channel.""")))
conf.registerChannelValue(AutoMode, 'voice',
    registry.Boolean(False, _("""Determines whether the bot will automatically
    voice people with the <channel>,voice capability when they join the
    channel.""")))
conf.registerChannelValue(AutoMode, 'ban',
    registry.Boolean(True, _("""Determines whether the bot will automatically
    ban people who join the channel and are on the banlist.""")))
conf.registerChannelValue(AutoMode.ban, 'period',
    registry.PositiveInteger(86400, _("""Determines how many seconds the bot
    will automatically ban a person when banning.""")))

conf.registerChannelValue(AutoMode, 'delay',
    registry.Integer(0, _("""Determines how many seconds the bot will wait
    before applying a mode. Has no effect on bans.""")))

conf.registerChannelValue(AutoMode, 'extra',
    registry.SpaceSeparatedListOfStrings([], _("""Extra modes that will be
    applied to a user. Example syntax: user1+o-v user2+v user3-v""")))

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2004, Jeremiah Fincher
# Copyright (c) 2009, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import re
import time

import supybot.log as log
import supybot.conf as conf
import supybot.ircdb as ircdb
import supybot.ircmsgs as ircmsgs
import supybot.ircutils as ircutils
import supybot.schedule as schedule
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('AutoMode')

class Continue(Exception):
    pass # Used below, look in the "do" function nested in doJoin.

class AutoMode(callbacks.Plugin):
    def doJoin(self, irc, msg):
        channel = msg.args[0]
        if ircutils.strEqual(irc.nick, msg.nick):
            return
        if not self.registryValue('enable', channel):
            return
        fallthrough = self.registryValue('fallthrough', channel)
        def do(type):
            cap = ircdb.makeChannelCapability(channel, type)
            cap_auto = ircdb.makeChannelCapability(channel, 'auto'+type)
            try:
                apply_mode = ircdb.checkCapability(msg.prefix, cap,
                        ignoreOwner=not self.registryValue('owner'),
                        ignoreChannelOp=True, ignoreDefaultAllow=True)
            except KeyError:
                apply_mode = False
            if self.registryValue('alternativeCapabilities', channel):
                try:
                    override = ircdb.checkCapability(msg.prefix, cap_auto,
                            ignoreOwner=not self.registryValue('owner'),
                            ignoreChannelOp=True, ignoreDefaultAllow=True)
                except KeyError:
                    override = False
            else:
                override = False
            if apply_mode or override:
                if override or self.registryValue(type, channel):
                    self.log.info('Scheduling auto-%s of %s in %s.',
                                  type, msg.prefix, channel)
                    def dismiss():
                        """Determines whether or not a mode has already
                        been applied."""
                        l = getattr(irc.state.channels[channel], type+'s')
                        return (msg.nick in l)
                    msgmaker = getattr(ircmsgs, type)
                    schedule_msg(msgmaker(channel, msg.nick),
                            dismiss)
                    raise Continue # Even if fallthrough, let's only do one.
                elif not fallthrough:
                    self.log.debug('%s has %s, but supybot.plugins.AutoMode.%s'
                                   ' is not enabled in %s, refusing to fall '
                                   'through.', msg.prefix, cap, type, channel)
                    raise Continue
        def schedule_msg(msg, dismiss):
            def f():
                if not dismiss():
                    irc.queueMsg(msg)
                else:
                    self.log.info('Dismissing auto-mode for %s.' % msg.nick)
            delay = self.registryValue('delay', channel)
            if delay:
                schedule.addEvent(f, time.time() + delay)
            else:
                f()
        def extra_modes():
            try:
                user = ircdb.users.getUser(ircdb.users.getUserId(msg.prefix))
            except KeyError:
                return
            pattern = re.compile('-|\+')
            for item in self.registryValue('extra', channel):
                try:
                    username, modes = pattern.split(item, maxsplit=1)
                    modes = item[len(username)] + modes
                except ValueError: # No - or + in item
                    log.error(('%r is not a valid item for '
                            'supybot.plugins.AutoMode.extra') % item)
                    continue
                if username != user.name:
                    continue
                else:
                    self.log.info('Scheduling auto-modes %s of %s in %s.',
                                  modes, msg.prefix, channel)
                    modes = [modes] + \
                            ([msg.nick]*len(pattern.sub('', modes)))
                    schedule_msg(ircmsgs.mode(channel, modes), lambda :False)
                    break
        try:
            do('op')
            if 'h' in irc.state.supported['prefix']:
                do('halfop')
            do('voice')
        except Continue:
            return
        finally:
            extra_modes()
        c = ircdb.channels.getChannel(channel)
        if c.checkBan(msg.prefix) and self.registryValue('ban', channel):
            period = self.registryValue('ban.period', channel)
            if period:
                def unban():
                    try:
                        if msg.prefix in irc.state.channels[channel].bans:
                            irc.queueMsg(ircmsgs.unban(channel, msg.prefix))
                    except KeyError:
                        # We're not in the channel anymore.
                        pass
                schedule.addEvent(unban, time.time()+period)
            banmask =conf.supybot.protocols.irc.banmask.makeBanmask(msg.prefix)
            irc.queueMsg(ircmsgs.ban(channel, banmask))
            irc.queueMsg(ircmsgs.kick(channel, msg.nick))




Class = AutoMode

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

class AutoModeTestCase(PluginTestCase):
    plugins = ('AutoMode',)


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from __future__ import division

import time

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('BadWords')

def configure(advanced):
    from supybot.questions import output, expect, anything, something, yn
    conf.registerPlugin('BadWords', True)
    if yn(_('Would you like to add some bad words?')):
        words = anything(_('What words? (separate individual words by '
                         'spaces)'))
        conf.supybot.plugins.BadWords.words.set(words)

class LastModifiedSetOfStrings(registry.SpaceSeparatedSetOfStrings):
    lastModified = 0
    def setValue(self, v):
        self.lastModified = time.time()
        registry.SpaceSeparatedListOfStrings.setValue(self, v)

BadWords = conf.registerPlugin('BadWords')
conf.registerGlobalValue(BadWords, 'words',
    LastModifiedSetOfStrings([], _("""Determines what words are
    considered to be 'bad' so the bot won't say them.""")))
conf.registerChannelValue(BadWords,'requireWordBoundaries',
    registry.Boolean(False, _("""Determines whether the bot will require bad
    words to be independent words, or whether it will censor them within other
    words.  For instance, if 'darn' is a bad word, then if this is true, 'darn'
    will be censored, but 'darnit' will not.  You probably want this to be
    false. After changing this setting, the BadWords regexp needs to be
    regenerated by adding/removing a word to the list, or reloading the
    plugin.""")))

class String256(registry.String):
    def __call__(self):
        s = registry.String.__call__(self)
        return s * (1024//len(s))

    def __str__(self):
        return self.value

conf.registerGlobalValue(BadWords, 'nastyChars',
    String256('!@#&', _("""Determines what characters will replace bad words; a
    chunk of these characters matching the size of the replaced bad word will
    be used to replace the bad words you've configured.""")))

class ReplacementMethods(registry.OnlySomeStrings):
    validStrings = ('simple', 'nastyCharacters')

conf.registerGlobalValue(BadWords, 'replaceMethod',
    ReplacementMethods('nastyCharacters', _("""Determines the manner in which
    bad words will be replaced.  'nastyCharacters' (the default) will replace a
    bad word with the same number of 'nasty characters' (like those used in
    comic books; configurable by supybot.plugins.BadWords.nastyChars).
    'simple' will replace a bad word with a simple strings (regardless of the
    length of the bad word); this string is configurable via
    supybot.plugins.BadWords.simpleReplacement.""")))
conf.registerGlobalValue(BadWords,'simpleReplacement',
    registry.String('[CENSORED]', _("""Determines what word will replace bad
    words if the replacement method is 'simple'.""")))
conf.registerGlobalValue(BadWords, 'stripFormatting',
    registry.Boolean(True, _("""Determines whether the bot will strip
    formatting characters from messages before it checks them for bad words.
    If this is False, it will be relatively trivial to circumvent this plugin's
    filtering.  If it's True, however, it will interact poorly with other
    plugins that do coloring or bolding of text.""")))

conf.registerChannelValue(BadWords, 'kick',
    registry.Boolean(False, _("""Determines whether the bot will kick people with
    a warning when they use bad words.""")))
conf.registerChannelValue(BadWords.kick, 'message',
    registry.NormalizedString(_("""You have been kicked for using a word
    prohibited in the presence of this bot.  Please use more appropriate
    language in the future."""), _("""Determines the kick message used by the
    bot when kicking users for saying bad words.""")))


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2002-2004, Jeremiah Fincher
# Copyright (c) 2009, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import re
import math
import time

import supybot.conf as conf
import supybot.utils as utils
import supybot.ircdb as ircdb
import supybot.ircmsgs as ircmsgs
from supybot.commands import *
import supybot.ircutils as ircutils
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('BadWords')

class BadWords(callbacks.Privmsg):
    """Maintains a list of words that the bot is not allowed to say.
    Can also be used to kick people that say these words, if the bot
    has op."""
    def __init__(self, irc):
        self.__parent = super(BadWords, self)
        self.__parent.__init__(irc)
        # This is so we can not filter certain outgoing messages (like list,
        # which would be kinda useless if it were filtered).
        self.filtering = True
        self.lastModified = 0
        self.words = conf.supybot.plugins.BadWords.words

    def callCommand(self, name, irc, msg, *args, **kwargs):
        if ircdb.checkCapability(msg.prefix, 'admin'):
            self.__parent.callCommand(name, irc, msg, *args, **kwargs)
        else:
            irc.errorNoCapability('admin')

    def sub(self, m):
        replaceMethod = self.registryValue('replaceMethod')
        if replaceMethod == 'simple':
            return self.registryValue('simpleReplacement')
        elif replaceMethod == 'nastyCharacters':
            return self.registryValue('nastyChars')[:len(m.group(1))]

    def inFilter(self, irc, msg):
        self.filtering = True
        # We need to check for bad words here rather than in doPrivmsg because
        # messages don't get to doPrivmsg if the user is ignored.
        if msg.command == 'PRIVMSG':
            channel = msg.args[0]
            self.updateRegexp(channel)
            s = ircutils.stripFormatting(msg.args[1])
            if ircutils.isChannel(channel) and self.registryValue('kick', channel):
                if self.regexp.search(s):
                    if irc.nick in irc.state.channels[channel].ops or \
                            irc.nick in irc.state.channels[channel].halfops:
                        message = self.registryValue('kick.message', channel)
                        irc.queueMsg(ircmsgs.kick(channel, msg.nick, message))
                    else:
                        self.log.warning('Should kick %s from %s, but not opped.',
                                         msg.nick, channel)
        return msg

    def updateRegexp(self, channel):
        if self.lastModified < self.words.lastModified:
            self.makeRegexp(self.words(), channel)
            self.lastModified = time.time()

    def outFilter(self, irc, msg):
        if self.filtering and msg.command == 'PRIVMSG' and self.words():
            channel = msg.args[0]
            self.updateRegexp(channel)
            s = msg.args[1]
            if self.registryValue('stripFormatting'):
                s = ircutils.stripFormatting(s)
            t = self.regexp.sub(self.sub, s)
            if t != s:
                msg = ircmsgs.privmsg(msg.args[0], t, msg=msg)
        return msg

    def makeRegexp(self, iterable, channel):
        s = '(%s)' % '|'.join(map(re.escape, iterable))
        if self.registryValue('requireWordBoundaries', channel):
            s = r'\b%s\b' % s
        self.regexp = re.compile(s, re.I)

    @internationalizeDocstring
    def list(self, irc, msg, args):
        """takes no arguments

        Returns the list of words being censored.
        """
        L = list(self.words())
        if L:
            self.filtering = False
            utils.sortBy(str.lower, L)
            irc.reply(format('%L', L))
        else:
            irc.reply(_('I\'m not currently censoring any bad words.'))
    list = wrap(list, ['admin'])

    @internationalizeDocstring
    def add(self, irc, msg, args, words):
        """<word> [<word> ...]

        Adds all <word>s to the list of words being censored.
        """
        set = self.words()
        set.update(words)
        self.words.setValue(set)
        irc.replySuccess()
    add = wrap(add, ['admin', many('something')])

    @internationalizeDocstring
    def remove(self, irc, msg, args, words):
        """<word> [<word> ...]

        Removes <word>s from the list of words being censored.
        """
        set = self.words()
        for word in words:
            set.discard(word)
        self.words.setValue(set)
        irc.replySuccess()
    remove = wrap(remove, ['admin', many('something')])


Class = BadWords


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2002-2004, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

class BadWordsTestCase(PluginTestCase):
    plugins = ('BadWords', 'Utilities', 'Format')
    badwords = ('shit', 'ass')
    def tearDown(self):
        # .default() doesn't seem to be working for BadWords.words
        #default = conf.supybot.plugins.BadWords.words.default()
        #conf.supybot.plugins.BadWords.words.setValue(default)
        conf.supybot.plugins.BadWords.words.setValue([])

    def _test(self):
        for word in self.badwords:
            self.assertRegexp('echo %s' % word, '(?!%s)' % word)
            self.assertRegexp('echo [colorize %s]' % word, '(?!%s)' % word)
            self.assertRegexp('echo foo%sbar' % word, '(?!%s)' % word)
            self.assertRegexp('echo [format join "" %s]' % ' '.join(word),
                              '(?!%s)' % word)

    def _NegTest(self):
        for word in self.badwords:
            self.assertRegexp('echo %s' % word, word)
            self.assertRegexp('echo foo%sbar' % word, word)
            self.assertRegexp('echo [format join "" %s]' % ' '.join(word),word)

    def testAddbadwords(self):
        self.assertNotError('badwords add %s' % ' '.join(self.badwords))
        self._test()

    def testDefault(self):
        self._NegTest()

    def testRemovebadwords(self):
        self.assertNotError('badwords add %s' % ' '.join(self.badwords))
        self.assertNotError('badwords remove %s' % ' '.join(self.badwords))
        self._NegTest()

    def testList(self):
        self.assertNotError('badwords list')
        self.assertNotError('badwords add shit')
        self.assertNotError('badwords add ass')
        self.assertResponse('badwords list', 'ass and shit')

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:


########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2004-2005, Jeremiah Fincher
# Copyright (c) 2009, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###


import supybot.conf as conf
import supybot.utils as utils
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Channel')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Channel', True)

Channel = conf.registerPlugin('Channel')
conf.registerChannelValue(Channel, 'alwaysRejoin',
    registry.Boolean(True, _("""Determines whether the bot will always try to
    rejoin a channel whenever it's kicked from the channel.""")))


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# Copyright (c) 2009-2012, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import sys

import supybot.conf as conf
import supybot.ircdb as ircdb
import supybot.utils as utils
from supybot.commands import *
import supybot.ircmsgs as ircmsgs
import supybot.schedule as schedule
import supybot.ircutils as ircutils
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Channel')

class Channel(callbacks.Plugin):
    def __init__(self, irc):
        self.__parent = super(Channel, self)
        self.__parent.__init__(irc)
        self.invites = {}

    def doKick(self, irc, msg):
        channel = msg.args[0]
        if msg.args[1] == irc.nick:
            if self.registryValue('alwaysRejoin', channel):
                self.log.info('Kicked from %s by %s. Rejoining.' %
                        (channel, msg.prefix))
                networkGroup = conf.supybot.networks.get(irc.network)
                irc.sendMsg(networkGroup.channels.join(channel))
            else:
                self.log.info('Kicked from %s by %s. Not auto-rejoining.' %
                        (channel, msg.prefix))

    def _sendMsg(self, irc, msg):
        irc.queueMsg(msg)
        irc.noReply()

    def _sendMsgs(self, irc, nicks, f):
        numModes = irc.state.supported.get('modes', 1)
        for i in range(0, len(nicks), numModes):
            irc.queueMsg(f(nicks[i:i + numModes]))
        irc.noReply()

    @internationalizeDocstring
    def mode(self, irc, msg, args, channel, modes):
        """[<channel>] <mode> [<arg> ...]

        Sets the mode in <channel> to <mode>, sending the arguments given.
        <channel> is only necessary if the message isn't sent in the channel
        itself.
        """
        self._sendMsg(irc, ircmsgs.mode(channel, modes))
    mode = wrap(mode, ['op', ('haveHalfop+', _('change the mode')), many('something')])

    @internationalizeDocstring
    def limit(self, irc, msg, args, channel, limit):
        """[<channel>] [<limit>]

        Sets the channel limit to <limit>.  If <limit> is 0, or isn't given,
        removes the channel limit.  <channel> is only necessary if the message
        isn't sent in the channel itself.
        """
        if limit:
            self._sendMsg(irc, ircmsgs.mode(channel, ['+l', limit]))
        else:
            self._sendMsg(irc, ircmsgs.mode(channel, ['-l']))
    limit = wrap(limit, ['op', ('haveOp', _('change the limit')),
                        additional('nonNegativeInt', 0)])

    @internationalizeDocstring
    def moderate(self, irc, msg, args, channel):
        """[<channel>]

        Sets +m on <channel>, making it so only ops and voiced users can
        send messages to the channel.  <channel> is only necessary if the
        message isn't sent in the channel itself.
        """
        self._sendMsg(irc, ircmsgs.mode(channel, ['+m']))
    moderate = wrap(moderate, ['op', ('haveHalfop+', _('moderate the channel'))])

    @internationalizeDocstring
    def unmoderate(self, irc, msg, args, channel):
        """[<channel>]

        Sets -m on <channel>, making it so everyone can
        send messages to the channel.  <channel> is only necessary if the
        message isn't sent in the channel itself.
        """
        self._sendMsg(irc, ircmsgs.mode(channel, ['-m']))
    unmoderate = wrap(unmoderate, ['op', ('haveHalfop+',
                                   _('unmoderate the channel'))])

    @internationalizeDocstring
    def key(self, irc, msg, args, channel, key):
        """[<channel>] [<key>]

        Sets the keyword in <channel> to <key>.  If <key> is not given, removes
        the keyword requirement to join <channel>.  <channel> is only necessary
        if the message isn't sent in the channel itself.
        """
        networkGroup = conf.supybot.networks.get(irc.network)
        networkGroup.channels.key.get(channel).setValue(key)
        if key:
            self._sendMsg(irc, ircmsgs.mode(channel, ['+k', key]))
        else:
            self._sendMsg(irc, ircmsgs.mode(channel, ['-k']))
    key = wrap(key, ['op', ('haveHalfop+', _('change the keyword')),
                     additional('somethingWithoutSpaces', '')])

    @internationalizeDocstring
    def op(self, irc, msg, args, channel, nicks):
        """[<channel>] [<nick> ...]

        If you have the #channel,op capability, this will give all the <nick>s
        you provide ops.  If you don't provide any <nick>s, this will op you.
        <channel> is only necessary if the message isn't sent in the channel
        itself.
        """
        if not nicks:
            nicks = [msg.nick]
        def f(L):
            return ircmsgs.ops(channel, L)
        self._sendMsgs(irc, nicks, f)
    op = wrap(op, ['op', ('haveOp', _('op someone')), any('nickInChannel')])

    @internationalizeDocstring
    def halfop(self, irc, msg, args, channel, nicks):
        """[<channel>] [<nick> ...]

        If you have the #channel,halfop capability, this will give all the
        <nick>s you provide halfops.  If you don't provide any <nick>s, this
        will give you halfops. <channel> is only necessary if the message isn't
        sent in the channel itself.
        """
        if not nicks:
            nicks = [msg.nick]
        def f(L):
            return ircmsgs.halfops(channel, L)
        self._sendMsgs(irc, nicks, f)
    halfop = wrap(halfop, ['halfop', ('haveOp', _('halfop someone')),
                           any('nickInChannel')])

    def _voice(self, irc, msg, args, channel, nicks, fn):
        if nicks:
            if len(nicks) == 1 and msg.nick in nicks:
                capability = 'voice'
            else:
                capability = 'op'
        else:
            nicks = [msg.nick]
            capability = 'voice'
        capability = ircdb.makeChannelCapability(channel, capability)
        if ircdb.checkCapability(msg.prefix, capability):
            def f(L):
                return fn(channel, L)
            self._sendMsgs(irc, nicks, f)
        else:
            irc.errorNoCapability(capability)

    def voice(self, irc, msg, args, channel, nicks):
        """[<channel>] [<nick> ...]

        If you have the #channel,voice capability, this will voice all the
        <nick>s you provide.  If you don't provide any <nick>s, this will
        voice you. <channel> is only necessary if the message isn't sent in the
        channel itself.
        """
        self._voice(irc, msg, args, channel, nicks, ircmsgs.voices)
    voice = wrap(voice, ['channel', ('haveHalfop+', _('voice someone')),
                         any('nickInChannel')])

    @internationalizeDocstring
    def deop(self, irc, msg, args, channel, nicks):
        """[<channel>] [<nick> ...]

        If you have the #channel,op capability, this will remove operator
        privileges from all the nicks given.  If no nicks are given, removes
        operator privileges from the person sending the message.
        """
        if irc.nick in nicks:
            irc.error(_('I cowardly refuse to deop myself.  If you really '
                      'want me deopped, tell me to op you and then deop me '
                      'yourself.'), Raise=True)
        if not nicks:
            nicks = [msg.nick]
        def f(L):
            return ircmsgs.deops(channel, L)
        self._sendMsgs(irc, nicks, f)
    deop = wrap(deop, ['op', ('haveOp', _('deop someone')),
                       any('nickInChannel')])

    @internationalizeDocstring
    def dehalfop(self, irc, msg, args, channel, nicks):
        """[<channel>] [<nick> ...]

        If you have the #channel,op capability, this will remove half-operator
        privileges from all the nicks given.  If no nicks are given, removes
        half-operator privileges from the person sending the message.
        """
        if irc.nick in nicks:
            irc.error(_('I cowardly refuse to dehalfop myself.  If you really '
                      'want me dehalfopped, tell me to op you and then '
                      'dehalfop me yourself.'), Raise=True)
        if not nicks:
            nicks = [msg.nick]
        def f(L):
            return ircmsgs.dehalfops(channel, L)
        self._sendMsgs(irc, nicks, f)
    dehalfop = wrap(dehalfop, ['halfop', ('haveOp', _('dehalfop someone')),
                               any('nickInChannel')])

    @internationalizeDocstring
    def devoice(self, irc, msg, args, channel, nicks):
        """[<channel>] [<nick> ...]

        If you have the #channel,op capability, this will remove voice from all
        the nicks given.  If no nicks are given, removes voice from the person
        sending the message.
        """
        if irc.nick in nicks:
            irc.error(_('I cowardly refuse to devoice myself.  If you really '
                      'want me devoiced, tell me to op you and then devoice '
                      'me yourself.'), Raise=True)
        self._voice(irc, msg, args, channel, nicks, ircmsgs.devoices)
    devoice = wrap(devoice, ['channel', ('haveOp', 'devoice someone'),
                             any('nickInChannel')])

    @internationalizeDocstring
    def cycle(self, irc, msg, args, channel):
        """[<channel>]

        If you have the #channel,op capability, this will cause the bot to
        "cycle", or PART and then JOIN the channel. <channel> is only necessary
        if the message isn't sent in the channel itself.
        """
        self._sendMsg(irc, ircmsgs.part(channel, msg.nick))
        networkGroup = conf.supybot.networks.get(irc.network)
        self._sendMsg(irc, networkGroup.channels.join(channel))
    cycle = wrap(cycle, ['op'])

    @internationalizeDocstring
    def kick(self, irc, msg, args, channel, nicks, reason):
        """[<channel>] <nick>[, <nick>, ...] [<reason>]

        Kicks <nick>(s) from <channel> for <reason>.  If <reason> isn't given,
        uses the nick of the person making the command as the reason.
        <channel> is only necessary if the message isn't sent in the channel
        itself.
        """
        if utils.iter.any(lambda n: ircutils.strEqual(n, irc.nick), nicks):
            irc.error(_('I cowardly refuse to kick myself.'), Raise=True)
        if not reason:
            reason = msg.nick
        kicklen = irc.state.supported.get('kicklen', sys.maxsize)
        if len(reason) > kicklen:
            irc.error(_('The reason you gave is longer than the allowed '
                      'length for a KICK reason on this server.'),
                      Raise=True)
        for nick in nicks:
            self._sendMsg(irc, ircmsgs.kick(channel, nick, reason))
    kick = wrap(kick, ['op', ('haveHalfop+', _('kick someone')),
                       commalist('nickInChannel'), additional('text')])

    @internationalizeDocstring
    def kban(self, irc, msg, args,
             channel, optlist, bannedNick, expiry, reason):
        """[<channel>] [--{exact,nick,user,host}] <nick> [<seconds>] [<reason>]

        If you have the #channel,op capability, this will kickban <nick> for
        as many seconds as you specify, or else (if you specify 0 seconds or
        don't specify a number of seconds) it will ban the person indefinitely.
        --exact bans only the exact hostmask; --nick bans just the nick;
        --user bans just the user, and --host bans just the host.  You can
        combine these options as you choose.  <reason> is a reason to give for
        the kick.
        <channel> is only necessary if the message isn't sent in the channel
        itself.
        """
        self._ban(irc, msg, args,
                channel, optlist, bannedNick, expiry, reason, True)
    kban = wrap(kban,
                ['op',
                 getopts({'exact':'', 'nick':'', 'user':'', 'host':''}),
                 ('haveHalfop+', _('kick or ban someone')),
                 'nickInChannel',
                 optional('expiry', 0),
                 additional('text')])

    @internationalizeDocstring
    def iban(self, irc, msg, args,
             channel, optlist, bannedNick, expiry):
        """[<channel>] [--{exact,nick,user,host}] <nick> [<seconds>]

        If you have the #channel,op capability, this will ban <nick> for
        as many seconds as you specify, or else (if you specify 0 seconds or
        don't specify a number of seconds) it will ban the person indefinitely.
        --exact bans only the exact hostmask; --nick bans just the nick;
        --user bans just the user, and --host bans just the host.  You can
        combine these options as you choose.
        <channel> is only necessary if the message isn't sent in the channel
        itself.
        """
        self._ban(irc, msg, args,
                channel, optlist, bannedNick, expiry, None, False)
    iban = wrap(iban,
                ['op',
                 getopts({'exact':'', 'nick':'', 'user':'', 'host':''}),
                 ('haveHalfop+', _('ban someone')),
                 first('nick', 'hostmask'),
                 optional('expiry', 0)])

    def _ban(self, irc, msg, args,
            channel, optlist, target, expiry, reason, kick):
        # Check that they're not trying to make us kickban ourself.
        if irc.isNick(target):
            bannedNick = target
            try:
                bannedHostmask = irc.state.nickToHostmask(target)
                banmaskstyle = conf.supybot.protocols.irc.banmask
                banmask = banmaskstyle.makeBanmask(bannedHostmask, [o[0] for o in optlist])
            except KeyError:
                if not conf.supybot.protocols.irc.strictRfc() and \
                        target.startswith('$'):
                    # Select the last part, or the whole target:
                    bannedNick = target.split(':')[-1]
                    banmask = bannedHostmask = target
                else:
                    irc.error(format(_('I haven\'t seen %s.'), bannedNick), Raise=True)
        else:
            bannedNick = ircutils.nickFromHostmask(target)
            banmask = bannedHostmask = target
        if not irc.isNick(bannedNick):
            self.log.warning('%q tried to kban a non nick: %q',
                             msg.prefix, bannedNick)
            raise callbacks.ArgumentError
        elif bannedNick == irc.nick:
            self.log.warning('%q tried to make me kban myself.', msg.prefix)
            irc.error(_('I cowardly refuse to kickban myself.'))
            return
        if not reason:
            reason = msg.nick
        capability = ircdb.makeChannelCapability(channel, 'op')
        # Check (again) that they're not trying to make us kickban ourself.
        if ircutils.hostmaskPatternEqual(banmask, irc.prefix):
            if ircutils.hostmaskPatternEqual(bannedHostmask, irc.prefix):
                self.log.warning('%q tried to make me kban myself.',msg.prefix)
                irc.error(_('I cowardly refuse to ban myself.'))
                return
            else:
                self.log.warning('Using exact hostmask since banmask would '
                                 'ban myself.')
                banmask = bannedHostmask
        # Now, let's actually get to it.  Check to make sure they have
        # #channel,op and the bannee doesn't have #channel,op; or that the
        # bannee and the banner are both the same person.
        def doBan():
            if irc.state.channels[channel].isOp(bannedNick):
                irc.queueMsg(ircmsgs.deop(channel, bannedNick))
            irc.queueMsg(ircmsgs.ban(channel, banmask))
            if kick:
                irc.queueMsg(ircmsgs.kick(channel, bannedNick, reason))
            if expiry > 0:
                def f():
                    if channel in irc.state.channels and \
                       banmask in irc.state.channels[channel].bans:
                        irc.queueMsg(ircmsgs.unban(channel, banmask))
                schedule.addEvent(f, expiry)
        if bannedNick == msg.nick:
            doBan()
        elif ircdb.checkCapability(msg.prefix, capability):
            if ircdb.checkCapability(bannedHostmask, capability) and \
                    not ircdb.checkCapability(msg.prefix, 'owner'):
                self.log.warning('%s tried to ban %q, but both have %s',
                                 msg.prefix, bannedHostmask, capability)
                irc.error(format(_('%s has %s too, you can\'t ban '
                                 'them.'), bannedNick, capability))
            else:
                doBan()
        else:
            self.log.warning('%q attempted kban without %s',
                             msg.prefix, capability)
            irc.errorNoCapability(capability)

    @internationalizeDocstring
    def unban(self, irc, msg, args, channel, hostmask):
        """[<channel>] [<hostmask|--all>]

        Unbans <hostmask> on <channel>.  If <hostmask> is not given, unbans
        any hostmask currently banned on <channel> that matches your current
        hostmask.  Especially useful for unbanning yourself when you get
        unexpectedly (or accidentally) banned from the channel.  <channel> is
        only necessary if the message isn't sent in the channel itself.
        """
        if hostmask == '--all':
            bans = irc.state.channels[channel].bans
            self._sendMsg(irc, ircmsgs.unbans(channel, bans))
        elif hostmask:
            self._sendMsg(irc, ircmsgs.unban(channel, hostmask))
        else:
            bans = []
            for banmask in irc.state.channels[channel].bans:
                if ircutils.hostmaskPatternEqual(banmask, msg.prefix):
                    bans.append(banmask)
            if bans:
                irc.queueMsg(ircmsgs.unbans(channel, bans))
                irc.replySuccess(format(_('All bans on %s matching %s '
                                        'have been removed.'),
                                        channel, msg.prefix))
            else:
                irc.error(_('No bans matching %s were found on %s.') %
                          (msg.prefix, channel))
    unban = wrap(unban, ['op',
                         ('haveHalfop+', _('unban someone')),
                         additional(
                             first('hostmask',
                                 ('literal', '--all')))])

    @internationalizeDocstring
    def listbans(self, irc, msg, args, channel):
        """[<channel>]

        List all bans on the channel.
        If <channel> is not given, it defaults to the current channel."""
        irc.replies(irc.state.channels[channel].bans or [_('No bans.')])
    listbans = wrap(listbans, ['channel'])

    @internationalizeDocstring
    def invite(self, irc, msg, args, channel, nick):
        """[<channel>] <nick>

        If you have the #channel,op capability, this will invite <nick>
        to join <channel>. <channel> is only necessary if the message isn't
        sent in the channel itself.
        """
        nick = nick or msg.nick
        self._sendMsg(irc, ircmsgs.invite(nick, channel))
        self.invites[(irc.getRealIrc(), ircutils.toLower(nick))] = irc
    invite = wrap(invite, ['op', ('haveHalfop+', _('invite someone')),
                           additional('nick')])

    def do341(self, irc, msg):
        (foo, nick, channel) = msg.args
        nick = ircutils.toLower(nick)
        replyIrc = self.invites.pop((irc, nick), None)
        if replyIrc is not None:
            self.log.info('Inviting %s to %s by command of %s.',
                          nick, channel, replyIrc.msg.prefix)
            replyIrc.replySuccess()
        else:
            self.log.info('Inviting %s to %s.', nick, channel)

    def do443(self, irc, msg):
        (foo, nick, channel, foo) = msg.args
        nick = ircutils.toLower(nick)
        replyIrc = self.invites.pop((irc, nick), None)
        if replyIrc is not None:
            replyIrc.error(format(_('%s is already in %s.'), nick, channel))

    def do401(self, irc, msg):
        nick = msg.args[1]
        nick = ircutils.toLower(nick)
        replyIrc = self.invites.pop((irc, nick), None)
        if replyIrc is not None:
            replyIrc.error(format(_('There is no %s on this network.'), nick))

    def do504(self, irc, msg):
        nick = msg.args[1]
        nick = ircutils.toLower(nick)
        replyIrc = self.invites.pop((irc, nick), None)
        if replyIrc is not None:
            replyIrc.error(format('There is no %s on this server.', nick))

    class lobotomy(callbacks.Commands):
        @internationalizeDocstring
        def add(self, irc, msg, args, channel):
            """[<channel>]

            If you have the #channel,op capability, this will "lobotomize" the
            bot, making it silent and unanswering to all requests made in the
            channel. <channel> is only necessary if the message isn't sent in
            the channel itself.
            """
            c = ircdb.channels.getChannel(channel)
            c.lobotomized = True
            ircdb.channels.setChannel(channel, c)
            irc.replySuccess()
        add = wrap(add, ['op'])

        @internationalizeDocstring
        def remove(self, irc, msg, args, channel):
            """[<channel>]

            If you have the #channel,op capability, this will unlobotomize the
            bot, making it respond to requests made in the channel again.
            <channel> is only necessary if the message isn't sent in the channel
            itself.
            """
            c = ircdb.channels.getChannel(channel)
            c.lobotomized = False
            ircdb.channels.setChannel(channel, c)
            irc.replySuccess()
        remove = wrap(remove, ['op'])

        @internationalizeDocstring
        def list(self, irc, msg, args):
            """takes no arguments

            Returns the channels in which this bot is lobotomized.
            """
            L = []
            for (channel, c) in ircdb.channels.iteritems():
                if c.lobotomized:
                    chancap = ircdb.makeChannelCapability(channel, 'op')
                    if ircdb.checkCapability(msg.prefix, 'admin') or \
                       ircdb.checkCapability(msg.prefix, chancap) or \
                       (channel in irc.state.channels and \
                        msg.nick in irc.state.channels[channel].users):
                        L.append(channel)
            if L:
                L.sort()
                s = format(_('I\'m currently lobotomized in %L.'), L)
                irc.reply(s)
            else:
                irc.reply(_('I\'m not currently lobotomized in any channels '
                          'that you\'re in.'))
        list = wrap(list)

    class ban(callbacks.Commands):
        def hostmask(self, irc, msg, args, channel, banmask):
            """[<channel>] <banmask>

            Bans the <banmask> from the <channel>."""
            irc.queueMsg(ircmsgs.ban(channel, banmask))
        hostmask = wrap(hostmask, ['op', ('haveHalfop+', _('ban someone')), 'text'])

        @internationalizeDocstring
        def add(self, irc, msg, args, channel, banmask, expires):
            """[<channel>] <nick|hostmask> [<expires>]

            If you have the #channel,op capability, this will effect a
            persistent ban from interacting with the bot on the given
            <hostmask> (or the current hostmask associated with <nick>).  Other
            plugins may enforce this ban by actually banning users with
            matching hostmasks when they join.  <expires> is an optional
            argument specifying when (in "seconds from now") the ban should
            expire; if none is given, the ban will never automatically expire.
            <channel> is only necessary if the message isn't sent in the
            channel itself.
            """
            c = ircdb.channels.getChannel(channel)
            c.addBan(banmask, expires)
            ircdb.channels.setChannel(channel, c)
            irc.replySuccess()
        add = wrap(add, ['op', first('hostmask', 'banmask'), additional('expiry', 0)])

        @internationalizeDocstring
        def remove(self, irc, msg, args, channel, banmask):
            """[<channel>] <hostmask>

            If you have the #channel,op capability, this will remove the
            persistent ban on <hostmask>.  <channel> is only necessary if the
            message isn't sent in the channel itself.
            """
            c = ircdb.channels.getChannel(channel)
            try:
                c.removeBan(banmask)
                ircdb.channels.setChannel(channel, c)
                irc.replySuccess()
            except KeyError:
                irc.error(_('There are no persistent bans for that hostmask.'))
        remove = wrap(remove, ['op', 'hostmask'])

        @internationalizeDocstring
        def list(self, irc, msg, args, channel):
            """[<channel>]

            If you have the #channel,op capability, this will show you the
            current persistent bans on the <channel>.
            """
            c = ircdb.channels.getChannel(channel)
            if c.bans:
                bans = []
                for ban in c.bans:
                    if c.bans[ban]:
                        bans.append(format(_('%q (expires %t)'),
                                           ban, c.bans[ban]))
                    else:
                        bans.append(format(_('%q (never expires)'),
                                           ban, c.bans[ban]))
                irc.reply(format('%L', bans))
            else:
                irc.reply(format(_('There are no persistent bans on %s.'),
                                 channel))
        list = wrap(list, ['op'])

    class ignore(callbacks.Commands):
        @internationalizeDocstring
        def add(self, irc, msg, args, channel, banmask, expires):
            """[<channel>] <nick|hostmask> [<expires>]

            If you have the #channel,op capability, this will set a persistent
            ignore on <hostmask> or the hostmask currently
            associated with <nick>. <expires> is an optional argument
            specifying when (in "seconds from now") the ignore will expire; if
            it isn't given, the ignore will never automatically expire.
            <channel> is only necessary if the message isn't sent in the
            channel itself.
            """
            c = ircdb.channels.getChannel(channel)
            c.addIgnore(banmask, expires)
            ircdb.channels.setChannel(channel, c)
            irc.replySuccess()
        add = wrap(add, ['op', 'banmask', additional('expiry', 0)])

        @internationalizeDocstring
        def remove(self, irc, msg, args, channel, banmask):
            """[<channel>] <hostmask>

            If you have the #channel,op capability, this will remove the
            persistent ignore on <hostmask> in the channel. <channel> is only
            necessary if the message isn't sent in the channel itself.
            """
            c = ircdb.channels.getChannel(channel)
            try:
                c.removeIgnore(banmask)
                ircdb.channels.setChannel(channel, c)
                irc.replySuccess()
            except KeyError:
                irc.error(_('There are no ignores for that hostmask.'))
        remove = wrap(remove, ['op', 'hostmask'])

        @internationalizeDocstring
        def list(self, irc, msg, args, channel):
            """[<channel>]

            Lists the hostmasks that the bot is ignoring on the given channel.
            <channel> is only necessary if the message isn't sent in the
            channel itself.
            """
            # XXX Add the expirations.
            c = ircdb.channels.getChannel(channel)
            if len(c.ignores) == 0:
                s = format(_('I\'m not currently ignoring any hostmasks in '
                           '%q'), channel)
                irc.reply(s)
            else:
                L = sorted(c.ignores)
                irc.reply(utils.str.commaAndify(list(map(repr, L))))
        list = wrap(list, ['op'])

    class capability(callbacks.Commands):
        @internationalizeDocstring
        def add(self, irc, msg, args, channel, user, capabilities):
            """[<channel>] <nick|username> <capability> [<capability> ...]

            If you have the #channel,op capability, this will give the
            <username> (or the user to whom <nick> maps)
            the capability <capability> in the channel. <channel> is only
            necessary if the message isn't sent in the channel itself.
            """
            for c in capabilities.split():
                c = ircdb.makeChannelCapability(channel, c)
                user.addCapability(c)
            ircdb.users.setUser(user)
            irc.replySuccess()
        add = wrap(add, ['op', 'otherUser', 'capability'])

        @internationalizeDocstring
        def remove(self, irc, msg, args, channel, user, capabilities):
            """[<channel>] <name|hostmask> <capability> [<capability> ...]

            If you have the #channel,op capability, this will take from the
            user currently identified as <name> (or the user to whom <hostmask>
            maps) the capability <capability> in the channel. <channel> is only
            necessary if the message isn't sent in the channel itself.
            """
            fail = []
            for c in capabilities.split():
                cap = ircdb.makeChannelCapability(channel, c)
                try:
                    user.removeCapability(cap)
                except KeyError:
                    fail.append(c)
            ircdb.users.setUser(user)
            if fail:
                s = 'capability'
                if len(fail) > 1:
                    s = utils.str.pluralize(s)
                irc.error(format(_('That user didn\'t have the %L %s.'), fail,
                          s), Raise=True)
            irc.replySuccess()
        remove = wrap(remove, ['op', 'otherUser', 'capability'])

        # XXX This needs to be fix0red to be like Owner.defaultcapability.  Or
        # something else.  This is a horrible interface.
        @internationalizeDocstring
        def setdefault(self, irc, msg, args, channel, v):
            """[<channel>] {True|False}

            If you have the #channel,op capability, this will set the default
            response to non-power-related (that is, not {op, halfop, voice})
            capabilities to be the value you give. <channel> is only necessary
            if the message isn't sent in the channel itself.
            """
            c = ircdb.channels.getChannel(channel)
            if v:
                c.setDefaultCapability(True)
            else:
                c.setDefaultCapability(False)
            ircdb.channels.setChannel(channel, c)
            irc.replySuccess()
        setdefault = wrap(setdefault, ['op', 'boolean'])

        @internationalizeDocstring
        def set(self, irc, msg, args, channel, capabilities):
            """[<channel>] <capability> [<capability> ...]

            If you have the #channel,op capability, this will add the channel
            capability <capability> for all users in the channel. <channel> is
            only necessary if the message isn't sent in the channel itself.
            """
            chan = ircdb.channels.getChannel(channel)
            for c in capabilities:
                chan.addCapability(c)
            ircdb.channels.setChannel(channel, chan)
            irc.replySuccess()
        set = wrap(set, ['op', many('capability')])

        @internationalizeDocstring
        def unset(self, irc, msg, args, channel, capabilities):
            """[<channel>] <capability> [<capability> ...]

            If you have the #channel,op capability, this will unset the channel
            capability <capability> so each user's specific capability or the
            channel default capability will take precedence. <channel> is only
            necessary if the message isn't sent in the channel itself.
            """
            chan = ircdb.channels.getChannel(channel)
            fail = []
            for c in capabilities:
                try:
                    chan.removeCapability(c)
                except KeyError:
                    fail.append(c)
            ircdb.channels.setChannel(channel, chan)
            if fail:
                s = _('capability')
                if len(fail) > 1:
                    s = utils.str.pluralize(s)
                irc.error(format(_('I do not know about the %L %s.'), fail, s),
                          Raise=True)
            irc.replySuccess()
        unset = wrap(unset, ['op', many('capability')])

        @internationalizeDocstring
        def list(self, irc, msg, args, channel):
            """[<channel>]

            Returns the capabilities present on the <channel>. <channel> is
            only necessary if the message isn't sent in the channel itself.
            """
            c = ircdb.channels.getChannel(channel)
            L = sorted(c.capabilities)
            irc.reply(' '.join(L))
        list = wrap(list, ['channel'])

    @internationalizeDocstring
    def disable(self, irc, msg, args, channel, plugin, command):
        """[<channel>] [<plugin>] [<command>]

        If you have the #channel,op capability, this will disable the <command>
        in <channel>.  If <plugin> is provided, <command> will be disabled only
        for that plugin.  If only <plugin> is provided, all commands in the
        given plugin will be disabled.  <channel> is only necessary if the
        message isn't sent in the channel itself.
        """
        chan = ircdb.channels.getChannel(channel)
        failMsg = ''
        if plugin:
            s = '-%s' % plugin.name()
            if command:
                if plugin.isCommand(command):
                    s = '-%s.%s' % (plugin.name(), command)
                else:
                    failMsg = format(_('The %s plugin does not have a command '
                                     'called %s.'), plugin.name(), command)
        elif command:
            # findCallbackForCommand
            if list(filter(None, irc.findCallbacksForArgs([command]))):
                s = '-%s' % command
            else:
                failMsg = format(_('No plugin or command named %s could be '
                                 'found.'), command)
        else:
            raise callbacks.ArgumentError
        if failMsg:
            irc.error(failMsg)
        else:
            chan.addCapability(s)
            ircdb.channels.setChannel(channel, chan)
            irc.replySuccess()
    disable = wrap(disable, ['op',
                             optional(('plugin', False)),
                             additional('commandName')])

    @internationalizeDocstring
    def enable(self, irc, msg, args, channel, plugin, command):
        """[<channel>] [<plugin>] [<command>]

        If you have the #channel,op capability, this will enable the <command>
        in <channel> if it has been disabled.  If <plugin> is provided,
        <command> will be enabled only for that plugin.  If only <plugin> is
        provided, all commands in the given plugin will be enabled.  <channel>
        is only necessary if the message isn't sent in the channel itself.
        """
        chan = ircdb.channels.getChannel(channel)
        failMsg = ''
        if plugin:
            s = '-%s' % plugin.name()
            if command:
                if plugin.isCommand(command):
                    s = '-%s.%s' % (plugin.name(), command)
                else:
                    failMsg = format(_('The %s plugin does not have a command '
                                     'called %s.'), plugin.name(), command)
        elif command:
            # findCallbackForCommand
            if list(filter(None, irc.findCallbacksForArgs([command]))):
                s = '-%s' % command
            else:
                failMsg = format(_('No plugin or command named %s could be '
                                 'found.'), command)
        else:
            raise callbacks.ArgumentError
        if failMsg:
            irc.error(failMsg)
        else:
            fail = []
            try:
                chan.removeCapability(s)
            except KeyError:
                fail.append(s)
            ircdb.channels.setChannel(channel, chan)
            if fail:
                irc.error(format(_('%s was not disabled.'), s[1:]))
            else:
                irc.replySuccess()
    enable = wrap(enable, ['op',
                           optional(('plugin', False)),
                           additional('commandName')])

    @internationalizeDocstring
    def nicks(self, irc, msg, args, channel, optlist):
        """[<channel>] [--count]

        Returns the nicks in <channel>.  <channel> is only necessary if the
        message isn't sent in the channel itself. Returns only the number of
        nicks if --count option is provided.
        """
        # Make sure we don't elicit information about private channels to
        # people or channels that shouldn't know
        if 's' in irc.state.channels[channel].modes and \
            msg.args[0] != channel and \
            (ircutils.isChannel(msg.args[0]) or \
             msg.nick not in irc.state.channels[channel].users):
            irc.error(_('You don\'t have access to that information.'),
                    Raise=True)
        L = list(irc.state.channels[channel].users)
        keys = [option for (option, arg) in optlist]
        if 'count' not in keys:
            utils.sortBy(str.lower, L)
            irc.reply(utils.str.commaAndify(L))
        else:
            irc.reply(str(len(L)))
    nicks = wrap(nicks, ['inChannel',
                        getopts({'count':''})])

    @internationalizeDocstring
    def alertOps(self, irc, channel, s, frm=None):
        """Internal message for notifying all the #channel,ops in a channel of
        a given situation."""
        capability = ircdb.makeChannelCapability(channel, 'op')
        s = format(_('Alert to all %s ops: %s'), channel, s)
        if frm is not None:
            s += format(_(' (from %s)'), frm)
        for nick in irc.state.channels[channel].users:
            hostmask = irc.state.nickToHostmask(nick)
            if ircdb.checkCapability(hostmask, capability):
                irc.reply(s, to=nick, private=True)

    @internationalizeDocstring
    def alert(self, irc, msg, args, channel, text):
        """[<channel>] <text>

        Sends <text> to all the users in <channel> who have the <channel>,op
        capability.
        """
        self.alertOps(irc, channel, text, frm=msg.nick)
    alert = wrap(alert, ['inChannel', 'text'])


Class = Channel

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# Copyright (c) 2009, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

import supybot.conf as conf
import supybot.ircdb as ircdb
import supybot.ircmsgs as ircmsgs

class ChannelTestCase(ChannelPluginTestCase):
    plugins = ('Channel', 'User')

    def setUp(self):
        super(ChannelTestCase, self).setUp()
        self.irc.state.channels[self.channel].addUser('foo')
        self.irc.state.channels[self.channel].addUser('bar')

    def testLobotomies(self):
        self.assertRegexp('lobotomy list', 'not.*any')

##     def testCapabilities(self):
##         self.prefix = 'foo!bar@baz'
##         self.irc.feedMsg(ircmsgs.privmsg(self.irc.nick, 'register foo bar',
##                                          prefix=self.prefix))
##         u = ircdb.users.getUser(0)
##         u.addCapability('%s.op' % self.channel)
##         ircdb.users.setUser(u)
##         self.assertNotError(' ')
##         self.assertResponse('user capabilities foo', '[]')
##         self.assertNotError('channel addcapability foo op')
##         self.assertRegexp('channel capabilities foo', 'op')
##         self.assertNotError('channel removecapability foo op')
##         self.assertResponse('user capabilities foo', '[]')

    def testCapabilities(self):
        self.assertNotError('channel capability list')
        self.assertNotError('channel capability set -foo')
        self.assertNotError('channel capability unset -foo')
        self.assertError('channel capability unset -foo')
        self.assertNotError('channel capability set -foo bar baz')
        self.assertRegexp('channel capability list', 'baz')
        self.assertNotError('channel capability unset -foo baz')
        self.assertError('channel capability unset baz')

    def testEnableDisable(self):
        self.assertNotRegexp('channel capability list', '-Channel')
        self.assertError('channel enable channel')
        self.assertNotError('channel disable channel')
        self.assertRegexp('channel capability list', '-Channel')
        self.assertNotError('channel enable channel')
        self.assertNotRegexp('channel capability list', '-Channel')
        self.assertNotError('channel disable channel nicks')
        self.assertRegexp('channel capability list', '-Channel.nicks')
        self.assertNotError('channel enable channel nicks')
        self.assertNotRegexp('channel capability list', '-Channel.nicks')
        self.assertNotRegexp('channel capability list', 'nicks')
        self.assertNotError('channel disable nicks')
        self.assertRegexp('channel capability list', 'nicks')
        self.assertNotError('channel enable nicks')
        self.assertError('channel disable invalidPlugin')
        self.assertError('channel disable channel invalidCommand')

    def testUnban(self):
        self.assertError('unban foo!bar@baz')
        self.irc.feedMsg(ircmsgs.op(self.channel, self.nick))
        m = self.getMsg('unban foo!bar@baz')
        self.assertEqual(m.command, 'MODE')
        self.assertEqual(m.args, (self.channel, '-b', 'foo!bar@baz'))
        self.assertNoResponse(' ', 2)

    def testErrorsWithoutOps(self):
        for s in 'op deop halfop dehalfop voice devoice kick invite'.split():
            self.assertError('%s foo' % s)
            self.irc.feedMsg(ircmsgs.op(self.channel, self.nick))
            self.assertNotError('%s foo' % s)
            self.irc.feedMsg(ircmsgs.deop(self.channel, self.nick))

    def testWontDeItself(self):
        for s in 'deop dehalfop devoice'.split():
            self.irc.feedMsg(ircmsgs.op(self.channel, self.nick))
            self.assertError('%s %s' % (s, self.nick))

    def testOp(self):
        self.assertError('op')
        self.irc.feedMsg(ircmsgs.op(self.channel, self.nick))
        self.assertNotError('op')
        m = self.getMsg('op foo')
        self.failUnless(m.command == 'MODE' and
                        m.args == (self.channel, '+o', 'foo'))
        m = self.getMsg('op foo bar')
        self.failUnless(m.command == 'MODE' and
                        m.args == (self.channel, '+o', 'foo'))
        m = self.irc.takeMsg()
        self.failUnless(m.command == 'MODE' and
                        m.args == (self.channel, '+o', 'bar'))
        self.irc.state.supported['MODES'] = 2
        m = self.getMsg('op foo bar')
        try:
            self.failUnless(m.command == 'MODE' and
                            m.args == (self.channel, '+oo', 'foo', 'bar'))
        finally:
            self.irc.state.supported['MODES'] = 1

    def testHalfOp(self):
        self.assertError('halfop')
        self.irc.feedMsg(ircmsgs.op(self.channel, self.nick))
        self.assertNotError('halfop')
        m = self.getMsg('halfop foo')
        self.failUnless(m.command == 'MODE' and
                        m.args == (self.channel, '+h', 'foo'))
        m = self.getMsg('halfop foo bar')
        self.failUnless(m.command == 'MODE' and
                        m.args == (self.channel, '+h', 'foo'))
        m = self.irc.takeMsg()
        self.failUnless(m.command == 'MODE' and
                        m.args == (self.channel, '+h', 'bar'))

    def testVoice(self):
        self.assertError('voice')
        self.irc.feedMsg(ircmsgs.op(self.channel, self.nick))
        self.assertNotError('voice')
        m = self.getMsg('voice foo')
        self.failUnless(m.command == 'MODE' and
                        m.args == (self.channel, '+v', 'foo'))
        m = self.getMsg('voice foo bar')
        self.failUnless(m.command == 'MODE' and
                        m.args == (self.channel, '+v', 'foo'))
        m = self.irc.takeMsg()
        self.failUnless(m.command == 'MODE' and
                        m.args == (self.channel, '+v', 'bar'))

    def assertKban(self, query, hostmask, **kwargs):
        m = self.getMsg(query, **kwargs)
        self.assertEqual(m, ircmsgs.ban(self.channel, hostmask))
        m = self.getMsg(' ')
        self.assertEqual(m.command, 'KICK')
    def assertBan(self, query, hostmask, **kwargs):
        m = self.getMsg(query, **kwargs)
        self.assertEqual(m, ircmsgs.ban(self.channel, hostmask))

    def testIban(self):
        self.irc.feedMsg(ircmsgs.join(self.channel,
                                      prefix='foobar!user@host.domain.tld'))
        self.assertError('iban foo!bar@baz')
        self.irc.feedMsg(ircmsgs.op(self.channel, self.irc.nick))
        self.assertBan('iban foo!bar@baz', 'foo!bar@baz')
        self.assertBan('iban foobar', 'foobar!user@host.domain.tld')

        conf.supybot.protocols.irc.strictRfc.setValue(True)
        self.assertError('iban $a:nyuszika7h')
        self.assertError('unban $a:nyuszika7h')
        conf.supybot.protocols.irc.strictRfc.setValue(False)
        self.assertBan('iban $a:nyuszika7h', '$a:nyuszika7h')
        self.assertNotError('unban $a:nyuszika7h')

##    def testKban(self):
##        self.irc.prefix = 'something!else@somehwere.else'
##        self.irc.nick = 'something'
##        self.irc.feedMsg(ircmsgs.join(self.channel,
##                                      prefix='foobar!user@host.domain.tld'))
##        self.assertError('kban foobar')
##        self.irc.feedMsg(ircmsgs.op(self.channel, self.irc.nick))
##        self.assertError('kban foobar -1')
##        self.assertKban('kban foobar', '*!*@*.domain.tld')
##        self.assertKban('kban --exact foobar', 'foobar!user@host.domain.tld')
##        self.assertKban('kban --host foobar', '*!*@host.domain.tld')
##        self.assertKban('kban --user foobar', '*!user@*')
##        self.assertKban('kban --nick foobar', 'foobar!*@*')
##        self.assertKban('kban --nick --user foobar', 'foobar!user@*')
##        self.assertKban('kban --nick --host foobar',
##                       'foobar!*@host.domain.tld')
##        self.assertKban('kban --user --host foobar', '*!user@host.domain.tld')
##        self.assertKban('kban --nick --user --host foobar',
##                       'foobar!user@host.domain.tld')
##        self.assertNotRegexp('kban adlkfajsdlfkjsd', 'KeyError')
##        self.assertNotRegexp('kban foobar time', 'ValueError')
##        self.assertError('kban %s' % self.irc.nick)

    def testBan(self):
        with conf.supybot.protocols.irc.banmask.context(['exact']):
            self.assertNotError('ban add foo!bar@baz')
            self.assertNotError('ban remove foo!bar@baz')
            orig = conf.supybot.protocols.irc.strictRfc()
            with conf.supybot.protocols.irc.strictRfc.context(True):
                # something wonky is going on here. irc.error (src/Channel.py|449)
                # is being called but the assert is failing
                self.assertError('ban add not!a.hostmask')
                self.assertNotRegexp('ban add not!a.hostmask', 'KeyError')
                self.assertError('ban add $a:nyuszika7h')
                self.assertError('ban remove $a:nyuszika7h')
                conf.supybot.protocols.irc.strictRfc.setValue(False)
                self.assertNotError('ban add $a:nyuszika7h')
                self.assertNotError('ban remove $a:nyuszika7h')

    def testIgnore(self):
        orig = conf.supybot.protocols.irc.banmask()
        def ignore(given, expect=None):
            if expect is None:
                expect = given
            self.assertNotError('channel ignore add %s' % given)
            self.assertResponse('channel ignore list', "'%s'" % expect)
            self.assertNotError('channel ignore remove %s' % expect)
            self.assertRegexp('channel ignore list', 'not currently')
        ignore('foo!bar@baz', '*!bar@baz')
        ignore('foo!*@*')
        with conf.supybot.protocols.irc.banmask.context(['exact']):
            ignore('foo!bar@baz')
            ignore('foo!*@*')
            self.assertError('ban add not!a.hostmask')

    def testNicks(self):
        self.assertResponse('channel nicks', 'bar, foo, and test')
        self.assertResponse('channel nicks --count', '3')
        
# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:


########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2005, Jeremiah Fincher
# Copyright (c) 2009, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('ChannelLogger')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('ChannelLogger', True)

ChannelLogger = conf.registerPlugin('ChannelLogger')
conf.registerChannelValue(ChannelLogger, 'enable',
    registry.Boolean(True, _("""Determines whether logging is enabled.""")))
conf.registerGlobalValue(ChannelLogger, 'flushImmediately',
    registry.Boolean(False, _("""Determines whether channel logfiles will be
    flushed anytime they're written to, rather than being buffered by the
    operating system.""")))
conf.registerChannelValue(ChannelLogger, 'showJoinParts',
    registry.Boolean(True, _("""Determines wether joins and parts are logged""")))
conf.registerChannelValue(ChannelLogger, 'stripFormatting',
    registry.Boolean(True, _("""Determines whether formatting characters (such
    as bolding, color, etc.) are removed when writing the logs to disk.""")))
conf.registerChannelValue(ChannelLogger, 'timestamp',
    registry.Boolean(True, _("""Determines whether the logs for this channel are
    timestamped with the timestamp in supybot.log.timestampFormat.""")))
conf.registerChannelValue(ChannelLogger, 'noLogPrefix',
    registry.String('[nolog]', _("""Determines what string a message should be
    prefixed with in order not to be logged.  If you don't want any such
    prefix, just set it to the empty string.""")))
conf.registerChannelValue(ChannelLogger, 'rotateLogs',
    registry.Boolean(False, _("""Determines whether the bot will automatically
    rotate the logs for this channel.  The bot will rotate logs when the
    timestamp for the log changes.  The timestamp is set according to
    the 'filenameTimestamp' configuration variable.""")))
conf.registerChannelValue(ChannelLogger, 'filenameTimestamp',
    registry.String('%Y-%m-%d', _("""Determines how to represent the timestamp
    used for the filename in rotated logs.  When this timestamp changes, the
    old logfiles will be closed and a new one started. The format characters
    for the timestamp are in the time.strftime docs at python.org.  In order
    for your logs to be rotated, you'll also have to enable
    supybot.plugins.ChannelLogger.rotateLogs.""")))

conf.registerGlobalValue(ChannelLogger, 'directories',
    registry.Boolean(True, _("""Determines whether the bot will partition its
    channel logs into separate directories based on different criteria.""")))
conf.registerGlobalValue(ChannelLogger.directories, 'network',
    registry.Boolean(True, _("""Determines whether the bot will use a network
    directory if using directories.""")))
conf.registerGlobalValue(ChannelLogger.directories, 'channel',
    registry.Boolean(True, _("""Determines whether the bot will use a channel
    directory if using directories.""")))
conf.registerGlobalValue(ChannelLogger.directories, 'timestamp',
    registry.Boolean(False, _("""Determines whether the bot will use a timestamp
    (determined by supybot.plugins.ChannelLogger.directories.timestamp.format)
    if using directories.""")))
conf.registerGlobalValue(ChannelLogger.directories.timestamp, 'format',
    registry.String('%B', _("""Determines what timestamp format will be used in
    the directory structure for channel logs if
    supybot.plugins.ChannelLogger.directories.timestamp is True.""")))

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2002-2004, Jeremiah Fincher
# Copyright (c) 2009-2010, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import os
import sys
import time
if sys.version_info[0] < 3:
    from io import open
from cStringIO import StringIO

import supybot.conf as conf
import supybot.world as world
import supybot.ircdb as ircdb
import supybot.irclib as irclib
import supybot.ircmsgs as ircmsgs
import supybot.ircutils as ircutils
import supybot.registry as registry
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('ChannelLogger')

class FakeLog(object):
    def flush(self):
        return
    def close(self):
        return
    def write(self, s):
        return

class ChannelLogger(callbacks.Plugin):
    noIgnore = True
    def __init__(self, irc):
        self.__parent = super(ChannelLogger, self)
        self.__parent.__init__(irc)
        self.lastMsgs = {}
        self.lastStates = {}
        self.logs = {}
        self.flusher = self.flush
        world.flushers.append(self.flusher)

    def die(self):
        for log in self._logs():
            log.close()
        world.flushers = [x for x in world.flushers if x is not self.flusher]

    def __call__(self, irc, msg):
        try:
            # I don't know why I put this in, but it doesn't work, because it
            # doesn't call doNick or doQuit.
            # if msg.args and irc.isChannel(msg.args[0]):
            self.__parent.__call__(irc, msg)
            if irc in self.lastMsgs:
                if irc not in self.lastStates:
                    self.lastStates[irc] = irc.state.copy()
                self.lastStates[irc].addMsg(irc, self.lastMsgs[irc])
        finally:
            # We must make sure this always gets updated.
            self.lastMsgs[irc] = msg

    def reset(self):
        for log in self._logs():
            log.close()
        self.logs.clear()
        self.lastMsgs.clear()
        self.lastStates.clear()

    def _logs(self):
        for logs in self.logs.itervalues():
            for log in logs.itervalues():
                yield log

    def flush(self):
        self.checkLogNames()
        for log in self._logs():
            try:
                log.flush()
            except ValueError as e:
                if e.args[0] != 'I/O operation on a closed file':
                    self.log.exception('Odd exception:')

    def logNameTimestamp(self, channel):
        format = self.registryValue('filenameTimestamp', channel)
        return time.strftime(format)

    def getLogName(self, channel):
        if self.registryValue('rotateLogs', channel):
            return '%s.%s.log' % (channel, self.logNameTimestamp(channel))
        else:
            return '%s.log' % channel

    def getLogDir(self, irc, channel):
        logDir = conf.supybot.directories.log.dirize(self.name())
        if self.registryValue('directories'):
            if self.registryValue('directories.network'):
                logDir = os.path.join(logDir,  irc.network)
            if self.registryValue('directories.channel'):
                logDir = os.path.join(logDir, channel)
            if self.registryValue('directories.timestamp'):
                format = self.registryValue('directories.timestamp.format')
                timeDir =time.strftime(format)
                logDir = os.path.join(logDir, timeDir)
        if not os.path.exists(logDir):
            os.makedirs(logDir)
        return logDir

    def checkLogNames(self):
        for (irc, logs) in self.logs.items():
            for (channel, log) in logs.items():
                if self.registryValue('rotateLogs', channel):
                    name = self.getLogName(channel)
                    if name != os.path.basename(log.name):
                        log.close()
                        del logs[channel]

    def getLog(self, irc, channel):
        self.checkLogNames()
        try:
            logs = self.logs[irc]
        except KeyError:
            logs = ircutils.IrcDict()
            self.logs[irc] = logs
        if channel in logs:
            return logs[channel]
        else:
            try:
                name = self.getLogName(channel)
                logDir = self.getLogDir(irc, channel)
                log = open(os.path.join(logDir, name), encoding='utf-8', mode='a')
                logs[channel] = log
                return log
            except IOError:
                self.log.exception('Error opening log:')
                return FakeLog()

    def timestamp(self, log):
        format = conf.supybot.log.timestampFormat()
        if format:
            string = time.strftime(format) + '  '
            if sys.version_info[0] < 3:
                string = string.decode('utf8', 'ignore')
            log.write(string)

    def normalizeChannel(self, irc, channel):
        return ircutils.toLower(channel)

    def doLog(self, irc, channel, s, *args):
        if not self.registryValue('enable', channel):
            return
        s = format(s, *args)
        channel = self.normalizeChannel(irc, channel)
        log = self.getLog(irc, channel)
        if self.registryValue('timestamp', channel):
            self.timestamp(log)
        if self.registryValue('stripFormatting', channel):
            s = ircutils.stripFormatting(s)
        if sys.version_info[0] < 3:
            s = s.decode('utf8', 'ignore')
        log.write(s)
        if self.registryValue('flushImmediately'):
            log.flush()

    def doPrivmsg(self, irc, msg):
        (recipients, text) = msg.args
        for channel in recipients.split(','):
            if irc.isChannel(channel):
                noLogPrefix = self.registryValue('noLogPrefix', channel)
                cap = ircdb.makeChannelCapability(channel, 'logChannelMessages')
                try:
                    logChannelMessages = ircdb.checkCapability(msg.prefix, cap,
                        ignoreOwner=True)
                except KeyError:
                    logChannelMessages = True
                nick = msg.nick or irc.nick
                if msg.tagged('ChannelLogger__relayed'):
                    (nick, text) = text.split(' ', 1)
                    nick = nick[1:-1]
                    msg.args = (recipients, text)
                if (noLogPrefix and text.startswith(noLogPrefix)) or \
                        not logChannelMessages:
                    text = '-= THIS MESSAGE NOT LOGGED =-'
                if ircmsgs.isAction(msg):
                    self.doLog(irc, channel,
                               '* %s %s\n', nick, ircmsgs.unAction(msg))
                else:
                    self.doLog(irc, channel, '<%s> %s\n', nick, text)

    def doNotice(self, irc, msg):
        (recipients, text) = msg.args
        for channel in recipients.split(','):
            if irc.isChannel(channel):
                self.doLog(irc, channel, '-%s- %s\n', msg.nick, text)

    def doNick(self, irc, msg):
        oldNick = msg.nick
        newNick = msg.args[0]
        for (channel, c) in irc.state.channels.items():
            if newNick in c.users:
                self.doLog(irc, channel,
                           '*** %s is now known as %s\n', oldNick, newNick)
    def doJoin(self, irc, msg):
        for channel in msg.args[0].split(','):
            if(self.registryValue('showJoinParts', channel)):
                self.doLog(irc, channel,
                           '*** %s <%s> has joined %s\n',
                           msg.nick, msg.prefix, channel)

    def doKick(self, irc, msg):
        if len(msg.args) == 3:
            (channel, target, kickmsg) = msg.args
        else:
            (channel, target) = msg.args
            kickmsg = ''
        if kickmsg:
            self.doLog(irc, channel,
                       '*** %s was kicked by %s (%s)\n',
                       target, msg.nick, kickmsg)
        else:
            self.doLog(irc, channel,
                       '*** %s was kicked by %s\n', target, msg.nick)

    def doPart(self, irc, msg):
        if len(msg.args) > 1:
            reason = " (%s)" % msg.args[1]
        else:
            reason = ""
        for channel in msg.args[0].split(','):
            if(self.registryValue('showJoinParts', channel)):
                self.doLog(irc, channel,
                           '*** %s <%s> has left %s%s\n',
                           msg.nick, msg.prefix, channel, reason)

    def doMode(self, irc, msg):
        channel = msg.args[0]
        if irc.isChannel(channel) and msg.args[1:]:
            self.doLog(irc, channel,
                       '*** %s sets mode: %s %s\n',
                       msg.nick or msg.prefix, msg.args[1],
                        ' '.join(msg.args[2:]))

    def doTopic(self, irc, msg):
        if len(msg.args) == 1:
            return # It's an empty TOPIC just to get the current topic.
        channel = msg.args[0]
        self.doLog(irc, channel,
                   '*** %s changes topic to "%s"\n', msg.nick, msg.args[1])

    def doQuit(self, irc, msg):
        if len(msg.args) == 1:
            reason = " (%s)" % msg.args[0]
        else:
            reason = ""
        if not isinstance(irc, irclib.Irc):
            irc = irc.getRealIrc()
        if irc not in self.lastStates:
            return
        for (channel, chan) in self.lastStates[irc].channels.items():
            if(self.registryValue('showJoinParts', channel)):
                if msg.nick in chan.users:
                    self.doLog(irc, channel,
                               '*** %s <%s> has quit IRC%s\n',
                               msg.nick, msg.prefix, reason)

    def outFilter(self, irc, msg):
        # Gotta catch my own messages *somehow* :)
        # Let's try this little trick...
        if msg.command in ('PRIVMSG', 'NOTICE'):
            # Other messages should be sent back to us.
            m = ircmsgs.IrcMsg(msg=msg, prefix=irc.prefix)
            if msg.tagged('relayedMsg'):
                m.tag('ChannelLogger__relayed')
            self(irc, m)
        return msg


Class = ChannelLogger
# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

class ChannelLoggerTestCase(PluginTestCase):
    plugins = ('ChannelLogger',)


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import re

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring

_ = PluginInternationalization('ChannelStats')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('ChannelStats', True)

class Smileys(registry.Value):
    def set(self, s):
        L = s.split()
        self.setValue(L)

    def setValue(self, v):
        self.s = ' '.join(v)
        self.value = re.compile('|'.join(map(re.escape, v)))

    def __str__(self):
        return self.s

ChannelStats = conf.registerPlugin('ChannelStats')
conf.registerChannelValue(ChannelStats, 'selfStats',
    registry.Boolean(True, _("""Determines whether the bot will keep channel
    statistics on itself, possibly skewing the channel stats (especially in
    cases where the bot is relaying between channels on a network).""")))
conf.registerChannelValue(ChannelStats, 'smileys',
    Smileys(':) ;) ;] :-) :-D :D :P :p (= =)'.split(), _("""Determines what
    words (i.e., pieces of text with no spaces in them) are considered
    'smileys' for the purposes of stats-keeping.""")))
conf.registerChannelValue(ChannelStats, 'frowns',
    Smileys(':| :-/ :-\\ :\\ :/ :( :-( :\'('.split(), _("""Determines what words
    (i.e., pieces of text with no spaces in them) are considered 'frowns' for
    the purposes of stats-keeping.""")))

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2002-2004, Jeremiah Fincher
# Copyright (c) 2009-2010, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import re
import math
import types

import supybot.log as log
import supybot.conf as conf
from supybot.i18n import PluginInternationalization, internationalizeDocstring
import supybot.utils as utils
import supybot.world as world
import supybot.ircdb as ircdb
from supybot.commands import *
import supybot.irclib as irclib
import supybot.ircmsgs as ircmsgs
import supybot.plugins as plugins
import supybot.ircutils as ircutils
import supybot.callbacks as callbacks

_ = PluginInternationalization('ChannelStats')

class ChannelStat(irclib.IrcCommandDispatcher):
    _values = ['actions', 'chars', 'frowns', 'joins', 'kicks','modes',
               'msgs', 'parts', 'quits', 'smileys', 'topics', 'words', 'users']
    def __init__(self, actions=0, chars=0, frowns=0, joins=0, kicks=0, modes=0,
                 msgs=0, parts=0, quits=0, smileys=0, topics=0, words=0,
                 users=0):
        self.actions = actions
        self.chars = chars
        self.frowns = frowns
        self.joins = joins
        self.kicks = kicks
        self.modes = modes
        self.msgs = msgs
        self.parts = parts
        self.quits = quits
        self.smileys = smileys
        self.topics = topics
        self.words = words
        self.users = users

    def values(self):
        return [getattr(self, s) for s in self._values]

    def addMsg(self, msg):
        self.msgs += 1
        method = self.dispatchCommand(msg.command)
        if method is not None:
            method(msg)

    def doPayload(self, channel, payload):
        channel = plugins.getChannel(channel)
        self.chars += len(payload)
        self.words += len(payload.split())
        fRe = conf.supybot.plugins.ChannelStats.get('frowns').get(channel)()
        sRe =conf.supybot.plugins.ChannelStats.get('smileys').get(channel)()
        self.frowns += len(fRe.findall(payload))
        self.smileys += len(sRe.findall(payload))

    def doPrivmsg(self, msg):
        isAction = ircmsgs.isAction(msg)
        if ircmsgs.isCtcp(msg) and not isAction:
            return
        self.doPayload(*msg.args)
        if isAction:
            self.actions += 1

    def doTopic(self, msg):
        self.doPayload(*msg.args)
        self.topics += 1

    def doKick(self, msg):
        self.kicks += 1

    def doPart(self, msg):
        if len(msg.args) == 2:
            self.doPayload(*msg.args)
        self.parts += 1

    def doJoin(self, msg):
        if len(msg.args) == 2:
            self.doPayload(*msg.args)
        self.joins += 1
        # Handle max-users in the plugin since we need an irc object

    def doMode(self, msg):
        self.modes += 1

    # doQuit is handled by the plugin.


class UserStat(ChannelStat):
    _values = ['kicked'] + ChannelStat._values
    def __init__(self, kicked=0, *args):
        ChannelStat.__init__(self, *args)
        self.kicked = kicked

    def doKick(self, msg):
        self.doPayload(msg.args[0], msg.args[2])
        self.kicks += 1

class StatsDB(plugins.ChannelUserDB):
    def __init__(self, *args, **kwargs):
        plugins.ChannelUserDB.__init__(self, *args, **kwargs)

    def serialize(self, v):
        return v.values()

    def deserialize(self, channel, id, L):
        L = list(map(int, L))
        if id == 'channelStats':
            return ChannelStat(*L)
        else:
            return UserStat(*L)

    def addMsg(self, msg, id=None):
        if ircutils.isChannel(msg.args[0]):
            channel = plugins.getChannel(msg.args[0])
            if (channel, 'channelStats') not in self:
                self[channel, 'channelStats'] = ChannelStat()
            self[channel, 'channelStats'].addMsg(msg)
            try:
                if id is None:
                    id = ircdb.users.getUserId(msg.prefix)
            except KeyError:
                return
            if (channel, id) not in self:
                self[channel, id] = UserStat()
            self[channel, id].addMsg(msg)

    def getChannelStats(self, channel):
        return self[channel, 'channelStats']

    def getUserStats(self, channel, id):
        return self[channel, id]

filename = conf.supybot.directories.data.dirize('ChannelStats.db')
class ChannelStats(callbacks.Plugin):
    noIgnore = True
    def __init__(self, irc):
        self.__parent = super(ChannelStats, self)
        self.__parent.__init__(irc)
        self.lastmsg = None
        self.laststate = None
        self.outFiltering = False
        self.db = StatsDB(filename)
        self._flush = self.db.flush
        world.flushers.append(self._flush)

    def die(self):
        world.flushers.remove(self._flush)
        self.db.close()
        self.__parent.die()

    def __call__(self, irc, msg):
        try:
            if self.lastmsg:
                self.laststate.addMsg(irc, self.lastmsg)
            else:
                self.laststate = irc.state.copy()
        finally:
            self.lastmsg = msg
        self.db.addMsg(msg)
        super(ChannelStats, self).__call__(irc, msg)

    def outFilter(self, irc, msg):
        if msg.command == 'PRIVMSG':
            if ircutils.isChannel(msg.args[0]):
                if self.registryValue('selfStats', msg.args[0]):
                    try:
                        self.outFiltering = True
                        self.db.addMsg(msg, 0)
                    finally:
                        self.outFiltering = False
        return msg

    def _setUsers(self, irc, channel):
        if (channel, 'channelStats') not in self.db:
            self.db[channel, 'channelStats'] = ChannelStat()
        oldUsers = self.db[channel, 'channelStats'].users
        newUsers = len(irc.state.channels[channel].users)
        self.db[channel, 'channelStats'].users = max(oldUsers, newUsers)

    def doJoin(self, irc, msg):
        self._setUsers(irc, msg.args[0])

    def do366(self, irc, msg):
        self._setUsers(irc, msg.args[1])

    def doQuit(self, irc, msg):
        try:
            id = ircdb.users.getUserId(msg.prefix)
        except KeyError:
            id = None
        for (channel, c) in self.laststate.channels.iteritems():
            if msg.nick in c.users:
                if (channel, 'channelStats') not in self.db:
                    self.db[channel, 'channelStats'] = ChannelStat()
                self.db[channel, 'channelStats'].quits += 1
                if id is not None:
                    if (channel, id) not in self.db:
                        self.db[channel, id] = UserStat()
                    self.db[channel, id].quits += 1

    def doKick(self, irc, msg):
        (channel, nick, _) = msg.args
        hostmask = irc.state.nickToHostmask(nick)
        try:
            id = ircdb.users.getUserId(hostmask)
        except KeyError:
            return
        if (channel, id) not in self.db:
            self.db[channel, id] = UserStat()
        self.db.channels[channel][id].kicked += 1

    @internationalizeDocstring
    def stats(self, irc, msg, args, channel, name):
        """[<channel>] [<name>]

        Returns the statistics for <name> on <channel>.  <channel> is only
        necessary if the message isn't sent on the channel itself.  If <name>
        isn't given, it defaults to the user sending the command.
        """
        if msg.nick not in irc.state.channels[channel].users:
            irc.error(format('You must be in %s to use this command.', channel))
            return
        if name and ircutils.strEqual(name, irc.nick):
            id = 0
        elif not name:
            try:
                id = ircdb.users.getUserId(msg.prefix)
                name = ircdb.users.getUser(id).name
            except KeyError:
                irc.error(_('I couldn\'t find you in my user database.'))
                return
        elif not ircdb.users.hasUser(name):
            try:
                hostmask = irc.state.nickToHostmask(name)
                id = ircdb.users.getUserId(hostmask)
            except KeyError:
                irc.errorNoUser()
                return
        else:
            id = ircdb.users.getUserId(name)
        try:
            stats = self.db.getUserStats(channel, id)
            s = format(_('%s has sent %n; a total of %n, %n, '
                       '%n, and %n; %s of those messages %s. '
                       '%s has joined %n, parted %n, quit %n, '
                       'kicked someone %n, been kicked %n, '
                       'changed the topic %n, and changed the '
                       'mode %n.'),
                       name, (stats.msgs, 'message'),
                       (stats.chars, _('character')),
                       (stats.words, _('word')),
                       (stats.smileys, _('smiley')),
                       (stats.frowns, _('frown')),
                       stats.actions,
                       stats.actions == 1 and _('was an ACTION')
                                           or _('were ACTIONs'),
                       name,
                       (stats.joins, _('time')),
                       (stats.parts, _('time')),
                       (stats.quits, _('time')),
                       (stats.kicks, _('time')),
                       (stats.kicked, _('time')),
                       (stats.topics, _('time')),
                       (stats.modes, _('time')))
            irc.reply(s)
        except KeyError:
            irc.error(format(_('I have no stats for that %s in %s.'),
                             name, channel))
    stats = wrap(stats, ['channeldb', additional('something')])

    _calc_match_forbidden_chars = re.compile('[_[\]]')
    _env = {'__builtins__': types.ModuleType('__builtins__')}
    _env.update(math.__dict__)
    @internationalizeDocstring
    def rank(self, irc, msg, args, channel, expr):
        """[<channel>] <stat expression>

        Returns the ranking of users according to the given stat expression.
        Valid variables in the stat expression include 'msgs', 'chars',
        'words', 'smileys', 'frowns', 'actions', 'joins', 'parts', 'quits',
        'kicks', 'kicked', 'topics', and 'modes'.  Any simple mathematical
        expression involving those variables is permitted.
        """
        if msg.nick not in irc.state.channels[channel].users:
            irc.error(format('You must be in %s to use this command.', channel))
            return
        # XXX I could do this the right way, and abstract out a safe eval,
        #     or I could just copy/paste from the Math plugin.
        if self._calc_match_forbidden_chars.match(expr):
            irc.error(_('There\'s really no reason why you should have '
                      'underscores or brackets in your mathematical '
                      'expression.  Please remove them.'), Raise=True)
        if 'lambda' in expr:
            irc.error(_('You can\'t use lambda in this command.'), Raise=True)
        expr = expr.lower()
        users = []
        for ((c, id), stats) in self.db.items():
            if ircutils.strEqual(c, channel) and \
               (id == 0 or ircdb.users.hasUser(id)):
                e = self._env.copy()
                for attr in stats._values:
                    e[attr] = float(getattr(stats, attr))
                try:
                    v = eval(expr, e, e)
                except ZeroDivisionError:
                    v = float('inf')
                except NameError as e:
                    irc.errorInvalid(_('stat variable'), str(e).split()[1])
                except Exception as e:
                    irc.error(utils.exnToString(e), Raise=True)
                if id == 0:
                    users.append((v, irc.nick))
                else:
                    users.append((v, ircdb.users.getUser(id).name))
        users.sort()
        users.reverse()
        s = utils.str.commaAndify(['#%s %s (%.3g)' % (i+1, u, v)
                                   for (i, (v, u)) in enumerate(users)])
        irc.reply(s)
    rank = wrap(rank, ['channeldb', 'text'])

    @internationalizeDocstring
    def channelstats(self, irc, msg, args, channel):
        """[<channel>]

        Returns the statistics for <channel>.  <channel> is only necessary if
        the message isn't sent on the channel itself.
        """
        if channel not in irc.state.channels:
            irc.error(_('I am not in %s.') % channel, Raise=True)
        elif msg.nick not in irc.state.channels[channel].users:
            irc.error(_('You must be in %s to use this command.') % channel,
                    Raise=True)
        try:
            channeldb = conf.supybot.databases.plugins.channelSpecific. \
                    getChannelLink(channel)
            stats = self.db.getChannelStats(channeldb)
            curUsers = len(irc.state.channels[channel].users)
            s = format(_('On %s there %h been %i messages, containing %i '
                       'characters, %n, %n, and %n; '
                       '%i of those messages %s.  There have been '
                       '%n, %n, %n, %n, %n, and %n.  There %b currently %n '
                       'and the channel has peaked at %n.'),
                       channel, stats.msgs, stats.msgs, stats.chars,
                       (stats.words, _('word')),
                       (stats.smileys, _('smiley')),
                       (stats.frowns, _('frown')),
                       stats.actions, stats.actions == 1 and _('was an ACTION')
                                                          or _('were ACTIONs'),
                       (stats.joins, _('join')),
                       (stats.parts, _('part')),
                       (stats.quits, _('quit')),
                       (stats.kicks, _('kick')),
                       (stats.modes, _('mode'), _('change')),
                       (stats.topics, _('topic'), _('change')),
                       curUsers,
                       (curUsers, _('user')),
                       (stats.users, _('user')))
            irc.reply(s)
        except KeyError:
            irc.error(format(_('I\'ve never been on %s.'), channel))
    channelstats = wrap(channelstats, ['channel'])


Class = ChannelStats

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2002-2004, Jeremiah Fincher
# Copyright (c) 2010, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

import supybot.ircdb as ircdb

class ChannelStatsTestCase(ChannelPluginTestCase):
    plugins = ('ChannelStats', 'User')
    def setUp(self):
        ChannelPluginTestCase.setUp(self)
        self.prefix = 'foo!bar@baz'
        self.nick = 'foo'
        self.irc.feedMsg(ircmsgs.privmsg(self.irc.nick,
                                         'register foo bar',
                                         prefix=self.prefix))
        _ = self.irc.takeMsg()
        chanop = ircdb.makeChannelCapability(self.channel, 'op')
        ircdb.users.getUser(self.nick).addCapability(chanop)

    def test(self):
        self.irc.feedMsg(ircmsgs.join(self.channel, prefix=self.prefix))
        self.assertNotError('channelstats')
        self.assertNotError('channelstats')
        self.assertNotError('channelstats')

    def testStats(self):
        self.assertError('channelstats stats %s' % self.nick)
        self.irc.feedMsg(ircmsgs.join(self.channel, prefix=self.prefix))
        self.assertNotError('channelstats stats %s' % self.nick)
        self.assertNotError('channelstats stats %s' % self.nick.upper())
        self.assertNotError('channelstats stats')
        self.assertRegexp('channelstats stats', self.nick)

    def testSelfStats(self):
        self.irc.feedMsg(ircmsgs.join(self.channel, prefix=self.prefix))
        self.assertError('channelstats stats %s' % self.irc.nick)
        self.assertNotError('channelstats stats %s' % self.irc.nick)
        self.assertNotError('channelstats stats %s' % self.irc.nick)
        self.assertNotError('channelstats stats %s' % self.irc.nick.upper())
        self.assertRegexp('channelstats rank chars', self.irc.nick)
        u = ircdb.users.getUser(self.prefix)
        u.addCapability(ircdb.makeChannelCapability(self.channel, 'op'))
        ircdb.users.setUser(u)
        try:
            conf.supybot.plugins.ChannelStats.selfStats.setValue(False)
            m1 = self.getMsg('channelstats stats %s' % self.irc.nick)
            m2 = self.getMsg('channelstats stats %s' % self.irc.nick)
            self.assertEqual(m1.args[1], m2.args[1])
        finally:
            conf.supybot.plugins.ChannelStats.selfStats.setValue(True)

    def testNoKeyErrorStats(self):
        self.irc.feedMsg(ircmsgs.join(self.channel, prefix=self.prefix))
        self.assertNotRegexp('stats sweede', 'KeyError')

    def testRank(self):
        self.irc.feedMsg(ircmsgs.join(self.channel, prefix=self.prefix))
        self.assertError('channelstats stats %s' % self.irc.nick)
        self.assertNotError('channelstats stats %s' % self.irc.nick)
        self.assertNotError('channelstats stats %s' % self.irc.nick)
        self.assertNotError('channelstats stats %s' % self.irc.nick.upper())
        self.assertNotError('channelstats stats %s' % self.nick)
        self.assertNotError('channelstats stats %s' % self.nick.upper())
        self.assertNotError('channelstats stats')
        self.assertNotError('channelstats rank chars / msgs')
        self.assertNotError('channelstats rank kicks/kicked') # Tests inf
        self.assertNotError('channelstats rank log(msgs)')


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:


########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2010, Daniel Folkinshteyn
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

###

import supybot.conf as conf
import supybot.registry as registry

try:
    from supybot.i18n import PluginInternationalization
    from supybot.i18n import internationalizeDocstring
    _ = PluginInternationalization('Conditional')
except:
    # This are useless functions that's allow to run the plugin on a bot
    # without the i18n plugin
    _ = lambda x:x
    internationalizeDocstring = lambda x:x

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Conditional', True)


Conditional = conf.registerPlugin('Conditional')
# This is where your configuration variables (if any) should go.  For example:
# conf.registerGlobalValue(Conditional, 'someConfigVariableName',
#     registry.Boolean(False, """Help for someConfigVariableName."""))


# vim:set shiftwidth=4 tabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2010, Daniel Folkinshteyn
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

###

import supybot.utils as utils
from supybot.commands import *
import supybot.plugins as plugins
import supybot.ircutils as ircutils
import supybot.callbacks as callbacks

import re

try:
    from supybot.i18n import PluginInternationalization
    from supybot.i18n import internationalizeDocstring
    _ = PluginInternationalization('Conditional')
except:
    # This are useless functions that's allow to run the plugin on a bot
    # without the i18n plugin
    _ = lambda x:x
    internationalizeDocstring = lambda x:x

if isinstance(__builtins__, dict):
    _any = __builtins__['any']
    _all = __builtins__['all']
else:
    _any = __builtins__.any
    _all = __builtins__.all

class Conditional(callbacks.Plugin):
    """Add the help for "@plugin help Conditional" here
    This should describe *how* to use this plugin."""
    threaded = True
    def __init__(self, irc):
        callbacks.Plugin.__init__(self, irc)

    def _runCommandFunction(self, irc, msg, command):
        """Run a command from message, as if command was sent over IRC."""
        tokens = callbacks.tokenize(command)
        try:
            self.Proxy(irc.irc, msg, tokens)
        except Exception as e:
            self.log.exception('Uncaught exception in requested function:')

    @internationalizeDocstring
    def cif(self, irc, msg, args, condition, ifcommand, elsecommand):
        """<condition> <ifcommand> <elsecommand>

        Runs <ifcommand> if <condition> evaluates to true, runs <elsecommand>
        if it evaluates to false.

        Use other logical operators defined in this plugin and command nesting
        to your advantage here.
        """
        if condition:
            self._runCommandFunction(irc, msg, ifcommand)
        else:
            self._runCommandFunction(irc, msg, elsecommand)
        irc.noReply()
    cif = wrap(cif, ['boolean', 'something', 'something'])

    @internationalizeDocstring
    def cand(self, irc, msg, args, conds):
        """<cond1> [<cond2> ... <condN>]

        Returns true if all conditions supplied evaluate to true.
        """
        if _all(conds):
            irc.reply("true")
        else:
            irc.reply("false")
    cand = wrap(cand, [many('boolean'),])

    @internationalizeDocstring
    def cor(self, irc, msg, args, conds):
        """<cond1> [<cond2> ... <condN>]

        Returns true if any one of conditions supplied evaluates to true.
        """
        if _any(conds):
            irc.reply("true")
        else:
            irc.reply("false")
    cor = wrap(cor, [many('boolean'),])

    @internationalizeDocstring
    def cxor(self, irc, msg, args, conds):
        """<cond1> [<cond2> ... <condN>]

        Returns true if only one of conditions supplied evaluates to true.
        """
        if sum(conds) == 1:
            irc.reply("true")
        else:
            irc.reply("false")
    cxor = wrap(cxor, [many('boolean'),])

    @internationalizeDocstring
    def ceq(self, irc, msg, args, item1, item2):
        """<item1> <item2>

        Does a string comparison on <item1> and <item2>.
        Returns true if they are equal.
        """
        if item1 == item2:
            irc.reply('true')
        else:
            irc.reply('false')
    ceq = wrap(ceq, ['anything', 'anything'])

    @internationalizeDocstring
    def ne(self, irc, msg, args, item1, item2):
        """<item1> <item2>

        Does a string comparison on <item1> and <item2>.
        Returns true if they are not equal.
        """
        if item1 != item2:
            irc.reply('true')
        else:
            irc.reply('false')
    ne = wrap(ne, ['anything', 'anything'])

    @internationalizeDocstring
    def gt(self, irc, msg, args, item1, item2):
        """<item1> <item2>

        Does a string comparison on <item1> and <item2>.
        Returns true if <item1> is greater than <item2>.
        """
        if item1 > item2:
            irc.reply('true')
        else:
            irc.reply('false')
    gt = wrap(gt, ['anything', 'anything'])

    @internationalizeDocstring
    def ge(self, irc, msg, args, item1, item2):
        """<item1> <item2>

        Does a string comparison on <item1> and <item2>.
        Returns true if <item1> is greater than or equal to <item2>.
        """
        if item1 >= item2:
            irc.reply('true')
        else:
            irc.reply('false')
    ge = wrap(ge, ['anything', 'anything'])

    @internationalizeDocstring
    def lt(self, irc, msg, args, item1, item2):
        """<item1> <item2>

        Does a string comparison on <item1> and <item2>.
        Returns true if <item1> is less than <item2>.
        """
        if item1 < item2:
            irc.reply('true')
        else:
            irc.reply('false')
    lt = wrap(lt, ['anything', 'anything'])

    @internationalizeDocstring
    def le(self, irc, msg, args, item1, item2):
        """<item1> <item2>

        Does a string comparison on <item1> and <item2>.
        Returns true if <item1> is less than or equal to <item2>.
        """
        if item1 <= item2:
            irc.reply('true')
        else:
            irc.reply('false')
    le = wrap(le, ['anything', 'anything'])

    @internationalizeDocstring
    def match(self, irc, msg, args, optlist, item1, item2):
        """[--case-insensitive] <item1> <item2>

        Determines if <item1> is a substring of <item2>.
        Returns true if <item1> is contained in <item2>.

        Will only match case if --case-insensitive is not given.
        """
        optlist = dict(optlist)
        if 'case-insensitive' in optlist:
            item1 = item1.lower()
            item2 = item2.lower()
        if item2.find(item1) != -1:
            irc.reply('true')
        else:
            irc.reply('false')
    match = wrap(match, [getopts({'case-insensitive': ''}),
                         'something', 'something'])

    @internationalizeDocstring
    def nceq(self, irc, msg, args, item1, item2):
        """<item1> <item2>

        Does a numeric comparison on <item1> and <item2>.
        Returns true if they are equal.
        """
        if item1 == item2:
            irc.reply('true')
        else:
            irc.reply('false')
    nceq = wrap(nceq, ['float', 'float'])

    @internationalizeDocstring
    def nne(self, irc, msg, args, item1, item2):
        """<item1> <item2>

        Does a numeric comparison on <item1> and <item2>.
        Returns true if they are not equal.
        """
        if item1 != item2:
            irc.reply('true')
        else:
            irc.reply('false')
    nne = wrap(nne, ['float', 'float'])

    @internationalizeDocstring
    def ngt(self, irc, msg, args, item1, item2):
        """<item1> <item2>

        Does a numeric comparison on <item1> and <item2>.
        Returns true if <item1> is greater than <item2>.
        """
        if item1 > item2:
            irc.reply('true')
        else:
            irc.reply('false')
    ngt = wrap(ngt, ['float', 'float'])

    @internationalizeDocstring
    def nge(self, irc, msg, args, item1, item2):
        """<item1> <item2>

        Does a numeric comparison on <item1> and <item2>.
        Returns true if <item1> is greater than or equal to <item2>.
        """
        if item1 >= item2:
            irc.reply('true')
        else:
            irc.reply('false')
    nge = wrap(nge, ['float', 'float'])

    @internationalizeDocstring
    def nlt(self, irc, msg, args, item1, item2):
        """<item1> <item2>

        Does a numeric comparison on <item1> and <item2>.
        Returns true if <item1> is less than <item2>.
        """
        if item1 < item2:
            irc.reply('true')
        else:
            irc.reply('false')
    nlt = wrap(nlt, ['float', 'float'])

    @internationalizeDocstring
    def nle(self, irc, msg, args, item1, item2):
        """<item1> <item2>

        Does a numeric comparison on <item1> and <item2>.
        Returns true if <item1> is less than or equal to <item2>.
        """
        if item1 <= item2:
            irc.reply('true')
        else:
            irc.reply('false')
    nle = wrap(nle, ['float', 'float'])
Condition = internationalizeDocstring(Conditional)

Class = Conditional


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2010, Daniel Folkinshteyn
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

###

from supybot.test import *

class ConditionalTestCase(PluginTestCase):
    plugins = ('Conditional','Utilities',)

    def testCif(self):
        self.assertError('cif stuff')
        self.assertRegexp('cif [ceq bla bla] "echo moo" "echo foo"', 'moo')
        self.assertRegexp('cif [ceq bla bar] "echo moo" "echo foo"', 'foo')
        self.assertRegexp('cif [cand [ceq bla bla] [ne soo boo]] "echo moo" "echo foo"', 'moo')
        self.assertRegexp('cif [ceq [echo $nick] "test"] "echo yay" "echo nay"', 'yay')
        
    def testCand(self):
        self.assertRegexp('cand true true', 'true')
        self.assertRegexp('cand false true', 'false')
        self.assertRegexp('cand true false', 'false')
        self.assertRegexp('cand false false', 'false')
        self.assertRegexp('cand true true true', 'true')
    
    def testCor(self):
        self.assertRegexp('cor true true', 'true')
        self.assertRegexp('cor false true', 'true')
        self.assertRegexp('cor true false', 'true')
        self.assertRegexp('cor false false', 'false')
        self.assertRegexp('cor true true true', 'true')
    
    def testCxor(self):
        self.assertRegexp('cxor true true', 'false')
        self.assertRegexp('cxor false true', 'true')
        self.assertRegexp('cxor true false', 'true')
        self.assertRegexp('cxor false false', 'false')
        self.assertRegexp('cxor true true true', 'false')
    
    def testCeq(self):
        self.assertRegexp('ceq bla bla', 'true')
        self.assertRegexp('ceq bla moo', 'false')
        self.assertError('ceq bla bla bla')
    
    def testNe(self):
        self.assertRegexp('ne bla bla', 'false')
        self.assertRegexp('ne bla moo', 'true')
        self.assertError('ne bla bla bla')
    
    def testGt(self):
        self.assertRegexp('gt bla bla', 'false')
        self.assertRegexp('gt bla moo', 'false')
        self.assertRegexp('gt moo bla', 'true')
        self.assertError('gt bla bla bla')
        
    def testGe(self):
        self.assertRegexp('ge bla bla', 'true')
        self.assertRegexp('ge bla moo', 'false')
        self.assertRegexp('ge moo bla', 'true')
        self.assertError('ge bla bla bla')
        
    def testLt(self):
        self.assertRegexp('lt bla bla', 'false')
        self.assertRegexp('lt bla moo', 'true')
        self.assertRegexp('lt moo bla', 'false')
        self.assertError('lt bla bla bla')
        
    def testLe(self):
        self.assertRegexp('le bla bla', 'true')
        self.assertRegexp('le bla moo', 'true')
        self.assertRegexp('le moo bla', 'false')
        self.assertError('le bla bla bla')
    
    def testMatch(self):
        self.assertRegexp('match bla mooblafoo', 'true')
        self.assertRegexp('match bla mooblfoo', 'false')
        self.assertRegexp('match Bla moobLafoo', 'false')
        self.assertRegexp('match --case-insensitive Bla moobLafoo', 'true')
        self.assertError('match bla bla stuff')
    
    def testNceq(self):
        self.assertRegexp('nceq 10.0 10', 'true')
        self.assertRegexp('nceq 4 5', 'false')
        self.assertError('nceq 1 2 3')
        self.assertError('nceq bla 1')
    
    def testNne(self):
        self.assertRegexp('nne 1 1', 'false')
        self.assertRegexp('nne 2.2 3', 'true')
        self.assertError('nne 1 2 3')
        self.assertError('nne bla 3')
    
    def testNgt(self):
        self.assertRegexp('ngt 3 3', 'false')
        self.assertRegexp('ngt 2 3', 'false')
        self.assertRegexp('ngt 4 3', 'true')
        self.assertError('ngt 1 2 3')
        self.assertError('ngt 3 bla')
        
    def testNge(self):
        self.assertRegexp('nge 3 3', 'true')
        self.assertRegexp('nge 3 4', 'false')
        self.assertRegexp('nge 5 4.3', 'true')
        self.assertError('nge 3 4.5 4')
        self.assertError('nge 45 bla')
        
    def testNlt(self):
        self.assertRegexp('nlt 3 3', 'false')
        self.assertRegexp('nlt 3 4.5', 'true')
        self.assertRegexp('nlt 5 3', 'false')
        self.assertError('nlt 2 3 4')
        self.assertError('nlt bla bla')
        
    def testNle(self):
        self.assertRegexp('nle 2 2', 'true')
        self.assertRegexp('nle 2 3.5', 'true')
        self.assertRegexp('nle 4 3', 'false')
        self.assertError('nle 3 4 5')
        self.assertError('nle 1 bla')
        
# vim:set shiftwidth=4 tabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2004-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###


import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Config')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Config', True)


Config = conf.registerPlugin('Config')
# This is where your configuration variables (if any) should go.  For example:
# conf.registerGlobalValue(Config, 'someConfigVariableName',
#     registry.Boolean(False, """Help for someConfigVariableName."""))

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# Copyright (c) 2009, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import os
import signal

import supybot.log as log
import supybot.conf as conf
import supybot.utils as utils
import supybot.world as world
import supybot.ircdb as ircdb
from supybot.commands import *
from supybot.utils.iter import all
import supybot.ircutils as ircutils
import supybot.registry as registry
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Config')

###
# Now, to setup the registry.
###

def getWrapper(name):
    parts = registry.split(name)
    if not parts or parts[0] not in ('supybot', 'users'):
        raise registry.InvalidRegistryName(name)
    group = getattr(conf, parts.pop(0))
    while parts:
        try:
            group = group.get(parts.pop(0))
        # We'll catch registry.InvalidRegistryName and re-raise it here so
        # that we have a useful error message for the user.
        except (registry.NonExistentRegistryEntry,
                registry.InvalidRegistryName):
            raise registry.InvalidRegistryName(name)
    return group

def getCapability(name):
    capability = 'owner' # Default to requiring the owner capability.
    parts = registry.split(name)
    while parts:
        part = parts.pop()
        if ircutils.isChannel(part):
            # If a registry value has a channel in it, it requires a
            # 'channel,op' capability, or so we assume.  We'll see if we're
            # proven wrong.
            capability = ircdb.makeChannelCapability(part, 'op')
        ### Do more later, for specific capabilities/sections.
    return capability

def _reload():
    ircdb.users.reload()
    ircdb.ignores.reload()
    ircdb.channels.reload()
    registry.open_registry(world.registryFilename)

def _hupHandler(sig, frame):
    log.info('Received SIGHUP, reloading configuration.')
    _reload()

if os.name == 'posix':
    signal.signal(signal.SIGHUP, _hupHandler)

def getConfigVar(irc, msg, args, state):
    name = args[0]
    if name.startswith('conf.'):
        name = name[5:]
    if not name.startswith('supybot') and not name.startswith('users'):
        name = 'supybot.' + name
    try:
        group = getWrapper(name)
        state.args.append(group)
        del args[0]
    except registry.InvalidRegistryName as e:
        state.errorInvalid(_('configuration variable'), str(e))
addConverter('configVar', getConfigVar)

def getSettableConfigVar(irc, msg, args, state):
    getConfigVar(irc, msg, args, state)
    if not hasattr(state.args[-1], 'set'):
        state.errorInvalid(_('settable configuration variable'),
                           state.args[-1]._name)
addConverter('settableConfigVar', getSettableConfigVar)

class Config(callbacks.Plugin):
    def callCommand(self, command, irc, msg, *args, **kwargs):
        try:
            super(Config, self).callCommand(command, irc, msg, *args, **kwargs)
        except registry.InvalidRegistryValue as e:
            irc.error(str(e))

    def _list(self, group):
        L = []
        for (vname, v) in group._children.iteritems():
            if hasattr(group, 'channelValue') and group.channelValue and \
               ircutils.isChannel(vname) and not v._children:
                continue
            if hasattr(v, 'channelValue') and v.channelValue:
                vname = '#' + vname
            if v._added and not all(ircutils.isChannel, v._added):
                vname = '@' + vname
            L.append(vname)
        utils.sortBy(str.lower, L)
        return L

    @internationalizeDocstring
    def list(self, irc, msg, args, group):
        """<group>

        Returns the configuration variables available under the given
        configuration <group>.  If a variable has values under it, it is
        preceded by an '@' sign.  If a variable is a 'ChannelValue', that is,
        it can be separately configured for each channel using the 'channel'
        command in this plugin, it is preceded by an '#' sign.
        """
        L = self._list(group)
        if L:
            irc.reply(format('%L', L))
        else:
            irc.error(_('There don\'t seem to be any values in %s.') % 
                      group._name)
    list = wrap(list, ['configVar'])

    @internationalizeDocstring
    def search(self, irc, msg, args, word):
        """<word>

        Searches for <word> in the current configuration variables.
        """
        L = []
        for (name, x) in conf.supybot.getValues(getChildren=True):
            if word in name.lower():
                possibleChannel = registry.split(name)[-1]
                if not ircutils.isChannel(possibleChannel):
                    L.append(name)
        if L:
            irc.reply(format('%L', L))
        else:
            irc.reply(_('There were no matching configuration variables.'))
    search = wrap(search, ['lowered']) # XXX compose with withoutSpaces?

    def _getValue(self, irc, msg, group, addChannel=False):
        value = str(group) or ' '
        if addChannel and irc.isChannel(msg.args[0]) and not irc.nested:
            s = str(group.get(msg.args[0]))
            value = _('Global: %s; %s: %s') % (value, msg.args[0], s)
        if hasattr(group, 'value'):
            if not group._private:
                irc.reply(value)
            else:
                capability = getCapability(group._name)
                if ircdb.checkCapability(msg.prefix, capability):
                    irc.reply(value, private=True)
                else:
                    irc.errorNoCapability(capability)
        else:
            irc.error(_('That registry variable has no value.  Use the list '
                      'command in this plugin to see what variables are '
                      'available in this group.'))

    def _setValue(self, irc, msg, group, value):
        capability = getCapability(group._name)
        if ircdb.checkCapability(msg.prefix, capability):
            # I think callCommand catches exceptions here.  Should it?
            group.set(value)
            irc.replySuccess()
        else:
            irc.errorNoCapability(capability)

    @internationalizeDocstring
    def channel(self, irc, msg, args, channel, group, value):
        """[<channel>] <name> [<value>]

        If <value> is given, sets the channel configuration variable for <name>
        to <value> for <channel>.  Otherwise, returns the current channel
        configuration value of <name>.  <channel> is only necessary if the
        message isn't sent in the channel itself."""
        if not group.channelValue:
            irc.error(_('That configuration variable is not a channel-specific '
                      'configuration variable.'))
            return
        group = group.get(channel)
        if value is not None:
            self._setValue(irc, msg, group, value)
        else:
            self._getValue(irc, msg, group)
    channel = wrap(channel, ['channel', 'settableConfigVar',
                             additional('text')])

    @internationalizeDocstring
    def config(self, irc, msg, args, group, value):
        """<name> [<value>]

        If <value> is given, sets the value of <name> to <value>.  Otherwise,
        returns the current value of <name>.  You may omit the leading
        "supybot." in the name if you so choose.
        """
        if value is not None:
            self._setValue(irc, msg, group, value)
        else:
            self._getValue(irc, msg, group, addChannel=group.channelValue)
    config = wrap(config, ['settableConfigVar', additional('text')])

    @internationalizeDocstring
    def help(self, irc, msg, args, group):
        """<name>

        Returns the description of the configuration variable <name>.
        """
        if hasattr(group, '_help'):
            s = group.help()
            if s:
                if hasattr(group, 'value') and not group._private:
                    channel = msg.args[0]
                    if irc.isChannel(channel) and \
                            channel in group._children:
                        globvalue = str(group)
                        chanvalue = str(group.get(channel))
                        if chanvalue != globvalue:
                            s += _('  (Current global value: %s;  '
                                    'current channel value: %s)') % \
                                            (globvalue, chanvalue)
                        else:
                            s += _('  (Current value: %s)') % group
                    else:
                        s += _('  (Current value: %s)') % group
                irc.reply(s)
            else:
                irc.reply(_('That configuration group exists, but seems to '
                          'have no help.  Try "config list %s" to see if it '
                          'has any children values.') % group._name)
        else:
            irc.error(_('%s has no help.') % group._name)
    help = wrap(help, ['configVar'])

    @internationalizeDocstring
    def default(self, irc, msg, args, group):
        """<name>

        Returns the default value of the configuration variable <name>.
        """
        v = group.__class__(group._default, '')
        irc.reply(str(v))
    default = wrap(default, ['settableConfigVar'])

    @internationalizeDocstring
    def reload(self, irc, msg, args):
        """takes no arguments

        Reloads the various configuration files (user database, channel
        database, registry, etc.).
        """
        _reload() # This was factored out for SIGHUP handling.
        irc.replySuccess()
    reload = wrap(reload, [('checkCapability', 'owner')])

    @internationalizeDocstring
    def export(self, irc, msg, args, filename):
        """<filename>

        Exports the public variables of your configuration to <filename>.
        If you want to show someone your configuration file, but you don't
        want that person to be able to see things like passwords, etc., this
        command will export a "sanitized" configuration file suitable for
        showing publicly.
        """
        registry.close(conf.supybot, filename, private=False)
        irc.replySuccess()
    export = wrap(export, [('checkCapability', 'owner'), 'filename'])

    @internationalizeDocstring
    def setdefault(self, irc, msg, args, group):
        """<name>

        Resets the configuration variable <name> to its default value.
        """
        v = str(group.__class__(group._default, ''))
        self._setValue(irc, msg, group, v)
    setdefault = wrap(setdefault, ['settableConfigVar'])

Class = Config

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# Copyright (c) 2009, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

import supybot.conf as conf

class ConfigTestCase(ChannelPluginTestCase):
    # We add utilities so there's something in supybot.plugins.
    plugins = ('Config', 'Utilities')
    def testGet(self):
        self.assertNotRegexp('config get supybot.reply', r'registry\.Group')
        self.assertResponse('config supybot.protocols.irc.throttleTime', '0.0')

    def testList(self):
        self.assertError('config list asldfkj')
        self.assertError('config list supybot.asdfkjsldf')
        self.assertNotError('config list supybot')
        self.assertNotError('config list supybot.replies')
        self.assertRegexp('config list supybot', r'@plugins.*@replies.*@reply')

    def testHelp(self):
        self.assertError('config help alsdkfj')
        self.assertError('config help supybot.alsdkfj')
        self.assertNotError('config help supybot') # We tell the user to list.
        self.assertNotError('config help supybot.plugins')
        self.assertNotError('config help supybot.replies.success')
        self.assertNotError('config help replies.success')

    def testHelpDoesNotAssertionError(self):
        self.assertNotRegexp('config help ' # Cont'd.
                             'supybot.commands.defaultPlugins.help',
                             'AssertionError')

    def testHelpExhaustively(self):
        L = conf.supybot.getValues(getChildren=True)
        for (name, v) in L:
            self.assertNotError('config help %s' % name)

    def testSearch(self):
        self.assertNotError('config search chars')
        self.assertNotError('config channel reply.whenAddressedBy.chars @')
        self.assertNotRegexp('config search chars', self.channel)

    def testDefault(self):
        self.assertNotError('config default '
                            'supybot.replies.genericNoCapability')

    def testConfigErrors(self):
        self.assertRegexp('config supybot.replies.', 'not a valid')
        self.assertRegexp('config supybot.repl', 'not a valid')
        self.assertRegexp('config supybot.reply.withNickPrefix 123',
                          'True or False.*, not \'123\'.')
        self.assertRegexp('config supybot.replies foo', 'settable')

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:


########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Ctcp')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Ctcp', True)


###
# Ctcp plugin configuration variables.
###
Ctcp = conf.registerPlugin('Ctcp')
conf.registerGlobalValue(Ctcp, 'versionWait',
    registry.PositiveInteger(10, """Determines how many seconds the bot will
    wait after getting a version command (not a CTCP VERSION, but an actual
    call of the command in this plugin named "version") before replying with
    the results it has collected."""))
conf.registerGlobalValue(Ctcp, 'userinfo',
    registry.String('', """Determines what will be sent when a
    USERINFO query is received."""))

###
# supybot.abuse configuration variables.
###
conf.registerGlobalValue(conf.supybot.abuse.flood, 'ctcp',
    registry.Boolean(True, """Determines whether the bot will defend itself
    against CTCP flooding."""))
conf.registerGlobalValue(conf.supybot.abuse.flood.ctcp, 'maximum',
    registry.PositiveInteger(5, """Determines how many CTCP messages (not
    including actions) the bot will reply to from a given user in a minute.
    If a user sends more than this many CTCP messages in a 60 second period,
    the bot will ignore CTCP messages from this user for
    supybot.abuse.flood.ctcp.punishment seconds."""))
conf.registerGlobalValue(conf.supybot.abuse.flood.ctcp, 'punishment',
    registry.PositiveInteger(300, """Determines how many seconds the bot will
    ignore CTCP messages from users who flood it with CTCP messages."""))

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2002-2004, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import time

import supybot.conf as conf
import supybot.utils as utils
from supybot.commands import *
import supybot.ircmsgs as ircmsgs
import supybot.ircutils as ircutils
import supybot.schedule as schedule
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Ctcp')

class Ctcp(callbacks.PluginRegexp):
    public = False
    regexps = ('ctcpPing', 'ctcpVersion', 'ctcpUserinfo',
               'ctcpTime', 'ctcpFinger', 'ctcpSource')
    def __init__(self, irc):
        self.__parent = super(Ctcp, self)
        self.__parent.__init__(irc)
        self.ignores = ircutils.IrcDict()
        self.floods = ircutils.FloodQueue(conf.supybot.abuse.flood.interval())
        conf.supybot.abuse.flood.interval.addCallback(self.setFloodQueueTimeout)

    def setFloodQueueTimeout(self, *args, **kwargs):
        self.floods.timeout = conf.supybot.abuse.flood.interval()

    def callCommand(self, command, irc, msg, *args, **kwargs):
        if conf.supybot.abuse.flood.ctcp():
            now = time.time()
            for (ignore, expiration) in self.ignores.items():
                if expiration < now:
                    del self.ignores[ignore]
                elif ircutils.hostmaskPatternEqual(ignore, msg.prefix):
                        return
            self.floods.enqueue(msg)
            max = conf.supybot.abuse.flood.ctcp.maximum()
            if self.floods.len(msg) > max:
                expires = conf.supybot.abuse.flood.ctcp.punishment()
                self.log.warning('Apparent CTCP flood from %s, '
                                 'ignoring CTCP messages for %s seconds.',
                                 msg.prefix, expires)
                ignoreMask = '*!%s@%s' % (msg.user, msg.host)
                self.ignores[ignoreMask] = now + expires
                return
        self.__parent.callCommand(command, irc, msg, *args, **kwargs)

    def _reply(self, irc, msg, s):
        s = '\x01%s\x01' % s
        irc.reply(s, notice=True, private=True, to=msg.nick)

    def ctcpPing(self, irc, msg, match):
        "^\x01PING(?: (.+))?\x01$"
        self.log.info('Received CTCP PING from %s', msg.prefix)
        payload = match.group(1)
        if payload:
            self._reply(irc, msg, 'PING %s' % match.group(1))
        else:
            self._reply(irc, msg, 'PING')

    def ctcpVersion(self, irc, msg, match):
        "^\x01VERSION\x01$"
        self.log.info('Received CTCP VERSION from %s', msg.prefix)
        self._reply(irc, msg, 'VERSION Supybot %s' % conf.version)

    def ctcpUserinfo(self, irc, msg, match):
        "^\x01USERINFO\x01$"
        self.log.info('Received CTCP USERINFO from %s', msg.prefix)
        self._reply(irc, msg, 'USERINFO %s' % self.registryValue('userinfo'))

    def ctcpTime(self, irc, msg, match):
        "^\x01TIME\x01$"
        self.log.info('Received CTCP TIME from %s', msg.prefix)
        self._reply(irc, msg, 'TIME %s' % time.ctime())

    def ctcpFinger(self, irc, msg, match):
        "^\x01FINGER\x01$"
        self.log.info('Received CTCP FINGER from %s', msg.prefix)
        self._reply(irc, msg, 'FINGER ' + 
                    _('Supybot, the best Python IRC bot in existence!'))

    def ctcpSource(self, irc, msg, match):
        "^\x01SOURCE\x01$"
        self.log.info('Received CTCP SOURCE from %s', msg.prefix)
        self._reply(irc, msg,
                    'SOURCE https://github.com/ProgVal/Limnoria')

    def doNotice(self, irc, msg):
        if ircmsgs.isCtcp(msg):
            try:
                (version, payload) = msg.args[1][1:-1].split(None, 1)
            except ValueError:
                return
            if version == 'VERSION':
                self.versions.setdefault(payload, []).append(msg.nick)

    @internationalizeDocstring
    def version(self, irc, msg, args, channel, optlist):
        """[<channel>] [--nicks]

        Sends a CTCP VERSION to <channel>, returning the various
        version strings returned.  It waits for 10 seconds before returning
        the versions received at that point.  If --nicks is given, nicks are
        associated with the version strings; otherwise, only the version
        strings are given.
        """
        self.versions = ircutils.IrcDict()
        nicks = False
        for (option, arg) in optlist:
            if option == 'nicks':
                nicks = True
        irc.queueMsg(ircmsgs.privmsg(channel, '\x01VERSION\x01'))
        def doReply():
            if self.versions:
                L = []
                for (reply, nicks) in self.versions.iteritems():
                    if nicks:
                        L.append(format('%L responded with %q', nicks, reply))
                    else:
                        L.append(reply)
                irc.reply(format('%L', L))
            else:
                irc.reply('I received no version responses.')
        wait = self.registryValue('versionWait')
        schedule.addEvent(doReply, time.time()+wait)
    version = wrap(version, ['channel', getopts({'nicks':''})])

Class = Ctcp
# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2002-2004, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

class CtcpTestCase(PluginTestCase):
    plugins = ('Ctcp',)


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:


########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2004, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Dict')

def configure(advanced):
    from supybot.questions import output, expect, anything, something, yn
    conf.registerPlugin('Dict', True)
    output(_('The default dictd server is dict.org.'))
    if yn(_('Would you like to specify a different dictd server?')):
        server = something('What server?')
        conf.supybot.plugins.Dict.server.set(server)

Dict = conf.registerPlugin('Dict')
conf.registerGlobalValue(Dict, 'server',
    registry.String('dict.org', _("""Determines what server the bot will
    retrieve definitions from.""")))
conf.registerChannelValue(Dict, 'default',
    registry.String('', _("""Determines the default dictionary the bot will
    ask for definitions in.  If this value is '*' (without the quotes) the bot
    will use all dictionaries to define words.""")))

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = dictclient
# Client for the DICT protocol (RFC2229)
#
# Copyright (C) 2002 John Goerzen
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import socket, re

version = '1.0'

def dequote(str):
    """Will remove single or double quotes from the start and end of a string
    and return the result."""
    quotechars = "'\""
    while len(str) and str[0] in quotechars:
        str = str[1:]
    while len(str) and str[-1] in quotechars:
        str = str[0:-1]
    return str

def enquote(str):
    """This function will put a string in double quotes, properly
    escaping any existing double quotes with a backslash.  It will
    return the result."""
    return '"' + str.replace('"', "\\\"") + '"'

class Connection:
    """This class is used to establish a connection to a database server.
    You will usually use this as the first call into the dictclient library.
    Instantiating it takes two optional arguments: a hostname (a string)
    and a port (an int).  The hostname defaults to localhost
    and the port to 2628, the port specified in RFC."""
    def __init__(self, hostname = 'localhost', port = 2628):
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.connect((hostname, port))
        self.rfile = self.sock.makefile("rb")
        self.wfile = self.sock.makefile("wb", 0)
        self.saveconnectioninfo()

    def getresultcode(self):
        """Generic function to get a result code.  It will return a list
        consisting of two items: the integer result code and the text
        following.  You will not usually use this function directly."""
        line = self.rfile.readline().decode('utf8').strip()
        if line.startswith('['):
            return [None, line]
        code, text = line.split(' ', 1)
        return [int(code), text]

    def get200result(self):
        """Used when expecting a single line of text -- a 200-class
        result.  Returns [intcode, remaindertext]"""

        code, text = self.getresultcode()
        if code < 200 or code >= 300:
            raise Exception("Got '%s' when 200-class response expected" % \
                  line)
        return [code, text]

    def get100block(self):
        """Used when expecting multiple lines of text -- gets the block
        part only.  Does not get any codes or anything!  Returns a string."""
        data = []
        while True:
            line = self.rfile.readline().decode('utf8').strip()
            if line == '.':
                break
            data.append(line)
        return "\n".join(data)

    def get100result(self):
        """Used when expecting multiple lines of text, terminated by a period
        and a 200 code.  Returns: [initialcode, [bodytext_1lineperentry],
        finalcode]"""
        code, text = self.getresultcode()
        if code < 100 or code >= 200:
            raise Exception("Got '%s' when 100-class response expected" % \
                  code)

        bodylines = self.get100block().split("\n")

        code2 = self.get200result()[0]
        return [code, bodylines, code2]

    def get100dict(self):
        """Used when expecting a dictionary of results.  Will read from
        the initial 100 code, to a period and the 200 code."""
        dict = {}
        for line in self.get100result()[1]:
            key, val = line.split(' ', 1)
            dict[key] = dequote(val)
        return dict

    def saveconnectioninfo(self):
        """Called by __init__ to handle the initial connection.  Will
        save off the capabilities and messageid."""
        code, string = self.get200result()
        assert code == 220
        capstr, msgid = re.search('<(.*)> (<.*>)$', string).groups()
        self.capabilities = capstr.split('.')
        self.messageid = msgid
        
    def getcapabilities(self):
        """Returns a list of the capabilities advertised by the server."""
        return self.capabilities

    def getmessageid(self):
        """Returns the message id, including angle brackets."""
        return self.messageid

    def getdbdescs(self):
        """Gets a dict of available databases.  The key is the db name
        and the value is the db description.  This command may generate
        network traffic!"""
        if hasattr(self, 'dbdescs'):
            return self.dbdescs
        
        self.sendcommand("SHOW DB")
        self.dbdescs = self.get100dict()
        return self.dbdescs

    def getstratdescs(self):
        """Gets a dict of available strategies.  The key is the strat
        name and the value is the strat description.  This call may
        generate network traffic!"""
        if hasattr(self, 'stratdescs'):
            return self.stratdescs

        self.sendcommand("SHOW STRAT")
        self.stratdescs = self.get100dict()
        return self.stratdescs

    def getdbobj(self, dbname):
        """Gets a Database object corresponding to the database name passed
        in.  This function explicitly will *not* generate network traffic.
        If you have not yet run getdbdescs(), it will fail."""
        if not hasattr(self, 'dbobjs'):
            self.dbobjs = {}

        if dbname in self.dbobjs:
            return self.dbobjs[dbname]

        # We use self.dbdescs explicitly since we don't want to
        # generate net traffic with this request!

        if dbname != '*' and dbname != '!' and \
               not dbname in self.dbdescs.keys():
            raise Exception("Invalid database name '%s'" % dbname)

        self.dbobjs[dbname] = Database(self, dbname)
        return self.dbobjs[dbname]

    def sendcommand(self, command):
        """Takes a command, without a newline character, and sends it to
        the server."""
        self.wfile.write(command.encode('ascii') + b"\n")

    def define(self, database, word):
        """Returns a list of Definition objects for each matching
        definition.  Parameters are the database name and the word
        to look up.  This is one of the main functions you will use
        to interact with the server.  Returns a list of Definition
        objects.  If there are no matches, an empty list is returned.

        Note: database may be '*' which means to search all databases,
        or '!' which means to return matches from the first database that
        has a match."""
        self.getdbdescs()               # Prime the cache

        if database != '*' and database != '!' and \
           not database in self.getdbdescs():
            raise Exception("Invalid database '%s' specified" % database)
        
        self.sendcommand("DEFINE " + enquote(database) + " " + enquote(word))
        code = self.getresultcode()[0]

        retval = []

        if code == 552:
            # No definitions.
            return []
        if code != 150:
            raise Exception("Unknown code %d" % code)

        while True:
            code, text = self.getresultcode()
            if code != 151 or code is None:
                break

            resultword, resultdb = re.search('^"(.+)" (\S+)', text).groups()
            defstr = self.get100block()
            retval.append(Definition(self, self.getdbobj(resultdb),
                                     resultword, defstr))
        return retval

    def match(self, database, strategy, word):
        """Gets matches for a query.  Arguments are database name,
        the strategy (see available ones in getstratdescs()), and the
        pattern/word to look for.  Returns a list of Definition objects.
        If there is no match, an empty list is returned.

        Note: database may be '*' which means to search all databases,
        or '!' which means to return matches from the first database that
        has a match."""
        self.getstratdescs()            # Prime the cache
        self.getdbdescs()               # Prime the cache
        if not strategy in self.getstratdescs().keys():
            raise Exception("Invalid strategy '%s'" % strategy)
        if database != '*' and database != '!' and \
               not database in self.getdbdescs().keys():
            raise Exception("Invalid database name '%s'" % database)

        self.sendcommand("MATCH %s %s %s" % (enquote(database),
                                             enquote(strategy),
                                             enquote(word)))
        code = self.getresultcode()[0]
        if code == 552:
            # No Matches
            return []
        if code != 152:
            raise Exception("Unexpected code %d" % code)

        retval = []

        for matchline in self.get100block().split("\n"):
            matchdict, matchword = matchline.split(" ", 1)
            retval.append(Definition(self, self.getdbobj(matchdict),
                                     dequote(matchword)))
        if self.getresultcode()[0] != 250:
            raise Exception("Unexpected end-of-list code %d" % code)
        return retval

class Database:
    """An object corresponding to a particular database in a server."""
    def __init__(self, dictconn, dbname):
        """Initialize the object -- requires a Connection object and
        a database name."""
        self.conn = dictconn
        self.name = dbname
    
    def getname(self):
        """Returns the short name for this database."""
        return self.name
    
    def getdescription(self):
        if hasattr(self, 'description'):
            return self.description
        if self.getname() == '*':
            self.description = 'All Databases'
        elif self.getname() == '!':
            self.description = 'First matching database'
        else:
            self.description = self.conn.getdbdescs()[self.getname()]
        return self.description
    
    def getinfo(self):
        """Returns a string of info describing this database."""
        if hasattr(self, 'info'):
            return self.info

        if self.getname() == '*':
            self.info = "This special database will search all databases on the system."
        elif self.getname() == '!':
            self.info = "This special database will return matches from the first matching database."
        else:
            self.conn.sendcommand("SHOW INFO " + self.name)
            self.info = "\n".join(self.conn.get100result()[1])
        return self.info

    def define(self, word):
        """Get a definition from within this database.
        The argument, word, is the word to look up.  The return value is the
        same as from Connection.define()."""
        return self.conn.define(self.getname(), word)

    def match(self, strategy, word):
        """Get a match from within this database.
        The argument, word, is the word to look up.  The return value is
        the same as from Connection.define()."""
        return self.conn.match(self.getname(), strategy, word)

class Definition:
    """An object corresponding to a single definition."""
    def __init__(self, dictconn, db, word, defstr = None):
        """Instantiate the object.  Requires: a Connection object,
        a Database object (NOT corresponding to '*' or '!' databases),
        a word.  Optional: a definition string.  If not supplied,
        it will be fetched if/when it is requested."""
        self.conn = dictconn
        self.db = db
        self.word = word
        self.defstr = defstr

    def getdb(self):
        """Get the Database object corresponding to this definition."""
        return self.db

    def getdefstr(self):
        """Get the definition string (the actual content) of this
        definition."""
        if not self.defstr:
            self.defstr = self.conn.define(self.getdb().getname(), self.word)[0].getdefstr()
        return self.defstr

    def getword(self):
        """Get the word this object describes."""
        return self.word

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2002-2004, Jeremiah Fincher
# Copyright (c) 2008, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import socket

import supybot.conf as conf
import supybot.utils as utils
from supybot.commands import *
import supybot.ircutils as ircutils
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Dict')

import random

from local import dictclient

class Dict(callbacks.Plugin):
    threaded = True
    @internationalizeDocstring
    def dictionaries(self, irc, msg, args):
        """takes no arguments

        Returns the dictionaries valid for the dict command.
        """
        try:
            server = conf.supybot.plugins.Dict.server()
            conn = dictclient.Connection(server)
            dbs = list(conn.getdbdescs().keys())
            dbs.sort()
            irc.reply(format('%L', dbs))
        except socket.error as e:
            irc.error(utils.web.strError(e))
    dictionaries = wrap(dictionaries)

    @internationalizeDocstring
    def random(self, irc, msg, args):
        """takes no arguments

        Returns a random valid dictionary.
        """
        try:
            server = conf.supybot.plugins.Dict.server()
            conn = dictclient.Connection(server)
            dbs = conn.getdbdescs().keys()
            irc.reply(utils.iter.choice(dbs))
        except socket.error as e:
            irc.error(utils.web.strError(e))
    random = wrap(random)

    @internationalizeDocstring
    def dict(self, irc, msg, args, words):
        """[<dictionary>] <word>

        Looks up the definition of <word> on the dictd server specified by
        the supybot.plugins.Dict.server config variable.
        """
        try:
            server = conf.supybot.plugins.Dict.server()
            conn = dictclient.Connection(server)
        except socket.error as e:
            irc.error(utils.web.strError(e), Raise=True)
        dbs = set(conn.getdbdescs())
        if words[0] in dbs:
            dictionary = words.pop(0)
        else:
            default = self.registryValue('default', msg.args[0])
            if default in dbs:
                dictionary = default
            else:
                if default:
                    self.log.info('Default dict for %s is not a supported '
                                  'dictionary: %s.', msg.args[0], default)
                dictionary = '*'
        if not words:
            irc.error(_('You must give a word to define.'), Raise=True)
        word = ' '.join(words)
        definitions = conn.define(dictionary, word)
        dbs = set()
        if not definitions:
            if dictionary == '*':
                irc.reply(format(_('No definition for %q could be found.'),
                                 word))
            else:
                irc.reply(format(_('No definition for %q could be found in '
                                   '%s'), word, ircutils.bold(dictionary)))
            return
        L = []
        for d in definitions:
            dbs.add(ircutils.bold(d.getdb().getname()))
            (db, s) = (d.getdb().getname(), d.getdefstr())
            db = ircutils.bold(db)
            s = utils.str.normalizeWhitespace(s).rstrip(';.,')
            L.append('%s: %s' % (db, s))
        utils.sortBy(len, L)
        if dictionary == '*' and len(dbs) > 1:
            s = format(_('%L responded: %s'), list(dbs), '; '.join(L))
        else:
            s = '; '.join(L)
        irc.reply(s)
    dict = wrap(dict, [many('something')])

    def synonym(self, irc, msg, args, words):
        """<word> [<word> ...]

        Gets a random synonym from the Moby Thesaurus (moby-thes) database.

        If given many words, gets a random synonym for each of them.

        Quote phrases to have them treated as one lookup word.
        """
        try:
            server = conf.supybot.plugins.Dict.server()
            conn = dictclient.Connection(server)
        except socket.error as e:
            irc.error(utils.web.strError(e), Raise=True)

        dictionary = 'moby-thes'
        response = []
        for word in words:
            definitions = conn.define(dictionary, word)
            if not definitions:
                asynonym = word
            else:
                defstr = definitions[0].getdefstr()
                synlist = ' '.join(defstr.split('\n')).split(': ', 1)[1].split(',')
                asynonym = random.choice(synlist).strip()
            response.append(asynonym)
        irc.reply(' '.join(response))
    synonym = wrap(synonym, [many('something')])

Class = Dict


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
# -*- coding: utf8 -*-
###
# Copyright (c) 2002-2004, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

class DictTestCase(PluginTestCase):
    plugins = ('Dict',)
    if network:
        def testDict(self):
            self.assertNotError('dict slash')
            self.assertNotError('dict flutter')
            self.assertNotRegexp('dict web1913 slash', 'foldoc')
            self.assertError('dict ""')
            self.assertRegexp('dict eng-fra school', 'école')

        def testDictionaries(self):
            self.assertNotError('dictionaries')

        def testRandomDictionary(self):
            self.assertNotError('random')
            self.assertNotError('dict [random] moo')
        
        def testSynonym(self):
            self.assertNotError('synonym stuff')
            self.assertNotError('synonym someone goes home')
            self.assertRegexp('synonym nanotube', 'nanotube')

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2003-2005, Daniel DiPaolo
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Dunno')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Dunno', True)


Dunno = conf.registerPlugin('Dunno')
conf.registerChannelValue(Dunno, 'prefixNick',
    registry.Boolean(True, _("""Determines whether the bot will prefix the nick
    of the user giving an invalid command to the "dunno" response.""")))


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2003-2005, Daniel DiPaolo
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.commands import *
import supybot.plugins as plugins
import supybot.ircutils as ircutils
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Dunno')

class Dunno(plugins.ChannelIdDatabasePlugin):
    """This plugin was written initially to work with MoobotFactoids, the two
    of them to provide a similar-to-moobot-and-blootbot interface for factoids.
    Basically, it replaces the standard 'Error: <x> is not a valid command.'
    messages with messages kept in a database, able to give more personable
    responses."""

    callAfter = ['MoobotFactoids', 'Factoids', 'Infobot']
    def invalidCommand(self, irc, msg, tokens):
        channel = msg.args[0]
        if irc.isChannel(channel):
            dunno = self.db.random(channel)
            if dunno is not None:
                dunno = dunno.text
                prefixNick = self.registryValue('prefixNick', channel)
                env = {'command': tokens[0]}
                dunno = ircutils.standardSubstitute(irc, msg, dunno, env=env)
                irc.reply(dunno, prefixNick=prefixNick)
Dunno = internationalizeDocstring(Dunno)

Class = Dunno


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2003-2005, Daniel DiPaolo
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

class DunnoTestCase(ChannelPluginTestCase):
    plugins = ('Dunno', 'User')
    def setUp(self):
        PluginTestCase.setUp(self)
        self.prefix = 'foo!bar@baz'
        self.assertNotError('register tester moo', private=True)

    def testDunnoAdd(self):
        self.assertNotError('dunno add moo')
        self.assertResponse('asdfagagfosdfk', 'moo')

    def testDunnoRemove(self):
        self.assertNotError('dunno add moo')
        self.assertNotError('dunno remove 1')

    def testDunnoSearch(self):
        self.assertNotError('dunno add foo')
        self.assertRegexp('dunno search moo', 'No.*dunnos.*found')
        # Test searching using just the getopts
        self.assertRegexp('dunno search --regexp m/foo/', r'1 found')
        self.assertNotError('dunno add moo')
        self.assertRegexp('dunno search moo', r'1 found')
        self.assertRegexp('dunno search m', r'1 found')
        # Test multiple adds
        for i in range(5):
            self.assertNotError('dunno add moo%s' % i)
        self.assertRegexp('dunno search moo', r'6 found')

    def testDunnoGet(self):
        self.assertNotError('dunno add moo')
        self.assertRegexp('dunno get 1', r'#1.*moo')
        self.assertNotError('dunno add $who')
        self.assertRegexp('dunno get 2', r'#2.*\$who')
        self.assertError('dunno get 3')
        self.assertError('dunno get a')

    def testDunnoChange(self):
        self.assertNotError('dunno add moo')
        self.assertNotError('dunno change 1 s/moo/bar/')
        self.assertRegexp('dunno get 1', '.*?: [\'"]bar[\'"]')

    def testDollarCommand(self):
        self.assertNotError("dunno add I can't $command.")
        self.assertResponse('asdf', "I can't asdf.")


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# Copyright (c) 2009, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Factoids')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Factoids', True)

class FactoidFormat(registry.TemplatedString):
    """Value must include $value, otherwise the factoid's value would be left
    out."""
    requiredTemplates = ['value']

Factoids = conf.registerPlugin('Factoids')
conf.registerGroup(Factoids, 'web')
conf.registerGlobalValue(Factoids.web, 'enable',
    registry.Boolean(False, _("""Determines whether the Factoids plugins will
    be browsable on the HTTP server.""")))
conf.registerChannelValue(Factoids.web, 'channel',
    registry.Boolean(False, _("""Determines whether factoids can be displayed
    via the web server.""")))

conf.registerChannelValue(Factoids, 'requireVoice',
    registry.Boolean(False, _("""Only allows a user with voice or above on a
    channel to use the command.""")))
conf.registerChannelValue(Factoids, 'learnSeparator',
    registry.String('as', _("""Determines what separator must be used in the
    learn command.  Defaults to 'as' -- learn <key> as <value>.  Users might
    feel more comfortable with 'is' or something else, so it's
    configurable.""")))
conf.registerChannelValue(Factoids, 'showFactoidIfOnlyOneMatch',
    registry.Boolean(True, _("""Determines whether the bot will reply with the
    single matching factoid if only one factoid matches when using the search
    command.""")))
conf.registerChannelValue(Factoids, 'replyWhenInvalidCommand',
    registry.Boolean(True,  _("""Determines whether the bot will reply to invalid
    commands by searching for a factoid; basically making the whatis
    unnecessary when you want all factoids for a given key.""")))
conf.registerChannelValue(Factoids, 'replyApproximateSearchKeys',
    registry.Boolean(True,  _("""If you try to look up a nonexistent factoid,
    this setting make the bot try to find some possible matching keys through
    several approximate matching algorithms and return a list of matching keys,
    before giving up.""")))
conf.registerChannelValue(Factoids, 'format',
    FactoidFormat(_('$key could be $value.'), _("""Determines the format of
    the response given when a factoid's value is requested.  All the standard
    substitutes apply, in addition to "$key" for the factoid's key and "$value"
    for the factoid's value.""")))
conf.registerChannelValue(Factoids, 'keepRankInfo',
    registry.Boolean(True, """Determines whether we keep updating the usage
    count for each factoid, for popularity ranking."""))
conf.registerChannelValue(Factoids, 'rankListLength',
    registry.Integer(20, """Determines the number of factoid keys returned
    by the factrank command."""))
# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# Copyright (c) 2009-2010, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import os
import time
import string
import urllib

import supybot.conf as conf
import supybot.ircdb as ircdb
import supybot.utils as utils
from supybot.commands import *
import supybot.plugins as plugins
import supybot.ircutils as ircutils
import supybot.callbacks as callbacks
import supybot.httpserver as httpserver
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Factoids')

import sqlite3

import re
from supybot.utils.seq import dameraulevenshtein

def getFactoid(irc, msg, args, state):
    assert not state.channel
    callConverter('channel', irc, msg, args, state)
    separator = state.cb.registryValue('learnSeparator', state.channel)
    try:
        i = args.index(separator)
    except ValueError:
        raise callbacks.ArgumentError
    args.pop(i)
    key = []
    value = []
    for (j, s) in enumerate(args[:]):
        if j < i:
            key.append(args.pop(0))
        else:
            value.append(args.pop(0))
    if not key or not value:
        raise callbacks.ArgumentError
    state.args.append(' '.join(key))
    state.args.append(' '.join(value))

def getFactoidId(irc, msg, args, state):
    Type = 'key id'
    p = lambda i: i > 0
    callConverter('int', irc, msg, args, state, Type, p)

addConverter('factoid', getFactoid)
addConverter('factoidId', getFactoidId)


PAGE_SKELETON = """\
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>Factoids</title>
    <link rel="stylesheet" href="/default.css" />
</head>
%s
</html>"""

DEFAULT_TEMPLATES = {
        'factoids/index.html': PAGE_SKELETON % """\
<body class="purelisting">
    <h1>Factoids</h1>
    <form action="." method="post">
        <label for="chan">Channel name:</label>
        <input type="text" placeholder="#channel" name="chan" id="chan" />
        <input type="submit" name="submit" value="view" />
    </form>
</body>""",
        'factoids/channel.html': PAGE_SKELETON % """\
<body class="puretable">
    <h1>Factoids of %(channel)s</h1>
    <table>
        <tr class="header">
            <th class="key">""" + _('key') + """</th>
            <th class="id">""" + _('id') + """</th>
            <th class="fact">""" + _('fact') + """</th>
        </tr>
        %(rows)s
    </table>
</body>"""
}
httpserver.set_default_templates(DEFAULT_TEMPLATES)

class FactoidsCallback(httpserver.SupyHTTPServerCallback):
    name = 'Factoids web interface'

    def doGet(self, handler, path):
        parts = path.split('/')[1:]
        if path == '/':
            self.send_response(200)
            self.send_header('Content-type', 'text/html; charset=utf-8')
            self.end_headers()
            self.wfile.write(httpserver.get_template('factoids/index.html'))
        elif len(parts) == 2:
            channel = urllib.unquote(parts[0])
            if not ircutils.isChannel(channel):
                self.send_response(404)
                self.send_header('Content-type', 'text/html; charset=utf-8')
                self.end_headers()
                self.wfile.write(httpserver.get_template('generic/error.html')%
                    {'title': 'Factoids - not a channel',
                     'error': 'This is not a channel'})
                return
            if not self._plugin.registryValue('web.channel', channel):
                self.send_response(403)
                self.send_header('Content-type', 'text/html; charset=utf-8')
                self.end_headers()
                self.wfile.write(httpserver.get_template('generic/error.html')%
                    {'title': 'Factoids - unavailable',
                     'error': 'This channel does not exist or its factoids '
                              'are not available here.'})
                return
            db = self._plugin.getDb(channel)
            cursor = db.cursor()
            cursor.execute("""SELECT keys.key, factoids.id, factoids.fact
                              FROM factoids, keys, relations
                              WHERE relations.key_id=keys.id AND relations.fact_id=factoids.id
                              """)
            factoids = {}
            for (key, id_, fact) in cursor.fetchall():
                if key not in factoids:
                    factoids[key] = {}
                factoids[key][id_] = fact
            content = ''
            keys = factoids.keys()
            keys.sort()
            for key in keys:
                facts = factoids[key]
                content += '<tr>'
                content += ('<td rowspan="%i" class="key">'
                                '<a name="%s" href="#%s">%s</a>'
                           '</td>') % (len(facts), key, key, key)
                for id_, fact in facts.items():
                    content += '<td class="id">%i</td>' % id_
                    content += '<td class="fact">%s</td>' % fact
                    content += '</tr><tr>'
                content = content[:-len('<tr>')]
            self.send_response(200)
            self.send_header('Content-type', 'text/html; charset=utf-8')
            self.end_headers()
            self.wfile.write(httpserver.get_template('factoids/channel.html')%
                    {'channel': channel, 'rows': content})
    def doPost(self, handler, path, form):
        if 'chan' in form:
            self.send_response(303)
            self.send_header('Location',
                    './%s/' % urllib.quote(form['chan'].value))
            self.end_headers()
        else:
            self.send_response(400)
            self.send_header('Content-type', 'text/plain; charset=utf-8')
            self.end_headers()
            self.wfile.write('Missing field \'chan\'.')

class Factoids(callbacks.Plugin, plugins.ChannelDBHandler):
    def __init__(self, irc):
        callbacks.Plugin.__init__(self, irc)
        plugins.ChannelDBHandler.__init__(self)
        self._http_running = False
        conf.supybot.plugins.Factoids.web.enable.addCallback(self._doHttpConf)
        if self.registryValue('web.enable'):
            self._startHttp()
    def _doHttpConf(self, *args, **kwargs):
        if self.registryValue('web.enable'):
            if not self._http_running:
                self._startHttp()
        else:
            if self._http_running:
                self._stopHttp()
    def _startHttp(self):
        callback = FactoidsCallback()
        callback._plugin = self
        httpserver.hook('factoids', callback)
        self._http_running = True
    def _stopHttp(self):
        httpserver.unhook('factoids')
        self._http_running = False
    def die(self):
        if self.registryValue('web.enable'):
            self._stopHttp()
        super(self.__class__, self).die()

    def makeDb(self, filename):
        if os.path.exists(filename):
            db = sqlite3.connect(filename)
            db.text_factory = str
            return db
        db = sqlite3.connect(filename)
        db.text_factory = str
        cursor = db.cursor()
        cursor.execute("""CREATE TABLE keys (
                          id INTEGER PRIMARY KEY,
                          key TEXT UNIQUE ON CONFLICT REPLACE
                          )""")
        cursor.execute("""CREATE TABLE factoids (
                          id INTEGER PRIMARY KEY,
                          added_by TEXT,
                          added_at TIMESTAMP,
                          fact TEXT UNIQUE ON CONFLICT REPLACE,
                          locked BOOLEAN
                          )""")
        cursor.execute("""CREATE TABLE relations (
                          id INTEGER PRIMARY KEY,
                          key_id INTEGER,
                          fact_id INTEGER,
                          usage_count INTEGER
                          )""")
        db.commit()
        return db

    def getCommandHelp(self, command, simpleSyntax=None):
        method = self.getCommandMethod(command)
        if method.im_func.__name__ == 'learn':
            chan = None
            if dynamic.msg is not None:
                chan = dynamic.msg.args[0]
            s = self.registryValue('learnSeparator', chan)
            help = callbacks.getHelp
            if simpleSyntax is None:
                simpleSyntax = conf.get(conf.supybot.reply.showSimpleSyntax,
                                        chan)
            if simpleSyntax:
                help = callbacks.getSyntax
            return help(method,
                        doc=method._fake__doc__ % (s, s),
                        name=callbacks.formatCommand(command))
        return super(Factoids, self).getCommandHelp(command, simpleSyntax)

    def _getKeyAndFactId(self, channel, key, factoid):
        db = self.getDb(channel)
        cursor = db.cursor()
        cursor.execute("SELECT id FROM keys WHERE key=?", (key,))
        keyresults = cursor.fetchall()
        cursor.execute("SELECT id FROM factoids WHERE fact=?", (factoid,))
        factresults = cursor.fetchall()
        return (keyresults, factresults,)
    
    def learn(self, irc, msg, args, channel, key, factoid):
        if self.registryValue('requireVoice', channel) and \
                not irc.state.channels[channel].isVoicePlus(msg.nick):
            irc.error(_('You have to be at least voiced to teach factoids.'))
        
        # if neither key nor factoid exist, add them.
        # if key exists but factoid doesn't, add factoid, link it to existing key
        # if factoid exists but key doesn't, add key, link it to existing factoid
        # if both key and factoid already exist, and are linked, do nothing, print nice message
        db = self.getDb(channel)
        cursor = db.cursor()
        (keyid, factid) = self._getKeyAndFactId(channel, key, factoid)
        
        if len(keyid) == 0:
            cursor.execute("""INSERT INTO keys VALUES (NULL, ?)""", (key,))
            db.commit()
        if len(factid) == 0:
            if ircdb.users.hasUser(msg.prefix):
                name = ircdb.users.getUser(msg.prefix).name
            else:
                name = msg.nick
            cursor.execute("""INSERT INTO factoids VALUES
                              (NULL, ?, ?, ?, ?)""",
                           (name, int(time.time()), factoid, 0))
            db.commit()
        (keyid, factid) = self._getKeyAndFactId(channel, key, factoid)
        
        cursor.execute("""SELECT id, key_id, fact_id from relations
                            WHERE key_id=? AND fact_id=?""", 
                            (keyid[0][0], factid[0][0],))
        existingrelation = cursor.fetchall()
        if len(existingrelation) == 0:
            cursor.execute("""INSERT INTO relations VALUES (NULL, ?, ?, ?)""", 
                    (keyid[0][0],factid[0][0],0,))
            db.commit()
            irc.replySuccess()
        else:
            irc.error("This key-factoid relationship already exists.")
        
    learn = wrap(learn, ['factoid'], checkDoc=False)
    learn._fake__doc__ = _("""[<channel>] <key> %s <value>

                         Associates <key> with <value>.  <channel> is only
                         necessary if the message isn't sent on the channel
                         itself.  The word '%s' is necessary to separate the
                         key from the value.  It can be changed to another word
                         via the learnSeparator registry value.
                         """)


    def _lookupFactoid(self, channel, key):
        db = self.getDb(channel)
        cursor = db.cursor()
        cursor.execute("""SELECT factoids.fact, factoids.id, relations.id FROM factoids, keys, relations
                          WHERE keys.key LIKE ? AND relations.key_id=keys.id AND relations.fact_id=factoids.id
                          ORDER BY factoids.id
                          LIMIT 20""", (key,))
        return cursor.fetchall()
    
    def _searchFactoid(self, channel, key):
        """Try to typo-match input to possible factoids.
        
        Assume first letter is correct, to reduce processing time.        
        First, try a simple wildcard search.
        If that fails, use the Damerau-Levenshtein edit-distance metric.
        """
        # if you made a typo in a two-character key, boo on you.
        if len(key) < 3:
            return []
            
        db = self.getDb(channel)
        cursor = db.cursor()
        cursor.execute("""SELECT key FROM keys WHERE key LIKE ?""", ('%' + key + '%',))
        wildcardkeys = cursor.fetchall()
        if len(wildcardkeys) > 0:
            return [line[0] for line in wildcardkeys]
        
        cursor.execute("""SELECT key FROM keys WHERE key LIKE ?""", (key[0] + '%',))
        flkeys = cursor.fetchall()
        if len(flkeys) == 0:
            return []
        flkeys = [line[0] for line in flkeys]
        dl_metrics = [dameraulevenshtein(key, sourcekey) for sourcekey in flkeys]
        dict_metrics = dict(list(zip(flkeys, dl_metrics)))
        if min(dl_metrics) <= 2:
            return [key for key,item in dict_metrics.iteritems() if item <= 2]
        if min(dl_metrics) <= 3:
            return [key for key,item in dict_metrics.iteritems() if item <= 3]
        
        return []
                
    def _updateRank(self, channel, factoids):
        if self.registryValue('keepRankInfo', channel):
            db = self.getDb(channel)
            cursor = db.cursor()
            for (fact,factid,relationid) in factoids:
                cursor.execute("""SELECT relations.usage_count
                          FROM relations
                          WHERE relations.id=?""", (relationid,))
                old_count = cursor.fetchall()[0][0]
                cursor.execute("UPDATE relations SET usage_count=? WHERE id=?", 
                            (old_count + 1, relationid,))
                db.commit()
        
    def _replyFactoids(self, irc, msg, key, channel, factoids,
                       number=0, error=True, raw=False):
        def format_fact(text):
            if raw:
                return text
            else:
                return ircutils.standardSubstitute(irc, msg, text)
        
        if factoids:
            if number:
                try:
                    irc.reply(format_fact(factoids[number-1][0]))
                    self._updateRank(channel, [factoids[number-1]])
                except IndexError:
                    irc.error(_('That\'s not a valid number for that key.'))
                    return
            else:
                env = {'key': key}
                def prefixer(v):
                    env['value'] = v
                    formatter = self.registryValue('format', msg.args[0])
                    return ircutils.standardSubstitute(irc, msg,
                                                       formatter, env)
                if len(factoids) == 1:
                    irc.reply(format_fact(prefixer(factoids[0][0])))
                else:
                    factoidsS = []
                    counter = 1
                    for factoid in factoids:
                        factoidsS.append(format('(#%i) %s', counter, 
                                format_fact(factoid[0])))
                        counter += 1
                    irc.replies(factoidsS, prefixer=prefixer,
                                joiner=', or ', onlyPrefixFirst=True)
                self._updateRank(channel, factoids)
        elif error:
            irc.error(_('No factoid matches that key.'))

    def _replyApproximateFactoids(self, irc, msg, channel, key, error=True):
        if self.registryValue('replyApproximateSearchKeys'):
            factoids = self._searchFactoid(channel, key)
            factoids.sort()
            if factoids:
                keylist = ["'%s'" % (fact,) for fact in factoids]
                keylist = ', '.join(keylist)
                irc.reply("I do not know about '%s', but I do know about these similar topics: %s" % (key, keylist))
            elif error:
                irc.error('No factoid matches that key.')

    def invalidCommand(self, irc, msg, tokens):
        if irc.isChannel(msg.args[0]):
            channel = msg.args[0]
            if self.registryValue('replyWhenInvalidCommand', channel):
                key = ' '.join(tokens)
                factoids = self._lookupFactoid(channel, key)
                if factoids:
                    self._replyFactoids(irc, msg, key, channel, factoids, error=False)
                else:
                    self._replyApproximateFactoids(irc, msg, channel, key, error=False)

    @internationalizeDocstring
    def whatis(self, irc, msg, args, channel, optlist, words):
        """[<channel>] [--raw] <key> [<number>]

        Looks up the value of <key> in the factoid database.  If given a
        number, will return only that exact factoid. If '--raw' option is
        given, no variable substitution will take place on the factoid.
        <channel> is only necessary if the message isn't sent in the channel
        itself.
        """
        raw = False
        for (option, arg) in optlist:
            if option == 'raw':
                raw = True
        number = None
        if len(words) > 1:
            if words[-1].isdigit():
                number = int(words.pop())
                if number <= 0:
                    irc.errorInvalid(_('key id'))
        key = ' '.join(words)
        factoids = self._lookupFactoid(channel, key)
        if factoids:
            self._replyFactoids(irc, msg, key, channel, factoids, number, raw=raw)
        else:
            self._replyApproximateFactoids(irc, msg, channel, key)
    whatis = wrap(whatis, ['channel',
                            getopts({'raw': '',}),
                            many('something')])

    @internationalizeDocstring
    def alias(self, irc, msg, args, channel, oldkey, newkey, number):
        """[<channel>] <oldkey> <newkey> [<number>]

        Adds a new key <newkey> for factoid associated with <oldkey>.
        <number> is only necessary if there's more than one factoid associated
        with <oldkey>.

        The same action can be accomplished by using the 'learn' function with
        a new key but an existing (verbatim) factoid content.
        """
        def _getNewKey(channel, newkey, arelation):
            db = self.getDb(channel)
            cursor = db.cursor()
            cursor.execute("""SELECT id FROM keys WHERE key=?""", (newkey,))
            newkey_info = cursor.fetchall()
            if len(newkey_info) == 1:
                # check if we already have the requested relation
                cursor.execute("""SELECT id FROM relations WHERE
                            key_id=? and fact_id=?""",
                            (arelation[1], arelation[2]))
                existentrelation = cursor.fetchall()
                if len(existentrelation) != 0:
                    newkey_info = False
            if len(newkey_info) == 0:
                cursor.execute("""INSERT INTO keys VALUES (NULL, ?)""",
                            (newkey,))
                db.commit()
                cursor.execute("""SELECT id FROM keys WHERE key=?""", (newkey,))
                newkey_info = cursor.fetchall()
            return newkey_info

        db = self.getDb(channel)
        cursor = db.cursor()
        cursor.execute("""SELECT relations.id, relations.key_id, relations.fact_id
                        FROM keys, relations
                        WHERE keys.key=? AND
                        relations.key_id=keys.id""", (oldkey,))
        results = cursor.fetchall()
        if len(results) == 0:
            irc.error(_('No factoid matches that key.'))
            return
        elif len(results) == 1:
            newkey_info = _getNewKey(channel, newkey, results[0])
            if newkey_info is not False:
                cursor.execute("""INSERT INTO relations VALUES(NULL, ?, ?, ?)""",
                            (newkey_info[0][0], results[0][2], 0,))
                irc.replySuccess()
            else:
                irc.error(_('This key-factoid relationship already exists.'))
        elif len(results) > 1:
            try:
                arelation = results[number-1]
            except IndexError:
                irc.error(_("That's not a valid number for that key."))
                return
            except TypeError:
                irc.error(_("This key has more than one factoid associated "
                        "with it, but you have not provided a number."))
                return
            newkey_info = _getNewKey(channel, newkey, arelation)
            if newkey_info is not False:
                cursor.execute("""INSERT INTO relations VALUES(NULL, ?, ?, ?)""",
                            (newkey_info[0][0], arelation[2], 0,))
                irc.replySuccess()
            else:
                irc.error(_('This key-factoid relationship already exists.'))
    alias = wrap(alias, ['channel', 'something', 'something', optional('int')])

    @internationalizeDocstring
    def rank(self, irc, msg, args, channel, optlist, number):
        """[<channel>] [--plain] [--alpha] [<number>]

        Returns a list of top-ranked factoid keys, sorted by usage count
        (rank). If <number> is not provided, the default number of factoid keys
        returned is set by the rankListLength registry value.

        If --plain option is given, rank numbers and usage counts are not
        included in output.

        If --alpha option is given in addition to --plain, keys are sorted
        alphabetically, instead of by rank.

        <channel> is only necessary if the message isn't sent in the channel
        itself.
        """
        if not number:
            number = self.registryValue('rankListLength', channel)
        db = self.getDb(channel)
        cursor = db.cursor()
        cursor.execute("""SELECT keys.key, relations.usage_count
                          FROM keys, relations
                          WHERE relations.key_id=keys.id
                          ORDER BY relations.usage_count DESC
                          LIMIT ?""", (number,))
        factkeys = cursor.fetchall()
        plain=False
        alpha=False
        for (option, arg) in optlist:
            if option == 'plain':
                plain = True
            elif option =='alpha':
                alpha = True
        if plain:
            s = [ "%s" % (key[0],) for i, key in enumerate(factkeys) ]
            if alpha:
                s.sort()
        else:
            s = [ "#%d %s (%d)" % (i+1, key[0], key[1]) for i, key in enumerate(factkeys) ]
        irc.reply(", ".join(s))
    rank = wrap(rank, ['channel', 
                        getopts({'plain': '', 'alpha': '',}), 
                        optional('int')])

    @internationalizeDocstring
    def lock(self, irc, msg, args, channel, key):
        """[<channel>] <key>

        Locks the factoid(s) associated with <key> so that they cannot be
        removed or added to.  <channel> is only necessary if the message isn't
        sent in the channel itself.
        """
        db = self.getDb(channel)
        cursor = db.cursor()
        cursor.execute("UPDATE factoids "
                "SET locked=1 WHERE factoids.id IN "
                "(SELECT fact_id FROM relations WHERE key_id IN "
                "(SELECT id FROM keys WHERE key LIKE ?));", (key,))
        db.commit()
        irc.replySuccess()
    lock = wrap(lock, ['channel', 'text'])

    @internationalizeDocstring
    def unlock(self, irc, msg, args, channel, key):
        """[<channel>] <key>

        Unlocks the factoid(s) associated with <key> so that they can be
        removed or added to.  <channel> is only necessary if the message isn't
        sent in the channel itself.
        """
        db = self.getDb(channel)
        cursor = db.cursor()
        cursor.execute("UPDATE factoids "
                "SET locked=0 WHERE factoids.id IN "
                "(SELECT fact_id FROM relations WHERE key_id IN "
                "(SELECT id FROM keys WHERE key LIKE ?));", (key,))
        db.commit()
        irc.replySuccess()
    unlock = wrap(unlock, ['channel', 'text'])

    def _deleteRelation(self, channel, relationlist):
        db = self.getDb(channel)
        cursor = db.cursor()
        for (keyid, factid, relationid) in relationlist:
            cursor.execute("""DELETE FROM relations where relations.id=?""",
                        (relationid,))
            db.commit()

            cursor.execute("""SELECT id FROM relations
                            WHERE relations.key_id=?""", (keyid,))
            remaining_key_relations = cursor.fetchall()
            if len(remaining_key_relations) == 0:
                cursor.execute("""DELETE FROM keys where id=?""", (keyid,))

            cursor.execute("""SELECT id FROM relations
                            WHERE relations.fact_id=?""", (factid,))
            remaining_fact_relations = cursor.fetchall()
            if len(remaining_fact_relations) == 0:
                cursor.execute("""DELETE FROM factoids where id=?""", (factid,))
            db.commit()

    @internationalizeDocstring
    def forget(self, irc, msg, args, channel, words):
        """[<channel>] <key> [<number>|*]

        Removes a key-fact relationship for key <key> from the factoids
        database.  If there is more than one such relationship for this key,
        a number is necessary to determine which one should be removed.
        A * can be used to remove all relationships for <key>.

        If as a result, the key (factoid) remains without any relationships to
        a factoid (key), it shall be removed from the database.

        <channel> is only necessary if
        the message isn't sent in the channel itself.
        """
        if self.registryValue('requireVoice', channel) and \
                not irc.state.channels[channel].isVoicePlus(msg.nick):
            irc.error(_('You have to be at least voiced to remove factoids.'))
        number = None
        if len(words) > 1:
            if words[-1].isdigit():
                number = int(words.pop())
                if number <= 0:
                    irc.errorInvalid(_('key id'))
            elif words[-1] == '*':
                words.pop()
                number = True
        key = ' '.join(words)
        db = self.getDb(channel)
        cursor = db.cursor()
        cursor.execute("""SELECT keys.id, factoids.id, relations.id
                        FROM keys, factoids, relations
                        WHERE key LIKE ? AND
                        relations.key_id=keys.id AND
                        relations.fact_id=factoids.id""", (key,))
        results = cursor.fetchall()
        if len(results) == 0:
            irc.error(_('There is no such factoid.'))
        elif len(results) == 1 or number is True:
            self._deleteRelation(channel, results)
            irc.replySuccess()
        else:
            if number is not None:
                #results = cursor.fetchall()
                try:
                    arelation = results[number-1]
                except IndexError:
                    irc.error(_('Invalid factoid number.'))
                    return
                self._deleteRelation(channel, [arelation,])
                irc.replySuccess()
            else:
                irc.error(_('%s factoids have that key.  '
                          'Please specify which one to remove, '
                          'or use * to designate all of them.') %
                          len(results))
    forget = wrap(forget, ['channel', many('something')])

    @internationalizeDocstring
    def random(self, irc, msg, args, channel):
        """[<channel>]

        Returns random factoids from the database for <channel>.  <channel>
        is only necessary if the message isn't sent in the channel itself.
        """
        db = self.getDb(channel)
        cursor = db.cursor()
        cursor.execute("""SELECT id, key_id, fact_id FROM relations
                          ORDER BY random()
                          LIMIT 3""")
        results = cursor.fetchall()
        if len(results) != 0:
            L = []
            for (relationid, keyid, factid) in results:
                cursor.execute("""SELECT keys.key, factoids.fact
                            FROM keys, factoids
                            WHERE factoids.id=? AND
                            keys.id=?""", (factid,keyid,))
                (key,factoid) = cursor.fetchall()[0]
                L.append('"%s": %s' % (ircutils.bold(key), factoid))
            irc.reply('; '.join(L))
        else:
            irc.error(_('I couldn\'t find a factoid.'))
    random = wrap(random, ['channel'])

    @internationalizeDocstring
    def info(self, irc, msg, args, channel, key):
        """[<channel>] <key>

        Gives information about the factoid(s) associated with <key>.
        <channel> is only necessary if the message isn't sent in the channel
        itself.
        """
        db = self.getDb(channel)
        cursor = db.cursor()
        cursor.execute("SELECT id FROM keys WHERE key LIKE ?", (key,))
        results = cursor.fetchall()
        if len(results) == 0:
            irc.error(_('No factoid matches that key.'))
            return
        id = results[0][0]
        cursor.execute("""SELECT factoids.added_by, factoids.added_at, factoids.locked, relations.usage_count
                        FROM factoids, relations
                        WHERE relations.key_id=? AND
                        relations.fact_id=factoids.id
                        ORDER BY relations.id""", (id,))
        factoids = cursor.fetchall()
        L = []
        counter = 0
        for (added_by, added_at, locked, usage_count) in factoids:
            counter += 1
            added_at = time.strftime(conf.supybot.reply.format.time(),
                                     time.localtime(int(added_at)))
            L.append(format(_('#%i was added by %s at %s, and has been '
                            'recalled %n'),
                            counter, added_by, added_at,
                            (usage_count, _('time'))))
        factoids = '; '.join(L)
        s = format('Key %q is %s and has %n associated with it: %s',
                   key, locked and 'locked' or 'not locked',
                   (counter, 'factoid'), factoids)
        irc.reply(s)
    info = wrap(info, ['channel', 'text'])

    @internationalizeDocstring
    def change(self, irc, msg, args, channel, key, number, replacer):
        """[<channel>] <key> <number> <regexp>

        Changes the factoid #<number> associated with <key> according to
        <regexp>.
        """
        db = self.getDb(channel)
        cursor = db.cursor()
        cursor.execute("""SELECT factoids.id, factoids.fact
                        FROM keys, factoids, relations
                        WHERE keys.key LIKE ? AND
                        keys.id=relations.key_id AND
                        factoids.id=relations.fact_id""", (key,))
        results = cursor.fetchall()
        if len(results) == 0:
            irc.error(format(_('I couldn\'t find any key %q'), key))
            return
        elif len(results) < number:
            irc.errorInvalid('key id')
        (id, fact) = results[number-1]
        newfact = replacer(fact)
        cursor.execute("UPDATE factoids SET fact=? WHERE id=?", (newfact, id))
        db.commit()
        irc.replySuccess()
    change = wrap(change, ['channel', 'something',
                           'factoidId', 'regexpReplacer'])

    _sqlTrans = utils.str.MultipleReplacer({'*': '%', '?': '_'})
    @internationalizeDocstring
    def search(self, irc, msg, args, channel, optlist, globs):
        """[<channel>] [--values] [--{regexp} <value>] [<glob> ...]

        Searches the keyspace for keys matching <glob>.  If --regexp is given,
        its associated value is taken as a regexp and matched against the keys.
        If --values is given, search the value space instead of the keyspace.
        """
        if not optlist and not globs:
            raise callbacks.ArgumentError
        tables = ['keys']
        formats = []
        criteria = []
        target = 'keys.key'
        predicateName = 'p'
        db = self.getDb(channel)
        for (option, arg) in optlist:
            if option == 'values':
                target = 'factoids.fact'
                if 'factoids' not in tables:
                    tables.append('factoids')
                    tables.append('relations')
                criteria.append('factoids.id=relations.fact_id AND keys.id=relations.key_id')
            elif option == 'regexp':
                criteria.append('%s(TARGET)' % predicateName)
                def p(s, r=arg):
                    return int(bool(r.search(s)))
                db.create_function(predicateName, 1, p)
                predicateName += 'p'
        for glob in globs:
            criteria.append('TARGET LIKE ?')
            formats.append(self._sqlTrans(glob))
        cursor = db.cursor()
        sql = """SELECT keys.key FROM %s WHERE %s""" % \
              (', '.join(tables), ' AND '.join(criteria))
        sql = sql + " ORDER BY keys.key"
        sql = sql.replace('TARGET', target)
        cursor.execute(sql, formats)
        if cursor.rowcount == 0:
            irc.reply(_('No keys matched that query.'))
        elif cursor.rowcount == 1 and \
             self.registryValue('showFactoidIfOnlyOneMatch', channel):
            self.whatis(irc, msg, [channel, cursor.fetchone()[0]])
        elif cursor.rowcount > 100:
            irc.reply(_('More than 100 keys matched that query; '
                      'please narrow your query.'))
        results = cursor.fetchall()
        if len(results) == 0:
            irc.reply(_('No keys matched that query.'))
        elif len(results) == 1 and \
             self.registryValue('showFactoidIfOnlyOneMatch', channel):
            self.whatis(irc, msg, [channel, results[0][0]])
        elif len(results) > 100:
            irc.reply(_('More than 100 keys matched that query; '
                      'please narrow your query.'))
        else:
            keys = [repr(t[0]) for t in results]
            s = format('%L', keys)
            irc.reply(s)
    search = wrap(search, ['channel',
                           getopts({'values': '', 'regexp': 'regexpMatcher'}),
                           any('glob')])


Class = Factoids


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# Copyright (c) 2010, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *
import supybot.conf as conf

import sqlite3

class FactoidsTestCase(ChannelPluginTestCase):
    plugins = ('Factoids',)
    def testRandomfactoid(self):
        self.assertError('random')
        self.assertNotError('learn jemfinch as my primary author')
        self.assertRegexp('random', 'primary author')

    def testLearn(self):
        self.assertError('learn as my primary author')
        self.assertError('learn jemfinch as')
        self.assertNotError('learn jemfinch as my primary author')
        self.assertNotError('info jemfinch')
        self.assertRegexp('whatis jemfinch', 'my primary author')
        self.assertRegexp('whatis JEMFINCH', 'my primary author')
        self.assertRegexp('whatis JEMFINCH 1', 'my primary author')
        self.assertNotError('learn jemfinch as a bad assembly programmer')
        self.assertRegexp('whatis jemfinch 2', 'bad assembly')
        self.assertNotRegexp('whatis jemfinch 2', 'primary author')
        self.assertRegexp('whatis jemfinch', r'.*primary author.*assembly')
        self.assertError('forget jemfinch')
        self.assertError('forget jemfinch 3')
        self.assertError('forget jemfinch 0')
        self.assertNotError('forget jemfinch 2')
        self.assertNotError('forget jemfinch 1')
        self.assertError('whatis jemfinch')
        self.assertError('info jemfinch')

        self.assertNotError('learn foo bar as baz')
        self.assertNotError('info foo bar')
        self.assertRegexp('whatis foo bar', 'baz')
        self.assertNotError('learn foo bar as quux')
        self.assertRegexp('whatis foo bar', '.*baz.*quux')
        self.assertError('forget foo bar')
        self.assertNotError('forget foo bar 2')
        self.assertNotError('forget foo bar 1')
        self.assertError('whatis foo bar')
        self.assertError('info foo bar')

        self.assertError('learn foo bar baz') # No 'as'
        self.assertError('learn foo bar') # No 'as'

        with conf.supybot.plugins.Factoids.requireVoice.context(True):
            self.assertError('learn jemfinch as my primary author')
            self.irc.feedMsg(ircmsgs.mode(self.channel,
                args=('+h', self.nick)))
            self.assertNotError('learn jemfinch as my primary author')

    def testChangeFactoid(self):
        self.assertNotError('learn foo as bar')
        self.assertNotError('change foo 1 s/bar/baz/')
        self.assertRegexp('whatis foo', 'baz')
        self.assertError('change foo 2 s/bar/baz/')
        self.assertError('change foo 0 s/bar/baz/')

    def testSearchFactoids(self):
        self.assertNotError('learn jemfinch as my primary author')
        self.assertNotError('learn strike as a cool guy working on me')
        self.assertNotError('learn inkedmn as another of my developers')
        self.assertNotError('learn jamessan as a developer of much python')
        self.assertNotError('learn bwp as author of my weather command')
        self.assertRegexp('factoids search --regexp /.w./', 'bwp')
        self.assertRegexp('factoids search --regexp /^.+i/',
                          'jemfinch.*strike')
        self.assertNotRegexp('factoids search --regexp /^.+i/', 'inkedmn')
        self.assertRegexp('factoids search --regexp m/j/ --regexp m/ss/',
                          'jamessan')
        self.assertRegexp('factoids search --regexp m/^j/ *ss*',
                          'jamessan')
        self.assertRegexp('factoids search --regexp /^j/',
                          'jamessan.*jemfinch')
        self.assertRegexp('factoids search j*', 'jamessan.*jemfinch')
        self.assertRegexp('factoids search *ke*',
                          'inkedmn.*strike|strike.*inkedmn')
        self.assertRegexp('factoids search ke',
                          'inkedmn.*strike|strike.*inkedmn')
        self.assertRegexp('factoids search jemfinch',
                          'my primary author')
        self.assertRegexp('factoids search --values primary author',
                          'my primary author')

    def testWhatisOnNumbers(self):
        self.assertNotError('learn 911 as emergency number')
        self.assertRegexp('whatis 911', 'emergency number')

    def testNotZeroIndexed(self):
        self.assertNotError('learn foo as bar')
        self.assertNotRegexp('info foo', '#0')
        self.assertNotRegexp('whatis foo', '#0')
        self.assertNotError('learn foo as baz')
        self.assertNotRegexp('info foo', '#0')
        self.assertNotRegexp('whatis foo', '#0')

    def testInfoReturnsRightNumber(self):
        self.assertNotError('learn foo as bar')
        self.assertNotRegexp('info foo', '2 factoids')

    def testInfoUsageCount(self):
        self.assertNotError('learn moo as cow')
        self.assertRegexp('info moo', 'recalled 0 times')
        self.assertNotError('whatis moo')
        self.assertRegexp('info moo', 'recalled 1 time')

    def testLearnSeparator(self):
        self.assertError('learn foo is bar')
        self.assertNotError('learn foo as bar')
        self.assertRegexp('whatis foo', 'bar')
        orig = conf.supybot.plugins.Factoids.learnSeparator()
        try:
            conf.supybot.plugins.Factoids.learnSeparator.setValue('is')
            self.assertError('learn bar as baz')
            self.assertNotError('learn bar is baz')
            self.assertRegexp('whatis bar', 'baz')
        finally:
            conf.supybot.plugins.Factoids.learnSeparator.setValue(orig)

    def testShowFactoidIfOnlyOneMatch(self):
        m1 = self.assertNotError('factoids search m/foo|bar/')
        orig = conf.supybot.plugins.Factoids.showFactoidIfOnlyOneMatch()
        try:
            conf.supybot.plugins.Factoids. \
                showFactoidIfOnlyOneMatch.setValue(False)
            m2 = self.assertNotError('factoids search m/foo/')
            self.failUnless(m1.args[1].startswith(m2.args[1]))
        finally:
            conf.supybot.plugins.Factoids. \
                showFactoidIfOnlyOneMatch.setValue(orig)

    def testInvalidCommand(self):
        self.assertNotError('learn foo as bar')
        self.assertRegexp('foo', 'bar')
        self.assertNotError('learn mooz as cowz')
        self.assertRegexp('moo', 'mooz')
        self.assertRegexp('mzo', 'mooz')
        self.assertRegexp('moz', 'mooz')
        self.assertNotError('learn moped as pretty fast')
        self.assertRegexp('moe', 'mooz.*moped')
        self.assertError('nosuchthing')
    
    def testWhatis(self):
        self.assertNotError('learn foo as bar')
        self.assertRegexp('whatis foo', 'bar')
        self.assertRegexp('whatis foob', 'foo')
        self.assertNotError('learn foob as barb')
        self.assertRegexp('whatis foom', 'foo.*foob')
    
    def testStandardSubstitute(self):
        self.assertNotError('learn foo as this is $channel, and hour is $hour')
        self.assertRegexp('whatis foo', 'this is #test, and hour is \d{1,2}')
        self.assertRegexp('whatis --raw foo', 'this is \$channel, and hour is \$hour')
        self.assertNotError('learn bar as this is $$channel escaped')
        self.assertRegexp('whatis bar', 'this is \$channel')
        self.assertNotError('learn bar as this is $minute')
        self.assertRegexp('whatis bar', '\$channel.*\d{1,2}')
        
    def testAlias(self):
        self.assertNotError('learn foo as bar')
        self.assertNotError('alias foo zoog')
        self.assertRegexp('whatis zoog', 'bar')
        self.assertNotError('learn foo as snorp')
        self.assertError('alias foo gnoop')
        self.assertNotError('alias foo gnoop 2')
        self.assertRegexp('whatis gnoop', 'snorp')
    
    def testRank(self):
        self.assertNotError('learn foo as bar')
        self.assertNotError('learn moo as cow')
        self.assertRegexp('factoids rank', '#1 foo \(0\), #2 moo \(0\)')
        self.assertRegexp('whatis moo', '.*cow.*')
        self.assertRegexp('factoids rank', '#1 moo \(1\), #2 foo \(0\)')
        self.assertRegexp('factoids rank 1', '#1 moo \(1\)')
        self.assertNotRegexp('factoids rank 1', 'foo')
        self.assertRegexp('factoids rank --plain', 'moo, foo')
        self.assertRegexp('factoids rank --plain --alpha', 'foo, moo')
        self.assertResponse('factoids rank --plain 1', 'moo')
    
    def testQuoteHandling(self):
        self.assertNotError('learn foo as "\\"bar\\""')
        self.assertRegexp('whatis foo', r'"bar"')

    def testLock(self):
        self.assertNotError('learn foo as bar')
        self.assertNotError('lock foo')
        self.assertNotError('unlock foo')


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2004, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Filter')

Filter = conf.registerPlugin('Filter')
conf.registerGroup(Filter, 'spellit')
conf.registerGlobalValue(Filter.spellit,
    'replaceLetters', registry.Boolean(True, _("""Determines whether or not to
    replace letters in the output of spellit.""")))
conf.registerGlobalValue(Filter.spellit,
    'replacePunctuation', registry.Boolean(True, _("""Determines whether or not
    to replace punctuation in the output of spellit.""")))
conf.registerGlobalValue(Filter.spellit,
    'replaceNumbers', registry.Boolean(True, _("""Determines whether or not to
    replace numbers in the output of spellit.""")))
conf.registerGroup(Filter, 'shrink')
conf.registerChannelValue(Filter.shrink, 'minimum',
    registry.PositiveInteger(4, _("""Determines the minimum number of a letters
    in a word before it will be shrunken by the shrink command/filter.""")))

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Filter', True)

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
# -*- encoding: utf-8 -*-
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import re
import sys
import codecs
import string
import random
from cStringIO import StringIO

import supybot.conf as conf
import supybot.utils as utils
from supybot.commands import *
import supybot.ircmsgs as ircmsgs
import supybot.ircutils as ircutils
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Filter')

class MyFilterProxy(object):
    def reply(self, s):
        self.s = s

class Filter(callbacks.Plugin):
    """This plugin offers several commands which transform text in some way.
    It also provides the capability of using such commands to 'filter' the
    output of the bot -- for instance, you could make everything the bot says
    be in leetspeak, or Morse code, or any number of other kinds of filters.
    Not very useful, but definitely quite fun :)"""
    def __init__(self, irc):
        self.__parent = super(Filter, self)
        self.__parent.__init__(irc)
        self.outFilters = ircutils.IrcDict()

    def outFilter(self, irc, msg):
        if msg.command == 'PRIVMSG':
            if msg.args[0] in self.outFilters:
                if ircmsgs.isAction(msg):
                    s = ircmsgs.unAction(msg)
                else:
                    s = msg.args[1]
                methods = self.outFilters[msg.args[0]]
                for filtercommand in methods:
                    myIrc = MyFilterProxy()
                    filtercommand(myIrc, msg, [s])
                    s = myIrc.s
                if ircmsgs.isAction(msg):
                    msg = ircmsgs.action(msg.args[0], s, msg=msg)
                else:
                    msg = ircmsgs.IrcMsg(msg=msg, args=(msg.args[0], s))
        return msg

    _filterCommands = ['jeffk', 'leet', 'rot13', 'hexlify', 'binary', 'lithp',
                       'scramble', 'morse', 'reverse', 'colorize', 'squish',
                       'supa1337', 'colorstrip', 'aol', 'rainbow', 'spellit',
                       'hebrew', 'undup', 'gnu', 'shrink', 'azn', 'uniud']
    @internationalizeDocstring
    def outfilter(self, irc, msg, args, channel, command):
        """[<channel>] [<command>]

        Sets the outFilter of this plugin to be <command>.  If no command is
        given, unsets the outFilter.  <channel> is only necessary if the
        message isn't sent in the channel itself.
        """
        if command:
            if not self.isDisabled(command) and \
               command in self._filterCommands:
                method = getattr(self, command)
                self.outFilters.setdefault(channel, []).append(method)
                irc.replySuccess()
            else:
                irc.error(_('That\'s not a valid filter command.'))
        else:
            self.outFilters[channel] = []
            irc.replySuccess()
    outfilter = wrap(outfilter,
                     [('checkChannelCapability', 'op'),
                      additional('commandName')])

    _hebrew_remover = utils.str.MultipleRemover('aeiou')
    @internationalizeDocstring
    def hebrew(self, irc, msg, args, text):
        """<text>

        Removes all the vowels from <text>.  (If you're curious why this is
        named 'hebrew' it's because I (jemfinch) thought of it in Hebrew class,
        and printed Hebrew often elides the vowels.)
        """
        irc.reply(self._hebrew_remover(text))
    hebrew = wrap(hebrew, ['text'])

    @internationalizeDocstring
    def squish(self, irc, msg, args, text):
        """<text>

        Removes all the spaces from <text>.
        """
        text = ''.join(text.split())
        irc.reply(text)
    squish = wrap(squish, ['text'])

    @internationalizeDocstring
    def undup(self, irc, msg, args, text):
        """<text>

        Returns <text>, with all consecutive duplicated letters removed.
        """
        L = [text[0]]
        for c in text:
            if c != L[-1]:
                L.append(c)
        irc.reply(''.join(L))
    undup = wrap(undup, ['text'])

    @internationalizeDocstring
    def binary(self, irc, msg, args, text):
        """<text>

        Returns the binary representation of <text>.
        """
        L = []
        if sys.version_info[0] >= 3:
            print(repr(text))
            if isinstance(text, str):
                bytes_ = text.encode()
            else:
                bytes_ = text
        else:
            if isinstance(text, unicode):
                text = text.encode()
            bytes_ = map(ord, text)
        for i in bytes_:
            LL = []
            assert i<=256
            counter = 8
            while i:
                counter -= 1
                if i & 1:
                    LL.append('1')
                else:
                    LL.append('0')
                i >>= 1
            while counter:
                LL.append('0')
                counter -= 1
            LL.reverse()
            L.extend(LL)
        irc.reply(''.join(L))
    binary = wrap(binary, ['text'])

    def unbinary(self, irc, msg, args, text):
        """<text>

        Returns the character representation of binary <text>.
        Assumes ASCII, 8 digits per character.
        """
        try:
            L = [chr(int(text[i:(i+8)], 2)) for i in xrange(0, len(text), 8)]
            irc.reply(''.join(L))
        except ValueError:
            irc.errorInvalid('binary string', text)
    unbinary = wrap(unbinary, ['text'])

    _hex_encoder = staticmethod(codecs.getencoder('hex_codec'))
    def hexlify(self, irc, msg, args, text):
        """<text>

        Returns a hexstring from the given string; a hexstring is a string
        composed of the hexadecimal value of each character in the string
        """
        irc.reply(self._hex_encoder(text.encode('utf8'))[0].decode('utf8'))
    hexlify = wrap(hexlify, ['text'])

    _hex_decoder = staticmethod(codecs.getdecoder('hex_codec'))
    @internationalizeDocstring
    def unhexlify(self, irc, msg, args, text):
        """<hexstring>

        Returns the string corresponding to <hexstring>.  Obviously,
        <hexstring> must be a string of hexadecimal digits.
        """
        try:
            irc.reply(self._hex_decoder(text.encode('utf8'))[0]
                    .decode('utf8', 'replace'))
        except TypeError:
            irc.error(_('Invalid input.'))
    unhexlify = wrap(unhexlify, ['text'])

    _rot13_encoder = codecs.getencoder('rot-13')
    @internationalizeDocstring
    def rot13(self, irc, msg, args, text):
        """<text>

        Rotates <text> 13 characters to the right in the alphabet.  Rot13 is
        commonly used for text that simply needs to be hidden from inadvertent
        reading by roaming eyes, since it's easily reversible.
        """
        if sys.version_info[0] < 3:
            text = text.decode('utf8')
        irc.reply(self._rot13_encoder(text)[0])
    rot13 = wrap(rot13, ['text'])

    @internationalizeDocstring
    def lithp(self, irc, msg, args, text):
        """<text>

        Returns the lisping version of <text>
        """
        text = text.replace('sh', 'th')
        text = text.replace('SH', 'TH')
        text = text.replace('Sh', 'Th')
        text = text.replace('ss', 'th')
        text = text.replace('SS', 'TH')
        text = text.replace('s', 'th')
        text = text.replace('z', 'th')
        text = text.replace('S', 'Th')
        text = text.replace('Z', 'Th')
        text = text.replace('x', 'kth')
        text = text.replace('X', 'KTH')
        text = text.replace('cce', 'kth')
        text = text.replace('CCE', 'KTH')
        text = text.replace('tion', 'thion')
        text = text.replace('TION', 'THION')
        irc.reply(text)
    lithp = wrap(lithp, ['text'])

    _leettrans = utils.str.MultipleReplacer(dict(list(zip('oOaAeElBTiIts',
                                                     '004433187!1+5'))))
    _leetres = [(re.compile(r'\b(?:(?:[yY][o0O][oO0uU])|u)\b'), 'j00'),
                (re.compile(r'fear'), 'ph33r'),
                (re.compile(r'[aA][tT][eE]'), '8'),
                (re.compile(r'[aA][tT]'), '@'),
                (re.compile(r'[sS]\b'), 'z'),
                (re.compile(r'x'), '><'),]
    @internationalizeDocstring
    def leet(self, irc, msg, args, text):
        """<text>

        Returns the l33tspeak version of <text>
        """
        for (r, sub) in self._leetres:
            text = re.sub(r, sub, text)
        text = self._leettrans(text)
        irc.reply(text)
    leet = wrap(leet, ['text'])

    _supaleetreplacers = [('xX', '><'), ('kK', '|<'), ('rR', '|2'),
                          ('hH', '|-|'), ('L', '|_'), ('uU', '|_|'),
                          ('O', '()'), ('nN', '|\\|'), ('mM', '/\\/\\'),
                          ('G', '6'), ('Ss', '$'), ('i', ';'), ('aA', '/-\\'),
                          ('eE', '3'), ('t', '+'), ('T', '7'), ('l', '1'),
                          ('D', '|)'), ('B', '|3'), ('I', ']['), ('Vv', '\\/'),
                          ('wW', '\\/\\/'), ('d', 'c|'), ('b', '|>'),
                          ('c', '<'), ('h', '|n'),]
    @internationalizeDocstring
    def supa1337(self, irc, msg, args, text):
        """<text>

        Replies with an especially k-rad translation of <text>.
        """
        for (r, sub) in self._leetres:
            text = re.sub(r, sub, text)
        for (letters, replacement) in self._supaleetreplacers:
            for letter in letters:
                text = text.replace(letter, replacement)
        irc.reply(text)
    supa1337 = wrap(supa1337, ['text'])

    _scrambleRe = re.compile(r'(?:\b|(?![a-zA-Z]))([a-zA-Z])([a-zA-Z]*)'
                             r'([a-zA-Z])(?:\b|(?![a-zA-Z]))')
    @internationalizeDocstring
    def scramble(self, irc, msg, args, text):
        """<text>

        Replies with a string where each word is scrambled; i.e., each internal
        letter (that is, all letters but the first and last) are shuffled.
        """
        def _subber(m):
            L = list(m.group(2))
            random.shuffle(L)
            return '%s%s%s' % (m.group(1), ''.join(L), m.group(3))
        s = self._scrambleRe.sub(_subber, text)
        irc.reply(s)
    scramble = wrap(scramble, ['text'])

    _morseCode = {
        "A" : ".-",
        "B" : "-...",
        "C" : "-.-.",
        "D" : "-..",
        "E" : ".",
        "F" : "..-.",
        "G" : "--.",
        "H" : "....",
        "I" : "..",
        "J" : ".---",
        "K" : "-.-",
        "L" : ".-..",
        "M" : "--",
        "N" : "-.",
        "O" : "---",
        "P" : ".--.",
        "Q" : "--.-",
        "R" : ".-.",
        "S" : "...",
        "T" : "-",
        "U" : "..-",
        "V" : "...-",
        "W" : ".--",
        "X" : "-..-",
        "Y" : "-.--",
        "Z" : "--..",
        "0" : "-----",
        "1" : ".----",
        "2" : "..---",
        "3" : "...--",
        "4" : "....-",
        "5" : ".....",
        "6" : "-....",
        "7" : "--...",
        "8" : "---..",
        "9" : "----.",
        "." : ".-.-.-",
        "," : "--..--",
        ":" : "---...",
        "?" : "..--..",
        "'" : ".----.",
        "-" : "-....-",
        "/" : "-..-.",
        '"' : ".-..-.",
        "@" : ".--.-.",
        "=" : "-...-"
    }
    _revMorseCode = dict([(y, x) for (x, y) in _morseCode.items()])
    _unmorsere = re.compile('([.-]+)')
    @internationalizeDocstring
    def unmorse(self, irc, msg, args, text):
        """<Morse code text>

        Does the reverse of the morse command.
        """
        text = text.replace('_', '-')
        def morseToLetter(m):
            s = m.group(1)
            return self._revMorseCode.get(s, s)
        text = self._unmorsere.sub(morseToLetter, text)
        text = text.replace('  ', '\x00')
        text = text.replace(' ', '')
        text = text.replace('\x00', ' ')
        irc.reply(text)
    unmorse = wrap(unmorse, ['text'])

    @internationalizeDocstring
    def morse(self, irc, msg, args, text):
        """<text>

        Gives the Morse code equivalent of a given string.
        """
        L = []
        for c in text.upper():
            L.append(self._morseCode.get(c, c))
        irc.reply(' '.join(L))
    morse = wrap(morse, ['text'])

    @internationalizeDocstring
    def reverse(self, irc, msg, args, text):
        """<text>

        Reverses <text>.
        """
        irc.reply(text[::-1])
    reverse = wrap(reverse, ['text'])

    @internationalizeDocstring
    def _color(self, c, fg=None):
        if c == ' ':
            return c
        if fg is None:
            fg = random.randint(2, 15)
        fg = str(fg).zfill(2)
        return '\x03%s%s' % (fg, c)

    @internationalizeDocstring
    def colorize(self, irc, msg, args, text):
        """<text>

        Returns <text> with each character randomly colorized.
        """
        L = [self._color(c) for c in text]
        irc.reply('%s%s' % (''.join(L), '\x03'))
    colorize = wrap(colorize, ['text'])

    @internationalizeDocstring
    def rainbow(self, irc, msg, args, text):
        """<text>

        Returns <text> colorized like a rainbow.
        """
        if sys.version_info[0] < 3:
            text = text.decode('utf-8')
        colors = utils.iter.cycle(['04', '07', '08', '03', '02', '12', '06'])
        L = [self._color(c, fg=next(colors)) for c in text]
        if sys.version_info[0] < 3:
            L = [c.encode('utf-8') for c in L]
        irc.reply(''.join(L) + '\x03')
    rainbow = wrap(rainbow, ['text'])

    @internationalizeDocstring
    def stripcolor(self, irc, msg, args, text):
        """<text>

        Returns <text> stripped of all color codes.
        """
        irc.reply(ircutils.stripColor(text))
    stripcolor = wrap(stripcolor, ['text'])

    @internationalizeDocstring
    def aol(self, irc, msg, args, text):
        """<text>

        Returns <text> as if an AOLuser had said it.
        """
        text = text.replace(' you ', ' u ')
        text = text.replace(' are ', ' r ')
        text = text.replace(' love ', ' <3 ')
        text = text.replace(' luv ', ' <3 ')
        text = text.replace(' too ', ' 2 ')
        text = text.replace(' to ', ' 2 ')
        text = text.replace(' two ', ' 2 ')
        text = text.replace('fore', '4')
        text = text.replace(' for ', ' 4 ')
        text = text.replace('be', 'b')
        text = text.replace('four', ' 4 ')
        text = text.replace(' their ', ' there ')
        text = text.replace(', ', ' ')
        text = text.replace(',', ' ')
        text = text.replace("'", '')
        text = text.replace('one', '1')
        smiley = utils.iter.choice(['<3', ':)', ':-)', ':D', ':-D'])
        text += smiley*3
        irc.reply(text)
    aol = wrap(aol, ['text'])

    @internationalizeDocstring
    def jeffk(self, irc, msg, args, text):
        """<text>

        Returns <text> as if JeffK had said it himself.
        """
        def randomlyPick(L):
            return utils.iter.choice(L)
        def quoteOrNothing(m):
            return randomlyPick(['"', '']).join(m.groups())
        def randomlyReplace(s, probability=0.5):
            def f(m):
                if random.random() < probability:
                    return m.expand(s)
                else:
                    return m.group(0)
            return f
        def randomExclaims(m):
            if random.random() < 0.85:
                return ('!' * random.randrange(1, 5)) + m.group(1)
            else:
                return '.' + m.group(1)
        def randomlyShuffle(m):
            L = list(m.groups())
            random.shuffle(L)
            return ''.join(L)
        def lessRandomlyShuffle(m):
            L = list(m.groups())
            if random.random() < .4:
                random.shuffle(L)
            return ''.join(L)
        def randomlyLaugh(text, probability=.3):
            if random.random() < probability:
                if random.random() < .5:
                    insult = utils.iter.choice([' fagot1', ' fagorts',
                                                ' jerks', 'fagot' ' jerk',
                                                'dumbshoes', ' dumbshoe'])
                else:
                    insult = ''
                laugh1 = utils.iter.choice(['ha', 'hah', 'lol', 'l0l', 'ahh'])
                laugh2 = utils.iter.choice(['ha', 'hah', 'lol', 'l0l', 'ahh'])
                laugh1 = laugh1 * random.randrange(1, 5)
                laugh2 = laugh2 * random.randrange(1, 5)
                exclaim = utils.iter.choice(['!', '~', '!~', '~!!~~',
                                             '!!~', '~~~!'])
                exclaim += utils.iter.choice(['!', '~', '!~', '~!!~~',
                                              '!!~', '~~~!'])
                if random.random() < 0.5:
                    exclaim += utils.iter.choice(['!', '~', '!~', '~!!~~',
                                                  '!!~', '~~~!'])
                laugh = ''.join([' ', laugh1, laugh2, insult, exclaim])
                text += laugh
            return text
        if random.random() < .03:
            irc.reply(randomlyLaugh('NO YUO', probability=1))
            return
        alwaysInsertions = {
            r'er\b': 'ar',
            r'\bthe\b': 'teh',
            r'\byou\b': 'yuo',
            r'\bis\b': 'si',
            r'\blike\b': 'liek',
            r'[^e]ing\b': 'eing',
            }
        for (r, s) in alwaysInsertions.iteritems():
            text = re.sub(r, s, text)
        randomInsertions = {
            r'i': 'ui',
            r'le\b': 'al',
            r'i': 'io',
            r'l': 'll',
            r'to': 'too',
            r'that': 'taht',
            r'[^s]c([ei])': r'sci\1',
            r'ed\b': r'e',
            r'\band\b': 'adn',
            r'\bhere\b': 'hear',
            r'\bthey\'re': 'their',
            r'\bthere\b': 'they\'re',
            r'\btheir\b': 'there',
            r'[^e]y': 'ey',
            }
        for (r, s) in randomInsertions.iteritems():
            text = re.sub(r, randomlyReplace(s), text)
        text = re.sub(r'(\w)\'(\w)', quoteOrNothing, text)
        text = re.sub(r'\.(\s+|$)', randomExclaims, text)
        text = re.sub(r'([aeiou])([aeiou])', randomlyShuffle, text)
        text = re.sub(r'([bcdfghkjlmnpqrstvwxyz])([bcdfghkjlmnpqrstvwxyz])',
                      lessRandomlyShuffle, text)
        text = randomlyLaugh(text)
        if random.random() < .4:
            text = text.upper()
        irc.reply(text)
    jeffk = wrap(jeffk, ['text'])

    # Keeping these separate so people can just replace the alphabets for
    # whatever their language of choice
    _spellLetters = {
        'a': _('ay'), 'b': _('bee'), 'c': _('see'), 'd': _('dee'),
        'e': _('ee'), 'f': _('eff'), 'g': _('gee'), 'h': _('aych'),
        'i': _('eye'), 'j': _('jay'), 'k': _('kay'), 'l': _('ell'),
        'm': _('em'), 'n': _('en'), 'o': _('oh'), 'p': _('pee'), 'q': _('cue'),
        'r': _('arr'), 's': _('ess'), 't': _('tee'), 'u': _('you'),
        'v': _('vee'), 'w': _('double-you'), 'x': _('ecks'), 'y': _('why'),
        'z': _('zee')
    }
    for (k, v) in _spellLetters.items():
        _spellLetters[k.upper()] = v
    _spellPunctuation = {
        '!': _('exclamation point'),
        '"': _('quote'),
        '#': _('pound'),
        '$': _('dollar sign'),
        '%': _('percent'),
        '&': _('ampersand'),
        '\'': _('single quote'),
        '(': _('left paren'),
        ')': _('right paren'),
        '*': _('asterisk'),
        '+': _('plus'),
        ',': _('comma'),
        '-': _('minus'),
        '.': _('period'),
        '/': _('slash'),
        ':': _('colon'),
        ';': _('semicolon'),
        '<': _('less than'),
        '=': _('equals'),
        '>': _('greater than'),
        '?': _('question mark'),
        '@': _('at'),
        '[': _('left bracket'),
        '\\': _('backslash'),
        ']': _('right bracket'),
        '^': _('caret'),
        '_': _('underscore'),
        '`': _('backtick'),
        '{': _('left brace'),
        '|': _('pipe'),
        '}': _('right brace'),
        '~': _('tilde')
    }
    _spellNumbers = {
        '0': _('zero'), '1': _('one'), '2': _('two'), '3': _('three'), 
        '4': _('four'), '5': _('five'), '6': _('six'), '7': _('seven'),
        '8': _('eight'), '9': _('nine')
    }
    @internationalizeDocstring
    def spellit(self, irc, msg, args, text):
        """<text>

        Returns <text>, phonetically spelled out.
        """
        d = {}
        if self.registryValue('spellit.replaceLetters'):
            d.update(self._spellLetters)
        if self.registryValue('spellit.replaceNumbers'):
            d.update(self._spellNumbers)
        if self.registryValue('spellit.replacePunctuation'):
            d.update(self._spellPunctuation)
# A bug in unicode on OSX prevents me from testing this.
##         dd = {}
##         for (c, v) in d.iteritems():
##             dd[ord(c)] = unicode(v + ' ')
##         irc.reply(unicode(text).translate(dd))
        out = StringIO()
        write = out.write
        for c in text:
            try:
                c = d[c]
                write(' ')
            except KeyError:
                pass
            write(c)
        irc.reply(out.getvalue())
    spellit = wrap(spellit, ['text'])

    @internationalizeDocstring
    def gnu(self, irc, msg, args, text):
        """<text>

        Returns <text> as GNU/RMS would say it.
        """
        irc.reply(' '.join(['GNU/' + s for s in text.split()]))
    gnu = wrap(gnu, ['text'])

    @internationalizeDocstring
    def shrink(self, irc, msg, args, text):
        """<text>

        Returns <text> with each word longer than
        supybot.plugins.Filter.shrink.minimum being shrunken (i.e., like
        "internationalization" becomes "i18n").
        """
        L = []
        minimum = self.registryValue('shrink.minimum', msg.args[0])
        r = re.compile(r'[A-Za-z]{%s,}' % minimum)
        def shrink(m):
            s = m.group(0)
            return ''.join((s[0], str(len(s)-2), s[-1]))
        text = r.sub(shrink, text)
        irc.reply(text)
    shrink = wrap(shrink, ['text'])

    _azn_trans = utils.str.MultipleReplacer(dict(list(zip('rlRL', 'lrLR'))))
    @internationalizeDocstring
    def azn(self, irc, msg, args, text):
        """<text>

        Returns <text> with the l's made into r's and r's made into l's.
        """
        text = self._azn_trans(text)
        irc.reply(text)
    azn = wrap(azn, ['text'])

    # TODO: 2,4,;
    # XXX suckiest: B,K,P,Q,T
    # alternatives: 3: U+2107
    _uniudMap = {
    ' ': u' ',      '0': u'0',      '@': u'@',
    '!': u'\u00a1', '1': u'1',      'A': u'\u2200',
    '"': u'\u201e', '2': u'\u2681', 'B': u'q',
    '#': u'#',      '3': u'\u0190', 'C': u'\u0186',
    '$': u'$',      '4': u'\u2683', 'D': u'\u15e1',
    '%': u'%',      '5': u'\u1515', 'E': u'\u018e',
    '&': u'\u214b', '6': u'9',      'F': u'\u2132',
    "'": u'\u0375', '7': u'L',      'G': u'\u2141',
    '(': u')',      '8': u'8',      'H': u'H',
    ')': u'(',      '9': u'6',      'I': u'I',
    '*': u'*',      ':': u':',      'J': u'\u148b',
    '+': u'+',      ';': u';',      'K': u'\u029e',
    ',': u'\u2018', '<': u'>',      'L': u'\u2142',
    '-': u'-',      '=': u'=',      'M': u'\u019c',
    '.': u'\u02d9', '>': u'<',      'N': u'N',
    '/': u'/',      '?': u'\u00bf', 'O': u'O',

    'P': u'd',      '`': u'\u02ce', 'p': u'd',
    'Q': u'b',      'a': u'\u0250', 'q': u'b',
    'R': u'\u1d1a', 'b': u'q',      'r': u'\u0279',
    'S': u'S',      'c': u'\u0254', 's': u's',
    'T': u'\u22a5', 'd': u'p',      't': u'\u0287',
    'U': u'\u144e', 'e': u'\u01dd', 'u': u'n',
    'V': u'\u039b', 'f': u'\u214e', 'v': u'\u028c',
    'W': u'M',      'g': u'\u0253', 'w': u'\u028d',
    'X': u'X',      'h': u'\u0265', 'x': u'x',
    'Y': u'\u2144', 'i': u'\u1d09', 'y': u'\u028e',
    'Z': u'Z',      'j': u'\u027f', 'z': u'z',
    '[': u']',      'k': u'\u029e', '{': u'}',
    '\\': u'\\',    'l': u'\u05df', '|': u'|',
    ']': u'[',      'm': u'\u026f', '}': u'{',
    '^': u'\u2335', 'n': u'u',      '~': u'~',
    '_': u'\u203e', 'o': u'o',
    }

    @internationalizeDocstring
    def uniud(self, irc, msg, args, text):
        """<text>

        Returns <text> rotated 180 degrees. Only really works for ASCII
        printable characters.
        """
        turned = []
        tlen = 0
        for c in text:
            if c in self._uniudMap:
                tmp = self._uniudMap[c]
                if not len(tmp):
                    tmp = u'\ufffd'
                turned.insert(0, tmp)
                tlen += 1
            elif c == '\t':
                tablen = 8 - tlen % 8
                turned.insert(0, ' ' * tablen)
                tlen += tablen
            elif ord(c) >= 32:
                turned.insert(0, c)
                tlen += 1
        s = '%s \x02 \x02' % ''.join(turned)
        irc.reply(s)
    uniud = wrap(uniud, ['text'])
Filter = internationalizeDocstring(Filter)

Class = Filter


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
# -*- coding: utf8 -*-
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

import re
import codecs

import supybot.utils as utils
import supybot.callbacks as callbacks

class FilterTest(ChannelPluginTestCase):
    plugins = ('Filter', 'Utilities', 'Reply')
    def testNoErrors(self):
        self.assertNotError('leet foobar')
        self.assertNotError('supa1337 foobar')
        self.assertNotError('lithp meghan sweeney')
        self.assertNotError('aol I\'m too legit to quit.')

    def testDisabledCommandsCannotFilter(self):
        self.assertNotError('outfilter rot13')
        self.assertResponse('echo foo', 'sbb')
        self.assertNotError('outfilter')
        try:
            self.assertNotError('disable rot13')
            self.assertError('outfilter rot13')
            self.assertNotError('enable rot13')
            self.assertNotError('outfilter rot13')
        finally:
            try:
                callbacks.Plugin._disabled.remove('rot13')
            except KeyError:
                pass

    def testHebrew(self):
        self.assertResponse('hebrew The quick brown fox '
                            'jumps over the lazy dog.',
                            'Th qck brwn fx jmps vr th lzy dg.')
    def testJeffk(self):
        for i in range(100):
            self.assertNotError('jeffk the quick brown fox is ghetto')

    def testSquish(self):
        self.assertResponse('squish foo bar baz', 'foobarbaz')
        self.assertResponse('squish "foo bar baz"', 'foobarbaz')

    def testUndup(self):
        self.assertResponse('undup foo bar baz quux', 'fo bar baz qux')
        self.assertResponse('undup aaaaaaaaaa', 'a')

    def testLithp(self):
        self.assertResponse('lithp jamessan', 'jamethan')
        self.assertResponse('lithp Shame', 'Thame')

    def testMorse(self):
        self.assertResponse('unmorse [morse jemfinch]', 'JEMFINCH')

    def testReverse(self):
        for s in map(str, range(1000, 1010)):
            self.assertResponse('reverse %s' % s, s[::-1])

    def testBinary(self):
        self.assertResponse('binary A', '01000001')
    
    def testUnbinary(self):
        self.assertResponse('unbinary 011011010110111101101111', 'moo')

    def testUnbinary(self):
        self.assertResponse('unbinary 011011010110111101101111', 'moo')
        self.assertError('unbinary moo')

    def testRot13(self):
        for s in map(str, range(1000, 1010)):
            self.assertResponse('rot13 [rot13 %s]' % s, s)

    def testRot13HandlesNonAsciiStuff(self):
        self.assertNotError(u'rot13 é')

    def testHexlifyUnhexlify(self):
        for s in map(str, range(1000, 1010)):
            self.assertResponse('unhexlify [hexlify %s]' % s, s)
        self.assertNotError('unhexlify ff')

    def testScramble(self):
        s = 'the recalcitrant jamessan tests his scramble function'
        self.assertNotRegexp('scramble %s' % s, s)
        s = 'the recalc1trant jam3ssan tests his scramble fun><tion'
        self.assertNotRegexp('scramble %s' % s, s)

    def testColorize(self):
        self.assertNotRegexp('colorize foobar', r'\s+')
        self.assertRegexp('colorize foobar', r'\x03')
        # Make sure we're closing colorize with an 'end color' marker
        self.assertRegexp('colorize foobar', r'\x03$')

    _strings = ('Supybot pwns!', '123456', 'A string with \x02bold\x15')
    def testColorstrip(self):
        for s in self._strings:
            self.assertResponse('stripcolor [colorize %s]' % s, s)

    def testSpellit(self):
        self.assertRegexp('spellit abc123!.%', 'ay bee see one two three '
                          'exclamation point period percent')
        self.assertNotError('config plugins.Filter.spellit.replaceLetters off')
        self.assertRegexp('spellit asasdfasdf12345@#$!%^',
                          'asasdfasdf one two three four five at pound '
                          'dollar sign exclamation point percent caret')
        self.assertNotError('config plugins.Filter.spellit.replaceNumbers off')
        self.assertRegexp('spellit asasdfasdf12345@#$!%^',
                          'asasdfasdf12345 at pound dollar sign exclamation '
                          'point percent caret')
        self.assertNotError('config '
                            'plugins.Filter.spellit.replacePunctuation off')
        self.assertResponse('spellit asasdfasdf12345@#$!%^',
                            'asasdfasdf12345@#$!%^')

    _rot13_encoder = codecs.getencoder('rot-13')
    def testOutfilter(self):
        s = self._rot13_encoder(self.nick)[0]
        self.assertNotError('outfilter rot13')
        self.assertResponse('rot13 foobar', '%s: foobar' % s)
        self.assertNotError('outfilter rot13')
        self.assertResponse('rot13 foobar', 'sbbone')
        self.assertNotError('outfilter')
        self.assertResponse('rot13 foobar', 'sbbone')
        self.assertNotError('outfilter ROT13')
        self.assertResponse('rot13 foobar', '%s: foobar' % s)
        self.assertNotError('outfilter')
        self.assertResponse('rot13 foobar', 'sbbone')

    def testOutfilterAction(self):
        s = self._rot13_encoder(self.nick)[0]
        self.assertNotError('outfilter rot13')
        self.assertResponse('rot13 foobar', '%s: foobar' % s)
        m = self.getMsg('action foobar')
        self.failUnless(ircmsgs.isAction(m))
        s = ircmsgs.unAction(m)
        self.assertEqual(s, 'sbbone')

    def testGnu(self):
        self.assertResponse('gnu foo bar baz', 'GNU/foo GNU/bar GNU/baz')
        self.assertNotError('outfilter gnu')
        self.assertResponse('echo foo bar baz', 'GNU/foo GNU/bar GNU/baz')
        self.assertNotError('outfilter')

    def testShrink(self):
        self.assertResponse('shrink I love you', 'I l2e you')
        self.assertResponse('shrink internationalization', 'i18n')
        self.assertResponse('shrink "I love you"', 'I l2e you')
        self.assertResponse('shrink internationalization, localization',
                            'i18n, l10n')

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2004, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Format')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Format', True)


Format = conf.registerPlugin('Format')
# This is where your configuration variables (if any) should go.  For example:
# conf.registerGlobalValue(Format, 'someConfigVariableName',
#     registry.Boolean(False, """Help for someConfigVariableName."""))


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2004-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import string

import supybot.conf as conf
import supybot.utils as utils
from supybot.commands import *
import supybot.ircutils as ircutils
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Format')

class Format(callbacks.Plugin):
    @internationalizeDocstring
    def bold(self, irc, msg, args, text):
        """<text>

        Returns <text> bolded.
        """
        irc.reply(ircutils.bold(text))
    bold = wrap(bold, ['text'])

    @wrap(['text'])
    def stripformatting(self, irc, msg, args, text):
        """<text>

        Strips bold, underline, and colors from <text>."""
        irc.reply(ircutils.stripFormatting(text))

    @internationalizeDocstring
    def reverse(self, irc, msg, args, text):
        """<text>

        Returns <text> in reverse-video.
        """
        irc.reply(ircutils.reverse(text))
    reverse = wrap(reverse, ['text'])

    @internationalizeDocstring
    def underline(self, irc, msg, args, text):
        """<text>

        Returns <text> underlined.
        """
        irc.reply(ircutils.underline(text))
    underline = wrap(underline, ['text'])

    @internationalizeDocstring
    def color(self, irc, msg, args, fg, bg, text):
        """<foreground> [<background>] <text>

        Returns <text> with foreground color <foreground> and background color
        <background> (if given)
        """
        irc.reply(ircutils.mircColor(text, fg=fg, bg=bg))
    color = wrap(color, ['color', optional('color'), 'text'])

    @internationalizeDocstring
    def join(self, irc, msg, args, sep):
        """<separator> <string 1> [<string> ...]

        Joins all the arguments together with <separator>.
        """
        irc.reply(sep.join(args))
    join = wrap(join, ['anything'], allowExtra=True)

    @internationalizeDocstring
    def translate(self, irc, msg, args, bad, good, text):
        """<chars to translate> <chars to replace those with> <text>

        Replaces <chars to translate> with <chars to replace those with> in
        <text>.  The first and second arguments must necessarily be the same
        length.
        """
        if len(bad) != len(good):
            irc.error(_('<chars to translate> must be the same length as '
                      '<chars to replace those with>.'), Raise=True)
        irc.reply(utils.str.MultipleReplacer(dict(list(zip(bad, good))))(text))
    translate = wrap(translate, ['something', 'something', 'text'])

    @internationalizeDocstring
    def replace(self, irc, msg, args, bad, good, text):
        """<substring to translate> <substring to replace it with> <text>

        Replaces all non-overlapping occurrences of <substring to translate>
        with <substring to replace it with> in <text>.
        """
        irc.reply(text.replace(bad, good))
    replace = wrap(replace, ['something', 'something', 'text'])

    def upper(self, irc, msg, args, text):
        """<text>

        Returns <text> uppercased.
        """
        irc.reply(text.upper())
    upper = wrap(upper, ['text'])

    @internationalizeDocstring
    def lower(self, irc, msg, args, text):
        """<text>

        Returns <text> lowercased.
        """
        irc.reply(text.lower())
    lower = wrap(lower, ['text'])

    @internationalizeDocstring
    def capitalize(self, irc, msg, args, text):
        """<text>

        Returns <text> capitalized.
        """
        irc.reply(text.capitalize())
    capitalize = wrap(capitalize, ['text'])

    @internationalizeDocstring
    def title(self, irc, msg, args, text):
        """<text>

        Returns <text> titlecased.
        """
        irc.reply(text.title())
    title = wrap(title, ['text'])

    @internationalizeDocstring
    def repr(self, irc, msg, args, text):
        """<text>

        Returns <text> surrounded by double quotes.
        """
        irc.reply(utils.str.dqrepr(text))
    repr = wrap(repr, ['text'])

    @internationalizeDocstring
    def concat(self, irc, msg, args, first, second):
        """<string 1> <string 2>

        Concatenates two strings.  Do keep in mind that this is *not* the same
        thing as join "", since if <string 2> contains spaces, they won't be
        removed by concat.
        """
        irc.reply(first+second)
    concat = wrap(concat, ['something', 'text'])

    @internationalizeDocstring
    def cut(self, irc, msg, args, size, text):
        """<size> <text>

        Cuts <text> down to <size> by chopping off the rightmost characters in
        excess of <size>.  If <size> is a negative number, it chops that many
        characters off the end of <text>.
        """
        irc.reply(text[:size])
    cut = wrap(cut, ['int', 'text'])

    @internationalizeDocstring
    def field(self, irc, msg, args, index, text):
        """<number> <text>

        Returns the <number>th space-separated field of <text>.  I.e., if text
        is "foo bar baz" and <number> is 2, "bar" is returned.
        """
        try:
            irc.reply(text.split()[index])
        except IndexError:
            irc.errorInvalid('field')
    field = wrap(field, ['index', 'text'])

    @internationalizeDocstring
    def format(self, irc, msg, args):
        """<format string> [<arg> ...]

        Expands a Python-style format string using the remaining args.  Just be
        sure always to use %s, not %d or %f or whatever, because all the args
        are strings.
        """
        if not args:
            raise callbacks.ArgumentError
        s = args.pop(0)
        try:
            s %= tuple(args)
            irc.reply(s)
        except TypeError as e:
            self.log.debug(utils.exnToString(e))
            irc.error(_('Not enough arguments for the format string.'),
                      Raise=True)


Class = Format

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2002-2004, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

class FormatTestCase(PluginTestCase):
    plugins = ('Format',)
    def testBold(self):
        self.assertResponse('bold foobar', '\x02foobar\x02')

    def testUnderline(self):
        self.assertResponse('underline foobar', '\x1ffoobar\x1f')

    def testReverse(self):
        self.assertResponse('reverse foobar', '\x16foobar\x16')


    def testFormat(self):
        self.assertResponse('format %s foo', 'foo')
        self.assertResponse('format %s%s foo bar', 'foobar')
        self.assertResponse('format "%sbaz%s" "foo bar" 1', 'foo barbaz1')
        self.assertError('format %s foo bar')
        self.assertError('format %s%s foo')
        
    def testJoin(self):
        self.assertResponse('join + foo bar baz', 'foo+bar+baz')
        self.assertResponse('join "" foo bar baz', 'foobarbaz')

    def testTranslate(self):
        self.assertResponse('translate 123 456 1234567890', '4564567890')
        self.assertError('translate 123 1234 123125151')
    
    def testReplace(self):
        self.assertResponse('replace # %23 bla#foo', 'bla%23foo')

    def testUpper(self):
        self.assertResponse('upper foo', 'FOO')
        self.assertResponse('upper FOO', 'FOO')

    def testLower(self):
        self.assertResponse('lower foo', 'foo')
        self.assertResponse('lower FOO', 'foo')

    def testCapitalize(self):
        self.assertResponse('capitalize foo', 'Foo')
        self.assertResponse('capitalize foo bar', 'Foo bar')

    def testTitle(self):
        self.assertResponse('title foo', 'Foo')
        self.assertResponse('title foo bar', 'Foo Bar')

    def testRepr(self):
        self.assertResponse('repr foo bar baz', '"foo bar baz"')

    def testConcat(self):
        self.assertResponse('concat foo bar baz', 'foobar baz')

    def testCut(self):
        self.assertResponse('cut 5 abcdefgh', 'abcde')
        self.assertResponse('cut 5 abcd', 'abcd')
        self.assertResponse('cut -1 abcde', 'abcd')

    def testField(self):
        self.assertResponse('field 2 foo bar baz', 'bar')
        self.assertResponse('field -1 foo bar baz', 'baz')

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2003-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Games')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Games', True)


Games = conf.registerPlugin('Games')


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2003-2005, Jeremiah Fincher
# Copyright (c) 2010, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import re
import random


import supybot.utils as utils
from supybot.commands import *
import supybot.ircmsgs as ircmsgs
import supybot.ircutils as ircutils
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Games')


class Games(callbacks.Plugin):
    @internationalizeDocstring
    def coin(self, irc, msg, args):
        """takes no arguments

        Flips a coin and returns the result.
        """
        if random.randrange(0, 2):
            irc.reply(_('heads'))
        else:
            irc.reply(_('tails'))
    coin = wrap(coin)

    @internationalizeDocstring
    def dice(self, irc, msg, args, m):
        """<dice>d<sides>

        Rolls a die with <sides> number of sides <dice> times.
        For example, 2d6 will roll 2 six-sided dice; 10d10 will roll 10
        ten-sided dice.
        """
        (dice, sides) = list(map(int, m.groups()))
        if dice > 1000:
            irc.error(_('You can\'t roll more than 1000 dice.'))
        elif sides > 100:
            irc.error(_('Dice can\'t have more than 100 sides.'))
        elif sides < 3:
            irc.error(_('Dice can\'t have fewer than 3 sides.'))
        else:
            L = [0] * dice
            for i in xrange(dice):
                L[i] = random.randrange(1, sides+1)
            irc.reply(format('%L', [str(x) for x in L]))
    _dicere = re.compile(r'^(\d+)d(\d+)$')
    dice = wrap(dice, [('matches', _dicere,
                        _('Dice must be of the form <dice>d<sides>'))])

    # The list of words and algorithm are pulled straight the mozbot
    # MagicEightBall.bm module: http://tinyurl.com/7ytg7
    _positive = _('It is possible.|Yes!|Of course.|Naturally.|Obviously.|'
                  'It shall be.|The outlook is good.|It is so.|'
                  'One would be wise to think so.|'
                  'The answer is certainly yes.')
    _negative = _('In your dreams.|I doubt it very much.|No chance.|'
                  'The outlook is poor.|Unlikely.|'
                  'About as likely as pigs flying.|You\'re kidding, right?|'
                  'NO!|NO.|No.|The answer is a resounding no.')
    _unknown = _('Maybe...|No clue.|_I_ don\'t know.|'
                 'The outlook is hazy, please ask again later.|'
                 'What are you asking me for?|Come again?|'
                 'You know the answer better than I.|'
                 'The answer is def-- oooh! shiny thing!')

    def _checkTheBall(self, questionLength):
        if questionLength % 3 == 0:
            catalog = self._positive
        elif questionLength % 3 == 1:
            catalog = self._negative
        else:
            catalog = self._unknown
        return utils.iter.choice(catalog.split('|'))

    @internationalizeDocstring
    def eightball(self, irc, msg, args, text):
        """[<question>]

        Ask a question and the answer shall be provided.
        """
        if text:
            irc.reply(self._checkTheBall(len(text)))
        else:
            irc.reply(self._checkTheBall(random.randint(0, 2)))
    eightball = wrap(eightball, [additional('text')])

    _rouletteChamber = random.randrange(0, 6)
    _rouletteBullet = random.randrange(0, 6)
    @internationalizeDocstring
    def roulette(self, irc, msg, args, spin):
        """[spin]

        Fires the revolver.  If the bullet was in the chamber, you're dead.
        Tell me to spin the chambers and I will.
        """
        if spin:
            self._rouletteBullet = random.randrange(0, 6)
            irc.reply(_('*SPIN* Are you feeling lucky?'), prefixNick=False)
            return
        channel = msg.args[0]
        if self._rouletteChamber == self._rouletteBullet:
            self._rouletteBullet = random.randrange(0, 6)
            self._rouletteChamber = random.randrange(0, 6)
            if irc.nick in irc.state.channels[channel].ops or \
                    irc.nick in irc.state.channels[channel].halfops:
                irc.queueMsg(ircmsgs.kick(channel, msg.nick, 'BANG!'))
            else:
                irc.reply(_('*BANG* Hey, who put a blank in here?!'),
                          prefixNick=False)
            irc.reply(_('reloads and spins the chambers.'), action=True)
        else:
            irc.reply(_('*click*'))
            self._rouletteChamber += 1
            self._rouletteChamber %= 6
    roulette = wrap(roulette, ['public', additional(('literal', 'spin'))])

    @internationalizeDocstring
    def monologue(self, irc, msg, args, channel):
        """[<channel>]

        Returns the number of consecutive lines you've sent in <channel>
        without being interrupted by someone else (i.e. how long your current
        'monologue' is).  <channel> is only necessary if the message isn't sent
        in the channel itself.
        """
        i = 0
        for m in reversed(irc.state.history):
            if m.command != 'PRIVMSG':
                continue
            if not m.prefix:
                continue
            if not ircutils.strEqual(m.args[0], channel):
                continue
            if msg.prefix == m.prefix:
                i += 1
            else:
                break
        irc.reply(format(_('Your current monologue is at least %n long.'),
                         (i, _('line'))))
    monologue = wrap(monologue, ['channel'])

Class = Games


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2003-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

class GamesTestCase(ChannelPluginTestCase):
    plugins = ('Games',)
    _nonKickRe = re.compile(r'bang|click|spin', re.I)
    def testRoulette(self):
        self.irc.feedMsg(ircmsgs.op(self.channel, self.irc.nick))
        sawKick = False
        for i in xrange(100):
            m = self.getMsg('roulette', frm='someoneElse')
            if m.command == 'PRIVMSG':
                self.failUnless(self._nonKickRe.search(m.args[1]),
                                'Got a msg without bang|click|spin: %r' % m)
            elif m.command == 'KICK':
                sawKick = True
                self.failUnless('bang' in m.args[2].lower(),
                                'Got a KICK without bang in it.')
            else:
                self.fail('Got something other than a kick or a privmsg.')
        self.failUnless(sawKick, 'Didn\'t get a kick in %s iterations!' % i)

    def testEightball(self):
        self.assertNotError('eightball')
        self.assertNotError('eightball a')
        self.assertNotError('eightball ab')
        self.assertNotError('eightball abc')

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2005, Jeremiah Fincher
# Copyright (c) 2008-2010, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Google')

def configure(advanced):
    from supybot.questions import output, yn
    conf.registerPlugin('Google', True)
    output(_("""The Google plugin has the functionality to watch for URLs
              that match a specific pattern. (We call this a snarfer)
              When supybot sees such a URL, it will parse the web page
              for information and reply with the results."""))
    if yn(_('Do you want the Google search snarfer enabled by default?')):
        conf.supybot.plugins.Google.searchSnarfer.setValue(True)

class Language(registry.OnlySomeStrings):
    transLangs = {'Afrikaans': 'af', 'Albanian': 'sq', 'Amharic': 'am',
                  'Arabic': 'ar', 'Armenian': 'hy', 'Azerbaijani': 'az',
                  'Basque': 'eu', 'Belarusian': 'be', 'Bengali': 'bn',
                  'Bulgarian': 'bg', 'Burmese': 'my', 'Catalan': 'ca',
                  'Chinese': 'zh', 'Chinese_simplified': 'zh-CN',
                  'Chinese_traditional': 'zh-TW', 'Croatian': 'hr',
                  'Czech': 'cs', 'Danish': 'da', 'Dhivehi': 'dv',
                  'Dutch': 'nl', 'English': 'en', 'Esperanto': 'eo',
                  'Estonian': 'et', 'Filipino': 'tl', 'Finnish': 'fi',
                  'French': 'fr', 'Galician': 'gl', 'Georgian': 'ka',
                  'German': 'de', 'Greek': 'el', 'Gujarati': 'gu',
                  'Hebrew': 'iw', 'Hindi': 'hi', 'Hungarian': 'hu',
                  'Icelandic': 'is', 'Indonesian': 'id', 'Inuktitut': 'iu',
                  'Italian': 'it', 'Japanese': 'ja', 'Kannada': 'kn',
                  'Kazakh': 'kk', 'Khmer': 'km', 'Korean': 'ko',
                  'Kurdish': 'ku', 'Kyrgyz': 'ky', 'Laothian': 'lo',
                  'Latvian': 'lv', 'Lithuanian': 'lt', 'Macedonian': 'mk',
                  'Malay': 'ms', 'Malayalam': 'ml', 'Maltese': 'mt',
                  'Marathi': 'mr', 'Mongolian': 'mn', 'Nepali': 'ne',
                  'Norwegian': 'no', 'Oriya': 'or', 'Pashto': 'ps',
                  'Persian': 'fa', 'Polish': 'pl', 'Portuguese': 'pt-PT',
                  'Punjabi': 'pa', 'Romanian': 'ro', 'Russian': 'ru',
                  'Sanskrit': 'sa', 'Serbian': 'sr', 'Sindhi': 'sd',
                  'Sinhalese': 'si', 'Slovak': 'sk', 'Slovenian': 'sl',
                  'Spanish': 'es', 'Swedish': 'sv', 'Tajik': 'tg',
                  'Tamil': 'ta', 'Tagalog': 'tl', 'Telugu': 'te',
                  'Thai': 'th', 'Tibetan': 'bo', 'Turkish': 'tr',
                  'Ukranian': 'uk', 'Urdu': 'ur', 'Uzbek': 'uz',
                  'Uighur': 'ug', 'Vietnamese': 'vi',
                  'Detect language': 'auto'}
    validStrings = ['lang_' + s for s in transLangs.values()]
    validStrings.append('')
    def normalize(self, s):
        if s and not s.startswith('lang_'):
            s = 'lang_' + s
        if not s.endswith('CN') or s.endswith('TW') or s.endswith('PT'):
            s = s.lower()
        else:
            s = s.lower()[:-2] + s[-2:]
        return s

class NumSearchResults(registry.PositiveInteger):
    """Value must be 1 <= n <= 8"""
    def setValue(self, v):
        if v > 8:
            self.error()
        super(self.__class__, self).setValue(v)

class SafeSearch(registry.OnlySomeStrings):
    validStrings = ['active', 'moderate', 'off']

Google = conf.registerPlugin('Google')
conf.registerGlobalValue(Google, 'referer',
    registry.String('', _("""Determines the URL that will be sent to Google for
    the Referer field of the search requests.  If this value is empty, a
    Referer will be generated in the following format:
    http://$server/$botName""")))
conf.registerChannelValue(Google, 'baseUrl',
    registry.String('google.com', _("""Determines the base URL used for
    requests.""")))
conf.registerChannelValue(Google, 'searchSnarfer',
    registry.Boolean(False, _("""Determines whether the search snarfer is
    enabled.  If so, messages (even unaddressed ones) beginning with the word
    'google' will result in the first URL Google returns being sent to the
    channel.""")))
conf.registerChannelValue(Google, 'colorfulFilter',
    registry.Boolean(False, _("""Determines whether the word 'google' in the
    bot's output will be made colorful (like Google's logo).""")))
conf.registerChannelValue(Google, 'bold',
    registry.Boolean(True, _("""Determines whether results are bolded.""")))
conf.registerChannelValue(Google, 'oneToOne',
    registry.Boolean(False, _("""Determines whether results are sent in
    different lines or all in the same one.""")))
conf.registerChannelValue(Google, 'maximumResults',
    NumSearchResults(8, _("""Determines the maximum number of results returned
    from the google command.""")))
conf.registerChannelValue(Google, 'defaultLanguage',
    Language('lang_'+ _('en'), _("""Determines what default language is used in
    searches.  If left empty, no specific language will be requested.""")))
conf.registerChannelValue(Google, 'searchFilter',
    SafeSearch('moderate', _("""Determines what level of search filtering to use
    by default.  'active' - most filtering, 'moderate' - default filtering,
    'off' - no filtering""")))

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2002-2004, Jeremiah Fincher
# Copyright (c) 2008-2010, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import re
import sys
import cgi
import json
import time
import socket
import urllib

import supybot.conf as conf
import supybot.utils as utils
import supybot.world as world
from supybot.commands import *
import supybot.ircmsgs as ircmsgs
import supybot.ircutils as ircutils
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Google')

import json

class Google(callbacks.PluginRegexp):
    threaded = True
    callBefore = ['Web']
    regexps = ['googleSnarfer']

    _colorGoogles = {}
    def _getColorGoogle(self, m):
        s = m.group(1)
        ret = self._colorGoogles.get(s)
        if not ret:
            L = list(s)
            L[0] = ircutils.mircColor(L[0], 'blue')[:-1]
            L[1] = ircutils.mircColor(L[1], 'red')[:-1]
            L[2] = ircutils.mircColor(L[2], 'yellow')[:-1]
            L[3] = ircutils.mircColor(L[3], 'blue')[:-1]
            L[4] = ircutils.mircColor(L[4], 'green')[:-1]
            L[5] = ircutils.mircColor(L[5], 'red')
            ret = ''.join(L)
            self._colorGoogles[s] = ret
        return ircutils.bold(ret)

    _googleRe = re.compile(r'\b(google)\b', re.I)
    def outFilter(self, irc, msg):
        if msg.command == 'PRIVMSG' and \
           self.registryValue('colorfulFilter', msg.args[0]):
            s = msg.args[1]
            s = re.sub(self._googleRe, self._getColorGoogle, s)
            msg = ircmsgs.privmsg(msg.args[0], s, msg=msg)
        return msg

    _gsearchUrl = 'http://ajax.googleapis.com/ajax/services/search/web'
    @internationalizeDocstring
    def search(self, query, channel, options={}):
        """Perform a search using Google's AJAX API.
        search("search phrase", options={})

        Valid options are:
            smallsearch - True/False (Default: False)
            filter - {active,moderate,off} (Default: "moderate")
            language - Restrict search to documents in the given language
                       (Default: "lang_en")
        """
        ref = self.registryValue('referer')
        if not ref:
            ref = 'http://%s/%s' % (dynamic.irc.server,
                                    dynamic.irc.nick)
        headers = dict(utils.web.defaultHeaders)
        headers['Referer'] = ref
        opts = {'q': query, 'v': '1.0'}
        for (k, v) in options.iteritems():
            if k == 'smallsearch':
                if v:
                    opts['rsz'] = 'small'
                else:
                    opts['rsz'] = 'large'
            elif k == 'filter':
                opts['safe'] = v
            elif k == 'language':
                opts['lr'] = v
        defLang = self.registryValue('defaultLanguage', channel)
        if 'lr' not in opts and defLang:
            opts['lr'] = defLang
        if 'safe' not in opts:
            opts['safe'] = self.registryValue('searchFilter', dynamic.channel)
        if 'rsz' not in opts:
            opts['rsz'] = 'large'

        text = utils.web.getUrl('%s?%s' % (self._gsearchUrl,
                                           urllib.urlencode(opts)),
                                headers=headers).decode('utf8')
        data = json.loads(text)
        if data['responseStatus'] != 200:
            raise callbacks.Error(_('We broke The Google!'))
        return data

    def formatData(self, data, bold=True, max=0, onetoone=False):
        if isinstance(data, basestring):
            return data
        results = []
        if max:
            data = data[:max]
        for result in data:
            title = utils.web.htmlToText(result['titleNoFormatting']\
                                         .encode('utf-8'))
            url = result['unescapedUrl']
            if sys.version_info[0] < 3:
                url = url.encode('utf-8')
            if title:
                if bold:
                    title = ircutils.bold(title)
                results.append(format('%s: %u', title, url))
            else:
                results.append(url)
        if sys.version_info[0] < 3:
            repl = lambda x:x if isinstance(x, unicode) else unicode(x, 'utf8')
            results = list(map(repl, results))
        if not results:
            return [_('No matches found.')]
        elif onetoone:
            return results
        else:
            return [u'; '.join(results)]

    @internationalizeDocstring
    def lucky(self, irc, msg, args, opts, text):
        """[--snippet] <search>

        Does a google search, but only returns the first result.
        If option --snippet is given, returns also the page text snippet.
        """
        opts = dict(opts)
        data = self.search(text, msg.args[0], {'smallsearch': True})
        if data['responseData']['results']:
            url = data['responseData']['results'][0]['unescapedUrl']
            if 'snippet' in opts:
                snippet = data['responseData']['results'][0]['content']
                snippet = " | " + utils.web.htmlToText(snippet, tagReplace='')
            else:
                snippet = ""
            result = url + snippet
            irc.reply(result)
        else:
            irc.reply(_('Google found nothing.'))
    lucky = wrap(lucky, [getopts({'snippet':'',}), 'text'])

    @internationalizeDocstring
    def google(self, irc, msg, args, optlist, text):
        """<search> [--{filter,language} <value>]

        Searches google.com for the given string.  As many results as can fit
        are included.  --language accepts a language abbreviation; --filter
        accepts a filtering level ('active', 'moderate', 'off').
        """
        if 'language' in optlist and optlist['language'].lower() not in \
           conf.supybot.plugins.Google.safesearch.validStrings:
            irc.errorInvalid('language')
        data = self.search(text, msg.args[0], dict(optlist))
        if data['responseStatus'] != 200:
            irc.reply(_('We broke The Google!'))
            return
        bold = self.registryValue('bold', msg.args[0])
        max = self.registryValue('maximumResults', msg.args[0])
        # We don't use supybot.reply.oneToOne here, because you generally
        # do not want @google to echo ~20 lines of results, even if you
        # have reply.oneToOne enabled.
        onetoone = self.registryValue('oneToOne', msg.args[0])
        for result in self.formatData(data['responseData']['results'],
                                  bold=bold, max=max, onetoone=onetoone):
            irc.reply(result)
    google = wrap(google, [getopts({'language':'something',
                                    'filter':''}),
                           'text'])

    @internationalizeDocstring
    def cache(self, irc, msg, args, url):
        """<url>

        Returns a link to the cached version of <url> if it is available.
        """
        data = self.search(url, msg.args[0], {'smallsearch': True})
        if data['responseData']['results']:
            m = data['responseData']['results'][0]
            if m['cacheUrl']:
                url = m['cacheUrl'].encode('utf-8')
                irc.reply(url)
                return
        irc.error(_('Google seems to have no cache for that site.'))
    cache = wrap(cache, ['url'])

    @internationalizeDocstring
    def fight(self, irc, msg, args):
        """<search string> <search string> [<search string> ...]

        Returns the results of each search, in order, from greatest number
        of results to least.
        """
        channel = msg.args[0]
        results = []
        for arg in args:
            data = self.search(arg, channel, {'smallsearch': True})
            count = data['responseData']['cursor'].get('estimatedResultCount',
                                                       0)
            results.append((int(count), arg))
        results.sort()
        results.reverse()
        if self.registryValue('bold', msg.args[0]):
            bold = ircutils.bold
        else:
            bold = repr
        s = ', '.join([format('%s: %i', bold(s), i) for (i, s) in results])
        irc.reply(s)

    @internationalizeDocstring
    def translate(self, irc, msg, args, sourceLang, targetLang, text):
        """<source language> [to] <target language> <text>

        Returns <text> translated from <source language> into <target
        language>.
        """

        channel = msg.args[0]

        headers = dict(utils.web.defaultHeaders)
        headers['User-Agent'] = ('Mozilla/5.0 (X11; U; Linux i686) '
                                 'Gecko/20071127 Firefox/2.0.0.11')

        sourceLang = urllib.quote(sourceLang)
        targetLang = urllib.quote(targetLang)

        text = urllib.quote(text)

        result = utils.web.getUrlFd('http://translate.google.com/translate_a/t'
                                    '?client=t&hl=en&sl=%s&tl=%s&multires=1'
                                    '&otf=1&ssel=0&tsel=0&uptl=en&sc=1&text='
                                    '%s' % (sourceLang, targetLang, text),
                                    headers).read().decode('utf8')

        while ',,' in result:
            result = result.replace(',,', ',null,')
        while '[,' in result:
            result = result.replace('[,', '[')
        data = json.loads(result)

        try:
            language = data[2]
        except:
            language = 'unknown'

        irc.reply(''.join(x[0] for x in data[0]), language)
    translate = wrap(translate, ['something', 'to', 'something', 'text'])

    def googleSnarfer(self, irc, msg, match):
        r"^google\s+(.*)$"
        if not self.registryValue('searchSnarfer', msg.args[0]):
            return
        searchString = match.group(1)
        data = self.search(searchString, msg.args[0], {'smallsearch': True})
        if data['responseData']['results']:
            url = data['responseData']['results'][0]['unescapedUrl']
            irc.reply(url, prefixNick=False)
    googleSnarfer = urlSnarfer(googleSnarfer)

    def _googleUrl(self, s, channel):
        s = urllib.quote_plus(s)
        url = r'http://%s/search?q=%s' % \
                (self.registryValue('baseUrl', channel), s)
        return url

    _calcRe1 = re.compile(r'<span class="cwcot".*?>(.*?)</span>', re.I)
    _calcRe2 = re.compile(r'<div class="vk_ans.*?>(.*?)</div>', re.I | re.S)
    _calcRe3 = re.compile(r'<div class="side_div" id="rhs_div">.*?<input class="ucw_data".*?value="(.*?)"', re.I)
    @internationalizeDocstring
    def calc(self, irc, msg, args, expr):
        """<expression>

        Uses Google's calculator to calculate the value of <expression>.
        """
        channel = msg.args[0]
        if not ircutils.isChannel(channel):
            channel = None
        url = self._googleUrl(expr, channel)
        h = {"User-Agent":"Mozilla/5.0 (Windows NT 6.2; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/32.0.1667.0 Safari/537.36"}
        html = utils.web.getUrl(url, headers=h).decode('utf8')
        match = self._calcRe1.search(html)
        if not match:
            match = self._calcRe2.search(html)
            if not match:
                match = self._calcRe3.search(html)
                if not match:
                    irc.reply("I could not find an output from Google Calc for: %s" % expr)
                    self.log.info("HTML: {0}".format(html))
                    return
                else:
                    s = match.group(1)
            else:
                s = match.group(1)
        else:
            s = match.group(1)
        # do some cleanup of text
        s = re.sub(r'<sup>(.*)</sup>&#8260;<sub>(.*)</sub>', r' \1/\2', s)
        s = re.sub(r'<sup>(.*)</sup>', r'^\1', s)
        s = utils.web.htmlToText(s)
        irc.reply("%s = %s" % (expr, s))
    calc = wrap(calc, ['text'])

    _phoneRe = re.compile(r'Phonebook.*?<font size=-1>(.*?)<a href')
    @internationalizeDocstring
    def phonebook(self, irc, msg, args, phonenumber):
        """<phone number>

        Looks <phone number> up on Google.
        """
        channel = msg.args[0]
        if not ircutils.isChannel(channel):
            channel = None
        url = self._googleUrl(phonenumber, channel)
        html = utils.web.getUrl(url).decode('utf8')
        m = self._phoneRe.search(html)
        if m is not None:
            s = m.group(1)
            s = s.replace('<b>', '')
            s = s.replace('</b>', '')
            s = utils.web.htmlToText(s)
            irc.reply(s)
        else:
            irc.reply(_('Google\'s phonebook didn\'t come up with anything.'))
    phonebook = wrap(phonebook, ['text'])


Class = Google


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2002-2004, Jeremiah Fincher
# Copyright (c) 2008-2009, James Vega
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

class GoogleTestCase(ChannelPluginTestCase):
    plugins = ('Google', 'Config')
    if network:
        def testCalcHandlesMultiplicationSymbol(self):
            self.assertNotRegexp('google calc seconds in a century', r'215')

        def testCalc(self):
            self.assertNotRegexp('google calc e^(i*pi)+1', r'didn\'t')
            self.assertNotRegexp('google calc 1 usd in gbp', r'didn\'t')

        def testHtmlHandled(self):
            self.assertNotRegexp('google calc '
                                 'the speed of light '
                                 'in microns / fortnight', '<sup>')
            self.assertNotRegexp('google calc '
                                 'the speed of light '
                                 'in microns / fortnight', '&times;')

        def testSearch(self):
            self.assertNotError('google foo')
            self.assertRegexp('google dupa', r'dupa')
            # Unicode check
            self.assertNotError('google ae')

        def testSearchFormat(self):
            self.assertRegexp('google foo', '<http://.*>')
            self.assertNotError('config reply.format.url %s')
            self.assertRegexp('google foo', 'http://.*')
            self.assertNotRegexp('google foo', '<http://.*>')

        def testSearchOneToOne(self):
            self.assertRegexp('google dupa', ';')
            self.assertNotError('config plugins.Google.oneToOne True')
            self.assertNotRegexp('google dupa', ';')

        def testFight(self):
            self.assertRegexp('fight supybot moobot', r'.*supybot.*: \d+')
            self.assertNotError('fight ... !')

        def testCalcDoesNotHaveExtraSpaces(self):
            self.assertNotRegexp('google calc 1000^2', r'\s+,\s+')

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2004, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Herald')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Herald', True)


Herald = conf.registerPlugin('Herald')
conf.registerChannelValue(Herald, 'heralding',
    registry.Boolean(True, _("""Determines whether messages will be sent to the
    channel when a recognized user joins; basically enables or disables the
    plugin.""")))
conf.registerGlobalValue(Herald, 'requireCapability',
    registry.String('', _("""Determines what capability (if any) is required to
    add/change/remove the herald of another user.""")))
conf.registerChannelValue(Herald, 'throttle',
    registry.PositiveInteger(600, _("""Determines the minimum number of seconds
    between heralds.""")))
conf.registerChannelValue(Herald.throttle, 'afterPart',
    registry.NonNegativeInteger(0, _("""Determines the minimum number of seconds
    after parting that the bot will not herald the person when he or she
    rejoins.""")))
conf.registerChannelValue(Herald.throttle, 'afterSplit',
    registry.NonNegativeInteger(60, _("""Determines the minimum number of seconds
    after a netsplit that the bot will not herald the users that split.""")))
conf.registerChannelValue(Herald, 'default',
    registry.String('', _("""Sets the default herald to use.  If a user has a
    personal herald specified, that will be used instead.  If set to the empty
    string, the default herald will be disabled.""")))
conf.registerChannelValue(Herald.default, 'notice',
    registry.Boolean(True, _("""Determines whether the default herald will be
    sent as a NOTICE instead of a PRIVMSG.""")))
conf.registerChannelValue(Herald.default, 'public',
    registry.Boolean(False, _("""Determines whether the default herald will be
    sent publicly.""")))

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import os
import time

import supybot.conf as conf
import supybot.utils as utils
import supybot.world as world
import supybot.ircdb as ircdb
from supybot.commands import *
import supybot.ircmsgs as ircmsgs
import supybot.plugins as plugins
import supybot.ircutils as ircutils
import supybot.callbacks as callbacks
from supybot.utils.structures import TimeoutQueue
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Herald')

filename = conf.supybot.directories.data.dirize('Herald.db')

class HeraldDB(plugins.ChannelUserDB):
    def serialize(self, v):
        return [v]

    def deserialize(self, channel, id, L):
        if len(L) != 1:
            raise ValueError
        return L[0]

class Herald(callbacks.Plugin):
    def __init__(self, irc):
        self.__parent = super(Herald, self)
        self.__parent.__init__(irc)
        self.db = HeraldDB(filename)
        world.flushers.append(self.db.flush)
        self.lastParts = plugins.ChannelUserDictionary()
        splitTimeout = conf.supybot.plugins.Herald.throttle.afterSplit
        self.splitters = TimeoutQueue(splitTimeout)
        self.lastHerald = plugins.ChannelUserDictionary()

    def die(self):
        if self.db.flush in world.flushers:
            world.flushers.remove(self.db.flush)
        self.db.close()
        self.__parent.die()

    def doQuit(self, irc, msg):
        # We want to observe netsplits and keep from heralding users rejoining
        # after one.
        if ircmsgs.isSplit(msg):
            self.splitters.enqueue(msg.nick)
            try:
                id = ircdb.users.getUserId(msg.prefix)
                self.splitters.enqueue(id)
            except KeyError:
                pass

    def doJoin(self, irc, msg):
        if ircutils.strEqual(irc.nick, msg.nick):
            return # It's us.
        if msg.nick in self.splitters:
            self.log.debug('Not heralding %s, recent split.', msg.nick)
            return # Recently split.
        channel = msg.args[0]
        irc = callbacks.SimpleProxy(irc, msg)
        if self.registryValue('heralding', channel):
            try:
                id = ircdb.users.getUserId(msg.prefix)
                if id in self.splitters:
                    self.log.debug('Not heralding id #%s, recent split.', id)
                    return
                herald = self.db[channel, id]
            except KeyError:
                default = self.registryValue('default', channel)
                if default:
                    default = ircutils.standardSubstitute(irc, msg, default)
                    msgmaker = ircmsgs.privmsg
                    if self.registryValue('default.notice', channel):
                        msgmaker = ircmsgs.notice
                    target = msg.nick
                    if self.registryValue('default.public', channel):
                        target = channel
                    irc.queueMsg(msgmaker(target, default))
                return
            now = time.time()
            throttle = self.registryValue('throttle', channel)
            if now - self.lastHerald.get((channel, id), 0) > throttle:
                if (channel, id) in self.lastParts:
                   i = self.registryValue('throttle.afterPart', channel)
                   if now - self.lastParts[channel, id] < i:
                       return
                self.lastHerald[channel, id] = now
                herald = ircutils.standardSubstitute(irc, msg, herald)
                irc.reply(herald, prefixNick=False)

    def doPart(self, irc, msg):
        try:
            id = self._getId(irc, msg.prefix)
            self.lastParts[msg.args[0], id] = time.time()
        except KeyError:
            pass

    def _getId(self, irc, userNickHostmask):
        try:
            id = ircdb.users.getUserId(userNickHostmask)
        except KeyError:
            if not ircutils.isUserHostmask(userNickHostmask):
                hostmask = irc.state.nickToHostmask(userNickHostmask)
                id = ircdb.users.getUserId(hostmask)
            else:
                raise KeyError
        return id

    @internationalizeDocstring
    def default(self, irc, msg, args, channel, optlist, text):
        """[<channel>] [--remove|<msg>]

        If <msg> is given, sets the default herald to <msg>.  A <msg> of ""
        will remove the default herald.  If <msg> is not given, returns the
        current default herald.  <channel> is only necessary if the message
        isn't sent in the channel itself.
        """
        if optlist and text:
            raise callbacks.ArgumentError
        for (option, foo) in optlist:
            if option == 'remove':
                self.setRegistryValue('default', '', channel)
                irc.replySuccess()
                return
        if text:
            self.setRegistryValue('default', text, channel)
            irc.replySuccess()
        else:
            resp = self.registryValue('default', channel) or \
                   _('I do not have a default herald set for %s.') % channel
            irc.reply(resp)
    default = wrap(default, ['channel',
                             getopts({'remove': ''}),
                             additional('text')])

    @internationalizeDocstring
    def get(self, irc, msg, args, channel, user):
        """[<channel>] [<user|nick>]

        Returns the current herald message for <user> (or the user
        <nick|hostmask> is currently identified or recognized as).  If <user>
        is not given, defaults to the user giving the command.  <channel>
        is only necessary if the message isn't sent in the channel itself.
        """
        try:
            herald = self.db[channel, user.id]
            irc.reply(herald)
        except KeyError:
            irc.error(_('I have no herald for %s.') % user.name)
    get = wrap(get, ['channel', first('otherUser', 'user')])

    def _preCheck(self, irc, msg, user):
        capability = self.registryValue('requireCapability')
        if capability:
            try:
                u = ircdb.users.getUser(msg.prefix)
            except KeyError:
                irc.errorNotRegistered(Raise=True)
            else:
                if u != user:
                    if not ircdb.checkCapability(msg.prefix, capability):
                        irc.errorNoCapability(capability, Raise=True)

    # I chose not to make <user|nick> optional in this command because
    # if it's not a valid username (e.g., if the user tyops and misspells a
    # username), it may be nice not to clobber the user's herald.
    @internationalizeDocstring
    def add(self, irc, msg, args, channel, user, herald):
        """[<channel>] <user|nick> <msg>

        Sets the herald message for <user> (or the user <nick|hostmask> is
        currently identified or recognized as) to <msg>.  <channel> is only
        necessary if the message isn't sent in the channel itself.
        """
        self._preCheck(irc, msg, user)
        self.db[channel, user.id] = herald
        irc.replySuccess()
    add = wrap(add, ['channel', 'otherUser', 'text'])

    @internationalizeDocstring
    def remove(self, irc, msg, args, channel, user):
        """[<channel>] [<user|nick>]

        Removes the herald message set for <user>, or the user
        <nick|hostmask> is currently identified or recognized as.  If <user>
        is not given, defaults to the user giving the command.
        <channel> is only necessary if the message isn't sent in the channel
        itself.
        """
        self._preCheck(irc, msg, user)
        try:
            del self.db[channel, user.id]
            irc.replySuccess()
        except KeyError:
            irc.error(_('I have no herald for that user.'))
    remove = wrap(remove, ['channel', first('otherUser', 'user')])

    @internationalizeDocstring
    def change(self, irc, msg, args, channel, user, changer):
        """[<channel>] [<user|nick>] <regexp>

        Changes the herald message for <user>, or the user <nick|hostmask> is
        currently identified or recognized as, according to <regexp>.  If
        <user> is not given, defaults to the calling user. <channel> is only
        necessary if the message isn't sent in the channel itself.
        """
        self._preCheck(irc, msg, user)
        s = self.db[channel, user.id]
        newS = changer(s)
        self.db[channel, user.id] = newS
        irc.replySuccess()
    change = wrap(change, ['channel',
                          first('otherUser', 'user'),
                           'regexpReplacer'])


Class = Herald

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

class HeraldTestCase(PluginTestCase):
    plugins = ('Herald',)


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:


########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2003-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Internet')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Internet', True)


Internet = conf.registerPlugin('Internet')
# This is where your configuration variables (if any) should go.  For example:
# conf.registerGlobalValue(Internet, 'someConfigVariableName',
#     registry.Boolean(False, _("""Help for someConfigVariableName.""")))


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2003-2005, Jeremiah Fincher
# Copyright (c) 2010-2011, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import time
import socket
import telnetlib

import supybot.utils as utils
from supybot.commands import *
from supybot.utils.iter import any
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Internet')

class Internet(callbacks.Plugin):
    """Add the help for "@help Internet" here."""
    threaded = True
    @internationalizeDocstring
    def dns(self, irc, msg, args, host):
        """<host|ip>

        Returns the ip of <host> or the reverse DNS hostname of <ip>.
        """
        if utils.net.isIP(host):
            hostname = socket.getfqdn(host)
            if hostname == host:
                irc.reply(_('Host not found.'))
            else:
                irc.reply(hostname)
        else:
            try:
                ip = socket.getaddrinfo(host, None)[0][4][0]
                irc.reply(ip)
            except socket.error:
                irc.reply(_('Host not found.'))
    dns = wrap(dns, ['something'])

    _domain = ['Domain Name', 'Server Name', 'domain']
    _registrar = ['Sponsoring Registrar', 'Registrar', 'source']
    _updated = ['Last Updated On', 'Domain Last Updated Date', 'Updated Date',
                'Last Modified', 'changed']
    _created = ['Created On', 'Domain Registration Date', 'Creation Date']
    _expires = ['Expiration Date', 'Domain Expiration Date']
    _status = ['Status', 'Domain Status', 'status']
    @internationalizeDocstring
    def whois(self, irc, msg, args, domain):
        """<domain>

        Returns WHOIS information on the registration of <domain>.
        """
        usertld = domain.split('.')[-1]
        if '.' not in domain:
            irc.errorInvalid(_('domain'))
            return
        try:
            sock = utils.net.getSocket('%s.whois-servers.net' % usertld)
            sock.connect(('%s.whois-servers.net' % usertld, 43))
        except socket.error as e:
            irc.error(str(e))
            return
        sock.settimeout(5)
        if usertld == 'com':
            sock.send(b'=')
        sock.send(domain.encode('ascii'))
        sock.send(b'\r\n')

        s = b''
        end_time = time.time() + 5
        try:
            while end_time>time.time():
                s += sock.recv(4096)
        except socket.error:
            pass
        server = registrar = updated = created = expires = status = ''
        for line in s.splitlines():
            line = line.decode('utf8').strip()
            if not line or ':' not in line:
                continue
            if not server and any(line.startswith, self._domain):
                server = ':'.join(line.split(':')[1:]).strip().lower()
                # Let's add this check so that we don't respond with info for
                # a different domain. E.g., doing a whois for microsoft.com
                # and replying with the info for microsoft.com.wanadoodoo.com
                if server != domain:
                    server = ''
                    continue
            if not server:
                continue
            if not registrar and any(line.startswith, self._registrar):
                registrar = ':'.join(line.split(':')[1:]).strip()
            elif not updated and any(line.startswith, self._updated):
                s = ':'.join(line.split(':')[1:]).strip()
                updated = _('updated %s') % s
            elif not created and any(line.startswith, self._created):
                s = ':'.join(line.split(':')[1:]).strip()
                created = _('registered %s') % s
            elif not expires and any(line.startswith, self._expires):
                s = ':'.join(line.split(':')[1:]).strip()
                expires = _('expires %s') % s
            elif not status and any(line.startswith, self._status):
                status = ':'.join(line.split(':')[1:]).strip().lower()
        if not status:
            status = 'unknown'
        try:
            t = telnetlib.Telnet('whois.pir.org', 43)
        except socket.error as e:
            irc.error(str(e))
            return
        t.write(b'registrar ')
        t.write(registrar.split('(')[0].strip().encode('ascii'))
        t.write(b'\n')
        s = t.read_all()
        url = ''
        for line in s.splitlines():
            line = line.decode('ascii').strip()
            if not line:
                continue
            if line.startswith('Email'):
                url = _(' <registered at %s>') % line.split('@')[-1]
            elif line.startswith('Registrar Organization:'):
                url = _(' <registered by %s>') % line.split(':')[1].strip()
            elif line == 'Not a valid ID pattern':
                url = ''
        if server and status:
            info = filter(None, [status, created, updated, expires])
            s = format(_('%s%s is %L.'), server, url, info)
            irc.reply(s)
        else:
            irc.error(_('I couldn\'t find such a domain.'))
    whois = wrap(whois, ['lowered'])

    @internationalizeDocstring
    def hexip(self, irc, msg, args, ip):
        """<ip>

        Returns the hexadecimal IP for that IP.
        """
        ret = ""
        if utils.net.isIPV4(ip):
            quads = ip.split('.')
            for quad in quads:
                i = int(quad)
                ret += '%02X' % i
        else:
            octets = ip.split(':')
            for octet in octets:
                if octet:
                    i = int(octet, 16)
                    ret += '%04X' % i
                else:
                    missing = (8 - len(octets)) * 4
                    ret += '0' * missing
        irc.reply(ret)
    hexip = wrap(hexip, ['ip'])
Internet = internationalizeDocstring(Internet)

Class = Internet


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2003-2005, Jeremiah Fincher
# Copyright (c) 2010, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

class InternetTestCase(PluginTestCase):
    plugins = ('Internet',)
    if network:
        def testDns(self):
            self.assertNotError('dns slashdot.org')
            self.assertResponse('dns does.not.exist.',
                                'Host not found.')

        def testWhois(self):
            self.assertNotError('internet whois ohio-state.edu')
            self.assertNotError('internet whois microsoft.com')
            self.assertNotError('internet whois inria.fr')
            self.assertNotError('internet whois slime.com.au')


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Karma')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Karma', True)

Karma = conf.registerPlugin('Karma')

conf.registerChannelValue(Karma, 'simpleOutput',
    registry.Boolean(False, _("""Determines whether the bot will output shorter
    versions of the karma output when requesting a single thing's karma.""")))
conf.registerChannelValue(Karma, 'response',
    registry.Boolean(False, _("""Determines whether the bot will reply with a
    success message when something's karma is increased or decreased.""")))
conf.registerChannelValue(Karma, 'rankingDisplay',
    registry.Integer(3, _("""Determines how many highest/lowest karma things
    are shown when karma is called with no arguments.""")))
conf.registerChannelValue(Karma, 'mostDisplay',
    registry.Integer(25, _("""Determines how many karma things are shown when
    the most command is called.""")))
conf.registerChannelValue(Karma, 'allowSelfRating',
    registry.Boolean(False, _("""Determines whether users can adjust the karma
    of their nick.""")))
conf.registerChannelValue(Karma, 'allowUnaddressedKarma',
    registry.Boolean(True, _("""Determines whether the bot will
    increase/decrease karma without being addressed.""")))

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2005, Jeremiah Fincher
# Copyright (c) 2010, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import os
import csv

import supybot.conf as conf
import supybot.utils as utils
from supybot.commands import *
import supybot.plugins as plugins
import supybot.ircmsgs as ircmsgs
import supybot.ircutils as ircutils
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Karma')

import sqlite3

class SqliteKarmaDB(object):
    def __init__(self, filename):
        self.dbs = ircutils.IrcDict()
        self.filename = filename

    def close(self):
        for db in self.dbs.itervalues():
            db.close()

    def _getDb(self, channel):
        filename = plugins.makeChannelFilename(self.filename, channel)
        if filename in self.dbs:
            return self.dbs[filename]
        if os.path.exists(filename):
            db = sqlite3.connect(filename, check_same_thread=False)
            db.text_factory = str
            self.dbs[filename] = db
            return db
        db = sqlite3.connect(filename, check_same_thread=False)
        db.text_factory = str
        self.dbs[filename] = db
        cursor = db.cursor()
        cursor.execute("""CREATE TABLE karma (
                          id INTEGER PRIMARY KEY,
                          name TEXT,
                          normalized TEXT UNIQUE ON CONFLICT IGNORE,
                          added INTEGER,
                          subtracted INTEGER
                          )""")
        db.commit()
        def p(s1, s2):
            return int(ircutils.nickEqual(s1, s2))
        db.create_function('nickeq', 2, p)
        return db

    def get(self, channel, thing):
        db = self._getDb(channel)
        thing = thing.lower()
        cursor = db.cursor()
        cursor.execute("""SELECT added, subtracted FROM karma
                          WHERE normalized=?""", (thing,))
        results = cursor.fetchall()
        if len(results) == 0:
            return None
        else:
            return list(map(int, results[0]))

    def gets(self, channel, things):
        db = self._getDb(channel)
        cursor = db.cursor()
        normalizedThings = dict(list(zip([s.lower() for s in things], things)))
        criteria = ' OR '.join(['normalized=?'] * len(normalizedThings))
        sql = """SELECT name, added-subtracted FROM karma
                 WHERE %s ORDER BY added-subtracted DESC""" % criteria
        cursor.execute(sql, normalizedThings.keys())
        L = [(name, int(karma)) for (name, karma) in cursor.fetchall()]
        for (name, _) in L:
            del normalizedThings[name.lower()]
        neutrals = normalizedThings.values()
        neutrals.sort()
        return (L, neutrals)

    def top(self, channel, limit):
        db = self._getDb(channel)
        cursor = db.cursor()
        cursor.execute("""SELECT name, added-subtracted FROM karma
                          ORDER BY added-subtracted DESC LIMIT ?""", (limit,))
        return [(t[0], int(t[1])) for t in cursor.fetchall()]

    def bottom(self, channel, limit):
        db = self._getDb(channel)
        cursor = db.cursor()
        cursor.execute("""SELECT name, added-subtracted FROM karma
                          ORDER BY added-subtracted ASC LIMIT ?""", (limit,))
        return [(t[0], int(t[1])) for t in cursor.fetchall()]

    def rank(self, channel, thing):
        db = self._getDb(channel)
        cursor = db.cursor()
        cursor.execute("""SELECT added-subtracted FROM karma
                          WHERE name=?""", (thing,))
        results = cursor.fetchall()
        if len(results) == 0:
            return None
        karma = int(results[0][0])
        cursor.execute("""SELECT COUNT(*) FROM karma
                          WHERE added-subtracted > ?""", (karma,))
        rank = int(cursor.fetchone()[0])
        return rank+1

    def size(self, channel):
        db = self._getDb(channel)
        cursor = db.cursor()
        cursor.execute("""SELECT COUNT(*) FROM karma""")
        return int(cursor.fetchone()[0])

    def increment(self, channel, name):
        db = self._getDb(channel)
        cursor = db.cursor()
        normalized = name.lower()
        cursor.execute("""INSERT INTO karma VALUES (NULL, ?, ?, 0, 0)""",
                       (name, normalized,))
        cursor.execute("""UPDATE karma SET added=added+1
                          WHERE normalized=?""", (normalized,))
        db.commit()

    def decrement(self, channel, name):
        db = self._getDb(channel)
        cursor = db.cursor()
        normalized = name.lower()
        cursor.execute("""INSERT INTO karma VALUES (NULL, ?, ?, 0, 0)""",
                       (name, normalized,))
        cursor.execute("""UPDATE karma SET subtracted=subtracted+1
                          WHERE normalized=?""", (normalized,))
        db.commit()

    def most(self, channel, kind, limit):
        if kind == 'increased':
            orderby = 'added'
        elif kind == 'decreased':
            orderby = 'subtracted'
        elif kind == 'active':
            orderby = 'added+subtracted'
        else:
            raise ValueError('invalid kind')
        sql = """SELECT name, %s FROM karma ORDER BY %s DESC LIMIT %s""" % \
              (orderby, orderby, limit)
        db = self._getDb(channel)
        cursor = db.cursor()
        cursor.execute(sql)
        return [(name, int(i)) for (name, i) in cursor.fetchall()]

    def clear(self, channel, name):
        db = self._getDb(channel)
        cursor = db.cursor()
        normalized = name.lower()
        cursor.execute("""UPDATE karma SET subtracted=0, added=0
                          WHERE normalized=?""", (normalized,))
        db.commit()

    def dump(self, channel, filename):
        filename = conf.supybot.directories.data.dirize(filename)
        fd = utils.file.AtomicFile(filename)
        out = csv.writer(fd)
        db = self._getDb(channel)
        cursor = db.cursor()
        cursor.execute("""SELECT name, added, subtracted FROM karma""")
        for (name, added, subtracted) in cursor.fetchall():
            out.writerow([name, added, subtracted])
        fd.close()

    def load(self, channel, filename):
        filename = conf.supybot.directories.data.dirize(filename)
        fd = open(filename)
        reader = csv.reader(fd)
        db = self._getDb(channel)
        cursor = db.cursor()
        cursor.execute("""DELETE FROM karma""")
        for (name, added, subtracted) in reader:
            normalized = name.lower()
            cursor.execute("""INSERT INTO karma
                              VALUES (NULL, ?, ?, ?, ?)""",
                           (name, normalized, added, subtracted,))
        db.commit()
        fd.close()

KarmaDB = plugins.DB('Karma',
                     {'sqlite3': SqliteKarmaDB})

class Karma(callbacks.Plugin):
    callBefore = ('Factoids', 'MoobotFactoids', 'Infobot')
    def __init__(self, irc):
        self.__parent = super(Karma, self)
        self.__parent.__init__(irc)
        self.db = KarmaDB()

    def die(self):
        self.__parent.die()
        self.db.close()

    def _normalizeThing(self, thing):
        assert thing
        if thing[0] == '(' and thing[-1] == ')':
            thing = thing[1:-1]
        return thing

    def _respond(self, irc, channel, thing, karma):
        if self.registryValue('response', channel):
            irc.reply(_('%(thing)s\'s karma is now %(karma)i') %
                    {'thing': thing, 'karma': karma})
        else:
            irc.noReply()

    def _doKarma(self, irc, channel, thing):
        assert thing[-2:] in ('++', '--')
        if thing.endswith('++'):
            thing = thing[:-2]
            if ircutils.strEqual(thing, irc.msg.nick) and \
               not self.registryValue('allowSelfRating', channel):
                irc.error(_('You\'re not allowed to adjust your own karma.'))
            elif thing:
                self.db.increment(channel, self._normalizeThing(thing))
                karma = self.db.get(channel, self._normalizeThing(thing))
                self._respond(irc, channel, thing, karma[0]-karma[1])
        else:
            thing = thing[:-2]
            if ircutils.strEqual(thing, irc.msg.nick) and \
               not self.registryValue('allowSelfRating', channel):
                irc.error(_('You\'re not allowed to adjust your own karma.'))
            elif thing:
                self.db.decrement(channel, self._normalizeThing(thing))
                karma = self.db.get(channel, self._normalizeThing(thing))
                self._respond(irc, channel, thing, karma[0]-karma[1])

    def invalidCommand(self, irc, msg, tokens):
        channel = msg.args[0]
        if not irc.isChannel(channel) or not tokens:
            return
        if tokens[-1][-2:] in ('++', '--'):
            thing = ' '.join(tokens)
            self._doKarma(irc, channel, thing)

    def doPrivmsg(self, irc, msg):
        # We don't handle this if we've been addressed because invalidCommand
        # will handle it for us.  This prevents us from accessing the db twice
        # and therefore crashing.
        if not (msg.addressed or msg.repliedTo):
            channel = msg.args[0]
            if irc.isChannel(channel) and \
               not ircmsgs.isCtcp(msg) and \
               self.registryValue('allowUnaddressedKarma', channel):
                irc = callbacks.SimpleProxy(irc, msg)
                thing = msg.args[1].rstrip()
                if thing[-2:] in ('++', '--'):
                    self._doKarma(irc, channel, thing)

    @internationalizeDocstring
    def karma(self, irc, msg, args, channel, things):
        """[<channel>] [<thing> ...]

        Returns the karma of <thing>.  If <thing> is not given, returns the top
        N karmas, where N is determined by the config variable
        supybot.plugins.Karma.rankingDisplay.  If one <thing> is given, returns
        the details of its karma; if more than one <thing> is given, returns
        the total karma of each of the things. <channel> is only necessary
        if the message isn't sent on the channel itself.
        """
        if len(things) == 1:
            name = things[0]
            t = self.db.get(channel, name)
            if t is None:
                irc.reply(format(_('%s has neutral karma.'), name))
            else:
                (added, subtracted) = t
                total = added - subtracted
                if self.registryValue('simpleOutput', channel):
                    s = format('%s: %i', name, total)
                else:
                    s = format(_('Karma for %q has been increased %n and '
                               'decreased %n for a total karma of %s.'),
                               name, (added, _('time')),
                               (subtracted, _('time')),
                               total)
                irc.reply(s)
        elif len(things) > 1:
            (L, neutrals) = self.db.gets(channel, things)
            if L:
                s = format('%L', [format('%s: %i', *t) for t in L])
                if neutrals:
                    neutral = format('.  %L %h neutral karma',
                                     neutrals, len(neutrals))
                    s += neutral
                irc.reply(s + '.')
            else:
                irc.reply(_('I didn\'t know the karma for any of those '
                            'things.'))
        else: # No name was given.  Return the top/bottom N karmas.
            limit = self.registryValue('rankingDisplay', channel)
            top = self.db.top(channel, limit)
            highest = [format('%q (%s)', s, t)
                       for (s, t) in self.db.top(channel, limit)]
            lowest = [format('%q (%s)', s, t)
                      for (s, t) in self.db.bottom(channel, limit)]
            if not (highest and lowest):
                irc.error(_('I have no karma for this channel.'))
                return
            rank = self.db.rank(channel, msg.nick)
            if rank is not None:
                total = self.db.size(channel)
                rankS = format(_('  You (%s) are ranked %i out of %i.'),
                               msg.nick, rank, total)
            else:
                rankS = ''
            s = format(_('Highest karma: %L.  Lowest karma: %L.%s'),
                       highest, lowest, rankS)
            irc.reply(s)
    karma = wrap(karma, ['channel', any('something')])

    _mostAbbrev = utils.abbrev(['increased', 'decreased', 'active'])
    @internationalizeDocstring
    def most(self, irc, msg, args, channel, kind):
        """[<channel>] {increased,decreased,active}

        Returns the most increased, the most decreased, or the most active
        (the sum of increased and decreased) karma things.  <channel> is only
        necessary if the message isn't sent in the channel itself.
        """
        L = self.db.most(channel, kind,
                         self.registryValue('mostDisplay', channel))
        if L:
            L = [format('%q: %i', name, i) for (name, i) in L]
            irc.reply(format('%L', L))
        else:
            irc.error(_('I have no karma for this channel.'))
    most = wrap(most, ['channel',
                       ('literal', ['increased', 'decreased', 'active'])])

    @internationalizeDocstring
    def clear(self, irc, msg, args, channel, name):
        """[<channel>] <name>

        Resets the karma of <name> to 0.
        """
        self.db.clear(channel, name)
        irc.replySuccess()
    clear = wrap(clear, [('checkChannelCapability', 'op'), 'text'])

    @internationalizeDocstring
    def dump(self, irc, msg, args, channel, filename):
        """[<channel>] <filename>

        Dumps the Karma database for <channel> to <filename> in the bot's
        data directory.  <channel> is only necessary if the message isn't sent
        in the channel itself.
        """
        self.db.dump(channel, filename)
        irc.replySuccess()
    dump = wrap(dump, [('checkCapability', 'owner'), 'channeldb', 'filename'])

    @internationalizeDocstring
    def load(self, irc, msg, args, channel, filename):
        """[<channel>] <filename>

        Loads the Karma database for <channel> from <filename> in the bot's
        data directory.  <channel> is only necessary if the message isn't sent
        in the channel itself.
        """
        self.db.load(channel, filename)
        irc.replySuccess()
    load = wrap(load, [('checkCapability', 'owner'), 'channeldb', 'filename'])

Class = Karma

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

import sqlite3

class KarmaTestCase(ChannelPluginTestCase):
    plugins = ('Karma',)
    def testKarma(self):
        self.assertError('karma')
        self.assertRegexp('karma foobar', 'neutral karma')
        try:
            conf.replyWhenNotCommand = True
            self.assertNoResponse('foobar++', 2)
        finally:
            conf.replyWhenNotCommand = False
        self.assertRegexp('karma foobar', 'increased 1.*total.*1')
        self.assertRegexp('karma FOOBAR', 'increased 1.*total.*1')
        self.assertNoResponse('foobar--', 2)
        self.assertRegexp('karma foobar', 'decreased 1.*total.*0')
        self.assertRegexp('karma FOOBAR', 'decreased 1.*total.*0')
        self.assertNoResponse('FOO++', 2)
        self.assertNoResponse('BAR--', 2)
        self.assertRegexp('karma foo bar foobar', '.*foo.*foobar.*bar.*')
        self.assertRegexp('karma FOO BAR FOOBAR', '.*foo.*foobar.*bar.*')
        self.assertRegexp('karma FOO BAR FOOBAR',
                          '.*FOO.*foobar.*BAR.*', flags=0)
        self.assertRegexp('karma foo bar foobar asdfjkl', 'asdfjkl')
        # Test case-insensitive
        self.assertNoResponse('MOO++', 2)
        self.assertRegexp('karma moo',
                          'Karma for [\'"]moo[\'"].*increased 1.*total.*1')
        self.assertRegexp('karma MoO',
                          'Karma for [\'"]MoO[\'"].*increased 1.*total.*1')

    def testKarmaRankingDisplayConfigurable(self):
        try:
            orig = conf.supybot.plugins.Karma.response()
            conf.supybot.plugins.Karma.response.setValue(True)
            original = conf.supybot.plugins.Karma.rankingDisplay()
            self.assertNotError('foo++')
            self.assertNotError('foo++')
            self.assertNotError('foo++')
            self.assertNotError('foo++')
            self.assertNotError('bar++')
            self.assertNotError('bar++')
            self.assertNotError('bar++')
            self.assertNotError('baz++')
            self.assertNotError('baz++')
            self.assertNotError('quux++')
            self.assertNotError('xuuq--')
            self.assertNotError('zab--')
            self.assertNotError('zab--')
            self.assertNotError('rab--')
            self.assertNotError('rab--')
            self.assertNotError('rab--')
            self.assertNotError('oof--')
            self.assertNotError('oof--')
            self.assertNotError('oof--')
            self.assertNotError('oof--')
            self.assertRegexp('karma', 'foo.*bar.*baz.*oof.*rab.*zab')
            conf.supybot.plugins.Karma.rankingDisplay.setValue(4)
            self.assertRegexp('karma', 'foo.*bar.*baz.*quux')
        finally:
            conf.supybot.plugins.Karma.response.setValue(orig)
            conf.supybot.plugins.Karma.rankingDisplay.setValue(original)

    def testMost(self):
        self.assertError('most increased')
        self.assertError('most decreased')
        self.assertError('most active')
        self.assertHelp('most aldsfkj')
        self.assertNoResponse('foo++', 1)
        self.assertNoResponse('foo++', 1)
        self.assertNoResponse('bar++', 1)
        self.assertNoResponse('bar--', 1)
        self.assertNoResponse('bar--', 1)
        self.assertRegexp('karma most active', 'bar.*foo')
        self.assertRegexp('karma most increased', 'foo.*bar')
        self.assertRegexp('karma most decreased', 'bar.*foo')
        self.assertNoResponse('foo--', 1)
        self.assertNoResponse('foo--', 1)
        self.assertNoResponse('foo--', 1)
        self.assertNoResponse('foo--', 1)
        self.assertRegexp('karma most active', 'foo.*bar')
        self.assertRegexp('karma most increased', 'foo.*bar')
        self.assertRegexp('karma most decreased', 'foo.*bar')

    def testSimpleOutput(self):
        try:
            orig = conf.supybot.plugins.Karma.simpleOutput()
            conf.supybot.plugins.Karma.simpleOutput.setValue(True)
            self.assertNoResponse('foo++', 2)
            self.assertResponse('karma foo', 'foo: 1')
            self.assertNoResponse('bar--', 2)
            self.assertResponse('karma bar', 'bar: -1')
        finally:
            conf.supybot.plugins.Karma.simpleOutput.setValue(orig)

    def testSelfRating(self):
        nick = self.nick
        try:
            orig = conf.supybot.plugins.Karma.allowSelfRating()
            conf.supybot.plugins.Karma.allowSelfRating.setValue(False)
            self.assertError('%s++' % nick)
            self.assertResponse('karma %s' % nick,
                                '%s has neutral karma.' % nick)
            conf.supybot.plugins.Karma.allowSelfRating.setValue(True)
            self.assertNoResponse('%s++' % nick, 2)
            self.assertRegexp('karma %s' % nick,
                  'Karma for [\'"]%s[\'"].*increased 1.*total.*1' % nick)
        finally:
            conf.supybot.plugins.Karma.allowSelfRating.setValue(orig)

    def testKarmaOutputConfigurable(self):
        self.assertNoResponse('foo++', 2)
        try:
            orig = conf.supybot.plugins.Karma.response()
            conf.supybot.plugins.Karma.response.setValue(True)
            self.assertNotError('foo++')
        finally:
            conf.supybot.plugins.Karma.response.setValue(orig)

    def testKarmaMostDisplayConfigurable(self):
        self.assertNoResponse('foo++', 1)
        self.assertNoResponse('foo++', 1)
        self.assertNoResponse('bar++', 1)
        self.assertNoResponse('bar--', 1)
        self.assertNoResponse('bar--', 1)
        self.assertNoResponse('foo--', 1)
        self.assertNoResponse('foo--', 1)
        self.assertNoResponse('foo--', 1)
        self.assertNoResponse('foo--', 1)
        try:
            orig = conf.supybot.plugins.Karma.mostDisplay()
            conf.supybot.plugins.Karma.mostDisplay.setValue(1)
            self.assertRegexp('karma most active', '(?!bar)')
            conf.supybot.plugins.Karma.mostDisplay.setValue(25)
            self.assertRegexp('karma most active', 'bar')
        finally:
            conf.supybot.plugins.Karma.mostDisplay.setValue(orig)


    def testIncreaseKarmaWithNickNotCallingInvalidCommand(self):
        self.assertSnarfNoResponse('%s: foo++' % self.irc.nick, 3)

    def testClear(self):
        self.assertNoResponse('foo++', 1)
        self.assertRegexp('karma foo', '1')
        self.assertNotError('karma clear foo')
        self.assertRegexp('karma foo', '0')
        self.assertNotRegexp('karma foo', '1')

#        def testNoKarmaDunno(self):
#            self.assertNotError('load Infobot')
#            self.assertNoResponse('foo++')

    def testMultiWordKarma(self):
        self.assertNoResponse('(foo bar)++', 1)
        self.assertRegexp('karma "foo bar"', '1')

    def testUnaddressedKarma(self):
        karma = conf.supybot.plugins.Karma
        resp = karma.response()
        unaddressed = karma.allowUnaddressedKarma()
        try:
            karma.response.setValue(True)
            karma.allowUnaddressedKarma.setValue(True)
            for m in ('++', '--'):
                self.assertRegexp('foo%s' % m, 'is now')
                self.assertSnarfRegexp('foo%s' % m, 'is now')
                #self.assertNoResponse('foo bar%s' % m)
                #self.assertSnarfNoResponse('foo bar%s' % m)
                self.assertRegexp('(foo bar)%s' % m, 'is now')
                self.assertSnarfRegexp('(foo bar)%s' % m, 'is now')
        finally:
            karma.response.setValue(resp)
            karma.allowUnaddressedKarma.setValue(unaddressed)

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2005, Daniel DiPaolo
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Lart')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Lart', True)


Lart = conf.registerPlugin('Lart')
# This is where your configuration variables (if any) should go.  For example:
# conf.registerGlobalValue(Lart, 'someConfigVariableName',
#     registry.Boolean(False, _("""Help for someConfigVariableName.""")))
conf.registerChannelValue(Lart, 'showIds',
    registry.Boolean(False, _("""Determines whether the bot will show the ids
    of a lart when the lart is given.""")))


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2005, Daniel DiPaolo
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import re

from supybot.commands import *
import supybot.plugins as plugins
import supybot.ircutils as ircutils
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Lart')

class Lart(plugins.ChannelIdDatabasePlugin):
    _meRe = re.compile(r'\bme\b', re.I)
    _myRe = re.compile(r'\bmy\b', re.I)
    def _replaceFirstPerson(self, s, nick):
        s = self._meRe.sub(nick, s)
        s = self._myRe.sub('%s\'s' % nick, s)
        return s

    def addValidator(self, irc, text):
        if '$who' not in text:
            irc.error(_('Larts must contain $who.'), Raise=True)

    @internationalizeDocstring
    def lart(self, irc, msg, args, channel, id, text):
        """[<channel>] [<id>] <who|what> [for <reason>]

        Uses the Luser Attitude Readjustment Tool on <who|what> (for <reason>,
        if given).  If <id> is given, uses that specific lart.  <channel> is
        only necessary if the message isn't sent in the channel itself.
        """
        if ' for ' in text:
            (target, reason) = list(map(str.strip, text.split(' for ', 1)))
        else:
            (target, reason) = (text, '')
        if id is not None:
            try:
                lart = self.db.get(channel, id)
            except KeyError:
                irc.error(format(_('There is no lart with id #%i.'), id))
                return
        else:
            lart = self.db.random(channel)
            if not lart:
                irc.error(format(_('There are no larts in my database '
                                 'for %s.'), channel))
                return
        text = lart.text
        if ircutils.strEqual(target, irc.nick):
            target = msg.nick
            reason = self._replaceFirstPerson(_('trying to dis me'), irc.nick)
        else:
            target = self._replaceFirstPerson(target, msg.nick)
            reason = self._replaceFirstPerson(reason, msg.nick)
        if target.endswith('.'):
            target = target.rstrip('.')
        text = text.replace('$who', target)
        if reason:
            text += _(' for ') + reason
        if self.registryValue('showIds', channel):
            text += format(' (#%i)', lart.id)
        irc.reply(text, action=True)
    lart = wrap(lart, ['channeldb', optional('id'), 'text'])

Class = Lart

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2005, Daniel DiPaolo
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

class LartTestCase(ChannelPluginTestCase):
    plugins = ('Lart', 'User')

    def setUp(self):
        ChannelPluginTestCase.setUp(self)
        # Create a valid user to use
        self.prefix = 'mf!bar@baz'
        self.irc.feedMsg(ircmsgs.privmsg(self.nick, 'register tester moo',
                                         prefix=self.prefix))
        m = self.irc.takeMsg() # Response to register.

    def testAdd(self):
        self.assertError('lart add foo')  # needs $who
        self.assertNotError('lart add smacks $who')

    def testLart(self):
        self.assertError('lart foo')  # no praises!
        self.assertNotError('lart add smacks $who')
        self.assertAction('lart foo', 'smacks foo')

    def testMeInReason(self):
        self.assertNotError('lart add makes $who sit by me')
        self.assertAction('lart foo', 'makes foo sit by me')

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Later')

def configure(advanced):
    # This will be called by setup.py to configure this module.  Advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Later', True)

Later = conf.registerPlugin('Later')
conf.registerGlobalValue(Later, 'maximum',
    registry.NonNegativeInteger(0, _("""Determines the maximum number of
    messages to be queued for a user.  If this value is 0, there is no maximum.
    """)))
conf.registerGlobalValue(Later, 'private',
    registry.Boolean(True, _("""Determines whether users will be notified in
    the first place in which they're seen, or in private.""")))
conf.registerGlobalValue(Later, 'tellOnJoin',
    registry.Boolean(True, _("""Determines whether users will be notified upon
    joining any channel the bot is in, or only upon sending a message.""")))
conf.registerGlobalValue(Later, 'messageExpiry',
    registry.NonNegativeInteger(30, _("""Determines the maximum number of
    days that a message will remain queued for a user. After this time elapses,
    the message will be deleted. If this value is 0, there is no maximum.""")))

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2004, Jeremiah Fincher
# Copyright (c) 2010, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import csv
import time
import datetime

import supybot.log as log
import supybot.conf as conf
import supybot.utils as utils
from supybot.commands import *
import supybot.ircmsgs as ircmsgs
import supybot.ircutils as ircutils
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Later')

class Later(callbacks.Plugin):
    """Used to do things later; currently, it only allows the sending of
    nick-based notes.  Do note (haha!) that these notes are *not* private
    and don't even pretend to be; if you want such features, consider using the
    Note plugin."""
    def __init__(self, irc):
        self.__parent = super(Later, self)
        self.__parent.__init__(irc)
        self._notes = ircutils.IrcDict()
        self.wildcards = []
        self.filename = conf.supybot.directories.data.dirize('Later.db')
        self._openNotes()

    def die(self):
        self._flushNotes()

    def _flushNotes(self):
        fd = utils.file.AtomicFile(self.filename)
        writer = csv.writer(fd)
        for (nick, notes) in self._notes.iteritems():
            for (time, whence, text) in notes:
                writer.writerow([nick, time, whence, text])
        fd.close()

    def _openNotes(self):
        try:
            fd = open(self.filename)
        except EnvironmentError as e:
            self.log.warning('Couldn\'t open %s: %s', self.filename, e)
            return
        reader = csv.reader(fd)
        for (nick, time, whence, text) in reader:
            self._addNote(nick, whence, text, at=float(time), maximum=0)
        fd.close()

    def _timestamp(self, when):
        #format = conf.supybot.reply.format.time()
        diff = when - time.time()
        try:
            return utils.timeElapsed(diff, seconds=False)
        except ValueError:
            return _('just now')

    def _addNote(self, nick, whence, text, at=None, maximum=None):
        if at is None:
            at = time.time()
        if maximum is None:
            maximum = self.registryValue('maximum')
        try:
            notes = self._notes[nick]
            if maximum and len(notes) >= maximum:
                raise ValueError
            else:
                notes.append((at, whence, text))
        except KeyError:
            self._notes[nick] = [(at, whence, text)]
        if '?' in nick or '*' in nick and nick not in self.wildcards:
            self.wildcards.append(nick)
        self._flushNotes()

    def _validateNick(self, irc, nick):
        """Validate nick according to the IRC RFC 2812 spec.

        Reference: http://tools.ietf.org/rfcmarkup?doc=2812#section-2.3.1

        Some irc clients' tab-completion feature appends 'address' characters
        to nick, such as ':' or ','. We try correcting for that by trimming
        a char off the end.

        If nick incorrigibly invalid, return False, otherwise,
        return (possibly trimmed) nick.
        """
        if not irc.isNick(nick):
            if not irc.isNick(nick[:-1]):
                return False
            else:
                return nick[:-1]
        return nick

    def _deleteExpired(self):
        expiry = self.registryValue('messageExpiry')
        curtime = time.time()
        nickremovals=[]
        for (nick, notes) in self._notes.iteritems():
            removals = []
            for (notetime, whence, text) in notes:
                td = datetime.timedelta(seconds=(curtime - notetime))
                if td.days > expiry:
                    removals.append((notetime, whence, text))
            for note in removals:
                notes.remove(note)
            if len(notes) == 0:
                nickremovals.append(nick)
        for nick in nickremovals:
            del self._notes[nick]
        self._flushNotes()

    ## Note: we call _deleteExpired from 'tell'. This means that it's possible
    ## for expired notes to remain in the database for longer than the maximum,
    ## if no tell's are called.
    ## However, the whole point of this is to avoid crud accumulation in the
    ## database, so it's fine that we only delete expired notes when we try
    ## adding new ones.

    @internationalizeDocstring
    def tell(self, irc, msg, args, nick, text):
        """<nick> <text>

        Tells <nick> <text> the next time <nick> is seen.  <nick> can
        contain wildcard characters, and the first matching nick will be
        given the note.
        """
        self._deleteExpired()
        if ircutils.strEqual(nick, irc.nick):
            irc.error(_('I can\'t send notes to myself.'))
            return
        validnick = self._validateNick(irc, nick)
        if validnick is False:
            irc.error('That is an invalid IRC nick. Please check your input.')
            return
        try:
            self._addNote(validnick, msg.nick, text)
            irc.replySuccess()
        except ValueError:
            irc.error(_('That person\'s message queue is already full.'))
    tell = wrap(tell, ['something', 'text'])

    @internationalizeDocstring
    def notes(self, irc, msg, args, nick):
        """[<nick>]

        If <nick> is given, replies with what notes are waiting on <nick>,
        otherwise, replies with the nicks that have notes waiting for them.
        """
        if nick:
            if nick in self._notes:
                notes = [self._formatNote(when, whence, note)
                         for (when, whence, note) in self._notes[nick]]
                irc.reply(format('%L', notes))
            else:
                irc.error(_('I have no notes for that nick.'))
        else:
            nicks = self._notes.keys()
            if nicks:
                utils.sortBy(ircutils.toLower, nicks)
                irc.reply(format(_('I currently have notes waiting for %L.'),
                                 nicks))
            else:
                irc.error(_('I have no notes waiting to be delivered.'))
    notes = wrap(notes, [additional('something')])

    @internationalizeDocstring
    def remove(self, irc, msg, args, nick):
        """<nick>

        Removes the notes waiting on <nick>.
        """
        try:
            del self._notes[nick]
            self._flushNotes()
            irc.replySuccess()
        except KeyError:
            irc.error(_('There were no notes for %r') % nick)
    remove = wrap(remove, [('checkCapability', 'admin'), 'something'])

    @internationalizeDocstring
    def undo(self, irc, msg, args, nick):
        """<nick>

        Removes the latest note you sent to <nick>.
        """
        if nick not in self._notes:
            irc.error(_('There are no note waiting for %s.') % nick)
            return
        self._notes[nick].reverse()
        for note in self._notes[nick]:
            if note[1] == msg.nick:
                self._notes[nick].remove(note)
                if len(self._notes[nick]) == 0:
                    del self._notes[nick]
                self._flushNotes()
                irc.replySuccess()
                return
        irc.error(_('There are no note from you waiting for %s.') % nick)
    undo = wrap(undo, ['something'])

    def doPrivmsg(self, irc, msg):
        if ircmsgs.isCtcp(msg) and not ircmsgs.isAction(msg):
            return
        notes = self._notes.pop(msg.nick, [])
        # Let's try wildcards.
        removals = []
        for wildcard in self.wildcards:
            if ircutils.hostmaskPatternEqual(wildcard, msg.nick):
                removals.append(wildcard)
                notes.extend(self._notes.pop(wildcard))
            for removal in removals:
                self.wildcards.remove(removal)
        if notes:
            irc = callbacks.SimpleProxy(irc, msg)
            private = self.registryValue('private')
            for (when, whence, note) in notes:
                s = self._formatNote(when, whence, note)
                irc.reply(s, private=private, prefixNick=not private)
            self._flushNotes()

    def _formatNote(self, when, whence, note):
        return _('Sent %s: <%s> %s') % (self._timestamp(when), whence, note)

    def doJoin(self, irc, msg):
        if self.registryValue('tellOnJoin'):
            self.doPrivmsg(irc, msg)
Later = internationalizeDocstring(Later)

Class = Later

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2002-2004, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *
import time

class LaterTestCase(ChannelPluginTestCase):
    plugins = ('Later',)
    def testLaterWorksTwice(self):
        self.assertNotError('later tell foo bar')
        self.assertNotError('later tell foo baz')

    def testLaterRemove(self):
        self.assertNotError('later tell foo 1')
        self.assertNotError('later tell bar 1')
        self.assertRegexp('later notes', 'bar.*foo')
        self.assertNotError('later remove bar')
        self.assertNotRegexp('later notes', 'bar.*foo')
        self.assertRegexp('later notes', 'foo')

    def testLaterUndo(self):
        self.assertNotError('later tell foo 1')
        self.assertNotError('later tell bar 1')
        self.assertRegexp('later notes', 'bar.*foo')
        self.assertNotError('later undo foo')
        self.assertNotRegexp('later notes', 'bar.*foo')
        self.assertRegexp('later notes', 'bar')

    def testNickValidation(self):
        origconf = conf.supybot.protocols.irc.strictRfc()
        conf.supybot.protocols.irc.strictRfc.setValue('True')
        self.assertError('later tell 1foo bar')
        self.assertError('later tell foo$moo zoob')
        self.assertNotError('later tell foo: baz')
        self.assertRegexp('later notes', 'foo\.')
        conf.supybot.protocols.irc.strictRfc.setValue(origconf)

    def testNoteExpiry(self):
        cb = self.irc.getCallback('Later')
        # add a note 40 days in the past
        cb._addNote('foo', 'test', 'some stuff', at=(time.time() - 3456000))
        self.assertRegexp('later notes', 'foo')
        self.assertNotError('later tell moo stuff')
        self.assertNotRegexp('later notes', 'foo')
        self.assertRegexp('later notes', 'moo')

    def testNoteSend(self):
        self.assertNotError('later tell foo stuff')
        self.assertNotError('later tell bar more stuff')
        self.assertRegexp('later notes', 'bar.*foo')
        testPrefix = 'foo!bar@baz'
        self.irc.feedMsg(ircmsgs.privmsg(self.channel, 'something',
                                         prefix=testPrefix))
        m = self.getMsg(' ')
        self.assertEqual(str(m).strip(),
                'PRIVMSG foo :Sent just now: <test> stuff')
        self.assertNotRegexp('later notes', 'foo')
        self.assertRegexp('later notes', 'bar')

        real_time = time.time
        def fake_time():
            return real_time() + 62
        time.time = fake_time
        self.irc.feedMsg(ircmsgs.privmsg(self.channel, 'something',
                                         prefix='bar!baz@qux'))
        m = self.getMsg(' ')
        self.assertEqual(str(m).strip(),
                'PRIVMSG bar :Sent 1 minute ago: <test> more stuff')
        time.time = real_time
        
# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:


########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2004-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Limiter')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Limiter', True)


Limiter = conf.registerPlugin('Limiter')
conf.registerChannelValue(Limiter, 'enable',
    registry.Boolean(False, _("""Determines whether the bot will maintain the
    channel limit to be slightly above the current number of people in the
    channel, in order to make clone/drone attacks harder.""")))
conf.registerChannelValue(Limiter, 'minimumExcess',
    registry.PositiveInteger(5, _("""Determines the minimum number of free
    spots that will be saved when limits are being enforced.  This should
    always be smaller than supybot.plugins.Limiter.limit.maximumExcess.""")))
conf.registerChannelValue(Limiter, 'maximumExcess',
    registry.PositiveInteger(10, _("""Determines the maximum number of free spots
    that will be saved when limits are being enforced.  This should always be
    larger than supybot.plugins.Limiter.limit.minimumExcess.""")))


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2004-2005, Jeremiah Fincher
# Copyright (c) 2009, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.commands import *
import supybot.ircmsgs as ircmsgs
import supybot.ircutils as ircutils
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Limiter')

class Limiter(callbacks.Plugin):
    """In order to use this plugin, its config values need to be properly
    setup.  supybot.plugins.Limiter.enable needs to be set to True and
    supybot.plugins.Limiter.{maximumExcess,minimumExcess} should be set to
    values appropriate to your channel (if the defaults aren't satisfactory).
    Once these are set, and someone enters/leaves the channel, Supybot will
    start setting the proper +l modes.
    """
    def _enforce(self, irc, limit):
        irc.queueMsg(limit)
        irc.noReply()

    def _enforceLimit(self, irc, channel):
        if self.registryValue('enable', channel):
            maximum = self.registryValue('maximumExcess', channel)
            minimum = self.registryValue('minimumExcess', channel)
            assert maximum > minimum
            currentUsers = len(irc.state.channels[channel].users)
            currentLimit = irc.state.channels[channel].modes.get('l', 0)
            if currentLimit - currentUsers < minimum:
                self._enforce(irc, ircmsgs.limit(channel,currentUsers+maximum))
            elif currentLimit - currentUsers > maximum:
                self._enforce(irc, ircmsgs.limit(channel,currentUsers+minimum))

    def doJoin(self, irc, msg):
        if not ircutils.strEqual(msg.nick, irc.nick):
            irc = callbacks.SimpleProxy(irc, msg)
            self._enforceLimit(irc, msg.args[0])
    doPart = doJoin
    doKick = doJoin

    def doQuit(self, irc, msg):
        for channel in irc.state.channels:
            self._enforceLimit(irc, channel)
Limiter = internationalizeDocstring(Limiter)

Class = Limiter


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2004-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

class LimiterTestCase(ChannelPluginTestCase):
    plugins = ('Limiter',)
    config = {'supybot.plugins.Limiter.enable': True}
    def testEnforceLimit(self):
        origMin = conf.supybot.plugins.Limiter.minimumExcess()
        origMax = conf.supybot.plugins.Limiter.maximumExcess()
        try:
            conf.supybot.plugins.Limiter.minimumExcess.setValue(5)
            conf.supybot.plugins.Limiter.maximumExcess.setValue(10)
            self.irc.feedMsg(ircmsgs.join('#foo', prefix='foo!root@host'))
            m = self.irc.takeMsg()
            self.assertEqual(m, ircmsgs.limit('#foo', 1+10))
            self.irc.feedMsg(ircmsgs.join('#foo', prefix='bar!root@host'))
            m = self.irc.takeMsg()
            self.failIf(m is not None)
            conf.supybot.plugins.Limiter.maximumExcess.setValue(7)
            self.irc.feedMsg(ircmsgs.part('#foo', prefix='bar!root@host'))
            m = self.irc.takeMsg()
            self.assertEqual(m, ircmsgs.limit('#foo', 1+5))
        finally:
            conf.supybot.plugins.Limiter.minimumExcess.setValue(origMin)
            conf.supybot.plugins.Limiter.maximumExcess.setValue(origMax)


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2004, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Math')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Math', True)


Math = conf.registerPlugin('Math')
# This is where your configuration variables (if any) should go.  For example:
# conf.registerGlobalValue(Math, 'someConfigVariableName',
#     registry.Boolean(False, _("""Help for someConfigVariableName.""")))


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = convertcore
#****************************************************************************
# This file has been modified from its original version. It has been
# formatted to fit your irc bot.
#
# The original version is a nifty PyQt application written by Douglas Bell,
# available at  http://convertall.bellz.org/
#
# Below is the original copyright. Doug Bell rocks.
# The hijacker is Keith Jones, and he has no bomb in his shoe.
#
#****************************************************************************

import re, copy, sys, os.path, StringIO

import supybot.conf as conf
import supybot.registry as registry

unitData = \
"""
#*****************************************************************************
# units.dat, the units data file, version 0.3.1
#
# ConvertAll, a units conversion program
# Copyright (C) 2005, Douglas W. Bell
#
# This is free software; you can redistribute it and/or modify it under the
# terms of the GNU General Public License, Version 2.  This program is
# distributed in the hope that it will be useful, but WITTHOUT ANY WARRANTY.
#*****************************************************************************
#
# Units are defined by an optional quantity and an equivalent unit or unit
# combination.  A python expression may be used for the quantity, but is
# resticted to using only the following operators: *, /, +, -, **, (, ).
# Beware of integer division truncation: be sure to use a float for at
# least one of the values.
#
# The unit type must be placed in square brackets before a set of units.
# The first comment after the equivalent unit will be put in parenthesis after
# the unit name (usually used to give the full name of an abbreviated unit).
# The next comment will be used in the program list's comment column;
# later comments and full line comments are ignored.
#
# Non-linear units are indicated with an equivalent unit in square brackets,
# followed by either equations or equivalency lists for the definition.
# For equations, two are given, separated by a ';'.  Both are functions of
# "x", the first going from the unit to the equivalent unit and the second
# one in reverse.  Any valid Python expression returning a float (including 
# the functions in the math module) should work.  The equivalency list is a 
# python list of tuples giving points for linear interpolation.
#
# All units must reduce to primitive units, which are indicated by an '!'
# as the equivalent unit.  Circular refernces must also be avoided.
#
# Primitive units:  kg, m, s, K, A, mol, cd, rad, sr, bit, unit
#
##############################################################################

#
# mass units
#
[mass]
kg                = !                  # kilogram
kilogram          = kg
key               = kg                 # # drug slang
hectogram         = 100 gram
dekagram          = 10 gram
gram              = 0.001 kg
g                 = gram               # gram
decigram          = 0.1 gram
centigram         = 0.01 gram
milligram         = 0.001 gram
mg                = milligram          # milligram
microgram         = 0.001 mg
tonne             = 1000 kg            # # metric
metric ton        = tonne
megagram          = tonne
kilotonne         = 1000 tonne         # # metric
gigagram          = 1e9 gram
teragram          = 1e12 gram
carat             = 0.2 gram
ct                = carat              # carat
amu               = 1.66053873e-27 kg  # atomic mass
atomic mass unit  = amu
pound             = 0.45359237 kg
lb                = pound              # pound
lbm               = pound              # pound
ounce             = 1/16.0 pound
oz                = ounce              # ounce
lid               = ounce              # # drug slang
pound troy        = 5760 grain
lb troy           = pound troy         # pound troy
ounce troy        = 1/12.0 lb troy
oz troy           = ounce troy         # ounce troy
ton               = 2000 lb            # # non-metric
kiloton           = 1000 ton           # # non-metric
slug              = lbf*s^2/ft
stone             = 14 lb
grain             = 1/7000.0 lb


#
# length / distance units
#
[length]
m                    = !              # meter
meter                = m
metre                = m
decimeter            = 0.1 m
cm                   = 0.01 m         # centimeter
centimeter           = cm
mm                   = 0.001 m        # millimeter
millimeter           = mm
micrometer           = 1e-6 m
micron               = micrometer
nanometer            = 1e-9 m
nm                   = nanometer      # nanometer
dekameter            = 10 m
hectometer           = 100 m
km                   = 1000 m         # kilometer
kilometer            = km
megameter            = 1000 km
angstrom             = 1e-10 m
fermi                = 1e-15 m        # # nuclear sizes
inch                 = 2.54 cm
in                   = inch           # inch
inches               = inch
mil                  = 0.001 inch
microinch            = 1e-6 inch
microinches          = microinch
foot                 = 12 inch
ft                   = foot           # foot
feet                 = foot
yard                 = 3 ft
yd                   = yard           # yard
mile                 = 5280 ft
mi                   = mile           # mile
nautical mile        = 1852 m
nmi                  = nautical mile  # nautical mile
league               = 3 mile
chain                = 66 ft
fathom               = 6 ft
rod                  = 5.5 yard
furlong              = 40 rod
hand                 = 4 inch
cubit                = 21.8 inch      # # biblical unit
point                = 1/72.27 inch
pica                 = 12 point
caliber              = 0.01 inch      # # bullet sizes
football field       = 100 yd
marathon             = 46145 yd
mil Swedish          = 10 km
au                   = 1.49597870691e11 m   # astronomical unit
astronomical unit    = au
light year           = 365.25 light speed * day
light minute         = light speed * min
light second         = light speed * s
parsec               = 3.0856775813e16 m
kiloparsec           = 1000 parsec
megaparsec           = 1000 kiloparsec
screw size           = [in] 0.013*x + 0.06 ; (x - 0.06) / 0.013 \
                       # # Unified diameters, non-linear
AWG                  = [in] 92.0**((36-x)/39.0)/200.0 ; \
                       36 - 39.0*log(200.0*x)/log(92.0) \
                       # American Wire Gauge \
                       # use -1, -2 for 00, 000; non-linear
American Wire Gauge  = [in] 92.0**((36-x)/39.0)/200.0 ; \
                       36 - 39.0*log(200.0*x)/log(92.0) \
                       #  # use -1, -2 for 00, 000; non-linear
standard gauge       = [in] [(-5, .448350), (1, .269010), (14, .0747250), \
                       (16, .0597800), (17, .0538020), (20, .0358680), \
                       (26, .0179340), (31, .0104615), (36, .00672525), \
                       (38, .00597800)] # steel \
                       # Manufacturers Std. Gauge, non-linear
zinc gauge           = [in] [(1, .002), (10, .02), (15, .04), (19, .06), \
                       (23, .1), (24, .125), (27, .5), (28, 1)]  \
                       # # sheet metal thickness, non-linear
ring size            = [in] 0.1018*x + 1.4216 ; (x - 1.4216) / 0.1018  \
                       # # US size, circum., non-linear
shoe size mens       = [in] x/3.0 + 7 + 1/3.0 ; (x - 7 - 1/3.0) * 3 \
                       # # US sizes, non-linear
shoe size womens     = [in] x/3.0 + 6 + 5/6.0 ; (x - 6 - 5/6.0) * 3 \
                       # # US sizes, non-linear


#
# time units
#
[time]
s             = !                 # second
sec           = s                 # second
second        = s
ms            = 0.001 s           # millisecond
millisecond   = ms
microsecond   = 1e-6 s
ns            = 1e-9 s            # nanosecond
nanosecond    = ns
minute        = 60 s
min           = minute            # minute
hour          = 60 min
hr            = hour              # hour
bell          = 30 min            #  # naval definition
watch         = 4 hour
watches       = watch
day           = 24 hr
week          = 7 day
wk            = week              # week
fortnight     = 14 day
month         = 1/12.0 year
year          = 365.242198781 day
yr            = year              # year
calendar year = 365 day
decade        = 10 year
century       = 100 year
centuries     = century
millennium    = 1000 year
millennia     = millennium
[scheduling]
man hour      = 168/40.0 hour
man week      = 40 man hour
man month     = 1/12.0 man year
man year      = 52 man week


#
# temperature
#
[temperature]
K                 = !     # Kelvin
Kelvin            = K
deg K             = K     # Kelvin
degree Kelvin     = K

C                 = [K] x + 273.15 ; x - 273.15  # Celsius  # non-linear
Celsius           = [K] x + 273.15 ; x - 273.15  #          # non-linear
deg C             = [K] x + 273.15 ; x - 273.15  # Celsius  # non-linear
degree Celsius    = [K] x + 273.15 ; x - 273.15  #          # non-linear

R                 = 5/9.0 K     # Rankine
Rankine           = R
deg R             = R           # Rankine
F                 = [R] x + 459.67 ; x - 459.67  # Fahrenheit  # non-linear
Fahrenheit        = [R] x + 459.67 ; x - 459.67  #             # non-linear
deg F             = [R] x + 459.67 ; x - 459.67  # Fahrenheit  # non-linear
degree Fahrenheit = [R] x + 459.67 ; x - 459.67  #             # non-linear

[temp. diff.]
C deg             = K        # Celsius degree
Celsius degree    = C deg
F deg             = R        # Fahrenheit deg.
Fahrenheit degree = F deg


#
# electrical units
#
[current]
A              = !              # ampere
ampere         = A
amp            = A
milliampere    = 0.001 A
milliamp       = milliampere
mA             = milliampere    # milliampere
microampere    = 0.001 mA
kiloampere     = 1000 A
kA             = kiloampere     # kiloampere
[charge]
coulomb        = A*s
amp hour       = A*hr
mAh            = 0.001 amp hour # milliamp hour
milliamp hour  = mAh
[potential]
volt           = W/A
V              = volt           # volt
millivolt      = 0.001 volt
mV             = millivolt      # millivolt
kilovolt       = 1000 volt
kV             = kilovolt       # kilovolt
[resistance]
ohm            = V/A
milliohm       = 0.001 ohm
microhm        = 0.001 milliohm
kilohm         = 1000 ohm
[conductance]
siemens        = A/V
[capacitance]
farad          = coulomb/V
millifarad     = 0.001 farad
microfarad     = 0.001 millifarad
nanofarad      = 1e-9 farad
picofarad      = 1e-12 farad
[magn. flux]
weber          = V*s
Wb             = weber          # weber
[inductance]
henry          = Wb/A
H              = henry          # henry
millihenry     = 0.001 henry
mH             = millihenry     # millihenry
microhenry     = 0.001 mH
[flux density]
tesla          = Wb/m^2
T              = tesla          # tesla


#
# molecular units
#
[molecular qty]
mol          = !           # mole       # gram mole
mole         = mol         #            # gram mole
gram mole    = mol
kilomole     = 1000 mol
kmol         = kilomole    # kilomole
pound mole   = mol*lbm/gram
lbmol        = pound mole  # pound mole
[size of a mol]
avogadro     = gram/amu*mol


#
# Illumination units
#
[lum. intens.]
cd          = !          # candela
candela     = cd

[luminous flux]
lumen        = cd * sr
lm           = lumen     # lumen

[illuminance]
lux          = lumen/m^2
footcandle   = lumen/ft^2
metercandle  = lumen/m^2

[luminance]
lambert      = cd/pi*cm^2
millilambert = 0.001 lambert
footlambert  = cd/pi*ft^2


#
# angular units
#
[angle]
radian      = !
rad         = radian         # radian
circle      = 2 pi*radian
turn        = circle
revolution  = circle
rev         = revolution     # revolution
degree      = 1/360.0 circle
deg         = degree         # degree
arc min     = 1/60.0 degree  # minute
arc minute  = arc min
min arc     = arc min        # minute
minute arc  = arc min
arc sec     = 1/60.0 arc min # second
arc second  = arc sec
sec arc     = arc sec        # second
second arc  = arc sec
quadrant    = 1/4.0 circle
right angle = quadrant
gradian     = 0.01 quadrant


#
# solid angle units
#
[solid angle]
sr         = !      # steradian
steradian  = sr
sphere     = 4 pi*sr
hemisphere = 1/2.0 sphere


#
# information units
#
[data]
bit              = !
kilobit          = 1000 bit          #                  # based on power of 10
megabit          = 1000 kilobit      #                  # based on power of 10
byte             = 8 bit
B                = byte              # byte
kilobyte         = 1024 byte         #                  # based on power of 2
kB               = kilobyte          # kilobyte         # based on power of 2
megabyte         = 1024 kB           #                  # based on power of 2
MB               = megabyte          # megabyte         # based on power of 2
gigabyte         = 1024 MB           #                  # based on power of 2
GB               = gigabyte          # gigabyte         # based on power of 2
terabyte         = 1024 GB           #                  # based on power of 2
TB               = terabyte          # terabyte         # based on power of 2
petabyte         = 1024 TB           #                  # based on power of 2
PB               = petabyte          # petabyte         # based on power of 2

kilobyte IEC std = 1000 byte         #                  # based on power of 10
kB IEC std       = kilobyte IEC std  # kilobyte         # based on power of 10
megabyte IEC std = 1000 kB IEC std   #                  # based on power of 10
MB IEC std       = megabyte IEC std  # megabyte         # based on power of 10
gigabyte IEC std = 1000 MB IEC std   #                  # based on power of 10
GB IEC std       = gigabyte IEC std  # gigabyte         # based on power of 10
terabyte IEC std = 1000 GB IEC std   #                  # based on power of 10
TB IEC std       = terabyte IEC std  # terabyte         # based on power of 10
petabyte IEC std = 1000 TB IEC std   #                  # based on power of 10
PB IEC std       = petabyte IEC std  # petabyte         # based on power of 10

kibibyte         = 1024 byte
KiB              = kibibyte          # kibibyte
mebibyte         = 1024 KiB
MiB              = mebibyte          # mebibyte
gibibyte         = 1024 MiB
GiB              = gibibyte          # gibibyte
tebibyte         = 1024 GiB
TiB              = tebibyte          # tebibyte
pebibyte         = 1024 TiB
PiB              = pebibyte          # pebibyte

[data transfer]
bps              = bit/sec           # bits / second
kbps             = 1000 bps          # kilobits / sec.  # based on power of 10


#
# Unitless numbers
#
[quantity]
unit               = !
1                  = unit            # unit
pi                 = 3.14159265358979323846 unit
pair               = 2 unit
hat trick          = 3 unit          # # sports
dozen              = 12 unit
doz                = dozen           # dozen
bakers dozen       = 13 unit
score              = 20 unit
gross              = 144 unit
great gross        = 12 gross
ream               = 500 unit
percent            = 0.01 unit
%                  = percent
mill               = 0.001 unit
[interest rate]
APR                = [unit] log(1 + x/100) ;  (exp(x) - 1)*100 \
                     # annual % rate # based on continuous compounding
[concentration]
proof              = 1/200.0 unit    # # alcohol content
ppm                = 1e-6 unit       # parts per million
parts per million  = ppm
ppb                = 1e-9 unit       # parts per billion
parts per billion  = ppb
ppt                = 1e-12 unit      # parts per trillion
parts per trillion = ppt
karat              = 1/24.0 unit     # # gold purity
carat gold         = karat           # # gold purity


#
# force units
#
[force]
newton         = kg*m/s^2
N              = newton          # newton
dekanewton     = 10 newton
kilonewton     = 1000 N
kN             = kilonewton      # kilonewton
meganewton     = 1000 kN
millinewton    = 0.001 N
dyne           = cm*g/s^2
kg force       = kg * gravity    # kilogram f
kgf            = kg force        # kilogram force
kilogram force = kg force
gram force     = g * gravity
pound force    = lbm * gravity
lbf            = pound force     # pound force
ton force      = ton * gravity
ounce force    = ounce * gravity
ozf            = ounce force     # ounce force


#
# area units
#
[area]
barn          = 1e-28 m^2       # # particle physics
are           = 100 m^2
decare        = 10 are
dekare        = 10 are
hectare       = 100 are
acre          = 10 chain^2
section       = mile^2
township      = 36 section
homestead     = 160 acre
rai           = 1600 m^2        # # Thai
ngaan         = 400 m^2         # # Thai
circular inch = 1/4.0 pi*in^2   # # area of 1 inch circle
circular mil  = 1/4.0 pi*mil^2  # # area of 1 mil circle


#
# volume units
#
[volume]
cc                   = cm^3                 # cubic centimeter
cubic centimeter     = cc
liter                = 1000 cc
l                    = liter                # liter
litre                = liter
deciliter            = 0.1 liter
centiliter           = 0.01 liter
milliliter           = cc
ml                   = milliliter           # milliliter
dekaliter            = 10 liter
hectoliter           = 100 liter
kiloliter            = 1000 liter
kl                   = kiloliter            # kiloliter
megaliter            = 1000 kiloliter
gallon               = 231 in^3             #             # US liquid
gal                  = gallon               # gallon      # US liquid
quart                = 1/4.0 gallon         #             # US liquid
qt                   = quart                # quart       # US liquid
pint                 = 1/2.0 quart          #             # US liquid
pt                   = pint                 # pint        # US liquid
fluid ounce          = 1/16.0 pint          #             # US
fl oz                = fluid ounce          # fluid ounce # US
ounce fluid          = fluid ounce          #             # US
imperial gallon      = 4.54609 liter
imp gal              = imperial gallon      # imperial gallon
gallon imperial      = imperial gallon
imperial quart       = 1/4.0 imp gal
imp qt               = imperial quart       # imperial quart
quart imperial       = imperial quart
imperial pint        = 1/8.0 imp gal
imp pt               = imperial pint        # imperial pint
pint imperial        = imperial pint
imperial fluid ounce = 1/160.0 imp gal
imp fl oz            = imperial fluid ounce # imperial fluid ounce
cup                  = 8 fl oz
tablespoon           = 1/16.0 cup
tbsp                 = tablespoon           # tablespoon
teaspoon             = 1/3.0 tbsp
tsp                  = teaspoon             # teaspoon
barrel               = 42 gallon
bbl                  = barrel               # barrel
shot                 = 1.5 fl oz
fifth                = 1/5.0 gallon         #             # alcohol
wine bottle          = 750 ml
magnum               = 1.5 liter            #             # alcohol
keg                  = 15.5 gallon          #             # beer
hogshead wine        = 63 gal
hogshead beer        = 54 gal
bushel               = 2150.42 in^3
peck                 = 1/4.0 bushel
cord                 = 128 ft^3
board foot           = ft^2*in
board feet           = board foot


#
# velocity units
#
[velocity]
knot        = nmi/hr
kt          = knot             # knot
light speed = 2.99792458e8 m/s
mph         = mi/hr            # miles/hour
kph         = km/hr            # kilometers/hour
mach        = 340.29 m/s       # # speed sound at STP
[rot. velocity]
rpm         = rev/min          # rev/min
rps         = rev/sec          # rev/sec


#
# flow rate units
#
[fluid flow]
gph         = gal/hr           # gallons/hour
gpm         = gal/min          # gallons/minute
cfs         = ft^3/sec         # cu ft/second
cfm         = ft^3/min         # cu ft/minute
lpm         = l/min            # liter/min
[gas flow]
sccm        = atm*cc/min       # std cc/min      # pressure * flow
sccs        = atm*cc/sec       # std cc/sec      # pressure * flow
slpm        = atm*l/min        # std liter/min   # pressure * flow
slph        = atm*l/hr         # std liter/hour  # pressure * flow
scfh        = atm*ft^3/hour    # std cu ft/hour  # pressure * flow
scfm        = atm*ft^3/min     # std cu ft/min   # pressure * flow


#
# pressure units
#
[pressure]
Pa                    = N/m^2                    # pascal
pascal                = Pa
hPa                   = 100 Pa                   # hectopascal
hectopascal           = hPa
kPa                   = 1000 Pa                  # kilopascal
kilopascal            = kPa
MPa                   = 1000 kPa                 # megapascal
megapascal            = MPa
GPa                   = 1000 MPa                 # gigapascal
gigapascal            = GPa
atm                   = 101325 Pa                # atmosphere
atmosphere            = atm
bar                   = 1e5 Pa
mbar                  = 0.001 bar                # millibar
millibar              = mbar
microbar              = 0.001 mbar
decibar               = 0.1 bar
kilobar               = 1000 bar
megabar               = 1000 kilobar
mm Hg                 = mm*density Hg*gravity
millimeter of Hg      = mm Hg
torr                  = mm Hg
in Hg                 = in*density Hg*gravity    # inch of Hg
inch of Hg            = in Hg
m water               = m*density water*gravity  # meter of H2O
m H2O                 = m water                  # meter of H2O
meter of water        = m water
in water              = in*density water*gravity # inch of H2O
in H2O                = in water                 # inch of H2O
inch of water         = in water
ft water              = ft*density water*gravity # feet of H2O
ft H2O                = ft water                 # feet of H20
feet of water         = ft water
foot of head          = ft water
ft hd                 = ft water                 # foot of head
psi                   = lbf/in^2                 # pound / sq inch
pound per sq inch     = psi
ksi                   = 1000 psi                 # 1000 lb / sq inch


#
# density units
#
[density]
density water         = gram/cm^3
density sea water     = 1.025 gram/cm^3
density Hg            = 13.5950981 gram/cm^3
density air           = 1.293 kg/m^3          # # at STP
density steel         = 0.283 lb/in^3         # # carbon steel
density aluminum      = 0.098 lb/in^3
density zinc          = 0.230 lb/in^3
density brass         = 0.310 lb/in^3         # # 80Cu-20Zn
density copper        = 0.295 lb/in^3
density iron          = 0.260 lb/in^3         # # cast iron
density nickel        = 0.308 lb/in^3
density tin           = 0.275 lb/in^3
density titanium      = 0.170 lb/in^3
density silver        = 0.379 lb/in^3
density nylon         = 0.045 lb/in^3
density polycarbonate = 0.045 lb/in^3


#
# energy units
#
[energy]
joule                = N*m
J                    = joule             # joule
kilojoule            = 1000 joule
kJ                   = kilojoule         # kilojoule
megajoule            = 1000 kilojoule
gigajoule            = 1000 megajoule
millijoule           = 0.001 joule
mJ                   = millijoule        # millijoule
calorie              = 4.1868 J
cal                  = calorie           # calorie
kilocalorie          = 1000 cal
kcal                 = kilocalorie       # kilocalorie
calorie food         = kilocalorie
Btu                  = cal*lb*R/g*K      # British thermal unit
British thermal unit = Btu
erg                  = cm*dyne
electronvolt         = 1.602176462e-19 J
eV                   = electronvolt      # electronvolt
kWh                  = kW*hour           # kilowatt-hour
kilowatt hour        = kWh
ton TNT              = 4.184e9 J


#
# power units
#
[power]
watt              = J/s
W                 = watt            # watt
kilowatt          = 1000 W
kW                = kilowatt        # kilowatt
megawatt          = 1000 kW
MW                = megawatt        # megawatt
gigawatt          = 1000 MW
GW                = gigawatt        # gigawatt
milliwatt         = 0.001 W
horsepower        = 550 ft*lbf/sec
hp                = horsepower      # horsepower
metric horsepower = 75 kgf*m/s


#
# frequency
#
[frequency]
hertz       = unit/sec
Hz          = hertz      # hertz
millihertz  = 0.001 Hz
kilohertz   = 1000 Hz
kHz         = kilohertz  # kilohertz
megahertz   = 1000 kHz
MHz         = megahertz  # megahertz
gigahertz   = 1000 MHz
GHz         = gigahertz  # gigahertz


#
# radioactivity
#
[radioactivity]
becquerel       = unit/sec
Bq              = becquerel     # becquerel
curie           = 3.7e10 Bq
millicurie      = 0.001 curie
roentgen        = 2.58e-4 coulomb/kg
[radiation dose]
gray            = J/kg
Gy              = gray          # gray
rad. abs. dose  = 0.001 Gy      # # commonly rad
sievert         = J/kg          # # equiv. dose
millisievert    = 0.001 sievert # # equiv. dose
Sv              = sievert       # sievert # equiv. dose
rem             = 0.01 Sv       # # roentgen equiv mammal
millirem        = 0.001 rem     # # roentgen equiv mammal


#
# viscosity
#
[dyn viscosity]
poise        = g/cm*s
P            = poise       # poise
centipoise   = 0.01 poise
cP           = centipoise  # centipoise

[kin viscosity]
stokes       = cm^2/s
St           = stokes      # stokes
centistokes  = 0.01 stokes
cSt          = centistokes # centistokes


#
# misc. units
#
[acceleration]
gravity                = 9.80665 m/s^2
[constant]
gravity constant       = 6.673e-11 N*m^2/kg^2
gas constant           = 8.314472 J/mol*K     # R
[fuel consumpt.]
mpg                    = mi/gal               # miles/gallon
liter per 100 km       = [mpg] 3.785411784 / (x * 0.01609344) ; \
                         3.785411784 / (x * 0.01609344) # # non-linear

"""


class UnitGroup:
    "Stores, updates and converts a group of units"
    maxDecPlcs = 8
    def __init__(self, unitData, option):
        self.unitData = unitData
        self.option = option
        self.unitList = []
        self.currentNum = 0
        self.factor = 1.0
        self.reducedList = []
        self.linear = 1

    def update(self, text, cursorPos=None):
        "Decode user entered text into units"
        self.unitList = self.parseGroup(text)
        if cursorPos != None:
            self.updateCurrentUnit(text, cursorPos)
        else:
            self.currentNum = len(self.unitList) - 1

    def updateCurrentUnit(self, text, cursorPos):
        "Set current unit number"
        self.currentNum = len(re.findall('[\*/]', text[:cursorPos]))

    def currentUnit(self):
        "Return current unit if its a full match, o/w None"
        if self.unitList and self.unitList[self.currentNum].equiv:
            return self.unitList[self.currentNum]
        return None

    def currentPartialUnit(self):
        "Return unit with at least a partial match, o/w None"
        if not self.unitList:
            return None
        return self.unitData.findPartialMatch(self.unitList[self.currentNum]\
                                              .name)

    def currentSortPos(self):
        "Return unit near current unit for sorting"
        if not self.unitList:
            return self.unitData[self.unitData.sortedKeys[0]]
        return self.unitData.findSortPos(self.unitList[self.currentNum]\
                                         .name)

    def replaceCurrent(self, unit):
        "Replace the current unit with unit"
        if self.unitList:
            exp = self.unitList[self.currentNum].exp
            self.unitList[self.currentNum] = copy.copy(unit)
            self.unitList[self.currentNum].exp = exp
        else:
            self.unitList.append(copy.copy(unit))

    def completePartial(self):
        "Replace a partial unit with a full one"
        if self.unitList and not self.unitList[self.currentNum].equiv:
            text = self.unitList[self.currentNum].name
            unit = self.unitData.findPartialMatch(text)
            if unit:
                exp = self.unitList[self.currentNum].exp
                self.unitList[self.currentNum] = copy.copy(unit)
                self.unitList[self.currentNum].exp = exp

    def moveToNext(self, upward):
        "Replace unit with adjacent one based on match or sort position"
        unit = self.currentSortPos()
        num = self.unitData.sortedKeys.index(unit.name.\
                                             replace(' ', '')) \
                                             + (upward and -1 or 1)
        if 0 <= num < len(self.unitData.sortedKeys):
            self.replaceCurrent(self.unitData[self.unitData.sortedKeys[num]])

    def addOper(self, mult):
        "Add new operator & blank unit after current, * if mult is true"
        if self.unitList:
            self.completePartial()
            prevExp = self.unitList[self.currentNum].exp
            self.currentNum += 1
            self.unitList.insert(self.currentNum, Unit(''))
            if (not mult and prevExp > 0) or (mult and prevExp < 0):
                self.unitList[self.currentNum].exp = -1

    def changeExp(self, newExp):
        "Change the current unit's exponent"
        if self.unitList:
            self.completePartial()
            if self.unitList[self.currentNum].exp > 0:
                self.unitList[self.currentNum].exp = newExp
            else:
                self.unitList[self.currentNum].exp = -newExp

    def clearUnit(self):
        "Remove units"
        self.unitList = []

    def parseGroup(self, text):
        "Return list of units from text string"
        unitList = []
        parts = [part.strip() for part in re.split('([\*/])', text)]
        numerator = 1
        while parts:
            unit = self.parseUnit(parts.pop(0))
            if not numerator:
                unit.exp = -unit.exp
            if parts and parts.pop(0) == '/':
                numerator = not numerator
            unitList.append(unit)
        return unitList

    def parseUnit(self, text):
        "Return a valid or invalid unit with exponent from a text string"
        parts = text.split('^', 1)
        exp = 1
        if len(parts) > 1:   # has exponent
            try:
                exp = int(parts[1])
            except ValueError:
                if parts[1].lstrip().startswith('-'):
                    exp = -Unit.partialExp  # tmp invalid exp
                else:
                    exp = Unit.partialExp
        unitText = parts[0].strip().replace(' ', '')
        unit = copy.copy(self.unitData.get(unitText, None))
        if not unit and unitText and unitText[-1] == 's' and not \
           self.unitData.findPartialMatch(unitText):   # check for plural
            unit = copy.copy(self.unitData.get(unitText[:-1], None))
        if not unit:
            #unit = Unit(parts[0].strip())   # tmp invalid unit
            raise UnitDataError('%s is not a valid unit.' % (unitText))
        unit.exp = exp
        return unit

    def unitString(self, unitList=None):
        "Return the full string for this group or a given group"
        if unitList == None:
            unitList = self.unitList[:]
        fullText = ''
        if unitList:
            fullText = unitList[0].unitText(0)
            numerator = 1
            for unit in unitList[1:]:
                if (numerator and unit.exp > 0) \
                   or (not numerator and unit.exp < 0):
                    fullText = '%s * %s' % (fullText, unit.unitText(1))
                else:
                    fullText = '%s / %s' % (fullText, unit.unitText(1))
                    numerator = not numerator
        return fullText

    def groupValid(self):
        "Return 1 if all unitself.reducedLists are valid"
        if not self.unitList:
            return 0
        for unit in self.unitList:
            if not unit.unitValid():
                return 0
        return 1

    def reduceGroup(self):
        "Update reduced list of units and factor"
        self.linear = 1
        self.reducedList = []
        self.factor = 1.0
        if not self.groupValid():
            return
        count = 0
        tmpList = self.unitList[:]
        while tmpList:
            count += 1
            if count > 5000:
                raise UnitDataError('Circular unit definition')
            unit = tmpList.pop(0)
            if unit.equiv == '!':
                self.reducedList.append(copy.copy(unit))
            elif not unit.equiv:
                raise UnitDataError('Invalid conversion for "%s"' % unit.name)
            else:
                if unit.fromEqn:
                    self.linear = 0
                newList = self.parseGroup(unit.equiv)
                for newUnit in newList:
                    newUnit.exp *= unit.exp
                tmpList.extend(newList)
                self.factor *= unit.factor**unit.exp
        self.reducedList.sort()
        tmpList = self.reducedList[:]
        self.reducedList = []
        for unit in tmpList:
            if self.reducedList and unit == self.reducedList[-1]:
                self.reducedList[-1].exp += unit.exp
            else:
                self.reducedList.append(unit)
        self.reducedList = [unit for unit in self.reducedList if \
                            unit.name != 'unit' and unit.exp != 0]

    def categoryMatch(self, otherGroup):
        "Return 1 if unit types are equivalent"
        if not self.checkLinear() or not otherGroup.checkLinear():
            return 0
        return self.reducedList == otherGroup.reducedList and \
               [unit.exp for unit in self.reducedList] \
               == [unit.exp for unit in otherGroup.reducedList]

    def checkLinear(self):
        "Return 1 if linear or acceptable non-linear"
        if not self.linear:
            if len(self.unitList) > 1 or self.unitList[0].exp != 1:
                return 0
        return 1

    def compatStr(self):
        "Return string with reduced unit or linear compatability problem"
        if self.checkLinear():
            return self.unitString(self.reducedList)
        return 'Cannot combine non-linear units'

    def convert(self, num, toGroup):

        "Return num of this group converted to toGroup"
        if self.linear:
            num *= self.factor
        else:
            num = self.nonLinearCalc(num, 1) * self.factor


        n2 = -1
        if toGroup.linear:
            n2 =  num / toGroup.factor
        else:
            n2 = toGroup.nonLinearCalc(num / toGroup.factor, 0)
        return n2

    def nonLinearCalc(self, num, isFrom):
        "Return result of non-linear calculation"

        x = num
        try:
            if self.unitList[0].toEqn:      # regular equations
                if isFrom:
                    temp =  float(eval(self.unitList[0].fromEqn))
                    return temp
                temp = float(eval(self.unitList[0].toEqn))
                return temp
            data = list(eval(self.unitList[0].fromEqn))  # extrapolation list
            if isFrom:
                data = [(float(group[0]), float(group[1])) for group in data]
            else:
                data = [(float(group[1]), float(group[0])) for group in data]
            data.sort()
            pos = len(data) - 1
            for i in range(len(data)):
                if num <= data[i][0]:
                    pos = i
                    break
            if pos == 0:
                pos = 1
            y = (num-data[pos-1][0]) / float(data[pos][0]-data[pos-1][0]) \
                   * (data[pos][1]-data[pos-1][1]) + data[pos-1][1]
            return y
        except OverflowError:
            return 1e9999
        except:
            raise UnitDataError('Bad equation for %s' % self.unitList[0].name)

    def convertStr(self, num, toGroup):
        "Return formatted string of converted number"
        return self.formatNumStr(self.convert(num, toGroup))

    def formatNumStr(self, num):
        "Return num string formatted per options"
        decPlcs = self.option.intData('DecimalPlaces', 0, UnitGroup.maxDecPlcs)
        if self.option.boolData('SciNotation'):
            return ('%%0.%dE' % decPlcs) % num
        if self.option.boolData('FixedDecimals'):
            return ('%%0.%df' % decPlcs) % num
        return ('%%0.%dG' % decPlcs) % num


class UnitDataError(Exception):
    pass


class UnitData(dict):
    def __init__(self):
        dict.__init__(self)
        self.sortedKeys = []

    def readData(self):
        "Read all unit data from file"
        types = []
        typeUnits = {}
        try:
            f = StringIO.StringIO(unitData)
            lines = f.readlines()
            f.close()
        except IOError:
            raise UnitDataError('Can not read "units.dat" file')
        for i in range(len(lines)):     # join continuation lines
            delta = 1
            while lines[i].rstrip().endswith('\\'):
                lines[i] = ''.join([lines[i].rstrip()[:-1], lines[i+delta]])
                lines[i+delta] = ''
                delta += 1
        units = [Unit(line) for line in lines if \
                 line.split('#', 1)[0].strip()]   # remove comment lines
        typeText = ''
        for unit in units:               # find & set headings
            if unit.name.startswith('['):
                typeText = unit.name[1:-1].strip()
                types.append(typeText)
                typeUnits[typeText] = []
            unit.typeName = typeText
        units = [unit for unit in units if unit.equiv]  # keep valid units
        for unit in units:
            self[unit.name.replace(' ', '')] = unit
            typeUnits[unit.typeName].append(unit.name)
        self.sortedKeys = self.keys()
        self.sortedKeys.sort()

        if len(self.sortedKeys) < len(units):
            raise UnitDataError('Duplicate unit names found')

        return (types, typeUnits)

    def findPartialMatch(self, text):
        "Return first partially matching unit or None"
        text = text.replace(' ', '')
        if not text:
            return None
        for name in self.sortedKeys:
            if name.startswith(text):
                return self[name]
        return None

    def findSortPos(self, text):
        "Return unit whose abbrev comes immediately after text"
        text = text.replace(' ', '')
        for name in self.sortedKeys:
            if text <= name:
                return self[name]
        return self[self.sortedKeys[-1]]


class Unit:
    "Reads and stores a single unit conversion"
    partialExp = 1000
    def __init__(self, dataStr):
        dataList = dataStr.split('#')
        unitList = dataList.pop(0).split('=', 1)
        self.name = unitList.pop(0).strip()
        self.equiv = ''
        self.factor = 1.0
        self.fromEqn = ''   # used only for non-linear units
        self.toEqn = ''     # used only for non-linear units
        if unitList:
            self.equiv = unitList[0].strip()
            if self.equiv[0] == '[':   # used only for non-linear units
                try:
                    self.equiv, self.fromEqn = re.match('\[(.*?)\](.*)', \
                                                        self.equiv).groups()
                    if ';' in self.fromEqn:
                        self.fromEqn, self.toEqn = self.fromEqn.split(';', 1)
                        self.toEqn = self.toEqn.strip()
                    self.fromEqn = self.fromEqn.strip()
                except AttributeError:
                    raise UnitDataError('Bad equation for "%s"' % self.name)
            else:                # split factor and equiv unit for linear
                parts = self.equiv.split(None, 1)
                if len(parts) > 1 and re.search('[^\d\.eE\+\-\*/]', parts[0]) \
                   == None:       # only allowed digits and operators
                    try:
                        self.factor = float(eval(parts[0]))
                        self.equiv = parts[1]
                    except:
                        pass
        self.comments = [comm.strip() for comm in dataList]
        self.comments.extend([''] * (2 - len(self.comments)))
        self.exp = 1
        self.viewLink = [None, None]
        self.typeName = ''

    def description(self):
        "Return name and 1st comment (usu. full name) if applicable"
        if self.comments[0]:
            return '%s  (%s)' % (self.name, self.comments[0])
        return self.name

    def unitValid(self):
        "Return 1 if unit and exponent are valid"
        if self.equiv and -Unit.partialExp < self.exp < Unit.partialExp:
            return 1
        return 0

    def unitText(self, absExp=0):
        "Return text for unit name with exponent or absolute value of exp"
        exp = self.exp
        if absExp:
            exp = abs(self.exp)
        if exp == 1:
            return self.name
        if -Unit.partialExp < exp < Unit.partialExp:
            return '%s^%d' % (self.name, exp)
        if exp > 1:
            return '%s^' % self.name
        else:
            return '%s^-' % self.name

    def __cmp__(self, other):
        return cmp(self.name, other.name)

    def __lt__(self, other):
        return self.name < other.name

    def __eq__(self, other):
        return self.name == other.name

############################################################################
# Wrapper functionality
#
############################################################################


# Parse the data file, and set everything up for conversion
data = UnitData()
(types, unitsByType) = data.readData()

# At the moment, we're not handling options
option = None

# set up the objects for unit conversion
fromUnit = UnitGroup(data, option)
toUnit = UnitGroup(data, option)

def convert(num, unit1, unit2):
    """ Convert from one unit to another

    num is the factor for the first unit. Raises UnitDataError for
    various errors.
    """
    fromUnit.update(unit1)
    toUnit.update(unit2)

    fromUnit.reduceGroup()
    toUnit.reduceGroup()

    # Match up unit categories
    if not fromUnit.categoryMatch(toUnit):
        raise UnitDataError('unit categories did not match')

    return fromUnit.convert(num, toUnit)



def units(type):
    """ Return comma separated string list of units of given type, or
        a list of types if the argument is not valid.
    """
    if type in types:
        return '%s units: %s' % (type, ', '.join(unitsByType[type]))
    else:
        return 'valid types: ' + ', '.join(types)



########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2002-2004, Jeremiah Fincher
# Copyright (c) 2008-2009, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from __future__ import division

import re
import math
import cmath
import types
import string

import supybot.utils as utils
from supybot.commands import *
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Math')

try:
    from local import convertcore
except ImportError:
    from .local import convertcore

baseArg = ('int', 'base', lambda i: i <= 36)

class Math(callbacks.Plugin):
    @internationalizeDocstring
    def base(self, irc, msg, args, frm, to, number):
        """<fromBase> [<toBase>] <number>

        Converts <number> from base <fromBase> to base <toBase>.
        If <toBase> is left out, it converts to decimal.
        """
        if not number:
            number = str(to)
            to = 10
        try:
            irc.reply(self._convertBaseToBase(number, to, frm))
        except ValueError:
            irc.error(_('Invalid <number> for base %s: %s') % (frm, number))
    base = wrap(base, [('int', 'base', lambda i: 2 <= i <= 36),
                       optional(('int', 'base', lambda i: 2 <= i <= 36), 10),
                       additional('something')])

    def _convertDecimalToBase(self, number, base):
        """Convert a decimal number to another base; returns a string."""
        if number == 0:
            return '0'
        elif number < 0:
            negative = True
            number = -number
        else:
            negative = False
        digits = []
        while number != 0:
            digit = number % base
            if digit >= 10:
                digit = string.ascii_uppercase[digit - 10]
            else:
                digit = str(digit)
            digits.append(digit)
            number = number // base
        digits.reverse()
        return '-'*negative + ''.join(digits)

    def _convertBaseToBase(self, number, toBase, fromBase):
        """Convert a number from any base, 2 through 36, to any other
        base, 2 through 36. Returns a string."""
        number = long(str(number), fromBase)
        if toBase == 10:
            return str(number)
        return self._convertDecimalToBase(number, toBase)

    _mathEnv = {'__builtins__': types.ModuleType('__builtins__'), 'i': 1j}
    _mathEnv.update(math.__dict__)
    _mathEnv.update(cmath.__dict__)
    def _sqrt(x):
        if isinstance(x, complex) or x < 0:
            return cmath.sqrt(x)
        else:
            return math.sqrt(x)
    def _cbrt(x):
        return math.pow(x, 1.0/3)
    _mathEnv['sqrt'] = _sqrt
    _mathEnv['cbrt'] = _cbrt
    _mathEnv['abs'] = abs
    _mathEnv['max'] = max
    _mathEnv['min'] = min
    _mathSafeEnv = dict([(x,y) for x,y in _mathEnv.items()
        if x not in ['factorial']])
    _mathRe = re.compile(r'((?:(?<![A-Fa-f\d)])-)?'
                         r'(?:0x[A-Fa-f\d]+|'
                         r'0[0-7]+|'
                         r'\d+\.\d+|'
                         r'\.\d+|'
                         r'\d+\.|'
                         r'\d+))')
    def _floatToString(self, x):
        if -1e-10 < x < 1e-10:
            return '0'
        elif -1e-10 < int(x) - x < 1e-10:
            return str(int(x))
        else:
            return str(x)

    def _complexToString(self, x):
        realS = self._floatToString(x.real)
        imagS = self._floatToString(x.imag)
        if imagS == '0':
            return realS
        elif imagS == '1':
            imagS = '+i'
        elif imagS == '-1':
            imagS = '-i'
        elif x.imag < 0:
            imagS = '%si' % imagS
        else:
            imagS = '+%si' % imagS
        if realS == '0' and imagS == '0':
            return '0'
        elif realS == '0':
            return imagS.lstrip('+')
        elif imagS == '0':
            return realS
        else:
            return '%s%s' % (realS, imagS)

    _calc_match_forbidden_chars = re.compile('[_[\]]')
    _calc_remover = utils.str.MultipleRemover('_[] \t')
    ###
    # So this is how the 'calc' command works:
    # First, we make a nice little safe environment for evaluation; basically,
    # the names in the 'math' and 'cmath' modules.  Then, we remove the ability
    # of a random user to get ints evaluated: this means we have to turn all
    # int literals (even octal numbers and hexadecimal numbers) into floats.
    # Then we delete all square brackets, underscores, and whitespace, so no
    # one can do list comprehensions or call __...__ functions.
    ###
    @internationalizeDocstring
    def calc(self, irc, msg, args, text):
        """<math expression>

        Returns the value of the evaluated <math expression>.  The syntax is
        Python syntax; the type of arithmetic is floating point.  Floating
        point arithmetic is used in order to prevent a user from being able to
        crash to the bot with something like '10**10**10**10'.  One consequence
        is that large values such as '10**24' might not be exact.
        """
        try:
            text = str(text)
        except UnicodeEncodeError:
            irc.error(_("There's no reason you should have fancy non-ASCII "
                            "characters in your mathematical expression. "
                            "Please remove them."))
            return
        if self._calc_match_forbidden_chars.match(text):
            irc.error(_('There\'s really no reason why you should have '
                           'underscores or brackets in your mathematical '
                           'expression.  Please remove them.'))
            return
        text = self._calc_remover(text)
        if 'lambda' in text:
            irc.error(_('You can\'t use lambda in this command.'))
            return
        text = text.lower()
        def handleMatch(m):
            s = m.group(1)
            if s.startswith('0x'):
                i = int(s, 16)
            elif s.startswith('0') and '.' not in s:
                try:
                    i = int(s, 8)
                except ValueError:
                    i = int(s)
            else:
                i = float(s)
            x = complex(i)
            if x.imag == 0:
                x = x.real
                # Need to use string-formatting here instead of str() because
                # use of str() on large numbers loses information:
                # str(float(33333333333333)) => '3.33333333333e+13'
                # float('3.33333333333e+13') => 33333333333300.0
                return '%.16f' % x
            return str(x)
        text = self._mathRe.sub(handleMatch, text)
        try:
            self.log.info('evaluating %q from %s', text, msg.prefix)
            x = complex(eval(text, self._mathSafeEnv, self._mathSafeEnv))
            irc.reply(self._complexToString(x))
        except OverflowError:
            maxFloat = math.ldexp(0.9999999999999999, 1024)
            irc.error(_('The answer exceeded %s or so.') % maxFloat)
        except TypeError:
            irc.error(_('Something in there wasn\'t a valid number.'))
        except NameError as e:
            irc.error(_('%s is not a defined function.') % str(e).split()[1])
        except Exception as e:
            irc.error(str(e))
    calc = wrap(calc, ['text'])

    @internationalizeDocstring
    def icalc(self, irc, msg, args, text):
        """<math expression>

        This is the same as the calc command except that it allows integer
        math, and can thus cause the bot to suck up CPU.  Hence it requires
        the 'trusted' capability to use.
        """
        if self._calc_match_forbidden_chars.match(text):
            irc.error(_('There\'s really no reason why you should have '
                           'underscores or brackets in your mathematical '
                           'expression.  Please remove them.'))
            return
        # This removes spaces, too, but we'll leave the removal of _[] for
        # safety's sake.
        text = self._calc_remover(text)
        if 'lambda' in text:
            irc.error(_('You can\'t use lambda in this command.'))
            return
        text = text.replace('lambda', '')
        try:
            self.log.info('evaluating %q from %s', text, msg.prefix)
            irc.reply(str(eval(text, self._mathEnv, self._mathEnv)))
        except OverflowError:
            maxFloat = math.ldexp(0.9999999999999999, 1024)
            irc.error(_('The answer exceeded %s or so.') % maxFloat)
        except TypeError:
            irc.error(_('Something in there wasn\'t a valid number.'))
        except NameError as e:
            irc.error(_('%s is not a defined function.') % str(e).split()[1])
        except Exception as e:
            irc.error(utils.exnToString(e))
    icalc = wrap(icalc, [('checkCapability', 'trusted'), 'text'])

    _rpnEnv = {
        'dup': lambda s: s.extend([s.pop()]*2),
        'swap': lambda s: s.extend([s.pop(), s.pop()])
        }
    def rpn(self, irc, msg, args):
        """<rpn math expression>

        Returns the value of an RPN expression.
        """
        stack = []
        for arg in args:
            try:
                x = complex(arg)
                if x == abs(x):
                    x = abs(x)
                stack.append(x)
            except ValueError: # Not a float.
                if arg in self._mathEnv:
                    f = self._mathEnv[arg]
                    if callable(f):
                        called = False
                        arguments = []
                        while not called and stack:
                            arguments.append(stack.pop())
                            try:
                                stack.append(f(*arguments))
                                called = True
                            except TypeError:
                                pass
                        if not called:
                            irc.error(_('Not enough arguments for %s') % arg)
                            return
                    else:
                        stack.append(f)
                elif arg in self._rpnEnv:
                    self._rpnEnv[arg](stack)
                else:
                    arg2 = stack.pop()
                    arg1 = stack.pop()
                    s = '%s%s%s' % (arg1, arg, arg2)
                    try:
                        stack.append(eval(s, self._mathEnv, self._mathEnv))
                    except SyntaxError:
                        irc.error(format(_('%q is not a defined function.'),
                                         arg))
                        return
        if len(stack) == 1:
            irc.reply(str(self._complexToString(complex(stack[0]))))
        else:
            s = ', '.join(map(self._complexToString, list(map(complex, stack))))
            irc.reply(_('Stack: [%s]') % s)

    @internationalizeDocstring
    def convert(self, irc, msg, args, number, unit1, unit2):
        """[<number>] <unit> to <other unit>

        Converts from <unit> to <other unit>. If number isn't given, it
        defaults to 1. For unit information, see 'units' command.
        """
        try:
            digits = len(str(number).split('.')[1])
        except IndexError:
            digits = 0
        try:
            newNum = convertcore.convert(number, unit1, unit2)
            if isinstance(newNum, float):
                zeros = 0
                for char in str(newNum).split('.')[1]:
                    if char != '0':
                        break
                    zeros += 1
                # Let's add one signifiant digit. Physicists would not like
                # that, but common people usually do not give extra zeros...
                # (for example, with '32 C to F', an extra digit would be
                # expected).
                newNum = round(newNum, digits + 1 + zeros)
            newNum = self._floatToString(newNum)
            irc.reply(str(newNum))
        except convertcore.UnitDataError as ude:
            irc.error(str(ude))
    convert = wrap(convert, [optional('float', 1.0),'something','to','text'])

    @internationalizeDocstring
    def units(self, irc, msg, args, type):
        """ [<type>]

        With no arguments, returns a list of measurement types, which can be
        passed as arguments. When called with a type as an argument, returns
        the units of that type.
        """

        irc.reply(convertcore.units(type))
    units = wrap(units, [additional('text')])

Class = Math

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2002-2004, Jeremiah Fincher
# Copyright (c) 2008, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

class MathTestCase(PluginTestCase):
    plugins = ('Math',)
    def testBase(self):
        self.assertNotRegexp('base 56 asdflkj', 'ValueError')
        self.assertResponse('base 16 2 F', '1111')
        self.assertResponse('base 2 16 1111', 'F')
        self.assertResponse('base 20 BBBB', '92631')
        self.assertResponse('base 10 20 92631', 'BBBB')
        self.assertResponse('base 2 36 10', '2')
        self.assertResponse('base 36 2 10', '100100')
        self.assertResponse('base 2 1010101', '85')
        self.assertResponse('base 2 2 11', '11')

        self.assertResponse('base 12 0', '0')
        self.assertResponse('base 36 2 0', '0')


        self.assertNotError("base 36 " +\
            "ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ"\
            "ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ"\
            "ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ"\
            "ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ"\
            "ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ"\
            "ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ"\
            "ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ")

        self.assertResponse("base 10 36 [base 36 " +\
            "zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz"\
            "zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz"\
            "zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz"\
            "zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz"\
            "zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz"\
            "zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz"\
            "zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz]",

            "ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ"\
            "ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ"\
            "ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ"\
            "ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ"\
            "ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ"\
            "ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ"\
            "ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ")

        self.assertResponse('base 2 10 [base 10 2 12]', '12')
        self.assertResponse('base 16 2 [base 2 16 110101]', '110101')
        self.assertResponse('base 10 8 [base 8 76532]', '76532')
        self.assertResponse('base 10 36 [base 36 csalnwea]', 'CSALNWEA')
        self.assertResponse('base 5 4 [base 4 5 212231]', '212231')

        self.assertError('base 37 1')
        self.assertError('base 1 1')
        self.assertError('base 12 1 1')
        self.assertError('base 1 12 1')
        self.assertError('base 1.0 12 1')
        self.assertError('base A 1')

        self.assertError('base 4 4')
        self.assertError('base 10 12 A')

        print()
        print("If we have not fixed a bug with Math.base, the following ")
        print("tests will hang the test-suite.")
        self.assertRegexp('base 2 10 [base 10 2 -12]', '-12')
        self.assertRegexp('base 16 2 [base 2 16 -110101]', '-110101')

    def testCalc(self):
        self.assertResponse('calc 5*0.06', str(5*0.06))
        self.assertResponse('calc 2.0-7.0', str(2-7))
        self.assertResponse('calc e**(i*pi)+1', '0')
        if sys.version_info[0] >= 3:
            # Python 2 has bad handling of exponentiation of negative numbers
            self.assertResponse('calc (-1)**.5', 'i')
            self.assertRegexp('calc (-5)**.5', '2.236067977[0-9]+i')
            self.assertRegexp('calc -((-5)**.5)', '-2.236067977[0-9]+i')
        self.assertNotRegexp('calc [9, 5] + [9, 10]', 'TypeError')
        self.assertError('calc [9, 5] + [9, 10]')
        self.assertNotError('calc degrees(2)')
        self.assertNotError('calc (2 * 3) - 2*(3*4)')
        self.assertNotError('calc (3) - 2*(3*4)')
        self.assertNotError('calc (1600 * 1200) - 2*(1024*1280)')
        self.assertNotError('calc 3-2*4')
        self.assertNotError('calc (1600 * 1200)-2*(1024*1280)')
        self.assertError('calc factorial(99)')

    def testCalcNoNameError(self):
        self.assertNotRegexp('calc foobar(x)', 'NameError')

    def testCalcImaginary(self):
        self.assertResponse('calc 3 + sqrt(-1)', '3+i')

    def testCalcFloorWorksWithSqrt(self):
        self.assertNotError('calc floor(sqrt(5))')

    def testCaseInsensitive(self):
        self.assertNotError('calc PI**PI')

    def testCalcMaxMin(self):
        self.assertResponse('calc max(1,2)', '2')
        self.assertResponse('calc min(1,2)', '1')

    def testCalcStrFloat(self):
        self.assertResponse('calc 3+33333333333333', '33333333333336')

    def testICalc(self):
        self.assertResponse('icalc 1^1', '0')
        self.assertResponse('icalc 10**24', '1' + '0'*24)
        self.assertRegexp('icalc 49/6', '8.16')
        self.assertNotError('icalc factorial(99)')

    def testRpn(self):
        self.assertResponse('rpn 5 2 +', '7')
        self.assertResponse('rpn 1 2 3 +', 'Stack: [1, 5]')
        self.assertResponse('rpn 1 dup', 'Stack: [1, 1]')
        self.assertResponse('rpn 2 3 4 + -', str(2-7))
        self.assertNotError('rpn 2 degrees')

    def testRpnSwap(self):
        self.assertResponse('rpn 1 2 swap', 'Stack: [2, 1]')

    def testRpmNoSyntaxError(self):
        self.assertNotRegexp('rpn 2 3 foobar', 'SyntaxError')

    def testConvert(self):
        self.assertResponse('convert 1 m to cm', '100')
        self.assertResponse('convert m to cm', '100')
        self.assertResponse('convert 3 metres to km', '0.003')
        self.assertResponse('convert 32 F to C', '0')
        self.assertResponse('convert 32 C to F', '89.6')
        self.assertResponse('convert [calc 2*pi] rad to degree', '360')
        self.assertResponse('convert amu to atomic mass unit',
                            '1')
        self.assertResponse('convert [calc 2*pi] rad to circle', '1')



        self.assertError('convert 1 meatball to bananas')
        self.assertError('convert 1 gram to meatballs')
        self.assertError('convert 1 mol to grams')
        self.assertError('convert 1 m to kpa')

    def testConvertSingularPlural(self):
        self.assertResponse('convert [calc 2*pi] rads to degrees', '360')
        self.assertResponse('convert 1 carat to grams', '0.2')
        self.assertResponse('convert 10 lbs to oz', '160')
        self.assertResponse('convert mA to amps', '0.001')

    def testConvertCaseSensitivity(self):
        self.assertError('convert MA to amps')
        self.assertError('convert M to amps')
        self.assertError('convert Radians to rev')

    def testUnits(self):
        self.assertNotError('units')
        self.assertNotError('units mass')
        self.assertNotError('units flux density')

    def testAbs(self):
        self.assertResponse('calc abs(2)', '2')
        self.assertResponse('calc abs(-2)', '2')
        self.assertResponse('calc abs(2.0)', '2')
        self.assertResponse('calc abs(-2.0)', '2')


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:


########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2010, Daniel Folkinshteyn
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

###

import supybot.conf as conf
import supybot.registry as registry

try:
    from supybot.i18n import PluginInternationalization
    from supybot.i18n import internationalizeDocstring
    _ = PluginInternationalization('MessageParser')
except:
    # This are useless functions that's allow to run the plugin on a bot
    # without the i18n plugin
    _ = lambda x:x
    internationalizeDocstring = lambda x:x

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('MessageParser', True)

MessageParser = conf.registerPlugin('MessageParser')
# This is where your configuration variables (if any) should go.  For example:
# conf.registerGlobalValue(MessageParser, 'someConfigVariableName',
#     registry.Boolean(False, """Help for someConfigVariableName."""))
conf.registerChannelValue(MessageParser, 'enable',
    registry.Boolean(True, _("""Determines whether the
    message parser is enabled.  If enabled, will trigger on regexps
    added to the regexp db.""")))
conf.registerChannelValue(MessageParser, 'enableForNotices',
    registry.Boolean(False, _("""Determines whether the message parser
    is enabled for NOTICE messages too.""")))
conf.registerChannelValue(MessageParser, 'keepRankInfo',
    registry.Boolean(True, _("""Determines whether we keep updating the usage
    count for each regexp, for popularity ranking.""")))
conf.registerChannelValue(MessageParser, 'rankListLength',
    registry.Integer(20, _("""Determines the number of regexps returned
    by the triggerrank command.""")))
conf.registerChannelValue(MessageParser, 'requireVacuumCapability',
    registry.String('admin', _("""Determines the capability required (if any) to
    vacuum the database.""")))
conf.registerChannelValue(MessageParser, 'requireManageCapability',
    registry.String('admin; channel,op', _("""Determines the
    capabilities required (if any) to manage the regexp database,
    including add, remove, lock, unlock. Use 'channel,capab' for
    channel-level capabilities.
    Note that absence of an explicit anticapability means user has
    capability.""")))
conf.registerChannelValue(MessageParser, 'listSeparator',
    registry.String(', ', _("""Determines the separator used between regexps when
    shown by the list command.""")))
conf.registerChannelValue(MessageParser, 'maxTriggers',
    registry.Integer(0, _("""Determines the maximum number of triggers in
    one message. Set this to 0 to allow an infinite number of triggers.""")))

# vim:set shiftwidth=4 tabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2010, Daniel Folkinshteyn
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

###

import supybot.utils as utils
from supybot.commands import *
import supybot.plugins as plugins
import supybot.ircutils as ircutils
import supybot.callbacks as callbacks

import supybot.conf as conf
import supybot.ircdb as ircdb

import re
import os
import time

try:
    from supybot.i18n import PluginInternationalization
    from supybot.i18n import internationalizeDocstring
    _ = PluginInternationalization('MessageParser')
except:
    # This are useless functions that's allow to run the plugin on a bot
    # without the i18n plugin
    _ = lambda x:x
    internationalizeDocstring = lambda x:x

#try:
    #import sqlite
#except ImportError:
    #raise callbacks.Error, 'You need to have PySQLite installed to use this ' \
                           #'plugin.  Download it at ' \
                           #'<http://code.google.com/p/pysqlite/>'

import sqlite3

# these are needed cuz we are overriding getdb
import threading
import supybot.world as world


import supybot.log as log


class MessageParser(callbacks.Plugin, plugins.ChannelDBHandler):
    """This plugin can set regexp triggers to activate the bot.
    Use 'add' command to add regexp trigger, 'remove' to remove."""
    threaded = True
    def __init__(self, irc):
        callbacks.Plugin.__init__(self, irc)
        plugins.ChannelDBHandler.__init__(self)

    def makeDb(self, filename):
        """Create the database and connect to it."""
        if os.path.exists(filename):
            db = sqlite3.connect(filename)
            db.text_factory = str
            return db
        db = sqlite3.connect(filename)
        db.text_factory = str
        cursor = db.cursor()
        cursor.execute("""CREATE TABLE triggers (
                          id INTEGER PRIMARY KEY,
                          regexp TEXT UNIQUE ON CONFLICT REPLACE,
                          added_by TEXT,
                          added_at TIMESTAMP,
                          usage_count INTEGER,
                          action TEXT,
                          locked BOOLEAN
                          )""")
        db.commit()
        return db

    # override this because sqlite3 doesn't have autocommit
    # use isolation_level instead.
    def getDb(self, channel):
        """Use this to get a database for a specific channel."""
        currentThread = threading.currentThread()
        if channel not in self.dbCache and currentThread == world.mainThread:
            self.dbCache[channel] = self.makeDb(self.makeFilename(channel))
        if currentThread != world.mainThread:
            db = self.makeDb(self.makeFilename(channel))
        else:
            db = self.dbCache[channel]
        db.isolation_level = None
        return db

    def _updateRank(self, channel, regexp):
        subfolder = None if channel == 'global' else channel
        if self.registryValue('keepRankInfo', subfolder):
            db = self.getDb(channel)
            cursor = db.cursor()
            cursor.execute("""SELECT usage_count
                      FROM triggers
                      WHERE regexp=?""", (regexp,))
            old_count = cursor.fetchall()[0][0]
            cursor.execute("UPDATE triggers SET usage_count=? WHERE regexp=?", (old_count + 1, regexp,))
            db.commit()

    def _runCommandFunction(self, irc, msg, command):
        """Run a command from message, as if command was sent over IRC."""
        tokens = callbacks.tokenize(command)
        try:
            self.Proxy(irc.irc, msg, tokens)
        except Exception as e:
            log.exception('Uncaught exception in function called by MessageParser:')

    def _checkManageCapabilities(self, irc, msg, channel):
        """Check if the user has any of the required capabilities to manage
        the regexp database."""
        capabilities = self.registryValue('requireManageCapability')
        if capabilities:
            for capability in re.split(r'\s*;\s*', capabilities):
                if capability.startswith('channel,'):
                    capability = capability[8:]
                    if channel != 'global':
                        capability = ircdb.makeChannelCapability(channel, capability)
                if capability and ircdb.checkCapability(msg.prefix, capability):
                    #print "has capability:", capability
                    return True
            return False
        else:
            return True

    def do_privmsg_notice(self, irc, msg):
        channel = msg.args[0]
        if not irc.isChannel(channel):
            return
        if self.registryValue('enable', channel):
            actions = []
            results = []
            for channel in set(map(plugins.getChannel, (channel, 'global'))):
                db = self.getDb(channel)
                cursor = db.cursor()
                cursor.execute("SELECT regexp, action FROM triggers")
                # Fetch results and prepend channel name or 'global'. This
                # prevents duplicating the following lines.
                results.extend([(channel,)+x for x in cursor.fetchall()])
            if len(results) == 0:
                return
            max_triggers = self.registryValue('maxTriggers', channel)
            for (channel, regexp, action) in results:
                for match in re.finditer(regexp, msg.args[1]):
                    if match is not None:
                        thisaction = action
                        self._updateRank(channel, regexp)
                        for (i, j) in enumerate(match.groups()):
                            if match.group(i+1):
                                thisaction = re.sub(r'\$' + str(i+1), match.group(i+1), thisaction)
                        actions.append(thisaction)
                        if max_triggers != 0 and max_triggers == len(actions):
                            break
                if max_triggers != 0 and max_triggers == len(actions):
                    break


            for action in actions:
                self._runCommandFunction(irc, msg, action)

    def doPrivmsg(self, irc, msg):
        if not callbacks.addressed(irc.nick, msg): #message is not direct command
            self.do_privmsg_notice(irc, msg)

    def doNotice(self, irc, msg):
        if self.registryValue('enableForNotices', msg.args[0]):
            self.do_privmsg_notice(irc, msg)

    @internationalizeDocstring
    def add(self, irc, msg, args, channel, regexp, action):
        """[<channel>|global] <regexp> <action>

        Associates <regexp> with <action>.  <channel> is only
        necessary if the message isn't sent on the channel
        itself.  Action is echoed upon regexp match, with variables $1, $2,
        etc. being interpolated from the regexp match groups."""
        if not self._checkManageCapabilities(irc, msg, channel):
            capabilities = self.registryValue('requireManageCapability')
            irc.errorNoCapability(capabilities, Raise=True)
        db = self.getDb(channel)
        cursor = db.cursor()
        cursor.execute("SELECT id, usage_count, locked FROM triggers WHERE regexp=?", (regexp,))
        results = cursor.fetchall()
        if len(results) != 0:
            (id, usage_count, locked) = list(map(int, results[0]))
        else:
            locked = 0
            usage_count = 0
        if not locked:
            try:
                re.compile(regexp)
            except Exception as e:
                irc.error(_('Invalid python regexp: %s') % (e,))
                return
            if ircdb.users.hasUser(msg.prefix):
                name = ircdb.users.getUser(msg.prefix).name
            else:
                name = msg.nick
            cursor.execute("""INSERT INTO triggers VALUES
                              (NULL, ?, ?, ?, ?, ?, ?)""",
                            (regexp, name, int(time.time()), usage_count, action, locked,))
            db.commit()
            irc.replySuccess()
        else:
            irc.error(_('That trigger is locked.'))
            return
    add = wrap(add, ['channelOrGlobal', 'something', 'something'])

    @internationalizeDocstring
    def remove(self, irc, msg, args, channel, optlist, regexp):
        """[<channel>|global] [--id] <regexp>]

        Removes the trigger for <regexp> from the triggers database.
        <channel> is only necessary if
        the message isn't sent in the channel itself.
        If option --id specified, will retrieve by regexp id, not content.
        """
        if not self._checkManageCapabilities(irc, msg, channel):
            capabilities = self.registryValue('requireManageCapability')
            irc.errorNoCapability(capabilities, Raise=True)
        db = self.getDb(channel)
        cursor = db.cursor()
        target = 'regexp'
        for (option, arg) in optlist:
            if option == 'id':
                target = 'id'
        sql = "SELECT id, locked FROM triggers WHERE %s=?" % (target,)
        cursor.execute(sql, (regexp,))
        results = cursor.fetchall()
        if len(results) != 0:
            (id, locked) = list(map(int, results[0]))
        else:
            irc.error(_('There is no such regexp trigger.'))
            return

        if locked:
            irc.error(_('This regexp trigger is locked.'))
            return

        cursor.execute("""DELETE FROM triggers WHERE id=?""", (id,))
        db.commit()
        irc.replySuccess()
    remove = wrap(remove, ['channelOrGlobal',
                            getopts({'id': '',}),
                            'something'])

    @internationalizeDocstring
    def lock(self, irc, msg, args, channel, regexp):
        """[<channel>|global] <regexp>

        Locks the <regexp> so that it cannot be
        removed or overwritten to.  <channel> is only necessary if the message isn't
        sent in the channel itself.
        """
        if not self._checkManageCapabilities(irc, msg, channel):
            capabilities = self.registryValue('requireManageCapability')
            irc.errorNoCapability(capabilities, Raise=True)
        db = self.getDb(channel)
        cursor = db.cursor()
        cursor.execute("SELECT id FROM triggers WHERE regexp=?", (regexp,))
        results = cursor.fetchall()
        if len(results) == 0:
            irc.error(_('There is no such regexp trigger.'))
            return
        cursor.execute("UPDATE triggers SET locked=1 WHERE regexp=?", (regexp,))
        db.commit()
        irc.replySuccess()
    lock = wrap(lock, ['channelOrGlobal', 'text'])

    @internationalizeDocstring
    def unlock(self, irc, msg, args, channel, regexp):
        """[<channel>|global] <regexp>

        Unlocks the entry associated with <regexp> so that it can be
        removed or overwritten.  <channel> is only necessary if the message isn't
        sent in the channel itself.
        """
        if not self._checkManageCapabilities(irc, msg, channel):
            capabilities = self.registryValue('requireManageCapability')
            irc.errorNoCapability(capabilities, Raise=True)
        db = self.getDb(channel)
        cursor = db.cursor()
        cursor.execute("SELECT id FROM triggers WHERE regexp=?", (regexp,))
        results = cursor.fetchall()
        if len(results) == 0:
            irc.error(_('There is no such regexp trigger.'))
            return
        cursor.execute("UPDATE triggers SET locked=0 WHERE regexp=?", (regexp,))
        db.commit()
        irc.replySuccess()
    unlock = wrap(unlock, ['channelOrGlobal', 'text'])

    @internationalizeDocstring
    def show(self, irc, msg, args, channel, optlist, regexp):
        """[<channel>|global] [--id] <regexp>

        Looks up the value of <regexp> in the triggers database.
        <channel> is only necessary if the message isn't sent in the channel
        itself.
        If option --id specified, will retrieve by regexp id, not content.
        """
        db = self.getDb(channel)
        cursor = db.cursor()
        target = 'regexp'
        for (option, arg) in optlist:
            if option == 'id':
                target = 'id'
        sql = "SELECT regexp, action FROM triggers WHERE %s=?" % (target,)
        cursor.execute(sql, (regexp,))
        results = cursor.fetchall()
        if len(results) != 0:
            (regexp, action) = results[0]
        else:
            irc.error(_('There is no such regexp trigger.'))
            return

        irc.reply("The action for regexp trigger \"%s\" is \"%s\"" % (regexp, action))
    show = wrap(show, ['channelOrGlobal',
                        getopts({'id': '',}),
                        'something'])

    @internationalizeDocstring
    def info(self, irc, msg, args, channel, optlist, regexp):
        """[<channel>|global] [--id] <regexp>

        Display information about <regexp> in the triggers database.
        <channel> is only necessary if the message isn't sent in the channel
        itself.
        If option --id specified, will retrieve by regexp id, not content.
        """
        db = self.getDb(channel)
        cursor = db.cursor()
        target = 'regexp'
        for (option, arg) in optlist:
            if option == 'id':
                target = 'id'
        sql = "SELECT * FROM triggers WHERE %s=?" % (target,)
        cursor.execute(sql, (regexp,))
        results = cursor.fetchall()
        if len(results) != 0:
            (id, regexp, added_by, added_at, usage_count,
                    action, locked) = results[0]
        else:
            irc.error(_('There is no such regexp trigger.'))
            return

        irc.reply(_("The regexp id is %d, regexp is \"%s\", and action is"
                    " \"%s\". It was added by user %s on %s, has been "
                    "triggered %d times, and is %s.") % (id,
                    regexp,
                    action,
                    added_by,
                    time.strftime(conf.supybot.reply.format.time(),
                                     time.localtime(int(added_at))),
                    usage_count,
                    locked and _("locked") or _("not locked"),))
    info = wrap(info, ['channelOrGlobal',
                        getopts({'id': '',}),
                        'something'])

    @internationalizeDocstring
    def list(self, irc, msg, args, channel):
        """[<channel>|global]

        Lists regexps present in the triggers database.
        <channel> is only necessary if the message isn't sent in the channel
        itself. Regexp ID listed in parentheses.
        """
        db = self.getDb(channel)
        cursor = db.cursor()
        cursor.execute("SELECT regexp, id FROM triggers ORDER BY id")
        results = cursor.fetchall()
        if len(results) != 0:
            regexps = results
        else:
            irc.reply(_('There are no regexp triggers in the database.'))
            return

        s = [ "\"%s\" (%d)" % (regexp[0], regexp[1]) for regexp in regexps ]
        separator = self.registryValue('listSeparator', channel)
        irc.reply(separator.join(s))
    list = wrap(list, ['channelOrGlobal'])

    @internationalizeDocstring
    def rank(self, irc, msg, args, channel):
        """[<channel>|global]

        Returns a list of top-ranked regexps, sorted by usage count
        (rank). The number of regexps returned is set by the
        rankListLength registry value. <channel> is only necessary if the
        message isn't sent in the channel itself.
        """
        numregexps = self.registryValue('rankListLength', channel)
        db = self.getDb(channel)
        cursor = db.cursor()
        cursor.execute("""SELECT regexp, usage_count
                          FROM triggers
                          ORDER BY usage_count DESC
                          LIMIT ?""", (numregexps,))
        regexps = cursor.fetchall()
        if len(regexps) == 0:
            irc.reply(_('There are no regexp triggers in the database.'))
            return
        s = [ "#%d \"%s\" (%d)" % (i+1, regexp[0], regexp[1]) for i, regexp in enumerate(regexps) ]
        irc.reply(", ".join(s))
    rank = wrap(rank, ['channelOrGlobal'])

    @internationalizeDocstring
    def vacuum(self, irc, msg, args, channel):
        """[<channel>|global]

        Vacuums the database for <channel>.
        See SQLite vacuum doc here: http://www.sqlite.org/lang_vacuum.html
        <channel> is only necessary if the message isn't sent in
        the channel itself.
        First check if user has the required capability specified in plugin
        config requireVacuumCapability.
        """
        capability = self.registryValue('requireVacuumCapability')
        if capability:
            if not ircdb.checkCapability(msg.prefix, capability):
                irc.errorNoCapability(capability, Raise=True)
        db = self.getDb(channel)
        cursor = db.cursor()
        cursor.execute("""VACUUM""")
        db.commit()
        irc.replySuccess()
    vacuum = wrap(vacuum, ['channelOrGlobal'])
MessageParser = internationalizeDocstring(MessageParser)

Class = MessageParser


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2010, Daniel Folkinshteyn
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

###

from supybot.test import *

import sqlite3


class MessageParserTestCase(ChannelPluginTestCase):
    plugins = ('MessageParser','Utilities','User') 
    #utilities for the 'echo'
    #user for register for testVacuum
    
    def testAdd(self):
        self.assertError('messageparser add') #no args
        self.assertError('messageparser add "stuff"') #no action arg
        self.assertNotError('messageparser add "stuff" "echo i saw some stuff"')
        self.assertRegexp('messageparser show "stuff"', '.*i saw some stuff.*')
        
        self.assertError('messageparser add "[a" "echo stuff"') #invalid regexp
        self.assertError('messageparser add "(a" "echo stuff"') #invalid regexp
        self.assertNotError('messageparser add "stuff" "echo i saw no stuff"') #overwrite existing regexp
        self.assertRegexp('messageparser show "stuff"', '.*i saw no stuff.*')
        
        
        try:
            world.testing = False
            origuser = self.prefix
            self.prefix = 'stuff!stuff@stuff'
            self.assertNotError('register nottester stuff', private=True)
            
            self.assertError('messageparser add "aoeu" "echo vowels are nice"')
            origconf = conf.supybot.plugins.MessageParser.requireManageCapability()
            conf.supybot.plugins.MessageParser.requireManageCapability.setValue('')
            self.assertNotError('messageparser add "aoeu" "echo vowels are nice"')
        finally:
            world.testing = True
            self.prefix = origuser
            conf.supybot.plugins.MessageParser.requireManageCapability.setValue(origconf)
        
    def testShow(self):
        self.assertNotError('messageparser add "stuff" "echo i saw some stuff"')
        self.assertRegexp('messageparser show "nostuff"', 'there is no such regexp trigger')
        self.assertRegexp('messageparser show "stuff"', '.*i saw some stuff.*')
        self.assertRegexp('messageparser show --id 1', '.*i saw some stuff.*')
    
    def testInfo(self):
        self.assertNotError('messageparser add "stuff" "echo i saw some stuff"')
        self.assertRegexp('messageparser info "nostuff"', 'there is no such regexp trigger')
        self.assertRegexp('messageparser info "stuff"', '.*i saw some stuff.*')
        self.assertRegexp('messageparser info --id 1', '.*i saw some stuff.*')
        self.assertRegexp('messageparser info "stuff"', 'has been triggered 0 times')
        self.feedMsg('this message has some stuff in it')
        self.getMsg(' ')
        self.assertRegexp('messageparser info "stuff"', 'has been triggered 1 times')
    
    def testTrigger(self):
        self.assertNotError('messageparser add "stuff" "echo i saw some stuff"')
        self.feedMsg('this message has some stuff in it')
        m = self.getMsg(' ')
        self.failUnless(str(m).startswith('PRIVMSG #test :i saw some stuff'))
    
    def testMaxTriggers(self):
        self.assertNotError('messageparser add "stuff" "echo i saw some stuff"')
        self.assertNotError('messageparser add "sbd" "echo i saw somebody"')
        self.feedMsg('this message issued by sbd has some stuff in it')
        m = self.getMsg(' ')
        self.failUnless(str(m).startswith('PRIVMSG #test :i saw some'))
        m = self.getMsg(' ')
        self.failUnless(str(m).startswith('PRIVMSG #test :i saw some'))

        with conf.supybot.plugins.messageparser.maxtriggers.context(1):
            self.feedMsg('this message issued by sbd has some stuff in it')
            m = self.getMsg(' ')
            self.failUnless(str(m).startswith('PRIVMSG #test :i saw some'))
            m = self.getMsg(' ')
            self.failIf(m)

    def testLock(self):
        self.assertNotError('messageparser add "stuff" "echo i saw some stuff"')
        self.assertNotError('messageparser lock "stuff"')
        self.assertError('messageparser add "stuff" "echo some other stuff"')
        self.assertError('messageparser remove "stuff"')
        self.assertRegexp('messageparser info "stuff"', 'is locked')
    
    def testUnlock(self):
        self.assertNotError('messageparser add "stuff" "echo i saw some stuff"')
        self.assertNotError('messageparser lock "stuff"')
        self.assertError('messageparser remove "stuff"')
        self.assertNotError('messageparser unlock "stuff"')
        self.assertRegexp('messageparser info "stuff"', 'is not locked')
        self.assertNotError('messageparser remove "stuff"')
        
    def testRank(self):
        self.assertRegexp('messageparser rank', 
                'There are no regexp triggers in the database\.')
        self.assertNotError('messageparser add "stuff" "echo i saw some stuff"')
        self.assertRegexp('messageparser rank', '#1 "stuff" \(0\)')
        self.assertNotError('messageparser add "aoeu" "echo vowels are nice!"')
        self.assertRegexp('messageparser rank', '#1 "stuff" \(0\), #2 "aoeu" \(0\)')
        self.feedMsg('instead of asdf, dvorak has aoeu')
        self.getMsg(' ')
        self.assertRegexp('messageparser rank', '#1 "aoeu" \(1\), #2 "stuff" \(0\)')
        
    def testList(self):
        self.assertRegexp('messageparser list', 
                'There are no regexp triggers in the database\.')
        self.assertNotError('messageparser add "stuff" "echo i saw some stuff"')
        self.assertRegexp('messageparser list', '"stuff" \(1\)')
        self.assertNotError('messageparser add "aoeu" "echo vowels are nice!"')
        self.assertRegexp('messageparser list', '"stuff" \(1\), "aoeu" \(2\)')
        
    def testRemove(self):
        self.assertError('messageparser remove "stuff"')
        self.assertNotError('messageparser add "stuff" "echo i saw some stuff"')
        self.assertNotError('messageparser lock "stuff"')
        self.assertError('messageparser remove "stuff"')
        self.assertNotError('messageparser unlock "stuff"')
        self.assertNotError('messageparser remove "stuff"')
        self.assertNotError('messageparser add "stuff" "echo i saw some stuff"')
        self.assertNotError('messageparser remove --id 1')
        
    def testVacuum(self):
        self.assertNotError('messageparser add "stuff" "echo i saw some stuff"')
        self.assertNotError('messageparser remove "stuff"')
        self.assertNotError('messageparser vacuum')
        # disable world.testing since we want new users to not
        # magically be endowed with the admin capability
        try:
            world.testing = False
            original = self.prefix
            self.prefix = 'stuff!stuff@stuff'
            self.assertNotError('register nottester stuff', private=True)
            self.assertError('messageparser vacuum')
            
            orig = conf.supybot.plugins.MessageParser.requireVacuumCapability()
            conf.supybot.plugins.MessageParser.requireVacuumCapability.setValue('')
            self.assertNotError('messageparser vacuum')
        finally:
            world.testing = True
            self.prefix = original
            conf.supybot.plugins.MessageParser.requireVacuumCapability.setValue(orig)
    
    def testKeepRankInfo(self):
        orig = conf.supybot.plugins.MessageParser.keepRankInfo()
        
        try:
            conf.supybot.plugins.MessageParser.keepRankInfo.setValue(False)
            self.assertNotError('messageparser add "stuff" "echo i saw some stuff"')
            self.feedMsg('instead of asdf, dvorak has aoeu')
            self.getMsg(' ')
            self.assertRegexp('messageparser info "stuff"', 'has been triggered 0 times')
        finally:
            conf.supybot.plugins.MessageParser.keepRankInfo.setValue(orig)
        
        self.feedMsg('this message has some stuff in it')
        self.getMsg(' ')
        self.assertRegexp('messageparser info "stuff"', 'has been triggered 1 times')
        
# vim:set shiftwidth=4 tabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2004-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Misc')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Misc', True)

Misc = conf.registerPlugin('Misc')
conf.registerChannelValue(Misc, 'mores',
    registry.PositiveInteger(1, _("""Determines how many messages the bot
    will issue when using the 'more' command.""")))
conf.registerGlobalValue(Misc, 'listPrivatePlugins',
    registry.Boolean(True, _("""Determines whether the bot will list private
    plugins with the list command if given the --private switch.  If this is
    disabled, non-owner users should be unable to see what private plugins
    are loaded.""")))
conf.registerGlobalValue(Misc, 'listUnloadedPlugins',
    registry.Boolean(True, _("""Determines whether the bot will list unloaded
    plugins with the list command if given the --unloaded switch.  If this is
    disabled, non-owner users should be unable to see what unloaded plugins
    are available.""")))
conf.registerGlobalValue(Misc, 'timestampFormat',
    registry.String('[%H:%M:%S]', _("""Determines the format string for
    timestamps in the Misc.last command.  Refer to the Python documentation
    for the time module to see what formats are accepted. If you set this
    variable to the empty string, the timestamp will not be shown.""")))
conf.registerGroup(Misc, 'last')
conf.registerGroup(Misc.last, 'nested')
conf.registerChannelValue(Misc.last.nested,
    'includeTimestamp', registry.Boolean(False, _("""Determines whether or not
    the timestamp will be included in the output of last when it is part of a
    nested command""")))
conf.registerChannelValue(Misc.last.nested,
    'includeNick', registry.Boolean(False, _("""Determines whether or not the
    nick will be included in the output of last when it is part of a nested
    command""")))

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# Copyright (c) 2009, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import re
import os
import imp
import sys
import json
import time


import supybot

import supybot.conf as conf
from supybot import commands
import supybot.utils as utils
from supybot.commands import *
import supybot.ircdb as ircdb
import supybot.irclib as irclib
import supybot.ircmsgs as ircmsgs
import supybot.ircutils as ircutils
import supybot.callbacks as callbacks
from supybot import commands

from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Misc')

if sys.version_info[0] < 3:
    from itertools import ifilter as filter

def get_suffix(file):
    for suffix in imp.get_suffixes():
        if file[-len(suffix[0]):] == suffix[0]:
            return suffix
    return None

def getPluginsInDirectory(directory):
    # get modules in a given directory
    plugins = []
    for filename in os.listdir(directory):
        pluginPath = os.path.join(directory, filename)
        if os.path.isdir(pluginPath):
            if all(os.path.isfile(os.path.join(pluginPath, x))
                    for x in ['__init__.py', 'config.py', 'plugin.py']):
                plugins.append(filename)
    return plugins

class RegexpTimeout(Exception):
    pass

class Misc(callbacks.Plugin):
    def __init__(self, irc):
        self.__parent = super(Misc, self)
        self.__parent.__init__(irc)
        self.invalidCommands = \
                ircutils.FloodQueue(conf.supybot.abuse.flood.interval())
        conf.supybot.abuse.flood.interval.addCallback(self.setFloodQueueTimeout)

    def setFloodQueueTimeout(self, *args, **kwargs):
        self.invalidCommands.timeout = conf.supybot.abuse.flood.interval()

    def callPrecedence(self, irc):
        return ([cb for cb in irc.callbacks if cb is not self], [])

    def invalidCommand(self, irc, msg, tokens):
        assert not msg.repliedTo, 'repliedTo msg in Misc.invalidCommand.'
        assert self is irc.callbacks[-1], 'Misc isn\'t last callback.'
        assert msg.command in ('PRIVMSG', 'NOTICE')
        self.log.debug('Misc.invalidCommand called (tokens %s)', tokens)
        # First, we check for invalidCommand floods.  This is rightfully done
        # here since this will be the last invalidCommand called, and thus it
        # will only be called if this is *truly* an invalid command.
        maximum = conf.supybot.abuse.flood.command.invalid.maximum()
        self.invalidCommands.enqueue(msg)
        if self.invalidCommands.len(msg) > maximum and \
           conf.supybot.abuse.flood.command.invalid() and \
           not ircdb.checkCapability(msg.prefix, 'owner'):
            punishment = conf.supybot.abuse.flood.command.invalid.punishment()
            banmask = '*!%s@%s' % (msg.user, msg.host)
            self.log.info('Ignoring %s for %s seconds due to an apparent '
                          'invalid command flood.', banmask, punishment)
            if tokens and tokens[0] == 'Error:':
                self.log.warning('Apparent error loop with another Supybot '
                                 'observed.  Consider ignoring this bot '
                                 'permanently.')
            ircdb.ignores.add(banmask, time.time() + punishment)
            if conf.supybot.abuse.flood.command.invalid.notify():
                irc.reply(_('You\'ve given me %s invalid commands within the last '
                          '%i seconds; I\'m now ignoring you for %s.') %
                          (maximum,
                           conf.supybot.abuse.flood.interval(),
                           utils.timeElapsed(punishment, seconds=False)))
            return
        # Now, for normal handling.
        channel = msg.args[0]
        # Only bother with the invaildCommand flood handling if it's actually
        # enabled
        if conf.supybot.abuse.flood.command.invalid():
            # First, we check for invalidCommand floods.  This is rightfully done
            # here since this will be the last invalidCommand called, and thus it
            # will only be called if this is *truly* an invalid command.
            maximum = conf.supybot.abuse.flood.command.invalid.maximum()
            banmasker = conf.supybot.protocols.irc.banmask.makeBanmask
            if self.invalidCommands.len(msg) > maximum and \
               not ircdb.checkCapability(msg.prefix, 'owner') and \
               msg.prefix != irc.prefix and \
               ircutils.isUserHostmask(msg.prefix):
                penalty = conf.supybot.abuse.flood.command.invalid.punishment()
                banmask = banmasker(msg.prefix, channel=None)
                self.log.info('Ignoring %s for %s seconds due to an apparent '
                              'invalid command flood.', banmask, penalty)
                if tokens and tokens[0] == 'Error:':
                    self.log.warning('Apparent error loop with another Supybot '
                                     'observed.  Consider ignoring this bot '
                                     'permanently.')
                ircdb.ignores.add(banmask, time.time() + penalty)
                if conf.supybot.abuse.flood.command.invalid.notify():
                    irc.reply('You\'ve given me %s invalid commands within '
                              'the last minute; I\'m now ignoring you for %s.' %
                              (maximum,
                               utils.timeElapsed(penalty, seconds=False)))
                return
        # Now, for normal handling.
        if conf.get(conf.supybot.reply.whenNotCommand, channel):
            if len(tokens) >= 2:
                cb = irc.getCallback(tokens[0])
                if cb:
                    plugin = cb.name()
                    irc.error(format(_('The %q plugin is loaded, but there is '
                                     'no command named %q in it.  Try "list '
                                     '%s" to see the commands in the %q '
                                     'plugin.'), plugin, tokens[1],
                                     plugin, plugin))
                else:
                    irc.errorInvalid(_('command'), tokens[0], repr=False)
            else:
                command = tokens and tokens[0] or ''
                irc.errorInvalid(_('command'), command, repr=False)
        else:
            if tokens:
                # echo [] will get us an empty token set, but there's no need
                # to log this in that case anyway, it being a nested command.
                self.log.info('Not replying to %s, not a command.', tokens[0])
            if irc.nested:
                bracketConfig = conf.supybot.commands.nested.brackets
                brackets = conf.get(bracketConfig, channel)
                if brackets:
                    (left, right) = brackets
                    irc.reply(left + ' '.join(tokens) + right)
                else:
                    pass # Let's just do nothing, I can't think of better.

    @internationalizeDocstring
    def list(self, irc, msg, args, optlist, cb):
        """[--private] [--unloaded] [<plugin>]

        Lists the commands available in the given plugin.  If no plugin is
        given, lists the public plugins available.  If --private is given,
        lists the private plugins. If --unloaded is given, it will list
        available plugins that are not loaded.
        """
        private = False
        unloaded = False
        for (option, argument) in optlist:
            if option == 'private':
                private = True
                if not self.registryValue('listPrivatePlugins') and \
                   not ircdb.checkCapability(msg.prefix, 'owner'):
                    irc.errorNoCapability('owner')
            elif option == 'unloaded':
                unloaded = True
                if not self.registryValue('listUnloadedPlugins') and \
                   not ircdb.checkCapability(msg.prefix, 'owner'):
                    irc.errorNoCapability('owner')
        if unloaded and private:
            irc.error(_('--private and --unloaded are uncompatible options.'))
            return
        if not cb:
            if unloaded:
                # We were using the path of Misc + .. to detect the install
                # directory. However, it fails if Misc is not in the
                # installation directory for some reason, so we use a
                # supybot module.
                installedPluginsDirectory = os.path.join(
                        os.path.dirname(conf.__file__), 'plugins')
                plugins = getPluginsInDirectory(installedPluginsDirectory)
                for directory in conf.supybot.directories.plugins()[:]:
                    plugins.extend(getPluginsInDirectory(directory))
                # Remove loaded plugins:
                loadedPlugins = [x.name() for x in irc.callbacks]
                plugins = [x for x in plugins if x not in loadedPlugins]

                plugins.sort()
                irc.reply(format('%L', plugins))
            else:
                def isPublic(cb):
                    name = cb.name()
                    return conf.supybot.plugins.get(name).public()
                names = [cb.name() for cb in irc.callbacks
                         if (private and not isPublic(cb)) or
                            (not private and isPublic(cb))]
                names.sort()
                if names:
                    irc.reply(format('%L', names))
                else:
                    if private:
                        irc.reply(_('There are no private plugins.'))
                    else:
                        irc.reply(_('There are no public plugins.'))
        else:
            commands = cb.listCommands()
            if commands:
                commands.sort()
                irc.reply(format('%L', commands))
            else:
                irc.reply(format(_('That plugin exists, but has no commands.  '
                                 'This probably means that it has some '
                                 'configuration variables that can be '
                                 'changed in order to modify its behavior.  '
                                 'Try "config list supybot.plugins.%s" to see '
                                 'what configuration variables it has.'),
                                 cb.name()))
    list = wrap(list, [getopts({'private':'', 'unloaded':''}),
                       additional('plugin')])

    @internationalizeDocstring
    def apropos(self, irc, msg, args, s):
        """<string>

        Searches for <string> in the commands currently offered by the bot,
        returning a list of the commands containing that string.
        """
        commands = {}
        L = []
        for cb in irc.callbacks:
            if isinstance(cb, callbacks.Plugin):
                for command in cb.listCommands():
                    if s in command:
                        commands.setdefault(command, []).append(cb.name())
        for (key, names) in commands.iteritems():
            for name in names:
                L.append('%s %s' % (name, key))
        if L:
            L.sort()
            irc.reply(format('%L', L))
        else:
            irc.reply(_('No appropriate commands were found.'))
    apropos = wrap(apropos, ['lowered'])

    @internationalizeDocstring
    def help(self, irc, msg, args, command):
        """[<plugin>] [<command>]

        This command gives a useful description of what <command> does.
        <plugin> is only necessary if the command is in more than one plugin.

        You may also want to use the 'list' command to list all available
        plugins and commands.
        """
        command = list(map(callbacks.canonicalName, command))
        (maxL, cbs) = irc.findCallbacksForArgs(command)
        if maxL == command:
            if len(cbs) > 1:
                names = sorted([cb.name() for cb in cbs])
                irc.error(format(_('That command exists in the %L plugins.  '
                                 'Please specify exactly which plugin command '
                                 'you want help with.'), names))
            else:
                assert cbs, 'Odd, maxL == command, but no cbs.'
                irc.reply(_.__call__(cbs[0].getCommandHelp(command, False)))
        else:
            irc.error(format(_('There is no command %q.'),
                             callbacks.formatCommand(command)))
    help = wrap(help, [many('something')])

    @internationalizeDocstring
    def version(self, irc, msg, args):
        """takes no arguments

        Returns the version of the current bot.
        """
        try:
            newestUrl = 'https://api.github.com/repos/ProgVal/Limnoria/' + \
                    'commits/%s'
            versions = {}
            for branch in ('master', 'testing'):
                data = json.loads(utils.web.getUrl(newestUrl % branch)
                        .decode('utf8'))
                version = data['commit']['committer']['date']
                # Strip the last 'Z':
                version = version.rsplit('T', 1)[0].replace('-', '.')
                if sys.version_info[0] < 3 and isinstance(version, unicode):
                    version = version.encode('utf8')
                versions[branch] = version
            newest = _('The newest versions available online are %s.') % \
                    ', '.join([_('%s (in %s)') % (y,x)
                               for x,y in versions.items()])
        except utils.web.Error as e:
            self.log.info('Couldn\'t get website version: %s', e)
            newest = _('I couldn\'t fetch the newest version '
                     'from the Limnoria repository.')
        s = _('The current (running) version of this Supybot is %s, '
              'running on Python %s.  %s') % \
            (conf.version, sys.version.replace('\n', ' '), newest)
        irc.reply(s)
    version = wrap(thread(version))

    @internationalizeDocstring
    def source(self, irc, msg, args):
        """takes no arguments

        Returns a URL saying where to get Limnoria.
        """
        irc.reply(_('My source is at https://github.com/ProgVal/Limnoria'))
    source = wrap(source)

    @internationalizeDocstring
    def more(self, irc, msg, args, nick):
        """[<nick>]

        If the last command was truncated due to IRC message length
        limitations, returns the next chunk of the result of the last command.
        If <nick> is given, it takes the continuation of the last command from
        <nick> instead of the person sending this message.
        """
        userHostmask = msg.prefix.split('!', 1)[1]
        if nick:
            try:
                (private, L) = irc._mores[nick]
                if not private:
                    irc._mores[userHostmask] = L[:]
                else:
                    irc.error(_('%s has no public mores.') % nick)
                    return
            except KeyError:
                irc.error(_('Sorry, I can\'t find any mores for %s') % nick)
                return
        try:
            L = irc._mores[userHostmask]
            number = self.registryValue('mores', msg.args[0])
            chunks = [L.pop() for x in xrange(0, number)]
            if L:
                if len(L) < 2:
                    more = _('1 more message')
                else:
                    more = _('%i more messages') % len(L)
                chunks[-1] += format(' \x02(%s)\x0F', more)
            irc.replies(chunks, noLengthCheck=True, oneToOne=False)
        except KeyError:
            irc.error(_('You haven\'t asked me a command; perhaps you want '
                      'to see someone else\'s more.  To do so, call this '
                      'command with that person\'s nick.'))
        except IndexError:
            irc.error(_('That\'s all, there is no more.'))
    more = wrap(more, [additional('seenNick')])

    def _validLastMsg(self, msg):
        return msg.prefix and \
               msg.command == 'PRIVMSG' and \
               ircutils.isChannel(msg.args[0])

    @internationalizeDocstring
    def last(self, irc, msg, args, optlist):
        """[--{from,in,on,with,without,regexp} <value>] [--nolimit]

        Returns the last message matching the given criteria.  --from requires
        a nick from whom the message came; --in requires a channel the message
        was sent to; --on requires a network the message was sent on; --with
        requires some string that had to be in the message; --regexp requires
        a regular expression the message must match; --nolimit returns all
        the messages that can be found.  By default, the channel this command is
        given in is searched.
        """
        predicates = {}
        nolimit = False
        skipfirst = True
        if ircutils.isChannel(msg.args[0]):
            predicates['in'] = lambda m: ircutils.strEqual(m.args[0],
                                                           msg.args[0])
        else:
            skipfirst = False
        for (option, arg) in optlist:
            if option == 'from':
                def f(m, arg=arg):
                    return ircutils.hostmaskPatternEqual(arg, m.nick)
                predicates['from'] = f
            elif option == 'in':
                def f(m, arg=arg):
                    return ircutils.strEqual(m.args[0], arg)
                predicates['in'] = f
                if arg != msg.args[0]:
                    skipfirst = False
            elif option == 'on':
                def f(m, arg=arg):
                    return m.receivedOn == arg
                predicates['on'] = f
            elif option == 'with':
                def f(m, arg=arg):
                    return arg.lower() in m.args[1].lower()
                predicates.setdefault('with', []).append(f)
            elif option == 'without':
                def f(m, arg=arg):
                    return arg.lower() not in m.args[1].lower()
                predicates.setdefault('without', []).append(f)
            elif option == 'regexp':
                def f(m, arg=arg):
                    def f1(s, arg):
                        """Since we can't enqueue match objects into the multiprocessing queue,
                        we'll just wrap the function to return bools."""
                        if arg.search(s) is not None:
                            return True
                        else:
                            return False
                    if ircmsgs.isAction(m):
                        m1 = ircmsgs.unAction(m)
                    else:
                        m1 = m.args[1]
                    return regexp_wrapper(m1, reobj=arg, timeout=0.1,
                                          plugin_name=self.name(),
                                          fcn_name='last')
                predicates.setdefault('regexp', []).append(f)
            elif option == 'nolimit':
                nolimit = True
        iterable = filter(self._validLastMsg, reversed(irc.state.history))
        if skipfirst:
            # Drop the first message only if our current channel is the same as
            # the channel we've been instructed to look at.
            next(iterable)
        predicates = list(utils.iter.flatten(predicates.itervalues()))
        # Make sure the user can't get messages from channels they aren't in
        def userInChannel(m):
            return m.args[0] in irc.state.channels \
                    and msg.nick in irc.state.channels[m.args[0]].users
        predicates.append(userInChannel)
        # Make sure the user can't get messages from a +s channel unless
        # they're calling the command from that channel or from a query
        def notSecretMsg(m):
            return not irc.isChannel(msg.args[0]) \
                    or msg.args[0] == m.args[0] \
                    or (m.args[0] in irc.state.channels \
                        and 's' not in irc.state.channels[m.args[0]].modes)
        predicates.append(notSecretMsg)
        resp = []
        if irc.nested and not \
          self.registryValue('last.nested.includeTimestamp'):
            tsf = None
        else:
            tsf = self.registryValue('timestampFormat')
        if irc.nested and not self.registryValue('last.nested.includeNick'):
            showNick = False
        else:
            showNick = True
        for m in iterable:
            for predicate in predicates:
                try:
                    if not predicate(m):
                        break
                except RegexpTimeout:
                    irc.error(_('The regular expression timed out.'))
                    return
            else:
                if nolimit:
                    resp.append(ircmsgs.prettyPrint(m,
                                                    timestampFormat=tsf,
                                                    showNick=showNick))
                else:
                    irc.reply(ircmsgs.prettyPrint(m,
                                                  timestampFormat=tsf,
                                                  showNick=showNick))
                    return
        if not resp:
            irc.error(_('I couldn\'t find a message matching that criteria in '
                      'my history of %s messages.') % len(irc.state.history))
        else:
            irc.reply(format('%L', resp))
    last = wrap(last, [getopts({'nolimit': '',
                                'on': 'something',
                                'with': 'something',
                                'from': 'something',
                                'without': 'something',
                                'in': 'callerInGivenChannel',
                                'regexp': 'regexpMatcher',})])


    def _tell(self, irc, msg, args, target, text, notice):
        if irc.nested:
            irc.error('This command cannot be nested.', Raise=True)
        if target.lower() == 'me':
            target = msg.nick
        if ircutils.isChannel(target):
            irc.error(_('Hey, just give the command.  No need for the tell.'))
            return
        if not ircutils.isNick(target):
            irc.errorInvalid('nick', target)
        if ircutils.nickEqual(target, irc.nick):
            irc.error(_('You just told me, why should I tell myself?'),
                      Raise=True)
        if target not in irc.state.nicksToHostmasks and \
             not ircdb.checkCapability(msg.prefix, 'owner'):
            # We'll let owners do this.
            s = _('I haven\'t seen %s, I\'ll let you do the telling.') % target
            irc.error(s, Raise=True)
        if irc.action:
            irc.action = False
            text = '* %s %s' % (irc.nick, text)
        s = _('%s wants me to tell you: %s') % (msg.nick, text)
        irc.replySuccess()
        irc.reply(s, to=target, private=True, notice=notice)

    @internationalizeDocstring
    def tell(self, *args):
        """<nick> <text>

        Tells the <nick> whatever <text> is.  Use nested commands to your
        benefit here.
        """
        self._tell(*args, notice=False)
    tell = wrap(tell, ['something', 'text'])

    @internationalizeDocstring
    def noticetell(self, *args):
        """<nick> <text>

        Tells the <nick> whatever <text> is, in a notice.  Use nested
        commands to your benefit here.
        """
        self._tell(*args, notice=True)
    noticetell = wrap(noticetell, ['something', 'text'])

    @internationalizeDocstring
    def ping(self, irc, msg, args):
        """takes no arguments

        Checks to see if the bot is alive.
        """
        irc.reply(_('pong'), prefixNick=False)

    @internationalizeDocstring
    def completenick(self, irc, msg, args, channel, beginning, optlist):
        """[<channel>] <beginning> [--match-case]

        Returns the nick of someone on the channel whose nick begins with the
        given <beginning>.
        <channel> defaults to the current channel."""
        if channel not in irc.state.channels:
            irc.error(_('I\'m not even in %s.') % channel, Raise=True)
        if ('match-case', True) in optlist:
            def match(nick):
                return nick.startswith(beginning)
        else:
            beginning = beginning.lower()
            def match(nick):
                return nick.lower().startswith(beginning)
        for nick in irc.state.channels[channel].users:
            if match(nick):
                irc.reply(nick)
                return
        irc.error(_('No such nick.'))
    completenick = wrap(completenick, ['channel', 'something',
                                       getopts({'match-case':''})])

Class = Misc

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# Copyright (c) 2008, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import re

from supybot.test import *

class MiscTestCase(ChannelPluginTestCase):
    plugins = ('Misc', 'Utilities', 'Anonymous', 'Plugin',
               'Channel', 'Dict', 'User', 'String')
    def testReplyWhenNotCommand(self):
        try:
            original = conf.supybot.reply.whenNotCommand()
            conf.supybot.reply.whenNotCommand.setValue(True)
            self.prefix = 'somethingElse!user@host.domain.tld'
            self.assertRegexp('foo', 'not.*command')
            self.assertRegexp('foo bar baz', 'not.*command')
        finally:
            conf.supybot.reply.whenNotCommand.setValue(original)

    def testReplyWhenNotCommandButFirstCommandIsPluginName(self):
        try:
            original = conf.supybot.reply.whenNotCommand()
            conf.supybot.reply.whenNotCommand.setValue(True)
            self.assertRegexp('misc foo', '"list Misc"')
        finally:
            conf.supybot.reply.whenNotCommand.setValue(original)

#    if network:
#        def testNotReplyWhenRegexpsMatch(self):
#            try:
#                orig = conf.supybot.reply.whenNotCommand()
#                gk = conf.supybot.plugins.Gameknot.gameSnarfer()
#                conf.supybot.reply.whenNotCommand.setValue(True)
#                conf.supybot.plugins.Gameknot.gameSnarfer.setValue(True)
#                self.prefix = 'somethingElse!user@host.domain.tld'
#                self.assertSnarfNotError(
#                        'http://gameknot.com/chess.pl?bd=1019508')
#            finally:
#                conf.supybot.reply.whenNotCommand.setValue(orig)
#                conf.supybot.plugins.Gameknot.gameSnarfer.setValue(gk)

    def testNotReplyWhenNotCanonicalName(self):
        try:
            original = str(conf.supybot.reply.whenNotCommand)
            conf.supybot.reply.whenNotCommand.set('True')
            self.prefix = 'somethingElse!user@host.domain.tld'
            self.assertNotRegexp('LeN foobar', 'command')
            self.assertResponse('lEn foobar', '6')
        finally:
            conf.supybot.reply.whenNotCommand.set(original)

    def testHelp(self):
        self.assertHelp('help list')
        self.assertRegexp('help help', r'^\(\x02help')
        #self.assertRegexp('help misc help', r'^\(\x02misc help')
        self.assertError('help nonExistentCommand')

    def testHelpIncludeFullCommandName(self):
        self.assertHelp('help channel capability add')
        m = self.getMsg('help channel capability add')
        self.failUnless('channel capability add' in m.args[1])

    def testHelpDoesAmbiguityWithDefaultPlugins(self):
        m = self.getMsg('help list') # Misc.list and User.list.
        self.failIf(m.args[1].startswith('Error'))

    def testHelpIsCaseInsensitive(self):
        self.assertHelp('help LIST')

    def testList(self):
        self.assertNotError('list')
        self.assertNotError('list Misc')
        self.assertRegexp('list --unloaded', 'Ctcp')

    def testListIsCaseInsensitive(self):
        self.assertNotError('list misc')

    def testListPrivate(self):
        # If Anonymous changes to public, these tests will break.  So if
        # the next assert fails, change the plugin we test for public/private
        # to some other non-public plugin.
        name = 'Anonymous'
        conf.supybot.plugins.Anonymous.public.setValue(False)
        self.assertNotRegexp('list', name)
        self.assertRegexp('list --private', name)
        conf.supybot.plugins.Anonymous.public.setValue(True)
        self.assertRegexp('list', name)
        self.assertNotRegexp('list --private', name)

    def testListUnloaded(self):
        unloadedPlugin = 'Alias'
        loadedPlugin = 'Anonymous'
        self.assertRegexp('list --unloaded', 'Alias')
        self.assertNotRegexp('list --unloaded', 'Anonymous')

    def testListDoesNotIncludeNonCanonicalName(self):
        self.assertNotRegexp('list Owner', '_exec')

    def testListNoIncludeDispatcher(self):
        self.assertNotRegexp('list Misc', 'misc')

    def testListIncludesDispatcherIfThereIsAnOriginalCommand(self):
        self.assertRegexp('list Dict', r'\bdict\b')

    if network:
        def testVersion(self):
            print('*** This test should start passing when we have our '\
                  'threaded issues resolved.')
            self.assertNotError('version')

    def testSource(self):
        self.assertNotError('source')

    def testTell(self):
        # This test fails because the test is seeing us as owner and Misc.tell
        # allows the owner to send messages to people the bot hasn't seen.
        oldprefix, self.prefix = self.prefix, 'tester!foo@bar__no_testcap__baz'
        self.nick = 'tester'
        m = self.getMsg('tell aljsdkfh [plugin tell]')
        self.failUnless('let you do' in m.args[1])
        m = self.getMsg('tell #foo [plugin tell]')
        self.failUnless('No need for' in m.args[1])
        m = self.getMsg('tell me you love me')
        m = self.irc.takeMsg()
        self.failUnless(m.args[0] == self.nick)

    def testNoNestedTell(self):
        self.assertRegexp('echo [tell %s foo]' % self.nick, 'nested')

    def testTellDoesNotPropogateAction(self):
        m = self.getMsg('tell foo [action bar]')
        self.failIf(ircmsgs.isAction(m))

    def testLast(self):
        orig = conf.supybot.plugins.Misc.timestampFormat()
        try:
            conf.supybot.plugins.Misc.timestampFormat.setValue('')
            self.feedMsg('foo bar baz')
            self.assertResponse('last', '<%s> foo bar baz' % self.nick)
            self.assertRegexp('last', '<%s> @last' % self.nick)
            self.assertResponse('last --with foo', '<%s> foo bar baz' % \
                                self.nick)
            self.assertResponse('last --without foo', '<%s> @last' % self.nick)
            self.assertRegexp('last --regexp m/\s+/', 'last --without foo')
            self.assertResponse('last --regexp m/bar/',
                                '<%s> foo bar baz' % self.nick)
            self.assertResponse('last --from %s' % self.nick.upper(),
                                '<%s> @last --regexp m/bar/' % self.nick)
            self.assertResponse('last --from %s*' % self.nick[0],
                                '<%s> @last --from %s' %
                                (self.nick, self.nick.upper()))
            conf.supybot.plugins.Misc.timestampFormat.setValue('foo')
            self.assertSnarfNoResponse('foo bar baz', 1)
            self.assertResponse('last', 'foo <%s> foo bar baz' % self.nick)
        finally:
            conf.supybot.plugins.Misc.timestampFormat.setValue(orig)

    def testNestedLastTimestampConfig(self):
        tsConfig = conf.supybot.plugins.Misc.last.nested.includeTimestamp
        orig = tsConfig()
        try:
            tsConfig.setValue(True)
            self.getMsg('foo bar baz')
            chars = conf.supybot.reply.whenAddressedBy.chars()
            chars = re.escape(chars)
            self.assertRegexp('echo [last]', r'[%s]foo bar baz' % chars)
        finally:
            tsConfig.setValue(orig)

    def testNestedLastNickConfig(self):
        nickConfig = conf.supybot.plugins.Misc.last.nested.includeNick
        orig = nickConfig()
        try:
            nickConfig.setValue(True)
            self.getMsg('foo bar baz')
            chars = conf.supybot.reply.whenAddressedBy.chars()
            chars = re.escape(chars)
            self.assertRegexp('echo [last]',
                              '<%s> [%s]foo bar baz' % (self.nick, chars))
        finally:
            nickConfig.setValue(orig)

    def testMore(self):
        self.assertRegexp('echo %s' % ('abc'*300), 'more')
        self.assertRegexp('more', 'more')
        self.assertNotRegexp('more', 'more')
        with conf.supybot.plugins.Misc.mores.context(2):
            self.assertRegexp('echo %s' % ('abc'*600), 'more')

            self.assertNotRegexp('more', 'more')
            m = self.irc.takeMsg()
            self.assertIsNot(m, None)
            self.assertIn('more', m.args[1])

            self.assertNotRegexp('more', 'more')
            m = self.irc.takeMsg()
            self.assertIsNot(m, None)
            self.assertNotIn('more', m.args[1])

    def testInvalidCommand(self):
        self.assertError('echo []')

    def testInvalidCommands(self):
        with conf.supybot.abuse.flood.command.invalid.maximum.context(3):
            self.assertNotRegexp('foo', 'given me', frm='f!f@__no_testcap__')
            self.assertNotRegexp('bar', 'given me', frm='f!f@__no_testcap__')
            self.assertNotRegexp('baz', 'given me', frm='f!f@__no_testcap__')
            self.assertRegexp('qux', 'given me', frm='f!f@__no_testcap__')

    def testMoreIsCaseInsensitive(self):
        self.assertNotError('echo %s' % ('abc'*2000))
        self.assertNotError('more')
        nick = ircutils.nickFromHostmask(self.prefix)
        self.assertNotError('more %s' % nick)
        self.assertNotError('more %s' % nick.upper())
        self.assertNotError('more %s' % nick.lower())

    def testApropos(self):
        self.assertNotError('apropos f')
        self.assertRegexp('apropos asldkfjasdlkfja', 'No appropriate commands')

    def testAproposIsNotCaseSensitive(self):
        self.assertNotRegexp('apropos LIST', 'No appropriate commands')

    def testAproposDoesntReturnNonCanonicalNames(self):
        self.assertNotRegexp('apropos exec', '_exec')

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:


########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2003-2005, Daniel DiPaolo
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('MoobotFactoids')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('MoobotFactoids', True)


MoobotFactoids = conf.registerPlugin('MoobotFactoids')
conf.registerChannelValue(MoobotFactoids,
    'showFactoidIfOnlyOneMatch', registry.Boolean(True, _("""Determines whether
    or not the factoid value will be shown when a listkeys search returns only
    one factoid key.""")))
conf.registerChannelValue(MoobotFactoids,
    'mostCount', registry.Integer(10, _("""Determines how many items are shown
    when the 'most' command is called.""")))


# vim:set shiftwidth=4 softtabstop=8 expandtab textwidth=78

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2003-2005, Daniel DiPaolo
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import os
import time
import string

from cStringIO import StringIO

import supybot.conf as conf
import supybot.ircdb as ircdb
import supybot.utils as utils
import supybot.shlex as shlex
from supybot.commands import *
import supybot.plugins as plugins
import supybot.ircutils as ircutils
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('MoobotFactoids')

class OptionList(object):
    separators = '|()'
    def _insideParens(self, lexer):
        ret = []
        while True:
            token = lexer.get_token()
            if not token:
                return '(%s' % ''.join(ret) #)
            elif token == ')':
                if '|' in ret:
                    L = list(map(''.join,
                            utils.iter.split('|'.__eq__, ret,
                                             yieldEmpty=True)))
                    return utils.iter.choice(L)
                else:
                    return '(%s)' % ''.join(ret)
            elif token == '(':
                ret.append(self._insideParens(lexer))
            elif token == '|':
                ret.append(token)
            else:
                ret.append(token)

    def tokenize(self, s):
        lexer = shlex.shlex(StringIO(s))
        lexer.commenters = ''
        lexer.quotes = ''
        lexer.whitespace = ''
        lexer.separators += self.separators
        ret = []
        while True:
            token = lexer.get_token()
            if not token:
                break
            elif token == '(':
                ret.append(self._insideParens(lexer))
            else:
                ret.append(token)
        return ''.join(ret)

def pickOptions(s):
    return OptionList().tokenize(s)

class SqliteMoobotDB(object):
    def __init__(self, filename):
        self.filename = filename
        self.dbs = ircutils.IrcDict()

    def close(self):
        for db in self.dbs.itervalues():
            db.close()
        self.dbs.clear()

    def _getDb(self, channel):
        import sqlite3

        if channel in self.dbs:
            return self.dbs[channel]
        filename = plugins.makeChannelFilename(self.filename, channel)
        
        if os.path.exists(filename):
            db = sqlite3.connect(filename, check_same_thread=False)
            db.text_factory = str
            self.dbs[channel] = db
            return db
        db = sqlite3.connect(filename, check_same_thread=False)
        db.text_factory = str
        self.dbs[channel] = db
        cursor = db.cursor()
        cursor.execute("""CREATE TABLE factoids (
                          key TEXT PRIMARY KEY,
                          created_by INTEGER,
                          created_at TIMESTAMP,
                          modified_by INTEGER,
                          modified_at TIMESTAMP,
                          locked_at TIMESTAMP,
                          locked_by INTEGER,
                          last_requested_by TEXT,
                          last_requested_at TIMESTAMP,
                          fact TEXT,
                          requested_count INTEGER
                          )""")
        db.commit()
        return db

    def getFactoid(self, channel, key):
        db = self._getDb(channel)
        cursor = db.cursor()
        cursor.execute("""SELECT fact FROM factoids
                          WHERE key LIKE ?""", (key,))
        results = cursor.fetchall()
        if len(results) == 0:
            return None
        else:
            return results[0]

    def getFactinfo(self, channel, key):
        db = self._getDb(channel)
        cursor = db.cursor()
        cursor.execute("""SELECT created_by, created_at,
                                 modified_by, modified_at,
                                 last_requested_by, last_requested_at,
                                 requested_count, locked_by, locked_at
                          FROM factoids
                          WHERE key LIKE ?""", (key,))
        results = cursor.fetchall()
        if len(results) == 0:
            return None
        else:
            return results[0]

    def randomFactoid(self, channel):
        db = self._getDb(channel)
        cursor = db.cursor()
        cursor.execute("""SELECT fact, key FROM factoids
                          ORDER BY random() LIMIT 1""")
        results = cursor.fetchall()
        if len(results) == 0:
            return None
        else:
            return results[0]

    def addFactoid(self, channel, key, value, creator_id):
        db = self._getDb(channel)
        cursor = db.cursor()
        cursor.execute("""INSERT INTO factoids VALUES
                          (?, ?, ?, NULL, NULL, NULL, NULL,
                           NULL, NULL, ?, 0)""",
                           (key, creator_id, int(time.time()), value))
        db.commit()

    def updateFactoid(self, channel, key, newvalue, modifier_id):
        db = self._getDb(channel)
        cursor = db.cursor()
        cursor.execute("""UPDATE factoids
                          SET fact=?, modified_by=?,
                          modified_at=? WHERE key LIKE ?""",
                          (newvalue, modifier_id, int(time.time()), key))
        db.commit()

    def updateRequest(self, channel, key, hostmask):
        db = self._getDb(channel)
        cursor = db.cursor()
        cursor.execute("""UPDATE factoids SET
                          last_requested_by = ?,
                          last_requested_at = ?,
                          requested_count = requested_count + 1
                          WHERE key = ?""",
                          (hostmask, int(time.time()), key))
        db.commit()

    def removeFactoid(self, channel, key):
        db = self._getDb(channel)
        cursor = db.cursor()
        cursor.execute("""DELETE FROM factoids WHERE key LIKE ?""",
                          (key,))
        db.commit()

    def locked(self, channel, key):
        db = self._getDb(channel)
        cursor = db.cursor()
        cursor.execute ("""SELECT locked_by FROM factoids
                           WHERE key LIKE ?""", (key,))
        if cursor.fetchone()[0] is None:
            return False
        else:
            return True

    def lock(self, channel, key, locker_id):
        db = self._getDb(channel)
        cursor = db.cursor()
        cursor.execute("""UPDATE factoids
                          SET locked_by=?, locked_at=?
                          WHERE key LIKE ?""",
                          (locker_id, int(time.time()), key))
        db.commit()

    def unlock(self, channel, key):
        db = self._getDb(channel)
        cursor = db.cursor()
        cursor.execute("""UPDATE factoids
                          SET locked_by=?, locked_at=?
                          WHERE key LIKE ?""", (None, None, key))
        db.commit()

    def mostAuthored(self, channel, limit):
        db = self._getDb(channel)
        cursor = db.cursor()
        cursor.execute("""SELECT created_by, count(key) FROM factoids
                          GROUP BY created_by
                          ORDER BY count(key) DESC LIMIT ?""", (limit,))
        return cursor.fetchall()

    def mostRecent(self, channel, limit):
        db = self._getDb(channel)
        cursor = db.cursor()
        cursor.execute("""SELECT key FROM factoids
                          ORDER BY created_at DESC LIMIT ?""", (limit,))
        return cursor.fetchall()

    def mostPopular(self, channel, limit):
        db = self._getDb(channel)
        cursor = db.cursor()
        cursor.execute("""SELECT key, requested_count FROM factoids
                          WHERE requested_count > 0
                          ORDER BY requested_count DESC LIMIT ?""", (limit,))
        results = cursor.fetchall()
        return results

    def getKeysByAuthor(self, channel, authorId):
        db = self._getDb(channel)
        cursor = db.cursor()
        cursor.execute("""SELECT key FROM factoids WHERE created_by=?
                          ORDER BY key""", (authorId,))
        results = cursor.fetchall()
        return results

    def getKeysByGlob(self, channel, glob):
        db = self._getDb(channel)
        cursor = db.cursor()
        glob = '%%%s%%' % glob
        cursor.execute("""SELECT key FROM factoids WHERE key LIKE ?
                          ORDER BY key""", (glob,))
        results = cursor.fetchall()
        return results

    def getKeysByValueGlob(self, channel, glob):
        db = self._getDb(channel)
        cursor = db.cursor()
        glob = '%%%s%%' % glob
        cursor.execute("""SELECT key FROM factoids WHERE fact LIKE ?
                          ORDER BY key""", (glob,))
        results = cursor.fetchall()
        return results

MoobotDB = plugins.DB('MoobotFactoids', {'sqlite3': SqliteMoobotDB})

class MoobotFactoids(callbacks.Plugin):
    """Add the help for "@help MoobotFactoids" here (assuming you don't implement a MoobotFactoids
    command).  This should describe *how* to use this plugin."""
    callBefore = ['Dunno']
    def __init__(self, irc):
        self.db = MoobotDB()
        self.__parent = super(MoobotFactoids, self)
        self.__parent.__init__(irc)

    def die(self):
        self.__parent.die()
        self.db.close()

    def reset(self):
        self.db.close()

    _replyTag = '<reply>'
    _actionTag = '<action>'
    def _parseFactoid(self, irc, msg, fact):
        type = 'define'  # Default is to just spit the factoid back as a
                         # definition of what the key is (i.e., "foo is bar")
        newfact = pickOptions(fact)
        if newfact.startswith(self._replyTag):
            newfact = newfact[len(self._replyTag):]
            type = 'reply'
        elif newfact.startswith(self._actionTag):
            newfact = newfact[len(self._actionTag):]
            type = 'action'
        newfact = newfact.strip()
        newfact = ircutils.standardSubstitute(irc, msg, newfact)
        return (type, newfact)

    def invalidCommand(self, irc, msg, tokens):
        if '=~' in tokens:
            self.changeFactoid(irc, msg, tokens)
        elif tokens and tokens[0] in ('no', 'no,'):
            self.replaceFactoid(irc, msg, tokens)
        elif ['is', 'also'] in utils.seq.window(tokens, 2):
            self.augmentFactoid(irc, msg, tokens)
        else:
            key = ' '.join(tokens)
            key = self._sanitizeKey(key)
            channel = plugins.getChannel(msg.args[0])
            fact = self.db.getFactoid(channel, key)
            if fact:
                self.db.updateRequest(channel, key, msg.prefix)
                # getFactoid returns "all results", so we need to extract the
                # first one.
                fact = fact[0]
                # Update the requested count/requested by for this key
                hostmask = msg.prefix
                # Now actually get the factoid and respond accordingly
                (type, text) = self._parseFactoid(irc, msg, fact)
                if type == 'action':
                    irc.reply(text, action=True)
                elif type == 'reply':
                    irc.reply(text, prefixNick=False)
                elif type == 'define':
                    irc.reply(format(_('%s is %s'), key, text),
                                     prefixNick=False)
                else:
                    assert False, 'Spurious type from _parseFactoid'
            else:
                if 'is' in tokens or '_is_' in tokens:
                    self.addFactoid(irc, msg, tokens)

    def _getUserId(self, irc, prefix):
        try:
            return ircdb.users.getUserId(prefix)
        except KeyError:
            irc.errorNotRegistered(Raise=True)

    def _sanitizeKey(self, key):
        return key.rstrip('!? ')

    def _checkNotLocked(self, irc, channel, key):
        if self.db.locked(channel, key):
            irc.error(format(_('Factoid %q is locked.'), key), Raise=True)

    def _getFactoid(self, irc, channel, key):
        fact = self.db.getFactoid(channel, key)
        if fact is not None:
            return fact
        else:
            irc.error(format(_('Factoid %q not found.'), key), Raise=True)

    def _getKeyAndFactoid(self, tokens):
        if '_is_' in tokens:
            p = '_is_'.__eq__
        elif 'is' in tokens:
            p = 'is'.__eq__
        else:
            self.log.debug('Invalid tokens for {add,replace}Factoid: %s.',
                           tokens)
            s = _('Missing an \'is\' or \'_is_\'.')
            raise ValueError(s)
        (key, newfact) = list(map(' '.join, utils.iter.split(p, tokens, maxsplit=1)))
        key = self._sanitizeKey(key)
        return (key, newfact)

    def addFactoid(self, irc, msg, tokens):
        # First, check and see if the entire message matches a factoid key
        channel = plugins.getChannel(msg.args[0])
        id = self._getUserId(irc, msg.prefix)
        try:
            (key, fact) = self._getKeyAndFactoid(tokens)
        except ValueError as e:
            irc.error(str(e), Raise=True)
        # Check and make sure it's not in the DB already
        if self.db.getFactoid(channel, key):
            irc.error(format(_('Factoid %q already exists.'), key), Raise=True)
        self.db.addFactoid(channel, key, fact, id)
        irc.replySuccess()

    def changeFactoid(self, irc, msg, tokens):
        id = self._getUserId(irc, msg.prefix)
        (key, regexp) = list(map(' '.join,
                            utils.iter.split('=~'.__eq__, tokens, maxsplit=1)))
        channel = plugins.getChannel(msg.args[0])
        # Check and make sure it's in the DB
        fact = self._getFactoid(irc, channel, key)
        self._checkNotLocked(irc, channel, key)
        # It's fair game if we get to here
        try:
            r = utils.str.perlReToReplacer(regexp)
        except ValueError as e:
            irc.errorInvalid('regexp', regexp, Raise=True)
        fact = fact[0]
        new_fact = r(fact)
        self.db.updateFactoid(channel, key, new_fact, id)
        irc.replySuccess()

    def augmentFactoid(self, irc, msg, tokens):
        # Must be registered!
        id = self._getUserId(irc, msg.prefix)
        pairs = list(utils.seq.window(tokens, 2))
        isAlso = pairs.index(['is', 'also'])
        key = ' '.join(tokens[:isAlso])
        new_text = ' '.join(tokens[isAlso+2:])
        channel = plugins.getChannel(msg.args[0])
        fact = self._getFactoid(irc, channel, key)
        self._checkNotLocked(irc, channel, key)
        # It's fair game if we get to here
        fact = fact[0]
        new_fact = format(_('%s, or %s'), fact, new_text)
        self.db.updateFactoid(channel, key, new_fact, id)
        irc.replySuccess()

    def replaceFactoid(self, irc, msg, tokens):
        # Must be registered!
        channel = plugins.getChannel(msg.args[0])
        id = self._getUserId(irc, msg.prefix)
        del tokens[0] # remove the "no,"
        try:
            (key, fact) = self._getKeyAndFactoid(tokens)
        except ValueError as e:
            irc.error(str(e), Raise=True)
        _ = self._getFactoid(irc, channel, key)
        self._checkNotLocked(irc, channel, key)
        self.db.removeFactoid(channel, key)
        self.db.addFactoid(channel, key, fact, id)
        irc.replySuccess()

    @internationalizeDocstring
    def literal(self, irc, msg, args, channel, key):
        """[<channel>] <factoid key>

        Returns the literal factoid for the given factoid key.  No parsing of
        the factoid value is done as it is with normal retrieval.  <channel>
        is only necessary if the message isn't sent in the channel itself.
        """
        fact = self._getFactoid(irc, channel, key)
        fact = fact[0]
        irc.reply(fact)
    literal = wrap(literal, ['channeldb', 'text'])

    @internationalizeDocstring
    def factinfo(self, irc, msg, args, channel, key):
        """[<channel>] <factoid key>

        Returns the various bits of info on the factoid for the given key.
        <channel> is only necessary if the message isn't sent in the channel
        itself.
        """
        # Start building the response string
        s = key + ': '
        # Next, get all the info and build the response piece by piece
        info = self.db.getFactinfo(channel, key)
        if not info:
            irc.error(format(_('No such factoid: %q'), key))
            return
        (created_by, created_at, modified_by, modified_at, last_requested_by,
         last_requested_at, requested_count, locked_by, locked_at) = info
        # First, creation info.
        # Map the integer created_by to the username
        created_by = plugins.getUserName(created_by)
        created_at = time.strftime(conf.supybot.reply.format.time(),
                                   time.localtime(int(created_at)))
        s += format(_('Created by %s on %s.'), created_by, created_at)
        # Next, modification info, if any.
        if modified_by is not None:
            modified_by = plugins.getUserName(modified_by)
            modified_at = time.strftime(conf.supybot.reply.format.time(),
                                   time.localtime(int(modified_at)))
            s += format(_(' Last modified by %s on %s.'), modified_by,
                        modified_at)
        # Next, last requested info, if any
        if last_requested_by is not None:
            last_by = last_requested_by  # not an int user id
            last_at = time.strftime(conf.supybot.reply.format.time(),
                                    time.localtime(int(last_requested_at)))
            req_count = requested_count
            s += format(_(' Last requested by %s on %s, requested %n.'),
                        last_by, last_at, (requested_count, 'time'))
        # Last, locked info
        if locked_at is not None:
            lock_at = time.strftime(conf.supybot.reply.format.time(),
                                     time.localtime(int(locked_at)))
            lock_by = plugins.getUserName(locked_by)
            s += format(_(' Locked by %s on %s.'), lock_by, lock_at)
        irc.reply(s)
    factinfo = wrap(factinfo, ['channeldb', 'text'])

    def _lock(self, irc, msg, channel, user, key, locking=True):
        #self.log.debug('in _lock')
        #self.log.debug('id: %s', id)
        id = user.id
        info = self.db.getFactinfo(channel, key)
        if not info:
            irc.error(format(_('No such factoid: %q'), key))
            return
        (created_by, a, a, a, a, a, a, locked_by, a) = info
        # Don't perform redundant operations
        if locking and locked_by is not None:
               irc.error(format(_('Factoid %q is already locked.'), key))
               return
        if not locking and locked_by is None:
               irc.error(format(_('Factoid %q is not locked.'), key))
               return
        # Can only lock/unlock own factoids unless you're an admin
        #self.log.debug('admin?: %s', ircdb.checkCapability(id, 'admin'))
        #self.log.debug('created_by: %s', created_by)
        if not (ircdb.checkCapability(id, 'admin') or created_by == id):
            if locking:
                s = 'lock'
            else:
                s = 'unlock'
            irc.error(format(_('Cannot %s someone else\'s factoid unless you '
                             'are an admin.'), s))
            return
        # Okay, we're done, ready to lock/unlock
        if locking:
           self.db.lock(channel, key, id)
        else:
           self.db.unlock(channel, key)
        irc.replySuccess()

    @internationalizeDocstring
    def lock(self, irc, msg, args, channel, user, key):
        """[<channel>] <factoid key>

        Locks the factoid with the given factoid key.  Requires that the user
        be registered and have created the factoid originally.  <channel> is
        only necessary if the message isn't sent in the channel itself.
        """
        self._lock(irc, msg, channel, user, key, True)
    lock = wrap(lock, ['channeldb', 'user', 'text'])

    @internationalizeDocstring
    def unlock(self, irc, msg, args, channel, user, key):
        """[<channel>] <factoid key>

        Unlocks the factoid with the given factoid key.  Requires that the
        user be registered and have locked the factoid.  <channel> is only
        necessary if the message isn't sent in the channel itself.
        """
        self._lock(irc, msg, channel, user, key, False)
    unlock = wrap(unlock, ['channeldb', 'user', 'text'])

    @internationalizeDocstring
    def most(self, irc, msg, args, channel, method):
        """[<channel>] {popular|authored|recent}

        Lists the most {popular|authored|recent} factoids.  "popular" lists the
        most frequently requested factoids.  "authored" lists the author with
        the most factoids.  "recent" lists the most recently created factoids.
        <channel> is only necessary if the message isn't sent in the channel
        itself.
        """
        method = method.capitalize()
        method = getattr(self, '_most%s' % method, None)
        if method is None:
            raise callbacks.ArgumentError
        limit = self.registryValue('mostCount', channel)
        method(irc, channel, limit)
    most = wrap(most, ['channeldb',
                       ('literal', ('popular', 'authored', 'recent'))])

    def _mostAuthored(self, irc, channel, limit):
        results = self.db.mostAuthored(channel, limit)
        L = ['%s (%s)' % (plugins.getUserName(t[0]), int(t[1]))
             for t in results]
        if L:
            author = _('author')
            if len(L) != 1:
                author = _('authors')
            irc.reply(format(_('Most prolific %s: %L'), author, L))
        else:
            irc.error(_('There are no factoids in my database.'))

    def _mostRecent(self, irc, channel, limit):
        results = self.db.mostRecent(channel, limit)
        L = [format('%q', t[0]) for t in results]
        if L:
            if len(L) < 2:
                latest = _('latest factoid')
            else:
                latest = _('latest factoids')
            irc.reply(format(_('%i %s: %L'), len(L), latest, L))
        else:
            irc.error(_('There are no factoids in my database.'))

    def _mostPopular(self, irc, channel, limit):
        results = self.db.mostPopular(channel, limit)
        L = [format('%q (%s)', t[0], t[1]) for t in results]
        if L:
            if len(L) < 2:
                requested = _('requested factoid')
            else:
                requested = _('requested factoids')
            irc.reply(format(_('Top %i %s: %L'), len(L), requested, L))
        else:
            irc.error(_('No factoids have been requested from my database.'))

    @internationalizeDocstring
    def listauth(self, irc, msg, args, channel, author):
        """[<channel>] <author name>

        Lists the keys of the factoids with the given author.  Note that if an
        author has an integer name, you'll have to use that author's id to use
        this function (so don't use integer usernames!).  <channel> is only
        necessary if the message isn't sent in the channel itself.
        """
        try:
            id = ircdb.users.getUserId(author)
        except KeyError:
            irc.errorNoUser(name=author, Raise=True)
        results = self.db.getKeysByAuthor(channel, id)
        if not results:
            irc.reply(format(_('No factoids by %q found.'), author))
            return
        keys = [format('%q', t[0]) for t in results]
        s = format(_('Author search for %q (%i found): %L'),
                   author, len(keys), keys)
        irc.reply(s)
    listauth = wrap(listauth, ['channeldb', 'something'])

    @internationalizeDocstring
    def listkeys(self, irc, msg, args, channel, search):
        """[<channel>] <text>

        Lists the keys of the factoids whose key contains the provided text.
        <channel> is only necessary if the message isn't sent in the channel
        itself.
        """
        results = self.db.getKeysByGlob(channel, search)
        if not results:
            irc.reply(format(_('No keys matching %q found.'), search))
        elif len(results) == 1 and \
             self.registryValue('showFactoidIfOnlyOneMatch', channel):
            key = results[0][0]
            self.invalidCommand(irc, msg, [key])
        else:
            keys = [format('%q', tup[0]) for tup in results]
            s = format(_('Key search for %q (%i found): %L'),
                       search, len(keys), keys)
            irc.reply(s)
    listkeys = wrap(listkeys, ['channeldb', 'text'])

    @internationalizeDocstring
    def listvalues(self, irc, msg, args, channel, search):
        """[<channel>] <text>

        Lists the keys of the factoids whose value contains the provided text.
        <channel> is only necessary if the message isn't sent in the channel
        itself.
        """
        results = self.db.getKeysByValueGlob(channel, search)
        if not results:
            irc.reply(format(_('No values matching %q found.'), search))
            return
        keys = [format('%q', tup[0]) for tup in results]
        s = format(_('Value search for %q (%i found): %L'),
                   search, len(keys), keys)
        irc.reply(s)
    listvalues = wrap(listvalues, ['channeldb', 'text'])

    @internationalizeDocstring
    def remove(self, irc, msg, args, channel, _, key):
        """[<channel>] <factoid key>

        Deletes the factoid with the given key.  <channel> is only necessary
        if the message isn't sent in the channel itself.
        """
        _ = self._getFactoid(irc, channel, key)
        self._checkNotLocked(irc, channel, key)
        self.db.removeFactoid(channel, key)
        irc.replySuccess()
    remove = wrap(remove, ['channeldb', 'user', 'text'])

    @internationalizeDocstring
    def random(self, irc, msg, args, channel):
        """[<channel>]

        Displays a random factoid (along with its key) from the database.
        <channel> is only necessary if the message isn't sent in the channel
        itself.
        """
        results = self.db.randomFactoid(channel)
        if not results:
            irc.error(_('No factoids in the database.'))
            return
        (fact, key) = results
        irc.reply(format('Random factoid: %q is %q', key, fact))
    random = wrap(random, ['channeldb'])
MoobotFactoids = internationalizeDocstring(MoobotFactoids)

Class = MoobotFactoids


# vim:set shiftwidth=4 softtabstop=8 expandtab textwidth=78:

########NEW FILE########
__FILENAME__ = test
# -*- encoding: utf-8 -*-
###
# Copyright (c) 2003-2005, Daniel DiPaolo
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import time

from supybot.test import *
#import supybot.plugin as plugin
import supybot.ircutils as ircutils

try:
    import sqlite
except ImportError:
    sqlite = None

import plugin
MFconf = conf.supybot.plugins.MoobotFactoids

class OptionListTestCase(SupyTestCase):
    maxIterations = 267
    def _testOptions(self, s, L):
        max = self.maxIterations
        original = L[:]
        while max and L:
            max -= 1
            option = plugin.pickOptions(s)
            self.failUnless(option in original,
                            'Option %s not in %s' % (option, original))
            if option in L:
                L.remove(option)
        self.failIf(L, 'Some options never seen: %s' % L)

    def testPickOptions(self):
        self._testOptions('(a|b)', ['a', 'b'])
        self._testOptions('a', ['a'])
        self._testOptions('(a|b (c|d))', ['a', 'b c', 'b d'])
        self._testOptions('(a|(b|)c)', ['a', 'bc', 'c'])
        self._testOptions('(a(b|)|(c|)d)', ['a', 'ab', 'cd', 'd'])
        self._testOptions('(a|)', ['a', ''])
        self._testOptions('(|a)', ['a', ''])
        self._testOptions('((a)|(b))', ['(a)', '(b)'])
        self._testOptions('^\\%(\\%(foo\\)\\@<!.\\)*$',
                          ['^\\%(\\%(foo\\)\\@<!.\\)*$'])

class FactoidsTestCase(ChannelPluginTestCase):
    plugins = ('MoobotFactoids', 'User', 'String', 'Utilities', 'Web')
    config = {'reply.whenNotCommand': False}
    def setUp(self):
        ChannelPluginTestCase.setUp(self)
        # Create a valid user to use
        self.prefix = 'mf!bar@baz'
        self.irc.feedMsg(ircmsgs.privmsg(self.nick, 'register tester moo',
                                         prefix=self.prefix))
        m = self.irc.takeMsg() # Response to register.

    def testAddFactoid(self):
        self.assertNotError('moo is foo')
        # Check stripping punctuation
        self.assertError('moo!?    is foo') # 'moo' already exists
        self.assertNotError('foo!?    is foo')
        self.assertResponse('foo', 'foo is foo')
        self.assertNotError('bar is <reply>moo is moo')
        self.assertResponse('bar', 'moo is moo')
        # Check substitution
        self.assertNotError('who is <reply>$who')
        self.assertResponse('who', ircutils.nickFromHostmask(self.prefix))
        # Check that actions ("\x01ACTION...") don't match
        m = ircmsgs.action(self.channel, 'is doing something')
        self.irc.feedMsg(m)
        self.assertNoResponse(' ', 1)

    def testLiteral(self):
        self.assertError('literal moo') # no factoids yet
        self.assertNotError('moo is <reply>foo')
        self.assertResponse('literal moo', '<reply>foo')
        self.assertNotError('moo2 is moo!')
        self.assertResponse('literal moo2', 'moo!')
        self.assertNotError('moo3 is <action>foo')
        self.assertResponse('literal moo3', '<action>foo')

    def testGetFactoid(self):
        self.assertNotError('moo is <reply>foo')
        self.assertResponse('moo', 'foo')
        self.assertNotError('moo2 is moo!')
        self.assertResponse('moo2', 'moo2 is moo!')
        self.assertNotError('moo3 is <action>foo')
        self.assertAction('moo3', 'foo')
        # Test and make sure it's parsing
        self.assertNotError('moo4 is <reply>(1|2|3)')
        self.assertRegexp('moo4', '^(1|2|3)$')
        # Check case-insensitivity
        self.assertResponse('MOO', 'foo')
        self.assertResponse('mOo', 'foo')
        self.assertResponse('MoO', 'foo')
        # Check the "_is_" ability
        self.assertNotError('remove moo')
        self.assertNotError('moo _is_ <reply>foo')
        self.assertResponse('moo', 'foo')
        self.assertNotError('foo is bar _is_ baz')
        self.assertResponse('foo is bar', 'foo is bar is baz')

    def testFactinfo(self):
        self.assertNotError('moo is <reply>foo')
        self.assertRegexp('factinfo moo', '^moo: Created by tester on.*$')
        self.assertNotError('moo')
        self.assertRegexp('factinfo moo', self.prefix + '.*1 time')
        self.assertNotError('moo')
        self.assertRegexp('factinfo moo', self.prefix + '.*2 times')
        self.assertNotError('moo =~ s/foo/bar/')
        self.assertRegexp('factinfo moo',
                          '^moo: Created by tester on'
                          '.*?\. Last modified by tester on .*?\. '
                          'Last requested by %s on .*?, '
                          'requested 2 times.$' % self.prefix)
        self.assertNotError('lock moo')
        self.assertRegexp('factinfo moo',
                          '^moo: Created by tester on'
                          '.*?\. Last modified by tester on .*?\. '
                          'Last requested by %s on .*?, '
                          'requested 2 times. '
                          'Locked by tester on .*\.$' % self.prefix)
        self.assertNotError('unlock moo')
        self.assertRegexp('factinfo moo',
                          '^moo: Created by tester on'
                          '.*?\. Last modified by tester on .*?\. '
                          'Last requested by %s on .*?, '
                          'requested 2 times.$' % self.prefix)
        # Make sure I solved this bug
        # Check and make sure all the other stuff is reset
        self.assertNotError('foo is bar')
        self.assertNotError('foo =~ s/bar/blah/')
        self.assertNotError('foo')
        self.assertNotError('no foo is baz')
        self.assertRegexp('factinfo foo',
                          '^foo: Created by tester on'
                          '(?!(request|modif)).*?\.$')

    def testLockUnlock(self):
        # disable world.testing since we want new users to not
        # magically be endowed with the admin capability
        try:
            world.testing = False
            self.assertNotError('moo is <reply>moo')
            self.assertNotError('lock moo')
            self.assertRegexp('factinfo moo',
                              '^moo: Created by tester on'
                              '.*?\. Locked by tester on .*?\.')
            # switch user
            original = self.prefix
            self.prefix = 'moo!moo@moo'
            self.assertNotError('register nottester moo', private=True)
            self.assertError('unlock moo')
            self.assertRegexp('factinfo moo',
                              '^moo: Created by tester on'
                              '.*?\. Locked by tester on .*?\.')
            # switch back
            self.prefix = original
            self.assertNotError('identify tester moo', private=True)
            self.assertNotError('unlock moo')
            self.assertRegexp('factinfo moo',
                              '^moo: Created by tester on.*?\.')
        finally:
            world.testing = True

    def testChangeFactoid(self):
        self.assertNotError('moo is <reply>moo')
        self.assertNotError('moo =~ s/moo/moos/')
        self.assertResponse('moo', 'moos')
        self.assertNotError('moo =~ s/reply/action/')
        self.assertAction('moo', 'moos')
        self.assertNotError('moo =~ s/moos/(moos|woofs)/')
        self.assertActionRegexp('moo', '^(moos|woofs)$')
        self.assertError('moo =~ s/moo/')

    def testMost(self):
        userPrefix1 = 'moo!bar@baz'; userNick1 = 'moo'
        userPrefix2 = 'boo!bar@baz'; userNick2 = 'boo'
        self.assertNotError('register %s bar' % userNick1,
                            frm=userPrefix1, private=True)
        self.assertNotError('register %s bar' % userNick2,
                            frm=userPrefix2, private=True)
        # Check an empty database
        self.assertError('most popular')
        self.assertError('most authored')
        self.assertError('most recent')
        # Check singularity response
        self.prefix = userPrefix1
        self.assertNotError('moogle is <reply>moo')
        self.assertError('most popular')
        self.assertResponse('most authored',
                            'Most prolific author: moo (1)')
        self.assertRegexp('most recent', "1 latest factoid:.*moogle")
        self.assertResponse('moogle', 'moo')
        self.assertRegexp('most popular',
                            "Top 1 requested factoid:.*moogle.*(1)")
        # Check plural response
        time.sleep(1)
        self.prefix = userPrefix2
        self.assertNotError('mogle is <reply>mo')
        self.assertRegexp('most authored',
                            'Most prolific authors:.*moo.*(1).*boo.*(1)')
        self.assertRegexp('most recent',
                            "2 latest factoids:.*mogle.*moogle.*")
        self.assertResponse('moogle', 'moo')
        self.assertRegexp('most popular',
                            "Top 1 requested factoid:.*moogle.*(2)")
        self.assertResponse('mogle', 'mo')
        self.assertRegexp('most popular',
                            "Top 2 requested factoids:.*"
                            "moogle.*(2).*mogle.*(1)")
        # Check most author ordering
        self.assertNotError('moo is <reply>oom')
        self.assertRegexp('most authored',
                            'Most prolific authors:.*boo.*(2).*moo.*(1)')

    def testListkeys(self):
        self.assertResponse('listkeys %', 'No keys matching "%" found.')
        self.assertNotError('moo is <reply>moo')
        # With this set, if only one key matches, it should respond with
        # the factoid
        orig = MFconf.showFactoidIfOnlyOneMatch()
        try:
            MFconf.showFactoidIfOnlyOneMatch.setValue(True)
            self.assertResponse('listkeys moo', 'moo')
            self.assertResponse('listkeys foo', 'No keys matching "foo" '
                                'found.')
            # Throw in a bunch more
            for i in range(10):
                self.assertNotError('moo%s is <reply>moo' % i)
            self.assertRegexp('listkeys moo',
                              '^Key search for "moo" '
                              '\(11 found\): ("moo\d*", )+and "moo9"$')
            self.assertNotError('foo is bar')
            self.assertRegexp('listkeys %',
                              '^Key search for "\%" '
                              '\(12 found\): "foo", ("moo\d*", )+and '
                              '"moo9"$')
            # Check quoting
            self.assertNotError('foo\' is bar')
            self.assertResponse('listkeys foo',
                                'Key search for "foo" '
                                '(2 found): "foo" and "foo\'"')
            # Check unicode stuff
            self.assertResponse(u'listkeys Б', 'No keys matching "Б" found.')
            self.assertNotError(u'АБВГДЕЖ is foo')
            self.assertNotError(u'АБВГДЕЖЗИ is foo')
            self.assertResponse(u'listkeys Б',
                                'Key search for "Б" '
                                '(2 found): "АБВГДЕЖ" and "АБВГДЕЖЗИ"')
        finally:
            MFconf.showFactoidIfOnlyOneMatch.setValue(orig)

    def testListvalues(self):
        self.assertNotError('moo is moo')
        self.assertResponse('listvalues moo',
                            'Value search for "moo" (1 found): "moo"')

    def testListauth(self):
        self.assertNotError('moo is <reply>moo')
        self.assertRegexp('listauth tester', 'tester.*\(1 found\):.*moo')
        self.assertError('listauth moo')

    def testRemove(self):
        self.assertNotError('moo is <reply>moo')
        self.assertNotError('lock moo')
        self.assertError('remove moo')
        self.assertNotError('unlock moo')
        self.assertNotError('remove moo')

    def testAugmentFactoid(self):
        self.assertNotError('moo is foo')
        self.assertNotError('moo is also bar')
        self.assertResponse('moo', 'moo is foo, or bar')
        self.assertNotError('moo is bar _is_ foo')
        self.assertNotError('moo is bar is also foo')
        self.assertResponse('moo is bar', 'moo is bar is foo, or foo')

    def testReplaceFactoid(self):
        self.assertNotError('moo is foo')
        self.assertNotError('no moo is bar')
        self.assertResponse('moo', 'moo is bar')
        self.assertNotError('no, moo is baz')
        self.assertResponse('moo', 'moo is baz')
        self.assertNotError('lock moo')
        self.assertError('no moo is qux')
        self.assertNotError('foo is bar _is_ foo')
        self.assertNotError('no foo is bar _is_ baz')
        self.assertResponse('foo is bar', 'foo is bar is baz')

    def testRegexpNotCalledIfAlreadyHandled(self):
        self.assertResponse('echo foo is bar', 'foo is bar')
        self.assertNoResponse(' ', 3)

    def testNoResponseToCtcp(self):
        self.assertNotError('foo is bar')
        self.assertResponse('foo', 'foo is bar')
        self.irc.feedMsg(ircmsgs.privmsg(self.irc.nick, '\x01VERSION\x01'))
        m = self.irc.takeMsg()
        self.failIf(m)

    def testAddFactoidNotCalledWithBadNestingSyntax(self):
        self.assertError('re s/Error:.*/jbm is a tard/ ]')
        self.assertNoResponse(' ', 3)

    def testConfigShowFactoidIfOnlyOneMatch(self):
        # these are long
        MFconf = conf.supybot.plugins.MoobotFactoids
        self.assertNotError('foo is bar')
        # Default to saying the factoid value
        self.assertResponse('listkeys foo', 'foo is bar')
        # Check the False setting
        MFconf.showFactoidIfOnlyOneMatch.setValue(False)
        self.assertResponse('listkeys foo', 'Key search for "foo" '
                                            '(1 found): "foo"')

    def testRandom(self):
        self.assertNotError('foo is <reply>bar')
        self.assertNotError('bar is <reply>baz')
        self.assertRegexp('random', r'bar|baz')


# vim:set shiftwidth=4 softtabstop=8 expandtab textwidth=78:

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2004, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Network')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Network', True)


Network = conf.registerPlugin('Network')
# This is where your configuration variables (if any) should go.  For example:
# conf.registerGlobalValue(Network, 'someConfigVariableName',
#     registry.Boolean(False, """Help for someConfigVariableName."""))


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2002-2004, Jeremiah Fincher
# Copyright (c) 2010, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import time
import functools

import supybot.conf as conf
import supybot.utils as utils
import supybot.world as world
from supybot.commands import *
import supybot.ircmsgs as ircmsgs
import supybot.ircutils as ircutils
import supybot.registry as registry
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Network')

class Network(callbacks.Plugin):
    _whois = {}
    _latency = {}
    def _getIrc(self, network):
        irc = world.getIrc(network)
        if irc:
            return irc
        else:
            raise callbacks.Error('I\'m not currently connected to %s.' % network)

    @internationalizeDocstring
    def connect(self, irc, msg, args, opts, network, server, password):
        """[--ssl] <network> [<host[:port]>] [<password>]

        Connects to another network (which will be represented by the name
        provided in <network>) at <host:port>.  If port is not provided, it
        defaults to 6667, the default port for IRC.  If password is
        provided, it will be sent to the server in a PASS command.  If --ssl is
        provided, an SSL connection will be attempted.
        """
        try:
            otherIrc = self._getIrc(network)
            irc.error(_('I\'m already connected to %s.') % network)
            return # We've gotta return here.  This is ugly code, but I'm not
                   # quite sure what to do about it.
        except callbacks.Error:
            pass
        ssl = False
        for (opt, arg) in opts:
            if opt == 'ssl':
                ssl = True
        if server:
            if ':' in server:
                (server, port) = server.split(':')
                port = int(port)
            else:
                port = 6667
            serverPort = (server, port)
        else:
            try:
                serverPort = conf.supybot.networks.get(network).servers()[0]
            except (registry.NonExistentRegistryEntry, IndexError):
                irc.error(_('A server must be provided if the network is not '
                          'already registered.'))
                return
        Owner = irc.getCallback('Owner')
        newIrc = Owner._connect(network, serverPort=serverPort,
                                password=password, ssl=ssl)
        conf.supybot.networks().add(network)
        assert newIrc.callbacks is irc.callbacks, 'callbacks list is different'
        irc.replySuccess(_('Connection to %s initiated.') % network)
    connect = wrap(connect, ['owner', getopts({'ssl': ''}), 'something',
                             additional('something'),
                             additional('something', '')])

    @internationalizeDocstring
    def disconnect(self, irc, msg, args, otherIrc, quitMsg):
        """[<network>] [<quit message>]

        Disconnects from the network represented by the network <network>.
        If <quit message> is given, quits the network with the given quit
        message.  <network> is only necessary if the network is different
        from the network the command is sent on.
        """
        quitMsg = quitMsg or conf.supybot.plugins.Owner.quitMsg() or msg.nick
        otherIrc.queueMsg(ircmsgs.quit(quitMsg))
        otherIrc.die()
        conf.supybot.networks().discard(otherIrc.network)
        if otherIrc != irc:
            irc.replySuccess(_('Disconnection to %s initiated.') %
                             otherIrc.network)
    disconnect = wrap(disconnect, ['owner', 'networkIrc', additional('text')])

    @internationalizeDocstring
    def reconnect(self, irc, msg, args, otherIrc, quitMsg):
        """[<network>] [<quit message>]

        Disconnects and then reconnects to <network>.  If no network is given,
        disconnects and then reconnects to the network the command was given
        on.  If no quit message is given, uses the configured one
        (supybot.plugins.Owner.quitMsg) or the nick of the person giving the
        command.
        """
        quitMsg = quitMsg or conf.supybot.plugins.Owner.quitMsg() or msg.nick
        otherIrc.queueMsg(ircmsgs.quit(quitMsg))
        if otherIrc != irc:
            # No need to reply if we're reconnecting ourselves.
            irc.replySuccess()
    reconnect = wrap(reconnect, ['owner', 'networkIrc', additional('text')])

    @internationalizeDocstring
    def command(self, irc, msg, args, otherIrc, commandAndArgs):
        """<network> <command> [<arg> ...]

        Gives the bot <command> (with its associated <arg>s) on <network>.
        """
        self.Proxy(otherIrc, msg, commandAndArgs)
    command = wrap(command, ['admin', ('networkIrc', True), many('something')])
    
    def cmdall(self, irc, msg, args, commandAndArgs):
        """<command> <args>...
        
        Perform <command> (with its associated <arg>s) on all networks.
        """
        ircs = world.ircs
        for ircd in ircs:
            self.Proxy(ircd, msg, commandAndArgs)
    cmdall = wrap(cmdall, ['admin', many('something')])
    
    ###
    # whois command-related stuff.
    ###
    def do311(self, irc, msg):
        nick = ircutils.toLower(msg.args[1])
        if (irc, nick) not in self._whois:
            return
        else:
            self._whois[(irc, nick)][2][msg.command] = msg

    # These are all sent by a WHOIS response.
    do301 = do311
    do312 = do311
    do314 = do311
    do317 = do311
    do319 = do311
    do320 = do311

    def do318(self, irc, msg):
        nick = msg.args[1]
        loweredNick = ircutils.toLower(nick)
        if (irc, loweredNick) not in self._whois:
            return
        (replyIrc, replyMsg, d, command) = self._whois[(irc, loweredNick)]
        START_CODE = '311' if command == 'whois' else '314'
        hostmask = '@'.join(d[START_CODE].args[2:4])
        user = d[START_CODE].args[-1]
        if '319' in d:
            channels = d['319'].args[-1].split()
            ops = []
            voices = []
            normal = []
            halfops = []
            for channel in channels:
                origchan = channel
                channel = channel.lstrip('@%+~!')
                # UnrealIRCd uses & for user modes and disallows it as a
                # channel-prefix, flying in the face of the RFC.  Have to
                # handle this specially when processing WHOIS response.
                testchan = channel.lstrip('&')
                if testchan != channel and irc.isChannel(testchan):
                    channel = testchan
                diff = len(channel) - len(origchan)
                modes = origchan[:diff]
                chan = irc.state.channels.get(channel)
                # The user is in a channel the bot is in, so the ircd may have
                # responded with otherwise private data.
                if chan:
                    # Skip channels the callee isn't in.  This helps prevents
                    # us leaking information when the channel is +s or the
                    # target is +i
                    if replyMsg.nick not in chan.users:
                        continue
                    # Skip +s channels the target is in only if the reply isn't
                    # being sent to that channel
                    if 's' in chan.modes and \
                       not ircutils.strEqual(replyMsg.args[0], channel):
                        continue
                if not modes:
                    normal.append(channel)
                elif utils.iter.any(lambda c: c in modes,('@', '&', '~', '!')):
                    ops.append(channel)
                elif utils.iter.any(lambda c: c in modes, ('%',)):
                    halfops.append(channel)
                elif utils.iter.any(lambda c: c in modes, ('+',)):
                    voices.append(channel)
            L = []
            if ops:
                L.append(format(_('is an op on %L'), ops))
            if halfops:
                L.append(format(_('is a halfop on %L'), halfops))
            if voices:
                L.append(format(_('is voiced on %L'), voices))
            if normal:
                if L:
                    L.append(format(_('is also on %L'), normal))
                else:
                    L.append(format(_('is on %L'), normal))
        else:
            if command == 'whois':
                L = [_('isn\'t on any non-secret channels')]
            else:
                L = []
        channels = format('%L', L)
        if '317' in d:
            idle = utils.timeElapsed(d['317'].args[2])
            signon = time.strftime(conf.supybot.reply.format.time(),
                                   time.localtime(float(d['317'].args[3])))
        else:
            idle = _('<unknown>')
            signon = _('<unknown>')
        if '312' in d:
            server = d['312'].args[2]
            if len(d['312']) > 3:
                signoff = d['312'].args[3]
        else:
            server = _('<unknown>')
        if '301' in d:
            away = '  %s is away: %s.' % (nick, d['301'].args[2])
        else:
            away = ''
        if '320' in d:
            if d['320'].args[2]:
                identify = _(' identified')
            else:
                identify = ''
        else:
            identify = ''
        if command == 'whois':
            s = _('%s (%s) has been%s on server %s since %s (idle for %s) and '
                '%s.%s') % (user, hostmask, identify, server,
                        signon, idle, channels, away)
        else:
            s = _('%s (%s) has been%s on server %s and disconnect on %s.') % \
                    (user, hostmask, identify, server, signoff)
        replyIrc.reply(s)
        del self._whois[(irc, loweredNick)]
    do369 = do318

    def do402(self, irc, msg):
        nick = msg.args[1]
        loweredNick = ircutils.toLower(nick)
        if (irc, loweredNick) not in self._whois:
            return
        (replyIrc, replyMsg, d, command) = self._whois[(irc, loweredNick)]
        del self._whois[(irc, loweredNick)]
        if command == 'whois':
            template = _('There is no %s on %s.')
        else:
            template = _('There was no %s on %s.')
        s = template  % (nick, irc.network)
        replyIrc.reply(s)
    do401 = do402
    do406 = do402

    @internationalizeDocstring
    def whois(self, irc, msg, args, otherIrc, nick):
        """[<network>] <nick>

        Returns the WHOIS response <network> gives for <nick>.  <network> is
        only necessary if the network is different than the network the command
        is sent on.
        """
        # The double nick here is necessary because single-nick WHOIS only works
        # if the nick is on the same server (*not* the same network) as the user
        # giving the command.  Yeah, it made me say wtf too.
        nick = ircutils.toLower(nick)
        otherIrc.queueMsg(ircmsgs.whois(nick, nick))
        self._whois[(otherIrc, nick)] = (irc, msg, {}, 'whois')
    whois = wrap(whois, ['networkIrc', 'nick'])

    @internationalizeDocstring
    def whowas(self, irc, msg, args, otherIrc, nick):
        """[<network>] <nick>

        Returns the WHOIS response <network> gives for <nick>.  <network> is
        only necessary if the network is different than the network the command
        is sent on.
        """
        # The double nick here is necessary because single-nick WHOIS only works
        # if the nick is on the same server (*not* the same network) as the user
        # giving the command.  Yeah, it made me say wtf too.
        nick = ircutils.toLower(nick)
        otherIrc.queueMsg(ircmsgs.whowas(nick, nick))
        self._whois[(otherIrc, nick)] = (irc, msg, {}, 'whowas')
    whowas = wrap(whowas, ['networkIrc', 'nick'])

    @internationalizeDocstring
    def networks(self, irc, msg, args):
        """takes no arguments

        Returns the networks to which the bot is currently connected.
        """
        L = ['%s: %s' % (ircd.network, ircd.server) for ircd in world.ircs]
        utils.sortBy(str.lower, L)
        irc.reply(format('%L', L))
    networks = wrap(networks)

    def doPong(self, irc, msg):
        now = time.time()
        if irc in self._latency:
            (replyIrc, when) = self._latency.pop(irc)
            replyIrc.reply(_('%.2f seconds.') % (now-when))

    @internationalizeDocstring
    def latency(self, irc, msg, args, otherIrc):
        """[<network>]

        Returns the current latency to <network>.  <network> is only necessary
        if the message isn't sent on the network to which this command is to
        apply.
        """
        otherIrc.queueMsg(ircmsgs.ping(_('Latency check (from %s).') %
                                       msg.nick))
        self._latency[otherIrc] = (irc, time.time())
        irc.noReply()
    latency = wrap(latency, ['networkIrc'])

    @internationalizeDocstring
    def driver(self, irc, msg, args, otherIrc):
        """[<network>]

        Returns the current network driver for <network>.  <network> is only
        necessary if the message isn't sent on the network to which this
        command is to apply.
        """
        irc.reply(otherIrc.driver.__class__.__module__[8:])
    driver = wrap(driver, ['networkIrc'])

    @internationalizeDocstring
    def uptime(self, irc, msg, args, otherIrc):
        """[<network>]
        
        Returns the time duration since the connection was established.
        """
        network = otherIrc.network
        now = time.time()
        started = otherIrc.startedAt
        irc.reply(_("I've been connected to %s for %s.") %
                            (network, utils.timeElapsed(now - started)))
    uptime = wrap(uptime, ['networkIrc'])

Class = Network

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

class NetworkTestCase(PluginTestCase):
    plugins = ['Network', 'Utilities']
    def testNetworks(self):
        self.assertNotError('networks')

    def testCommand(self):
        self.assertResponse('network command %s echo 1' % self.irc.network,
                            '1')


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:


########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2003-2005, Daniel DiPaolo
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('News')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('News', True)


News = conf.registerPlugin('News')
# This is where your configuration variables (if any) should go.  For example:
# conf.registerGlobalValue(News, 'someConfigVariableName',
#     registry.Boolean(False, _("""Help for someConfigVariableName.""")))


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2003-2005, Daniel DiPaolo
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import time

import supybot.dbi as dbi
import supybot.conf as conf
import supybot.utils as utils
from supybot.commands import *
import supybot.plugins as plugins
import supybot.ircutils as ircutils
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('News')


class DbiNewsDB(plugins.DbiChannelDB):
    class DB(dbi.DB):
        class Record(dbi.Record):
            __fields__ = [
                'subject',
                'text',
                'at',
                'expires',
                'by',
                ]

            def __str__(self):
                user = plugins.getUserName(self.by)
                if self.expires == 0:
                    s = format(_('%s (Subject: %q, added by %s on %s)'),
                               self.text, self.subject, self.by,
                               utils.str.timestamp(self.at))
                else:
                    s = format(_('%s (Subject: %q, added by %s on %s, '
                               'expires at %s)'),
                               self.text, self.subject, user,
                               utils.str.timestamp(self.at),
                               utils.str.timestamp(self.expires))
                return s

        def __init__(self, filename):
            # We use self.__class__ here because apparently DB isn't in our
            # scope.  python--
            self.__parent = super(self.__class__, self)
            self.__parent.__init__(filename)

        def add(self, subject, text, at, expires, by):
            return self.__parent.add(self.Record(at=at, by=by, text=text,
                                     subject=subject, expires=expires))

        def getOld(self, id=None):
            now = time.time()
            if id:
                return self.get(id)
            else:
                L = [R for R in self if R.expires < now and R.expires != 0]
                if not L:
                    raise dbi.NoRecordError
                else:
                    return L

        def get(self, id=None):
            now = time.time()
            if id:
                return self.__parent.get(id)
            else:
                L = [R for R in self if R.expires >= now or R.expires == 0]
                if not L:
                    raise dbi.NoRecordError
                return L

        def change(self, id, f):
            news = self.get(id)
            s = '%s: %s' % (news.subject, news.text)
            s = f(s)
            (news.subject, news.text) = s.split(': ', 1)
            self.set(id, news)

NewsDB = plugins.DB('News', {'flat': DbiNewsDB})

class News(callbacks.Plugin):
    def __init__(self, irc):
        self.__parent = super(News, self)
        self.__parent.__init__(irc)
        self.db = NewsDB()

    def die(self):
        self.__parent.die()
        self.db.close()

    @internationalizeDocstring
    def add(self, irc, msg, args, channel, user, at, expires, news):
        """[<channel>] <expires> <subject>: <text>

        Adds a given news item of <text> to a channel with the given <subject>.
        If <expires> isn't 0, that news item will expire <expires> seconds from
        now.  <channel> is only necessary if the message isn't sent in the
        channel itself.
        """
        try:
            (subject, text) = news.split(': ', 1)
        except ValueError:
            raise callbacks.ArgumentError
        id = self.db.add(channel, subject, text, at, expires, user.id)
        irc.replySuccess(format(_('(News item #%i added)'), id))
    add = wrap(add, ['channeldb', 'user', 'now', 'expiry', 'text'])

    @internationalizeDocstring
    def news(self, irc, msg, args, channel, id):
        """[<channel>] [<id>]

        Display the news items for <channel> in the format of '(#id) subject'.
        If <id> is given, retrieve only that news item; otherwise retrieve all
        news items.  <channel> is only necessary if the message isn't sent in
        the channel itself.
        """
        if not id:
            try:
                records = self.db.get(channel)
                items = [format('(#%i) %s', R.id, R.subject) for R in records]
                s = format(_('News for %s: %s'), channel, '; '.join(items))
                irc.reply(s)
            except dbi.NoRecordError:
                irc.reply(format(_('No news for %s.'), channel))
        else:
            try:
                record = self.db.get(channel, id)
                irc.reply(str(record))
            except dbi.NoRecordError as id:
                irc.errorInvalid(_('news item id'), id)
    news = wrap(news, ['channeldb', additional('positiveInt')])

    @internationalizeDocstring
    def remove(self, irc, msg, args, channel, id):
        """[<channel>] <id>

        Removes the news item with <id> from <channel>.  <channel> is only
        necessary if the message isn't sent in the channel itself.
        """
        try:
            self.db.remove(channel, id)
            irc.replySuccess()
        except dbi.NoRecordError:
            irc.errorInvalid(_('news item id'), id)
    remove = wrap(remove, ['channeldb', 'positiveInt'])

    @internationalizeDocstring
    def change(self, irc, msg, args, channel, id, replacer):
        """[<channel>] <id> <regexp>

        Changes the news item with <id> from <channel> according to the
        regular expression <regexp>.  <regexp> should be of the form
        s/text/replacement/flags.  <channel> is only necessary if the message
        isn't sent on the channel itself.
        """
        try:
            self.db.change(channel, id, replacer)
            irc.replySuccess()
        except dbi.NoRecordError:
            irc.errorInvalid(_('news item id'), id)
    change = wrap(change, ['channeldb', 'positiveInt', 'regexpReplacer'])

    @internationalizeDocstring
    def old(self, irc, msg, args, channel, id):
        """[<channel>] [<id>]

        Returns the old news item for <channel> with <id>.  If no number is
        given, returns all the old news items in reverse order.  <channel> is
        only necessary if the message isn't sent in the channel itself.
        """
        if id:
            try:
                record = self.db.getOld(channel, id)
                irc.reply(str(record))
            except dbi.NoRecordError as id:
                irc.errorInvalid(_('news item id'), id)
        else:
            try:
                records = self.db.getOld(channel)
                items = [format('(#%i) %s', R.id, R.subject) for R in records]
                s = format(_('Old news for %s: %s'), channel, '; '.join(items))
                irc.reply(s)
            except dbi.NoRecordError:
                irc.reply(format(_('No old news for %s.'), channel))
    old = wrap(old, ['channeldb', additional('positiveInt')])


Class = News


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2003-2005, Daniel DiPaolo
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import time

from supybot.test import *

class NewsTestCase(ChannelPluginTestCase):
    plugins = ('News','User')
    def setUp(self):
        ChannelPluginTestCase.setUp(self)
        # Create a valid user to use
        self.prefix = 'news!bar@baz'
        self.irc.feedMsg(ircmsgs.privmsg(self.nick, 'register tester moo',
                                         prefix=self.prefix))
        m = self.irc.takeMsg() # Response to register.

    def testAddnews(self):
        self.assertNotError('add 0 subject: foo')
        self.assertRegexp('news', 'subject')
        self.assertNotError('add 0 subject2: foo2')
        self.assertRegexp('news', 'subject.*subject2')
        self.assertNotError('add 5 subject3: foo3')
        self.assertRegexp('news', 'subject3')
        print()
        print('Sleeping to expire the news item (testAddnews)')
        time.sleep(6)
        print('Done sleeping.')
        self.assertNotRegexp('news', 'subject3')

    def testNews(self):
        # These should both fail first, as they will have nothing in the DB
        self.assertRegexp('news', 'no news')
        self.assertRegexp('news #channel', 'no news')
        # Now we'll add news and make sure listnews doesn't fail
        self.assertNotError('add #channel 0 subject: foo')
        self.assertNotError('news #channel')
        self.assertNotError('add 0 subject: foo')
        self.assertRegexp('news', '#1')
        self.assertNotError('news 1')

    def testChangenews(self):
        self.assertNotError('add 0 Foo: bar')
        self.assertNotError('change 1 s/bar/baz/')
        self.assertNotRegexp('news 1', 'bar')
        self.assertRegexp('news 1', 'baz')

    def testOldnews(self):
        self.assertRegexp('old', 'No old news')
        self.assertNotError('add 0 a: b')
        self.assertRegexp('old', 'No old news')
        self.assertNotError('add 5 foo: bar')
        self.assertRegexp('old', 'No old news')
        print()
        print('Sleeping to expire the news item (testOldnews)')
        time.sleep(6)
        print('Done sleeping.')
        self.assertNotError('old')


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2012, Valentin Lorentz
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring

_ = PluginInternationalization('NickAuth')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('NickAuth', True)


NickAuth = conf.registerPlugin('NickAuth')
# This is where your configuration variables (if any) should go.  For example:
# conf.registerGlobalValue(NickAuth, 'someConfigVariableName',
#     registry.Boolean(False, _("""Help for someConfigVariableName.""")))


# vim:set shiftwidth=4 tabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2012, Valentin Lorentz
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

###

import time

import supybot.conf as conf
import supybot.utils as utils
import supybot.ircdb as ircdb
from supybot.commands import *
import supybot.ircmsgs as ircmsgs
import supybot.plugins as plugins
import supybot.ircutils as ircutils
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring

_ = PluginInternationalization('NickAuth')

@internationalizeDocstring
class NickAuth(callbacks.Plugin):
    """Support authentication based on nicks and network services."""
    def __init__(self, irc):
        super(NickAuth, self).__init__(irc)
        self._requests = {}
    class nick(callbacks.Commands):
        def _check_auth(self, irc, msg, user):
            if user is None:
                irc.error(_('You are not authenticated.'), Raise=True)
            if not user.checkHostmask(msg.prefix):
                try:
                    u = ircdb.users.getUser(msg.prefix)
                except KeyError:
                    irc.error(_('You are not authenticated.'),
                              Raise=True)
                if not u._checkCapability('owner'):
                    irc.error(_('You must be owner to do that.'),
                              Raise=True)

        @internationalizeDocstring
        def add(self, irc, msg, args, network, user, nick):
            """[<network>] <user> <nick>

            Add <nick> to the list of nicks owned by the <user> on the
            <network>. You have to register this nick to the network
            services to be authenticated.
            <network> defaults to the current network.
            """
            network = network.network or irc.network
            user = user or ircdb.users.getUser(msg.prefix)
            self._check_auth(irc, msg, user)
            try:
                user.addNick(network, nick)
            except KeyError:
                irc.error(_('This nick is already used by someone on this '
                    'network.'), Raise=True)
            irc.replySuccess()
        add = wrap(add, [optional('networkIrc'),
                         optional('otherUser'),
                         'nick'])

        @internationalizeDocstring
        def remove(self, irc, msg, args, network, user, nick):
            """[<network>] <user> <nick>

            Remove <nick> from the list of nicks owned by the <user> on the
            <network>.
            <network> defaults to the current network.
            """
            network = network.network or irc.network
            user = user or ircdb.users.getUser(msg.prefix)
            self._check_auth(irc, msg, user)
            try:
                user.removeNick(network, nick)
            except KeyError:
                irc.error(_('This nick is not registered to you on this '
                    'network.'), Raise=True)
            irc.replySuccess()
        remove = wrap(remove, [optional('networkIrc'),
                               optional('otherUser'),
                               'nick'])

        @internationalizeDocstring
        def list(self, irc, msg, args, network, user):
            """[<network>] [<user>]

            Lists nicks of the <user> on the network.
            <network> defaults to the current network.
            """
            network = network.network or irc.network
            try:
                user = user or ircdb.users.getUser(msg.prefix)
            except KeyError:
                irc.error(_('You are not identified and <user> is not given.'),
                        Raise=True)
            self._check_auth(irc, msg, user)
            try:
                list_ = user.nicks[network]
                if list_:
                    irc.reply(format('%L', list_))
                else:
                    raise KeyError
            except KeyError:
                irc.error(_('You have no recognized nick on this '
                        'network.'), Raise=True)
        list = wrap(list, [optional('networkIrc'),
                           optional('otherUser')])

    @internationalizeDocstring
    def auth(self, irc, msg, args):
        """takes no argument

        Tries to authenticate you using network services.
        If you get no reply, it means you are not authenticated to the
        network services."""
        nick = ircutils.toLower(msg.nick)
        self._requests[(irc.network, msg.nick)] = (time.time(), msg.prefix, irc)
        irc.queueMsg(ircmsgs.whois(nick, nick))
    auth = wrap(auth, [])

    def do330(self, irc, msg):
        mynick, theirnick, theiraccount, garbage = msg.args
        # I would like to use a dict comprehension, but we have to support
        # Python 2.6 :(
        self._requests = dict([(x,y) for x,y in self._requests.items()
                if y[0]+60>time.time()])
        try:
            (timestamp, prefix, irc) = self._requests.pop((irc.network, theirnick))
        except KeyError:
            return
        user = ircdb.users.getUserFromNick(irc.network, theiraccount)
        if not user:
            user = ircdb.users.getUserFromNick(irc.network, theirnick)
        if user:
            user.addAuth(prefix)
            ircdb.users.setUser(user, flush=False)
            irc.reply(_('You are now authenticated as %s.') % user.name)
        else:
            irc.error(_('No user has this nick on this network.'))


Class = NickAuth


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2012, Valentin Lorentz
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

###

import supybot.ircdb as ircdb
from supybot.test import *

class NickAuthTestCase(PluginTestCase):
    plugins = ('NickAuth', 'User')

    prefix1 = 'something!user@host.tld'
    def _procedure(self, nickserv_reply):
        self.assertNotError('register foobar 123')
        self.assertResponse('user list', 'foobar')
        self.assertNotError('hostmask remove foobar %s' % self.prefix)
        self.assertNotError('identify foobar 123')
        self.assertNotError('nick add foobar baz')
        self.assertNotError('unidentify')
        self.prefix = self.prefix1
        self.assertError('nick add foobar qux')
        self.nick = self.prefix.split('!')[0]

        self.assertError('hostmask list')
        self.irc.feedMsg(ircmsgs.privmsg(self.irc.nick,
                                         'auth',
                                         prefix=self.prefix))
        self.assertEqual(self.irc.takeMsg().command, 'WHOIS')
        self.assertError('hostmask list')

        self.irc.feedMsg(ircmsgs.privmsg(self.irc.nick,
                                         'auth',
                                         prefix=self.prefix))
        self.assertEqual(self.irc.takeMsg().command, 'WHOIS')
        if nickserv_reply:
            self.irc.feedMsg(ircmsgs.IrcMsg(':leguin.freenode.net 330 pgjrgrg '
                    '%s baz :is logged in as' % self.nick))
            msg = self.irc.takeMsg()
            self.assertNotEqual(msg, None)
            self.assertEqual(msg.args[1], 'You are now authenticated as foobar.')
            self.assertResponse('hostmask list',
                    'foobar has no registered hostmasks.')
        else:
            msg = self.irc.takeMsg()
            self.assertEqual(msg, None)
            self.assertError('hostmask list')

    def testAuth(self):
        self._procedure(True)
    def testNoAuth(self):
        self._procedure(False)

    def testList(self):
        self.assertNotError('register foobar 123')
        self.assertRegexp('nick list', 'You have no recognized nick')
        self.assertNotError('nick add foo')
        self.assertRegexp('nick list', 'foo')
        self.assertNotError('nick add %s bar' % self.nick)
        self.assertRegexp('nick list', 'foo and bar')
        self.assertNotError('nick add %s %s baz' % (self.irc.network, self.nick))
        self.assertRegexp('nick list', 'foo, bar, and baz')
        self.assertRegexp('nick list %s' % self.irc.network, 'foo, bar, and baz')
        self.assertRegexp('nick list %s foobar' % self.irc.network,
                'foo, bar, and baz')


# vim:set shiftwidth=4 tabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('NickCapture')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('NickCapture', True)


NickCapture = conf.registerPlugin('NickCapture')
conf.registerPlugin('NickCapture')
conf.registerGlobalValue(NickCapture, 'ison',
    registry.Boolean(True, _("""Determines whether the bot will check
    occasionally if its preferred nick is in use via the ISON command.""")))
conf.registerGlobalValue(NickCapture.ison, 'period',
    registry.PositiveInteger(600, _("""Determines how often (in seconds) the bot
    will check whether its nick ISON.""")))


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2004, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import time

import supybot.conf as conf
import supybot.ircmsgs as ircmsgs
import supybot.ircutils as ircutils
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('NickCapture')

class NickCapture(callbacks.Plugin):
    """This plugin constantly tries to take whatever nick is configured as
    supybot.nick.  Just make sure that's set appropriately, and thus plugin
    will do the rest."""
    public = False
    def __init__(self, irc):
        self.__parent = super(NickCapture, self)
        self.__parent.__init__(irc)
        self.lastIson = 0
        
    def _getNick(self, network):
        network_nick = conf.supybot.networks.get(network).nick()
        if network_nick == '':
            return conf.supybot.nick()
        else:
            return network_nick

    def __call__(self, irc, msg):
        if irc.afterConnect:
            nick = self._getNick(irc.network)
            if nick and not ircutils.strEqual(nick, irc.nick):
                # We used to check this, but nicksToHostmasks is never cleared
                # except on reconnects, which can cause trouble.
                # if nick not in irc.state.nicksToHostmasks:
                self._ison(irc, nick)
                self.__parent.__call__(irc, msg)

    def _ison(self, irc, nick):
        if self.registryValue('ison'):
            now = time.time()
            if now - self.lastIson > self.registryValue('ison.period'):
                self.lastIson = now
                self._sendIson(irc, nick)
                
    def _sendIson(self, irc, nick):
        self.log.info('Checking if %s ISON %s.', nick, irc.network)
        irc.queueMsg(ircmsgs.ison(nick))

    def _sendNick(self, irc, nick):
        self.log.info('Attempting to switch to nick %s on %s.',
                      nick, irc.network)
        irc.sendMsg(ircmsgs.nick(nick))
        
    def doQuit(self, irc, msg):
        nick = self._getNick(irc.network)
        if ircutils.strEqual(msg.nick, nick):
            self._sendNick(irc, nick)
            
    def doNick(self, irc, msg):
        nick = self._getNick(irc.network)
        if ircutils.strEqual(msg.nick, nick):
            self._sendNick(irc, nick)

    def do303(self, irc, msg):
        """This is returned by the ISON command."""
        if not msg.args[1]:
            nick = self._getNick(irc.network)
            if nick:
                self._sendNick(irc, nick)
NickCapture = internationalizeDocstring(NickCapture)

Class = NickCapture

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2002-2004, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

class NickCaptureTestCase(PluginTestCase):
    plugins = ('NickCapture',)


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:


########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2004, William Robinson.
# Derived from work (c) 1998, Adam Spiers <adam.spiers@new.ox.ac.uk>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Nickometer')

def configure(advanced):
    # This will be called by setup.py to configure this module.  Advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Nickometer', True)

Nickometer = conf.registerPlugin('Nickometer')
# This is where your configuration variables (if any) should go.  For example:
# conf.registerGlobalValue(Nickometer, 'someConfigVariableName',
#     registry.Boolean(False, _("""Help for someConfigVariableName.""")))


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2004, William Robinson.
# Derived from work (c) 1998, Adam Spiers <adam.spiers@new.ox.ac.uk>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

###
# This algorithm is almost a direct from a the perl nickometer from
# blootbot. Hardly any of the original code has been used, though most of
# the comments, I copy-pasted. As a matter of courtesy, the original copyright
# message follows:
#
#    #
#    # Lame-o-Nickometer backend
#    #
#    # (c) 1998 Adam Spiers <adam.spiers@new.ox.ac.uk>
#    #
#    # You may do whatever you want with this code, but give me credit.
#    #
#    # $Id: Nickometer.py,v 1.13 2004/10/22 22:19:30 jamessan Exp $
#    #
###

from __future__ import division

import supybot

import re
import math
import string

import supybot.utils as utils
import supybot.callbacks as callbacks
from supybot.commands import wrap, additional
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Nickometer')

def slowExponent(x):
    return 1.3 * x * (1 - math.atan(x / 6.0) * 2 / math.pi)

def slowPow(x, y):
    return math.pow(x, slowExponent(y))

def caseShifts(s):
    s=re.sub('[^a-zA-Z]', '', s)
    s=re.sub('[A-Z]+', 'U', s)
    s=re.sub('[a-z]+', 'l', s)
    return len(s)-1

def numberShifts(s):
    s=re.sub('[^a-zA-Z0-9]', '', s)
    s=re.sub('[a-zA-Z]+', 'l', s)
    s=re.sub('[0-9]+', 'n', s)
    return len(s)-1

class Nickometer(callbacks.Plugin):
    def punish(self, damage, reason):
        self.log.debug('%s lameness points awarded: %s', damage, reason)
        return damage

    @internationalizeDocstring
    def nickometer(self, irc, msg, args, nick):
        """[<nick>]

        Tells you how lame said nick is.  If <nick> is not given, uses the
        nick of the person giving the command.
        """
        score = 0L
        if not nick:
            nick = msg.nick
        originalNick = nick
        if not nick:
            irc.error('Give me a nick to judge as the argument, please.')
            return

        specialCost = [('69', 500),
                       ('dea?th', 500),
                       ('dark', 400),
                       ('n[i1]ght', 300),
                       ('n[i1]te', 500),
                       ('fuck', 500),
                       ('sh[i1]t', 500),
                       ('coo[l1]', 500),
                       ('kew[l1]', 500),
                       ('lame', 500),
                       ('dood', 500),
                       ('dude', 500),
                       ('[l1](oo?|u)[sz]er', 500),
                       ('[l1]eet', 500),
                       ('e[l1]ite', 500),
                       ('[l1]ord', 500),
                       ('pron', 1000),
                       ('warez', 1000),
                       ('xx', 100),
                       ('\\[rkx]0', 1000),
                       ('\\0[rkx]', 1000)]

        letterNumberTranslator = utils.str.MultipleReplacer(dict(list(zip(
                '023457+8', 'ozeasttb'))))
        for special in specialCost:
            tempNick = nick
            if special[0][0] != '\\':
                tempNick = letterNumberTranslator(tempNick)

            if tempNick and re.search(special[0], tempNick, re.IGNORECASE):
                score += self.punish(special[1], 'matched special case /%s/' %
                                                                  special[0])

        # I don't really know about either of these next two statements,
        # but they don't seem to do much harm.
        # Allow Perl referencing
        nick=re.sub('^\\\\([A-Za-z])', '\1', nick);

        # C-- ain't so bad either
        nick=re.sub('^C--$', 'C', nick);

        # Punish consecutive non-alphas
        matches=re.findall('[^\w\d]{2,}',nick)
        for match in matches:
            score += self.punish(slowPow(10, len(match)),
                                    '%s consecutive non-alphas ' % len(match))

        # Remove balanced brackets ...
        while True:
            nickInitial = nick
            nick=re.sub('^([^()]*)(\()(.*)(\))([^()]*)$', '\1\3\5', nick, 1)
            nick=re.sub('^([^{}]*)(\{)(.*)(\})([^{}]*)$', '\1\3\5', nick, 1)
            nick=re.sub('^([^[\]]*)(\[)(.*)(\])([^[\]]*)$', '\1\3\5', nick, 1)
            if nick == nickInitial:
                break
            self.log.debug('Removed some matching brackets %r => %r',
                           nickInitial, nick)
        # ... and punish for unmatched brackets
        unmatched = re.findall('[][(){}]', nick)
        if len(unmatched) > 0:
            score += self.punish(slowPow(10, len(unmatched)),
                                  '%s unmatched parentheses' % len(unmatched))

        # Punish k3wlt0k
        k3wlt0k_weights = (5, 5, 2, 5, 2, 3, 1, 2, 2, 2)
        for i in range(len(k3wlt0k_weights)):
            hits=re.findall(repr(i), nick)
            if (hits and len(hits)>0):
                score += self.punish(k3wlt0k_weights[i] * len(hits) * 30,
                                    '%s occurrences of %s ' % (len(hits), i))

        # An alpha caps is not lame in middle or at end, provided the first
        # alpha is caps.
        nickOriginalCase = nick
        match = re.search('^([^A-Za-z]*[A-Z].*[a-z].*?)[-_]?([A-Z])', nick)
        if match:
            nick = ''.join([nick[:match.start(2)],
                               nick[match.start(2)].lower(),
                               nick[match.start(2)+1:]])

        match = re.search('^([^A-Za-z]*)([A-Z])([a-z])', nick)
        if match:
            nick = ''.join([nick[:match.start(2)],
                               nick[match.start(2):match.end(2)].lower(),
                               nick[match.end(2):]])

        # Punish uppercase to lowercase shifts and vice-versa, modulo
        # exceptions above

        # the commented line is the equivalent of the original, but i think
        # they intended my version, otherwise, the first caps alpha will
        # still be punished
        #cshifts = caseShifts(nickOriginalCase);
        cshifts = caseShifts(nick);
        if cshifts > 1 and re.match('.*[A-Z].*', nick):
            score += self.punish(slowPow(9, cshifts),
                                 '%s case shifts' % cshifts)

        # Punish lame endings
        if re.match('.*[XZ][^a-zA-Z]*$', nickOriginalCase):
            score += self.punish(50, 'the last alphanumeric character was lame')

        # Punish letter to numeric shifts and vice-versa
        nshifts = numberShifts(nick);
        if nshifts > 1:
            score += self.punish(slowPow(9, nshifts),
                                 '%s letter/number shifts' % nshifts)

        # Punish extraneous caps
        caps = re.findall('[A-Z]', nick)
        if caps and len(caps) > 0:
            score += self.punish(slowPow(7, len(caps)),
                                 '%s extraneous caps' % len(caps))

        # one trailing underscore is ok. i also added a - for parasite-
        nick = re.sub('[-_]$','',nick)

        # Punish anything that's left
        remains = re.findall('[^a-zA-Z0-9]', nick)
        if remains and len(remains) > 0:
            score += self.punish(50*len(remains) + slowPow(9, len(remains)),
                                     '%s extraneous symbols' % len(remains))

        # Use an appropriate function to map [0, +inf) to [0, 100)
        percentage = 100 * (1 + math.tanh((score - 400.0) / 400.0)) * \
                     (1 - 1 / (1 + score / 5.0)) // 2

        # if it's above 99.9%, show as many digits as is interesting
        score_string=re.sub('(99\\.9*\\d|\\.\\d).*','\\1',repr(percentage))

        irc.reply(_('The "lame nick-o-meter" reading for "%s" is %s%%.') %
                  (originalNick, score_string))

        self.log.debug('Calculated lameness score for %s as %s '
                       '(raw score was %s)', originalNick, score_string, score)
    nickometer = wrap(nickometer, [additional('text')])

Class = Nickometer

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2005, aafshar@gmail.com
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

class NickometerTestCase(PluginTestCase):
    plugins = ('Nickometer',)
    def testNickometer(self):
        self.assertNotError('nickometer')
        self.assertNotError('nickometer jemfinch')

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Note')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Note', True)


Note = conf.registerPlugin('Note')
conf.registerGroup(Note, 'notify')
conf.registerGlobalValue(Note.notify, 'onJoin',
    registry.Boolean(False, """Determines whether the bot will notify people of
    their new messages when they join the channel.  Normally it will notify
    them when they send a message to the channel, since oftentimes joins are
    the result of netsplits and not the actual presence of the user."""))
conf.registerGlobalValue(Note.notify.onJoin, 'repeatedly',
    registry.Boolean(False, """Determines whether the bot will repeatedly
    notify people of their new messages when they join the channel.  That means
    when they join the channel, the bot will tell them they have unread
    messages, even if it's told them before."""))
conf.registerGlobalValue(Note.notify, 'autoSend',
    registry.NonNegativeInteger(0, """Determines the upper limit for
    automatically sending messages instead of notifications.  I.e., if this
    value is 2 and there are 2 new messages to notify a user about, instead of
    sending a notification message, the bot will simply send those new
    messages. If there are 3 new messages, however, the bot will send a
    notification message."""))


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2004, Brett Kelly
# Copyright (c) 2010, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import re
import time
import operator

import supybot.dbi as dbi
import supybot.log as log
import supybot.conf as conf
import supybot.utils as utils
import supybot.ircdb as ircdb
from supybot.commands import *
import supybot.ircmsgs as ircmsgs
import supybot.plugins as plugins
import supybot.ircutils as ircutils
import supybot.callbacks as callbacks
from supybot import commands
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Note')

class NoteRecord(dbi.Record):
    __fields__ = [
        'frm',
        'to',
        'at',
        'notified',
        'read',
        'public',
        'text',
        ]

class DbiNoteDB(dbi.DB):
    Mapping = 'flat'
    Record = NoteRecord

    def __init__(self, *args, **kwargs):
        dbi.DB.__init__(self, *args, **kwargs)
        self.unRead = {}
        self.unNotified = {}
        for record in self:
            self._addCache(record)

    def _addCache(self, record):
        if not record.read:
            self.unRead.setdefault(record.to, []).append(record.id)
        if not record.notified:
            self.unNotified.setdefault(record.to, []).append(record.id)

    def _removeCache(self, record):
        if record.notified:
            try:
                self.unNotified[record.to].remove(record.id)
            except (KeyError, ValueError):
                pass
        if record.read:
            try:
                self.unRead[record.to].remove(record.id)
            except (KeyError, ValueError):
                pass

    def setRead(self, id):
        n = self.get(id)
        n.read = True
        n.notified = True
        self._removeCache(n)
        self.set(id, n)

    def setNotified(self, id):
        n = self.get(id)
        n.notified = True
        self._removeCache(n)
        self.set(id, n)

    def getUnnotifiedIds(self, to):
        return self.unNotified.get(to, [])

    def getUnreadIds(self, to):
        return self.unRead.get(to, [])

    def send(self, frm, to, public, text):
        n = self.Record(frm=frm, to=to, text=text,
                        at=time.time(), public=public)
        id = self.add(n)
        self._addCache(n)
        return id

    def unsend(self, id):
        self.remove(id)
        for cache in self.unRead, self.unNotified:
            for (to, ids) in cache.items():
                while id in ids:
                    ids.remove(id)

NoteDB = plugins.DB('Note', {'flat': DbiNoteDB})

class Note(callbacks.Plugin):
    def __init__(self, irc):
        self.__parent= super(Note, self)
        self.__parent.__init__(irc)
        self.db = NoteDB()

    def die(self):
        self.__parent.die()
        self.db.close()

    def doPrivmsg(self, irc, msg):
        if ircmsgs.isCtcp(msg) and not ircmsgs.isAction(msg):
            return
        self._notify(irc, msg)

    def doJoin(self, irc, msg):
        if self.registryValue('notify.onJoin'):
            repeatedly = self.registryValue('notify.onJoin.repeatedly')
            self._notify(irc, msg, repeatedly)

    def _notify(self, irc, msg, repeatedly=False):
        irc = callbacks.SimpleProxy(irc, msg)
        try:
            to = ircdb.users.getUserId(msg.prefix)
        except KeyError:
            return
        ids = self.db.getUnnotifiedIds(to)
        if len(ids) <= self.registryValue('notify.autoSend'):
            for id in ids:
                irc.reply(self._formatNote(self.db.get(id), to), private=True)
                self.db.setRead(id)
            return
        unnotifiedIds = ['#%s' % nid for nid in ids]
        unnotified = len(unnotifiedIds)
        if unnotified or repeatedly:
            unreadIds = ['#%s' % nid for nid in self.db.getUnreadIds(to)]
            unread = len(unreadIds)
            s = format('You have %n; %i that I haven\'t told you about '
                       'before now.  %L %b still unread.',
                       (unread, 'unread', 'note'), unnotified,
                       unreadIds, unread)
            # Later we'll have a user value for allowing this to be a NOTICE.
            irc.reply(s, private=True)
            for nid in unnotifiedIds:
                id = int(nid[1:])
                self.db.setNotified(id)

    def _getUserId(self, irc, name):
        if ircdb.users.hasUser(name):
            return ircdb.users.getUserId(name)
        else:
            try:
                hostmask = irc.state.nickToHostmask(name)
                return ircdb.users.getUserId(hostmask)
            except KeyError:
                return None

    def send(self, irc, msg, args, user, targets, text):
        """<recipient>,[<recipient>,[...]] <text>

        Sends a new note to the user specified.  Multiple recipients may be
        specified by separating their names by commas.
        """
        # Let's get the from user.
        public = irc.isChannel(msg.args[0])
        sent = []
        for target in targets:
            id = self.db.send(user.id, target.id, public, text)
            s = format('note #%i sent to %s', id, target.name)
            sent.append(s)
        irc.reply(format('%L.', sent).capitalize())
    send = wrap(send, ['user', commalist('otherUser'), 'text'])

    def reply(self, irc, msg, args, user, id, text):
        """<id> <text>

        Sends a note in reply to <id>.
        """
        try:
            note = self.db.get(id)
        except dbi.NoRecordError:
            irc.error('That\'s not a note in my database.', Raise=True)
        if note.to != user.id:
            irc.error('You may only reply to notes '
                      'that have been sent to you.', Raise=True)
        self.db.setRead(id)
        text += ' (in reply to #%s)' % id
        public = irc.isChannel(msg.args[0])
        try:
            target = ircdb.users.getUser(note.frm)
        except KeyError:
            irc.error('The user who sent you that note '
                      'is no longer in my user database.', Raise=True)
        id = self.db.send(user.id, note.frm, public, text)
        irc.reply(format('Note #%i sent to %s.', id, target.name))
    reply = wrap(reply, ['user', ('id', 'note'), 'text'])

    def unsend(self, irc, msg, args, user, id):
        """<id>

        Unsends the note with the id given.  You must be the
        author of the note, and it must be unread.
        """
        try:
            note = self.db.get(id)
        except dbi.NoRecordError:
            irc.errorInvalid('note id')
        if note.frm == user.id:
            if not note.read:
                self.db.unsend(id)
                irc.replySuccess()
            else:
                irc.error('That note has been read already.')
        else:
            irc.error('That note wasn\'t sent by you.')
    unsend = wrap(unsend, ['user', ('id', 'note')])

    def _formatNote(self, note, to):
        elapsed = utils.timeElapsed(time.time() - note.at)
        if note.to == to:
            author = plugins.getUserName(note.frm)
            return format('#%i: %s (Sent by %s %s ago)',
                          note.id, note.text, author, elapsed)
        else:
            assert note.frm == to, 'Odd, userid isn\'t frm either.'
            recipient = plugins.getUserName(note.to)
            return format('#%i: %s (Sent to %s %s ago)',
                          note.id, note.text, recipient, elapsed)

    def note(self, irc, msg, args, user, id):
        """<id>

        Retrieves a single note by its unique note id.  Use the 'note list'
        command to see what unread notes you have.
        """
        try:
            note = self.db.get(id)
        except dbi.NoRecordError:
            irc.errorInvalid('note id')
        if user.id != note.frm and user.id != note.to:
            s = 'You may only retrieve notes you\'ve sent or received.'
            irc.error(s)
            return
        newnote = self._formatNote(note, user.id)
        irc.reply(newnote, private=(not note.public))
        self.db.setRead(id)
    note = wrap(note, ['user', ('id', 'note')])

    def _formatNoteId(self, msg, note, sent=False):
        if note.public or not ircutils.isChannel(msg.args[0]):
            if sent:
                sender = plugins.getUserName(note.to)
                return format('#%i to %s', note.id, sender)
            else:
                sender = plugins.getUserName(note.frm)
                return format('#%i from %s', note.id, sender)
        else:
            return format('#%i (private)', note.id)

    def search(self, irc, msg, args, user, optlist, glob):
        """[--{regexp} <value>] [--sent] [<glob>]

        Searches your received notes for ones matching <glob>.  If --regexp is
        given, its associated value is taken as a regexp and matched against
        the notes.  If --sent is specified, only search sent notes.
        """
        criteria = []
        def to(note):
            return note.to == user.id
        def frm(note):
            return note.frm == user.id
        own = to
        for (option, arg) in optlist:
            if option == 'regexp':
                criteria.append(lambda s:
                                regexp_wrapper(s, reobj=arg, timeout=0.1,
                                               plugin_name=self.name(),
                                               fcn_name='search'))
            elif option == 'sent':
                own = frm
        if glob:
            glob = utils.python.glob2re(glob)
            criteria.append(re.compile(glob).search)
        def match(note):
            for p in criteria:
                if not p(note.text):
                    return False
            return True
        notes = list(self.db.select(lambda n: match(n) and own(n)))
        if not notes:
            irc.reply('No matching notes were found.')
        else:
            utils.sortBy(operator.attrgetter('id'), notes)
            ids = [self._formatNoteId(msg, note) for note in notes]
            ids = self._condense(ids)
            irc.reply(format('%L', ids))
    search = wrap(search,
                  ['user', getopts({'regexp': ('regexpMatcher', True),
                                    'sent': ''}),
                   additional('glob')])

    def list(self, irc, msg, args, user, optlist):
        """[--{old,sent}] [--{from,to} <user>]

        Retrieves the ids of all your unread notes.  If --old is given, list
        read notes.  If --sent is given, list notes that you have sent.  If
        --from is specified, only lists notes sent to you from <user>.  If
        --to is specified, only lists notes sent by you to <user>.
        """
        (sender, receiver, old, sent) = (None, None, False, False)
        for (option, arg) in optlist:
            if option == 'old':
                old = True
            if option == 'sent':
                sent = True
            if option == 'from':
                sender = arg
            if option == 'to':
                receiver = arg
                sent = True
        if old:
            return self._oldnotes(irc, msg, sender)
        if sent:
            return self._sentnotes(irc, msg, receiver)
        def p(note):
            return not note.read and note.to == user.id
        if sender:
            originalP = p
            def p(note):
                return originalP(note) and note.frm == sender.id
        notes = list(self.db.select(p))
        if not notes:
            irc.reply('You have no unread notes.')
        else:
            utils.sortBy(operator.attrgetter('id'), notes)
            ids = [self._formatNoteId(msg, note) for note in notes]
            ids = self._condense(ids)
            irc.reply(format('%L.', ids))
    list = wrap(list, ['user', getopts({'old': '', 'sent': '',
                                        'from': 'otherUser',
                                        'to': 'otherUser'})])

    def next(self, irc, msg, args, user):
        """takes no arguments

        Retrieves your next unread note, if any.
        """
        notes = self.db.getUnreadIds(user.id)
        if not notes:
            irc.reply('You have no unread notes.')
        else:
            found = False
            for id in notes:
                try:
                    note = self.db.get(id)
                except KeyError:
                    continue
                found = True
                break
            if not found:
                irc.reply('You have no unread notes.')
            else:
                irc.reply(self._formatNote(note, user.id), private=(not note.public))
                self.db.setRead(note.id)
    next = wrap(next, ['user'])

    def _condense(self, notes):
        temp = {}
        for note in notes:
            note = note.split(' ', 1)
            if note[1] in temp:
                temp[note[1]].append(note[0])
            else:
                temp[note[1]] = [note[0]]
        notes = []
        for (k,v) in temp.iteritems():
            if '(private)' in k:
                k = k.replace('(private)', format('%b private', len(v)))
            notes.append(format('%L %s', v, k))
        return notes

    def _sentnotes(self, irc, msg, receiver):
        try:
            user = ircdb.users.getUser(msg.prefix)
        except KeyError:
            irc.errorNotRegistered()
            return
        def p(note):
            return note.frm == user.id
        if receiver:
            originalP = p
            def p(note):
                return originalP(note) and note.to == receiver.id
        notes = list(self.db.select(p))
        if not notes:
            irc.error('I couldn\'t find any sent notes for your user.')
        else:
            utils.sortBy(operator.attrgetter('id'), notes)
            notes.reverse() # Most recently sent first.
            ids = [self._formatNoteId(msg, note, sent=True) for note in notes]
            ids = self._condense(ids)
            irc.reply(format('%L.', ids))

    def _oldnotes(self, irc, msg, sender):
        try:
            user = ircdb.users.getUser(msg.prefix)
        except KeyError:
            irc.errorNotRegistered()
            return
        def p(note):
            return note.to == user.id and note.read
        if sender:
            originalP = p
            def p(note):
                return originalP(note) and note.frm == sender.id
        notes = list(self.db.select(p))
        if not notes:
            irc.reply('I couldn\'t find any matching read notes '
                      'for your user.')
        else:
            utils.sortBy(operator.attrgetter('id'), notes)
            notes.reverse()
            ids = [self._formatNoteId(msg, note) for note in notes]
            ids = self._condense(ids)
            irc.reply(format('%L.', ids))


Class = Note

# vim: shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2003, Brett Kelly
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

class NoteTestCase(PluginTestCase):
    plugins = ('Note', 'Misc', 'User')
    config = {'supybot.reply.whenNotCommand': False}
    def setUp(self):
        PluginTestCase.setUp(self)
        # setup a user
        self.prefix = 'foo!bar@baz'
        self.assertNotError('register inkedmn bar')
        self.assertNotError('hostmask add inkedmn test2!bar@baz')

    def testSendnote(self):
        self.assertRegexp('note send inkedmn test', '#1')
        # have to getMsg(' ') after each Note.send to absorb supybot's
        # automatic "You have an unread note" message
        _ = self.getMsg(' ')
        self.assertError('note send alsdkjfasldk foo')
        self.assertNotError('note send inkedmn test2')
        _ = self.getMsg(' ')
        # verify that sending a note to a user via their nick instead of their
        # ircdb user name works
        self.prefix = 'test2!bar@baz'
        self.assertNotError('note send test2 foo')
        _ = self.getMsg(' ')

    def testNote(self):
        self.assertNotError('note send inkedmn test')
        _ = self.getMsg(' ')
        self.assertRegexp('note 1', 'test')
        self.assertError('note blah')

    def testList(self):
        self.assertResponse('note list', 'You have no unread notes.')
        self.assertNotError('note send inkedmn testing')
        _ = self.getMsg(' ')
        self.assertNotError('note send inkedmn 1,2,3')
        _ = self.getMsg(' ')
        self.assertRegexp('note list --sent', r'#2.*#1')
        self.assertRegexp('note list --sent --to inkedmn', r'#2.*#1')
        self.assertRegexp('note list', r'#1.*#2')
        self.assertRegexp('note 1', 'testing')
        self.assertRegexp('note list --old', '#1 from inkedmn')
        self.assertRegexp('note list --old --from inkedmn','#1 from inkedmn')

    def testSearch(self):
        self.assertNotError('note send inkedmn testing')
        _ = self.getMsg(' ')
        self.assertNotError('note send inkedmn 1,2,3')
        _ = self.getMsg(' ')
        self.assertRegexp('note search test', r'#1')
        self.assertRegexp('note search --regexp m/1,2/', r'#2')
        self.assertRegexp('note search --sent test', r'#1')

    def testNext(self):
        self.assertNotError('note send inkedmn testing')
        _ = self.getMsg(' ')
        self.assertRegexp('note next', 'testing')


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2004-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###


import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Owner')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Owner', True)

Owner = conf.registerPlugin('Owner', True)
conf.registerGlobalValue(Owner, 'public',
    registry.Boolean(True, """Determines whether this plugin is publicly
    visible."""))
conf.registerGlobalValue(Owner, 'quitMsg',
    registry.String('', """Determines what quit message will be used by default.
    If the quit command is called without a quit message, this will be used.  If
    this value is empty, the nick of the person giving the quit command will be
    used."""))

conf.registerGroup(conf.supybot.commands, 'renames', orderAlphabetically=True)


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# Copyright (c) 2008-2009, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import gc
import os
import sys
import time
import socket
import linecache

import re

import supybot.log as log
import supybot.conf as conf
import supybot.i18n as i18n
import supybot.utils as utils
import supybot.world as world
import supybot.ircdb as ircdb
from supybot.commands import *
import supybot.irclib as irclib
import supybot.plugin as plugin
import supybot.plugins as plugins
import supybot.drivers as drivers
import supybot.ircmsgs as ircmsgs
import supybot.ircutils as ircutils
import supybot.registry as registry
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Owner')

###
# supybot.commands.
###

def registerDefaultPlugin(command, plugin):
    command = callbacks.canonicalName(command)
    conf.registerGlobalValue(conf.supybot.commands.defaultPlugins,
                             command, registry.String(plugin, ''))
    # This must be set, or the quotes won't be removed.
    conf.supybot.commands.defaultPlugins.get(command).set(plugin)

def registerRename(plugin, command=None, newName=None):
    g = conf.registerGlobalValue(conf.supybot.commands.renames, plugin,
            registry.SpaceSeparatedSetOfStrings([], """Determines what commands
            in this plugin are to be renamed."""))
    if command is not None:
        g().add(command)
        v = conf.registerGlobalValue(g, command, registry.String('', ''))
        if newName is not None:
            v.setValue(newName) # In case it was already registered.
        return v
    else:
        return g

def renameCommand(cb, name, newName):
    assert not hasattr(cb, newName), 'Cannot rename over existing attributes.'
    assert newName == callbacks.canonicalName(newName), \
           'newName must already be normalized.'
    if name != newName:
        method = getattr(cb.__class__, name)
        setattr(cb.__class__, newName, method)
        delattr(cb.__class__, name)


registerDefaultPlugin('list', 'Misc')
registerDefaultPlugin('help', 'Misc')
registerDefaultPlugin('ignore', 'Admin')
registerDefaultPlugin('reload', 'Owner')
registerDefaultPlugin('enable', 'Owner')
registerDefaultPlugin('disable', 'Owner')
registerDefaultPlugin('unignore', 'Admin')
registerDefaultPlugin('capabilities', 'User')
registerDefaultPlugin('addcapability', 'Admin')
registerDefaultPlugin('removecapability', 'Admin')

class Owner(callbacks.Plugin):
    # This plugin must be first; its priority must be lowest; otherwise odd
    # things will happen when adding callbacks.
    def __init__(self, irc=None):
        if irc is not None:
            assert not irc.getCallback(self.name())
        self.__parent = super(Owner, self)
        self.__parent.__init__(irc)
        # Setup command flood detection.
        self.commands = ircutils.FloodQueue(conf.supybot.abuse.flood.interval())
        conf.supybot.abuse.flood.interval.addCallback(self.setFloodQueueTimeout)
        # Setup plugins and default plugins for commands.
        #
        # This needs to be done before we connect to any networks so that the
        # children of supybot.plugins (the actual plugins) exist and can be
        # loaded.
        for (name, s) in registry._cache.iteritems():
            if 'alwaysLoadDefault' in name or 'alwaysLoadImportant' in name:
                continue
            if name.startswith('supybot.plugins'):
                try:
                    (_, _, name) = registry.split(name)
                except ValueError: # unpack list of wrong size.
                    continue
                # This is just for the prettiness of the configuration file.
                # There are no plugins that are all-lowercase, so we'll at
                # least attempt to capitalize them.
                if name == name.lower():
                    name = name.capitalize()
                conf.registerPlugin(name)
            if name.startswith('supybot.commands.defaultPlugins'):
                try:
                    (_, _, _, name) = registry.split(name)
                except ValueError: # unpack list of wrong size.
                    continue
                registerDefaultPlugin(name, s)
        # Setup Irc objects, connected to networks.  If world.ircs is already
        # populated, chances are that we're being reloaded, so don't do this.
        if not world.ircs:
            for network in conf.supybot.networks():
                try:
                    self._connect(network)
                except socket.error as e:
                    self.log.error('Could not connect to %s: %s.', network, e)
                except Exception as e:
                    self.log.exception('Exception connecting to %s:', network)
                    self.log.error('Could not connect to %s: %s.', network, e)

    def callPrecedence(self, irc):
        return ([], [cb for cb in irc.callbacks if cb is not self])

    def outFilter(self, irc, msg):
        if msg.command == 'PRIVMSG' and not world.testing:
            if ircutils.strEqual(msg.args[0], irc.nick):
                self.log.warning('Tried to send a message to myself: %r.', msg)
                return None
        return msg

    def reset(self):
        # This has to be done somewhere, I figure here is as good place as any.
        callbacks.IrcObjectProxy._mores.clear()
        self.__parent.reset()

    def _connect(self, network, serverPort=None, password='', ssl=False):
        try:
            group = conf.supybot.networks.get(network)
            (server, port) = group.servers()[0]
        except (registry.NonExistentRegistryEntry, IndexError):
            if serverPort is None:
                raise ValueError('connect requires a (server, port) ' \
                                  'if the network is not registered.')
            conf.registerNetwork(network, password, ssl)
            serverS = '%s:%s' % serverPort
            conf.supybot.networks.get(network).servers.append(serverS)
            assert conf.supybot.networks.get(network).servers(), \
                   'No servers are set for the %s network.' % network
        self.log.info('Creating new Irc for %s.', network)
        newIrc = irclib.Irc(network)
        for irc in world.ircs:
            if irc != newIrc:
                newIrc.state.history = irc.state.history
        driver = drivers.newDriver(newIrc)
        self._loadPlugins(newIrc)
        return newIrc

    def _loadPlugins(self, irc):
        self.log.info('Loading plugins (connecting to %s).', irc.network)
        alwaysLoadImportant = conf.supybot.plugins.alwaysLoadImportant()
        important = conf.supybot.commands.defaultPlugins.importantPlugins()
        for (name, value) in conf.supybot.plugins.getValues(fullNames=False):
            if irc.getCallback(name) is None:
                load = value()
                if not load and name in important:
                    if alwaysLoadImportant:
                        s = '%s is configured not to be loaded, but is being '\
                            'loaded anyway because ' \
                            'supybot.plugins.alwaysLoadImportant is True.'
                        self.log.warning(s, name)
                        load = True
                if load:
                    # We don't load plugins that don't start with a capital
                    # letter.
                    if name[0].isupper() and not irc.getCallback(name):
                        # This is debug because each log logs its beginning.
                        self.log.debug('Loading %s.', name)
                        try:
                            m = plugin.loadPluginModule(name,
                                                        ignoreDeprecation=True)
                            plugin.loadPluginClass(irc, m)
                        except callbacks.Error as e:
                            # This is just an error message.
                            log.warning(str(e))
                        except (plugins.NoSuitableDatabase, ImportError) as e:
                            s = 'Failed to load %s: %s' % (name, e)
                            if not s.endswith('.'):
                                s += '.'
                            log.warning(s)
                        except Exception as e:
                            log.exception('Failed to load %s:', name)
                else:
                    # Let's import the module so configuration is preserved.
                    try:
                        _ = plugin.loadPluginModule(name)
                    except Exception as e:
                        log.debug('Attempted to load %s to preserve its '
                                  'configuration, but load failed: %s',
                                  name, e)
        world.starting = False

    def do376(self, irc, msg):
        msg = conf.supybot.networks.get(irc.network).channels.joins()
        if msg:
            irc.queueMsg(msg)
    do422 = do377 = do376

    def setFloodQueueTimeout(self, *args, **kwargs):
        self.commands.timeout = conf.supybot.abuse.flood.interval()
    def doPrivmsg(self, irc, msg):
        assert self is irc.callbacks[0], \
               'Owner isn\'t first callback: %r' % irc.callbacks
        if ircmsgs.isCtcp(msg):
            return
        s = callbacks.addressed(irc.nick, msg)
        if s:
            ignored = ircdb.checkIgnored(msg.prefix)
            if ignored:
                self.log.info('Ignoring command from %s.', msg.prefix)
                return
            maximum = conf.supybot.abuse.flood.command.maximum()
            self.commands.enqueue(msg)
            if conf.supybot.abuse.flood.command() \
               and self.commands.len(msg) > maximum \
               and not ircdb.checkCapability(msg.prefix, 'trusted'):
                punishment = conf.supybot.abuse.flood.command.punishment()
                banmask = ircutils.banmask(msg.prefix)
                self.log.info('Ignoring %s for %s seconds due to an apparent '
                              'command flood.', banmask, punishment)
                ircdb.ignores.add(banmask, time.time() + punishment)
                irc.reply('You\'ve given me %s commands within the last '
                          '%i seconds; I\'m now ignoring you for %s.' %
                          (maximum,
                           conf.supybot.abuse.flood.interval(),
                           utils.timeElapsed(punishment, seconds=False)))
                return
            try:
                tokens = callbacks.tokenize(s, channel=msg.args[0])
                self.Proxy(irc, msg, tokens)
            except SyntaxError as e:
                irc.queueMsg(callbacks.error(msg, str(e)))

    def logmark(self, irc, msg, args, text):
        """<text>

        Logs <text> to the global Supybot log at critical priority.  Useful for
        marking logfiles for later searching.
        """
        self.log.critical(text)
        irc.replySuccess()
    logmark = wrap(logmark, ['text'])

    def announce(self, irc, msg, args, text):
        """<text>

        Sends <text> to all channels the bot is currently on and not
        lobotomized in.
        """
        u = ircdb.users.getUser(msg.prefix)
        text = 'Announcement from my owner (%s): %s' % (u.name, text)
        for channel in irc.state.channels:
            c = ircdb.channels.getChannel(channel)
            if not c.lobotomized:
                irc.queueMsg(ircmsgs.privmsg(channel, text))
        irc.noReply()
    announce = wrap(announce, ['text'])

    def defaultplugin(self, irc, msg, args, optlist, command, plugin):
        """[--remove] <command> [<plugin>]

        Sets the default plugin for <command> to <plugin>.  If --remove is
        given, removes the current default plugin for <command>.  If no plugin
        is given, returns the current default plugin set for <command>.  See
        also, supybot.commands.defaultPlugins.importantPlugins.
        """
        remove = False
        for (option, arg) in optlist:
            if option == 'remove':
                remove = True
        (_, cbs) = irc.findCallbacksForArgs([command])
        if remove:
            try:
                conf.supybot.commands.defaultPlugins.unregister(command)
                irc.replySuccess()
            except registry.NonExistentRegistryEntry:
                s = 'I don\'t have a default plugin set for that command.'
                irc.error(s)
        elif not cbs:
            irc.errorInvalid('command', command)
        elif plugin:
            if not plugin.isCommand(command):
                irc.errorInvalid('command in the %s plugin' % plugin.name(),
                                 command)
            registerDefaultPlugin(command, plugin.name())
            irc.replySuccess()
        else:
            try:
                irc.reply(conf.supybot.commands.defaultPlugins.get(command)())
            except registry.NonExistentRegistryEntry:
                s = 'I don\'t have a default plugin set for that command.'
                irc.error(s)
    defaultplugin = wrap(defaultplugin, [getopts({'remove': ''}),
                                         'commandName',
                                         additional('plugin')])

    def ircquote(self, irc, msg, args, s):
        """<string to be sent to the server>

        Sends the raw string given to the server.
        """
        try:
            m = ircmsgs.IrcMsg(s)
        except Exception as e:
            irc.error(utils.exnToString(e))
        else:
            irc.queueMsg(m)
            irc.noReply()
    ircquote = wrap(ircquote, ['text'])

    def quit(self, irc, msg, args, text):
        """[<text>]

        Exits the bot with the QUIT message <text>.  If <text> is not given,
        the default quit message (supybot.plugins.Owner.quitMsg) will be used.
        If there is no default quitMsg set, your nick will be used.
        """
        text = text or self.registryValue('quitMsg') or msg.nick
        irc.noReply()
        m = ircmsgs.quit(text)
        world.upkeep()
        for irc in world.ircs[:]:
            irc.queueMsg(m)
            irc.die()
    quit = wrap(quit, [additional('text')])

    def flush(self, irc, msg, args):
        """takes no arguments

        Runs all the periodic flushers in world.flushers.  This includes
        flushing all logs and all configuration changes to disk.
        """
        world.flush()
        irc.replySuccess()
    flush = wrap(flush)

    def upkeep(self, irc, msg, args, level):
        """[<level>]

        Runs the standard upkeep stuff (flushes and gc.collects()).  If given
        a level, runs that level of upkeep (currently, the only supported
        level is "high", which causes the bot to flush a lot of caches as well
        as do normal upkeep stuff).
        """
        L = []
        if level == 'high':
            L.append(format('Regexp cache flushed: %n cleared.',
                            (len(re._cache), 'regexp')))
            re.purge()
            L.append(format('Pattern cache flushed: %n cleared.',
                            (len(ircutils._patternCache), 'compiled pattern')))
            ircutils._patternCache.clear()
            L.append(format('hostmaskPatternEqual cache flushed: %n cleared.',
                            (len(ircutils._hostmaskPatternEqualCache),
                             'result')))
            ircutils._hostmaskPatternEqualCache.clear()
            L.append(format('ircdb username cache flushed: %n cleared.',
                            (len(ircdb.users._nameCache),
                             'username to id mapping')))
            ircdb.users._nameCache.clear()
            L.append(format('ircdb hostmask cache flushed: %n cleared.',
                            (len(ircdb.users._hostmaskCache),
                            'hostmask to id mapping')))
            ircdb.users._hostmaskCache.clear()
            L.append(format('linecache line cache flushed: %n cleared.',
                            (len(linecache.cache), 'line')))
            linecache.clearcache()
            sys.exc_clear()
        collected = world.upkeep()
        if gc.garbage:
            L.append('Garbage!  %r.' % gc.garbage)
        L.append(format('%n collected.', (collected, 'object')))
        irc.reply('  '.join(L))
    upkeep = wrap(upkeep, [additional(('literal', ['high']))])

    def load(self, irc, msg, args, optlist, name):
        """[--deprecated] <plugin>

        Loads the plugin <plugin> from any of the directories in
        conf.supybot.directories.plugins; usually this includes the main
        installed directory and 'plugins' in the current directory.
        --deprecated is necessary if you wish to load deprecated plugins.
        """
        ignoreDeprecation = False
        for (option, argument) in optlist:
            if option == 'deprecated':
                ignoreDeprecation = True
        if name.endswith('.py'):
            name = name[:-3]
        if irc.getCallback(name):
            irc.error('%s is already loaded.' % name.capitalize())
            return
        try:
            module = plugin.loadPluginModule(name, ignoreDeprecation)
        except plugin.Deprecated:
            irc.error('%s is deprecated.  Use --deprecated '
                      'to force it to load.' % name.capitalize())
            return
        except ImportError as e:
            if str(e).endswith(name):
                irc.error('No plugin named %s exists.' % utils.str.dqrepr(name))
            else:
                irc.error(str(e))
            return
        cb = plugin.loadPluginClass(irc, module)
        name = cb.name() # Let's normalize this.
        conf.registerPlugin(name, True)
        irc.replySuccess()
    load = wrap(load, [getopts({'deprecated': ''}), 'something'])

    def reload(self, irc, msg, args, name):
        """<plugin>

        Unloads and subsequently reloads the plugin by name; use the 'list'
        command to see a list of the currently loaded plugins.
        """
        callbacks = irc.removeCallback(name)
        if callbacks:
            module = sys.modules[callbacks[0].__module__]
            if hasattr(module, 'reload'):
                x = module.reload()
            try:
                module = plugin.loadPluginModule(name)
                if hasattr(module, 'reload') and 'x' in locals():
                    module.reload(x)
                if hasattr(module, 'config'):
                    reload(module.config)
                for callback in callbacks:
                    callback.die()
                    del callback
                gc.collect() # This makes sure the callback is collected.
                callback = plugin.loadPluginClass(irc, module)
                irc.replySuccess()
            except ImportError:
                for callback in callbacks:
                    irc.addCallback(callback)
                irc.error('No plugin %s exists.' % name)
        else:
            irc.error('There was no plugin %s.' % name)
    reload = wrap(reload, ['something'])

    def unload(self, irc, msg, args, name):
        """<plugin>

        Unloads the callback by name; use the 'list' command to see a list
        of the currently loaded plugins.  Obviously, the Owner plugin can't
        be unloaded.
        """
        if ircutils.strEqual(name, self.name()):
            irc.error('You can\'t unload the %s plugin.' % name)
            return
        # Let's do this so even if the plugin isn't currently loaded, it doesn't
        # stay attempting to load.
        conf.registerPlugin(name, False)
        callbacks = irc.removeCallback(name)
        if callbacks:
            for callback in callbacks:
                callback.die()
                del callback
            gc.collect()
            irc.replySuccess()
        else:
            irc.error('There was no plugin %s.' % name)
    unload = wrap(unload, ['something'])

    def defaultcapability(self, irc, msg, args, action, capability):
        """{add|remove} <capability>

        Adds or removes (according to the first argument) <capability> from the
        default capabilities given to users (the configuration variable
        supybot.capabilities stores these).
        """
        if action == 'add':
            conf.supybot.capabilities().add(capability)
            irc.replySuccess()
        elif action == 'remove':
            try:
                conf.supybot.capabilities().remove(capability)
                irc.replySuccess()
            except KeyError:
                if ircdb.isAntiCapability(capability):
                    irc.error('That capability wasn\'t in '
                              'supybot.capabilities.')
                else:
                    anticap = ircdb.makeAntiCapability(capability)
                    conf.supybot.capabilities().add(anticap)
                    irc.replySuccess()
    defaultcapability = wrap(defaultcapability,
                             [('literal', ['add','remove']), 'capability'])

    def disable(self, irc, msg, args, plugin, command):
        """[<plugin>] <command>

        Disables the command <command> for all users (including the owners).
        If <plugin> is given, only disables the <command> from <plugin>.  If
        you want to disable a command for most users but not for yourself, set
        a default capability of -plugin.command or -command (if you want to
        disable the command in all plugins).
        """
        if command in ('enable', 'identify'):
            irc.error('You can\'t disable %s.' % command)
            return
        if plugin:
            if plugin.isCommand(command):
                pluginCommand = '%s.%s' % (plugin.name(), command)
                conf.supybot.commands.disabled().add(pluginCommand)
                plugin._disabled.add(command)
            else:
                irc.error('%s is not a command in the %s plugin.' %
                          (command, plugin.name()))
                return
        else:
            conf.supybot.commands.disabled().add(command)
            self._disabled.add(command)
        irc.replySuccess()
    disable = wrap(disable, [optional('plugin'), 'commandName'])

    def enable(self, irc, msg, args, plugin, command):
        """[<plugin>] <command>

        Enables the command <command> for all users.  If <plugin>
        if given, only enables the <command> from <plugin>.  This command is
        the inverse of disable.
        """
        try:
            if plugin:
                plugin._disabled.remove(command, plugin.name())
                command = '%s.%s' % (plugin.name(), command)
            else:
                self._disabled.remove(command)
            conf.supybot.commands.disabled().remove(command)
            irc.replySuccess()
        except KeyError:
            irc.error('That command wasn\'t disabled.')
    enable = wrap(enable, [optional('plugin'), 'commandName'])

    def rename(self, irc, msg, args, plugin, command, newName):
        """<plugin> <command> <new name>

        Renames <command> in <plugin> to the <new name>.
        """
        if not plugin.isCommand(command):
            what = 'command in the %s plugin' % plugin.name()
            irc.errorInvalid(what, command)
        if hasattr(plugin, newName):
            irc.error('The %s plugin already has an attribute named %s.' %
                      (plugin, newName))
            return
        registerRename(plugin.name(), command, newName)
        renameCommand(plugin, command, newName)
        irc.replySuccess()
    rename = wrap(rename, ['plugin', 'commandName', 'commandName'])

    def unrename(self, irc, msg, args, plugin):
        """<plugin>

        Removes all renames in <plugin>.  The plugin will be reloaded after
        this command is run.
        """
        try:
            conf.supybot.commands.renames.unregister(plugin.name())
        except registry.NonExistentRegistryEntry:
            irc.errorInvalid('plugin', plugin.name())
        self.reload(irc, msg, [plugin.name()]) # This makes the replySuccess.
    unrename = wrap(unrename, ['plugin'])

    def reloadlocale(self, irc, msg, args):
        """takes no argument

        Reloads the locale of the bot."""
        i18n.reloadLocales()
        irc.replySuccess()

Class = Owner

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# Copyright (c) 2009, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import sys

if sys.version_info >= (2, 7, 0):
    from unittest import skip
else:
    # Workaround
    def skip(string):
        return lambda x:None
from supybot.test import *

import supybot.conf as conf
import supybot.plugin as plugin

class OwnerTestCase(PluginTestCase):
    plugins = ('Owner', 'Config', 'Misc', 'Admin')
    def testHelpLog(self):
        self.assertHelp('help logmark')

    def testSrcAmbiguity(self):
        self.assertError('capability add foo bar')

    def testIrcquote(self):
        self.assertResponse('ircquote PRIVMSG %s :foo' % self.irc.nick, 'foo')

    def testFlush(self):
        self.assertNotError('flush')

    def testUpkeep(self):
        self.assertNotError('upkeep')

    def testLoad(self):
        self.assertError('load Owner')
        self.assertError('load owner')
        self.assertNotError('load Channel')
        self.assertNotError('list Owner')

    def testReload(self):
        self.assertError('reload Channel')
        self.assertNotError('load Channel')
        self.assertNotError('reload Channel')
        self.assertNotError('reload Channel')

    def testUnload(self):
        self.assertError('unload Foobar')
        self.assertNotError('load Channel')
        self.assertNotError('unload Channel')
        self.assertError('unload Channel')
        self.assertNotError('load Channel')
        self.assertNotError('unload CHANNEL')

    def testDisable(self):
        self.assertError('disable enable')
        self.assertError('disable identify')

    def testEnable(self):
        self.assertError('enable enable')

    def testEnableIsCaseInsensitive(self):
        self.assertNotError('disable Foo')
        self.assertNotError('enable foo')

    def testRename(self):
        self.assertError('rename Admin join JOIN')
        self.assertError('rename Admin join jo-in')
        self.assertNotError('rename Admin join testcommand')
        self.assertRegexp('list Admin', 'testcommand')
        self.assertNotRegexp('list Admin', 'join')
        self.assertError('help join')
        self.assertRegexp('help testcommand', 'Tell the bot to join')
        self.assertRegexp('join', 'not a valid command')
        self.assertHelp('testcommand')

    @skip('Nested commands cannot be renamed yet.')
    def testRenameNested(self):
        self.assertNotError('rename Admin "capability remove" rmcap')
        self.assertNotRegexp('list Admin', 'capability remove')
        self.assertRegexp('list Admin', 'rmcap')
        self.assertNotError('reload Admin')
        self.assertNotRegexp('list Admin', 'capability remove')
        self.assertRegexp('list Admin', 'rmcap')
        self.assertNotError('unrename Admin')
        self.assertRegexp('list Admin', 'capability remove')
        self.assertNotRegexp('list Admin', 'rmcap')

    def testDefaultPluginErrorsWhenCommandNotInPlugin(self):
        self.assertError('defaultplugin foobar owner')


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Plugin')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Plugin', True)


Plugin = conf.registerPlugin('Plugin')
# This is where your configuration variables (if any) should go.  For example:
# conf.registerGlobalValue(Plugin, 'someConfigVariableName',
#     registry.Boolean(False, """Help for someConfigVariableName."""))


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot

import supybot.utils as utils
from supybot.commands import *
import supybot.plugins as plugins
import supybot.ircutils as ircutils
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Plugin')


class Plugin(callbacks.Plugin):
    """This plugin exists to help users manage their plugins.  Use 'plugin
    list' to list the loaded plugins; use 'plugin help' to get the description
    of a plugin; use the 'plugin' command itself to determine what plugin a
    command exists in."""
    @internationalizeDocstring
    def help(self, irc, msg, args, cb):
        """<plugin>

        Returns a useful description of how to use <plugin>, if the plugin has
        one.
        """
        doc = cb.getPluginHelp()
        if doc:
            irc.reply(utils.str.normalizeWhitespace(doc))
        else:
            irc.reply(_('That plugin is loaded, but has no plugin help.'))
    help = wrap(help, ['plugin'])

    @internationalizeDocstring
    def plugin(self, irc, msg, args, command):
        """<command>

        Returns the name of the plugin that would be used to call <command>.
        
        If it is not uniquely determined, returns list of all plugins that
        contain <command>.
        """
        (maxL, cbs) = irc.findCallbacksForArgs(command)
        L = []
        if maxL == command:
            for cb in cbs:
                L.append(cb.name())
        command = callbacks.formatCommand(command)
        if L:
            if irc.nested:
                irc.reply(format('%L', L))
            else:
                if len(L) > 1:
                    plugin = _('plugins')
                else:
                    plugin = _('plugin')
                irc.reply(format(_('The %q command is available in the %L '
                                 '%s.'), command, L, plugin))
        else:
            irc.error(format(_('There is no command %q.'), command))
    plugin = wrap(plugin, [many('something')])

    def _findCallbacks(self, irc, command):
        command = list(map(callbacks.canonicalName, command))
        plugin_list = []
        for cb in irc.callbacks:
            if not hasattr(cb, 'getCommand'):
                continue
            commandlist = cb.getCommand(command)
            if commandlist:
                plugin_list.append(cb.name())
        return plugin_list

    @internationalizeDocstring
    def plugins(self, irc, msg, args, command):
        """<command>

        Returns the names of all plugins that contain <command>.
        """
        L = self._findCallbacks(irc, command)
        command = callbacks.formatCommand(command)
        if L:
            if irc.nested:
                irc.reply(format('%L', L))
            else:
                if len(L) > 1:
                    plugin = 'plugins'
                else:
                    plugin = 'plugin'
                irc.reply(format('The %q command is available in the %L %s.',
                                 command, L, plugin))
        else:
            irc.error(format('There is no command %q.', command))
    plugins = wrap(plugins, [many('something')])

    def author(self, irc, msg, args, cb):
        """<plugin>

        Returns the author of <plugin>.  This is the person you should talk to
        if you have ideas, suggestions, or other comments about a given plugin.
        """
        if cb is None:
            irc.error(_('That plugin does not seem to be loaded.'))
            return
        module = cb.classModule
        if hasattr(module, '__author__') and module.__author__:
            irc.reply(str(module.__author__))
        else:
            irc.reply(_('That plugin doesn\'t have an author that claims it.'))
    author = wrap(author, [('plugin')])

    @internationalizeDocstring
    def contributors(self, irc, msg, args, cb, nick):
        """<plugin> [<nick>]

        Replies with a list of people who made contributions to a given plugin.
        If <nick> is specified, that person's specific contributions will
        be listed.  Note: The <nick> is the part inside of the parentheses
        in the people listing.
        """
        def getShortName(authorInfo):
            """
            Take an Authors object, and return only the name and nick values
            in the format 'First Last (nick)'.
            """
            return '%(name)s (%(nick)s)' % authorInfo.__dict__
        def buildContributorsString(longList):
            """
            Take a list of long names and turn it into :
            shortname[, shortname and shortname].
            """
            L = [getShortName(n) for n in longList]
            return format('%L', L)
        def sortAuthors():
            """
            Sort the list of 'long names' based on the number of contributions
            associated with each.
            """
            L = module.__contributors__.items()
            def negativeSecondElement(x):
                return -len(x[1])
            utils.sortBy(negativeSecondElement, L)
            return [t[0] for t in L]
        def buildPeopleString(module):
            """
            Build the list of author + contributors (if any) for the requested
            plugin.
            """
            head = _('The %s plugin') % cb.name()
            author = _('has not been claimed by an author')
            conjunction = _('and')
            contrib = _('has no contributors listed.')
            hasAuthor = False
            hasContribs = False
            if hasattr(module, '__author__'):
                if module.__author__ != supybot.authors.unknown:
                    author = _('was written by %s') % \
                        utils.web.mungeEmail(str(module.__author__))
                    hasAuthor = True
            if hasattr(module, '__contributors__'):
                contribs = sortAuthors()
                if hasAuthor:
                    try:
                        contribs.remove(module.__author__)
                    except ValueError:
                        pass
                if contribs:
                    contrib = format(_('%s %h contributed to it.'),
                                     buildContributorsString(contribs),
                                     len(contribs))
                    hasContribs = True
                elif hasAuthor:
                    contrib = _('has no additional contributors listed.')
            if hasContribs and not hasAuthor:
                conjunction = _('but')
            return ' '.join([head, author, conjunction, contrib])
        def buildPersonString(module):
            """
            Build the list of contributions (if any) for the requested person
            for the requested plugin
            """
            isAuthor = False
            authorInfo = None
            moduleContribs = module.__contributors__.keys()
            lnick = nick.lower()
            for contrib in moduleContribs:
                if contrib.nick.lower() == lnick:
                    authorInfo = contrib
                    break
            authorInfo = authorInfo or getattr(supybot.authors, nick, None)
            if not authorInfo:
                return _('The nick specified (%s) is not a registered '
                       'contributor.') % nick
            fullName = utils.web.mungeEmail(str(authorInfo))
            contributions = []
            if hasattr(module, '__contributors__'):
                if authorInfo not in module.__contributors__:
                    return _('The %s plugin does not have \'%s\' listed as a '
                           'contributor.') % (cb.name(), nick)
                contributions = module.__contributors__[authorInfo]
            isAuthor = getattr(module, '__author__', False) == authorInfo
            (nonCommands, commands) = utils.iter.partition(lambda s: ' ' in s,
                                                           contributions)
            results = []
            if commands:
                s = _('command')
                if len(commands) > 1:
                    s = utils.str.pluralize(s)
                results.append(format(_('the %L %s'), commands, s))
            if nonCommands:
                results.append(format(_('the %L'), nonCommands))
            if results and isAuthor:
                return format(
                        _('%s wrote the %s plugin and also contributed %L.'),
                        (fullName, cb.name(), results))
            elif results and not isAuthor:
                return format(_('%s contributed %L to the %s plugin.'),
                              fullName, results, cb.name())
            elif isAuthor and not results:
                return _('%s wrote the %s plugin') % (fullName, cb.name())
            # XXX Does this ever actually get reached?
            else:
                return _('%s has no listed contributions for the %s '
                         'plugin.') % (fullName, cb.name())
        # First we need to check and see if the requested plugin is loaded
        module = cb.classModule
        if not nick:
            irc.reply(buildPeopleString(module))
        else:
            nick = ircutils.toLower(nick)
            irc.reply(buildPersonString(module))
    contributors = wrap(contributors, ['plugin', additional('nick')])
Plugin = internationalizeDocstring(Plugin)

Class = Plugin

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

class PluginTestCase(PluginTestCase):
    plugins = ('Plugin', 'Utilities', 'Admin', 'Format')
    def testPlugin(self):
        self.assertRegexp('plugin ignore', 'available.*Utilities plugin')
        self.assertResponse('echo [plugin ignore]', 'Utilities')
    
    def testPlugins(self):
        self.assertRegexp('plugins join', '(Format.*Admin|Admin.*Format)')
        self.assertRegexp('plugins plugin', 'Plugin')

    def testHelp(self):
        self.assertRegexp('plugin help plugin', 'manage their plugins')

    def testAuthor(self):
        self.assertRegexp('plugin author plugin', 'jemfinch')

    def testContributors(self):
        # Test ability to list contributors
        self.assertNotError('contributors Plugin')
        # Test ability to list contributions
        # Verify that when a single command contribution has been made,
        # the word "command" is properly not pluralized.
        # Note: This will break if the listed person ever makes more than
        # one contribution to the Plugin plugin
        self.assertRegexp('contributors Plugin skorobeus', 'command')
        # Test handling of pluralization of "command" when person has
        # contributed more than one command to the plugin.
        # -- Need to create this case, check it with the regexp 'commands'
        # Test handling of invalid plugin
        self.assertRegexp('contributors InvalidPlugin', 'not a valid plugin')
        # Test handling of invalid person
        self.assertRegexp('contributors Plugin noname',
                          'not a registered contributor')
        # Test handling of valid person with no contributions
        # Note: This will break if the listed person ever makes a contribution
        # to the Plugin plugin
        self.assertRegexp('contributors Plugin bwp',
                          'listed as a contributor')

    def testContributorsIsCaseInsensitive(self):
        self.assertNotError('contributors Plugin Skorobeus')
        self.assertNotError('contributors Plugin sKoRoBeUs')


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2011, Valentin Lorentz
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring

_ = PluginInternationalization('PluginDownloader')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('PluginDownloader', True)


PluginDownloader = conf.registerPlugin('PluginDownloader')
# This is where your configuration variables (if any) should go.  For example:
# conf.registerGlobalValue(PluginDownloader, 'someConfigVariableName',
#     registry.Boolean(False, _("""Help for someConfigVariableName.""")))


# vim:set shiftwidth=4 tabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2011, Valentin Lorentz
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

###

import os
import io
import sys
import json
import shutil
import urllib
import urllib2
import tarfile
from cStringIO import StringIO

BytesIO = StringIO if sys.version_info[0] < 3 else io.BytesIO

import supybot.log as log
import supybot.conf as conf
import supybot.utils as utils
from supybot.commands import *
import supybot.plugins as plugins
import supybot.ircutils as ircutils
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring

_ = PluginInternationalization('PluginDownloader')

class Repository:
    pass

class VersionnedRepository(Repository):
    pass

class GitRepository(VersionnedRepository):
    pass

class GithubRepository(GitRepository):
    def __init__(self, username, reponame, path='/'):
        self._username = username
        self._reponame = reponame
        if not path.startswith('/'):
            path = '/' + path
        if not path.endswith('/'):
            path += '/'
        self._path = path

        self._downloadUrl = 'https://github.com/%s/%s/tarball/master' % \
                            (
                            self._username,
                            self._reponame,
                            )


    _apiUrl = 'https://api.github.com'
    def _query(self, type_, uri_end, args={}):
        args = dict([(x,y) for x,y in args.items() if y is not None])
        url = '%s/%s/%s?%s' % (self._apiUrl, type_, uri_end,
                               urllib.urlencode(args))
        return json.loads(utils.web.getUrl(url).decode('utf8'))

    def getPluginList(self):
        plugins = self._query(
                                  'repos',
                                  '%s/%s/contents%s' % (
                                                          self._username,
                                                          self._reponame,
                                                          self._path,
                                                          )
                                  )
        if plugins is None:
            log.error((
                      'Cannot get plugins list from repository %s/%s '
                      'at Github'
                      ) % (self._username, self._reponame))
            return []
        plugins = [x['name'] for x in plugins if x['type'] == 'dir']
        return plugins

    def _download(self, plugin):
        try:
            response = utils.web.getUrlFd(self._downloadUrl)
            if sys.version_info[0] < 3:
                assert response.getcode() == 200, response.getcode()
            else:
                assert response.status == 200, response.status
            fileObject = BytesIO()
            fileObject.write(response.read())
        finally: # urllib does not handle 'with' statements :(
            response.close()
        fileObject.seek(0)
        return tarfile.open(fileobj=fileObject, mode='r:gz')
    def install(self, plugin):
        archive = self._download(plugin)
        prefix = archive.getnames()[0]
        dirname = ''.join((self._path, plugin))
        directories = conf.supybot.directories.plugins()
        directory = self._getWritableDirectoryFromList(directories)
        assert directory is not None, \
                'No valid directory in supybot.directories.plugins.'

        try:
            assert archive.getmember(prefix + dirname).isdir(), \
                'This is not a valid plugin (it is a file, not a directory).'

            run_2to3 = sys.version_info[0] >= 3
            for file in archive.getmembers():
                if file.name.startswith(prefix + dirname):
                    extractedFile = archive.extractfile(file)
                    newFileName = os.path.join(*file.name.split('/')[1:])
                    newFileName = newFileName[len(self._path)-1:]
                    newFileName = os.path.join(directory, newFileName)
                    if os.path.exists(newFileName):
                        assert os.path.isdir(newFileName), newFileName + \
                                'should not be a file.'
                        shutil.rmtree(newFileName)
                    if extractedFile is None:
                        os.mkdir(newFileName)
                    else:
                        with open(newFileName, 'ab') as fd:
                            reload_imported = False
                            for line in extractedFile.readlines():
                                if sys.version_info[0] >= 3:
                                    if 'import reload' in line.decode():
                                        reload_imported = True
                                    elif not reload_imported and \
                                            'reload(' in line.decode():
                                        fd.write('from imp import reload\n' \
                                                .encode())
                                        reload_imported = True
                                fd.write(line)
                    if newFileName.endswith('__init__.py'):
                        with open(newFileName) as fd:
                            lines = list(filter(lambda x:'import plugin' in x,
                                fd.readlines()))
                            if lines and lines[0].startswith('from . import'):
                                # This should be already Python 3-compatible
                                run_2to3 = False
        finally:
            archive.close()
            del archive
        if run_2to3:
            try:
                import lib2to3
            except ImportError:
                return _('Plugin is probably not compatible with your '
                        'Python version (3.x) and could not be converted '
                        'because 2to3 is not installed.')
            import subprocess
            fixers = []
            subprocess.Popen(['2to3', '-wn', os.path.join(directory, plugin)]) \
                    .wait()
            return _('Plugin was designed for Python 2, but an attempt to '
                    'convert it to Python 3 has been made. There is no '
                    'garantee it will work, though.')
        else:
            return _('Plugin successfully installed.')

    def getInfo(self, plugin):
        archive = self._download(plugin)
        prefix = archive.getnames()[0]
        dirname = ''.join((self._path, plugin))
        for file in archive.getmembers():
            if file.name.startswith(prefix + dirname + '/README'):
                extractedFile = archive.extractfile(file)
                content = extractedFile.read()
                if sys.version_info[0] >= 3:
                    content = content.decode()
                return content

    def _getWritableDirectoryFromList(self, directories):
        for directory in directories:
            if os.access(directory, os.W_OK):
                return directory
        return None


repositories = {
               'ProgVal':          GithubRepository(
                                                   'ProgVal',
                                                   'Supybot-plugins'
                                                   ),
               'quantumlemur':     GithubRepository(
                                                   'quantumlemur',
                                                   'Supybot-plugins',
                                                   ),
               'stepnem':          GithubRepository(
                                                   'stepnem',
                                                   'supybot-plugins',
                                                   ),
               'code4lib-snapshot':GithubRepository(
                                                   'code4lib',
                                                   'supybot-plugins',
                                                   'Supybot-plugins-20060723',
                                                   ),
               'code4lib-edsu':    GithubRepository(
                                                   'code4lib',
                                                   'supybot-plugins',
                                                   'edsu-plugins',
                                                   ),
               'code4lib':         GithubRepository(
                                                   'code4lib',
                                                   'supybot-plugins',
                                                   'plugins',
                                                   ),
               'nanotube-bitcoin': GithubRepository(
                                                   'nanotube',
                                                   'supybot-bitcoin-'
                                                             'marketmonitor',
                                                   ),
               'mtughan-weather':  GithubRepository(
                                                   'mtughan',
                                                   'Supybot-Weather',
                                                   ),
               'SpiderDave':       GithubRepository(
                                                   'SpiderDave',
                                                   'spidey-supybot-plugins',
                                                   'Plugins',
                                                   ),
               'Antibody':         GithubRepository(
                                                   'Antibody',
                                                   'supybot-plugins',
                                                   ),
               'doorbot':          GithubRepository(
                                                   'hacklab',
                                                   'doorbot',
                                                   ),
               'boombot':          GithubRepository(
                                                   'nod',
                                                   'boombot',
                                                   'plugins',
                                                   ),
               'mailed-notifier':  GithubRepository(
                                                   'tbielawa',
                                                   'supybot-mailed-notifier',
                                                   ),
               'pingdom':          GithubRepository(
                                                   'rynop',
                                                   'supyPingdom',
                                                   'plugins',
                                                   ),
               'scrum':            GithubRepository(
                                                   'amscanne',
                                                   'supybot-scrum',
                                                   ),
               'Hoaas':            GithubRepository(
                                                   'Hoaas',
                                                   'Supybot-plugins'
                                                   ),
               'nyuszika7h':       GithubRepository(
                                                   'nyuszika7h',
                                                   'limnoria-plugins'
                                                   ),
               'nyuszika7h-old':   GithubRepository(
                                                   'nyuszika7h',
                                                   'Supybot-plugins'
                                                   ),
               'resistivecorpse':  GithubRepository(
                                                   'resistivecorpse',
                                                   'supybot-plugins'
                                                   ),
               'frumious':         GithubRepository(
                                                   'frumiousbandersnatch',
                                                   'sobrieti-plugins',
                                                   'plugins',
                                                   ),
               'jonimoose':        GithubRepository(
                                                   'Jonimoose',
                                                   'Supybot-plugins',
                                                   ),
               'skgsergio':        GithubRepository(
                                                   'skgsergio',
                                                   'Limnoria-plugins',
                                                   ),
               'GLolol':           GithubRepository(
                                                   'GLolol',
                                                   'SupyPlugins',
                                                   ),
               'Iota':             GithubRepository(
                                                   'IotaSpencer',
                                                   'supyplugins',
                                                   ),
               }

class PluginDownloader(callbacks.Plugin):
    """This plugin allows you to install unofficial plugins from
    multiple repositories easily. Use the "repolist" command to see list of
    available repositories and "repolist <repository>" to list plugins, 
    which are available in that repository. When you want to install plugin,
    just run command "install <repository> <plugin>"."""

    threaded = True

    @internationalizeDocstring
    def repolist(self, irc, msg, args, repository):
        """[<repository>]

        Displays the list of plugins in the <repository>.
        If <repository> is not given, returns a list of available
        repositories."""

        global repositories
        if repository is None:
            irc.reply(_(', ').join([x for x in repositories]))
        elif repository not in repositories:
            irc.error(_(
                       'This repository does not exist or is not known by '
                       'this bot.'
                       ))
        else:
            plugins = repositories[repository].getPluginList()
            if plugins == []:
                irc.error(_('No plugin found in this repository.'))
            else:
                irc.reply(_(', ').join([x for x in plugins]))
    repolist = wrap(repolist, [optional('something')])

    @internationalizeDocstring
    def install(self, irc, msg, args, repository, plugin):
        """<repository> <plugin>

        Downloads and installs the <plugin> from the <repository>."""
        global repositories
        if repository not in repositories:
            irc.error(_(
                       'This repository does not exist or is not known by '
                       'this bot.'
                       ))
        elif plugin not in repositories[repository].getPluginList():
            irc.error(_('This plugin does not exist in this repository.'))
        else:
            try:
                irc.reply(repositories[repository].install(plugin))
            except Exception as e:
                import traceback
                traceback.print_exc()
                log.error(str(e))
                irc.error('The plugin could not be installed. Check the logs '
                        'for a more detailed error.')

    install = wrap(install, ['owner', 'something', 'something'])

    @internationalizeDocstring
    def info(self, irc, msg, args, repository, plugin):
        """<repository> <plugin>

        Displays informations on the <plugin> in the <repository>."""
        global repositories
        if repository not in repositories:
            irc.error(_(
                       'This repository does not exist or is not known by '
                       'this bot.'
                       ))
        elif plugin not in repositories[repository].getPluginList():
            irc.error(_('This plugin does not exist in this repository.'))
        else:
            info = repositories[repository].getInfo(plugin)
            if info is None:
                irc.error(_('No README found for this plugin'))
            else:
                if info.startswith('Insert a description of your plugin here'):
                    irc.error(_('This plugin has no description.'))
                else:
                    info = info.split('\n\n')[0]
                    irc.reply(info.replace('\n', ' '))
    info = wrap(info, ['something', optional('something')])


PluginDownloader = internationalizeDocstring(PluginDownloader)
Class = PluginDownloader


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2011, Valentin Lorentz
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

###

import os
import sys
import shutil

from supybot.test import *

pluginsPath = '%s/test-plugins' % os.getcwd()

class PluginDownloaderTestCase(PluginTestCase):
    plugins = ('PluginDownloader',)
    config = {'supybot.directories.plugins': [pluginsPath]}

    def setUp(self):
        PluginTestCase.setUp(self)
        try:
            shutil.rmtree(pluginsPath)
        except:
            pass
        os.mkdir(pluginsPath)

    def tearDown(self):
        try:
            shutil.rmtree(pluginsPath)
        finally:
            PluginTestCase.tearDown(self)

    def _testPluginInstalled(self, name):
        assert os.path.isdir(pluginsPath + '/%s/' % name)
        assert os.path.isfile(pluginsPath + '/%s/plugin.py' % name)
        assert os.path.isfile(pluginsPath + '/%s/config.py' % name)

    def testRepolist(self):
        self.assertRegexp('repolist', '(.*, )?ProgVal(, .*)?')
        self.assertRegexp('repolist', '(.*, )?quantumlemur(, .*)?')
        self.assertRegexp('repolist ProgVal', '(.*, )?AttackProtector(, .*)?')

    def testInstallProgVal(self):
        self.assertError('plugindownloader install ProgVal Darcs')
        self.assertNotError('plugindownloader install ProgVal AttackProtector')
        self.assertError('plugindownloader install ProgVal Darcs')
        self._testPluginInstalled('AttackProtector')

    def testInstallQuantumlemur(self):
        self.assertError('plugindownloader install quantumlemur AttackProtector')
        self.assertNotError('plugindownloader install quantumlemur Listener')
        self.assertError('plugindownloader install quantumlemur AttackProtector')
        self._testPluginInstalled('Listener')

    def testInstallStepnem(self):
        self.assertNotError('plugindownloader install stepnem Freenode')
        self._testPluginInstalled('Freenode')

    def testInstallNanotubeBitcoin(self):
        self.assertNotError('plugindownloader install nanotube-bitcoin GPG')
        self._testPluginInstalled('GPG')

    def testInstallMtughanWeather(self):
        self.assertNotError('plugindownloader install mtughan-weather '
                            'WunderWeather')
        self._testPluginInstalled('WunderWeather')

    def testInstallSpiderDave(self):
        self.assertNotError('plugindownloader install SpiderDave Pastebin')
        self._testPluginInstalled('Pastebin')

    def testInfo(self):
        self.assertResponse('plugindownloader info ProgVal Twitter',
                'Advanced Twitter plugin for Supybot, with capabilities '
                'handling, and per-channel user account.')

    if sys.version_info[0] >= 3:
        def test_2to3(self):
            self.assertRegexp('plugindownloader install SpiderDave Pastebin',
                    'convert')
            self.assertNotError('load Pastebin')

if not network:
    class PluginDownloaderTestCase(PluginTestCase):
        pass

# vim:set shiftwidth=4 tabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2005, Daniel DiPaolo
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Praise')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Praise', True)


Praise = conf.registerPlugin('Praise')
# This is where your configuration variables (if any) should go.  For example:
# conf.registerGlobalValue(Praise, 'someConfigVariableName',
#     registry.Boolean(False, _("""Help for someConfigVariableName.""")))
conf.registerChannelValue(Praise, 'showIds',
    registry.Boolean(False, _("""Determines whether the bot will show the ids of
    a praise when the praise is given.""")))


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2005, Daniel DiPaolo
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import re

from supybot.commands import *
import supybot.plugins as plugins
import supybot.ircutils as ircutils
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Praise')

class Praise(plugins.ChannelIdDatabasePlugin):
    """Praise is a plugin for ... well, praising things.  Feel free to add
    your own flavor to it by customizing what praises it gives.  Use "praise
    add <text>" to add new ones, making sure to include "$who" in <text> where
    you want to insert the thing being praised.
    """
    _meRe = re.compile(r'\bme\b', re.I)
    _myRe = re.compile(r'\bmy\b', re.I)
    def _replaceFirstPerson(self, s, nick):
        s = self._meRe.sub(nick, s)
        s = self._myRe.sub('%s\'s' % nick, s)
        return s

    def addValidator(self, irc, text):
        if '$who' not in text:
            irc.error(_('Praises must contain $who.'), Raise=True)

    @internationalizeDocstring
    def praise(self, irc, msg, args, channel, id, text):
        """[<channel>] [<id>] <who|what> [for <reason>]

        Praises <who|what> (for <reason>, if given).  If <id> is given, uses
        that specific praise.  <channel> is only necessary if the message isn't
        sent in the channel itself.
        """
        if ' for ' in text:
            (target, reason) = list(map(str.strip, text.split(' for ', 1)))
        else:
            (target, reason) = (text, '')
        if ircutils.strEqual(target, irc.nick):
            target = 'itself'
        if id is not None:
            try:
                praise = self.db.get(channel, id)
            except KeyError:
                irc.error(format(_('There is no praise with id #%i.'), id))
                return
        else:
            praise = self.db.random(channel)
            if not praise:
                irc.error(format(_('There are no praises in my database ' \
                                 'for %s.'), channel))
                return
        text = self._replaceFirstPerson(praise.text, msg.nick)
        reason = self._replaceFirstPerson(reason, msg.nick)
        target = self._replaceFirstPerson(target, msg.nick)
        text = text.replace('$who', target)
        if reason:
            text += _(' for ') + reason
        if self.registryValue('showIds', channel):
            text += format(' (#%i)', praise.id)
        irc.reply(text, action=True)
    praise = wrap(praise, ['channeldb', optional('id'), 'text'])
Praise = internationalizeDocstring(Praise)

Class = Praise

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2005, Daniel DiPaolo
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

class PraiseTestCase(PluginTestCase):
    plugins = ('Praise',)
    
    def testAdd(self):
        self.assertError('praise add foo')  # needs $who

    def testPraise(self):
        self.assertError('praise foo')  # no praises!

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.ircutils as ircutils
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Protector')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Protector', True)


Protector = conf.registerPlugin('Protector')
conf.registerChannelValue(Protector, 'enable',
    registry.Boolean(False, _("""Determines whether this plugin is enabled in a
    given channel.""")))

class ImmuneNicks(conf.ValidNicks):
    List = ircutils.IrcSet

conf.registerChannelValue(Protector, 'immune',
    ImmuneNicks([], _("""Determines what nicks the bot will consider to
    be immune from enforcement.  These nicks will not even have their actions
    watched by this plugin.  In general, only the ChanServ for this network
    will be in this list.""")))



# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2004, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.utils as utils
import supybot.ircdb as ircdb
import supybot.ircmsgs as ircmsgs
import supybot.ircutils as ircutils
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Protector')

class Protector(callbacks.Plugin):
    def isImmune(self, irc, msg):
        if not ircutils.isUserHostmask(msg.prefix):
            self.log.debug('%q is immune, it\'s a server.', msg)
            return True # It's a server prefix.
        if ircutils.strEqual(msg.nick, irc.nick):
            self.log.debug('%q is immune, it\'s me.', msg)
            return True # It's the bot itself.
        if msg.nick in self.registryValue('immune', msg.args[0]):
            self.log.debug('%q is immune, it\'s configured to be immune.', msg)
            return True
        return False

    def isOp(self, irc, channel, hostmask):
        cap = ircdb.makeChannelCapability(channel, 'op')
        if ircdb.checkCapability(hostmask, cap):
            self.log.debug('%s is an op on %s, it has %s.',
                           hostmask, channel, cap)
            return True
        if ircutils.strEqual(hostmask, irc.prefix):
            return True
        return False

    def isProtected(self, irc, channel, hostmask):
        cap = ircdb.makeChannelCapability(channel, 'protected')
        if ircdb.checkCapability(hostmask, cap):
            self.log.debug('%s is protected on %s, it has %s.',
                           hostmask, channel, cap)
            return True
        if ircutils.strEqual(hostmask, irc.prefix):
            return True
        return False

    def demote(self, irc, channel, nick):
        irc.queueMsg(ircmsgs.deop(channel, nick))

    def __call__(self, irc, msg):
        def ignore(reason):
            self.log.debug('Ignoring %q, %s.', msg, reason)
        if not msg.args:
            ignore('no msg.args')
        elif not irc.isChannel(msg.args[0]):
            ignore('not on a channel')
        elif not self.registryValue('enable', msg.args[0]):
            ignore('supybot.plugins.Protector.enable is False.')
        elif msg.args[0] not in irc.state.channels:
            # One has to wonder how this would happen, but just in case...
            ignore('bot isn\'t in channel')
        elif irc.nick not in irc.state.channels[msg.args[0]].ops:
            ignore('bot is not opped')
        elif msg.nick not in irc.state.channels[msg.args[0]].users:
            ignore('sender is not in channel (ChanServ, maybe?)')
        elif msg.nick not in irc.state.channels[msg.args[0]].ops:
            ignore('sender is not an op in channel (IRCOP, maybe?)')
        elif self.isImmune(irc, msg):
            ignore('sender is immune')
        else:
            super(Protector, self).__call__(irc, msg)

    def doMode(self, irc, msg):
        channel = msg.args[0]
        chanOp = ircdb.makeChannelCapability(channel, 'op')
        chanVoice = ircdb.makeChannelCapability(channel, 'voice')
        chanHalfOp = ircdb.makeChannelCapability(channel, 'halfop')
        if not ircdb.checkCapability(msg.prefix, chanOp):
            irc.sendMsg(ircmsgs.deop(channel, msg.nick))
        for (mode, value) in ircutils.separateModes(msg.args[1:]):
            if not value:
                continue
            if ircutils.strEqual(value, msg.nick):
                # We allow someone to mode themselves to oblivion.
                continue
            if irc.isNick(value):
                hostmask = irc.state.nickToHostmask(value)
                if mode == '+o':
                    if not self.isOp(irc, channel, hostmask):
                        irc.queueMsg(ircmsgs.deop(channel, value))
                elif mode == '+h':
                    if not ircdb.checkCapability(hostmask, chanHalfOp):
                         irc.queueMsg(ircmsgs.dehalfop(channel, value))
                elif mode == '+v':
                    if not ircdb.checkCapability(hostmask, chanVoice):
                        irc.queueMsg(ircmsgs.devoice(channel, value))
                elif mode == '-o':
                    if ircdb.checkCapability(hostmask, chanOp):
                        irc.queueMsg(ircmsgs.op(channel, value))
                elif mode == '-h':
                    if ircdb.checkCapability(hostmask, chanOp):
                        irc.queueMsg(ircmsgs.halfop(channel, value))
                elif mode == '-v':
                    if ircdb.checkCapability(hostmask, chanOp):
                        irc.queueMsg(ircmsgs.voice(channel, value))
            else:
                assert ircutils.isUserHostmask(value)
                # Handle bans.

    def doKick(self, irc, msg):
        channel = msg.args[0]
        kicked = msg.args[1].split(',')
        protected = []
        for nick in kicked:
            if ircutils.strEqual(nick, irc.nick):
                return # Channel will handle the rejoin.
        for nick in kicked:
            hostmask = irc.state.nickToHostmask(nick)
            if self.isProtected(irc, channel, hostmask):
                self.log.info('%s was kicked from %s and is protected; '
                              'inviting back.', hostmask, channel)
                hostmask = '%s!%s' % (nick, irc.state.nickToHostmask(nick))
                protected.append(nick)
                bans = []
                for banmask in irc.state.channels[channel].bans:
                    if ircutils.hostmaskPatternEqual(banmask, hostmask):
                        bans.append(banmask)
                irc.queueMsg(ircmsgs.unbans(channel, bans))
                irc.queueMsg(ircmsgs.invite(nick, channel))
        if not self.isOp(irc, channel, msg.prefix):
            self.demote(irc, channel, msg.nick)


Class = Protector

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

class ProtectorTestCase(PluginTestCase):
    plugins = ('Protector',)


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2005, Daniel DiPaolo
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Quote')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Quote', True)


Quote = conf.registerPlugin('Quote')
# This is where your configuration variables (if any) should go.  For example:
# conf.registerGlobalValue(Quote, 'someConfigVariableName',
#     registry.Boolean(False, _("""Help for someConfigVariableName.""")))


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2005, Daniel DiPaolo
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.commands import *
import supybot.plugins as plugins
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Quote')

class Quote(plugins.ChannelIdDatabasePlugin):
    @internationalizeDocstring
    def random(self, irc, msg, args, channel):
        """[<channel>]

        Returns a random quote from <channel>.  <channel> is only necessary if
        the message isn't sent in the channel itself.
        """
        quote = self.db.random(channel)
        if quote:
            irc.reply(self.showRecord(quote))
        else:
            irc.error(_('I have no quotes in my database for %s.') % channel)
    random = wrap(random, ['channeldb'])

Class = Quote

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2005, Daniel DiPaolo
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

class QuoteTestCase(PluginTestCase):
    plugins = ('Quote',)


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2004, Daniel DiPaolo
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('QuoteGrabs')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('QuoteGrabs', True)


QuoteGrabs = conf.registerPlugin('QuoteGrabs')
# This is where your configuration variables (if any) should go.  For example:
# conf.registerGlobalValue(QuoteGrabs, 'someConfigVariableName',
#     registry.Boolean(False, _("""Help for someConfigVariableName.""")))
conf.registerChannelValue(conf.supybot.plugins.QuoteGrabs, 'randomGrabber',
    registry.Boolean(False, _("""Determines whether the bot will randomly grab
    possibly-suitable quotes on occasion.  The suitability of a given message
    is determined by ...""")))
conf.registerChannelValue(conf.supybot.plugins.QuoteGrabs.randomGrabber,
    'averageTimeBetweenGrabs',
    registry.PositiveInteger(864000, _("""Determines about how many seconds, on
    average, should elapse between random grabs.  This is only an average
    value; grabs can happen from any time after half this time until never,
    although that's unlikely to occur.""")))
conf.registerChannelValue(conf.supybot.plugins.QuoteGrabs.randomGrabber,
    'minimumWords', registry.PositiveInteger(3, _("""Determines the minimum
    number of words in a message for it to be considered for random
    grabbing.""")))
conf.registerChannelValue(conf.supybot.plugins.QuoteGrabs.randomGrabber,
    'minimumCharacters', registry.PositiveInteger(8, _("""Determines the
    minimum number of characters in a message for it to be considered for
    random grabbing.""")))

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2004, Daniel DiPaolo
# Copyright (c) 2008-2010, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import os
import time
import random

import supybot.dbi as dbi
import supybot.conf as conf
import supybot.utils as utils
from supybot.commands import *
import supybot.ircmsgs as ircmsgs
import supybot.plugins as plugins
import supybot.ircutils as ircutils
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('QuoteGrabs')

import sqlite3

import traceback

#sqlite3.register_converter('bool', bool)

class QuoteGrabsRecord(dbi.Record):
    __fields__ = [
        'by',
        'text',
        'grabber',
        'at',
        'hostmask',
        ]

    def __str__(self):
        grabber = plugins.getUserName(self.grabber)
        return format(_('%s (Said by: %s; grabbed by %s at %t)'),
                      self.text, self.hostmask, grabber, self.at)

class SqliteQuoteGrabsDB(object):
    def __init__(self, filename):
        self.dbs = ircutils.IrcDict()
        self.filename = filename

    def close(self):
        for db in self.dbs.itervalues():
            db.close()

    def _getDb(self, channel):
        filename = plugins.makeChannelFilename(self.filename, channel)
        def p(s1, s2):
            # text_factory seems to only apply as an output adapter,
            # so doesn't apply to created functions; so we use str()
            return ircutils.nickEqual(str(s1), str(s2))
        if filename in self.dbs:
            return self.dbs[filename]
        if os.path.exists(filename):
            db = sqlite3.connect(filename)
            db.text_factory = str
            db.create_function('nickeq', 2, p)
            self.dbs[filename] = db
            return db
        db = sqlite3.connect(filename)
        db.text_factory = str
        db.create_function('nickeq', 2, p)
        self.dbs[filename] = db
        cursor = db.cursor()
        cursor.execute("""CREATE TABLE quotegrabs (
                          id INTEGER PRIMARY KEY,
                          nick BLOB,
                          hostmask TEXT,
                          added_by TEXT,
                          added_at TIMESTAMP,
                          quote TEXT
                          );""")
        db.commit()
        return db

    def get(self, channel, id):
        db = self._getDb(channel)
        cursor = db.cursor()
        cursor.execute("""SELECT id, nick, quote, hostmask, added_at, added_by
                          FROM quotegrabs WHERE id = ?""", (id,))
        results = cursor.fetchall()
        if len(results) == 0:
            raise dbi.NoRecordError
        (id, by, quote, hostmask, at, grabber) = results[0]
        return QuoteGrabsRecord(id, by=by, text=quote, hostmask=hostmask,
                                at=int(at), grabber=grabber)

    def random(self, channel, nick):
        db = self._getDb(channel)
        cursor = db.cursor()
        if nick:
            cursor.execute("""SELECT quote FROM quotegrabs
                              WHERE nickeq(nick, ?)
                              ORDER BY random() LIMIT 1""",
                              (nick,))
        else:
            cursor.execute("""SELECT quote FROM quotegrabs
                              ORDER BY random() LIMIT 1""")
        results = cursor.fetchall()
        if len(results) == 0:
            raise dbi.NoRecordError
        return results[0][0]

    def list(self, channel, nick):
        db = self._getDb(channel)
        cursor = db.cursor()
        cursor.execute("""SELECT id, quote FROM quotegrabs
                          WHERE nickeq(nick, ?)
                          ORDER BY id DESC""", (nick,))
        results = cursor.fetchall()
        if len(results) == 0:
            raise dbi.NoRecordError
        return [QuoteGrabsRecord(id, text=quote)
                for (id, quote) in results]

    def getQuote(self, channel, nick):
        db = self._getDb(channel)
        cursor = db.cursor()
        cursor.execute("""SELECT quote FROM quotegrabs
                          WHERE nickeq(nick, ?)
                          ORDER BY id DESC LIMIT 1""", (nick,))
        results = cursor.fetchall()
        if len(results) == 0:
            raise dbi.NoRecordError
        return results[0][0]

    def select(self, channel, nick):
        db = self._getDb(channel)
        cursor = db.cursor()
        cursor.execute("""SELECT added_at FROM quotegrabs
                          WHERE nickeq(nick, ?)
                          ORDER BY id DESC LIMIT 1""", (nick,))
        results = cursor.fetchall()
        if len(results) == 0:
            raise dbi.NoRecordError
        return results[0][0]

    def add(self, channel, msg, by):
        db = self._getDb(channel)
        cursor = db.cursor()
        text = ircmsgs.prettyPrint(msg)
        # Check to see if the latest quotegrab is identical
        cursor.execute("""SELECT quote FROM quotegrabs
                          WHERE nick=?
                          ORDER BY id DESC LIMIT 1""", (msg.nick,))
        results = cursor.fetchall()
        if len(results) != 0:
            if text == results[0][0]:
                return
        cursor.execute("""INSERT INTO quotegrabs
                          VALUES (NULL, ?, ?, ?, ?, ?)""",
                       (msg.nick, msg.prefix, by, int(time.time()), text,))
        db.commit()

    def remove(self, channel, grab=None):
        db = self._getDb(channel)
        cursor = db.cursor()
        if grab is not None:
            # the testing if there actually *is* the to-be-deleted record is
            # strictly unnecessary -- the DELETE operation would "succeed"
            # anyway, but it's silly to just keep saying 'OK' no matter what,
            # so...
            cursor.execute("""SELECT * FROM quotegrabs WHERE id = ?""", (grab,))
            results = cursor.fetchall()
            if len(results) == 0:
                raise dbi.NoRecordError
            cursor.execute("""DELETE FROM quotegrabs WHERE id = ?""", (grab,))
        else:
            cursor.execute("""SELECT * FROM quotegrabs WHERE id = (SELECT MAX(id)
                FROM quotegrabs)""")
            results = cursor.fetchall()
            if len(results) == 0:
                raise dbi.NoRecordError
            cursor.execute("""DELETE FROM quotegrabs WHERE id = (SELECT MAX(id)
                FROM quotegrabs)""")
        db.commit()

    def search(self, channel, text):
        db = self._getDb(channel)
        cursor = db.cursor()
        text = '%' + text + '%'
        cursor.execute("""SELECT id, nick, quote FROM quotegrabs
                          WHERE quote LIKE ?
                          ORDER BY id DESC""", (text,))
        results = cursor.fetchall()
        if len(results) == 0:
            raise dbi.NoRecordError
        return [QuoteGrabsRecord(id, text=quote, by=nick)
                for (id, nick, quote) in results]

QuoteGrabsDB = plugins.DB('QuoteGrabs', {'sqlite3': SqliteQuoteGrabsDB})

class QuoteGrabs(callbacks.Plugin):
    """Add the help for "@help QuoteGrabs" here."""
    def __init__(self, irc):
        self.__parent = super(QuoteGrabs, self)
        self.__parent.__init__(irc)
        self.db = QuoteGrabsDB()

    def doPrivmsg(self, irc, msg):
        if ircmsgs.isCtcp(msg) and not ircmsgs.isAction(msg):
            return
        irc = callbacks.SimpleProxy(irc, msg)
        if irc.isChannel(msg.args[0]):
            (chan, payload) = msg.args
            words = self.registryValue('randomGrabber.minimumWords', chan)
            length = self.registryValue('randomGrabber.minimumCharacters',chan)
            grabTime = \
            self.registryValue('randomGrabber.averageTimeBetweenGrabs', chan)
            channel = plugins.getChannel(chan)
            if self.registryValue('randomGrabber', chan):
                if len(payload) > length and len(payload.split()) > words:
                    try:
                        last = int(self.db.select(channel, msg.nick))
                    except dbi.NoRecordError:
                        self._grab(channel, irc, msg, irc.prefix)
                        self._sendGrabMsg(irc, msg)
                    else:
                        elapsed = int(time.time()) - last
                        if (random.random() * elapsed) > (grabTime / 2):
                            self._grab(channel, irc, msg, irc.prefix)
                            self._sendGrabMsg(irc, msg)

    def _grab(self, channel, irc, msg, addedBy):
        self.db.add(channel, msg, addedBy)

    def _sendGrabMsg(self, irc, msg):
        s = 'jots down a new quote for %s' % msg.nick
        irc.reply(s, action=True, prefixNick=False)

    @internationalizeDocstring
    def grab(self, irc, msg, args, channel, nick):
        """[<channel>] <nick>

        Grabs a quote from <channel> by <nick> for the quotegrabs table.
        <channel> is only necessary if the message isn't sent in the channel
        itself.
        """
        # chan is used to make sure we know where to grab the quote from, as
        # opposed to channel which is used to determine which db to store the
        # quote in
        chan = msg.args[0]
        if chan is None:
            raise callbacks.ArgumentError
        if ircutils.nickEqual(nick, msg.nick):
            irc.error(_('You can\'t quote grab yourself.'), Raise=True)
        for m in reversed(irc.state.history):
            if m.command == 'PRIVMSG' and ircutils.nickEqual(m.nick, nick) \
                    and ircutils.strEqual(m.args[0], chan):
                self._grab(channel, irc, m, msg.prefix)
                irc.replySuccess()
                return
        irc.error(_('I couldn\'t find a proper message to grab.'))
    grab = wrap(grab, ['channeldb', 'nick'])

    @internationalizeDocstring
    def ungrab(self, irc, msg, args, channel, grab):
        """[<channel>] <number>

        Removes the grab <number> (the last by default) on <channel>.
        <channel> is only necessary if the message isn't sent in the channel
        itself.
        """
        try:
            self.db.remove(channel, grab)
            irc.replySuccess()
        except dbi.NoRecordError:
            if grab is None:
                irc.error(_('Nothing to ungrab.'))
            else:
                irc.error(_('Invalid grab number.'))
    ungrab = wrap(ungrab, ['channeldb', optional('id')])

    @internationalizeDocstring
    def quote(self, irc, msg, args, channel, nick):
        """[<channel>] <nick>

        Returns <nick>'s latest quote grab in <channel>.  <channel> is only
        necessary if the message isn't sent in the channel itself.
        """
        try:
            irc.reply(self.db.getQuote(channel, nick))
        except dbi.NoRecordError:
            irc.error(_('I couldn\'t find a matching quotegrab for %s.') %
                      nick, Raise=True)
    quote = wrap(quote, ['channeldb', 'nick'])

    @internationalizeDocstring
    def list(self, irc, msg, args, channel, nick):
        """[<channel>] <nick>

        Returns a list of shortened quotes that have been grabbed for <nick>
        as well as the id of each quote.  These ids can be used to get the
        full quote.  <channel> is only necessary if the message isn't sent in
        the channel itself.
        """
        try:
            records = self.db.list(channel, nick)
            L = []
            for record in records:
                # strip the nick from the quote
                quote = record.text.replace('<%s> ' % nick, '', 1)
                item = utils.str.ellipsisify('#%s: %s' % (record.id, quote),50)
                L.append(item)
            irc.reply(utils.str.commaAndify(L))
        except dbi.NoRecordError:
            irc.error(_('I couldn\'t find any quotegrabs for %s.') % nick,
                      Raise=True)
    list = wrap(list, ['channeldb', 'nick'])

    @internationalizeDocstring
    def random(self, irc, msg, args, channel, nick):
        """[<channel>] [<nick>]

        Returns a randomly grabbed quote, optionally choosing only from those
        quotes grabbed for <nick>.  <channel> is only necessary if the message
        isn't sent in the channel itself.
        """
        try:
            irc.reply(self.db.random(channel, nick))
        except dbi.NoRecordError:
            if nick:
                irc.error(_('Couldn\'t get a random quote for that nick.'))
            else:
                irc.error(_('Couldn\'t get a random quote.  Are there any '
                          'grabbed quotes in the database?'))
    random = wrap(random, ['channeldb', additional('nick')])

    @internationalizeDocstring
    def get(self, irc, msg, args, channel, id):
        """[<channel>] <id>

        Return the quotegrab with the given <id>.  <channel> is only necessary
        if the message isn't sent in the channel itself.
        """
        try:
            irc.reply(self.db.get(channel, id))
        except dbi.NoRecordError:
            irc.error(_('No quotegrab for id %s') % utils.str.quoted(id),
                      Raise=True)
    get = wrap(get, ['channeldb', 'id'])

    @internationalizeDocstring
    def search(self, irc, msg, args, channel, text):
        """[<channel>] <text>

        Searches for <text> in a quote.  <channel> is only necessary if the
        message isn't sent in the channel itself.
        """
        try:
            records = self.db.search(channel, text)
            L = []
            for record in records:
                # strip the nick from the quote
                quote = record.text.replace('<%s> ' % record.by, '', 1)
                item = utils.str.ellipsisify('#%s: %s' % (record.id, quote),50)
                L.append(item)
            irc.reply(utils.str.commaAndify(L))
        except dbi.NoRecordError:
            irc.error(_('No quotegrabs matching %s') % utils.str.quoted(text),
                       Raise=True)
    search = wrap(search, ['channeldb', 'text'])

Class = QuoteGrabs

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2004, Daniel DiPaolo
# Copyright (c) 2008, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

class QuoteGrabsTestCase(ChannelPluginTestCase):
    plugins = ('QuoteGrabs',)
    def testQuoteGrab(self):
        testPrefix = 'foo!bar@baz'
        self.assertError('grab foo')
        # Test join/part/notice (shouldn't grab)
        self.irc.feedMsg(ircmsgs.join(self.channel, prefix=testPrefix))
        self.assertError('grab foo')
        self.irc.feedMsg(ircmsgs.part(self.channel, prefix=testPrefix))
        self.assertError('grab foo')
        # Test privmsgs
        self.irc.feedMsg(ircmsgs.privmsg(self.channel, 'something',
                                         prefix=testPrefix))
        self.assertNotError('grab foo')
        self.assertResponse('quote foo', '<foo> something')
        # Test actions
        self.irc.feedMsg(ircmsgs.action(self.channel, 'moos',
                                        prefix=testPrefix))
        self.assertNotError('grab foo')
        self.assertResponse('quote foo', '* foo moos')

    def testUngrab(self):
        testPrefix = 'foo!bar@baz'
        # nothing yet
        self.assertError('ungrab')
        self.assertError('ungrab 2')
        self.irc.feedMsg(ircmsgs.privmsg(self.channel, 'something',
                                         prefix=testPrefix))
        # still not grabbed
        self.assertError('ungrab')
        self.assertError('ungrab 3')
        # grab and ungrab a quote
        self.assertNotError('grab foo')
        self.assertNotError('ungrab')

        self.assertNotError('grab foo')
        # this is not there...
        self.assertError('ungrab 8883')
        # ...unlike this...
        self.assertNotError('ungrab 1')
        # ...but not now anymore :-D
        self.assertError('ungrab')
        # grab two quotes and ungrab them by id
        self.irc.feedMsg(ircmsgs.privmsg(self.channel, 'something',
                                         prefix=testPrefix))
        self.assertNotError('grab foo')
        self.irc.feedMsg(ircmsgs.privmsg(self.channel, 'another',
                                         prefix=testPrefix))
        self.assertNotError('grab foo')
        self.assertNotError('ungrab 1')
        self.assertNotError('ungrab 2')
        self.assertError('ungrab')

    def testList(self):
        testPrefix = 'foo!bar@baz'
        self.irc.feedMsg(ircmsgs.privmsg(self.channel, 'testList',
                                         prefix=testPrefix))
        self.assertNotError('grab foo')
        self.assertResponse('quotegrabs list foo', '#1: testList')
        self.irc.feedMsg(ircmsgs.privmsg(self.channel, 'a' * 80,
                                         prefix=testPrefix))
        self.assertNotError('grab foo')
        self.assertResponse('quotegrabs list foo',
                            '#2: %s... and #1: testList' %\
                            ('a'*43)) # 50 - length of "#2: ..."

    def testDuplicateGrabs(self):
        testPrefix = 'foo!bar@baz'
        self.irc.feedMsg(ircmsgs.privmsg(self.channel, 'testDupe',
                                         prefix=testPrefix))
        self.assertNotError('grab foo')
        self.assertNotError('grab foo') # note:NOTanerror,stillwon'tdupe
        self.assertResponse('quotegrabs list foo', '#1: testDupe')

    def testCaseInsensitivity(self):
        testPrefix = 'foo!bar@baz'
        self.irc.feedMsg(ircmsgs.privmsg(self.channel, 'testCI',
                                         prefix=testPrefix))
        self.assertNotError('grab FOO')
        self.assertNotError('quote foo')
        self.assertNotError('quote FoO')
        self.assertNotError('quote Foo')
        self.assertNotError('quotegrabs list FOO')
        self.assertNotError('quotegrabs list fOo')

    def testRandom(self):
        testPrefix = 'foo!bar@baz'
        self.assertError('random')
        self.irc.feedMsg(ircmsgs.privmsg(self.channel, 'testRandom',
                                         prefix=testPrefix))
        self.assertError('random')  # still none in the db
        self.assertNotError('grab foo')
        self.assertResponse('random', '<foo> testRandom')
        self.assertResponse('random foo', '<foo> testRandom')
        self.assertResponse('random FOO', '<foo> testRandom')

    def testGet(self):
        testPrefix= 'foo!bar@baz'
        self.assertError('quotegrabs get asdf')
        self.assertError('quotegrabs get 1')
        self.irc.feedMsg(ircmsgs.privmsg(self.channel, 'testGet',
                                         prefix=testPrefix))
        self.assertNotError('grab foo')
        self.assertNotError('quotegrabs get 1')

    def testSearch(self):
        testPrefix= 'foo!bar@baz'
        self.irc.feedMsg(ircmsgs.privmsg(self.channel, 'testSearch',
                                         prefix=testPrefix))
        self.assertError('quotegrabs search test')  # still none in db
        self.assertNotError('grab foo')
        self.assertNotError('quotegrabs search test')

class QuoteGrabsNonChannelTestCase(QuoteGrabsTestCase):
    config = { 'databases.plugins.channelSpecific' : False }


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.ircutils as ircutils
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Relay')

def configure(advanced):
    from supybot.questions import output, expect, anything, something, yn
    conf.registerPlugin('Relay', True)
    if yn(_('Would you like to relay between any channels?')):
        channels = anything(_('What channels?  Separated them by spaces.'))
        conf.supybot.plugins.Relay.channels.set(channels)
    if yn(_('Would you like to use color to distinguish between nicks?')):
        conf.supybot.plugins.Relay.color.setValue(True)
    output("""Right now there's no way to configure the actual connection to
    the server.  What you'll need to do when the bot finishes starting up is
    use the 'start' command followed by the 'connect' command.  Use the 'help'
    command to see how these two commands should be used.""")

class Ignores(registry.SpaceSeparatedListOf):
    List = ircutils.IrcSet
    Value = conf.ValidHostmask
    
class Networks(registry.SpaceSeparatedListOf):
    List = ircutils.IrcSet
    Value = registry.String

Relay = conf.registerPlugin('Relay')
conf.registerChannelValue(Relay, 'color',
    registry.Boolean(False, _("""Determines whether the bot will color relayed
    PRIVMSGs so as to make the messages easier to read.""")))
conf.registerChannelValue(Relay, 'topicSync',
    registry.Boolean(True, _("""Determines whether the bot will synchronize
    topics between networks in the channels it relays.""")))
conf.registerChannelValue(Relay, 'hostmasks',
    registry.Boolean(False, _("""Determines whether the bot will relay the
    hostmask of the person joining or parting the channel when he or she joins
    or parts.""")))
conf.registerChannelValue(Relay, 'includeNetwork',
    registry.Boolean(True, _("""Determines whether the bot will include the
    network in relayed PRIVMSGs; if you're only relaying between two networks,
    it's somewhat redundant, and you may wish to save the space.""")))
conf.registerChannelValue(Relay, 'punishOtherRelayBots',
    registry.Boolean(False, _("""Determines whether the bot will detect other
    bots relaying and respond by kickbanning them.""")))
conf.registerGlobalValue(Relay, 'channels',
    conf.SpaceSeparatedSetOfChannels([], _("""Determines which channels the bot
    will relay in.""")))
conf.registerChannelValue(Relay.channels, 'joinOnAllNetworks',
    registry.Boolean(True, _("""Determines whether the bot
    will always join the channel(s) it relays for on all networks the bot is
    connected to.""")))
conf.registerChannelValue(Relay, 'ignores',
    Ignores([], _("""Determines what hostmasks will not be relayed on a
    channel.""")))
conf.registerChannelValue(Relay, 'noticeNonPrivmsgs',
    registry.Boolean(False, _("""Determines whether the bot will used NOTICEs
    rather than PRIVMSGs for non-PRIVMSG relay messages (i.e., joins, parts,
    nicks, quits, modes, etc.)""")))


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2002-2004, Jeremiah Fincher
# Copyright (c) 2010, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import time

import supybot.conf as conf
import supybot.utils as utils
import supybot.world as world
from supybot.commands import *
import supybot.irclib as irclib
import supybot.ircmsgs as ircmsgs
import supybot.ircutils as ircutils
import supybot.callbacks as callbacks
from supybot.utils.structures import MultiSet, TimeoutQueue
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Relay')

class Relay(callbacks.Plugin):
    noIgnore = True
    def __init__(self, irc):
        self.__parent = super(Relay, self)
        self.__parent.__init__(irc)
        self._whois = {}
        self.lastmsg = {}
        self.ircstates = {}
        self.queuedTopics = MultiSet()
        self.lastRelayMsgs = ircutils.IrcDict()

    def __call__(self, irc, msg):
        try:
            irc = self._getRealIrc(irc)
            if irc not in self.ircstates:
                self._addIrc(irc)
            self.ircstates[irc].addMsg(irc, self.lastmsg[irc])
        finally:
            self.lastmsg[irc] = msg
        self.__parent.__call__(irc, msg)

    def do376(self, irc, msg):
        networkGroup = conf.supybot.networks.get(irc.network)
        for channel in self.registryValue('channels'):
            if self.registryValue('channels.joinOnAllNetworks', channel):
                if channel not in irc.state.channels:
                    irc.queueMsg(networkGroup.channels.join(channel))
    do377 = do422 = do376

    def _getRealIrc(self, irc):
        if isinstance(irc, irclib.Irc):
            return irc
        else:
            return irc.getRealIrc()

    def _getIrcName(self, irc):
        # We should allow abbreviations at some point.
        return irc.network

    def _addIrc(self, irc):
        # Let's just be extra-special-careful here.
        if irc not in self.ircstates:
            self.ircstates[irc] = irclib.IrcState()
        if irc not in self.lastmsg:
            self.lastmsg[irc] = ircmsgs.ping('this is just a fake message')
        if irc.afterConnect:
            # We've probably been reloaded.  Let's send some messages to get
            # our IrcState objects up to current.
            for channel in self.registryValue('channels'):
                irc.queueMsg(ircmsgs.who(channel))
                irc.queueMsg(ircmsgs.names(channel))

    @internationalizeDocstring
    def join(self, irc, msg, args, channel):
        """[<channel>]

        Starts relaying between the channel <channel> on all networks.  If on a
        network the bot isn't in <channel>, he'll join.  This commands is
        required even if the bot is in the channel on both networks; he won't
        relay between those channels unless he's told to join both
        channels.  If <channel> is not given, starts relaying on the channel
        the message was sent in.
        """
        self.registryValue('channels').add(channel)
        for otherIrc in world.ircs:
            if channel not in otherIrc.state.channels:
                networkGroup = conf.supybot.networks.get(otherIrc.network)
                otherIrc.queueMsg(networkGroup.channels.join(channel))
        irc.replySuccess()
    join = wrap(join, ['channel', 'admin'])

    @internationalizeDocstring
    def part(self, irc, msg, args, channel):
        """<channel>

        Ceases relaying between the channel <channel> on all networks.  The bot
        will part from the channel on all networks in which it is on the
        channel.
        """
        self.registryValue('channels').discard(channel)
        for otherIrc in world.ircs:
            if channel in otherIrc.state.channels:
                otherIrc.queueMsg(ircmsgs.part(channel))
        irc.replySuccess()
    part = wrap(part, ['channel', 'admin'])

    @internationalizeDocstring
    def nicks(self, irc, msg, args, channel):
        """[<channel>]

        Returns the nicks of the people in the channel on the various networks
        the bot is connected to.  <channel> is only necessary if the message
        isn't sent on the channel itself.
        """
        realIrc = self._getRealIrc(irc)
        if channel not in self.registryValue('channels'):
            irc.error(format('I\'m not relaying in %s.', channel))
            return
        users = []
        for otherIrc in world.ircs:
            network = self._getIrcName(otherIrc)
            ops = []
            halfops = []
            voices = []
            usersS = []
            if network != self._getIrcName(realIrc):
                try:
                    Channel = otherIrc.state.channels[channel]
                except KeyError:
                    users.append(format('(not in %s on %s)',channel,network))
                    continue
                numUsers = 0
                for s in Channel.users:
                    s = s.strip()
                    if not s:
                        continue
                    numUsers += 1
                    if s in Channel.ops:
                        ops.append('@' + s)
                    elif s in Channel.halfops:
                        halfops.append('%' + s)
                    elif s in Channel.voices:
                        voices.append('+' + s)
                    else:
                        usersS.append(s)
                utils.sortBy(ircutils.toLower, ops)
                utils.sortBy(ircutils.toLower, voices)
                utils.sortBy(ircutils.toLower, halfops)
                utils.sortBy(ircutils.toLower, usersS)
                usersS = ', '.join(filter(None, list(map(', '.join,
                                  (ops,halfops,voices,usersS)))))
                users.append(format('%s (%i): %s',
                                    ircutils.bold(network), numUsers, usersS))
        users.sort()
        irc.reply('; '.join(users))
    nicks = wrap(nicks, ['channel'])

    def do311(self, irc, msg):
        irc = self._getRealIrc(irc)
        nick = ircutils.toLower(msg.args[1])
        if (irc, nick) not in self._whois:
            return
        else:
            self._whois[(irc, nick)][-1][msg.command] = msg

    # These are all sent by a WHOIS response.
    do301 = do311
    do312 = do311
    do317 = do311
    do319 = do311
    do320 = do311

    def do318(self, irc, msg):
        irc = self._getRealIrc(irc)
        nick = msg.args[1]
        loweredNick = ircutils.toLower(nick)
        if (irc, loweredNick) not in self._whois:
            return
        (replyIrc, replyMsg, d) = self._whois[(irc, loweredNick)]
        hostmask = '@'.join(d['311'].args[2:4])
        user = d['311'].args[-1]
        if '319' in d:
            channels = d['319'].args[-1].split()
            ops = []
            voices = []
            normal = []
            halfops = []
            for channel in channels:
                if channel.startswith('@'):
                    ops.append(channel[1:])
                elif channel.startswith('%'):
                    halfops.append(channel[1:])
                elif channel.startswith('+'):
                    voices.append(channel[1:])
                else:
                    normal.append(channel)
            L = []
            if ops:
                L.append(format(_('is an op on %L'), ops))
            if halfops:
                L.append(format(_('is a halfop on %L'), halfops))
            if voices:
                L.append(format(_('is voiced on %L'), voices))
            if normal:
                if L:
                    L.append(format(_('is also on %L'), normal))
                else:
                    L.append(format(_('is on %L'), normal))
        else:
            L = [_('isn\'t on any non-secret channels')]
        channels = format('%L', L)
        if '317' in d:
            idle = utils.timeElapsed(d['317'].args[2])
            signon = time.strftime(conf.supybot.reply.format.time(),
                                   time.localtime(float(d['317'].args[3])))
        else:
            idle = _('<unknown>')
            signon = _('<unknown>')
        if '312' in d:
            server = d['312'].args[2]
        else:
            server = _('<unknown>')
        if '301' in d:
            away = format(_('  %s is away: %s.'), nick, d['301'].args[2])
        else:
            away = ''
        if '320' in d:
            if d['320'].args[2]:
                identify = _(' identified')
            else:
                identify = ''
        else:
            identify = ''
        s = format(_('%s (%s) has been%s on server %s since %s (idle for %s) '
                   'and %s.%s'),
                   user, hostmask, identify, server, signon, idle,
                   channels, away)
        replyIrc.reply(s)
        del self._whois[(irc, loweredNick)]

    def do402(self, irc, msg):
        irc = self._getRealIrc(irc)
        nick = msg.args[1]
        loweredNick = ircutils.toLower(nick)
        if (irc, loweredNick) not in self._whois:
            return
        (replyIrc, replyMsg, d) = self._whois[(irc, loweredNick)]
        del self._whois[(irc, loweredNick)]
        s = format(_('There is no %s on %s.'), nick, self._getIrcName(irc))
        replyIrc.reply(s)

    do401 = do402

    def _formatPrivmsg(self, nick, network, msg):
        channel = msg.args[0]
        if self.registryValue('includeNetwork', channel):
            network = '@' + network
        else:
            network = ''
        # colorize nicks
        color = self.registryValue('color', channel) # Also used further down.
        if color:
            nick = ircutils.IrcString(nick)
            newnick = ircutils.mircColor(nick, *ircutils.canonicalColor(nick))
            colors = ircutils.canonicalColor(nick, shift=4)
            nick = newnick
        if ircmsgs.isAction(msg):
            if color:
                t = ircutils.mircColor('*', *colors)
            else:
                t = '*'
            s = format('%s %s%s %s', t, nick, network, ircmsgs.unAction(msg))
        else:
            if color:
                lt = ircutils.mircColor('<', *colors)
                gt = ircutils.mircColor('>', *colors)
            else:
                lt = '<'
                gt = '>'
            s = format('%s%s%s%s %s', lt, nick, network, gt, msg.args[1])
        return s

    def _sendToOthers(self, irc, msg):
        assert msg.command in ('PRIVMSG', 'NOTICE', 'TOPIC')
        for otherIrc in world.ircs:
            if otherIrc != irc and not otherIrc.zombie:
                if msg.args[0] in otherIrc.state.channels:
                    msg.tag('relayedMsg')
                    otherIrc.queueMsg(msg)

    def _checkRelayMsg(self, msg):
        channel = msg.args[0]
        if channel in self.lastRelayMsgs:
            q = self.lastRelayMsgs[channel]
            unformatted = ircutils.stripFormatting(msg.args[1])
            normalized = utils.str.normalizeWhitespace(unformatted)
            for s in q:
                if s in normalized:
                    return True
        return False

    def _punishRelayers(self, msg):
        assert self._checkRelayMsg(msg), 'Punishing without checking.'
        who = msg.prefix
        channel = msg.args[0]
        def notPunishing(irc, s, *args):
            self.log.info('Not punishing %s in %s on %s: %s.',
                          msg.prefix, channel, irc.network, s, *args)
        for irc in world.ircs:
            if channel in irc.state.channels:
                if irc.nick in irc.state.channels[channel].ops:
                    if who in irc.state.channels[channel].bans:
                        notPunishing(irc, 'already banned')
                    else:
                        self.log.info('Punishing %s in %s on %s for relaying.',
                                      who, channel, irc.network)
                        irc.sendMsg(ircmsgs.ban(channel, who))
                        kmsg = _('You seem to be relaying, punk.')
                        irc.sendMsg(ircmsgs.kick(channel, msg.nick, kmsg))
                else:
                    notPunishing(irc, 'not opped')

    def doPrivmsg(self, irc, msg):
        if ircmsgs.isCtcp(msg) and not ircmsgs.isAction(msg):
            return
        (channel, text) = msg.args
        if irc.isChannel(channel):
            irc = self._getRealIrc(irc)
            if channel not in self.registryValue('channels'):
                return
            ignores = self.registryValue('ignores', channel)
            for ignore in ignores:
                if ircutils.hostmaskPatternEqual(ignore, msg.prefix):
                    self.log.debug('Refusing to relay %s, ignored by %s.',
                                   msg.prefix, ignore)
                    return
            # Let's try to detect other relay bots.
            if self._checkRelayMsg(msg):
                if self.registryValue('punishOtherRelayBots', channel):
                    self._punishRelayers(msg)
                # Either way, we don't relay the message.
                else:
                    self.log.warning('Refusing to relay message from %s, '
                                     'it appears to be a relay message.',
                                     msg.prefix)
            else:
                network = self._getIrcName(irc)
                s = self._formatPrivmsg(msg.nick, network, msg)
                m = self._msgmaker(channel, s)
                self._sendToOthers(irc, m)

    def _msgmaker(self, target, s):
        msg = dynamic.msg
        channel = dynamic.channel
        if self.registryValue('noticeNonPrivmsgs', dynamic.channel) and \
           msg.command != 'PRIVMSG':
            return ircmsgs.notice(target, s)
        else:
            return ircmsgs.privmsg(target, s)

    def doJoin(self, irc, msg):
        irc = self._getRealIrc(irc)
        channel = msg.args[0]
        if channel not in self.registryValue('channels'):
            return
        network = self._getIrcName(irc)
        if self.registryValue('hostmasks', channel):
            hostmask = format(' (%s)', msg.prefix.split('!')[1])
        else:
            hostmask = ''
        s = format(_('%s%s has joined on %s'), msg.nick, hostmask, network)
        m = self._msgmaker(channel, s)
        self._sendToOthers(irc, m)

    def doPart(self, irc, msg):
        irc = self._getRealIrc(irc)
        channel = msg.args[0]
        if channel not in self.registryValue('channels'):
            return
        network = self._getIrcName(irc)
        if self.registryValue('hostmasks', channel):
            hostmask = format(' (%s)', msg.prefix.split('!')[1])
        else:
            hostmask = ''
        if len(msg.args) > 1:
            s = format(_('%s%s has left on %s (%s)'),
                       msg.nick, hostmask, network, msg.args[1])
        else:
            s = format(_('%s%s has left on %s'), msg.nick, hostmask, network)
        m = self._msgmaker(channel, s)
        self._sendToOthers(irc, m)

    def doMode(self, irc, msg):
        irc = self._getRealIrc(irc)
        channel = msg.args[0]
        if channel not in self.registryValue('channels'):
            return
        network = self._getIrcName(irc)
        s = format(_('mode change by %s on %s: %s'),
                   msg.nick, network, ' '.join(msg.args[1:]))
        m = self._msgmaker(channel, s)
        self._sendToOthers(irc, m)

    def doKick(self, irc, msg):
        irc = self._getRealIrc(irc)
        channel = msg.args[0]
        if channel not in self.registryValue('channels'):
            return
        network = self._getIrcName(irc)
        if len(msg.args) == 3:
            s = format(_('%s was kicked by %s on %s (%s)'),
                       msg.args[1], msg.nick, network, msg.args[2])
        else:
            s = format(_('%s was kicked by %s on %s'),
                       msg.args[1], msg.nick, network)
        m = self._msgmaker(channel, s)
        self._sendToOthers(irc, m)

    def doNick(self, irc, msg):
        irc = self._getRealIrc(irc)
        newNick = msg.args[0]
        network = self._getIrcName(irc)
        s = format(_('nick change by %s to %s on %s'), msg.nick,newNick,network)
        for channel in self.registryValue('channels'):
            if channel in irc.state.channels:
                if newNick in irc.state.channels[channel].users:
                    m = self._msgmaker(channel, s)
                    self._sendToOthers(irc, m)

    def doTopic(self, irc, msg):
        irc = self._getRealIrc(irc)
        (channel, newTopic) = msg.args
        if channel not in self.registryValue('channels'):
            return
        network = self._getIrcName(irc)
        if self.registryValue('topicSync', channel):
            m = ircmsgs.topic(channel, newTopic)
            for otherIrc in world.ircs:
                if irc != otherIrc:
                    try:
                        if otherIrc.state.getTopic(channel) != newTopic:
                            if (otherIrc, newTopic) not in self.queuedTopics:
                                self.queuedTopics.add((otherIrc, newTopic))
                                otherIrc.queueMsg(m)
                            else:
                                self.queuedTopics.remove((otherIrc, newTopic))

                    except KeyError:
                        self.log.warning('Not on %s on %s, '
                                         'can\'t sync topics.',
                                         channel, otherIrc.network)
        else:
            s = format(_('topic change by %s on %s: %s'),
                       msg.nick, network, newTopic)
            m = self._msgmaker(channel, s)
            self._sendToOthers(irc, m)

    def doQuit(self, irc, msg):
        irc = self._getRealIrc(irc)
        network = self._getIrcName(irc)
        if msg.args:
            s = format(_('%s has quit %s (%s)'), msg.nick, network, msg.args[0])
        else:
            s = format(_('%s has quit %s.'), msg.nick, network)
        for channel in self.registryValue('channels'):
            if channel in self.ircstates[irc].channels:
                if msg.nick in self.ircstates[irc].channels[channel].users:
                    m = self._msgmaker(channel, s)
                    self._sendToOthers(irc, m)

    def doError(self, irc, msg):
        irc = self._getRealIrc(irc)
        network = self._getIrcName(irc)
        s = format(_('disconnected from %s: %s'), network, msg.args[0])
        for channel in self.registryValue('channels'):
            m = self._msgmaker(channel, s)
            self._sendToOthers(irc, m)

    def outFilter(self, irc, msg):
        irc = self._getRealIrc(irc)
        if msg.command == 'PRIVMSG':
            if msg.relayedMsg:
                self._addRelayMsg(msg)
            else:
                channel = msg.args[0]
                if channel in self.registryValue('channels'):
                    network = self._getIrcName(irc)
                    s = self._formatPrivmsg(irc.nick, network, msg)
                    relayMsg = self._msgmaker(channel, s)
                    self._sendToOthers(irc, relayMsg)
        return msg

    def _addRelayMsg(self, msg):
        channel = msg.args[0]
        if channel in self.lastRelayMsgs:
            q = self.lastRelayMsgs[channel]
        else:
            q = TimeoutQueue(60) # XXX Make this configurable.
            self.lastRelayMsgs[channel] = q
        unformatted = ircutils.stripFormatting(msg.args[1])
        normalized = utils.str.normalizeWhitespace(unformatted)
        q.enqueue(normalized)


Class = Relay

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2002-2004, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

class RelayTestCase(PluginTestCase):
    plugins = ('Relay',)


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:


########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2005, Daniel DiPaolo
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Reply')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Reply', True)


Reply = conf.registerPlugin('Reply')
# This is where your configuration variables (if any) should go.  For example:
# conf.registerGlobalValue(Reply, 'someConfigVariableName',
#     registry.Boolean(False, _("""Help for someConfigVariableName.""")))


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2005, Daniel DiPaolo
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.commands import *
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Reply')


class Reply(callbacks.Plugin):
    """This plugin contains a few commands that construct various types of
    replies.  Some bot owners would be wise to not load this plugin because it
    can be easily abused.
    """
    @internationalizeDocstring
    def private(self, irc, msg, args, text):
        """<text>

        Replies with <text> in private.  Use nested commands to your benefit
        here.
        """
        irc.reply(text, private=True)
    private = wrap(private, ['text'])

    @internationalizeDocstring
    def action(self, irc, msg, args, text):
        """<text>

        Replies with <text> as an action.  Use nested commands to your benefit
        here.
        """
        if text:
            irc.reply(text, action=True)
        else:
            raise callbacks.ArgumentError
    action = wrap(action, ['text'])

    @internationalizeDocstring
    def notice(self, irc, msg, args, text):
        """<text>

        Replies with <text> in a notice.  Use nested commands to your benefit
        here.  If you want a private notice, nest the private command.
        """
        irc.reply(text, notice=True)
    notice = wrap(notice, ['text'])

    @internationalizeDocstring
    def reply(self, irc, msg, args, text):
        """<text>

        Replies with <text>.  Equivalent to the alias, 'echo $nick: $1'.
        """
        irc.reply(text, prefixNick=True)
    reply = wrap(reply, ['text'])

    @internationalizeDocstring
    def replies(self, irc, msg, args, strings):
        """<str> [<str> ...]

        Replies with each of its arguments <str> in separate replies, depending
        the configuration of supybot.reply.oneToOne.
        """
        irc.replies(strings)
    replies = wrap(replies, [many('something')])
Reply = internationalizeDocstring(Reply)

Class = Reply


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2005, Daniel DiPaolo
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *
import supybot.ircutils as ircutils

class ReplyTestCase(ChannelPluginTestCase):
    plugins = ('Reply',)
    def testPrivate(self):
        m = self.getMsg('private [list]')
        self.failIf(ircutils.isChannel(m.args[0]))

    def testNotice(self):
        m = self.getMsg('notice [list]')
        self.assertEqual(m.command, 'NOTICE')

    def testNoticePrivate(self):
        m = self.assertNotError('notice [private [list]]')
        self.assertEqual(m.command, 'NOTICE')
        self.assertEqual(m.args[0], self.nick)
        m = self.assertNotError('private [notice [list]]')
        self.assertEqual(m.command, 'NOTICE')
        self.assertEqual(m.args[0], self.nick)

class ReplyNonChannelTestCase(PluginTestCase):
    plugins = ('Reply',)
    def testAction(self):
        self.prefix = 'something!else@somewhere.else'
        self.nick = 'something'
        m = self.assertAction('action foo', 'foo')
        self.failIf(m.args[0] == self.irc.nick)

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('RSS')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('RSS', True)


class FeedNames(registry.SpaceSeparatedListOfStrings):
    List = callbacks.CanonicalNameSet

class FeedItemSortOrder(registry.OnlySomeStrings):
    """Valid values include 'asInFeed', 'oldestFirst', 'newestFirst'."""
    validStrings = ('asInFeed', 'oldestFirst', 'newestFirst')

RSS = conf.registerPlugin('RSS')
conf.registerChannelValue(RSS, 'bold', registry.Boolean(
    True, _("""Determines whether the bot will bold the title of the feed when
    it announces new news.""")))
conf.registerChannelValue(RSS, 'headlineSeparator',
    registry.StringSurroundedBySpaces(' || ', _("""Determines what string is
    used to separate headlines in new feeds.""")))
conf.registerChannelValue(RSS, 'announcementPrefix',
    registry.StringWithSpaceOnRight(_('New news from '), _("""Determines what
    prefix is prepended (if any) to the new news item announcements made in the
    channel.""")))
conf.registerChannelValue(RSS, 'announcementSeparator',
        registry.StringWithSpaceOnRight(_(': '), _("""Determines what
    suffix is appended to the feed name in a news item.""")))
conf.registerChannelValue(RSS, 'announce',
    registry.SpaceSeparatedSetOfStrings([], _("""Determines which RSS feeds
    should be announced in the channel; valid input is a list of strings
    (either registered RSS feeds or RSS feed URLs) separated by spaces.""")))
conf.registerGlobalValue(RSS, 'waitPeriod',
    registry.PositiveInteger(1800, _("""Indicates how many seconds the bot will
    wait between retrieving RSS feeds; requests made within this period will
    return cached results.""")))
conf.registerGlobalValue(RSS, 'sortFeedItems',
    FeedItemSortOrder('asInFeed', _("""Determines whether feed items should be
    sorted by their update timestamp or kept in the same order as they appear
    in a feed.""")))
conf.registerGlobalValue(RSS, 'stripRedirect', registry.Boolean(
    True, """Determines whether the bot will attempt to strip url redirection
    from headline links, by taking things after the last http://."""))

conf.registerGlobalValue(RSS, 'feeds',
    FeedNames([], _("""Determines what feeds should be accessible as
    commands.""")))
conf.registerChannelValue(RSS, 'showLinks',
    registry.Boolean(False, _("""Determines whether the bot will list the link
    along with the title of the feed when the rss command is called.
    supybot.plugins.RSS.announce.showLinks affects whether links will be
    listed when a feed is automatically announced.""")))
conf.registerChannelValue(RSS, 'showPubDate',
    registry.Boolean(False, """Determines whether the bot will list the 
    publication datetime stamp along with the title of the feed when the rss
    command is called.
    supybot.plugins.RSS.announce.showPubDate affects whether this will be
    listed when a feed is automatically announced."""))
conf.registerGlobalValue(RSS, 'defaultNumberOfHeadlines',
    registry.PositiveInteger(1, _("""Indicates how many headlines an rss feed
    will output by default, if no number is provided.""")))
conf.registerChannelValue(RSS, 'initialAnnounceHeadlines',
    registry.Integer(5, _("""Indicates how many headlines an rss feed
    will output when it is first added to announce for a channel.""")))
conf.registerChannelValue(RSS, 'keywordWhitelist',
    registry.SpaceSeparatedSetOfStrings([], _("""Space separated list of 
    strings, lets you filter headlines to those containing one or more items
    in this whitelist.""")))
conf.registerChannelValue(RSS, 'keywordBlacklist',
    registry.SpaceSeparatedSetOfStrings([], _("""Space separated list of 
    strings, lets you filter headlines to those not containing any items
    in this blacklist.""")))

conf.registerGroup(RSS, 'announce')
conf.registerChannelValue(RSS.announce, 'showLinks',
    registry.Boolean(False, _("""Determines whether the bot will list the link
    along with the title of the feed when a feed is automatically
    announced.""")))

conf.registerChannelValue(RSS.announce, 'showPubDate',
    registry.Boolean(False, """Determines whether the bot will list the 
    publication datetime stamp along with the title of the feed when a feed
    is automatically announced."""))
conf.registerGlobalValue(RSS.announce, 'cachePeriod',
    registry.PositiveInteger(604800, """Maximum age of cached RSS headlines,
    in seconds. Headline cache is used to avoid re-announcing old news."""))


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2002-2004, Jeremiah Fincher
# Copyright (c) 2008-2010, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import time
import types
import socket
import threading
import re
import sys
import feedparser

import supybot.conf as conf
import supybot.utils as utils
import supybot.world as world
from supybot.commands import *
import supybot.ircutils as ircutils
import supybot.registry as registry
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('RSS')

def getFeedName(irc, msg, args, state):
    if not registry.isValidRegistryName(args[0]):
        state.errorInvalid('feed name', args[0],
                           'Feed names must not include spaces.')
    state.args.append(callbacks.canonicalName(args.pop(0)))
addConverter('feedName', getFeedName)

class RSS(callbacks.Plugin):
    """This plugin is useful both for announcing updates to RSS feeds in a
    channel, and for retrieving the headlines of RSS feeds via command.  Use
    the "add" command to add feeds to this plugin, and use the "announce"
    command to determine what feeds should be announced in a given channel."""
    threaded = True
    def __init__(self, irc):
        self.__parent = super(RSS, self)
        self.__parent.__init__(irc)
        # Schema is feed : [url, command]
        self.feedNames = callbacks.CanonicalNameDict()
        self.locks = {}
        self.lastRequest = {}
        self.cachedFeeds = {}
        self.cachedHeadlines = {}
        self.gettingLockLock = threading.Lock()
        for name in self.registryValue('feeds'):
            self._registerFeed(name)
            try:
                url = self.registryValue(registry.join(['feeds', name]))
            except registry.NonExistentRegistryEntry:
                self.log.warning('%s is not a registered feed, removing.',name)
                continue
            self.makeFeedCommand(name, url)
            self.getFeed(url) # So announced feeds don't announce on startup.

    def isCommandMethod(self, name):
        if not self.__parent.isCommandMethod(name):
            if name in self.feedNames:
                return True
            else:
                return False
        else:
            return True

    def listCommands(self):
        return self.__parent.listCommands(self.feedNames.keys())

    def getCommandMethod(self, command):
        try:
            return self.__parent.getCommandMethod(command)
        except AttributeError:
            return self.feedNames[command[0]][1]

    def _registerFeed(self, name, url=''):
        self.registryValue('feeds').add(name)
        group = self.registryValue('feeds', value=False)
        conf.registerGlobalValue(group, name, registry.String(url, ''))

    def __call__(self, irc, msg):
        self.__parent.__call__(irc, msg)
        irc = callbacks.SimpleProxy(irc, msg)
        newFeeds = {}
        for channel in irc.state.channels:
            feeds = self.registryValue('announce', channel)
            for name in feeds:
                commandName = callbacks.canonicalName(name)
                if self.isCommandMethod(commandName):
                    url = self.feedNames[commandName][0]
                else:
                    url = name
                if self.willGetNewFeed(url):
                    newFeeds.setdefault((url, name), []).append(channel)
        for ((url, name), channels) in newFeeds.iteritems():
            # We check if we can acquire the lock right here because if we
            # don't, we'll possibly end up spawning a lot of threads to get
            # the feed, because this thread may run for a number of bytecodes
            # before it switches to a thread that'll get the lock in
            # _newHeadlines.
            if self.acquireLock(url, blocking=False):
                try:
                    t = threading.Thread(target=self._newHeadlines,
                                         name=format('Fetching %u', url),
                                         args=(irc, channels, name, url))
                    self.log.info('Checking for announcements at %u', url)
                    world.threadsSpawned += 1
                    t.setDaemon(True)
                    t.start()
                finally:
                    self.releaseLock(url)
                    time.sleep(0.1) # So other threads can run.

    def buildHeadlines(self, headlines, channel, linksconfig='announce.showLinks', dateconfig='announce.showPubDate'):
        newheadlines = []
        for headline in headlines:
            link = ''
            pubDate = ''
            if self.registryValue(linksconfig, channel):
                if headline[1]:
                    if self.registryValue('stripRedirect'):
                        link = re.sub('^.*http://', 'http://', headline[1])
                    else:
                        link = headline[1]
            if self.registryValue(dateconfig, channel):
                if headline[2]:
                    pubDate = ' [%s]' % (headline[2],)
            if sys.version_info[0] < 3:
                if isinstance(headline[0], unicode):
                    try:
                        import charade.universaldetector
                        u = charade.universaldetector.UniversalDetector()
                        u.feed(headline[0])
                        u.close()
                        encoding = u.result['encoding']
                    except ImportError:
                        encoding = 'utf8'
                    newheadlines.append(format('%s %u%s',
                                                headline[0].encode(encoding,'replace'),
                                                link,
                                                pubDate))
                else:
                    newheadlines.append(format('%s %u%s',
                                                headline[0],
                                                link,
                                                pubDate))
            else:
                newheadlines.append(format('%s %u%s',
                                            headline[0],
                                            link,
                                            pubDate))
        return newheadlines

    def _newHeadlines(self, irc, channels, name, url):
        try:
            # We acquire the lock here so there's only one announcement thread
            # in this code at any given time.  Otherwise, several announcement
            # threads will getFeed (all blocking, in turn); then they'll all
            # want to send their news messages to the appropriate channels.
            # Note that we're allowed to acquire this lock twice within the
            # same thread because it's an RLock and not just a normal Lock.
            self.acquireLock(url)
            t = time.time()
            try:
                #oldresults = self.cachedFeeds[url]
                #oldheadlines = self.getHeadlines(oldresults)
                oldheadlines = self.cachedHeadlines[url]
                oldheadlines = list(filter(lambda x: t - x[3] <
                    self.registryValue('announce.cachePeriod'), oldheadlines))
            except KeyError:
                oldheadlines = []
            newresults = self.getFeed(url)
            newheadlines = self.getHeadlines(newresults)
            if len(newheadlines) == 1:
                s = newheadlines[0][0]
                if s in ('Timeout downloading feed.',
                         'Unable to download feed.'):
                    self.log.debug('%s %u', s, url)
                    return
            def normalize(headline):
                return (tuple(headline[0].lower().split()), headline[1])
            oldheadlinesset = set(map(normalize, oldheadlines))
            for (i, headline) in enumerate(newheadlines):
                if normalize(headline) in oldheadlinesset:
                    newheadlines[i] = None
            newheadlines = list(filter(None, newheadlines)) # Removes Nones.
            number_of_headlines = len(oldheadlines)
            oldheadlines.extend(newheadlines)
            self.cachedHeadlines[url] = oldheadlines
            if newheadlines:
                def filter_whitelist(headline):
                    v = False
                    for kw in whitelist:
                        if kw in headline[0] or kw in headline[1]:
                            v = True
                            break
                    return v
                def filter_blacklist(headline):
                    v = True
                    for kw in blacklist:
                        if kw in headline[0] or kw in headline[1]:
                            v = False
                            break
                    return v
                for channel in channels:
                    if  number_of_headlines == 0:
                        channelnewheadlines = newheadlines[:self.registryValue('initialAnnounceHeadlines', channel)]
                    else:
                        channelnewheadlines = newheadlines[:]
                    whitelist = self.registryValue('keywordWhitelist', channel)
                    blacklist = self.registryValue('keywordBlacklist', channel)
                    if len(whitelist) != 0:
                        channelnewheadlines = filter(filter_whitelist, channelnewheadlines)
                    if len(blacklist) != 0:
                        channelnewheadlines = filter(filter_blacklist, channelnewheadlines)
                    channelnewheadlines = list(channelnewheadlines)
                    if len(channelnewheadlines) == 0:
                        return
                    bold = self.registryValue('bold', channel)
                    sep = self.registryValue('headlineSeparator', channel)
                    prefix = self.registryValue('announcementPrefix', channel)
                    suffix = self.registryValue('announcementSeparator', channel)
                    pre = format('%s%s%s', prefix, name, suffix)
                    if bold:
                        pre = ircutils.bold(pre)
                        sep = ircutils.bold(sep)
                    headlines = self.buildHeadlines(channelnewheadlines, channel)
                    irc.replies(headlines, prefixer=pre, joiner=sep,
                                to=channel, prefixNick=False, private=True)
        finally:
            self.releaseLock(url)

    def willGetNewFeed(self, url):
        now = time.time()
        wait = self.registryValue('waitPeriod')
        if url not in self.lastRequest or now - self.lastRequest[url] > wait:
            return True
        else:
            return False

    def acquireLock(self, url, blocking=True):
        try:
            self.gettingLockLock.acquire()
            try:
                lock = self.locks[url]
            except KeyError:
                lock = threading.RLock()
                self.locks[url] = lock
            return lock.acquire(blocking=blocking)
        finally:
            self.gettingLockLock.release()

    def releaseLock(self, url):
        self.locks[url].release()

    def getFeed(self, url):
        def error(s):
            return {'items': [{'title': s}]}
        try:
            # This is the most obvious place to acquire the lock, because a
            # malicious user could conceivably flood the bot with rss commands
            # and DoS the website in question.
            self.acquireLock(url)
            if self.willGetNewFeed(url):
                results = {}
                try:
                    self.log.debug('Downloading new feed from %u', url)
                    results = feedparser.parse(url)
                    if 'bozo_exception' in results and not results['entries']:
                        raise results['bozo_exception']
                except feedparser.sgmllib.SGMLParseError:
                    self.log.exception('Uncaught exception from feedparser:')
                    raise callbacks.Error('Invalid (unparsable) RSS feed.')
                except socket.timeout:
                    return error('Timeout downloading feed.')
                except Exception as e:
                    # These seem mostly harmless.  We'll need reports of a
                    # kind that isn't.
                    self.log.debug('Allowing bozo_exception %r through.', e)
                if results.get('feed', {}) and self.getHeadlines(results):
                    self.cachedFeeds[url] = results
                    self.lastRequest[url] = time.time()
                else:
                    self.log.debug('Not caching results; feed is empty.')
            try:
                return self.cachedFeeds[url]
            except KeyError:
                wait = self.registryValue('waitPeriod')
                # If there's a problem retrieving the feed, we should back off
                # for a little bit before retrying so that there is time for
                # the error to be resolved.
                self.lastRequest[url] = time.time() - .5 * wait
                return error('Unable to download feed.')
        finally:
            self.releaseLock(url)

    def _getConverter(self, feed):
        toText = utils.web.htmlToText
        if 'encoding' in feed:
            def conv(s):
                # encode() first so there implicit encoding doesn't happen in
                # other functions when unicode and bytestring objects are used
                # together
                s = s.encode(feed['encoding'], 'replace')
                s = toText(s).strip()
                return s
            return conv
        else:
            return lambda s: toText(s).strip()
    def _sortFeedItems(self, items):
        """Return feed items, sorted according to sortFeedItems."""
        order = self.registryValue('sortFeedItems')
        if order not in ['oldestFirst', 'newestFirst']:
            return items
        if order == 'oldestFirst':
            reverse = False
        if order == 'newestFirst':
            reverse = True
        try:
            sitems = sorted(items, key=lambda i: i['updated'], reverse=reverse)
        except KeyError:
            # feedparser normalizes required timestamp fields in ATOM and RSS
            # to the "updated" field. Feeds missing it are unsortable by date.
            return items
        return sitems

    def getHeadlines(self, feed):
        headlines = []
        t = time.time()
        conv = self._getConverter(feed)
        for d in self._sortFeedItems(feed['items']):
            if 'title' in d:
                title = conv(d['title'])
                link = d.get('link')
                pubDate = d.get('pubDate', d.get('updated'))
                headlines.append((title, link, pubDate, t))
        return headlines

    @internationalizeDocstring
    def makeFeedCommand(self, name, url):
        docstring = format("""[<number of headlines>]

        Reports the titles for %s at the RSS feed %u.  If
        <number of headlines> is given, returns only that many headlines.
        RSS feeds are only looked up every supybot.plugins.RSS.waitPeriod
        seconds, which defaults to 1800 (30 minutes) since that's what most
        websites prefer.
        """, name, url)
        if url not in self.locks:
            self.locks[url] = threading.RLock()
        if self.isCommandMethod(name):
            s = format('I already have a command in this plugin named %s.',name)
            raise callbacks.Error(s)
        def f(self, irc, msg, args):
            args.insert(0, url)
            self.rss(irc, msg, args)
        f = utils.python.changeFunctionName(f, name, docstring)
        f = types.MethodType(f, self)
        self.feedNames[name] = (url, f)
        self._registerFeed(name, url)

    @internationalizeDocstring
    def add(self, irc, msg, args, name, url):
        """<name> <url>

        Adds a command to this plugin that will look up the RSS feed at the
        given URL.
        """
        self.makeFeedCommand(name, url)
        irc.replySuccess()
    add = wrap(add, ['feedName', 'url'])

    @internationalizeDocstring
    def remove(self, irc, msg, args, name):
        """<name>

        Removes the command for looking up RSS feeds at <name> from
        this plugin.
        """
        if name not in self.feedNames:
            irc.error(_('That\'s not a valid RSS feed command name.'))
            return
        del self.feedNames[name]
        conf.supybot.plugins.RSS.feeds().remove(name)
        conf.supybot.plugins.RSS.feeds.unregister(name)
        irc.replySuccess()
    remove = wrap(remove, ['feedName'])

    class announce(callbacks.Commands):
        @internationalizeDocstring
        def list(self, irc, msg, args, channel):
            """[<channel>]

            Returns the list of feeds announced in <channel>.  <channel> is
            only necessary if the message isn't sent in the channel itself.
            """
            announce = conf.supybot.plugins.RSS.announce
            feeds = format('%L', list(announce.get(channel)()))
            irc.reply(feeds or _('I am currently not announcing any feeds.'))
        list = wrap(list, ['channel',])

        @internationalizeDocstring
        def add(self, irc, msg, args, channel, feeds):
            """[<channel>] <name|url> [<name|url> ...]

            Adds the list of feeds to the current list of announced feeds in
            <channel>.  Valid feeds include the names of registered feeds as
            well as URLs for RSS feeds.  <channel> is only necessary if the
            message isn't sent in the channel itself.
            """
            announce = conf.supybot.plugins.RSS.announce
            S = announce.get(channel)()
            for feed in feeds:
                S.add(feed)
            announce.get(channel).setValue(S)
            irc.replySuccess()
        add = wrap(add, [('checkChannelCapability', 'op'),
                         many(first('url', 'feedName'))])

        @internationalizeDocstring
        def remove(self, irc, msg, args, channel, feeds):
            """[<channel>] <name|url> [<name|url> ...]

            Removes the list of feeds from the current list of announced feeds
            in <channel>.  Valid feeds include the names of registered feeds as
            well as URLs for RSS feeds.  <channel> is only necessary if the
            message isn't sent in the channel itself.
            """
            announce = conf.supybot.plugins.RSS.announce
            S = announce.get(channel)()
            for feed in feeds:
                S.discard(feed)
            announce.get(channel).setValue(S)
            irc.replySuccess()
        remove = wrap(remove, [('checkChannelCapability', 'op'),
                               many(first('url', 'feedName'))])

    @internationalizeDocstring
    def rss(self, irc, msg, args, url, n):
        """<url> [<number of headlines>]

        Gets the title components of the given RSS feed.
        If <number of headlines> is given, return only that many headlines.
        """
        self.log.debug('Fetching %u', url)
        feed = self.getFeed(url)
        if irc.isChannel(msg.args[0]):
            channel = msg.args[0]
        else:
            channel = None
        headlines = self.getHeadlines(feed)
        if not headlines:
            irc.error(_('Couldn\'t get RSS feed.'))
            return
        headlines = self.buildHeadlines(headlines, channel, 'showLinks', 'showPubDate')
        if n:
            headlines = headlines[:n]
        else:
            headlines = headlines[:self.registryValue('defaultNumberOfHeadlines')]
        sep = self.registryValue('headlineSeparator', channel)
        if self.registryValue('bold', channel):
            sep = ircutils.bold(sep)
        irc.replies(headlines, joiner=sep)
    rss = wrap(rss, ['url', additional('int')])

    @internationalizeDocstring
    def info(self, irc, msg, args, url):
        """<url|feed>

        Returns information from the given RSS feed, namely the title,
        URL, description, and last update date, if available.
        """
        try:
            url = self.registryValue('feeds.%s' % url)
        except registry.NonExistentRegistryEntry:
            pass
        feed = self.getFeed(url)
        conv = self._getConverter(feed)
        info = feed.get('feed')
        if not info:
            irc.error(_('I couldn\'t retrieve that RSS feed.'))
            return
        # check the 'modified_parsed' key, if it's there, convert it here first
        if 'modified' in info:
            seconds = time.mktime(info['modified_parsed'])
            now = time.mktime(time.gmtime())
            when = utils.timeElapsed(now - seconds) + ' ago'
        else:
            when = 'time unavailable'
        title = conv(info.get('title', 'unavailable'))
        desc = conv(info.get('description', 'unavailable'))
        link = conv(info.get('link', 'unavailable'))
        # The rest of the entries are all available in the channel key
        response = format(_('Title: %s;  URL: %u;  '
                          'Description: %s;  Last updated: %s.'),
                          title, link, desc, when)
        irc.reply(utils.str.normalizeWhitespace(response))
    info = wrap(info, [first('url', 'feedName')])
RSS = internationalizeDocstring(RSS)

Class = RSS

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2002-2004, Jeremiah Fincher
# Copyright (c) 2009, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

url = 'http://www.advogato.org/rss/articles.xml'
class RSSTestCase(ChannelPluginTestCase):
    plugins = ('RSS','Plugin')
    def testRssAddBadName(self):
        self.assertError('rss add "foo bar" %s' % url)

    def testCantAddFeedNamedRss(self):
        self.assertError('rss add rss %s' % url)

    def testCantRemoveMethodThatIsntFeed(self):
        self.assertError('rss remove rss')

    if network:
        def testRssinfo(self):
            self.assertNotError('rss info %s' % url)
            self.assertNotError('rss add advogato %s' % url)
            self.assertNotError('rss info advogato')
            self.assertNotError('rss info AdVogATo')
            self.assertNotError('rss remove advogato')

        def testRssinfoDoesTimeProperly(self):
            self.assertNotRegexp('rss info http://slashdot.org/slashdot.rss',
                                 '-1 years')

        def testAnnounce(self):
            self.assertNotError('rss add advogato %s' % url)
            self.assertNotError('rss announce add advogato')
            self.assertNotRegexp('rss announce', r'ValueError')
            self.assertNotError('rss announce remove advogato')
            self.assertNotError('rss remove advogato')

        def testRss(self):
            self.assertNotError('rss %s' % url)
            m = self.assertNotError('rss %s 2' % url)
            self.failUnless(m.args[1].count('||') == 1)

        def testRssAdd(self):
            self.assertNotError('rss add advogato %s' % url)
            self.assertNotError('advogato')
            self.assertNotError('rss advogato')
            self.assertNotError('rss remove advogato')
            self.assertNotRegexp('list RSS', 'advogato')
            self.assertError('advogato')
            self.assertError('rss advogato')

        def testNonAsciiFeeds(self):
            self.assertNotError('rss http://www.heise.de/newsticker/heise.rdf')
            self.assertNotError('rss info http://br-linux.org/main/index.xml')


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Scheduler')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Scheduler', True)


Scheduler = conf.registerPlugin('Scheduler')
# This is where your configuration variables (if any) should go.  For example:
# conf.registerGlobalValue(Scheduler, 'someConfigVariableName',
#     registry.Boolean(False, _("""Help for someConfigVariableName.""")))


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2003-2004, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import time
import os
import shutil
import tempfile
import cPickle as pickle

import supybot.conf as conf
import supybot.utils as utils
from supybot.commands import *
import supybot.schedule as schedule
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Scheduler')
import supybot.world as world

datadir = conf.supybot.directories.data()
filename = conf.supybot.directories.data.dirize('Scheduler.pickle')

class Scheduler(callbacks.Plugin):
    def __init__(self, irc):
        self.__parent = super(Scheduler, self)
        self.__parent.__init__(irc)
        self.events = {}
        self._restoreEvents(irc)
        world.flushers.append(self._flush)

    def _restoreEvents(self, irc):
        try:
            pkl = open(filename, 'rb')
            try:
                eventdict = pickle.load(pkl)
            except Exception as e:
                self.log.debug('Unable to load pickled data: %s', e)
                return
            finally:
                pkl.close()
        except IOError as e:
            self.log.debug('Unable to open pickle file: %s', e)
            return
        for name, event in eventdict.iteritems():
            ircobj = callbacks.ReplyIrcProxy(irc, event['msg'])
            try:
                if event['type'] == 'single': # non-repeating event
                    n = None
                    if schedule.schedule.counter > int(name):
                        # counter not reset, we're probably reloading the plugin
                        # though we'll never know for sure, because other
                        # plugins can schedule stuff, too.
                        n = int(name)
                    self._add(ircobj, event['msg'],
                              event['time'], event['command'], n)
                elif event['type'] == 'repeat': # repeating event
                    self._repeat(ircobj, event['msg'], name,
                                 event['time'], event['command'], False)
            except AssertionError as e:
                if str(e) == 'An event with the same name has already been scheduled.':
                    # we must be reloading the plugin, event is still scheduled
                    self.log.info('Event %s already exists, adding to dict.' % (name,))
                    self.events[name] = event
                else:
                    raise

    def _flush(self):
        try:
            pklfd, tempfn = tempfile.mkstemp(suffix='scheduler', dir=datadir)
            pkl = os.fdopen(pklfd, 'wb')
            try:
                pickle.dump(self.events, pkl)
            except Exception as e:
                self.log.warning('Unable to store pickled data: %s', e)
            pkl.close()
            shutil.move(tempfn, filename)
        except (IOError, shutil.Error) as e:
            self.log.warning('File error: %s', e)

    def die(self):
        self._flush()
        world.flushers.remove(self._flush)
        self.__parent.die()

    def _makeCommandFunction(self, irc, msg, command, remove=True):
        """Makes a function suitable for scheduling from command."""
        tokens = callbacks.tokenize(command)
        def f():
            if remove:
                del self.events[str(f.eventId)]
            self.Proxy(irc.irc, msg, tokens)
        return f

    def _add(self, irc, msg, t, command, name=None):
        f = self._makeCommandFunction(irc, msg, command)
        id = schedule.addEvent(f, t, name)
        f.eventId = id
        self.events[str(id)] = {'command':command,
                                'msg':msg,
                                'time':t,
                                'type':'single'}
        return id

    @internationalizeDocstring
    def add(self, irc, msg, args, seconds, command):
        """<seconds> <command>

        Schedules the command string <command> to run <seconds> seconds in the
        future.  For example, 'scheduler add [seconds 30m] "echo [cpu]"' will
        schedule the command "cpu" to be sent to the channel the schedule add
        command was given in (with no prefixed nick, a consequence of using
        echo).  Do pay attention to the quotes in that example.
        """
        t = time.time() + seconds
        id = self._add(irc, msg, t, command)
        irc.replySuccess(format(_('Event #%i added.'), id))
    add = wrap(add, ['positiveInt', 'text'])

    @internationalizeDocstring
    def remove(self, irc, msg, args, id):
        """<id>

        Removes the event scheduled with id <id> from the schedule.
        """
        if id in self.events:
            del self.events[id]
            try:
                id = int(id)
            except ValueError:
                pass
            try:
                schedule.removeEvent(id)
                irc.replySuccess()
            except KeyError:
                irc.error(_('Invalid event id.'))
        else:
            irc.error(_('Invalid event id.'))
    remove = wrap(remove, ['lowered'])

    def _repeat(self, irc, msg, name, seconds, command, now=True):
        f = self._makeCommandFunction(irc, msg, command, remove=False)
        id = schedule.addPeriodicEvent(f, seconds, name, now)
        assert id == name
        self.events[name] = {'command':command,
                             'msg':msg,
                             'time':seconds,
                             'type':'repeat'}

    @internationalizeDocstring
    def repeat(self, irc, msg, args, name, seconds, command):
        """<name> <seconds> <command>

        Schedules the command <command> to run every <seconds> seconds,
        starting now (i.e., the command runs now, and every <seconds> seconds
        thereafter).  <name> is a name by which the command can be
        unscheduled.
        """
        name = name.lower()
        if name in self.events:
            irc.error(_('There is already an event with that name, please '
                      'choose another name.'), Raise=True)
        self._repeat(irc, msg, name, seconds, command)
        # We don't reply because the command runs immediately.
        # But should we?  What if the command doesn't have visible output?
        # irc.replySuccess()
    repeat = wrap(repeat, ['nonInt', 'positiveInt', 'text'])

    @internationalizeDocstring
    def list(self, irc, msg, args):
        """takes no arguments

        Lists the currently scheduled events.
        """
        L = self.events.items()
        if L:
            L.sort()
            for (i, (name, command)) in enumerate(L):
                L[i] = format('%s: %q', name, command['command'])
            irc.reply(format('%L', L))
        else:
            irc.reply(_('There are currently no scheduled commands.'))
    list = wrap(list)


Class = Scheduler

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2002-2004, Jeremiah Fincher
# Copyright (c) 2008, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

import supybot.schedule as schedule

class SchedulerTestCase(ChannelPluginTestCase):
    plugins = ('Scheduler', 'Utilities')
    def tearDown(self):
        schedule.schedule.reset()
        ChannelPluginTestCase.tearDown(self)

    def testAddRemove(self):
        self.assertRegexp('scheduler list', 'no.*commands')
        m = self.assertNotError('scheduler add 5 echo testAddRemove')
        self.assertNotRegexp('scheduler list', 'no.*commands')
        self.assertNoResponse(' ', 3)
        self.assertResponse(' ', 'testAddRemove')
        m = self.assertNotError('scheduler add 5 echo testAddRemove2')
        # Get id.
        id = None
        for s in m.args[1].split():
            s = s.lstrip('#')
            if s.isdigit():
                id = s
                break
        self.failUnless(id, 'Couldn\'t find id in reply.')
        self.assertNotError('scheduler remove %s' % id)
        self.assertNoResponse(' ', 5)

    # Need this test to run first so it has id 0 for its event
    def test00RemoveZero(self):
        id = None
        m = self.assertNotError('scheduler add 5 echo testRemoveZero')
        for s in m.args[1].split():
            s = s.lstrip('#')
            if s.isdigit():
                id = s
                break
        self.assertNotError('scheduler remove %s' % id)
        self.assertNoResponse(' ', 5)

    def testRepeat(self):
        self.assertNotError('scheduler repeat repeater 5 echo testRepeat')
        self.assertResponse(' ', 'testRepeat')
        self.assertResponse('scheduler list', 'repeater: "echo testRepeat"')
        self.assertNoResponse(' ', 3)
        self.assertResponse(' ', 'testRepeat')
        self.assertNotError('scheduler remove repeater')
        self.assertNotRegexp('scheduler list', 'repeater')
        self.assertNoResponse(' ', 5)

    def testRepeatWorksWithNestedCommands(self):
        self.assertNotError('scheduler repeat foo 5 "echo foo [echo nested]"')
        self.assertResponse(' ', 'foo nested')
        self.assertNoResponse(' ', 3)
        self.assertResponse(' ', 'foo nested')
        self.assertNotError('scheduler remove foo')
        self.assertNoResponse(' ', 5)

    def testRepeatDisallowsIntegerNames(self):
        self.assertError('scheduler repeat 1234 1234 "echo NoIntegerNames"')

    def testRepeatDisallowsDuplicateNames(self):
        self.assertNotError('scheduler repeat foo 5 "echo foo"')
        self.assertError('scheduler repeat foo 5 "echo another foo fails"')


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:


########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Seen')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Seen', True)


Seen = conf.registerPlugin('Seen')
# This is where your configuration variables (if any) should go.  For example:
# conf.registerGlobalValue(Seen, 'someConfigVariableName',
#     registry.Boolean(False, _("""Help for someConfigVariableName.""")))
conf.registerChannelValue(Seen, 'minimumNonWildcard',
    registry.NonNegativeInteger(2, _("""The minimum non-wildcard characters
    required to perform a 'seen' request. Of course, it only applies if there
    is a wildcard in the request.""")))
conf.registerChannelValue(Seen, 'showLastMessage',
    registry.Boolean(True, _("""Determines whether the last message will
    be displayed with @seen. Useful for keeping messages from a channel
    private.""")))


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2002-2004, Jeremiah Fincher
# Copyright (c) 2010-2011, 2013, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import re
import sys
import time

import supybot.log as log
import supybot.conf as conf
import supybot.utils as utils
import supybot.world as world
import supybot.ircdb as ircdb
from supybot.commands import *
import supybot.irclib as irclib
import supybot.ircmsgs as ircmsgs
import supybot.plugins as plugins
import supybot.ircutils as ircutils
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Seen')

class IrcStringAndIntDict(utils.InsensitivePreservingDict):
    def key(self, x):
        if isinstance(x, int):
            return x
        else:
            return ircutils.toLower(x)

class SeenDB(plugins.ChannelUserDB):
    IdDict = IrcStringAndIntDict
    def serialize(self, v):
        return list(v)

    def deserialize(self, channel, id, L):
        (seen, saying) = L
        return (float(seen), saying)

    def update(self, channel, nickOrId, saying):
        seen = time.time()
        self[channel, nickOrId] = (seen, saying)
        self[channel, '<last>'] = (seen, saying)

    def seenWildcard(self, channel, nick):
        nicks = ircutils.IrcSet()
        nickRe = re.compile('^%s$' % '.*'.join(nick.split('*')), re.I)
        for (searchChan, searchNick) in self.keys():
            #print 'chan: %s ... nick: %s' % (searchChan, searchNick)
            if isinstance(searchNick, int):
                # We need to skip the reponses that are keyed by id as they
                # apparently duplicate the responses for the same person that
                # are keyed by nick-string
                continue
            if ircutils.strEqual(searchChan, channel):
                if nickRe.search(searchNick) is not None:
                    nicks.add(searchNick)
        L = [[nick, self.seen(channel, nick)] for nick in nicks]
        def negativeTime(x):
            return -x[1][0]
        utils.sortBy(negativeTime, L)
        return L

    def seen(self, channel, nickOrId):
        return self[channel, nickOrId]

filename = conf.supybot.directories.data.dirize('Seen.db')
anyfilename = conf.supybot.directories.data.dirize('Seen.any.db')

class Seen(callbacks.Plugin):
    noIgnore = True
    def __init__(self, irc):
        self.__parent = super(Seen, self)
        self.__parent.__init__(irc)
        self.db = SeenDB(filename)
        self.anydb = SeenDB(anyfilename)
        self.lastmsg = {}
        self.ircstates = {}
        world.flushers.append(self.db.flush)
        world.flushers.append(self.anydb.flush)

    def die(self):
        if self.db.flush in world.flushers:
            world.flushers.remove(self.db.flush)
        else:
            self.log.debug('Odd, no flush in flushers: %r', world.flushers)
        self.db.close()
        if self.anydb.flush in world.flushers:
            world.flushers.remove(self.anydb.flush)
        else:
            self.log.debug('Odd, no flush in flushers: %r', world.flushers)
        self.anydb.close()
        self.__parent.die()

    def __call__(self, irc, msg):
        try:
            if irc not in self.ircstates:
                self._addIrc(irc)
            self.ircstates[irc].addMsg(irc, self.lastmsg[irc])
        finally:
            self.lastmsg[irc] = msg
        self.__parent.__call__(irc, msg)

    def _addIrc(self, irc):
        # Let's just be extra-special-careful here.
        if irc not in self.ircstates:
            self.ircstates[irc] = irclib.IrcState()
        if irc not in self.lastmsg:
            self.lastmsg[irc] = ircmsgs.ping('this is just a fake message')
        if not world.testing:
            for channel in irc.state.channels:
                irc.queueMsg(ircmsgs.who(channel))
                irc.queueMsg(ircmsgs.names(channel))

    def doPrivmsg(self, irc, msg):
        if ircmsgs.isCtcp(msg) and not ircmsgs.isAction(msg):
            return
        if irc.isChannel(msg.args[0]):
            channel = msg.args[0]
            said = ircmsgs.prettyPrint(msg)
            self.db.update(channel, msg.nick, said)
            self.anydb.update(channel, msg.nick, said)
            try:
                id = ircdb.users.getUserId(msg.prefix)
                self.db.update(channel, id, said)
                self.anydb.update(channel, id, said)
            except KeyError:
                pass # Not in the database.

    def doPart(self, irc, msg):
        channel = msg.args[0]
        said = ircmsgs.prettyPrint(msg)
        self.anydb.update(channel, msg.nick, said)
        try:
            id = ircdb.users.getUserId(msg.prefix)
            self.anydb.update(channel, id, said)
        except KeyError:
            pass # Not in the database.
    doJoin = doPart
    doKick = doPart

    def doQuit(self, irc, msg):
        said = ircmsgs.prettyPrint(msg)
        if irc not in self.ircstates:
            return
        try:
            id = ircdb.users.getUserId(msg.prefix)
        except KeyError:
            id = None # Not in the database.
        for channel in self.ircstates[irc].channels:
            if msg.nick in self.ircstates[irc].channels[channel].users:
                self.anydb.update(channel, msg.nick, said)
                if id is not None:
                    self.anydb.update(channel, id, said)
    doNick = doQuit

    def doMode(self, irc, msg):
        # Filter out messages from network Services
        if msg.nick:
            self.doQuit(irc, msg)
    doTopic = doMode

    def _seen(self, irc, channel, name, any=False):
        if any:
            db = self.anydb
        else:
            db = self.db
        try:
            results = []
            if '*' in name:
                if (len(name.replace('*', '')) <
                        self.registryValue('minimumNonWildcard', channel)):
                    irc.error(_('Not enough non-wildcard characters.'),
                            Raise=True)
                results = db.seenWildcard(channel, name)
            else:
                results = [[name, db.seen(channel, name)]]
            if len(results) == 1:
                (nick, info) = results[0]
                (when, said) = info
                reply = format(_('%s was last seen in %s %s ago'),
                                 nick, channel,
                                 utils.timeElapsed(time.time()-when))
                if self.registryValue('showLastMessage', channel):
                    if sys.version_info[0] < 3:
                        said = said.decode('utf8')
                    reply = _('%s: %s') % (reply, said)
                irc.reply(reply)
            elif len(results) > 1:
                L = []
                for (nick, info) in results:
                    (when, said) = info
                    L.append(format(_('%s (%s ago)'), nick,
                                    utils.timeElapsed(time.time()-when)))
                irc.reply(format(_('%s could be %L'), name, (L, _('or'))))
            else:
                irc.reply(format(_('I haven\'t seen anyone matching %s.'), name))
        except KeyError:
            irc.reply(format(_('I have not seen %s.'), name))

    @internationalizeDocstring
    def seen(self, irc, msg, args, channel, name):
        """[<channel>] <nick>

        Returns the last time <nick> was seen and what <nick> was last seen
        saying. <channel> is only necessary if the message isn't sent on the
        channel itself. <nick> may contain * as a wildcard.
        """
        if msg.nick not in irc.state.channels[channel].users:
            irc.error(format('You must be in %s to use this command.', channel))
            return
        self._seen(irc, channel, name)
    seen = wrap(seen, ['channel', 'something'])

    @internationalizeDocstring
    def any(self, irc, msg, args, channel, optlist, name):
        """[<channel>] [--user <name>] [<nick>]

        Returns the last time <nick> was seen and what <nick> was last seen
        doing.  This includes any form of activity, instead of just PRIVMSGs.
        If <nick> isn't specified, returns the last activity seen in
        <channel>.  If --user is specified, looks up name in the user database
        and returns the last time user was active in <channel>.  <channel> is
        only necessary if the message isn't sent on the channel itself.
        """
        if msg.nick not in irc.state.channels[channel].users:
            irc.error(format('You must be in %s to use this command.', channel))
            return
        if name and optlist:
            raise callbacks.ArgumentError
        elif name:
            self._seen(irc, channel, name, any=True)
        elif optlist:
            for (option, arg) in optlist:
                if option == 'user':
                    user = arg
            self._user(irc, channel, user, any=True)
        else:
            self._last(irc, channel, any=True)
    any = wrap(any, ['channel', getopts({'user': 'otherUser'}),
                     additional('something')])

    def _last(self, irc, channel, any=False):
        if any:
            db = self.anydb
        else:
            db = self.db
        try:
            (when, said) = db.seen(channel, '<last>')
            reply = format(_('Someone was last seen in %s %s ago'),
                             channel, utils.timeElapsed(time.time()-when))
            if self.registryValue('showLastMessage', channel):
                reply = _('%s: %s') % (reply, said)
            irc.reply(reply)
        except KeyError:
            irc.reply(_('I have never seen anyone.'))

    @internationalizeDocstring
    def last(self, irc, msg, args, channel):
        """[<channel>]

        Returns the last thing said in <channel>.  <channel> is only necessary
        if the message isn't sent in the channel itself.
        """
        if msg.nick not in irc.state.channels[channel].users:
            irc.error(format('You must be in %s to use this command.', channel))
            return
        self._last(irc, channel)
    last = wrap(last, ['channel'])

    def _user(self, irc, channel, user, any=False):
        if any:
            db = self.anydb
        else:
            db = self.db
        try:
            (when, said) = db.seen(channel, user.id)
            reply = format(_('%s was last seen in %s %s ago'),
                             user.name, channel,
                             utils.timeElapsed(time.time()-when))
            if self.registryValue('showLastMessage', channel):
                reply = _('%s: %s') % (reply, said)
            irc.reply(reply)
        except KeyError:
            irc.reply(format(_('I have not seen %s.'), user.name))

    @internationalizeDocstring
    def user(self, irc, msg, args, channel, user):
        """[<channel>] <name>

        Returns the last time <name> was seen and what <name> was last seen
        saying.  This looks up <name> in the user seen database, which means
        that it could be any nick recognized as user <name> that was seen.
        <channel> is only necessary if the message isn't sent in the channel
        itself.
        """
        if msg.nick not in irc.state.channels[channel].users:
            irc.error(format('You must be in %s to use this command.', channel))
            return
        self._user(irc, channel, user)
    user = wrap(user, ['channel', 'otherUser'])

    @internationalizeDocstring
    def since(self, irc, msg, args, channel,  nick):
        """[<channel>] [<nick>]

        Returns the messages since <nick> last left the channel.
        If <nick> is not given, it defaults to the nickname of the person
        calling the command.
        """
        if nick is None:
            nick = msg.nick
        if channel not in irc.state.channels:
            irc.error(_('I am not in %s.') % channel)
            return
        if nick not in irc.state.channels[channel].users:
            irc.error(format(_('%s must be in %s to use this command.'),
                ('You' if nick == msg.nick else nick), channel))
            return
        if nick is None:
            nick = msg.nick
        end = None # By default, up until the most recent message.
        for (i, m) in utils.seq.renumerate(irc.state.history):
            if end is None and m.command == 'JOIN' and \
               ircutils.strEqual(m.args[0], channel) and \
               ircutils.strEqual(m.nick, nick):
                end = i
            if m.command == 'PART' and \
               ircutils.strEqual(m.nick, nick) and \
               ircutils.strEqual(m.args[0], channel):
                break
            elif m.command == 'QUIT' and ircutils.strEqual(m.nick, nick):
                # XXX We assume the person was in-channel at this point.
                break
            elif m.command == 'KICK' and \
                 ircutils.strEqual(m.args[1], nick) and \
                 ircutils.strEqual(m.args[0], channel):
                break
        else: # I never use this; it only kicks in when the for loop exited normally.
            irc.error(format(_('I couldn\'t find in my history of %s messages '
                             'where %r last left %s'),
                             len(irc.state.history), nick, channel))
            return
        msgs = [m for m in irc.state.history[i:end]
                if m.command == 'PRIVMSG' and ircutils.strEqual(m.args[0], channel)]
        if msgs:
            irc.reply(format('%L', list(map(ircmsgs.prettyPrint, msgs))))
        else:
            irc.reply(format(_('Either %s didn\'t leave, '
                             'or no messages were sent while %s was gone.'), nick, nick))
    since = wrap(since, ['channel', additional('nick')])

Class = Seen

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2002-2004, Jeremiah Fincher
# Copyright (c) 2013, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

import supybot.ircdb as ircdb

class ChannelDBTestCase(ChannelPluginTestCase):
    plugins = ('Seen', 'User')
    def setUp(self):
        ChannelPluginTestCase.setUp(self)
        self.prefix = 'foo!bar@baz'
        self.nick = 'foo'
        self.wildcardTest = ['f*', '*oo', '*foo*', 'f*o*o']
        self.irc.feedMsg(ircmsgs.privmsg(self.irc.nick,
                                         'register foo bar',
                                         prefix=self.prefix))
        _ = self.irc.takeMsg()
        chancap = ircdb.makeChannelCapability(self.channel, 'op')
        ircdb.users.getUser(self.nick).addCapability(chancap)

    def testNoKeyErrorEscapeFromSeen(self):
        self.irc.feedMsg(ircmsgs.join(self.channel, self.irc.nick,
                                         prefix=self.prefix))
        self.assertRegexp('seen asldfkjasdlfkj', '^I have not seen')
        self.assertNotRegexp('seen asldfkjasdlfkj', 'KeyError')

    def testAny(self):
        self.irc.feedMsg(ircmsgs.join(self.channel, self.irc.nick,
                                         prefix=self.prefix))
        self.assertRegexp('seen any', '%s <%s> has joined' %
                (self.nick, self.prefix))
        self.irc.feedMsg(ircmsgs.mode(self.channel, args=('+o', self.nick),
                                      prefix=self.prefix))
        self.assertRegexp('seen any %s' % self.nick,
                    '^%s was last seen.*:' % self.nick)
        with conf.supybot.plugins.seen.showLastMessage.context(False):
            self.assertRegexp('seen any %s' % self.nick,
                        '^%s was last seen[^:]*' % self.nick)
        self.assertNotError('config plugins.Seen.minimumNonWildcard 0')
        orig = conf.supybot.protocols.irc.strictRfc()
        try:
            for state in (True, False):
                conf.supybot.protocols.irc.strictRfc.setValue(state)
                for wildcard in self.wildcardTest:
                    self.assertRegexp('seen any %s' % wildcard,
                                      '^%s was last seen' % self.nick)
                self.assertRegexp('seen any bar*', '^I haven\'t seen anyone matching')
        finally:
            conf.supybot.protocols.irc.strictRfc.setValue(orig)

    def testSeen(self):
        self.irc.feedMsg(ircmsgs.join(self.channel, self.irc.nick,
                                         prefix=self.prefix))
        self.assertNotError('seen last')
        self.assertNotError('list')
        self.assertNotError('config plugins.Seen.minimumNonWildcard 2')
        self.assertError('seen *')
        self.assertNotError('seen %s' % self.nick)
        m = self.assertNotError('seen %s' % self.nick.upper())
        self.failUnless(self.nick.upper() in m.args[1])
        self.assertRegexp('seen user %s' % self.nick,
                          '^%s was last seen' % self.nick)
        self.assertNotError('config plugins.Seen.minimumNonWildcard 0')
        orig = conf.supybot.protocols.irc.strictRfc()
        try:
            for state in (True, False):
                conf.supybot.protocols.irc.strictRfc.setValue(state)
                for wildcard in self.wildcardTest:
                    self.assertRegexp('seen %s' % wildcard,
                                      '^%s was last seen' % self.nick)
                self.assertRegexp('seen bar*', '^I haven\'t seen anyone matching')
        finally:
            conf.supybot.protocols.irc.strictRfc.setValue(orig)

    def testSeenNoUser(self):
        self.irc.feedMsg(ircmsgs.join(self.channel, self.irc.nick,
                                         prefix=self.prefix))
        self.assertNotRegexp('seen user alsdkfjalsdfkj', 'KeyError')


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:


########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2005, Jeremiah Fincher
# Copyright (c) 2010, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.ircutils as ircutils
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Services')

def registerNick(nick, password=''):
    p = conf.supybot.plugins.Services.Nickserv.get('password')
    h = _('Determines what password the bot will use with NickServ when ' \
        'identifying as %s.') % nick
    v = conf.registerGlobalValue(p, nick,
                                 registry.String(password, h, private=True))
    if password:
        v.setValue(password)

def configure(advanced):
    from supybot.questions import expect, anything, something, yn, getpass
    conf.registerPlugin('Services', True)
    nick = something(_('What is your registered nick?'))
    password = something(_('What is your password for that nick?'))
    chanserv = something(_('What is your ChanServ named?'), default='ChanServ')
    nickserv = something(_('What is your NickServ named?'), default='NickServ')
    conf.supybot.plugins.Services.nicks.setValue([nick])
    conf.supybot.plugins.Services.NickServ.setValue(nickserv)
    registerNick(nick, password)
    conf.supybot.plugins.Services.ChanServ.setValue(chanserv)

class ValidNickOrEmptyString(registry.String):
    def setValue(self, v):
        if v and not ircutils.isNick(v):
            raise registry.InvalidRegistryValue('Value must be a valid nick or the empty string.')
        registry.String.setValue(self, v)

class ValidNickSet(conf.ValidNicks):
    List = ircutils.IrcSet

Services = conf.registerPlugin('Services')
conf.registerGlobalValue(Services, 'nicks',
    ValidNickSet([], _("""Determines what nicks the bot will use with
    services.""")))

class Networks(registry.SpaceSeparatedSetOfStrings):
    List = ircutils.IrcSet

conf.registerGlobalValue(Services, 'disabledNetworks',
    Networks(_('QuakeNet').split(), _("""Determines what networks this plugin
    will be disabled on.""")))

conf.registerGlobalValue(Services, 'noJoinsUntilIdentified',
    registry.Boolean(False, _("""Determines whether the bot will not join any
    channels until it is identified.  This may be useful, for instances, if
    you have a vhost that isn't set until you're identified, or if you're
    joining +r channels that won't allow you to join unless you identify.""")))
conf.registerGlobalValue(Services, 'ghostDelay',
    registry.PositiveInteger(60, _("""Determines how many seconds the bot will
    wait between successive GHOST attempts.""")))
conf.registerGlobalValue(Services, 'NickServ',
    ValidNickOrEmptyString('', _("""Determines what nick the 'NickServ' service
    has.""")))
conf.registerGroup(Services.NickServ, 'password')
conf.registerGlobalValue(Services, 'ChanServ',
    ValidNickOrEmptyString('', _("""Determines what nick the 'ChanServ' service
    has.""")))
conf.registerChannelValue(Services.ChanServ, 'password',
    registry.String('', _("""Determines what password the bot will use with
    ChanServ."""), private=True))
conf.registerChannelValue(Services.ChanServ, 'op',
    registry.Boolean(False, _("""Determines whether the bot will request to get
    opped by the ChanServ when it joins the channel.""")))
conf.registerChannelValue(Services.ChanServ, 'halfop',
    registry.Boolean(False, _("""Determines whether the bot will request to get
    half-opped by the ChanServ when it joins the channel.""")))
conf.registerChannelValue(Services.ChanServ, 'voice',
    registry.Boolean(False, _("""Determines whether the bot will request to get
    voiced by the ChanServ when it joins the channel.""")))

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2002-2004, Jeremiah Fincher
# Copyright (c) 2010, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import re
import time

import config

import supybot.conf as conf
import supybot.utils as utils
from supybot.commands import *
import supybot.ircmsgs as ircmsgs
import supybot.ircutils as ircutils
import supybot.schedule as schedule
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Services')

class Services(callbacks.Plugin):
    """This plugin handles dealing with Services on networks that provide them.
    Basically, you should use the "password" command to tell the bot a nick to
    identify with and what password to use to identify with that nick.  You can
    use the password command multiple times if your bot has multiple nicks
    registered.  Also, be sure to configure the NickServ and ChanServ
    configuration variables to match the NickServ and ChanServ nicks on your
    network.  Other commands such as identify, op, etc. should not be
    necessary if the bot is properly configured."""
    def __init__(self, irc):
        self.__parent = super(Services, self)
        self.__parent.__init__(irc)
        for nick in self.registryValue('nicks'):
            config.registerNick(nick)
        self.reset()

    def reset(self):
        self.channels = []
        self.sentGhost = None
        self.identified = False
        self.waitingJoins = {}

    def disabled(self, irc):
        disabled = self.registryValue('disabledNetworks')
        if irc.network in disabled or \
           irc.state.supported.get('NETWORK', '') in disabled:
            return True
        return False

    def outFilter(self, irc, msg):
        if msg.command == 'JOIN' and not self.disabled(irc):
            if not self.identified:
                if self.registryValue('noJoinsUntilIdentified'):
                    self.log.info('Holding JOIN to %s until identified.',
                                  msg.args[0])
                    self.waitingJoins.setdefault(irc.network, [])
                    self.waitingJoins[irc.network].append(msg)
                    return None
        return msg

    def _getNick(self, network):
        network_nick = conf.supybot.networks.get(network).nick()
        if network_nick == '':
            return conf.supybot.nick()
        else:
            return network_nick

    def _getNickServPassword(self, nick):
        # This should later be nick-specific.
        assert nick in self.registryValue('nicks')
        return self.registryValue('NickServ.password.%s' % nick)

    def _setNickServPassword(self, nick, password):
        # This also should be nick-specific.
        assert nick in self.registryValue('nicks')
        self.setRegistryValue('NickServ.password.%s' % nick, password)

    def _doIdentify(self, irc, nick=None):
        if self.disabled(irc):
            return
        if nick is None:
            nick = self._getNick(irc.network)
        if nick not in self.registryValue('nicks'):
            return
        nickserv = self.registryValue('NickServ')
        password = self._getNickServPassword(nick)
        if not nickserv or not password:
            s = 'Tried to identify without a NickServ or password set.'
            self.log.warning(s)
            return
        assert ircutils.strEqual(irc.nick, nick), \
               'Identifying with not normal nick.'
        self.log.info('Sending identify (current nick: %s)', irc.nick)
        identify = 'IDENTIFY %s' % password
        # It's important that this next statement is irc.sendMsg, not
        # irc.queueMsg.  We want this message to get through before any
        # JOIN messages also being sent on 376.
        irc.sendMsg(ircmsgs.privmsg(nickserv, identify))

    def _doGhost(self, irc, nick=None):
        if self.disabled(irc):
            return
        if nick is None:
            nick = self._getNick(irc.network)
        if nick not in self.registryValue('nicks'):
            return
        nickserv = self.registryValue('NickServ')
        password = self._getNickServPassword(nick)
        ghostDelay = self.registryValue('ghostDelay')
        if not nickserv or not password:
            s = 'Tried to ghost without a NickServ or password set.'
            self.log.warning(s)
            return
        if self.sentGhost and time.time() < (self.sentGhost + ghostDelay):
            self.log.warning('Refusing to send GHOST more than once every '
                             '%s seconds.' % ghostDelay)
        elif not password:
            self.log.warning('Not ghosting: no password set.')
            return
        else:
            self.log.info('Sending ghost (current nick: %s; ghosting: %s)',
                          irc.nick, nick)
            ghost = 'GHOST %s %s' % (nick, password)
            # Ditto about the sendMsg (see _doIdentify).
            irc.sendMsg(ircmsgs.privmsg(nickserv, ghost))
            self.sentGhost = time.time()

    def __call__(self, irc, msg):
        self.__parent.__call__(irc, msg)
        if self.disabled(irc):
            return
        nick = self._getNick(irc.network)
        if nick not in self.registryValue('nicks'):
            return
        nickserv = self.registryValue('NickServ')
        password = self._getNickServPassword(nick)
        ghostDelay = self.registryValue('ghostDelay')
        if nick and nickserv and password and \
           not ircutils.strEqual(nick, irc.nick):
            if irc.afterConnect and (self.sentGhost is None or
               (self.sentGhost + ghostDelay) < time.time()):
                if nick in irc.state.nicksToHostmasks:
                    self._doGhost(irc)
                else:
                    irc.sendMsg(ircmsgs.nick(nick)) # 433 is handled elsewhere.

    def do001(self, irc, msg):
        # New connection, make sure sentGhost is False.
        self.sentGhost = None

    def do376(self, irc, msg):
        if self.disabled(irc):
            return
        nick = self._getNick(irc.network)
        if nick not in self.registryValue('nicks'):
            return
        nickserv = self.registryValue('NickServ')
        if not nickserv:
            self.log.warning('NickServ is unset, cannot identify.')
            return
        password = self._getNickServPassword(nick)
        if not password:
            self.log.warning('Password for %s is unset, cannot identify.',nick)
            return
        if not nick:
            self.log.warning('Cannot identify without a nick being set.  '
                             'Set supybot.plugins.Services.nick.')
            return
        if ircutils.strEqual(irc.nick, nick):
            self._doIdentify(irc)
        else:
            self._doGhost(irc)
    do422 = do377 = do376

    def do433(self, irc, msg):
        if self.disabled(irc):
            return
        nick = self._getNick(irc.network)
        if nick not in self.registryValue('nicks'):
            return
        if nick and irc.afterConnect:
            password = self._getNickServPassword(nick)
            if not password:
                return
            self._doGhost(irc)

    def do515(self, irc, msg):
        # Can't join this channel, it's +r (we must be identified).
        self.channels.append(msg.args[1])

    def doNick(self, irc, msg):
        nick = self._getNick(irc.network)
        if ircutils.strEqual(msg.args[0], irc.nick) and \
           ircutils.strEqual(irc.nick, nick):
            self._doIdentify(irc)
        elif ircutils.strEqual(msg.nick, nick):
            irc.sendMsg(ircmsgs.nick(nick))

    def _ghosted(self, irc, s):
        nick = self._getNick(irc.network)
        lowered = s.lower()
        return bool('killed' in lowered and (nick in s or 'ghost' in lowered))

    def doNotice(self, irc, msg):
        if irc.afterConnect:
            nickserv = self.registryValue('NickServ')
            chanserv = self.registryValue('ChanServ')
            if nickserv and ircutils.strEqual(msg.nick, nickserv):
                self.doNickservNotice(irc, msg)
            elif chanserv and ircutils.strEqual(msg.nick, chanserv):
                self.doChanservNotice(irc, msg)

    _chanRe = re.compile('\x02(.*?)\x02')
    def doChanservNotice(self, irc, msg):
        if self.disabled(irc):
            return
        s = msg.args[1].lower()
        channel = None
        m = self._chanRe.search(s)
        networkGroup = conf.supybot.networks.get(irc.network)
        on = 'on %s' % irc.network
        if m is not None:
            channel = m.group(1)
        if 'all bans' in s or 'unbanned from' in s:
            # All bans removed (freenode)
            # You have been unbanned from (oftc)
            irc.sendMsg(networkGroup.channels.join(channel))
        elif 'isn\'t registered' in s:
            self.log.warning('Received "%s isn\'t registered" from ChanServ %s',
                             channel, on)
        elif 'this channel has been registered' in s:
            self.log.debug('Got "Registered channel" from ChanServ %s.', on)
        elif 'already opped' in s:
            # This shouldn't happen, Services.op should refuse to run if
            # we already have ops.
            self.log.debug('Got "Already opped" from ChanServ %s.', on)
        elif 'access level' in s and 'is required' in s:
            self.log.warning('Got "Access level required" from ChanServ %s.',
                             on)
        elif 'inviting' in s:
            self.log.debug('Got "Inviting to channel" from ChanServ %s.', on)
        elif s.startswith('['):
            chanTypes = irc.state.supported['CHANTYPES']
            if re.match(r'^\[[%s]' % re.escape(chanTypes), s):
                self.log.debug('Got entrymsg from ChanServ %s.', on)
        else:
            self.log.warning('Got unexpected notice from ChanServ %s: %r.',
                             on, msg)

    def doNickservNotice(self, irc, msg):
        if self.disabled(irc):
            return
        nick = self._getNick(irc.network)
        s = ircutils.stripFormatting(msg.args[1].lower())
        on = 'on %s' % irc.network
        networkGroup = conf.supybot.networks.get(irc.network)
        if 'incorrect' in s or 'denied' in s:
            log = 'Received "Password Incorrect" from NickServ %s.  ' \
                  'Resetting password to empty.' % on
            self.log.warning(log)
            self.sentGhost = time.time()
            self._setNickServPassword(nick, '')
        elif self._ghosted(irc, s):
            self.log.info('Received "GHOST succeeded" from NickServ %s.', on)
            self.sentGhost = None
            self.identified = False
            irc.queueMsg(ircmsgs.nick(nick))
        elif 'is not registered' in s:
            self.log.info('Received "Nick not registered" from NickServ %s.',
                          on)
        elif 'currently' in s and 'isn\'t' in s or 'is not' in s:
            # The nick isn't online, let's change our nick to it.
            self.sentGhost = None
            irc.queueMsg(ircmsgs.nick(nick))
        elif ('owned by someone else' in s) or \
             ('nickname is registered and protected' in s) or \
             ('nick belongs to another user' in s):
            # freenode, arstechnica, chatjunkies
            # oftc, zirc.org
            # sorcery
            self.log.info('Received "Registered nick" from NickServ %s.', on)
        elif '/msg' in s and 'id' in s and 'password' in s:
            # Usage info for identify command; ignore.
            self.log.debug('Got usage info for identify command %s.', on)
        elif ('please choose a different nick' in s): # oftc, part 3
            # This is a catch-all for redundant messages from nickserv.
            pass
        elif ('now recognized' in s) or \
             ('already identified' in s) or \
             ('already logged in' in s) or \
             ('successfully identified' in s) or \
             ('password accepted' in s) or \
             ('now identified' in s):
            # freenode, oftc, arstechnica, zirc, ....
            # sorcery
            self.log.info('Received "Password accepted" from NickServ %s.', on)
            self.identified = True
            for channel in irc.state.channels.keys():
                self.checkPrivileges(irc, channel)
            for channel in self.channels:
                irc.queueMsg(networkGroup.channels.join(channel))
            waitingJoins = self.waitingJoins.pop(irc.network, None)
            if waitingJoins:
                for m in waitingJoins:
                    irc.sendMsg(m)
        elif 'not yet authenticated' in s:
            # zirc.org has this, it requires an auth code.
            email = s.split()[-1]
            self.log.warning('Received "Nick not yet authenticated" from '
                             'NickServ %s.  Check email at %s and send the '
                             'auth command to NickServ.', on, email)
        else:
            self.log.debug('Unexpected notice from NickServ %s: %q.', on, s)

    def checkPrivileges(self, irc, channel):
        if self.disabled(irc):
            return
        chanserv = self.registryValue('ChanServ')
        on = 'on %s' % irc.network
        if chanserv and self.registryValue('ChanServ.op', channel):
            if irc.nick not in irc.state.channels[channel].ops:
                self.log.info('Requesting op from %s in %s %s.',
                              chanserv, channel, on)
                irc.sendMsg(ircmsgs.privmsg(chanserv, 'op %s' % channel))
        if chanserv and self.registryValue('ChanServ.halfop', channel):
            if irc.nick not in irc.state.channels[channel].halfops:
                self.log.info('Requesting halfop from %s in %s %s.',
                              chanserv, channel, on)
                irc.sendMsg(ircmsgs.privmsg(chanserv, 'halfop %s' % channel))
        if chanserv and self.registryValue('ChanServ.voice', channel):
            if irc.nick not in irc.state.channels[channel].voices:
                self.log.info('Requesting voice from %s in %s %s.',
                              chanserv, channel, on)
                irc.sendMsg(ircmsgs.privmsg(chanserv, 'voice %s' % channel))

    def doMode(self, irc, msg):
        if self.disabled(irc):
            return
        chanserv = self.registryValue('ChanServ')
        on = 'on %s' % irc.network
        if ircutils.strEqual(msg.nick, chanserv):
            channel = msg.args[0]
            if len(msg.args) == 3:
                if ircutils.strEqual(msg.args[2], irc.nick):
                    mode = msg.args[1]
                    info = self.log.info
                    if mode == '+o':
                        info('Received op from ChanServ in %s %s.',
                             channel, on)
                    elif mode == '+h':
                        info('Received halfop from ChanServ in %s %s.',
                             channel, on)
                    elif mode == '+v':
                        info('Received voice from ChanServ in %s %s.',
                             channel, on)

    def do366(self, irc, msg): # End of /NAMES list; finished joining a channel
        if self.identified:
            channel = msg.args[1] # nick is msg.args[0].
            self.checkPrivileges(irc, channel)

    def callCommand(self, command, irc, msg, *args, **kwargs):
        if self.disabled(irc):
            irc.error('Services plugin is disabled on this network',
                      Raise=True)
        self.__parent.callCommand(command, irc, msg, *args, **kwargs)

    def _chanservCommand(self, irc, channel, command, log=False):
        chanserv = self.registryValue('ChanServ')
        if chanserv:
            msg = ircmsgs.privmsg(chanserv,
                                  ' '.join([command, channel, irc.nick]))
            irc.sendMsg(msg)
        else:
            if log:
                self.log.warning('Unable to send %s command to ChanServ, '
                                 'you must set '
                                 'supybot.plugins.Services.ChanServ before '
                                 'I can send commands to ChanServ.', command)
            else:
                irc.error(_('You must set supybot.plugins.Services.ChanServ '
                          'before I\'m able to send the %s command.') % command,
                          Raise=True)

    @internationalizeDocstring
    def op(self, irc, msg, args, channel):
        """[<channel>]

        Attempts to get opped by ChanServ in <channel>.  <channel> is only
        necessary if the message isn't sent in the channel itself.
        """
        if irc.nick in irc.state.channels[channel].ops:
            irc.error(format(_('I\'m already opped in %s.'), channel))
        else:
            self._chanservCommand(irc, channel, 'op')
    op = wrap(op, [('checkChannelCapability', 'op'), 'inChannel'])

    @internationalizeDocstring
    def voice(self, irc, msg, args, channel):
        """[<channel>]

        Attempts to get voiced by ChanServ in <channel>.  <channel> is only
        necessary if the message isn't sent in the channel itself.
        """
        if irc.nick in irc.state.channels[channel].voices:
            irc.error(format(_('I\'m already voiced in %s.'), channel))
        else:
            self._chanservCommand(irc, channel, 'voice')
    voice = wrap(voice, [('checkChannelCapability', 'op'), 'inChannel'])

    def do474(self, irc, msg):
        if self.disabled(irc):
            return
        channel = msg.args[1]
        on = 'on %s' % irc.network
        self.log.info('Banned from %s, attempting ChanServ unban %s.',
                      channel, on)
        self._chanservCommand(irc, channel, 'unban', log=True)
        # Success log in doChanservNotice.

    @internationalizeDocstring
    def unban(self, irc, msg, args, channel):
        """[<channel>]

        Attempts to get unbanned by ChanServ in <channel>.  <channel> is only
        necessary if the message isn't sent in the channel itself, but chances
        are, if you need this command, you're not sending it in the channel
        itself.
        """
        self._chanservCommand(irc, channel, 'unban')
        irc.replySuccess()
    unban = wrap(unban, [('checkChannelCapability', 'op')])

    def do473(self, irc, msg):
        if self.disabled(irc):
            return
        channel = msg.args[1]
        on = 'on %s' % irc.network
        self.log.info('%s is +i, attempting ChanServ invite %s.', channel, on)
        self._chanservCommand(irc, channel, 'invite', log=True)

    @internationalizeDocstring
    def invite(self, irc, msg, args, channel):
        """[<channel>]

        Attempts to get invited by ChanServ to <channel>.  <channel> is only
        necessary if the message isn't sent in the channel itself, but chances
        are, if you need this command, you're not sending it in the channel
        itself.
        """
        self._chanservCommand(irc, channel, 'invite')
        irc.replySuccess()
    invite = wrap(invite, [('checkChannelCapability', 'op'), 'inChannel'])

    def doInvite(self, irc, msg):
        if ircutils.strEqual(msg.nick, self.registryValue('ChanServ')):
            channel = msg.args[1]
            on = 'on %s' % irc.network
            networkGroup = conf.supybot.networks.get(irc.network)
            self.log.info('Joining %s, invited by ChanServ %s.', channel, on)
            irc.queueMsg(networkGroup.channels.join(channel))

    @internationalizeDocstring
    def identify(self, irc, msg, args):
        """takes no arguments

        Identifies with NickServ using the current nick.
        """
        if self.registryValue('NickServ'):
            if irc.nick in self.registryValue('nicks'):
                self._doIdentify(irc, irc.nick)
                irc.replySuccess()
            else:
                irc.error(_('I don\'t have a configured password for '
                          'my current nick.'))
        else:
            irc.error(_('You must set supybot.plugins.Services.NickServ before '
                      'I\'m able to do identify.'))
    identify = wrap(identify, [('checkCapability', 'admin')])

    @internationalizeDocstring
    def ghost(self, irc, msg, args, nick):
        """[<nick>]

        Ghosts the bot's given nick and takes it.  If no nick is given,
        ghosts the bot's configured nick and takes it.
        """
        if self.registryValue('NickServ'):
            if not nick:
                nick = self._getNick(irc.network)
            if ircutils.strEqual(nick, irc.nick):
                irc.error(_('I cowardly refuse to ghost myself.'))
            else:
                self._doGhost(irc, nick=nick)
                irc.replySuccess()
        else:
            irc.error(_('You must set supybot.plugins.Services.NickServ before '
                      'I\'m able to ghost a nick.'))
    ghost = wrap(ghost, [('checkCapability', 'admin'), additional('nick')])

    @internationalizeDocstring
    def password(self, irc, msg, args, nick, password):
        """<nick> [<password>]

        Sets the NickServ password for <nick> to <password>.  If <password> is
        not given, removes <nick> from the configured nicks.
        """
        if not password:
            try:
                self.registryValue('nicks').remove(nick)
                irc.replySuccess()
            except KeyError:
                irc.error(_('That nick was not configured with a password.'))
                return
        else:
            self.registryValue('nicks').add(nick)
            config.registerNick(nick, password)
            irc.replySuccess()
    password = wrap(password, [('checkCapability', 'admin'),
                                'private', 'nick', 'text'])

    @internationalizeDocstring
    def nicks(self, irc, msg, args):
        """takes no arguments

        Returns the nicks that this plugin is configured to identify and ghost
        with.
        """
        L = list(self.registryValue('nicks'))
        if L:
            utils.sortBy(ircutils.toLower, L)
            irc.reply(format('%L', L))
        else:
            irc.reply(_('I\'m not currently configured for any nicks.'))
    nicks = wrap(nicks, [('checkCapability', 'admin')])
Services = internationalizeDocstring(Services)

Class = Services

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2002-2004, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

class ServicesTestCase(PluginTestCase):
    plugins = ('Services',)
    config = {
        'plugins.Services.NickServ': 'NickServ',
        'plugins.Services.ChanServ': 'ChanServ',
        }

    def testPasswordAndIdentify(self):
        self.assertNotError('services password foo bar')
        self.assertError('services identify') # Don't have a password.
        self.assertNotError('services password %s baz' % self.nick)
        m = self.assertNotError('services identify')
        self.failUnless(m.args[0] == 'NickServ')
        self.failUnless(m.args[1].lower() == 'identify baz')
        self.assertNotError('services password %s biff' % self.nick)
        m = self.assertNotError('services identify')
        self.failUnless(m.args[0] == 'NickServ')
        self.failUnless(m.args[1].lower() == 'identify biff')


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:


########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2005, Jeremiah Fincher
# Copyright (c) 2009-2010, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('ShrinkUrl')

def configure(advanced):
    from supybot.questions import output, expect, anything, something, yn
    conf.registerPlugin('ShrinkUrl', True)
    if yn(_("""This plugin offers a snarfer that will go retrieve a shorter
             version of long URLs that are sent to the channel.  Would you
             like this snarfer to be enabled?"""), default=False):
        conf.supybot.plugins.ShrinkUrl.shrinkSnarfer.setValue(True)

class ShrinkService(registry.OnlySomeStrings):
    """Valid values include 'ln', 'tiny', 'xrl', 'goo', 'ur1', and 'x0'."""
    validStrings = ('ln', 'tiny', 'xrl', 'goo', 'ur1', 'x0')

class ShrinkCycle(registry.SpaceSeparatedListOfStrings):
    """Valid values include 'ln', 'tiny', 'xrl', 'goo', 'ur1', and 'x0'."""
    Value = ShrinkService

    def __init__(self, *args, **kwargs):
        super(ShrinkCycle, self).__init__(*args, **kwargs)
        self.lastIndex = -1

    def setValue(self, v):
        super(self.__class__, self).setValue(v)
        self.lastIndex = -1

    def getService(self):
        L = self()
        if L:
            self.lastIndex = (self.lastIndex + 1) % len(L)
            return L[self.lastIndex]
        raise ValueError('No services have been configured for rotation.  ' \
                'See conf.supybot.plugins.ShrinkUrl.serviceRotation.')

ShrinkUrl = conf.registerPlugin('ShrinkUrl')
conf.registerChannelValue(ShrinkUrl, 'shrinkSnarfer',
    registry.Boolean(False, _("""Determines whether the
    shrink snarfer is enabled.  This snarfer will watch for URLs in the
    channel, and if they're sufficiently long (as determined by
    supybot.plugins.ShrinkUrl.minimumLength) it will post a
    smaller URL from either ln-s.net or tinyurl.com, as denoted in
    supybot.plugins.ShrinkUrl.default.""")))
conf.registerChannelValue(ShrinkUrl.shrinkSnarfer, 'showDomain',
    registry.Boolean(True, _("""Determines whether the snarfer will show the
    domain of the URL being snarfed along with the shrunken URL.""")))
conf.registerChannelValue(ShrinkUrl, 'minimumLength',
    registry.PositiveInteger(48, _("""The minimum length a URL must be before
    the bot will shrink it.""")))
conf.registerChannelValue(ShrinkUrl, 'nonSnarfingRegexp',
    registry.Regexp(None, _("""Determines what URLs are to be snarfed; URLs
    matching the regexp given will not be snarfed.  Give the empty string if
    you have no URLs that you'd like to exclude from being snarfed.""")))
conf.registerChannelValue(ShrinkUrl, 'outFilter',
    registry.Boolean(False, _("""Determines whether the bot will shrink the
    URLs of outgoing messages if those URLs are longer than
    supybot.plugins.ShrinkUrl.minimumLength.""")))
conf.registerChannelValue(ShrinkUrl, 'default',
    ShrinkService('ln', _("""Determines what website the bot will use when
    shrinking a URL.""")))
conf.registerGlobalValue(ShrinkUrl, 'bold',
    registry.Boolean(True, _("""Determines whether this plugin will bold
    certain portions of its replies.""")))
conf.registerChannelValue(ShrinkUrl, 'serviceRotation',
    ShrinkCycle([], _("""If set to a non-empty value, specifies the list of
    services to rotate through for the shrinkSnarfer and outFilter.""")))

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2002-2004, Jeremiah Fincher
# Copyright (c) 2009-2010, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import re
import time
import json
import urllib

import supybot.log as log
import supybot.conf as conf
import supybot.utils as utils
from supybot.commands import *
import supybot.ircmsgs as ircmsgs
import supybot.plugins as plugins
import supybot.ircutils as ircutils
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('ShrinkUrl')

class CdbShrunkenUrlDB(object):
    def __init__(self, filename):
        self.dbs = {}
        cdb = conf.supybot.databases.types.cdb
        def register_service(service):
            dbname = filename.replace('.db', service.capitalize() + '.db')
            self.dbs[service] = cdb.connect(dbname)
        for service in conf.supybot.plugins.ShrinkUrl.default.validStrings:
            register_service(service)
        register_service('Expand')

    def get(self, service, url):
        return self.dbs[service][url]

    def set(self, service, url, shrunkurl):
        self.dbs[service][url] = shrunkurl

    def close(self):
        for service in self.dbs:
            self.dbs[service].close()

    def flush(self):
        for service in self.dbs:
            self.dbs[service].flush()

ShrunkenUrlDB = plugins.DB('ShrinkUrl', {'cdb': CdbShrunkenUrlDB})

class ShrinkError(Exception):
    pass

def retry(f):
    def newf(*args, **kwargs):
        for x in xrange(0, 3):
            try:
                return f(*args, **kwargs)
            except Exception:
                log.exception('Shrinking URL failed. Trying again.')
                time.sleep(1)
        return f(*args, **kwargs)
    return newf

class ShrinkUrl(callbacks.PluginRegexp):
    regexps = ['shrinkSnarfer']
    def __init__(self, irc):
        self.__parent = super(ShrinkUrl, self)
        self.__parent.__init__(irc)
        self.db = ShrunkenUrlDB()

    def die(self):
        self.db.close()

    def callCommand(self, command, irc, msg, *args, **kwargs):
        try:
            self.__parent.callCommand(command, irc, msg, *args, **kwargs)
        except utils.web.Error as e:
            irc.error(str(e))

    def _outFilterThread(self, irc, msg):
        (channel, text) = msg.args
        for m in utils.web.httpUrlRe.finditer(text):
            url = m.group(1)
            if len(url) > self.registryValue('minimumLength', channel):
                try:
                    cmd = self.registryValue('serviceRotation',
                                             channel, value=False)
                    cmd = cmd.getService().capitalize()
                except ValueError:
                    cmd = self.registryValue('default', channel).capitalize()
                try:
                    shortUrl = getattr(self, '_get%sUrl' % cmd)(url)
                    text = text.replace(url, shortUrl)
                except (utils.web.Error, AttributeError, ShrinkError):
                    pass
        newMsg = ircmsgs.privmsg(channel, text, msg=msg)
        newMsg.tag('shrunken')
        irc.queueMsg(newMsg)

    def outFilter(self, irc, msg):
        channel = msg.args[0]
        if msg.command == 'PRIVMSG' and irc.isChannel(channel):
            if not msg.shrunken:
                if self.registryValue('outFilter', channel):
                    if utils.web.httpUrlRe.search(msg.args[1]):
                        self._outFilterThread(irc, msg)
                        return None
        return msg

    def shrinkSnarfer(self, irc, msg, match):
        channel = msg.args[0]
        if not irc.isChannel(channel):
            return
        if self.registryValue('shrinkSnarfer', channel):
            url = match.group(0)
            r = self.registryValue('nonSnarfingRegexp', channel)
            if r and r.search(url) is not None:
                self.log.debug('Matched nonSnarfingRegexp: %u', url)
                return
            minlen = self.registryValue('minimumLength', channel)
            try:
                cmd = self.registryValue('serviceRotation',
                                         channel, value=False)
                cmd = cmd.getService().capitalize()
            except ValueError:
                cmd = self.registryValue('default', channel).capitalize()
            if len(url) >= minlen:
                try:
                    shorturl = getattr(self, '_get%sUrl' % cmd)(url)
                except (utils.web.Error, AttributeError, ShrinkError):
                    self.log.info('Couldn\'t get shorturl for %u', url)
                    return
                if self.registryValue('shrinkSnarfer.showDomain', channel):
                    domain = ' (at %s)' % utils.web.getDomain(url)
                else:
                    domain = ''
                if self.registryValue('bold'):
                    s = format('%u%s', ircutils.bold(shorturl), domain)
                else:
                    s = format('%u%s', shorturl, domain)
                m = irc.reply(s, prefixNick=False)
                if m is not None:
                    m.tag('shrunken')
    shrinkSnarfer = urlSnarfer(shrinkSnarfer)
    shrinkSnarfer.__doc__ = utils.web._httpUrlRe

    @retry
    def _getLnUrl(self, url):
        url = utils.web.urlquote(url)
        try:
            return self.db.get('ln', url)
        except KeyError:
            text = utils.web.getUrl('http://ln-s.net/home/api.jsp?url=' + url)
            text = text.decode()
            (code, text) = text.split(None, 1)
            text = text.strip()
            if code == '200':
                self.db.set('ln', url, text)
                return text
            else:
                raise ShrinkError(text)

    @internationalizeDocstring
    def ln(self, irc, msg, args, url):
        """<url>

        Returns an ln-s.net version of <url>.
        """
        try:
            lnurl = self._getLnUrl(url)
            m = irc.reply(lnurl)
            if m is not None:
                m.tag('shrunken')
        except ShrinkError as e:
            irc.error(str(e))
    ln = thread(wrap(ln, ['url']))

    @retry
    def _getTinyUrl(self, url):
        try:
            return self.db.get('tiny', url)
        except KeyError:
            text = utils.web.getUrl('http://tinyurl.com/api-create.php?url=' + url)
            text = text.decode()
            if text.startswith('Error'):
                raise ShrinkError(text[5:])
            self.db.set('tiny', url, text)
            return text

    @internationalizeDocstring
    def tiny(self, irc, msg, args, url):
        """<url>

        Returns a TinyURL.com version of <url>
        """
        try:
            tinyurl = self._getTinyUrl(url)
            m = irc.reply(tinyurl)
            if m is not None:
                m.tag('shrunken')
        except ShrinkError as e:
            irc.errorPossibleBug(str(e))
    tiny = thread(wrap(tiny, ['url']))

    _xrlApi = 'http://metamark.net/api/rest/simple'
    @retry
    def _getXrlUrl(self, url):
        quotedurl = utils.web.urlquote(url)
        try:
            return self.db.get('xrl', quotedurl)
        except KeyError:
            data = utils.web.urlencode({'long_url': url})
            text = utils.web.getUrl(self._xrlApi, data=data).decode()
            if text.startswith('ERROR:'):
                raise ShrinkError(text[6:])
            self.db.set('xrl', quotedurl, text)
            return text

    @internationalizeDocstring
    def xrl(self, irc, msg, args, url):
        """<url>

        Returns an xrl.us version of <url>.
        """
        try:
            xrlurl = self._getXrlUrl(url)
            m = irc.reply(xrlurl)
            if m is not None:
                m.tag('shrunken')
        except ShrinkError as e:
            irc.error(str(e))
    xrl = thread(wrap(xrl, ['url']))

    _gooApi = 'https://www.googleapis.com/urlshortener/v1/url'
    @retry
    def _getGooUrl(self, url):
        url = utils.web.urlquote(url)
        try:
            return self.db.get('goo', url)
        except KeyError:
            headers = utils.web.defaultHeaders.copy()
            headers['content-type'] = 'application/json'
            data = json.dumps({'longUrl': url})
            text = utils.web.getUrl(self._gooApi, data=data, headers=headers)
            googl = json.loads(text)['id']
            if googl:
                self.db.set('goo', url, googl)
                return googl
            else:
                raise ShrinkError(text)

    def goo(self, irc, msg, args, url):
        """<url>

        Returns an goo.gl version of <url>.
        """
        try:
            goourl = self._getGooUrl(url)
            m = irc.reply(goourl)
            if m is not None:
                m.tag('shrunken')
        except ShrinkError as e:
            irc.error(str(e))
    goo = thread(wrap(goo, ['url']))

    _ur1Api = 'http://ur1.ca/'
    _ur1Regexp = re.compile(r'<a href="(?P<url>[^"]+)">')
    @retry
    def _getUr1Url(self, url):
        try:
            return self.db.get('ur1ca', utils.web.urlquote(url))
        except KeyError:
            parameters = utils.web.urlencode({'longurl': url})
            response = utils.web.getUrl(self._ur1Api, data=parameters)
            ur1ca = self._ur1Regexp.search(response.decode()).group('url')
            if ur1ca:
                self.db.set('ur1', url, ur1ca)
                return ur1ca
            else:
                raise ShrinkError(response)

    def ur1(self, irc, msg, args, url):
        """<url>

        Returns an ur1 version of <url>.
        """
        try:
            ur1url = self._getUr1Url(url)
            m = irc.reply(ur1url)
            if m is not None:
                m.tag('shrunken')
        except ShrinkError as e:
            irc.error(str(e))
    ur1 = thread(wrap(ur1, ['url']))

    _x0Api = 'http://api.x0.no/?%s'
    @retry
    def _getX0Url(self, url):
        try:
            return self.db.get('x0', url)
        except KeyError:
            text = utils.web.getUrl(self._x0Api % url).decode()
            if text.startswith('ERROR:'):
                raise ShrinkError(text[6:])
            self.db.set('x0', url, text)
            return text

    @internationalizeDocstring
    def x0(self, irc, msg, args, url):
        """<url>

        Returns an x0.no version of <url>.
        """
        try:
            x0url = self._getX0Url(url)
            m = irc.reply(x0url)
            if m is not None:
                m.tag('shrunken')
        except ShrinkError as e:
            irc.error(str(e))
    x0 = thread(wrap(x0, ['url']))

    @retry
    def _getExpandUrl(self, url):
        url = utils.web.urlquote(url)
        try:
            return self.db.get('Expand', url)
        except KeyError:
            text = utils.web.getUrl('http://api.longurl.org/v2/expand?url=' + url)
            text = text.decode()
            text = text.split('<![CDATA[', 1)[1].split(']]>', 1)[0]
            self.db.set('Expand', url, text)
            return text

    @internationalizeDocstring
    def expand(self, irc, msg, args, url):
        """<url>

        Returns an expanded version of <url>.
        """
        try:
            expandurl = self._getExpandUrl(url)
            m = irc.reply(expandurl)
            if m is not None:
                m.tag('shrunken')
        except ShrinkError as e:
            irc.error(str(e))
    expand = thread(wrap(expand, ['url']))

Class = ShrinkUrl

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2002-2004, Jeremiah Fincher
# Copyright (c) 2009-2010, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

class ShrinkUrlTestCase(ChannelPluginTestCase):
    plugins = ('ShrinkUrl',)
    config = {'supybot.snarfThrottle': 0}

    sfUrl ='http://sourceforge.net/p/supybot/bugs/?source=navbar'
    udUrl = 'http://www.urbandictionary.com/define.php?' \
            'term=all+your+base+are+belong+to+us'
    tests = {'tiny': [(sfUrl, r'http://tinyurl.com/b7wyvfz'),
                      (udUrl, r'http://tinyurl.com/u479')],
             'ln': [(sfUrl, r'http://ln-s.net/\+PE-'),
                    (udUrl, r'http://ln-s.net/2\$K')],
             'xrl': [(sfUrl, r'http://xrl.us/bfq8ik'),
                     (udUrl, r'http://xrl.us/bfnyji')],
             'goo': [(sfUrl, r'http://goo.gl/3c59N'),
                     (udUrl, r'http://goo.gl/ocTga')],
             'ur1': [(sfUrl, r'http://ur1.ca/9xl25'),
                     (udUrl, r'http://ur1.ca/9xl9k')],
             'x0': [(sfUrl, r'http://x0.no/0l2j'),
                    (udUrl, r'http://x0.no/0l2k')]
            }
    if network:
        def testShrink(self):
            for (service, testdata) in self.tests.iteritems():
                for (url, shrunkurl) in testdata:
                    self.assertRegexp('shrinkurl %s %s' % (service, url),
                                      shrunkurl)

        def testShrinkCycle(self):
            cycle = conf.supybot.plugins.ShrinkUrl.serviceRotation
            snarfer = conf.supybot.plugins.ShrinkUrl.shrinkSnarfer
            origcycle = cycle()
            origsnarfer = snarfer()
            try:
                self.assertNotError(
                    'config plugins.ShrinkUrl.serviceRotation ln x0')
                self.assertError(
                    'config plugins.ShrinkUrl.serviceRotation ln x1')
                snarfer.setValue(True)
                self.assertSnarfRegexp(self.udUrl, r'.*%s.* \(at' %
                                       self.tests['ln'][1][1])
                self.assertSnarfRegexp(self.udUrl, r'.*%s.* \(at' %
                                       self.tests['x0'][1][1])
                self.assertSnarfRegexp(self.udUrl, r'.*%s.* \(at' %
                                       self.tests['ln'][1][1])
            finally:
                cycle.setValue(origcycle)
                snarfer.setValue(origsnarfer)

        def _snarf(self, service):
            shrink = conf.supybot.plugins.ShrinkUrl
            origService = shrink.default()
            origSnarf = shrink.shrinkSnarfer()
            shrink.default.setValue(service)
            shrink.shrinkSnarfer.setValue(True)
            try:
                for (url, shrunkurl) in self.tests[service]:
                    teststr = r'.*%s.* \(at' % shrunkurl
                    self.assertSnarfRegexp(url, teststr)
            finally:
                shrink.default.setValue(origService)
                shrink.shrinkSnarfer.setValue(origSnarf)

        def testTinysnarf(self):
            self._snarf('tiny')

        def testLnsnarf(self):
            self._snarf('ln')

        def testXrlsnarf(self):
            self._snarf('xrl')

        def testGoosnarf(self):
            self._snarf('goo')

        def testUr1snarf(self):
            self._snarf('ur1')

        def testX0snarf(self):
            self._snarf('x0')

        def testNonSnarfing(self):
            shrink = conf.supybot.plugins.ShrinkUrl
            origService = shrink.default()
            origSnarf = shrink.shrinkSnarfer()
            origLen = shrink.minimumLength()
            origRegexp = shrink.nonSnarfingRegexp()
            shrink.default.setValue('tiny')
            shrink.shrinkSnarfer.setValue(True)
            shrink.minimumLength.setValue(10)
            shrink.nonSnarfingRegexp.set('m/sf/')
            try:
                self.assertSnarfNoResponse('http://sf.net/', 5)
                self.assertSnarfRegexp('http://sourceforge.net/',
                                       r'http://tinyurl.com/7vm7.*\(at ')
            finally:
                shrink.default.setValue(origService)
                shrink.shrinkSnarfer.setValue(origSnarf)
                shrink.minimumLength.setValue(origLen)
                shrink.nonSnarfingRegexp.setValue(origRegexp)

        def testExpand(self):
            self.assertResponse('expand http://x0.no/0l2k', self.udUrl)
            self.assertResponse('expand http://x0.no/0l2k', self.udUrl)
            self.assertResponse('expand http://x0.no/a53s', self.sfUrl)
            self.assertResponse('expand http://x0.no/a53s', self.sfUrl)
            self.assertResponse('expand http://x0.no/0l2k', self.udUrl)

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2004, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Status')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Status', True)

Status = conf.registerPlugin('Status')
conf.registerGroup(Status, 'cpu')
conf.registerChannelValue(Status.cpu, 'children',
    registry.Boolean(True, _("""Determines whether the cpu command will list
    the time taken by children as well as the bot's process.""")))
conf.registerChannelValue(Status.cpu, 'threads',
    registry.Boolean(False, _("""Determines whether the cpu command will
    provide the number of threads spawned and active.""")))
conf.registerChannelValue(Status.cpu, 'memory',
    registry.Boolean(True, _("""Determines whether the cpu command will report
    the amount of memory being used by the bot.""")))

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# Copyright (c) 2009, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import os
import sys
import time
import threading
import multiprocessing
import subprocess

import supybot.conf as conf
import supybot.utils as utils
import supybot.world as world
from supybot.commands import *
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Status')

class Status(callbacks.Plugin):
    def __init__(self, irc):
        self.__parent = super(Status, self)
        self.__parent.__init__(irc)
        # XXX It'd be nice if these could be kept in the registry.
        self.sentMsgs = 0
        self.recvdMsgs = 0
        self.sentBytes = 0
        self.recvdBytes = 0
        self.connected = {}

    def __call__(self, irc, msg):
        self.recvdMsgs += 1
        self.recvdBytes += len(msg)
        self.__parent.__call__(irc, msg)

    def outFilter(self, irc, msg):
        self.sentMsgs += 1
        self.sentBytes += len(msg)
        return msg

    def do001(self, irc, msg):
        self.connected[irc] = time.time()

    @internationalizeDocstring
    def status(self, irc, msg, args):
        """takes no arguments

        Returns the status of the bot.
        """
        networks = {}
        for Irc in world.ircs:
            networks.setdefault(Irc.network, []).append(Irc.nick)
        networks = networks.items()
        networks.sort()
        networks = [format(_('%s as %L'), net, nicks) for (net,nicks) in networks]
        L = [format(_('I am connected to %L.'), networks)]
        if world.profiling:
            L.append(_('I am currently in code profiling mode.'))
        irc.reply('  '.join(L))
    status = wrap(status)

    @internationalizeDocstring
    def threads(self, irc, msg, args):
        """takes no arguments

        Returns the current threads that are active.
        """
        threads = [t.getName() for t in threading.enumerate()]
        threads.sort()
        s = format(_('I have spawned %n; %n %b still currently active: %L.'),
                   (world.threadsSpawned, 'thread'),
                   (len(threads), 'thread'), len(threads), threads)
        irc.reply(s)
    threads = wrap(threads)

    def processes(self, irc, msg, args):
        """takes no arguments

        Returns the number of processes that have been spawned, and list of
        ones that are still active.
        """
        ps = [multiprocessing.current_process().name]
        ps = ps + [p.name for p in multiprocessing.active_children()]
        s = format('I have spawned %n; %n %b still currently active: %L.',
                   (world.processesSpawned, 'process'),
                   (len(ps), 'process'),
                   len(ps), ps)
        irc.reply(s)
    processes = wrap(processes)

    def net(self, irc, msg, args):
        """takes no arguments

        Returns some interesting network-related statistics.
        """
        try:
            elapsed = time.time() - self.connected[irc.getRealIrc()]
            timeElapsed = utils.timeElapsed(elapsed)
        except KeyError:
            timeElapsed = _('an indeterminate amount of time')
        irc.reply(format(_('I have received %s messages for a total of %S.  '
                  'I have sent %s messages for a total of %S.  '
                  'I have been connected to %s for %s.'),
                  self.recvdMsgs, self.recvdBytes,
                  self.sentMsgs, self.sentBytes, irc.server, timeElapsed))
    net = wrap(net)

    @internationalizeDocstring
    def cpu(self, irc, msg, args):
        """takes no arguments

        Returns some interesting CPU-related statistics on the bot.
        """
        (user, system, childUser, childSystem, elapsed) = os.times()
        now = time.time()
        target = msg.args[0]
        timeRunning = now - world.startedAt
        if self.registryValue('cpu.children', target) and \
           user+system < timeRunning+1: # Fudge for FPU inaccuracies.
            children = _('My children have taken %.2f seconds of user time '
                       'and %.2f seconds of system time '
                       'for a total of %.2f seconds of CPU time.') % \
                       (childUser, childSystem, childUser+childSystem)
        else:
            children = ''
        activeThreads = threading.activeCount()
        response = _('I have taken %.2f seconds of user time and %.2f seconds '
                   'of system time, for a total of %.2f seconds of CPU '
                   'time.  %s') % (user, system, user + system, children)
        if self.registryValue('cpu.threads', target):
            response += format('I have spawned %n; I currently have %i still '
                               'running.',
                               (world.threadsSpawned, 'thread'), activeThreads)
        if self.registryValue('cpu.memory', target):
            mem = 'an unknown amount'
            pid = os.getpid()
            plat = sys.platform
            try:
                if plat.startswith('linux') or plat.startswith('sunos') or \
                   plat.startswith('freebsd') or plat.startswith('openbsd') or \
                   plat.startswith('darwin'):
                    cmd = 'ps -o rss -p %s' % pid
                    try:
                        inst = subprocess.Popen(cmd.split(), close_fds=True,
                                                stdin=open(os.devnull),
                                                stdout=subprocess.PIPE,
                                                stderr=subprocess.PIPE)
                    except OSError:
                        irc.error(_('Unable to run ps command.'), Raise=True)
                    (out, foo) = inst.communicate()
                    inst.wait()
                    mem = int(out.splitlines()[1])
                elif sys.platform.startswith('netbsd'):
                    mem = int(os.stat('/proc/%s/mem' % pid)[7])
                response += format(_('  I\'m taking up %S of memory.'),
                        mem*1024)
            except Exception:
                self.log.exception('Uncaught exception in cpu.memory:')
        irc.reply(utils.str.normalizeWhitespace(response))
    cpu = wrap(cpu)

    @internationalizeDocstring
    def cmd(self, irc, msg, args):
        """takes no arguments

        Returns some interesting command-related statistics.
        """
        commands = 0
        callbacksPlugin = 0
        for cb in irc.callbacks:
            if isinstance(cb, callbacks.Plugin):
                callbacksPlugin += 1
                commands += len(cb.listCommands())
        s = format(_('I offer a total of %n in %n.  I have processed %n.'),
                   (commands, 'command'),
                   (callbacksPlugin, 'command-based', 'plugin'),
                   (world.commandsProcessed, 'command'))
        irc.reply(s)
    cmd = wrap(cmd)

    @internationalizeDocstring
    def commands(self, irc, msg, args):
        """takes no arguments

        Returns a list of the commands offered by the bot.
        """
        commands = set()
        for cb in irc.callbacks:
            if isinstance(cb, callbacks.Plugin):
                for command in cb.listCommands():
                    commands.add(command)
        irc.reply(format('%L', sorted(commands)))
    commands = wrap(commands)

    @internationalizeDocstring
    def uptime(self, irc, msg, args):
        """takes no arguments

        Returns the amount of time the bot has been running.
        """
        response = _('I have been running for %s.') % \
                   utils.timeElapsed(time.time() - world.startedAt)
        irc.reply(response)
    uptime = wrap(uptime)

    @internationalizeDocstring
    def server(self, irc, msg, args):
        """takes no arguments

        Returns the server the bot is on.
        """
        irc.reply(irc.server)
    server = wrap(server)

    @internationalizeDocstring
    def network(self, irc, msg, args):
        """takes no arguments

        Returns the network the bot is on.
        """
        irc.reply(irc.network)
    network = wrap(network)


Class = Status

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

import sys

import supybot.world as world

class StatusTestCase(PluginTestCase):
    plugins = ('Status',)
    def testNet(self):
        self.assertNotError('net')

    def testCpu(self):
        m = self.assertNotError('status cpu')
        self.failIf('kB kB' in m.args[1])
        self.failIf('None' in m.args[1], 'None in cpu output: %r.' % m)
        for s in ['linux', 'freebsd', 'openbsd', 'netbsd', 'darwin']:
            if sys.platform.startswith(s):
                self.failUnless('B' in m.args[1] or 'KB' in m.args[1] or
                                'MB' in m.args[1],
                                'No memory string on supported platform.')
        try:
            original = conf.supybot.plugins.Status.cpu.get('children')()
            conf.supybot.plugins.Status.cpu.get('children').setValue(False)
            self.assertNotRegexp('cpu', 'children')
        finally:
            conf.supybot.plugins.Status.cpu.get('children').setValue(original)
            

    def testUptime(self):
        self.assertNotError('uptime')

    def testCmd(self):
        self.assertNotError('cmd')

    def testCommands(self):
        self.assertNotError('commands')

    def testLogfilesize(self):
        self.feedMsg('list')
        self.feedMsg('list Status')
        self.assertNotError('upkeep')

    def testThreads(self):
        self.assertNotError('threads')

    def testProcesses(self):
        self.assertNotError('processes')

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:


########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2003-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('String')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('String', True)


String = conf.registerPlugin('String')
conf.registerGroup(String, 'levenshtein')
conf.registerGlobalValue(String.levenshtein, 'max',
    registry.PositiveInteger(256, _("""Determines the maximum size of a string
    given to the levenshtein command.  The levenshtein command uses an O(m*n)
    algorithm, which means that with strings of length 256, it can take 1.5
    seconds to finish; with strings of length 384, though, it can take 4
    seconds to finish, and with strings of much larger lengths, it takes more
    and more time.  Using nested commands, strings can get quite large, hence
    this variable, to limit the size of arguments passed to the levenshtein
    command.""")))

conf.registerGroup(String, 're')
conf.registerGlobalValue(String.re, 'timeout',
    registry.PositiveFloat(0.1, _("""Determines the maximum time, in seconds, that
    a regular expression is given to execute before being terminated. Since
    there is a possibility that user input for the re command can cause it to
    eat up large amounts of ram or cpu time, it's a good idea to keep this 
    low. Most normal regexps should not take very long at all.""")))
# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2003-2005, Jeremiah Fincher
# Copyright (c) 2008-2009, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import sys
import types
import codecs
import base64
import binascii

import supybot.utils as utils
from supybot.commands import *
import supybot.commands as commands
import supybot.plugins as plugins
import supybot.commands as commands
import supybot.ircutils as ircutils
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('String')

import multiprocessing

class String(callbacks.Plugin):
    @internationalizeDocstring
    def ord(self, irc, msg, args, letter):
        """<letter>

        Returns the 8-bit value of <letter>.
        """
        irc.reply(str(ord(letter)))
    ord = wrap(ord, ['letter'])

    @internationalizeDocstring
    def chr(self, irc, msg, args, i):
        """<number>

        Returns the character associated with the 8-bit value <number>
        """
        try:
            irc.reply(chr(i))
        except ValueError:
            irc.error(_('That number doesn\'t map to an 8-bit character.'))
    chr = wrap(chr, ['int'])

    @internationalizeDocstring
    def encode(self, irc, msg, args, encoding, text):
        """<encoding> <text>

        Returns an encoded form of the given text; the valid encodings are
        available in the documentation of the Python codecs module:
        <http://docs.python.org/library/codecs.html#standard-encodings>.
        """
        # Binary codecs are prefixed with _codec in Python 3
        if encoding in 'base64 bz2 hex quopri uu zlib':
            encoding += '_codec'
        if encoding.endswith('_codec'):
            text = text.encode()

        # Do the encoding
        try:
            encoder = codecs.getencoder(encoding)
        except LookupError:
            irc.errorInvalid(_('encoding'), encoding)
        text = encoder(text)[0]

        # If this is a binary codec, re-encode it with base64
        if encoding.endswith('_codec') and encoding != 'base64_codec':
            text = codecs.getencoder('base64_codec')(text)[0].decode()

        # Change result into a string
        if sys.version_info[0] < 3 and isinstance(text, unicode):
            text = text.encode('utf-8')
        elif sys.version_info[0] >= 3 and isinstance(text, bytes):
            text = text.decode()

        # Reply
        irc.reply(text.rstrip('\n'))
    encode = wrap(encode, ['something', 'text'])

    @internationalizeDocstring
    def decode(self, irc, msg, args, encoding, text):
        """<encoding> <text>

        Returns an un-encoded form of the given text; the valid encodings are
        available in the documentation of the Python codecs module:
        <http://docs.python.org/library/codecs.html#standard-encodings>.
        """
        # Binary codecs are prefixed with _codec in Python 3
        if encoding in 'base64 bz2 hex quopri uu zlib':
            encoding += '_codec'

        # If this is a binary codec, pre-decode it with base64
        if encoding.endswith('_codec') and encoding != 'base64_codec':
            text = codecs.getdecoder('base64_codec')(text.encode())[0]

        # Do the decoding
        try:
            decoder = codecs.getdecoder(encoding)
        except LookupError:
            irc.errorInvalid(_('encoding'), encoding)
        if sys.version_info[0] >= 3 and not isinstance(text, bytes):
            text = text.encode()
        try:
            text = decoder(text)[0]
        except binascii.Error:
            irc.errorInvalid(_('base64 string'),
                             s=_('Base64 strings must be a multiple of 4 in '
                               'length, padded with \'=\' if necessary.'))
            return

        # Change result into a string
        if sys.version_info[0] < 3 and isinstance(text, unicode):
            text = text.encode('utf-8')
        elif sys.version_info[0] >= 3 and isinstance(text, bytes):
            text = text.decode()

        # Reply
        irc.reply(text)
    decode = wrap(decode, ['something', 'text'])

    @internationalizeDocstring
    def levenshtein(self, irc, msg, args, s1, s2):
        """<string1> <string2>

        Returns the levenshtein distance (also known as the "edit distance"
        between <string1> and <string2>)
        """
        max = self.registryValue('levenshtein.max')
        if len(s1) > max or len(s2) > max:
            irc.error(_('Levenshtein distance is a complicated algorithm, try '
                      'it with some smaller inputs.'))
        else:
            irc.reply(str(utils.str.distance(s1, s2)))
    levenshtein = thread(wrap(levenshtein, ['something', 'text']))

    @internationalizeDocstring
    def soundex(self, irc, msg, args, text, length):
        """<string> [<length>]

        Returns the Soundex hash to a given length.  The length defaults to
        4, since that's the standard length for a soundex hash.  For unlimited
        length, use 0. Maximum length 1024.
        """
        if length > 1024:
            irc.error("Maximum allowed length is 1024.")
            return
        irc.reply(utils.str.soundex(text, length))
    soundex = wrap(soundex, ['somethingWithoutSpaces', additional('int', 4)])

    @internationalizeDocstring
    def len(self, irc, msg, args, text):
        """<text>

        Returns the length of <text>.
        """
        irc.reply(str(len(text)))
    len = wrap(len, ['text'])

    @internationalizeDocstring
    def re(self, irc, msg, args, ff, text):
        """<regexp> <text>

        If <regexp> is of the form m/regexp/flags, returns the portion of
        <text> that matches the regexp.  If <regexp> is of the form
        s/regexp/replacement/flags, returns the result of applying such a
        regexp to <text>.
        """
        if isinstance(ff, (types.FunctionType, types.MethodType)):
            f = ff
        else:
            f = lambda s: ff.search(s) and ff.search(s).group(0) or ''
        if f('') and len(f(' ')) > len(f(''))+1: # Matches the empty string.
            s = _('You probably don\'t want to match the empty string.')
            irc.error(s)
        else:
            t = self.registryValue('re.timeout')
            try:
                v = process(f, text, timeout=t, pn=self.name(), cn='re')
                irc.reply(v)
            except commands.ProcessTimeoutError as e:
                irc.error("ProcessTimeoutError: %s" % (e,))
    re = thread(wrap(re, [first('regexpMatcher', 'regexpReplacer'),
                   'text']))

    def xor(self, irc, msg, args, password, text):
        """<password> <text>

        Returns <text> XOR-encrypted with <password>.  See
        http://www.yoe.org/developer/xor.html for information about XOR
        encryption.
        """
        chars = utils.iter.cycle(password)
        ret = [chr(ord(c) ^ ord(next(chars))) for c in text]
        irc.reply(''.join(ret))
    xor = wrap(xor, ['something', 'text'])

    @internationalizeDocstring
    def md5(self, irc, msg, args, text):
        """<text>

        Returns the md5 hash of a given string.  Read
        http://www.rsasecurity.com/rsalabs/faq/3-6-6.html for more information
        about md5.
        """
        irc.reply(utils.crypt.md5(text.encode('utf8')).hexdigest())
    md5 = wrap(md5, ['text'])

    @internationalizeDocstring
    def sha(self, irc, msg, args, text):
        """<text>

        Returns the SHA hash of a given string.  Read
        http://www.secure-hash-algorithm-md5-sha-1.co.uk/ for more information
        about SHA.
        """
        irc.reply(utils.crypt.sha(text.encode('utf8')).hexdigest())
    sha = wrap(sha, ['text'])

Class = String


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2003-2005, Jeremiah Fincher
# Copyright (c) 2009, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import re

from supybot.test import *
import supybot.utils as utils

nicks = ['fatjim','scn','moshez','LordVan','MetaCosm','pythong','fishfart',
         'alb','d0rt','jemfinch','StyxAlso','fors','deltab','gd',
         'hellz_hunter','are_j|pub_comp','jason_','dreid','sayke_','winjer',
         'TenOfTen','GoNoVas','queuetue','the|zzz','Hellfried','Therion',
         'shro','DaCa','rexec','polin8','r0ky','aaron_','ironfroggy','eugene',
         'faassen','tirloni','mackstann','Yhg1s','ElBarono','vegai','shang',
         'typo_','kikoforgetme','asqui','TazyTiggy','fab','nixman','liiwi',
         'AdamV','paolo','red_one','_AleX_','lament','jamessan','supybot',
         'macr0_zzz','plaisthos','redghost','disco','mphardy','gt3','mathie',
         'jonez','r0ky-office','tic','d33p','ES3merge','talin','af','flippo',
         'sholden','ameoba','shepherg','j2','Acapnotic','dash','merlin262',
         'Taaus','_moshez','rik','jafo__','blk-majik','JT__','itamar',
         'kermit-','davidmccabe','glyph','jojo','dave_p','goo','hyjinx',
         'SamB','exarkun','drewp','Ragica','skylan','redgore','k3','Ra1stlin',
         'StevenK','carball','h3x','carljm','_jacob','teratorn','frangen',
         'phed','datazone','Yaggo','acct_','nowhere','pyn','ThomasWaldmann',
         'dunker','pilotLight','brainless','LoganH_','jmpnz','steinn',
         'EliasREC','lowks__','OldSmrf','Mad77','snibril','delta','psy',
         'skimpIzu','Kengur','MoonFallen','kotkis','Hyperi']

def group(seq, groupSize, noneFill=True):
    """Groups a given sequence into sublists of length groupSize."""
    ret = []
    L = []
    i = groupSize
    for elt in seq:
        if i > 0:
            L.append(elt)
        else:
            ret.append(L)
            i = groupSize
            L = []
            L.append(elt)
        i -= 1
    if L:
        if noneFill:
            while len(L) < groupSize:
                L.append(None)
        ret.append(L)
    return ret

class StringTestCase(PluginTestCase):
    plugins = ('String', 'Format', 'Status')
    def testLen(self):
        self.assertResponse('len foo', '3')
        self.assertHelp('len')

    def testNoErrors(self):
        self.assertNotError('levenshtein Python Perl')

    def testSoundex(self):
        self.assertNotError('soundex jemfinch')
        self.assertNotRegexp('soundex foobar 3:30', 'ValueError')

    def testChr(self):
        for i in range(256):
            c = chr(i)
            regexp = r'%s|%s' % (re.escape(c), re.escape(repr(c)))
            self.assertRegexp('chr %s' % i, regexp)

    def testOrd(self):
        for c in map(chr, range(256)):
            i = ord(c)
            self.assertResponse('ord %s' % utils.str.dqrepr(c), str(i))

    def testMd5(self):
        self.assertResponse('md5 supybot', '1360578d1276e945cc235654a53f9c65')


    def testEncodeDecode(self):
        # This no longer works correctly.  It almost seems like were throwing
        # in a repr() somewhere.
        s = 'the recalcitrant jamessan tests his scramble function'
        self.assertNotRegexp('encode aldkfja foobar', 'LookupError')
        self.assertNotRegexp('decode asdflkj foobar', 'LookupError')
        self.assertResponse('decode zlib [encode zlib %s]' % s, s)
        self.assertRegexp('decode base64 $BCfBg7;9D;R(B', 'padded with')

    def testRe(self):
        self.assertResponse('re "m/system time/" [status cpu]', 'system time')
        self.assertResponse('re s/user/luser/g user user', 'luser luser')
        self.assertResponse('re s/user/luser/ user user', 'luser user')
        self.assertNotRegexp('re m/foo/ bar', 'has no attribute')
        self.assertResponse('re m/a\S+y/ "the bot angryman is hairy"','angry')

    def testReNotEmptyString(self):
        self.assertError('re s//foo/g blah')

    def testReWorksWithJustCaret(self):
        self.assertResponse('re s/^/foo/ bar', 'foobar')

    def testReNoEscapingUnpackListOfWrongSize(self):
        self.assertNotRegexp('re foo bar baz', 'unpack list of wrong size')

    def testReBug850931(self):
        self.assertResponse('re s/\b(\w+)\b/\1./g foo bar baz',
                            'foo. bar. baz.')

    def testNotOverlongRe(self):
        self.assertError('re [strjoin "" s/./ [eval \'xxx\'*400]] blah blah')

    def testXor(self):
        # This no longer works correctly.  It almost seems like were throwing
        # in a repr() somewhere.
        L = [nick for nick in nicks if '|' not in nick and
                                       '[' not in nick and
                                       ']' not in nick]
        for s0, s1, s2, s3, s4, s5, s6, s7, s8, s9 in group(L, 10):
            data = '%s%s%s%s%s%s%s%s%s' % (s0, s1, s2, s3, s4, s5, s6, s7, s8)
            self.assertResponse('xor %s [xor %s %s]' % (s9, s9, data), data)


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2005, Daniel DiPaolo
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Success')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Success', True)


Success = conf.registerPlugin('Success')
# This is where your configuration variables (if any) should go.  For example:
# conf.registerGlobalValue(Success, 'someConfigVariableName',
#     registry.Boolean(False, _("""Help for someConfigVariableName.""")))
conf.registerChannelValue(conf.supybot.plugins.Success, 'prefixNick',
    registry.Boolean(True, _("""Determines whether the bot will prefix the nick
    of the user giving an invalid command to the success response.""")))


# vim:set shiftwidth=4 softtabstop=8 expandtab textwidth=78

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2005, Daniel DiPaolo
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
from supybot.commands import *
import supybot.plugins as plugins
import supybot.ircutils as ircutils
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Success')

class Success(plugins.ChannelIdDatabasePlugin):
    """This plugin was written initially to work with MoobotFactoids, the two
    of them to provide a similar-to-moobot-and-blootbot interface for factoids.
    Basically, it replaces the standard 'The operation succeeded.' messages
    with messages kept in a database, able to give more personable
    responses."""

    def __init__(self, irc):
        self.__parent = super(Success, self)
        self.__parent.__init__(irc)
        self.target = None
        pluginSelf = self
        self.originalClass = conf.supybot.replies.success.__class__
        class MySuccessClass(self.originalClass):
            def __call__(self):
                ret = pluginSelf.db.random(dynamic.msg.args[0])
                if ret is None:
                    try:
                        self.__class__ = pluginSelf.originalClass
                        ret = self()
                    finally:
                        self.__class__ = MySuccessClass
                else:
                    ret = ret.text
                return ret

            def get(self, attr):
                if ircutils.isChannel(attr):
                    pluginSelf.target = attr
                return self
        conf.supybot.replies.success.__class__ = MySuccessClass

    def die(self):
        self.__parent.die()
        conf.supybot.replies.success.__class__ = self.originalClass

Success = internationalizeDocstring(Success)

Class = Success

# vim:set shiftwidth=4 softtabstop=8 expandtab textwidth=78:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2005, Daniel DiPaolo
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

class SuccessTestCase(PluginTestCase):
    plugins = ('Success',)


# vim:set shiftwidth=4 softtabstop=8 expandtab textwidth=78:

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Time')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Time', True)

Time = conf.registerPlugin('Time')
conf.registerChannelValue(Time, 'format',
    registry.String(str(conf.supybot.reply.format.time()), _("""Determines the
    format string for timestamps.  Refer to the Python documentation for the
    time module to see what formats are accepted. If you set this variable to
    the empty string, the timestamp will not be shown.""")))


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2004, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import time
TIME = time # For later use.
from datetime import datetime

import supybot.conf as conf
import supybot.utils as utils
from supybot.commands import *
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Time')


try:
    from dateutil import parser
    def parse(s):
        todo = []
        s = s.replace('noon', '12:00')
        s = s.replace('midnight', '00:00')
        if 'tomorrow' in s:
            todo.append(lambda i: i + 86400)
            s = s.replace('tomorrow', '')
        if 'next week' in s:
            todo.append(lambda i: i + 86400*7)
            s = s.replace('next week', '')
        i = int(time.mktime(parser.parse(s, fuzzy=True).timetuple()))
        for f in todo:
            i = f(i)
        return i
except ImportError:
    parse = None

class Time(callbacks.Plugin):
    @internationalizeDocstring
    def seconds(self, irc, msg, args):
        """[<years>y] [<weeks>w] [<days>d] [<hours>h] [<minutes>m] [<seconds>s]

        Returns the number of seconds in the number of <years>, <weeks>,
        <days>, <hours>, <minutes>, and <seconds> given.  An example usage is
        "seconds 2h 30m", which would return 9000, which is '3600*2 + 30*60'.
        Useful for scheduling events at a given number of seconds in the
        future.
        """
        if not args:
            raise callbacks.ArgumentError
        seconds = 0
        for arg in args:
            if not arg or arg[-1] not in 'ywdhms':
                raise callbacks.ArgumentError
            (s, kind) = arg[:-1], arg[-1]
            try:
                i = int(s)
            except ValueError:
                irc.errorInvalid('argument', arg, Raise=True)
            if kind == 'y':
                seconds += i*31536000
            elif kind == 'w':
                seconds += i*604800
            elif kind == 'd':
                seconds += i*86400
            elif kind == 'h':
                seconds += i*3600
            elif kind == 'm':
                seconds += i*60
            elif kind == 's':
                seconds += i
        irc.reply(str(seconds))

    @internationalizeDocstring
    def at(self, irc, msg, args, s=None):
        """[<time string>]

        Returns the number of seconds since epoch <time string> is.
        <time string> can be any number of natural formats; just try something
        and see if it will work.
        If the <time string> is not given, defaults to now.
        """
        if not s:
            irc.reply(str(int(time.time())))
            return
        if not parse:
            irc.error(_('This command is not available on this bot, ask the '
                'owner to install the python-dateutil library.'), Raise=True)
        now = int(time.time())
        new = parse(s)
        if new != now:
            irc.reply(str(new))
        else:
            irc.error(_('That\'s right now!'))
    at = wrap(at, [optional('text')])

    @internationalizeDocstring
    def until(self, irc, msg, args, s):
        """<time string>

        Returns the number of seconds until <time string>.
        """
        if not parse:
            irc.error(_('This command is not available on this bot, ask the '
                'owner to install the python-dateutil library.'), Raise=True)
        now = int(time.time())
        new = parse(s)
        if new != now:
            if new - now < 0:
                new += 86400
            irc.reply(str(new-now))
        else:
            irc.error(_('That\'s right now!'))
    until = wrap(until, ['text'])

    @internationalizeDocstring
    def ctime(self, irc, msg, args, seconds):
        """[<seconds since epoch>]

        Returns the ctime for <seconds since epoch>, or the current ctime if
        no <seconds since epoch> is given.
        """
        irc.reply(time.ctime(seconds))
    ctime = wrap(ctime,[additional(('int', _('number of seconds since epoch')),
                                    TIME.time)])

    @internationalizeDocstring
    def time(self, irc, msg, args, channel, format, seconds):
        """[<format>] [<seconds since epoch>]

        Returns the current time in <format> format, or, if <format> is not
        given, uses the configurable format for the current channel.  If no
        <seconds since epoch> time is given, the current time is used.
        """
        if not format:
            if channel:
                format = self.registryValue('format', channel)
            else:
                format = self.registryValue('format')
        irc.reply(time.strftime(format, time.localtime(seconds)))
    time = wrap(time, [optional('channel'), optional('nonInt'),
                       additional('float', TIME.time)])

    @internationalizeDocstring
    def elapsed(self, irc, msg, args, seconds):
        """<seconds>

        Returns a pretty string that is the amount of time represented by
        <seconds>.
        """
        irc.reply(utils.timeElapsed(seconds))
    elapsed = wrap(elapsed, ['int'])

    @internationalizeDocstring
    def tztime(self, irc, msg, args, timezone):
        """<region>/<city>

        Takes a city and its region, and returns the locale time."""
        try:
            import pytz
        except ImportError:
            irc.error(_('Python-tz is required by the command, but is not '
                        'installed on this computer.'))
            return
        try:
            timezone = pytz.timezone(timezone)
        except pytz.UnknownTimeZoneError:
            irc.error(_('Unknown timezone'))
            return
        irc.reply(str(datetime.now(timezone)))
    tztime = wrap(tztime, ['text'])


Class = Time

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2004, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

class TimeTestCase(PluginTestCase):
    plugins = ('Time','Utilities')
    def testSeconds(self):
        self.assertResponse('seconds 1s', '1')
        self.assertResponse('seconds 10s', '10')
        self.assertResponse('seconds 1m', '60')
        self.assertResponse('seconds 1m 1s', '61')
        self.assertResponse('seconds 1h', '3600')
        self.assertResponse('seconds 1h 1s', '3601')
        self.assertResponse('seconds 1d', '86400')
        self.assertResponse('seconds 1d 1s', '86401')
        self.assertResponse('seconds 2s', '2')
        self.assertResponse('seconds 2m', '120')
        self.assertResponse('seconds 2d 2h 2m 2s', '180122')
        self.assertResponse('seconds 1s', '1')
        self.assertResponse('seconds 1y 1s', '31536001')
        self.assertResponse('seconds 1w 1s', '604801')

    def testNoErrors(self):
        self.assertNotError('ctime')
        self.assertNotError('time %Y')
        self.assertNotError('tztime Europe/Paris')

    def testNoNestedErrors(self):
        self.assertNotError('echo [until 4:00]')
        self.assertNotError('echo [at now]')
        self.assertNotError('echo [seconds 4m]')

    def testErrors(self):
        self.assertError('tztime Europe/Gniarf')


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:


########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2003-2005, Daniel DiPaolo
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Todo')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Todo', True)


Todo = conf.registerPlugin('Todo')
# This is where your configuration variables (if any) should go.  For example:
# conf.registerGlobalValue(Todo, 'someConfigVariableName',
#     registry.Boolean(False, _("""Help for someConfigVariableName.""")))

conf.registerGlobalValue(Todo, 'allowThirdpartyReader',
    registry.Boolean(False, _("""Determines whether users can read the
    todo-list of another user.""")))

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2003-2005, Daniel DiPaolo
# Copyright (c) 2010, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import os
import re
import time
import operator

import supybot.dbi as dbi
import supybot.conf as conf
import supybot.ircdb as ircdb
import supybot.utils as utils
from supybot.commands import *
import supybot.plugins as plugins
import supybot.ircutils as ircutils
import supybot.callbacks as callbacks
from supybot import commands
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Todo')

class TodoRecord(dbi.Record):
    __fields__ = [
          ('priority', int),
          'at',
          'task',
          'active',
          ]

dataDir = conf.supybot.directories.data

class FlatTodoDb(object):
    def __init__(self):
        self.directory = dataDir.dirize('Todo')
        if not os.path.exists(self.directory):
            os.mkdir(self.directory)
        self.dbs = {}

    def _getDb(self, uid):
        dbfile = os.path.join(self.directory, str(uid))
        if uid not in self.dbs:
            self.dbs[uid] = dbi.DB(dbfile, Record=TodoRecord)
        return self.dbs[uid]

    def close(self):
        for db in self.dbs.itervalues():
            db.close()

    def get(self, uid, tid):
        db = self._getDb(uid)
        return db.get(tid)

    def getTodos(self, uid):
        db = self._getDb(uid)
        L = [R for R in db.select(lambda r: r.active)]
        if not L:
            raise dbi.NoRecordError
        return L

    def add(self, priority, now, uid, task):
        db = self._getDb(uid)
        return db.add(TodoRecord(priority=priority, at=now,
                                 task=task, active=True))

    def remove(self, uid, tid):
        db = self._getDb(uid)
        t = db.get(tid)
        t.active = False
        db.set(tid, t)

    def select(self, uid, criteria):
        db = self._getDb(uid)
        def match(todo):
            for p in criteria:
                if not p(todo.task):
                    return False
            return True
        todos = db.select(lambda t: match(t))
        if not todos:
            raise dbi.NoRecordError
        return todos

    def setpriority(self, uid, tid, priority):
        db = self._getDb(uid)
        t = db.get(tid)
        t.priority = priority
        db.set(tid, t)

    def change(self, uid, tid, replacer):
        db = self._getDb(uid)
        t = db.get(tid)
        t.task = replacer(t.task)
        db.set(tid, t)

class Todo(callbacks.Plugin):
    def __init__(self, irc):
        self.__parent = super(Todo, self)
        self.__parent.__init__(irc)
        self.db = FlatTodoDb()

    def die(self):
        self.__parent.die()
        self.db.close()

    def _shrink(self, s):
        return utils.str.ellipsisify(s, 50)

    @internationalizeDocstring
    def todo(self, irc, msg, args, user, taskid):
        """[<username>] [<task id>]

        Retrieves a task for the given task id.  If no task id is given, it
        will return a list of task ids that that user has added to their todo
        list.
        """
        try:
            u = ircdb.users.getUser(msg.prefix)
        except KeyError:
            u = None
        if u != user and not self.registryValue('allowThirdpartyReader'):
            irc.error(_('You are not allowed to see other users todo-list.'))
            return
        # List the active tasks for the given user
        if not taskid:
            try:
                tasks = self.db.getTodos(user.id)
                utils.sortBy(operator.attrgetter('priority'), tasks)
                tasks = [format(_('#%i: %s'), t.id, self._shrink(t.task))
                         for t in tasks]
                Todo = 'Todo'
                if len(tasks) != 1:
                    Todo = 'Todos'
                irc.reply(format(_('%s for %s: %L'),
                                 Todo, user.name, tasks))
            except dbi.NoRecordError:
                if u != user:
                    irc.reply(_('That user has no tasks in their todo list.'))
                else:
                    irc.reply(_('You have no tasks in your todo list.'))
                return
        # Reply with the user's task
        else:
            try:
                t = self.db.get(user.id, taskid)
                if t.active:
                    active = _('Active')
                else:
                    active = _('Inactive')
                if t.priority:
                    t.task += format(_(', priority: %i'), t.priority)
                at = time.strftime(conf.supybot.reply.format.time(),
                                   time.localtime(t.at))
                s = format(_('%s todo for %s: %s (Added at %s)'),
                           active, user.name, t.task, at)
                irc.reply(s)
            except dbi.NoRecordError:
                irc.errorInvalid(_('task id'), taskid)
    todo = wrap(todo, [first('otherUser', 'user'), additional(('id', 'task'))])

    @internationalizeDocstring
    def add(self, irc, msg, args, user, optlist, text, now):
        """[--priority=<num>] <text>

        Adds <text> as a task in your own personal todo list.  The optional
        priority argument allows you to set a task as a high or low priority.
        Any integer is valid.
        """
        priority = 0
        for (option, arg) in optlist:
            if option == 'priority':
                priority = arg
        todoId = self.db.add(priority, now, user.id, text)
        irc.replySuccess(format(_('(Todo #%i added)'), todoId))
    add = wrap(add, ['user', getopts({'priority': ('int', 'priority')}),
                     'text', 'now'])

    @internationalizeDocstring
    def remove(self, irc, msg, args, user, tasks):
        """<task id> [<task id> ...]

        Removes <task id> from your personal todo list.
        """
        invalid = []
        for taskid in tasks:
            try:
                self.db.get(user.id, taskid)
            except dbi.NoRecordError:
                invalid.append(taskid)
        if invalid and len(invalid) == 1:
            irc.error(format(_('Task %i could not be removed either because '
                             'that id doesn\'t exist or it has been removed '
                             'already.'), invalid[0]))
        elif invalid:
            irc.error(format(_('No tasks were removed because the following '
                             'tasks could not be removed: %L.'), invalid))
        else:
            for taskid in tasks:
                self.db.remove(user.id, taskid)
            irc.replySuccess()
    remove = wrap(remove, ['user', many(('id', 'task'))])

    @internationalizeDocstring
    def search(self, irc, msg, args, user, optlist, globs):
        """[--{regexp} <value>] [<glob> <glob> ...]

        Searches your todos for tasks matching <glob>.  If --regexp is given,
        its associated value is taken as a regexp and matched against the
        tasks.
        """
        if not optlist and not globs:
            raise callbacks.ArgumentError
        criteria = []
        for (option, arg) in optlist:
            if option == 'regexp':
                criteria.append(lambda s:
                                regexp_wrapper(s, reobj=arg, timeout=0.1,
                                               plugin_name=self.name(),
                                               fcn_name='search'))
        for glob in globs:
            glob = utils.python.glob2re(glob)
            criteria.append(re.compile(glob).search)
        try:
            tasks = self.db.select(user.id, criteria)
            L = [format('#%i: %s', t.id, self._shrink(t.task)) for t in tasks]
            irc.reply(format('%L', L))
        except dbi.NoRecordError:
            irc.reply(_('No tasks matched that query.'))
    search = wrap(search,
                  ['user', getopts({'regexp': 'regexpMatcher'}), any('glob')])

    @internationalizeDocstring
    def setpriority(self, irc, msg, args, user, id, priority):
        """<id> <priority>

        Sets the priority of the todo with the given id to the specified value.
        """
        try:
            self.db.setpriority(user.id, id, priority)
            irc.replySuccess()
        except dbi.NoRecordError:
            irc.errorInvalid(_('task id'), id)
    setpriority = wrap(setpriority,
                       ['user', ('id', 'task'), ('int', 'priority')])

    @internationalizeDocstring
    def change(self, irc, msg, args, user, id, replacer):
        """<task id> <regexp>

        Modify the task with the given id using the supplied regexp.
        """
        try:
            self.db.change(user.id, id, replacer)
            irc.replySuccess()
        except dbi.NoRecordError:
            irc.errorInvalid(_('task id'), id)
    change = wrap(change, ['user', ('id', 'task'), 'regexpReplacer'])


Class = Todo


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2003-2005, Daniel DiPaolo
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

class TodoTestCase(PluginTestCase):
    plugins = ('Todo', 'User', 'Config')
    _user1 = 'foo!bar@baz'
    _user2 = 'bar!foo@baz'
    def setUp(self):
        PluginTestCase.setUp(self)
        # Create a valid user to use
        self.prefix = self._user2
        self.assertNotError('register testy oom')
        self.prefix = self._user1
        self.assertNotError('register tester moo')

    def testTodo(self):
        # Should not error, but no tasks yet.
        self.assertNotError('todo')
        self.assertRegexp('todo', 'You have no tasks')
        # Add a task
        self.assertNotError('todo add wash my car')
        self.assertRegexp('todo', '#1: wash my car')
        # Check that task
        self.assertRegexp('todo 1',
                          'Todo for tester: wash my car \(Added .*?\)')
        # Check that it lists all my tasks when given my name
        self.assertResponse('todo tester',
                            'Todo for tester: #1: wash my car')
        # Check pluralization
        self.assertNotError('todo add moo')
        self.assertRegexp('todo tester',
                          'Todos for tester: #1: wash my car and #2: moo')
        # Check error
        self.assertError('todo asfas')
        self.assertRegexp('todo asfas',
                            'Error: \'asfas\' is not a valid task')
        # Check priority sorting
        self.assertNotError('todo setpriority 1 100')
        self.assertNotError('todo setpriority 2 10')
        self.assertRegexp('todo', '#2: moo and #1: wash my car')
        # Check permissions
        self.prefix = self._user2
        self.assertError('todo tester')
        self.assertNotRegexp('todo tester', 'task id')
        self.prefix = self._user1
        self.assertNotError('todo tester')
        self.assertNotError('config plugins.Todo.allowThirdpartyReader True')
        self.prefix = self._user2
        self.assertNotError('todo tester')
        self.prefix = self._user1
        self.assertNotError('todo tester')

    def testAddtodo(self):
        self.assertNotError('todo add code a new plugin')
        self.assertNotError('todo add --priority=1000 fix all bugs')

    def testRemovetodo(self):
        self.nick = 'testy'
        self.prefix = self._user2
        self.assertNotError('todo add do something')
        self.assertNotError('todo add do something else')
        self.assertNotError('todo add do something again')
        self.assertNotError('todo remove 1')
        self.assertNotError('todo 1')
        self.nick = 'tester'
        self.prefix = self._user1
        self.assertNotError('todo add make something')
        self.assertNotError('todo add make something else')
        self.assertNotError('todo add make something again')
        self.assertNotError('todo remove 1 3')
        self.assertRegexp('todo 1', r'Inactive')
        self.assertRegexp('todo 3', r'Inactive')
        self.assertNotError('todo')

    def testSearchtodo(self):
        self.assertNotError('todo add task number one')
        self.assertRegexp('todo search task*', '#1: task number one')
        self.assertRegexp('todo search number', '#1: task number one')
        self.assertNotError('todo add task number two is much longer than'
                            ' task number one')
        self.assertRegexp('todo search task*',
                          '#1: task number one and #2: task number two is '
                          'much longer than task number...')
        self.assertError('todo search --regexp s/bustedregex')
        self.assertRegexp('todo search --regexp m/task/',
                          '#1: task number one and #2: task number two is '
                          'much longer than task number...')

    def testSetPriority(self):
        self.assertNotError('todo add --priority=1 moo')
        self.assertRegexp('todo 1',
                          'moo, priority: 1 \(Added at .*?\)')
        self.assertNotError('setpriority 1 50')
        self.assertRegexp('todo 1',
                          'moo, priority: 50 \(Added at .*?\)')
        self.assertNotError('setpriority 1 0')
        self.assertRegexp('todo 1', 'moo \(Added at .*?\)')

    def testChangeTodo(self):
        self.assertNotError('todo add moo')
        self.assertError('todo change 1 asdfas')
        self.assertError('todo change 1 m/asdfaf//')
        self.assertNotError('todo change 1 s/moo/foo/')
        self.assertRegexp('todo 1', 'Todo for tester: foo \(Added .*?\)')

    def testActiveInactiveTodo(self):
        self.assertNotError('todo add foo')
        self.assertNotError('todo add bar')
        self.assertRegexp('todo 1', 'Active')
        self.assertRegexp('todo 2', 'Active')
        self.assertNotError('todo remove 1')
        self.assertRegexp('todo 1', 'Inactive')
        self.assertRegexp('todo 2', 'Active')
        self.assertNotError('todo remove 2')
        self.assertRegexp('todo 2', 'Inactive')


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Topic')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Topic', True)


class TopicFormat(registry.TemplatedString):
    "Value must include $topic, otherwise the actual topic would be left out."
    requiredTemplates = ['topic']

Topic = conf.registerPlugin('Topic')
conf.registerChannelValue(Topic, 'separator',
    registry.StringSurroundedBySpaces(' || ', _("""Determines what separator is
    used between individually added topics in the channel topic.""")))
conf.registerChannelValue(Topic, 'format',
    TopicFormat('$topic ($nick)', _("""Determines what format is used to add
    topics in the topic.  All the standard substitutes apply, in addition to
    "$topic" for the topic itself.""")))
conf.registerChannelValue(Topic, 'recognizeTopiclen',
    registry.Boolean(True, _("""Determines whether the bot will recognize the
    TOPICLEN value sent to it by the server and thus refuse to send TOPICs
    longer than the TOPICLEN.  These topics are likely to be truncated by the
    server anyway, so this defaults to True.""")))
conf.registerChannelValue(Topic, 'default',
    registry.String('', _("""Determines what the default topic for the channel
    is.  This is used by the default command to set this topic.""")))
conf.registerChannelValue(Topic, 'alwaysSetOnJoin',
    registry.Boolean(False, _("""Determines whether the bot will set the topic
    every time it joins, or only if the topic is empty.""")))
conf.registerGroup(Topic, 'undo')
conf.registerChannelValue(Topic.undo, 'max',
    registry.NonNegativeInteger(10, _("""Determines the number of previous
    topics to keep around in case the undo command is called.""")))
conf.registerChannelValue(Topic, 'requireManageCapability',
    registry.String('channel,op; channel,halfop', _("""Determines the
    capabilities required (if any) to make any topic changes,
    (everything except for read-only operations). Use 'channel,capab' for
    channel-level capabilities.
    Note that absence of an explicit anticapability means user has
    capability.""")))


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2002-2004, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import re
import os
import re
import random
import shutil
import tempfile
import cPickle as pickle

import supybot.conf as conf
import supybot.ircdb as ircdb
import supybot.utils as utils
import supybot.world as world
from supybot.commands import *
import supybot.ircmsgs as ircmsgs
import supybot.plugins as plugins
import supybot.ircutils as ircutils
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Topic')

import supybot.ircdb as ircdb

def canChangeTopic(irc, msg, args, state):
    assert not state.channel
    callConverter('channel', irc, msg, args, state)
    callConverter('inChannel', irc, msg, args, state)
    if state.channel not in irc.state.channels:
        state.error(format(_('I\'m not currently in %s.'), state.channel),
                    Raise=True)
    c = irc.state.channels[state.channel]
    if 't' in c.modes and not c.isHalfopPlus(irc.nick):
        state.error(format(_('I can\'t change the topic, I\'m not (half)opped '
                           'and %s is +t.'), state.channel), Raise=True)

def getTopic(irc, msg, args, state, format=True):
    separator = state.cb.registryValue('separator', state.channel)
    if separator in args[0]:
        state.errorInvalid('topic', args[0],
                           format(_('The topic must not include %q.'),
                                  separator))
    topic = args.pop(0)
    if format:
        env = {'topic': topic}
        formatter = state.cb.registryValue('format', state.channel)
        topic = ircutils.standardSubstitute(irc, msg, formatter, env)
    state.args.append(topic)

def getTopicNumber(irc, msg, args, state):
    def error(s):
        state.errorInvalid(_('topic number'), s)
    try:
        n = int(args[0])
        if not n:
            raise ValueError
    except ValueError:
        error(args[0])
    if n > 0:
        n -= 1
    topic = irc.state.getTopic(state.channel)
    separator = state.cb.registryValue('separator', state.channel)
    topics = splitTopic(topic, separator)
    if not topics:
        state.error(format(_('There are no topics in %s.'), state.channel),
                    Raise=True)
    try:
        topics[n]
    except IndexError:
        error(args[0])
    del args[0]
    while n < 0:
        n += len(topics)
    state.args.append(n)

addConverter('topic', getTopic)
addConverter('topicNumber', getTopicNumber)
addConverter('canChangeTopic', canChangeTopic)

def splitTopic(topic, separator):
    return list(filter(None, topic.split(separator)))

datadir = conf.supybot.directories.data()
filename = conf.supybot.directories.data.dirize('Topic.pickle')

class Topic(callbacks.Plugin):
    def __init__(self, irc):
        self.__parent = super(Topic, self)
        self.__parent.__init__(irc)
        self.undos = ircutils.IrcDict()
        self.redos = ircutils.IrcDict()
        self.lastTopics = ircutils.IrcDict()
        self.watchingFor332 = ircutils.IrcSet()
        try:
            pkl = open(filename, 'rb')
            try:
                self.undos = pickle.load(pkl)
                self.redos = pickle.load(pkl)
                self.lastTopics = pickle.load(pkl)
                self.watchingFor332 = pickle.load(pkl)
            except Exception as e:
                self.log.debug('Unable to load pickled data: %s', e)
            pkl.close()
        except IOError as e:
            self.log.debug('Unable to open pickle file: %s', e)
        world.flushers.append(self._flush)

    def die(self):
        world.flushers.remove(self._flush)
        self.__parent.die()

    def _flush(self):
        try:
            pklfd, tempfn = tempfile.mkstemp(suffix='topic', dir=datadir)
            pkl = os.fdopen(pklfd, 'wb')
            try:
                pickle.dump(self.undos, pkl)
                pickle.dump(self.redos, pkl)
                pickle.dump(self.lastTopics, pkl)
                pickle.dump(self.watchingFor332, pkl)
            except Exception as e:
                self.log.warning('Unable to store pickled data: %s', e)
            pkl.close()
            shutil.move(tempfn, filename)
        except (IOError, shutil.Error) as e:
            self.log.warning('File error: %s', e)

    def _splitTopic(self, topic, channel):
        separator = self.registryValue('separator', channel)
        return splitTopic(topic, separator)

    def _joinTopic(self, channel, topics):
        separator = self.registryValue('separator', channel)
        return separator.join(topics)

    def _addUndo(self, channel, topics):
        stack = self.undos.setdefault(channel, [])
        stack.append(topics)
        maxLen = self.registryValue('undo.max', channel)
        del stack[:len(stack)-maxLen]

    def _addRedo(self, channel, topics):
        stack = self.redos.setdefault(channel, [])
        stack.append(topics)
        maxLen = self.registryValue('undo.max', channel)
        del stack[:len(stack)-maxLen]

    def _getUndo(self, channel):
        try:
            return self.undos[channel].pop()
        except (KeyError, IndexError):
            return None

    def _getRedo(self, channel):
        try:
            return self.redos[channel].pop()
        except (KeyError, IndexError):
            return None

    def _formatTopics(self, irc, channel, topics, fit=False):
        topics = [s for s in topics if s and not s.isspace()]
        self.lastTopics[channel] = topics
        newTopic = self._joinTopic(channel, topics)
        try:
            maxLen = irc.state.supported['topiclen']
            if fit:
                while len(newTopic) > maxLen:
                    topics.pop(0)
                    self.lastTopics[channel] = topics
                    newTopic = self._joinTopic(channel, topics)
            elif len(newTopic) > maxLen:
                if self.registryValue('recognizeTopiclen', channel):
                    irc.error(format(_('That topic is too long for this '
                                     'server (maximum length: %i; this topic: '
                                     '%i).'), maxLen, len(newTopic)),
                              Raise=True)
        except KeyError:
            pass
        return newTopic

    def _sendTopics(self, irc, channel, topics=None, isDo=False, fit=False):
        if isinstance(topics, list) or isinstance(topics, tuple):
            assert topics is not None
            topics = self._formatTopics(irc, channel, topics, fit)
        self._addUndo(channel, topics)
        if not isDo and channel in self.redos:
            del self.redos[channel]
        irc.queueMsg(ircmsgs.topic(channel, topics))
        irc.noReply()

    def _checkManageCapabilities(self, irc, msg, channel):
        """Check if the user has any of the required capabilities to manage
        the channel topic.

        The list of required capabilities is in requireManageCapability
        channel config.

        Also allow if the user is a chanop. Since he can change the topic
        manually anyway.
        """
        c = irc.state.channels[channel]
        if msg.nick in c.ops or msg.nick in c.halfops or 't' not in c.modes:
            return True
        capabilities = self.registryValue('requireManageCapability')
        if capabilities:
            for capability in re.split(r'\s*;\s*', capabilities):
                if capability.startswith('channel,'):
                    capability = ircdb.makeChannelCapability(channel, capability[8:])
                if capability and ircdb.checkCapability(msg.prefix, capability):
                    return True
            return False
        else:
            return True

    def doJoin(self, irc, msg):
        if ircutils.strEqual(msg.nick, irc.nick):
            # We're joining a channel, let's watch for the topic.
            self.watchingFor332.add(msg.args[0])

    def do315(self, irc, msg):
        # Try to restore the topic when not set yet.
        channel = msg.args[1]
        c = irc.state.channels.get(channel)
        if c is None:
            return
        if irc.nick not in c.ops and 't' in c.modes:
            self.log.debug('Not trying to restore topic in %s. I\'m not opped '
                               'and %s is +t.', channel, channel)
            return
        try:
            topics = self.lastTopics[channel]
        except KeyError:
            self.log.debug('No topic to auto-restore in %s.', channel)
        else:
            newTopic = self._formatTopics(irc, channel, topics)
            if c.topic == '' or (c.topic != newTopic and
                    self.registryValue('alwaysSetOnJoin', channel)):
                self._sendTopics(irc, channel, newTopic)

    def do332(self, irc, msg):
        if msg.args[1] in self.watchingFor332:
            self.watchingFor332.remove(msg.args[1])
            # Store an undo for the topic when we join a channel.  This allows
            # us to undo the first topic change that takes place in a channel.
            self._addUndo(msg.args[1], [msg.args[2]])

    @internationalizeDocstring
    def topic(self, irc, msg, args, channel):
        """[<channel>]

        Returns the topic for <channel>.  <channel> is only necessary if the
        message isn't sent in the channel itself.
        """
        topic = irc.state.channels[channel].topic
        irc.reply(topic)
    topic = wrap(topic, ['inChannel'])

    @internationalizeDocstring
    def add(self, irc, msg, args, channel, topic):
        """[<channel>] <topic>

        Adds <topic> to the topics for <channel>.  <channel> is only necessary
        if the message isn't sent in the channel itself.
        """
        if not self._checkManageCapabilities(irc, msg, channel):
            capabilities = self.registryValue('requireManageCapability')
            irc.errorNoCapability(capabilities, Raise=True)
        topics = self._splitTopic(irc.state.getTopic(channel), channel)
        topics.append(topic)
        self._sendTopics(irc, channel, topics)
    add = wrap(add, ['canChangeTopic', rest('topic')])

    @internationalizeDocstring
    def fit(self, irc, msg, args, channel, topic):
        """[<channel>] <topic>

        Adds <topic> to the topics for <channel>.  If the topic is too long
        for the server, topics will be popped until there is enough room.
        <channel> is only necessary if the message isn't sent in the channel
        itself.
        """
        if not self._checkManageCapabilities(irc, msg, channel):
            capabilities = self.registryValue('requireManageCapability')
            irc.errorNoCapability(capabilities, Raise=True)
        topics = self._splitTopic(irc.state.getTopic(channel), channel)
        topics.append(topic)
        self._sendTopics(irc, channel, topics, fit=True)
    fit = wrap(fit, ['canChangeTopic', rest('topic')])

    @internationalizeDocstring
    def replace(self, irc, msg, args, channel, i, topic):
        """[<channel>] <number> <topic>

        Replaces topic <number> with <topic>.
        """
        if not self._checkManageCapabilities(irc, msg, channel):
            capabilities = self.registryValue('requireManageCapability')
            irc.errorNoCapability(capabilities, Raise=True)
        topics = self._splitTopic(irc.state.getTopic(channel), channel)
        topics[i] = topic
        self._sendTopics(irc, channel, topics)
    replace = wrap(replace, ['canChangeTopic', 'topicNumber', rest('topic')])

    @internationalizeDocstring
    def insert(self, irc, msg, args, channel, topic):
        """[<channel>] <topic>

        Adds <topic> to the topics for <channel> at the beginning of the topics
        currently on <channel>.  <channel> is only necessary if the message
        isn't sent in the channel itself.
        """
        if not self._checkManageCapabilities(irc, msg, channel):
            capabilities = self.registryValue('requireManageCapability')
            irc.errorNoCapability(capabilities, Raise=True)
        topics = self._splitTopic(irc.state.getTopic(channel), channel)
        topics.insert(0, topic)
        self._sendTopics(irc, channel, topics)
    insert = wrap(insert, ['canChangeTopic', rest('topic')])

    @internationalizeDocstring
    def shuffle(self, irc, msg, args, channel):
        """[<channel>]

        Shuffles the topics in <channel>.  <channel> is only necessary if the
        message isn't sent in the channel itself.
        """
        if not self._checkManageCapabilities(irc, msg, channel):
            capabilities = self.registryValue('requireManageCapability')
            irc.errorNoCapability(capabilities, Raise=True)
        topics = self._splitTopic(irc.state.getTopic(channel), channel)
        if len(topics) == 0 or len(topics) == 1:
            irc.error(_('I can\'t shuffle 1 or fewer topics.'), Raise=True)
        elif len(topics) == 2:
            topics.reverse()
        else:
            original = topics[:]
            while topics == original:
                random.shuffle(topics)
        self._sendTopics(irc, channel, topics)
    shuffle = wrap(shuffle, ['canChangeTopic'])

    @internationalizeDocstring
    def reorder(self, irc, msg, args, channel, numbers):
        """[<channel>] <number> [<number> ...]

        Reorders the topics from <channel> in the order of the specified
        <number> arguments.  <number> is a one-based index into the topics.
        <channel> is only necessary if the message isn't sent in the channel
        itself.
        """
        if not self._checkManageCapabilities(irc, msg, channel):
            capabilities = self.registryValue('requireManageCapability')
            irc.errorNoCapability(capabilities, Raise=True)
        topics = self._splitTopic(irc.state.getTopic(channel), channel)
        num = len(topics)
        if num == 0 or num == 1:
            irc.error(_('I cannot reorder 1 or fewer topics.'), Raise=True)
        if len(numbers) != num:
            irc.error(_('All topic numbers must be specified.'), Raise=True)
        if sorted(numbers) != range(num):
            irc.error(_('Duplicate topic numbers cannot be specified.'))
            return
        newtopics = [topics[i] for i in numbers]
        self._sendTopics(irc, channel, newtopics)
    reorder = wrap(reorder, ['canChangeTopic', many('topicNumber')])

    @internationalizeDocstring
    def list(self, irc, msg, args, channel):
        """[<channel>]

        Returns a list of the topics in <channel>, prefixed by their indexes.
        Mostly useful for topic reordering.  <channel> is only necessary if the
        message isn't sent in the channel itself.
        """
        topics = self._splitTopic(irc.state.getTopic(channel), channel)
        L = []
        for (i, t) in enumerate(topics):
            L.append(format(_('%i: %s'), i+1, utils.str.ellipsisify(t, 30)))
        s = utils.str.commaAndify(L)
        irc.reply(s)
    list = wrap(list, ['inChannel'])

    @internationalizeDocstring
    def get(self, irc, msg, args, channel, number):
        """[<channel>] <number>

        Returns topic number <number> from <channel>.  <number> is a one-based
        index into the topics.  <channel> is only necessary if the message
        isn't sent in the channel itself.
        """
        topics = self._splitTopic(irc.state.getTopic(channel), channel)
        irc.reply(topics[number])
    get = wrap(get, ['inChannel', 'topicNumber'])

    @internationalizeDocstring
    def change(self, irc, msg, args, channel, number, replacer):
        """[<channel>] <number> <regexp>

        Changes the topic number <number> on <channel> according to the regular
        expression <regexp>.  <number> is the one-based index into the topics;
        <regexp> is a regular expression of the form
        s/regexp/replacement/flags.  <channel> is only necessary if the message
        isn't sent in the channel itself.
        """
        if not self._checkManageCapabilities(irc, msg, channel):
            capabilities = self.registryValue('requireManageCapability')
            irc.errorNoCapability(capabilities, Raise=True)
        topics = self._splitTopic(irc.state.getTopic(channel), channel)
        topics[number] = replacer(topics[number])
        self._sendTopics(irc, channel, topics)
    change = wrap(change, ['canChangeTopic', 'topicNumber', 'regexpReplacer'])

    @internationalizeDocstring
    def set(self, irc, msg, args, channel, number, topic):
        """[<channel>] [<number>] <topic>

        Sets the topic <number> to be <text>.  If no <number> is given, this
        sets the entire topic.  <channel> is only necessary if the message
        isn't sent in the channel itself.
        """
        if not self._checkManageCapabilities(irc, msg, channel):
            capabilities = self.registryValue('requireManageCapability')
            irc.errorNoCapability(capabilities, Raise=True)
        if number is not None:
            topics = self._splitTopic(irc.state.getTopic(channel), channel)
            topics[number] = topic
        else:
            topics = [topic]
        self._sendTopics(irc, channel, topics)
    set = wrap(set, ['canChangeTopic',
                     optional('topicNumber'),
                     rest(('topic', False))])

    @internationalizeDocstring
    def remove(self, irc, msg, args, channel, number):
        """[<channel>] <number>

        Removes topic <number> from the topic for <channel>  Topics are
        numbered starting from 1; you can also use negative indexes to refer
        to topics starting the from the end of the topic.  <channel> is only
        necessary if the message isn't sent in the channel itself.
        """
        if not self._checkManageCapabilities(irc, msg, channel):
            capabilities = self.registryValue('requireManageCapability')
            irc.errorNoCapability(capabilities, Raise=True)
        topics = self._splitTopic(irc.state.getTopic(channel), channel)
        topic = topics.pop(number)
        self._sendTopics(irc, channel, topics)
    remove = wrap(remove, ['canChangeTopic', 'topicNumber'])

    @internationalizeDocstring
    def lock(self, irc, msg, args, channel):
        """[<channel>]

        Locks the topic (sets the mode +t) in <channel>.  <channel> is only
        necessary if the message isn't sent in the channel itself.
        """
        if not self._checkManageCapabilities(irc, msg, channel):
            capabilities = self.registryValue('requireManageCapability')
            irc.errorNoCapability(capabilities, Raise=True)
        irc.queueMsg(ircmsgs.mode(channel, '+t'))
        irc.noReply()
    lock = wrap(lock, ['channel', ('haveHalfop+', _('lock the topic'))])

    @internationalizeDocstring
    def unlock(self, irc, msg, args, channel):
        """[<channel>]

        Unlocks the topic (sets the mode -t) in <channel>.  <channel> is only
        necessary if the message isn't sent in the channel itself.
        """
        if not self._checkManageCapabilities(irc, msg, channel):
            capabilities = self.registryValue('requireManageCapability')
            irc.errorNoCapability(capabilities, Raise=True)
        irc.queueMsg(ircmsgs.mode(channel, '-t'))
        irc.noReply()
    unlock = wrap(unlock, ['channel', ('haveHalfop+', _('unlock the topic'))])

    @internationalizeDocstring
    def restore(self, irc, msg, args, channel):
        """[<channel>]

        Restores the topic to the last topic set by the bot.  <channel> is only
        necessary if the message isn't sent in the channel itself.
        """
        if not self._checkManageCapabilities(irc, msg, channel):
            capabilities = self.registryValue('requireManageCapability')
            irc.errorNoCapability(capabilities, Raise=True)
        try:
            topics = self.lastTopics[channel]
        except KeyError:
            irc.error(format(_('I haven\'t yet set the topic in %s.'),
                             channel))
            return
        self._sendTopics(irc, channel, topics)
    restore = wrap(restore, ['canChangeTopic'])

    @internationalizeDocstring
    def undo(self, irc, msg, args, channel):
        """[<channel>]

        Restores the topic to the one previous to the last topic command that
        set it.  <channel> is only necessary if the message isn't sent in the
        channel itself.
        """
        if not self._checkManageCapabilities(irc, msg, channel):
            capabilities = self.registryValue('requireManageCapability')
            irc.errorNoCapability(capabilities, Raise=True)
        self._addRedo(channel, self._getUndo(channel)) # current topic.
        topics = self._getUndo(channel) # This is the topic list we want.
        if topics is not None:
            self._sendTopics(irc, channel, topics, isDo=True)
        else:
            irc.error(format(_('There are no more undos for %s.'), channel))
    undo = wrap(undo, ['canChangetopic'])

    @internationalizeDocstring
    def redo(self, irc, msg, args, channel):
        """[<channel>]

        Undoes the last undo.  <channel> is only necessary if the message isn't
        sent in the channel itself.
        """
        if not self._checkManageCapabilities(irc, msg, channel):
            capabilities = self.registryValue('requireManageCapability')
            irc.errorNoCapability(capabilities, Raise=True)
        topics = self._getRedo(channel)
        if topics is not None:
            self._sendTopics(irc, channel, topics, isDo=True)
        else:
            irc.error(format(_('There are no redos for %s.'), channel))
    redo = wrap(redo, ['canChangeTopic'])

    @internationalizeDocstring
    def swap(self, irc, msg, args, channel, first, second):
        """[<channel>] <first topic number> <second topic number>

        Swaps the order of the first topic number and the second topic number.
        <channel> is only necessary if the message isn't sent in the channel
        itself.
        """
        if not self._checkManageCapabilities(irc, msg, channel):
            capabilities = self.registryValue('requireManageCapability')
            irc.errorNoCapability(capabilities, Raise=True)
        topics = self._splitTopic(irc.state.getTopic(channel), channel)
        if first == second:
            irc.error(_('I refuse to swap the same topic with itself.'))
            return
        t = topics[first]
        topics[first] = topics[second]
        topics[second] = t
        self._sendTopics(irc, channel, topics)
    swap = wrap(swap, ['canChangeTopic', 'topicNumber', 'topicNumber'])

    @internationalizeDocstring
    def save(self, irc, msg, args, channel):
        """[<channel>]

        Saves the topic in <channel> to be restored with @topic default
        later. <channel> is only necessary if the message isn't sent in
        the channel itself.
        """
        if not self._checkManageCapabilities(irc, msg, channel):
            capabilities = self.registryValue('requireManageCapability')
            irc.errorNoCapability(capabilities, Raise=True)
        topic = irc.state.getTopic(channel)
        if topic:
            self.setRegistryValue('default', value=topic, channel=channel)
        else:
            self.setRegistryValue('default', value='', channel=channel)
        irc.replySuccess()
    save = wrap(save, ['channel', 'inChannel'])

    @internationalizeDocstring
    def default(self, irc, msg, args, channel):
        """[<channel>]

        Sets the topic in <channel> to the default topic for <channel>.  The
        default topic for a channel may be configured via the configuration
        variable supybot.plugins.Topic.default.
        """
        if not self._checkManageCapabilities(irc, msg, channel):
            capabilities = self.registryValue('requireManageCapability')
            irc.errorNoCapability(capabilities, Raise=True)
        topic = self.registryValue('default', channel)
        if topic:
            self._sendTopics(irc, channel, [topic])
        else:
            irc.error(format(_('There is no default topic configured for %s.'),
                             channel))
    default = wrap(default, ['canChangeTopic'])

    @internationalizeDocstring
    def separator(self, irc, msg, args, channel, separator):
        """[<channel>] <separator>

        Sets the topic separator for <channel> to <separator>  Converts the
        current topic appropriately.
        """
        if not self._checkManageCapabilities(irc, msg, channel):
            capabilities = self.registryValue('requireManageCapability')
            irc.errorNoCapability(capabilities, Raise=True)
        topics = self._splitTopic(irc.state.getTopic(channel), channel)
        self.setRegistryValue('separator', separator, channel)
        self._sendTopics(irc, channel, topics)
    separator = wrap(separator, ['canChangeTopic', 'something'])

Class = Topic


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2002-2004, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

class TopicTestCase(ChannelPluginTestCase):
    plugins = ('Topic','User',)
    def testRemove(self):
        self.assertError('topic remove 1')
        _ = self.getMsg('topic add foo')
        _ = self.getMsg('topic add bar')
        _ = self.getMsg('topic add baz')
        self.assertError('topic remove 0')
        self.assertNotError('topic remove 3')
        self.assertNotError('topic remove 2')
        self.assertNotError('topic remove 1')
        self.assertError('topic remove 1')

    def testReplace(self):
        _ = self.getMsg('topic add foo')
        _ = self.getMsg('topic add bar')
        _ = self.getMsg('topic add baz')
        self.assertRegexp('topic replace 1 oof', 'oof.*bar.*baz')
        self.assertRegexp('topic replace -1 zab', 'oof.*bar.*zab')
        self.assertRegexp('topic replace 2 lorem ipsum',
                          'oof.*lorem ipsum.*zab')
        self.assertRegexp('topic replace 2 rab', 'oof.*rab.*zab')

    def testGet(self):
        self.assertError('topic get 1')
        _ = self.getMsg('topic add foo')
        _ = self.getMsg('topic add bar')
        _ = self.getMsg('topic add baz')
        self.assertRegexp('topic get 1', '^foo')
        self.assertError('topic get 0')

    def testAdd(self):
        self.assertError('topic add #floorgle')
        m = self.getMsg('topic add foo')
        self.assertEqual(m.command, 'TOPIC')
        self.assertEqual(m.args[0], self.channel)
        self.assertEqual(m.args[1], 'foo (test)')
        m = self.getMsg('topic add bar')
        self.assertEqual(m.command, 'TOPIC')
        self.assertEqual(m.args[0], self.channel)
        self.assertEqual(m.args[1], 'foo (test) || bar (test)')

    def testManageCapabilities(self):
        try:
            self.irc.feedMsg(ircmsgs.mode(self.channel, args=('+o', self.nick),
                                      prefix=self.prefix))
            self.irc.feedMsg(ircmsgs.mode(self.channel, args=('+t'),
                                      prefix=self.prefix))
            world.testing = False
            origuser = self.prefix
            self.prefix = 'stuff!stuff@stuff'
            self.assertNotError('register nottester stuff', private=True)

            self.assertError('topic add foo')
            origconf = conf.supybot.plugins.Topic.requireManageCapability()
            conf.supybot.plugins.Topic.requireManageCapability.setValue('')
            self.assertNotError('topic add foo')
        finally:
            world.testing = True
            self.prefix = origuser
            conf.supybot.plugins.Topic.requireManageCapability.setValue(origconf)

    def testInsert(self):
        m = self.getMsg('topic add foo')
        self.assertEqual(m.args[1], 'foo (test)')
        m = self.getMsg('topic insert bar')
        self.assertEqual(m.args[1], 'bar (test) || foo (test)')

    def testChange(self):
        _ = self.getMsg('topic add foo')
        _ = self.getMsg('topic add bar')
        _ = self.getMsg('topic add baz')
        self.assertRegexp('topic change -1 s/baz/biff/',
                          r'foo.*bar.*biff')
        self.assertRegexp('topic change 2 s/bar/baz/',
                          r'foo.*baz.*biff')
        self.assertRegexp('topic change 1 s/foo/bar/',
                          r'bar.*baz.*biff')
        self.assertRegexp('topic change -2 s/baz/bazz/',
                          r'bar.*bazz.*biff')
        self.assertError('topic change 0 s/baz/biff/')

    def testConfig(self):
        try:
            original = conf.supybot.plugins.Topic.separator()
            conf.supybot.plugins.Topic.separator.setValue(' <==> ')
            _ = self.getMsg('topic add foo')
            m = self.getMsg('topic add bar')
            self.failUnless('<==>' in m.args[1])
        finally:
            conf.supybot.plugins.Topic.separator.setValue(original)

    def testReorder(self):
        _ = self.getMsg('topic add foo')
        _ = self.getMsg('topic add bar')
        _ = self.getMsg('topic add baz')
        self.assertRegexp('topic reorder 2 1 3', r'bar.*foo.*baz')
        self.assertRegexp('topic reorder 3 -2 1', r'baz.*foo.*bar')
        self.assertError('topic reorder 0 1 2')
        self.assertError('topic reorder 1 -2 2')
        self.assertError('topic reorder 1 2')
        self.assertError('topic reorder 2 3 4')
        self.assertError('topic reorder 1 2 2')
        self.assertError('topic reorder 1 1 2 3')
        _ = self.getMsg('topic remove 1')
        _ = self.getMsg('topic remove 1')
        self.assertError('topic reorder 1')
        _ = self.getMsg('topic remove 1')
        self.assertError('topic reorder 0')

    def testList(self):
        _ = self.getMsg('topic add foo')
        self.assertRegexp('topic list', '1: foo')
        _ = self.getMsg('topic add bar')
        self.assertRegexp('topic list', '1: foo .*2: bar')
        _ = self.getMsg('topic add baz')
        self.assertRegexp('topic list', '1: foo .* 2: bar .* and 3: baz')

    def testSet(self):
        _ = self.getMsg('topic add foo')
        self.assertRegexp('topic set -1 bar', 'bar')
        self.assertNotRegexp('topic set -1 baz', 'bar')
        self.assertResponse('topic set foo bar baz', 'foo bar baz')
        # Catch a bug we had where setting topic 1 would reset the whole topic
        orig = conf.supybot.plugins.Topic.format()
        sep = conf.supybot.plugins.Topic.separator()
        try:
            conf.supybot.plugins.Topic.format.setValue('$topic')
            self.assertResponse('topic add baz', 'foo bar baz%sbaz' % sep)
            self.assertResponse('topic set 1 bar', 'bar%sbaz' % sep)
        finally:
            conf.supybot.plugins.Topic.format.setValue(orig)

    def testUndo(self):
        try:
            original = conf.supybot.plugins.Topic.format()
            conf.supybot.plugins.Topic.format.setValue('$topic')
            self.assertResponse('topic set ""', '')
            self.assertResponse('topic add foo', 'foo')
            self.assertResponse('topic add bar', 'foo || bar')
            self.assertResponse('topic add baz', 'foo || bar || baz')
            self.assertResponse('topic undo', 'foo || bar')
            self.assertResponse('topic undo', 'foo')
            self.assertResponse('topic undo', '')
        finally:
            conf.supybot.plugins.Topic.format.setValue(original)

    def testUndoRedo(self):
        try:
            original = conf.supybot.plugins.Topic.format()
            conf.supybot.plugins.Topic.format.setValue('$topic')
            self.assertResponse('topic set ""', '')
            self.assertResponse('topic add foo', 'foo')
            self.assertResponse('topic add bar', 'foo || bar')
            self.assertResponse('topic add baz', 'foo || bar || baz')
            self.assertResponse('topic undo', 'foo || bar')
            self.assertResponse('topic undo', 'foo')
            self.assertResponse('topic undo', '')
            self.assertResponse('topic redo', 'foo')
            self.assertResponse('topic redo', 'foo || bar')
            self.assertResponse('topic redo', 'foo || bar || baz')
            self.assertResponse('topic undo', 'foo || bar')
            self.assertResponse('topic undo', 'foo')
            self.assertResponse('topic redo', 'foo || bar')
            self.assertResponse('topic undo', 'foo')
            self.assertResponse('topic redo', 'foo || bar')
        finally:
            conf.supybot.plugins.Topic.format.setValue(original)

    def testSwap(self):
        original = conf.supybot.plugins.Topic.format()
        try:
            conf.supybot.plugins.Topic.format.setValue('$topic')
            self.assertResponse('topic set ""', '')
            self.assertResponse('topic add foo', 'foo')
            self.assertResponse('topic add bar', 'foo || bar')
            self.assertResponse('topic add baz', 'foo || bar || baz')
            self.assertResponse('topic swap 1 2', 'bar || foo || baz')
            self.assertResponse('topic swap 1 -1', 'baz || foo || bar')
            self.assertError('topic swap -1 -1')
            self.assertError('topic swap 2 -2')
            self.assertError('topic swap 1 -3')
            self.assertError('topic swap -2 2')
            self.assertError('topic swap -3 1')
        finally:
            conf.supybot.plugins.Topic.format.setValue(original)

    def testDefault(self):
        self.assertError('topic default')
        try:
            original = conf.supybot.plugins.Topic.default()
            conf.supybot.plugins.Topic.default.setValue('foo bar baz')
            self.assertResponse('topic default', 'foo bar baz')
        finally:
            conf.supybot.plugins.Topic.default.setValue(original)


    def testTopic(self):
        original = conf.supybot.plugins.Topic.format()
        try:
            conf.supybot.plugins.Topic.format.setValue('$topic')
            self.assertError('topic addd') # Error to send too many args.
            self.assertResponse('topic add foo', 'foo')
            self.assertResponse('topic add bar', 'foo || bar')
            self.assertResponse('topic', 'foo || bar')
        finally:
            conf.supybot.plugins.Topic.format.setValue(original)

    def testSeparator(self):
        original = conf.supybot.plugins.Topic.format()
        try:
            conf.supybot.plugins.Topic.format.setValue('$topic')
            self.assertResponse('topic add foo', 'foo')
            self.assertResponse('topic add bar', 'foo || bar')
            self.assertResponse('topic add baz', 'foo || bar || baz')
            self.assertResponse('topic separator |', 'foo | bar | baz')
            self.assertResponse('topic separator ::', 'foo :: bar :: baz')
            self.assertResponse('topic separator ||', 'foo || bar || baz')
        finally:
            conf.supybot.plugins.Topic.format.setValue(original)

    def testFit(self):
        original = conf.supybot.plugins.Topic.format()
        try:
            conf.supybot.plugins.Topic.format.setValue('$topic')
            self.irc.state.supported['TOPICLEN'] = 20
            self.assertResponse('topic fit foo', 'foo')
            self.assertResponse('topic fit bar', 'foo || bar')
            self.assertResponse('topic fit baz', 'foo || bar || baz')
            self.assertResponse('topic fit qux', 'bar || baz || qux')
        finally:
            conf.supybot.plugins.Topic.format.setValue(original)
            self.irc.state.supported.pop('TOPICLEN', None)


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:


########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.utils as utils
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Unix')

import plugin

progstats = plugin.progstats

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import output, expect, anything, something, yn
    conf.registerPlugin('Unix', True)
    output(_("""The "progstats" command can reveal potentially sensitive
              information about your machine. Here's an example of its output:

              %s\n""") % progstats())
    if yn(_('Would you like to disable this command for non-owner users?'),
          default=True):
        conf.supybot.commands.disabled().add('Unix.progstats')


Unix = conf.registerPlugin('Unix')
conf.registerGroup(Unix, 'fortune')
conf.registerGlobalValue(Unix.fortune, 'command',
    registry.String(utils.findBinaryInPath('fortune') or '', _("""Determines
    what command will be called for the fortune command.""")))
conf.registerChannelValue(Unix.fortune, 'short',
    registry.Boolean(True, _("""Determines whether only short fortunes will be
    used if possible.  This sends the -s option to the fortune program.""")))
conf.registerGlobalValue(Unix.fortune, 'equal',
    registry.Boolean(True, _("""Determines whether fortune will give equal
    weight to the different fortune databases.  If false, then larger
    databases will be given more weight.  This sends the -e option to the
    fortune program.""")))
conf.registerChannelValue(Unix.fortune, 'offensive',
    registry.Boolean(False, _("""Determines whether fortune will retrieve
    offensive fortunes along with the normal fortunes.  This sends the -a
    option to the fortune program.""")))
conf.registerGlobalValue(Unix.fortune, 'files',
    registry.SpaceSeparatedListOfStrings([], _("""Determines what specific file
    (if any) will be used with the fortune command; if none is given, the
    system-wide default will be used.  Do note that this fortune file must be
    placed with the rest of your system's fortune files.""")))

conf.registerGroup(Unix, 'spell')
conf.registerGlobalValue(Unix.spell, 'command',
    registry.String(utils.findBinaryInPath('aspell') or
                    utils.findBinaryInPath('ispell') or '', _("""Determines
    what command will be called for the spell command.""")))
conf.registerGlobalValue(Unix.spell, 'language',
    registry.String('en', _("""Determines what aspell dictionary will be used
    for spell checking.""")))

conf.registerGroup(Unix, 'wtf')
conf.registerGlobalValue(Unix.wtf, 'command',
    registry.String(utils.findBinaryInPath('wtf') or '', _("""Determines what
    command will be called for the wtf command.""")))

conf.registerGroup(Unix, 'ping')
conf.registerGlobalValue(Unix.ping, 'command', 
    registry.String(utils.findBinaryInPath('ping') or '', """Determines what 
    command will be called for the ping command."""))

conf.registerGroup(Unix, 'sysuptime')
conf.registerGlobalValue(Unix.sysuptime, 'command',
    registry.String(utils.findBinaryInPath('uptime') or '', """Determines what
    command will be called for the uptime command."""))

conf.registerGroup(Unix, 'sysuname')
conf.registerGlobalValue(Unix.sysuname, 'command',
    registry.String(utils.findBinaryInPath('uname') or '', """Determines what
    command will be called for the uname command."""))

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# Copyright (c) 2008-2010, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import os
import re
import pwd
import sys
import crypt
import errno
import random
import select
import struct
import subprocess
import shlex

import supybot.utils as utils
from supybot.commands import *
import supybot.plugins as plugins
import supybot.ircutils as ircutils
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Unix')

_progstats_endline_remover = utils.str.MultipleRemover('\r\n')
def progstats():
    pw = pwd.getpwuid(os.getuid())
    response = format('Process ID %i running as user %q and as group %q '
                      'from directory %q with the command line %q.  '
                      'Running on Python %s.',
                      os.getpid(), pw[0], pw[3],
                      os.getcwd(), ' '.join(sys.argv),
                      _progstats_endline_remover(sys.version))
    return response

class TimeoutError(IOError):
    pass

def pipeReadline(fd, timeout=2):
    (r, _, _) = select.select([fd], [], [], timeout)
    if r:
        return r[0].readline()
    else:
        raise TimeoutError

class Unix(callbacks.Plugin):
    threaded = True
    @internationalizeDocstring
    def errno(self, irc, msg, args, s):
        """<error number or code>

        Returns the number of an errno code, or the errno code of a number.
        """
        try:
            i = int(s)
            name = errno.errorcode[i]
        except ValueError:
            name = s.upper()
            try:
                i = getattr(errno, name)
            except AttributeError:
                irc.reply(_('I can\'t find the errno number for that code.'))
                return
        except KeyError:
            name = _('(unknown)')
        irc.reply(format(_('%s (#%i): %s'), name, i, os.strerror(i)))
    errno = wrap(errno, ['something'])

    @internationalizeDocstring
    def progstats(self, irc, msg, args):
        """takes no arguments

        Returns various unix-y information on the running supybot process.
        """
        irc.reply(progstats())

    @internationalizeDocstring
    def pid(self, irc, msg, args):
        """takes no arguments

        Returns the current pid of the process for this Supybot.
        """
        irc.reply(format('%i', os.getpid()), private=True)
    pid = wrap(pid, [('checkCapability', 'owner')])

    _cryptre = re.compile(b'[./0-9A-Za-z]')
    @internationalizeDocstring
    def crypt(self, irc, msg, args, password, salt):
        """<password> [<salt>]

        Returns the resulting of doing a crypt() on <password>.  If <salt> is
        not given, uses a random salt.  If running on a glibc2 system,
        prepending '$1$' to your salt will cause crypt to return an MD5sum
        based crypt rather than the standard DES based crypt.
        """
        def makeSalt():
            s = b'\x00'
            while self._cryptre.sub(b'', s) != b'':
                s = struct.pack('<h', random.randrange(-(2**15), 2**15))
            return s
        if not salt:
            salt = makeSalt().decode()
        irc.reply(crypt.crypt(password, salt))
    crypt = wrap(crypt, ['something', additional('something')])

    @internationalizeDocstring
    def spell(self, irc, msg, args, word):
        """<word>

        Returns the result of passing <word> to aspell/ispell.  The results
        shown are sorted from best to worst in terms of being a likely match
        for the spelling of <word>.
        """
        # We are only checking the first word
        spellCmd = self.registryValue('spell.command')
        if not spellCmd:
           irc.error(_('The spell checking command is not configured.  If one '
                     'is installed, reconfigure '
                     'supybot.plugins.Unix.spell.command appropriately.'),
                     Raise=True)
        spellLang = self.registryValue('spell.language') or 'en'
        if word and not word[0].isalpha():
            irc.error(_('<word> must begin with an alphabet character.'))
            return
        try:
            inst = subprocess.Popen([spellCmd, '-l', spellLang, '-a'], close_fds=True,
                                    stdout=subprocess.PIPE,
                                    stderr=subprocess.PIPE,
                                    stdin=subprocess.PIPE)
        except OSError as e:
            irc.error(e, Raise=True)
        ret = inst.poll()
        if ret is not None:
            s = inst.stderr.readline().decode('utf8')
            if not s:
                s = inst.stdout.readline().decode('utf8')
            s = s.rstrip('\r\n')
            s = s.lstrip('Error: ')
            irc.error(s, Raise=True)
        (out, err) = inst.communicate(word.encode())
        inst.wait()
        lines = [x.decode('utf8') for x in out.splitlines() if x]
        lines.pop(0) # Banner
        if not lines:
            irc.error(_('No results found.'), Raise=True)
        line = lines.pop(0)
        line2 = ''
        if lines:
            line2 = lines.pop(0)
        # parse the output
        # aspell will sometimes list spelling suggestions after a '*' or '+'
        # line for complex words.
        if line[0] in '*+' and line2:
            line = line2
        if line[0] in '*+':
            resp = format(_('%q may be spelled correctly.'), word)
        elif line[0] == '#':
            resp = format(_('I could not find an alternate spelling for %q'),
                          word)
        elif line[0] == '&':
            matches = line.split(':')[1].strip()
            resp = format(_('Possible spellings for %q: %L.'),
                          word, matches.split(', '))
        else:
            resp = _('Something unexpected was seen in the [ai]spell output.')
        irc.reply(resp)
    spell = thread(wrap(spell, ['something']))

    @internationalizeDocstring
    def fortune(self, irc, msg, args):
        """takes no arguments

        Returns a fortune from the *nix fortune program.
        """
        channel = msg.args[0]
        fortuneCmd = self.registryValue('fortune.command')
        if fortuneCmd:
            args = [fortuneCmd]
            if self.registryValue('fortune.short', channel):
                args.append('-s')
            if self.registryValue('fortune.equal'):
                args.append('-e')
            if self.registryValue('fortune.offensive', channel):
                args.append('-a')
            args.extend(self.registryValue('fortune.files'))
            try:
                with open(os.devnull) as null:
                    inst = subprocess.Popen(args,
                                            stdout=subprocess.PIPE,
                                            stderr=subprocess.PIPE,
                                            stdin=null)
            except OSError as e:
                irc.error(_('It seems the configured fortune command was '
                          'not available.'), Raise=True)
            (out, err) = inst.communicate()
            inst.wait()
            lines = out.splitlines()
            lines = list(map(str.rstrip, lines))
            lines = filter(None, lines)
            irc.replies(lines, joiner=' ')
        else:
            irc.error(_('The fortune command is not configured. If fortune is '
                      'installed on this system, reconfigure the '
                      'supybot.plugins.Unix.fortune.command configuration '
                      'variable appropriately.'))

    @internationalizeDocstring
    def wtf(self, irc, msg, args, foo, something):
        """[is] <something>

        Returns wtf <something> is.  'wtf' is a *nix command that first
        appeared in NetBSD 1.5.  In most *nices, it's available in some sort
        of 'bsdgames' package.
        """
        wtfCmd = self.registryValue('wtf.command')
        if wtfCmd:
            something = something.rstrip('?')
            try:
                with open(os.devnull, 'r+') as null:
                    inst = subprocess.Popen([wtfCmd, something],
                                            stdout=subprocess.PIPE,
                                            stderr=subprocess.STDOUT,
                                            stdin=null)
            except OSError:
                irc.error(_('It seems the configured wtf command was not '
                          'available.'), Raise=True)
            (out, foo) = inst.communicate()
            inst.wait()
            if out:
                response = out.decode('utf8').splitlines()[0].strip()
                response = utils.str.normalizeWhitespace(response)
                irc.reply(response)
        else:
            irc.error(_('The wtf command is not configured.  If it is installed '
                      'on this system, reconfigure the '
                      'supybot.plugins.Unix.wtf.command configuration '
                      'variable appropriately.'))
    wtf = thread(wrap(wtf, [optional(('literal', ['is'])), 'something']))

    @internationalizeDocstring
    def ping(self, irc, msg, args, optlist, host):
        """[--c <count>] [--i <interval>] [--t <ttl>] [--W <timeout>] <host or ip>
        Sends an ICMP echo request to the specified host.
        The arguments correspond with those listed in ping(8). --c is
        limited to 10 packets or less (default is 5). --i is limited to 5
        or less. --W is limited to 10 or less.
        """
        pingCmd = self.registryValue('ping.command')
        if not pingCmd:
           irc.error('The ping command is not configured.  If one '
                     'is installed, reconfigure '
                     'supybot.plugins.Unix.ping.command appropriately.',
                     Raise=True)
        else:
            try: host = host.group(0)
            except AttributeError: pass

            args = [pingCmd]
            for opt, val in optlist:
                if opt == 'c' and val > 10: val = 10
                if opt == 'i' and val >  5: val = 5
                if opt == 'W' and val > 10: val = 10
                args.append('-%s' % opt)
                args.append(str(val))
            if '-c' not in args:
                args.append('-c')
                args.append('5')
            args.append(host)
            try:
                with open(os.devnull) as null:
                    inst = subprocess.Popen(args,
                                            stdout=subprocess.PIPE,
                                            stderr=subprocess.PIPE,
                                            stdin=null)
            except OSError as e:
                irc.error('It seems the configured ping command was '
                          'not available (%s).' % e, Raise=True)
            result = inst.communicate()
            if result[1]: # stderr
                irc.error(' '.join(result[1].decode('utf8').split()))
            else:
                response = result[0].decode('utf8').split("\n");
                if response[1]:
                    irc.reply(' '.join(response[1].split()[3:5]).split(':')[0]
                              + ': ' + ' '.join(response[-3:]))
                else:
                    irc.reply(' '.join(response[0].split()[1:3])
                              + ': ' + ' '.join(response[-3:]))

    _hostExpr = re.compile(r'^[a-z0-9][a-z0-9\.-]*[a-z0-9]$', re.I)
    ping = thread(wrap(ping, [getopts({'c':'positiveInt','i':'float',
                                't':'positiveInt','W':'positiveInt'}),
                       first('ip', ('matches', _hostExpr, 'Invalid hostname'))]))

    def sysuptime(self, irc, msg, args):
        """takes no arguments

        Returns the uptime from the system the bot is runnning on.
        """
        uptimeCmd = self.registryValue('sysuptime.command')
        if uptimeCmd:
            args = [uptimeCmd]
            try:
                with open(os.devnull) as null:
                    inst = subprocess.Popen(args,
                                            stdout=subprocess.PIPE,
                                            stderr=subprocess.PIPE,
                                            stdin=null)
            except OSError as e:
                irc.error('It seems the configured uptime command was '
                          'not available.', Raise=True)
            (out, err) = inst.communicate()
            inst.wait()
            lines = out.splitlines()
            lines = [x.decode('utf8').rstrip() for x in lines]
            lines = filter(None, lines)
            irc.replies(lines, joiner=' ')
        else:
            irc.error('The uptime command is not configured. If uptime is '
                      'installed on this system, reconfigure the '
                      'supybot.plugins.Unix.sysuptime.command configuration '
                      'variable appropriately.')

    def sysuname(self, irc, msg, args):
        """takes no arguments

        Returns the uname -a from the system the bot is runnning on.
        """
        unameCmd = self.registryValue('sysuname.command')
        if unameCmd:
            args = [unameCmd, '-a']
            try:
                with open(os.devnull) as null:
                    inst = subprocess.Popen(args,
                                            stdout=subprocess.PIPE,
                                            stderr=subprocess.PIPE,
                                            stdin=null)
            except OSError as e:
                irc.error('It seems the configured uptime command was '
                          'not available.', Raise=True)
            (out, err) = inst.communicate()
            inst.wait()
            lines = out.splitlines()
            lines = [x.decode('utf8').rstrip() for x in lines]
            lines = filter(None, lines)
            irc.replies(lines, joiner=' ')
        else:
            irc.error('The uname command is not configured. If uname is '
                      'installed on this system, reconfigure the '
                      'supybot.plugins.Unix.sysuname.command configuration '
                      'variable appropriately.')

    def call(self, irc, msg, args, text):
        """<command to call with any arguments>
        Calls any command available on the system, and returns its output.
        Requires owner capability.
        Note that being restricted to owner, this command does not do any
        sanity checking on input/output. So it is up to you to make sure
        you don't run anything that will spamify your channel or that
        will bring your machine to its knees.
        """
        args = shlex.split(text)
        try:
            with open(os.devnull) as null:
                inst = subprocess.Popen(args,
                                        stdout=subprocess.PIPE,
                                        stderr=subprocess.PIPE,
                                        stdin=null)
        except OSError as e:
            irc.error('It seems the requested command was '
                      'not available (%s).' % e, Raise=True)
        result = inst.communicate()
        if result[1]: # stderr
            irc.error(' '.join(result[1].decode('utf8').split()))
        if result[0]: # stdout
            response = result[0].decode('utf8').splitlines()
            response = [l for l in response if l]
            irc.replies(response)
    call = thread(wrap(call, ["owner", "text"]))

    def shell(self, irc, msg, args, text):
        """<command to call with any arguments>
        Calls any command available on the system using the shell
        specified by the SHELL environment variable, and returns its
        output.
        Requires owner capability.
        Note that being restricted to owner, this command does not do any
        sanity checking on input/output. So it is up to you to make sure
        you don't run anything that will spamify your channel or that
        will bring your machine to its knees.
        """
        try:
            with open(os.devnull) as null:
                inst = subprocess.Popen(text,
                                        shell=True,
                                        stdout=subprocess.PIPE,
                                        stderr=subprocess.PIPE,
                                        stdin=null)
        except OSError as e:
            irc.error('It seems the shell (%s) was not available (%s)' %
                      (os.getenv('SHELL'), e), Raise=True)
        result = inst.communicate()
        if result[1]: # stderr
            irc.error(' '.join(result[1].decode('utf8').split()))
        if result[0]: # stdout
            response = result[0].decode('utf8').splitlines()
            response = [l for l in response if l]
            irc.replies(response)
    shell = thread(wrap(shell, ["owner", "text"]))


Class = Unix
# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import os

from supybot.test import *

if os.name == 'posix':
    class UnixTestCase(PluginTestCase):
        plugins = ('Unix',)
        if utils.findBinaryInPath('aspell') is not None or \
           utils.findBinaryInPath('ispell') is not None:
            def testSpell(self):
                self.assertRegexp('spell Strike',
                                  '(correctly|Possible spellings)')
                # ispell won't find any results.  aspell will make some
                # suggestions.
                self.assertRegexp('spell z0opadfnaf83nflafl230kasdf023hflasdf',
                                  'not find|Possible spellings')
                self.assertNotError('spell Strizzike')
                self.assertError('spell foo bar baz')
                self.assertError('spell -')
                self.assertError('spell .')
                self.assertError('spell ?')
                self.assertNotError('spell whereever')
                self.assertNotRegexp('spell foo', 'whatever')

        def testErrno(self):
            self.assertRegexp('errno 12', '^ENOMEM')
            self.assertRegexp('errno ENOMEM', '#12')

        def testProgstats(self):
            self.assertNotError('progstats')

        def testCrypt(self):
            self.assertNotError('crypt jemfinch')

        if utils.findBinaryInPath('fortune') is not None:
            def testFortune(self):
                self.assertNotError('fortune')

        if utils.findBinaryInPath('ping') is not None:
            def testPing(self):
                self.assertNotError('unix ping 127.0.0.1')
                self.assertError('unix ping')
                self.assertError('unix ping -localhost')
                self.assertError('unix ping local%host')
            def testPingCount(self):
                self.assertNotError('unix ping --c 1 127.0.0.1')
                self.assertError('unix ping --c a 127.0.0.1')
                self.assertRegexp('unix ping --c 11 127.0.0.1','10 packets')
                self.assertRegexp('unix ping 127.0.0.1','5 packets')
            def testPingInterval(self):
                self.assertNotError('unix ping --i 1 --c 1 127.0.0.1')
                self.assertError('unix ping --i a --c 1 127.0.0.1')
                # Super-user privileged interval setting
                self.assertError('unix ping --i 0.1 --c 1 127.0.0.1') 
            def testPingTtl(self):
                self.assertNotError('unix ping --t 64 --c 1 127.0.0.1')
                self.assertError('unix ping --t a --c 1 127.0.0.1')
            def testPingWait(self):
                self.assertNotError('unix ping --W 1 --c 1 127.0.0.1')
                self.assertError('unix ping --W a --c 1 127.0.0.1')

        def testCall(self):
            self.assertNotError('unix call /bin/ping -c 1 localhost')
            self.assertRegexp('unix call /bin/ping -c 1 localhost', 'ping statistics')
            self.assertError('unix call /usr/bin/nosuchcommandaoeuaoeu')

        def testUptime(self):
            self.assertNotError('unix sysuptime')

        def testUname(self):
            self.assertNotError('unix sysuname')
# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('URL')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('URL', True)

URL = conf.registerPlugin('URL')
conf.registerChannelValue(URL, 'nonSnarfingRegexp',
    registry.Regexp(None, _("""Determines what URLs are not to be snarfed and
    stored in the database for the channel; URLs matching the given regexp will
    not be snarfed.  Give the empty string if you have no URLs that you'd like
    to exclude from being snarfed.""")))


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2002-2004, Jeremiah Fincher
# Copyright (c) 2010, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.dbi as dbi
import supybot.conf as conf
import supybot.utils as utils
from supybot.commands import *
import supybot.plugins as plugins
import supybot.ircmsgs as ircmsgs
import supybot.ircutils as ircutils
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('URL')

class UrlRecord(dbi.Record):
    __fields__ = [
        ('url', eval),
        ('by', eval),
        ('near', eval),
        ('at', eval),
        ]

class DbiUrlDB(plugins.DbiChannelDB):
    class DB(dbi.DB):
        Record = UrlRecord
        def add(self, url, msg):
            record = self.Record(url=url, by=msg.nick,
                                 near=msg.args[1], at=msg.receivedAt)
            super(self.__class__, self).add(record)
        def urls(self, p):
            L = list(self.select(p))
            L.reverse()
            return L

URLDB = plugins.DB('URL', {'flat': DbiUrlDB})

class URL(callbacks.Plugin):
    def __init__(self, irc):
        self.__parent = super(URL, self)
        self.__parent.__init__(irc)
        self.db = URLDB()

    def doPrivmsg(self, irc, msg):
        if ircmsgs.isCtcp(msg) and not ircmsgs.isAction(msg):
            return
        channel = msg.args[0]
        if irc.isChannel(channel):
            if ircmsgs.isAction(msg):
                text = ircmsgs.unAction(msg)
            else:
                text = msg.args[1]
            for url in utils.web.urlRe.findall(text):
                r = self.registryValue('nonSnarfingRegexp', channel)
                if r and r.search(url):
                    self.log.debug('Skipping adding %u to db.', url)
                    continue
                self.log.debug('Adding %u to db.', url)
                self.db.add(channel, url, msg)

    @internationalizeDocstring
    def stats(self, irc, msg, args, channel):
        """[<channel>]

        Returns the number of URLs in the URL database.  <channel> is only
        required if the message isn't sent in the channel itself.
        """
        self.db.vacuum(channel)
        count = self.db.size(channel)
        irc.reply(format(_('I have %n in my database.'), (count, 'URL')))
    stats = wrap(stats, ['channeldb'])

    @internationalizeDocstring
    def last(self, irc, msg, args, channel, optlist):
        """[<channel>] [--{from,with,without,near,proto} <value>] [--nolimit]

        Gives the last URL matching the given criteria.  --from is from whom
        the URL came; --proto is the protocol the URL used; --with is something
        inside the URL; --without is something that should not be in the URL;
        --near is something in the same message as the URL.  If --nolimit is
        given, returns all the URLs that are found to just the URL.
        <channel> is only necessary if the message isn't sent in the channel
        itself.
        """
        predicates = []
        f = None
        nolimit = False
        for (option, arg) in optlist:
            if isinstance(arg, basestring):
                arg = arg.lower()
            if option == 'nolimit':
                nolimit = True
            elif option == 'from':
                def f(record, arg=arg):
                    return ircutils.strEqual(record.by, arg)
            elif option == 'with':
                def f(record, arg=arg):
                    return arg in record.url.lower()
            elif option == 'without':
                def f(record, arg=arg):
                    return arg not in record.url.lower()
            elif option == 'proto':
                def f(record, arg=arg):
                    return record.url.lower().startswith(arg)
            elif option == 'near':
                def f(record, arg=arg):
                    return arg in record.near.lower()
            if f is not None:
                predicates.append(f)
        def predicate(record):
            for predicate in predicates:
                if not predicate(record):
                    return False
            return True
        urls = [record.url for record in self.db.urls(channel, predicate)]
        if not urls:
            irc.reply(_('No URLs matched that criteria.'))
        else:
            if nolimit:
                urls = [format('%u', url) for url in urls]
                s = ', '.join(urls)
            else:
                # We should optimize this with another URLDB method eventually.
                s = urls[0]
            irc.reply(s)
    last = wrap(last, ['channeldb',
                       getopts({'from': 'something', 'with': 'something',
                                'near': 'something', 'proto': 'something',
                                'nolimit': '', 'without': 'something',})])

Class = URL

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2002-2004, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

urls = """
http://www.ureg.ohio-state.edu/courses/book3.asp
http://wwwsearch.sourceforge.net/ClientForm/
http://slashdot.org/comments.pl?sid=75443&cid=6747654
http://baseball-almanac.com/rb_menu.shtml
http://www.linuxquestions.org/questions/showthread.php?postid=442905#post442905
http://games.slashdot.org/comments.pl?sid=76027&cid=6785588'
http://games.slashdot.org/comments.pl?sid=76027&cid=6785588
http://www.census.gov/ftp/pub/tiger/tms/gazetteer/zcta5.zip
http://slashdot.org/~Strike
http://lambda.weblogs.com/xml/rss.xml'
http://lambda.weblogs.com/xml/rss.xml
http://www.sourcereview.net/forum/index.php?showforum=8
http://www.sourcereview.net/forum/index.php?showtopic=291
http://www.sourcereview.net/forum/index.php?showtopic=291&st=0&#entry1778
http://dhcp065-024-059-168.columbus.rr.com:81/~jfincher/old-supybot.tar.gz
http://www.sourcereview.net/forum/index.php?
http://www.joelonsoftware.com/articles/BuildingCommunitieswithSo.html
http://gameknot.com/stats.pl?ddipaolo
http://slashdot.org/slashdot.rss
http://gameknot.com/chess.pl?bd=1038943
http://codecentral.sleepwalkers.org/
http://gameknot.com/chess.pl?bd=1037471&r=327
http://dhcp065-024-059-168.columbus.rr.com:81/~jfincher/angryman.py
https://sourceforge.net/projects/pyrelaychecker/
http://gameknot.com/tsignup.pl
""".strip().splitlines()

class URLTestCase(ChannelPluginTestCase):
    plugins = ('URL',)
    def test(self):
        counter = 0
        #self.assertNotError('url random')
        for url in urls:
            self.assertRegexp('url stats', str(counter))
            self.feedMsg(url)
            counter += 1
        self.assertRegexp('url stats', str(counter))
        self.assertRegexp('url last', re.escape(urls[-1]))
        self.assertRegexp('url last --proto https', re.escape(urls[-2]))
        self.assertRegexp('url last --with gameknot.com',
                          re.escape(urls[-1]))
        self.assertRegexp('url last --with dhcp', re.escape(urls[-3]))
        self.assertRegexp('url last --from alsdkjf', '^No')
        self.assertRegexp('url last --without game', 'sourceforge')
        #self.assertNotError('url random')

    def testDefaultNotFancy(self):
        self.feedMsg(urls[0])
        self.assertResponse('url last', urls[0])

    def testAction(self):
        self.irc.feedMsg(ircmsgs.action(self.channel, urls[1]))
        self.assertNotRegexp('url last', '\\x01')

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:


########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2004-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###


import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('User')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('User', True)


User = conf.registerPlugin('User')
# This is where your configuration variables (if any) should go.  For example:
# conf.registerGlobalValue(User, 'someConfigVariableName',
#     registry.Boolean(False, """Help for someConfigVariableName."""))

conf.registerGroup(User, 'gpg')

conf.registerGlobalValue(User.gpg, 'enable',
    registry.Boolean(True, """Determines whether or not users are
    allowed to use GPG for authentication."""))
conf.registerGlobalValue(User.gpg, 'TokenTimeout',
    registry.PositiveInteger(60*10, """Determines the lifetime of a GPG
    authentication token (in seconds)."""))

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import re
import sys
import uuid
import time
import fnmatch

import supybot.conf as conf
import supybot.gpg as gpg
import supybot.utils as utils
import supybot.ircdb as ircdb
from supybot.commands import *
import supybot.ircutils as ircutils
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('User')

class User(callbacks.Plugin):
    def _checkNotChannel(self, irc, msg, password=' '):
        if password and irc.isChannel(msg.args[0]):
            raise callbacks.Error(conf.supybot.replies.requiresPrivacy())

    @internationalizeDocstring
    def list(self, irc, msg, args, optlist, glob):
        """[--capability=<capability>] [<glob>]

        Returns the valid registered usernames matching <glob>.  If <glob> is
        not given, returns all registered usernames.
        """
        predicates = []
        for (option, arg) in optlist:
            if option == 'capability':
                if arg in conf.supybot.capabilities.private():
                    try:
                        u = ircdb.users.getUser(msg.prefix)
                        if not u._checkCapability('admin'):
                            raise KeyError
                    except KeyError:
                        # Note that it may be raised by checkCapability too.
                        irc.error(_('This is a private capability. Only admins '
                            'can see who has it.'), Raise=True)
                def p(u, cap=arg):
                    try:
                        return u._checkCapability(cap)
                    except KeyError:
                        return False
                predicates.append(p)
        if glob:
            r = re.compile(fnmatch.translate(glob), re.I)
            def p(u):
                return r.match(u.name) is not None
            predicates.append(p)
        users = []
        for u in ircdb.users.itervalues():
            for predicate in predicates:
                if not predicate(u):
                    break
            else:
                users.append(u.name)
        if users:
            utils.sortBy(str.lower, users)
            irc.reply(format('%L', users))
        else:
            if predicates:
                irc.reply(_('There are no matching registered users.'))
            else:
                irc.reply(_('There are no registered users.'))
    list = wrap(list, [getopts({'capability':'capability'}),
                       additional('glob')])

    @internationalizeDocstring
    def register(self, irc, msg, args, name, password):
        """<name> <password>

        Registers <name> with the given password <password> and the current
        hostmask of the person registering.  You shouldn't register twice; if
        you're not recognized as a user but you've already registered, use the
        hostmask add command to add another hostmask to your already-registered
        user, or use the identify command to identify just for a session.
        This command (and all other commands that include a password) must be
        sent to the bot privately, not in a channel.
        """
        addHostmask = True
        try:
            ircdb.users.getUserId(name)
            irc.error(_('That name is already assigned to someone.'),
                      Raise=True)
        except KeyError:
            pass
        if ircutils.isUserHostmask(name):
            irc.errorInvalid(_('username'), name,
                             _('Hostmasks are not valid usernames.'),
                             Raise=True)
        try:
            u = ircdb.users.getUser(msg.prefix)
            if u._checkCapability('owner'):
                addHostmask = False
            else:
                irc.error(_('Your hostmask is already registered to %s') % 
                          u.name)
                return
        except KeyError:
            pass
        user = ircdb.users.newUser()
        user.name = name
        user.setPassword(password)
        if addHostmask:
            user.addHostmask(msg.prefix)
        ircdb.users.setUser(user)
        irc.replySuccess()
    register = wrap(register, ['private', 'something', 'something'])

    @internationalizeDocstring
    def unregister(self, irc, msg, args, user, password):
        """<name> [<password>]

        Unregisters <name> from the user database.  If the user giving this
        command is an owner user, the password is not necessary.
        """
        try:
            caller = ircdb.users.getUser(msg.prefix)
            isOwner = caller._checkCapability('owner')
        except KeyError:
            caller = None
            isOwner = False
        if not conf.supybot.databases.users.allowUnregistration():
            if not caller or not isOwner:
                self.log.warning('%s tried to unregister user %s.',
                                 msg.prefix, user.name)
                irc.error(_('This command has been disabled.  You\'ll have to '
                          'ask the owner of this bot to unregister your '
                          'user.'), Raise=True)
        if isOwner or user.checkPassword(password):
            ircdb.users.delUser(user.id)
            irc.replySuccess()
        else:
            irc.error(conf.supybot.replies.incorrectAuthentication())
    unregister = wrap(unregister, ['private', 'otherUser',
                                   additional('anything')])

    @internationalizeDocstring
    def changename(self, irc, msg, args, user, newname, password):
        """<name> <new name> [<password>]

        Changes your current user database name to the new name given.
        <password> is only necessary if the user isn't recognized by hostmask.
        This message must be sent to the bot privately (not on a channel) since
        it may contain a password.
        """
        try:
            id = ircdb.users.getUserId(newname)
            irc.error(format(_('%q is already registered.'), newname))
            return
        except KeyError:
            pass
        if user.checkHostmask(msg.prefix) or user.checkPassword(password):
            user.name = newname
            ircdb.users.setUser(user)
            irc.replySuccess()
    changename = wrap(changename, ['private', 'otherUser', 'something',
                                   additional('something', '')])

    class set(callbacks.Commands):
        @internationalizeDocstring
        def password(self, irc, msg, args, user, password, newpassword):
            """[<name>] <old password> <new password>

            Sets the new password for the user specified by <name> to <new
            password>.  Obviously this message must be sent to the bot
            privately (not in a channel). If the requesting user is an owner
            user (and the user whose password is being changed isn't that same
            owner user), then <old password> needn't be correct.
            """
            try:
                u = ircdb.users.getUser(msg.prefix)
            except KeyError:
                u = None
            if user is None:
                if u is None:
                    irc.errorNotRegistered(Raise=True)
                user = u
            if user.checkPassword(password) or \
               (u and u._checkCapability('owner') and not u == user):
                user.setPassword(newpassword)
                ircdb.users.setUser(user)
                irc.replySuccess()
            else:
                irc.error(conf.supybot.replies.incorrectAuthentication())
        password = wrap(password, ['private', optional('otherUser'),
                                   'something', 'something'])

        @internationalizeDocstring
        def secure(self, irc, msg, args, user, password, value):
            """<password> [<True|False>]

            Sets the secure flag on the user of the person sending the message.
            Requires that the person's hostmask be in the list of hostmasks for
            that user in addition to the password being correct.  When the
            secure flag is set, the user *must* identify before he or she can be
            recognized.  If a specific True/False value is not given, it
            inverts the current value.
            """
            if value is None:
                value = not user.secure
            if user.checkPassword(password) and \
               user.checkHostmask(msg.prefix, useAuth=False):
                user.secure = value
                ircdb.users.setUser(user)
                irc.reply(_('Secure flag set to %s') % value)
            else:
                irc.error(conf.supybot.replies.incorrectAuthentication())
        secure = wrap(secure, ['private', 'user', 'something',
                               additional('boolean')])

    @internationalizeDocstring
    def username(self, irc, msg, args, hostmask):
        """<hostmask|nick>

        Returns the username of the user specified by <hostmask> or <nick> if
        the user is registered.
        """
        if ircutils.isNick(hostmask):
            try:
                hostmask = irc.state.nickToHostmask(hostmask)
            except KeyError:
                irc.error(_('I haven\'t seen %s.') % hostmask, Raise=True)
        try:
            user = ircdb.users.getUser(hostmask)
            irc.reply(user.name)
        except KeyError:
            irc.error(_('I don\'t know who that is.'))
    username = wrap(username, [first('nick', 'hostmask')])

    class hostmask(callbacks.Commands):
        @internationalizeDocstring
        def hostmask(self, irc, msg, args, nick):
            """[<nick>]

            Returns the hostmask of <nick>.  If <nick> isn't given, return the
            hostmask of the person giving the command.
            """
            if not nick:
                nick = msg.nick
            irc.reply(irc.state.nickToHostmask(nick))
        hostmask = wrap(hostmask, [additional('seenNick')])

        @internationalizeDocstring
        def list(self, irc, msg, args, name):
            """[<name>]

            Returns the hostmasks of the user specified by <name>; if <name>
            isn't specified, returns the hostmasks of the user calling the
            command.
            """
            def getHostmasks(user):
                hostmasks = list(map(repr, user.hostmasks))
                if hostmasks:
                    hostmasks.sort()
                    return format('%L', hostmasks)
                else:
                    return format(_('%s has no registered hostmasks.'),
                                  user.name)
            try:
                user = ircdb.users.getUser(msg.prefix)
                if name:
                    if name != user.name and \
                       not ircdb.checkCapability(msg.prefix, 'owner'):
                        irc.error(_('You may only retrieve your own '
                                  'hostmasks.'), Raise=True)
                    else:
                        try:
                            user = ircdb.users.getUser(name)
                            irc.reply(getHostmasks(user))
                        except KeyError:
                            irc.errorNoUser()
                else:
                    irc.reply(getHostmasks(user))
            except KeyError:
                irc.errorNotRegistered()
        list = wrap(list, ['private', additional('something')])

        @internationalizeDocstring
        def add(self, irc, msg, args, user, hostmask, password):
            """[<name>] [<hostmask>] [<password>]

            Adds the hostmask <hostmask> to the user specified by <name>.  The
            <password> may only be required if the user is not recognized by
            hostmask.  <password> is also not required if an owner user is
            giving the command on behalf of some other user.  If <hostmask> is
            not given, it defaults to your current hostmask.  If <name> is not
            given, it defaults to your currently identified name.  This message
            must be sent to the bot privately (not on a channel) since it may
            contain a password.
            """
            if not hostmask:
                hostmask = msg.prefix
            if not ircutils.isUserHostmask(hostmask):
                irc.errorInvalid(_('hostmask'), hostmask,
                                 _('Make sure your hostmask includes a nick, '
                                 'then an exclamation point (!), then a user, '
                                 'then an at symbol (@), then a host.  Feel '
                                 'free to use wildcards (* and ?, which work '
                                 'just like they do on the command line) in '
                                 'any of these parts.'),
                                 Raise=True)
            try:
                otherId = ircdb.users.getUserId(hostmask)
                if otherId != user.id:
                    irc.error(_('That hostmask is already registered.'),
                              Raise=True)
            except KeyError:
                pass
            if not user.checkPassword(password) and \
               not user.checkHostmask(msg.prefix):
                try:
                    u = ircdb.users.getUser(msg.prefix)
                except KeyError:
                    irc.error(conf.supybot.replies.incorrectAuthentication(),
                              Raise=True)
                if not u._checkCapability('owner'):
                    irc.error(conf.supybot.replies.incorrectAuthentication(),
                              Raise=True)
            try:
                user.addHostmask(hostmask)
            except ValueError as e:
                irc.error(str(e), Raise=True)
            try:
                ircdb.users.setUser(user)
            except ircdb.DuplicateHostmask:
                irc.error(_('That hostmask is already registered.'),
                          Raise=True)
            except ValueError as e:
                irc.error(str(e), Raise=True)
            irc.replySuccess()
        add = wrap(add, ['private', first('otherUser', 'user'),
                         optional('something'), additional('something', '')])

        @internationalizeDocstring
        def remove(self, irc, msg, args, user, hostmask, password):
            """[<name>] [<hostmask>] [<password>]

            Removes the hostmask <hostmask> from the record of the user
            specified by <name>.  If the hostmask given is 'all' then all
            hostmasks will be removed.  The <password> may only be required if
            the user is not recognized by their hostmask.  This message must be
            sent to the bot privately (not on a channel) since it may contain a
            password.  If <hostmask> is
            not given, it defaults to your current hostmask.  If <name> is not
            given, it defaults to your currently identified name.
            """
            if not hostmask:
                hostmask = msg.prefix
            if not user.checkPassword(password) and \
               not user.checkHostmask(msg.prefix):
                u = ircdb.users.getUser(msg.prefix)
                if not u._checkCapability('owner'):
                    irc.error(conf.supybot.replies.incorrectAuthentication())
                    return
            try:
                s = ''
                if hostmask == 'all':
                    user.hostmasks.clear()
                    s = _('All hostmasks removed.')
                else:
                    user.removeHostmask(hostmask)
            except KeyError:
                irc.error(_('There was no such hostmask.'))
                return
            ircdb.users.setUser(user)
            irc.replySuccess(s)
        remove = wrap(remove, ['private', first('otherUser', 'user'),
                               optional('something'), additional('something', '')])

    def callCommand(self, command, irc, msg, *args, **kwargs):
        if command[0] != 'gpg' or \
                (gpg.available and self.registryValue('gpg.enable')):
            return super(User, self) \
                    .callCommand(command, irc, msg, *args, **kwargs)
        else:
            irc.error(_('GPG features are not enabled.'))

    class gpg(callbacks.Commands):
        def __init__(self, *args):
            super(User.gpg, self).__init__(*args)
            self._tokens = {}

        def _expire_tokens(self):
            now = time.time()
            self._tokens = dict(filter(lambda x_y: x_y[1][1]>now,
                self._tokens.items()))

        @internationalizeDocstring
        def add(self, irc, msg, args, user, keyid, keyserver):
            """<key id> <key server>

            Add a GPG key to your account."""
            if keyid in user.gpgkeys:
                irc.error(_('This key is already associated with your '
                    'account.'))
                return
            result = gpg.keyring.recv_keys(keyserver, keyid)
            reply = format(_('%n imported, %i unchanged, %i not imported.'),
                    (result.imported, _('key')),
                    result.unchanged,
                    result.not_imported,
                    [x['fingerprint'] for x in result.results])
            if result.imported == 1:
                user.gpgkeys.append(keyid)
                irc.reply(reply)
            else:
                irc.error(reply)
        add = wrap(add, ['user',
                         ('somethingWithoutSpaces',
                             _('You must give a valid key id')),
                         ('somethingWithoutSpaces',
                             _('You must give a valid key server'))])

        @internationalizeDocstring
        def remove(self, irc, msg, args, user, fingerprint):
            """<fingerprint>

            Remove a GPG key from your account."""
            try:
                keyids = [x['keyid'] for x in gpg.keyring.list_keys()
                        if x['fingerprint'] == fingerprint]
                if len(keyids) == 0:
                    raise ValueError
                for keyid in keyids:
                    user.gpgkeys.remove(keyid)
                gpg.keyring.delete_keys(fingerprint)
                irc.replySuccess()
            except ValueError:
                irc.error(_('GPG key not associated with your account.'))
        remove = wrap(remove, ['user', 'somethingWithoutSpaces'])

        @internationalizeDocstring
        def list(self, irc, msg, args, user):
            """takes no arguments

            List your GPG keys."""
            keyids = user.gpgkeys
            if len(keyids) == 0:
                irc.reply(_('No key is associated with your account.'))
            else:
                irc.reply(format('%L', keyids))
        list = wrap(list, ['user'])

        @internationalizeDocstring
        def gettoken(self, irc, msg, args):
            """takes no arguments

            Send you a token that you'll have to sign with your key."""
            self._expire_tokens()
            token = '{%s}' % str(uuid.uuid4())
            lifetime = conf.supybot.plugins.User.gpg.TokenTimeout()
            self._tokens.update({token: (msg.prefix, time.time()+lifetime)})
            irc.reply(_('Your token is: %s. Please sign it with your '
                'GPG key, paste it somewhere, and call the \'auth\' '
                'command with the URL to the (raw) file containing the '
                'signature.') % token)
        gettoken = wrap(gettoken, [])

        _auth_re = re.compile(r'-----BEGIN PGP SIGNED MESSAGE-----\r?\n'
                r'Hash: .*\r?\n\r?\n'
                r'\s*({[0-9a-z-]+})\s*\r?\n'
                r'-----BEGIN PGP SIGNATURE-----\r?\n.*'
                r'\r?\n-----END PGP SIGNATURE-----',
                re.S)
        @internationalizeDocstring
        def auth(self, irc, msg, args, url):
            """<url>

            Check the GPG signature at the <url> and authenticates you if
            the key used is associated to a user."""
            self._expire_tokens()
            content = utils.web.getUrl(url)
            if sys.version_info[0] >= 3 and isinstance(content, bytes):
                content = content.decode()
            match = self._auth_re.search(content)
            if not match:
                irc.error(_('Signature or token not found.'), Raise=True)
            data = match.group(0)
            token = match.group(1)
            if token not in self._tokens:
                irc.error(_('Unknown token. It may have expired before you '
                    'submit it.'), Raise=True)
            if self._tokens[token][0] != msg.prefix:
                irc.error(_('Your hostname/nick changed in the process. '
                    'Authentication aborted.'), Raise=True)
            verified = gpg.keyring.verify(data)
            if verified and verified.valid:
                keyid = verified.key_id
                prefix, expiry = self._tokens.pop(token)
                found = False
                for (id, user) in ircdb.users.items():
                    if keyid in [x[-len(keyid):] for x in user.gpgkeys]:
                        user.addAuth(msg.prefix)
                        ircdb.users.setUser(user, flush=False)
                        irc.reply(_('You are now authenticated as %s.') %
                                user.name)
                        return
                irc.error(_('Unknown GPG key.'), Raise=True)
            else:
                irc.error(_('Signature could not be verified. Make sure '
                    'this is a valid GPG signature and the URL is valid.'))
        auth = wrap(auth, ['url'])

    @internationalizeDocstring
    def capabilities(self, irc, msg, args, user):
        """[<name>]

        Returns the capabilities of the user specified by <name>; if <name>
        isn't specified, returns the capabilities of the user calling the
        command.
        """
        try:
            u = ircdb.users.getUser(msg.prefix)
        except KeyError:
            irc.errorNotRegistered()
        else:
            if u == user or u._checkCapability('admin'):
                irc.reply('[%s]' % '; '.join(user.capabilities), private=True)
            else:
                irc.error(conf.supybot.replies.incorrectAuthentication(),
                          Raise=True)
    capabilities = wrap(capabilities, [first('otherUser', 'user')])

    @internationalizeDocstring
    def identify(self, irc, msg, args, user, password):
        """<name> <password>

        Identifies the user as <name>. This command (and all other
        commands that include a password) must be sent to the bot privately,
        not in a channel.
        """
        if user.checkPassword(password):
            try:
                user.addAuth(msg.prefix)
                ircdb.users.setUser(user, flush=False)
                irc.replySuccess()
            except ValueError:
                irc.error(_('Your secure flag is true and your hostmask '
                          'doesn\'t match any of your known hostmasks.'))
        else:
            self.log.warning('Failed identification attempt by %s (password '
                             'did not match for %s).', msg.prefix, user.name)
            irc.error(conf.supybot.replies.incorrectAuthentication())
    identify = wrap(identify, ['private', 'otherUser', 'something'])

    @internationalizeDocstring
    def unidentify(self, irc, msg, args, user):
        """takes no arguments

        Un-identifies you.  Note that this may not result in the desired
        effect of causing the bot not to recognize you anymore, since you may
        have added hostmasks to your user that can cause the bot to continue to
        recognize you.
        """
        user.clearAuth()
        ircdb.users.setUser(user)
        irc.replySuccess(_('If you remain recognized after giving this command, '
                         'you\'re being recognized by hostmask, rather than '
                         'by password.  You must remove whatever hostmask is '
                         'causing you to be recognized in order not to be '
                         'recognized.'))
    unidentify = wrap(unidentify, ['user'])

    @internationalizeDocstring
    def whoami(self, irc, msg, args):
        """takes no arguments

        Returns the name of the user calling the command.
        """
        try:
            user = ircdb.users.getUser(msg.prefix)
            irc.reply(user.name)
        except KeyError:
            irc.reply(_('I don\'t recognize you.'))
    whoami = wrap(whoami)

    @internationalizeDocstring
    def stats(self, irc, msg, args):
        """takes no arguments

        Returns some statistics on the user database.
        """
        users = 0
        owners = 0
        admins = 0
        hostmasks = 0
        for user in ircdb.users.itervalues():
            users += 1
            hostmasks += len(user.hostmasks)
            try:
                if user._checkCapability('owner'):
                    owners += 1
                elif user._checkCapability('admin'):
                    admins += 1
            except KeyError:
                pass
        irc.reply(format(_('I have %s registered users '
                         'with %s registered hostmasks; '
                         '%n and %n.'),
                         users, hostmasks,
                         (owners, 'owner'), (admins, 'admin')))
    stats = wrap(stats)


Class = User

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:


########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import re
from cStringIO import StringIO

import supybot.gpg as gpg
from supybot.test import PluginTestCase, network

import supybot.conf as conf
import supybot.world as world
import supybot.ircdb as ircdb
import supybot.utils as utils

PRIVATE_KEY = """
-----BEGIN PGP PRIVATE KEY BLOCK-----
Version: GnuPG v1.4.12 (GNU/Linux)

lQHYBFD7GxQBBACeu7bj/wgnnv5NkfHImZJVJLaq2cwKYc3rErv7pqLXpxXZbDOI
jP+5eSmTLhPUK67aRD6gG0wQ9iAhYR03weOmyjDGh0eF7kLYhu/4Il56Y/YbB8ll
Imz/pep/Hi72ShcW8AtifDup/KeHjaWa1yF2WThHbX/0N2ghSxbJnatpBwARAQAB
AAP6Arf7le7FD3ZhGZvIBkPr25qca6i0Qxb5XpOinV7jLcoycZriJ9Xofmhda9UO
xhNVppMvs/ofI/m0umnR4GLKtRKnJSc8Edxi4YKyqLehfBTF20R/kBYPZ772FkNW
Kzo5yCpP1jpOc0+QqBuU7OmrG4QhQzTLXIUgw4XheORncEECAMGkvR47PslJqzbY
VRIzWEv297r1Jxqy6qgcuCJn3RWYJbEZ/qdTYy+MgHGmaNFQ7yhfIzkBueq0RWZp
Z4PfJn8CANHZGj6AJZcvb+VclNtc5VNfnKjYD+qQOh2IS8NhE/0umGMKz3frH1TH
yCbh2LlPR89cqNcd4QvbHKA/UmzISXkB/37MbUnxXTpS9Y4HNpQCh/6SYlB0lucV
QN0cgjfhd6nBrb6uO6+u40nBzgynWcEpPMNfN0AtQeA4Dx+WrnK6kZqfd7QMU3Vw
eWJvdCB0ZXN0iLgEEwECACIFAlD7GxQCGwMGCwkIBwMCBhUIAgkKCwQWAgMBAh4B
AheAAAoJEMnTMjwgrwErV3AD/0kRq8UWPlkc6nyiIR6qiT3EoBNHKIi4cz68Wa1u
F2M6einrRR0HolrxonynTGsdr1u2f3egOS4fNfGhTNAowSefYR9q5kIYiYE2DL5G
YnjJKNfmnRxZM9YqmEnN50rgu2cifSRehp61fXdTtmOAR3js+9wb73dwbYzr3kIc
3WH1
=UBcd
-----END PGP PRIVATE KEY BLOCK-----
"""

WRONG_TOKEN_SIGNATURE = """
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

{a95dc112-780e-47f7-a83a-c6f3820d7dc3}
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.12 (GNU/Linux)

iJwEAQECAAYFAlD7Jb0ACgkQydMyPCCvASv9HgQAhQf/oFMWcKwGncH0hjXC3QYz
7ck3chgL3S1pPAvS69viz6i2bwYZYD8fhzHNJ/qtw/rx6thO6PwT4SpdhKerap+I
kdem3LjM4fAGHRunHZYP39obNKMn1xv+f26mEAAWxdv/W/BLAFqxi3RijJywRkXm
zo5GUl844kpnV+uk0Xk=
=z2Cz
-----END PGP SIGNATURE-----
"""

FINGERPRINT = '2CF3E41500218D30F0B654F5C9D3323C20AF012B'

class UserTestCase(PluginTestCase):
    plugins = ('User', 'Admin', 'Config')
    prefix1 = 'somethingElse!user@host.tld'
    prefix2 = 'EvensomethingElse!user@host.tld'

    def setUp(self):
        super(UserTestCase, self).setUp()
        gpg.loadKeyring()

    def testHostmaskList(self):
        self.assertError('hostmask list')
        original = self.prefix
        self.prefix = self.prefix1
        self.assertNotError('register foo bar')
        self.prefix = original
        self.assertError('hostmask list foo')
        self.assertNotError('hostmask add foo [hostmask] bar')
        self.assertNotError('hostmask add foo')
        self.assertNotRegexp('hostmask add foo', 'IrcSet')

    def testHostmaskListHandlesEmptyListGracefully(self):
        self.assertError('hostmask list')
        self.prefix = self.prefix1
        self.assertNotError('register foo bar')
        self.assertNotError('hostmask remove foo %s' % self.prefix1)
        self.assertNotError('identify foo bar')
        self.assertRegexp('hostmask list', 'no registered hostmasks')


    def testHostmask(self):
        self.assertResponse('hostmask', self.prefix)
        self.assertError('@hostmask asdf')
        m = self.irc.takeMsg()
        self.failIf(m is not None, m)

    def testRegisterUnregister(self):
        self.prefix = self.prefix1
        self.assertNotError('register foo bar')
        self.assertError('register foo baz')
        self.failUnless(ircdb.users.getUserId('foo'))
        self.assertError('unregister foo')
        self.assertNotError('unregister foo bar')
        self.assertRaises(KeyError, ircdb.users.getUserId, 'foo')

    def testDisallowedUnregistration(self):
        self.prefix = self.prefix1
        self.assertNotError('register foo bar')
        orig = conf.supybot.databases.users.allowUnregistration()
        conf.supybot.databases.users.allowUnregistration.setValue(False)
        try:
            self.assertError('unregister foo')
            m = self.irc.takeMsg()
            self.failIf(m is not None, m)
            self.failUnless(ircdb.users.getUserId('foo'))
        finally:
            conf.supybot.databases.users.allowUnregistration.setValue(orig)

    def testList(self):
        self.prefix = self.prefix1
        self.assertNotError('register foo bar')
        self.assertResponse('user list', 'foo')
        self.prefix = self.prefix2
        self.assertNotError('register biff quux')
        self.assertResponse('user list', 'biff and foo')

        self.assertRegexp('user list --capability testcap', 'no matching')
        self.assertNotError('admin capability add biff testcap')
        self.assertResponse('user list --capability testcap', 'biff')
        self.assertNotError('config capabilities.private testcap')
        self.assertRegexp('user list --capability testcap', 'Error:.*private')
        self.assertNotError('admin capability add biff admin')
        self.assertResponse('user list --capability testcap', 'biff')
        self.assertNotError('admin capability remove biff admin')
        self.assertRegexp('user list --capability testcap', 'Error:.*private')
        self.assertNotError('config capabilities.private ""')
        self.assertResponse('user list --capability testcap', 'biff')
        self.assertNotError('admin capability remove biff testcap')
        self.assertRegexp('user list --capability testcap', 'no matching')

        self.assertResponse('user list f', 'biff and foo')
        self.assertResponse('user list f*', 'foo')
        self.assertResponse('user list *f', 'biff')
        self.assertNotError('unregister biff quux')
        self.assertResponse('user list', 'foo')
        self.assertNotError('unregister foo bar')
        self.assertRegexp('user list', 'no registered users')
        self.assertRegexp('user list asdlfkjasldkj', 'no matching registered')

    def testListHandlesCaps(self):
        self.prefix = self.prefix1
        self.assertNotError('register Foo bar')
        self.assertResponse('user list', 'Foo')
        self.assertResponse('user list f*', 'Foo')

    def testChangeUsername(self):
        self.prefix = self.prefix1
        self.assertNotError('register foo bar')
        self.prefix = self.prefix2
        self.assertNotError('register bar baz')
        self.prefix = self.prefix1
        self.assertError('changename foo bar')
        self.assertNotError('changename foo baz')

    def testSetpassword(self):
        self.prefix = self.prefix1
        self.assertNotError('register foo bar')
        password = ircdb.users.getUser(self.prefix).password
        self.assertNotEqual(password, 'bar')
        self.assertNotError('set password foo bar baz')
        self.assertNotEqual(ircdb.users.getUser(self.prefix).password,password)
        self.assertNotEqual(ircdb.users.getUser(self.prefix).password, 'baz')

    def testStats(self):
        self.assertNotError('user stats')
        self.assertNotError('load Lart')
        self.assertNotError('user stats')

    def testUserPluginAndUserList(self):
        self.prefix = self.prefix1
        self.assertNotError('register Foo bar')
        self.assertResponse('user list', 'Foo')
        self.assertNotError('load Seen')
        self.assertResponse('user list', 'Foo')

    if gpg.available and network:
        def testGpgAddRemove(self):
            self.assertNotError('register foo bar')
            self.assertError('user gpg add 51E516F0B0C5CE6A pgp.mit.edu')
            self.assertResponse('user gpg add EB17F1E0CEB63930 pgp.mit.edu',
                    '1 key imported, 0 unchanged, 0 not imported.')
            self.assertNotError(
                    'user gpg remove F88ECDE235846FA8652DAF5FEB17F1E0CEB63930')
            self.assertResponse('user gpg add EB17F1E0CEB63930 pgp.mit.edu',
                    '1 key imported, 0 unchanged, 0 not imported.')
            self.assertResponse('user gpg add EB17F1E0CEB63930 pgp.mit.edu',
                    'Error: This key is already associated with your account.')

    if gpg.available:
        def testGpgAuth(self):
            self.assertNotError('register spam egg')
            gpg.keyring.import_keys(PRIVATE_KEY).__dict__
            (id, user) = ircdb.users.items()[0]
            user.gpgkeys.append(FINGERPRINT)
            msg = self.getMsg('gpg gettoken').args[-1]
            match = re.search('is: ({.*}).', msg)
            assert match, repr(msg)
            token = match.group(1)

            def fakeGetUrlFd(*args, **kwargs):
                return fd
            (utils.web.getUrlFd, realGetUrlFd) = (fakeGetUrlFd, utils.web.getUrlFd)

            fd = StringIO()
            fd.write('foo')
            fd.seek(0)
            self.assertResponse('gpg auth http://foo.bar/baz.gpg',
                    'Error: Signature or token not found.')

            fd = StringIO()
            fd.write(token)
            fd.seek(0)
            self.assertResponse('gpg auth http://foo.bar/baz.gpg',
                    'Error: Signature or token not found.')

            fd = StringIO()
            fd.write(WRONG_TOKEN_SIGNATURE)
            fd.seek(0)
            self.assertRegexp('gpg auth http://foo.bar/baz.gpg',
                    'Error: Unknown token.*')

            fd = StringIO()
            fd.write(str(gpg.keyring.sign(token)))
            fd.seek(0)
            self.assertResponse('gpg auth http://foo.bar/baz.gpg',
                    'You are now authenticated as spam.')

            utils.web.getUrlFd = realGetUrlFd

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:


########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2004, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Utilities')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Utilities', True)


Utilities = conf.registerPlugin('Utilities')
# This is where your configuration variables (if any) should go.  For example:
# conf.registerGlobalValue(Utilities, 'someConfigVariableName',
#     registry.Boolean(False, _("""Help for someConfigVariableName.""")))


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2002-2004, Jeremiah Fincher
# Copyright (c) 2010, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import types
import random

from supybot.commands import *
import supybot.ircutils as ircutils
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Utilities')

class Utilities(callbacks.Plugin):
    # Yes, I really do mean "requires no arguments" below.  "takes no
    # arguments" would probably lead people to think it was a useless command.
    @internationalizeDocstring
    def ignore(self, irc, msg, args):
        """requires no arguments

        Does nothing.  Useful sometimes for sequencing commands when you don't
        care about their non-error return values.
        """
        if irc.nested:
            msg.tag('ignored')
            # Need to call NestedCommandsIrcProxy.reply to continue evaluation
            # of the remaining nested commands.
            irc.reply('')
    # Do be careful not to wrap this unless you do any('something').

    @internationalizeDocstring
    def success(self, irc, msg, args, text):
        """[<text>]

        Does nothing except to reply with a success message.  This is useful
        when you want to run multiple commands as nested commands, and don't
        care about their output as long as they're successful.  An error, of
        course, will break out of this command.  <text>, if given, will be
        appended to the end of the success message.
        """
        irc.replySuccess(text)
    success = wrap(success, [additional('text')])

    @internationalizeDocstring
    def last(self, irc, msg, args):
        """<text> [<text> ...]

        Returns the last argument given.  Useful when you'd like multiple
        nested commands to run, but only the output of the last one to be
        returned.
        """
        args = list(filter(None, args))
        if args:
            irc.reply(args[-1])
        else:
            raise callbacks.ArgumentError

    @internationalizeDocstring
    def echo(self, irc, msg, args, text):
        """<text>

        Returns the arguments given it.  Uses our standard substitute on the
        string(s) given to it; $nick (or $who), $randomNick, $randomInt,
        $botnick, $channel, $user, $host, $today, $now, and $randomDate are all
        handled appropriately.
        """
        text = ircutils.standardSubstitute(irc, msg, text)
        irc.reply(text, prefixNick=False)
    echo = wrap(echo, ['text'])

    @internationalizeDocstring
    def shuffle(self, irc, msg, args, things):
        """<arg> [<arg> ...]

        Shuffles the arguments given.
        """
        random.shuffle(things)
        irc.reply(' '.join(things))
    shuffle = wrap(shuffle, [many('anything')])

    @internationalizeDocstring
    def sort(self, irc, msg, args, things):
        """<arg> [<arg> ...]

        Sorts the arguments given.
        """
        irc.reply(' '.join(map(str, sorted(things))))
    # Keep ints as ints, floats as floats, without comparing between numbers
    # and strings.
    sort = wrap(sort, [first(many(first('int', 'float')), many('anything'))])

    @internationalizeDocstring
    def sample(self, irc, msg, args, num, things):
        """<num> <arg> [<arg> ...]

        Randomly chooses <num> items out of the arguments given.
        """
        try:
            samp = random.sample(things, num)
            irc.reply(' '.join(samp))
        except ValueError as e:
            irc.error('%s' % (e,))
    sample = wrap(sample, ['positiveInt', many('anything')])

    @internationalizeDocstring
    def countargs(self, irc, msg, args, things):
        """<arg> [<arg> ...]

        Counts the arguments given.
        """
        irc.reply(len(things))
    countargs = wrap(countargs, [any('anything')])

    @internationalizeDocstring
    def apply(self, irc, msg, args, command, rest):
        """<command> <text>

        Tokenizes <text> and calls <command> with the resulting arguments.
        """
        args = [token and token or '""' for token in rest]
        text = ' '.join(args)
        commands = command.split()
        commands = list(map(callbacks.canonicalName, commands))
        tokens = callbacks.tokenize(text)
        allTokens = commands + tokens
        self.Proxy(irc, msg, allTokens)
    apply = wrap(apply, ['something', many('something')])


Class = Utilities

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
# -*- coding: utf8 -*-
###
# Copyright (c) 2002-2004, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

class UtilitiesTestCase(PluginTestCase):
    plugins = ('Utilities', 'String')
    def testIgnore(self):
        self.assertNoResponse('utilities ignore foo bar baz', 1)
        self.assertError('utilities ignore [re m/foo bar]')

    def testSuccess(self):
        self.assertNotError('success 1')
        self.assertError('success [re m/foo bar]')

    def testLast(self):
        self.assertResponse('utilities last foo bar baz', 'baz')

    def testEcho(self):
        self.assertHelp('echo')
        self.assertResponse('echo foo', 'foo')
        self.assertResponse(u'echo 好', '好')
        self.assertResponse(u'echo "好"', '好')

    def testEchoDollarOneRepliesDollarOne(self):
        self.assertResponse('echo $1', '$1')

    def testEchoStandardSubstitute(self):
        self.assertNotRegexp('echo $nick', r'\$')

    def testApply(self):
        self.assertResponse('apply "utilities last" a', 'a')
        self.assertResponse('apply "utilities last" a b', 'b')

    def testShuffle(self):
        self.assertResponse('shuffle a', 'a')

    def testSort(self):
        self.assertResponse('sort abc cab cba bca', 'abc bca cab cba')
        self.assertResponse('sort 2 12 42 7 2', '2 2 7 12 42')
        self.assertResponse('sort 2 8 12.2 12.11 42 7 2', '2 2 7 8 12.11 12.2 42')

    def testSample(self):
        self.assertResponse('sample 1 a', 'a')
        self.assertError('sample moo')
        self.assertError('sample 5 moo')
        self.assertRegexp('sample 2 a b c', '^[a-c] [a-c]$')

    def testCountargs(self):
        self.assertResponse('countargs a b c', '3')
        self.assertResponse('countargs a "b c"', '2')
        self.assertResponse('countargs', '0')

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Web')

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified themself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    Web = conf.registerPlugin('Web', True)
    if yn("""This plugin also offers a snarfer that will try to fetch the
             title of URLs that it sees in the channel.  Would like you this
             snarfer to be enabled?""", default=False):
        Web.titleSnarfer.setValue(True)


Web = conf.registerPlugin('Web')
conf.registerChannelValue(Web, 'titleSnarfer',
    registry.Boolean(False, _("""Determines whether the bot will output the
    HTML title of URLs it sees in the channel.""")))
conf.registerChannelValue(Web, 'snarferReportIOExceptions',
    registry.Boolean(False, _("""Determines whether the bot will notfiy the user
    about network exceptions like hostnotfound, timeout ....""")))
conf.registerChannelValue(Web, 'snarferShowTargetDomain',
    registry.Boolean(False, _("""Determines whether the domain name displayed
    by the snarfer will be the original one (posted on IRC) or the target one
    (got after following redirects, if any).""")))
conf.registerChannelValue(Web, 'nonSnarfingRegexp',
    registry.Regexp(None, _("""Determines what URLs matching the given regexp
    will not be snarfed.  Give the empty string if you have no URLs that you'd
    like to exclude from being snarfed.""")))

conf.registerGlobalValue(Web, 'urlWhitelist',
    registry.SpaceSeparatedListOfStrings([], """If set, bot will only fetch data
    from urls in the whitelist, i.e. starting with http://domain/optionalpath/. This will
    apply to all commands that retrieve data from user-supplied URLs,
    including fetch, headers, title, doctype."""))

conf.registerGroup(Web, 'fetch')
conf.registerGlobalValue(Web.fetch, 'maximum',
    registry.NonNegativeInteger(0, _("""Determines the maximum number of
    bytes the bot will download via the 'fetch' command in this plugin.""")))

conf.registerGlobalValue(Web.fetch, 'timeout',
    registry.NonNegativeInteger(5, """Determines the maximum number of
    seconds the bot will wait for the site to respond, when using the 'fetch'
    command in this plugin. If 0, will use socket.defaulttimeout"""))

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2005, Jeremiah Fincher
# Copyright (c) 2009, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import re
import sys
import socket
import HTMLParser
import htmlentitydefs

import supybot.conf as conf
import supybot.utils as utils
from supybot.commands import *
import supybot.plugins as plugins
import supybot.commands as commands
import supybot.ircutils as ircutils
import supybot.callbacks as callbacks
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization('Web')

class Title(HTMLParser.HTMLParser):
    entitydefs = htmlentitydefs.entitydefs.copy()
    entitydefs['nbsp'] = ' '
    entitydefs['apos'] = '\''
    def __init__(self):
        self.inTitle = False
        self.title = ''
        HTMLParser.HTMLParser.__init__(self)

    def handle_starttag(self, tag, attrs):
        if tag == 'title':
            self.inTitle = True

    def handle_endtag(self, tag):
        if tag == 'title':
            self.inTitle = False

    def handle_data(self, data):
        if self.inTitle:
            self.title += data

    def handle_entityref(self, name):
        if self.inTitle:
            if name in self.entitydefs:
                self.title += self.entitydefs[name]

class DelayedIrc:
    def __init__(self, irc):
        self._irc = irc
        self._replies = []
    def reply(self, *args, **kwargs):
        self._replies.append(('reply', args, kwargs))
    def error(self, *args, **kwargs):
        self._replies.append(('error', args, kwargs))
    def __getattr__(self, name):
        assert name not in ('reply', 'error', '_irc', '_msg', '_replies')
        return getattr(self._irc, name)

def fetch_sandbox(f):
    """Runs a command in a forked process with limited memory resources
    to prevent memory bomb caused by specially crafted http responses."""
    def process(self, irc, msg, *args, **kwargs):
        delayed_irc = DelayedIrc(irc)
        f(self, delayed_irc, msg, *args, **kwargs)
        return delayed_irc._replies
    def newf(self, irc, *args):
        try:
            replies = commands.process(process, self, irc, *args,
                    timeout=5, heap_size=1024*1024,
                    pn=self.name(), cn=f.__name__)
        except commands.ProcessTimeoutError:
            raise utils.web.Error(_('Page is too big.'))
        else:
            for (method, args, kwargs) in replies:
                getattr(irc, method)(*args, **kwargs)
    newf.__doc__ = f.__doc__
    return newf

def catch_web_errors(f):
    """Display a nice error instead of "An error has occurred"."""
    def newf(self, irc, *args, **kwargs):
        try:
            f(self, irc, *args, **kwargs)
        except utils.web.Error as e:
            irc.reply(str(e))
    newf.__doc__ = f.__doc__
    return newf

class Web(callbacks.PluginRegexp):
    """Add the help for "@help Web" here."""
    regexps = ['titleSnarfer']

    @fetch_sandbox
    def titleSnarfer(self, irc, msg, match):
        channel = msg.args[0]
        if not irc.isChannel(channel):
            return
        if callbacks.addressed(irc.nick, msg):
            return
        if self.registryValue('titleSnarfer', channel):
            url = match.group(0)
            r = self.registryValue('nonSnarfingRegexp', channel)
            if r and r.search(url):
                self.log.debug('Not titleSnarfing %q.', url)
                return
            try:
                size = conf.supybot.protocols.http.peekSize()
                fd = utils.web.getUrlFd(url)
                text = fd.read(size)
                fd.close()
            except socket.timeout as e:
                self.log.info('Couldn\'t snarf title of %u: %s.', url, e)
                if self.registryValue('snarferReportIOExceptions', channel):
                     irc.reply(url+" : "+utils.web.TIMED_OUT, prefixNick=False)
                return
            try:
                text = text.decode(utils.web.getEncoding(text) or 'utf8',
                        'replace')
            except:
                pass
            parser = Title()
            try:
                parser.feed(text)
            except HTMLParser.HTMLParseError:
                self.log.debug('Encountered a problem parsing %u.  Title may '
                               'already be set, though', url)
            if parser.title:
                domain = utils.web.getDomain(fd.geturl()
                        if self.registryValue('snarferShowTargetDomain', channel)
                        else url)
                title = utils.web.htmlToText(parser.title.strip())
                if sys.version_info[0] < 3:
                    if isinstance(title, unicode):
                        title = title.encode('utf8', 'replace')
                s = format(_('Title: %s (at %s)'), title, domain)
                irc.reply(s, prefixNick=False)
    titleSnarfer = urlSnarfer(titleSnarfer)
    titleSnarfer.__doc__ = utils.web._httpUrlRe

    def _checkURLWhitelist(self, url):
        if not self.registryValue('urlWhitelist'):
            return True
        passed = False
        for wu in self.registryValue('urlWhitelist'):
            if wu.endswith('/') and url.find(wu) == 0:
                passed = True
                break
            if (not wu.endswith('/')) and (url.find(wu + '/') == 0 or url == wu):
                passed = True
                break
        return passed

    @catch_web_errors
    @fetch_sandbox
    @internationalizeDocstring
    def headers(self, irc, msg, args, url):
        """<url>

        Returns the HTTP headers of <url>.  Only HTTP urls are valid, of
        course.
        """
        if not self._checkURLWhitelist(url):
            irc.error("This url is not on the whitelist.")
            return
        fd = utils.web.getUrlFd(url)
        try:
            s = ', '.join([format(_('%s: %s'), k, v)
                           for (k, v) in fd.headers.items()])
            irc.reply(s)
        finally:
            fd.close()
    headers = wrap(headers, ['httpUrl'])

    _doctypeRe = re.compile(r'(<!DOCTYPE[^>]+>)', re.M)
    @catch_web_errors
    @fetch_sandbox
    @internationalizeDocstring
    def doctype(self, irc, msg, args, url):
        """<url>

        Returns the DOCTYPE string of <url>.  Only HTTP urls are valid, of
        course.
        """
        if not self._checkURLWhitelist(url):
            irc.error("This url is not on the whitelist.")
            return
        size = conf.supybot.protocols.http.peekSize()
        s = utils.web.getUrl(url, size=size) \
                        .decode('utf8')
        m = self._doctypeRe.search(s)
        if m:
            s = utils.str.normalizeWhitespace(m.group(0))
            irc.reply(s)
        else:
            irc.reply(_('That URL has no specified doctype.'))
    doctype = wrap(doctype, ['httpUrl'])

    @catch_web_errors
    @fetch_sandbox
    @internationalizeDocstring
    def size(self, irc, msg, args, url):
        """<url>

        Returns the Content-Length header of <url>.  Only HTTP urls are valid,
        of course.
        """
        if not self._checkURLWhitelist(url):
            irc.error("This url is not on the whitelist.")
            return
        fd = utils.web.getUrlFd(url)
        try:
            try:
                size = fd.headers['Content-Length']
                irc.reply(format(_('%u is %S long.'), url, int(size)))
            except KeyError:
                size = conf.supybot.protocols.http.peekSize()
                s = fd.read(size)
                if len(s) != size:
                    irc.reply(format(_('%u is %S long.'), url, len(s)))
                else:
                    irc.reply(format(_('The server didn\'t tell me how long %u '
                                     'is but it\'s longer than %S.'),
                                     url, size))
        finally:
            fd.close()
    size = wrap(size, ['httpUrl'])

    @catch_web_errors
    @fetch_sandbox
    @internationalizeDocstring
    def title(self, irc, msg, args, optlist, url):
        """[--no-filter] <url>

        Returns the HTML <title>...</title> of a URL.
        If --no-filter is given, the bot won't strip special chars (action,
        DCC, ...).
        """
        if not self._checkURLWhitelist(url):
            irc.error("This url is not on the whitelist.")
            return
        size = conf.supybot.protocols.http.peekSize()
        text = utils.web.getUrl(url, size=size)
        try:
            text = text.decode(utils.web.getEncoding(text) or 'utf8',
                    'replace')
        except:
            pass
        parser = Title()
        try:
            parser.feed(text)
        except HTMLParser.HTMLParseError:
            self.log.debug('Encountered a problem parsing %u.  Title may '
                           'already be set, though', url)
        if parser.title:
            title = utils.web.htmlToText(parser.title.strip())
            if not [y for x,y in optlist if x == 'no-filter']:
                for i in range(1, 4):
                    title = title.replace(chr(i), '')
            irc.reply(title)
        elif len(text) < size:
            irc.reply(_('That URL appears to have no HTML title.'))
        else:
            irc.reply(format(_('That URL appears to have no HTML title '
                             'within the first %S.'), size))
    title = wrap(title, [getopts({'no-filter': ''}), 'httpUrl'])

    @internationalizeDocstring
    def urlquote(self, irc, msg, args, text):
        """<text>

        Returns the URL quoted form of the text.
        """
        irc.reply(utils.web.urlquote(text))
    urlquote = wrap(urlquote, ['text'])

    @internationalizeDocstring
    def urlunquote(self, irc, msg, args, text):
        """<text>

        Returns the text un-URL quoted.
        """
        s = utils.web.urlunquote(text)
        irc.reply(s)
    urlunquote = wrap(urlunquote, ['text'])

    @catch_web_errors
    @fetch_sandbox
    @internationalizeDocstring
    def fetch(self, irc, msg, args, url):
        """<url>

        Returns the contents of <url>, or as much as is configured in
        supybot.plugins.Web.fetch.maximum.  If that configuration variable is
        set to 0, this command will be effectively disabled.
        """
        if not self._checkURLWhitelist(url):
            irc.error("This url is not on the whitelist.")
            return
        max = self.registryValue('fetch.maximum')
        if not max:
            irc.error(_('This command is disabled '
                      '(supybot.plugins.Web.fetch.maximum is set to 0).'),
                      Raise=True)
        fd = utils.web.getUrl(url, size=max) \
                        .decode('utf8')
        irc.reply(fd)
    fetch = wrap(fetch, ['url'])

Class = Web

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

class WebTestCase(ChannelPluginTestCase):
    plugins = ('Web',)
    timeout = 10
    if network:
        def testHeaders(self):
            self.assertError('headers ftp://ftp.cdrom.com/pub/linux')
            self.assertNotError('headers http://www.slashdot.org/')

        def testDoctype(self):
            self.assertError('doctype ftp://ftp.cdrom.com/pub/linux')
            self.assertNotError('doctype http://www.slashdot.org/')
            m = self.getMsg('doctype http://moobot.sf.net/')
            self.failUnless(m.args[1].endswith('>'))

        def testSize(self):
            self.assertError('size ftp://ftp.cdrom.com/pub/linux')
            self.assertNotError('size http://supybot.sf.net/')
            self.assertNotError('size http://www.slashdot.org/')

        def testTitle(self):
            self.assertRegexp('title http://www.slashdot.org/',
                              'News for nerds, stuff that matters')
            # Checks for @title not-working correctly
            self.assertResponse('title '
                'http://www.catb.org/~esr/jargon/html/F/foo.html',
                'foo')
            # Checks for only grabbing the real title tags instead of title
            # tags inside, for example, script tags. Bug #1190350
            self.assertNotRegexp('title '
                'http://www.irinnews.org/report.asp?ReportID=45910&'
                'SelectRegion=West_Africa&SelectCountry=CHAD',
                r'document\.write\(')
            # Checks that title parser grabs the full title instead of just
            # part of it.
            self.assertRegexp('title http://www.n-e-r-d.com/', 'N.*E.*R.*D')
            # Checks that the parser doesn't hang on invalid tags
            print()
            print("If we have not fixed a bug with the parser, the following")
            print("test will hang the test-suite.")
            self.assertNotError(
                        'title http://www.youtube.com/watch?v=x4BtiqPN4u8')

        def testTitleSnarfer(self):
            try:
                conf.supybot.plugins.Web.titleSnarfer.setValue(True)
                self.assertSnarfRegexp('http://microsoft.com/',
                                         'Microsoft')
            finally:
                conf.supybot.plugins.Web.titleSnarfer.setValue(False)

        def testNonSnarfing(self):
            snarf = conf.supybot.plugins.Web.nonSnarfingRegexp()
            title = conf.supybot.plugins.Web.titleSnarfer()
            try:
                conf.supybot.plugins.Web.nonSnarfingRegexp.set('m/sf/')
                try:
                    conf.supybot.plugins.Web.titleSnarfer.setValue(True)
                    self.assertSnarfNoResponse('http://sf.net/', 2)
                    self.assertSnarfRegexp('http://www.sourceforge.net/',
                                           r'Sourceforge\.net')
                finally:
                    conf.supybot.plugins.Web.titleSnarfer.setValue(title)
            finally:
                conf.supybot.plugins.Web.nonSnarfingRegexp.setValue(snarf)

        def testWhitelist(self):
            fm = conf.supybot.plugins.Web.fetch.maximum()
            uw = conf.supybot.plugins.Web.urlWhitelist()
            try:
                conf.supybot.plugins.Web.fetch.maximum.set(1024)
                self.assertNotError('web fetch http://fsf.org')
                conf.supybot.plugins.Web.urlWhitelist.set('http://slashdot.org')
                self.assertError('web fetch http://fsf.org')
                self.assertError('wef title http://fsf.org')
                self.assertError('web fetch http://slashdot.org.evildomain.com')
                self.assertNotError('web fetch http://slashdot.org')
                self.assertNotError('web fetch http://slashdot.org/recent')
                conf.supybot.plugins.Web.urlWhitelist.set('http://slashdot.org http://fsf.org')
                self.assertNotError('doctype http://fsf.org')
            finally:
                conf.supybot.plugins.Web.urlWhitelist.set('')
                conf.supybot.plugins.Web.fetch.maximum.set(fm)

    def testNonSnarfingRegexpConfigurable(self):
        self.assertSnarfNoResponse('http://foo.bar.baz/', 2)
        try:
            conf.supybot.plugins.Web.nonSnarfingRegexp.set('m/biff/')
            self.assertSnarfNoResponse('http://biff.bar.baz/', 2)
        finally:
            conf.supybot.plugins.Web.nonSnarfingRegexp.set('')


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = check_trans
#!/usr/bin/env python

import os
import sys
import glob
import operator
import subprocess

from supybot.i18n import parse

def main():
    directory = sys.argv[1]
    if directory == '--core':
        checkCore()
    else:
        for plugin in os.listdir(directory):
            if plugin[0] not in 'AZERTYUIOPQSDFGHJKLMWXCVBN':
                continue
            checkPlugin(os.path.join(directory, plugin))

def changedir(f):
    def newf(new_path):
        old_path = os.getcwd()
        os.chdir(new_path)
        try:
            return f('.')
        finally:
            os.chdir(old_path)
    return newf

def checkCore():
    _checkCore(os.path.join(os.path.dirname(__file__), '..'))

@changedir
def _checkCore(corePath):
    subprocess.Popen(['pygettext', '-p', 'locales', 'plugins/__init__.py'] + glob.glob('src/*.py') + glob.glob('src/*/*.py')).wait()
    localePath = os.path.join(corePath, 'locales')
    pot = open(os.path.join(localePath, 'messages.pot'))
    for translation in os.listdir(localePath):
        if not translation.endswith('.po'):
            continue
        pot.seek(0)
        potPath = os.path.join(os.getcwd(), 'locales', translation)
        po = open(potPath)
        if checkTranslation(pot, po):
            print('OK:      ' + potPath)
        else:
            print('ERROR:   ' + potPath)


@changedir
def checkPlugin(pluginPath):
    subprocess.Popen('pygettext -D config.py plugin.py', shell=True).wait()
    pot = open(os.path.join(pluginPath, 'messages.pot'))
    localePath = os.path.join(pluginPath, 'locales')
    for translation in os.listdir(localePath):
        if not translation.endswith('.po'):
            continue
        pot.seek(0)
        potPath = os.path.join(os.getcwd(), 'locales', translation)
        po = open(potPath)
        if checkTranslation(pot, po):
            print('OK:      ' + potPath)
        else:
            print('ERROR:   ' + potPath)

def checkTranslation(pot, po):
    checking = False
    pot = set(map(operator.itemgetter(0), parse(pot)))
    po = set(map(operator.itemgetter(0), parse(po)))
    diff = [x for x in pot if x not in po]
    return not bool(diff)

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = config
###
# Copyright (c) 2004, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import supybot.conf as conf
import supybot.registry as registry

def configure(advanced):
    # This will be called by supybot to configure this module.  advanced is
    # a bool that specifies whether the user identified himself as an advanced
    # user or not.  You should effect your configuration by manipulating the
    # registry as appropriate.
    from supybot.questions import expect, anything, something, yn
    conf.registerPlugin('Debug', True)


Debug = conf.registerPlugin('Debug')
# This is where your configuration variables (if any) should go.  For example:
# conf.registerGlobalValue(Debug, 'someConfigVariableName',
#     registry.Boolean(False, """Help for someConfigVariableName."""))


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/python

###
# Copyright (c) 2002-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

"""
This is for jemfinch's debugging only.  If this somehow gets added and
committed, remove it immediately.  It must not be released with Supybot.
"""

import supybot.plugins as plugins

import gc
import os
import pwd
import sys
try:
    import exceptions
except ImportError: # Python 3
    import builtins
    class exceptions:
        """Pseudo-module"""
        pass
    for (key, value) in list(exceptions.__dict__.items()):
        if isinstance(value, type) and issubclass(value, Exception):
            exceptions[key] = value

import supybot.conf as conf
import supybot.utils as utils
import supybot.ircdb as ircdb
from supybot.commands import *
import supybot.ircmsgs as ircmsgs
import supybot.callbacks as callbacks

def getTracer(fd):
    def tracer(frame, event, _):
        if event == 'call':
            code = frame.f_code
            fd.write('%s: %s\n' % (code.co_filename, code.co_name))
    return tracer

class Debug(callbacks.Privmsg):
    capability = 'owner'
    def __init__(self, irc):
        # Setup exec command.
        self.__parent = super(Debug, self)
        self.__parent.__init__(irc)
        setattr(self.__class__, 'exec', self.__class__._exec)

    def callCommand(self, name, irc, msg, *args, **kwargs):
        if ircdb.checkCapability(msg.prefix, self.capability):
            self.__parent.callCommand(name, irc, msg, *args, **kwargs)
        else:
            irc.errorNoCapability(self.capability)
            
    _evalEnv = {'_': None,
                '__': None,
                '___': None,
                }
    _evalEnv.update(globals())
    def eval(self, irc, msg, args, s):
        """<expression>

        Evaluates <expression> (which should be a Python expression) and
        returns its value.  If an exception is raised, reports the
        exception (and logs the traceback to the bot's logfile).
        """
        try:
            self._evalEnv.update(locals())
            x = eval(s, self._evalEnv, self._evalEnv)
            self._evalEnv['___'] = self._evalEnv['__']
            self._evalEnv['__'] = self._evalEnv['_']
            self._evalEnv['_'] = x
            irc.reply(repr(x))
        except SyntaxError as e:
            irc.reply(format('%s: %q', utils.exnToString(e), s))
    eval = wrap(eval, ['text'])

    def _exec(self, irc, msg, args, s):
        """<statement>

        Execs <code>.  Returns success if it didn't raise any exceptions.
        """
        exec(s)
        irc.replySuccess()
    _exec = wrap(_exec, ['text'])

    def simpleeval(self, irc, msg, args, text):
        """<expression>

        Evaluates the given expression.
        """
        try:
            irc.reply(repr(eval(text)))
        except Exception as e:
            irc.reply(utils.exnToString(e))
    simpleeval = wrap(simpleeval, ['text'])

    def exn(self, irc, msg, args, name):
        """<exception name>

        Raises the exception matching <exception name>.
        """
        if isinstance(__builtins__, dict):
            exn = __builtins__[name]
        else:
            exn = getattr(__builtins__, name)
        raise exn(msg.prefix)
    exn = wrap(exn, ['text'])

    def sendquote(self, irc, msg, args, text):
        """<raw IRC message>

        Sends (not queues) the raw IRC message given.
        """
        msg = ircmsgs.IrcMsg(text)
        irc.sendMsg(msg)
    sendquote = wrap(sendquote, ['text'])

    def settrace(self, irc, msg, args, filename):
        """[<filename>]

        Starts tracing function calls to <filename>.  If <filename> is not
        given, sys.stdout is used.  This causes much output.
        """
        if filename:
            fd = open(filename, 'a')
        else:
            fd = sys.stdout
        sys.settrace(getTracer(fd))
        irc.replySuccess()
    settrace = wrap(settrace, [additional('filename')])

    def unsettrace(self, irc, msg, args):
        """takes no arguments

        Stops tracing function calls on stdout.
        """
        sys.settrace(None)
        irc.replySuccess()
    unsettrace = wrap(unsettrace)

    def channeldb(self, irc, msg, args, channel):
        """[<channel>]

        Returns the result of the channeldb converter.
        """
        irc.reply(channel)
    channeldb = wrap(channeldb, ['channeldb'])

    def collect(self, irc, msg, args, times):
        """[<times>]

        Does <times> gc collections, returning the number of objects collected
        each time.  <times> defaults to 1.
        """
        L = []
        while times:
            L.append(gc.collect())
            times -= 1
        irc.reply(format('%L', list(map(str, L))))
    collect = wrap(collect, [additional('positiveInt', 1)])

    _progstats_endline_remover = utils.str.MultipleRemover('\r\n')
    def progstats(self, irc, msg, args):
        """takes no arguments

        Returns various unix-y information on the running supybot process.
        """
        pw = pwd.getpwuid(os.getuid())
        response = 'Process ID %s running as user "%s" and as group "%s" ' \
                   'from directory "%s" with the command line "%s".  ' \
                   'Running on Python %s.' % \
                   (os.getpid(), pw[0], pw[3],
                    os.getcwd(), ' '.join(sys.argv),
                    self._progstats_endline_remover(sys.version))
        irc.reply(response)
    progstats = wrap(progstats)

    def environ(self, irc, msg, args):
        """takes no arguments

        Returns the environment of the supybot process.
        """
        irc.reply(repr(os.environ))
    environ = wrap(environ)


Class = Debug

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2004, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

class DebugTestCase(PluginTestCase):
    plugins = ('Debug',)


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = release
#!/usr/bin/env python

import os
import re
import sys
import shutil
import subprocess

from optparse import OptionParser

def firstLines(filename, n):
    fd = file(filename)
    lines = []
    while n:
        n -= 1
        lines.append(fd.readline().rstrip('\r\n'))
    fd.close()
    return lines

def firstLine(filename):
    return firstLines(filename, 1)[0]

def error(s):
    sys.stderr.write(s+'\n')
    sys.exit(-1)

def system(sh, errmsg=None, **kwargs):
    if errmsg is None:
        if isinstance(sh, basestring):
            errmsg = repr(sh)
        else:
            errmsg = repr(' '.join(sh))
    ret = subprocess.call(sh, **kwargs)
    if ret:
        error(errmsg + '  (error code: %s)' % ret)

def checkGitRepo():
    system('test "$(git rev-parse --is-inside-work-tree)" = "true"',
           'Must be run from a git checkout.',
           shell=True)
    system('test "$(git rev-parse --show-cdup >/dev/null)" = ""',
           'Must be run from the top-level directory of the git checkout.',
           shell=True)
    system('git rev-parse --verify HEAD >/dev/null '
           '&& git update-index --refresh'
           '&& git diff-files --quiet'
           '&& git diff-index --cached --quiet HEAD --',
           'Your tree is unclean. Can\'t run from here.',
           shell=True)

if __name__ == '__main__':
    usage = 'usage: %prog [options] <username> <version>'
    parser = OptionParser(usage=usage)
    parser.set_defaults(sign=False, verbose=False, branch='master')
    parser.add_option('-s', '--sign', action='store_true', dest='sign',
                      help='Pass on -s to relevant git commands')
    parser.add_option('-n', '--dry-run', action='store_true', dest='dry_run',
                      help='Build the release, but do not push to the git '
                           'remote or upload the release archives.')
    parser.add_option('-b', '--branch', metavar='BRANCH', dest='branch',
                      help='Branch to use for the release. Default: %default')
    (options, args) = parser.parse_args()

    if len(args) != 2:
        parser.error('Both username and version must be specified')

    (u, v) = args
    if not re.match(r'^\d+\.\d+\.\d+(\.\d+)?\w*$', v):
        parser.error('Invalid version string: '
                     'must be of the form MAJOR.MINOR.PATCHLEVEL')

    checkGitRepo()

    sign = options.sign
    dryrun = options.dry_run
    branch = options.branch

    if os.path.exists('supybot'):
        error('I need to make the directory "supybot" but it already exists.'
              '  Change to an appropriate directory or remove the supybot '
              'directory to continue.')
    print 'Checking out fresh tree from git.'
    repo = 'git+ssh://%s@supybot.git.sourceforge.net/gitroot/supybot/supybot' % u
    system(['git', 'clone', '-b', branch, repo])
    os.chdir('supybot')

    print 'Checking RELNOTES version line.'
    if firstLine('RELNOTES') != 'Version %s' % v:
        error('Invalid first line in RELNOTES.')

    print 'Checking ChangeLog version line.'
    (first, _, third) = firstLines('ChangeLog', 3)
    if not re.match(r'^20\d\d-\d{2}-\d{2}\s+\w+.*<\S+@\S+>$', first):
        error('Invalid first line in ChangeLog.')
    if not re.match(r'^\t\* Version %s!$' % v, third):
        error('Invalid third line in ChangeLog.')

    print 'Updating version in version files.'
    versionFiles = ['src/version.py']
    for fn in versionFiles:
        sh = ['perl', '-pi', '-e', 's/^version\s*=.*/version = \'%s\'/' % v, fn]
        system(sh, 'Error changing version in %s' % fn)
    commit = ['git', 'commit']
    if sign:
        commit.append('-s')
    system(commit + ['-m', 'Updated to %s.' % v] + versionFiles)

    print 'Tagging release.'
    tag = ['git', 'tag']
    if sign:
        tag.append('-s')
    system(tag + ['-m', "Release %s" % v, 'v%s' % v])

    print 'Committing %s+git to version files.' % v
    for fn in versionFiles:
        system(['perl', '-pi', '-e',
                's/^version\s*=.*/version = \'%s+git\'/' % v, fn],
                'Error changing version in %s' % fn)
    system(commit + ['-m', 'Updated to %s+git.' % v] + versionFiles)

    if not dryrun:
        print 'Pushing commits and tag.'
        system(['git', 'push', 'origin', branch])
        system(['git', 'push', '--tags'])

    archive = ['git', 'archive', '--prefix=Supybot-%s/' % v]
    print 'Creating tarball (gzip).'
    system(archive + ['-o', '../Supybot-%s.tar.gz' % v,
                      '--format=tgz', 'v%s' % v])

    system(['git', 'config', 'tar.bz2.command', 'bzip2 -c'])

    print 'Creating tarball (bzip2).'
    system(archive + ['-o', '../Supybot-%s.tar.bz2' % v,
                      '--format=bz2', 'v%s' % v])

    print 'Creating zip.'
    system(archive + ['-o', '../Supybot-%s.zip' % v,
                      '--format=zip', 'v%s' % v])

    os.chdir('..')
    shutil.rmtree('supybot')

    if not dryrun:
        print 'Uploading package files to upload.sf.net.'
        system('scp Supybot-%s.tar.gz Supybot-%s.tar.bz2 Supybot-%s.zip '
               '%s@frs.sourceforge.net:uploads' % (v, v, v, u))
        os.unlink('Supybot-%s.tar.gz' % v)
        os.unlink('Supybot-%s.tar.bz2' % v)
        os.unlink('Supybot-%s.zip' % v)

        print 'Copying new version.txt over to project webserver.'
        system('echo %s > version.txt' % v)
        system('scp version.txt %s@web.sf.net:/home/groups/s/su/supybot/htdocs'
               %u)
        os.unlink('version.txt')

#    print 'Generating documentation.'
#    # docFiles is in the format {directory: files}
#    docFiles = {'.': ('README', 'INSTALL', 'ChangeLog'),
#                'docs': ('config.html', 'CAPABILITIES', 'commands.html',
#                         'CONFIGURATION', 'FAQ', 'GETTING_STARTED',
#                         'INTERFACES', 'OVERVIEW', 'PLUGIN-EXAMPLE',
#                         'plugins', 'plugins.html', 'STYLE'),
#               }
#    system('python scripts/supybot-plugin-doc')
#    pwd = os.getcwd()
#    os.chmod('docs/plugins', 0775)
#    sh = 'tar rf %s/docs.tar %%s' % pwd
#    for (dir, L) in docFiles.iteritems():
#        os.chdir(os.path.join(pwd, dir))
#        system(sh % ' '.join(L))
#    os.chdir(pwd)
#    system('bzip2 docs.tar')
#
#    print 'Uploading documentation to webspace.'
#    system('scp docs.tar.bz2 %s@supybot.sf.net:/home/groups/s/su/supybot'
#           '/htdocs/docs/.' % u)
#    system('ssh %s@supybot.sf.net "cd /home/groups/s/su/supybot/htdocs/docs; '
#           'tar jxf docs.tar.bz2"' % u)
#
#    print 'Cleaning up generated documentation.'
#    shutil.rmtree('docs/plugins')
#    configFiles = ('docs/config.html', 'docs/plugins.html',
#                   'docs/commands.html', 'docs.tar.bz2', 'test-conf',
#                   'test-data', 'test-logs', 'tmp')
#    for fn in configFiles:
#        os.remove(fn)

# This is the part where we do our release on Freshmeat using XMLRPC and
# <gasp> ESR's software to do it: http://freshmeat.net/p/freshmeat-submit/

########NEW FILE########
__FILENAME__ = update_plugins_messagespot
import os
import pbs

pbs.cd('Admin')
for plugin in os.listdir('..'):
    path = os.path.join('..', plugin)
    print(repr(path))
    assert os.path.exists(path)
    if not os.path.isdir(path):
        print 1
        continue
    print 2
    pbs.cd(path)
    pbs.pygettext('-D', 'config.py', 'plugin.py')

########NEW FILE########
__FILENAME__ = ansi
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

"""
ansi.py

ANSI Terminal Interface

Color Usage:
  print RED + 'this is red' + RESET
  print BOLD + GREEN + WHITEBG + 'this is bold green on white' + RESET
  def move(new_x, new_y): 'Move cursor to new_x, new_y'
  def moveUp(lines): 'Move cursor up # of lines'
  def moveDown(lines): 'Move cursor down # of lines'
  def moveForward(chars): 'Move cursor forward # of chars'
  def moveBack(chars): 'Move cursor backward # of chars'
  def save(): 'Saves cursor position'
  def restore(): 'Restores cursor position'
  def clear(): 'Clears screen and homes cursor'
  def clrtoeol(): 'Clears screen to end of line'
"""



################################
# C O L O R  C O N S T A N T S #
################################
BLACK = '\033[30m'
RED = '\033[31m'
GREEN = '\033[32m'
YELLOW = '\033[33m'
BLUE = '\033[34m'
MAGENTA = '\033[35m'
CYAN = '\033[36m'
WHITE = '\033[37m'

RESET = '\033[0;0m'
BOLD = '\033[1m'
REVERSE = '\033[2m'

BLACKBG = '\033[40m'
REDBG = '\033[41m'
GREENBG = '\033[42m'
YELLOWBG = '\033[43m'
BLUEBG = '\033[44m'
MAGENTABG = '\033[45m'
CYANBG = '\033[46m'
WHITEBG = '\033[47m'

#def move(new_x, new_y):
#  'Move cursor to new_x, new_y'
#  print '\033[' + str(new_x) + ';' + str(new_y) + 'H'
#
#def moveUp(lines):
#  'Move cursor up # of lines'
#  print '\033[' + str(lines) + 'A'
#
#def moveDown(lines):
#  'Move cursor down # of lines'
#  print '\033[' + str(lines) + 'B'
#
#def moveForward(chars):
#  'Move cursor forward # of chars'
#  print '\033[' + str(chars) + 'C'
#
#def moveBack(chars):
#  'Move cursor backward # of chars'
#  print '\033[' + str(chars) + 'D'
#
#def save():
#  'Saves cursor position'
#  print '\033[s'
#
#def restore():
#  'Restores cursor position'
#  print '\033[u'
#
#def clear():
#  'Clears screen and homes cursor'
#  print '\033[2J'
#
#def clrtoeol():
#  'Clears screen to end of line'
#  print '\033[K'
# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = callbacks
# -*- coding: utf8 -*-
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# Copyright (c) 2008-2010, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

"""
This module contains the basic callbacks for handling PRIVMSGs.
"""

import re
import sys
import copy
import time
import shlex
import codecs
import getopt
import inspect
import operator

if sys.version_info[0] < 3:
    # cStringIO is buggy with Python 2.6 (
    # see http://paste.progval.net/show/227/ )
    # and it does not handle unicode objects in Python  2.x
    from StringIO import StringIO
else:
    from cStringIO import StringIO

from . import (conf, ircdb, irclib, ircmsgs, ircutils, log, registry, utils,
        world)
from .utils.iter import any, all
from .i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization()

def _addressed(nick, msg, prefixChars=None, nicks=None,
              prefixStrings=None, whenAddressedByNick=None,
              whenAddressedByNickAtEnd=None):
    def get(group):
        if ircutils.isChannel(target):
            group = group.get(target)
        return group()
    def stripPrefixStrings(payload):
        for prefixString in prefixStrings:
            if payload.startswith(prefixString):
                payload = payload[len(prefixString):].lstrip()
        return payload

    assert msg.command == 'PRIVMSG'
    (target, payload) = msg.args
    if not payload:
        return ''
    if prefixChars is None:
        prefixChars = get(conf.supybot.reply.whenAddressedBy.chars)
    if whenAddressedByNick is None:
        whenAddressedByNick = get(conf.supybot.reply.whenAddressedBy.nick)
    if whenAddressedByNickAtEnd is None:
        r = conf.supybot.reply.whenAddressedBy.nick.atEnd
        whenAddressedByNickAtEnd = get(r)
    if prefixStrings is None:
        prefixStrings = get(conf.supybot.reply.whenAddressedBy.strings)
    # We have to check this before nicks -- try "@google supybot" with supybot
    # and whenAddressedBy.nick.atEnd on to see why.
    if any(payload.startswith, prefixStrings):
        return stripPrefixStrings(payload)
    elif payload[0] in prefixChars:
        return payload[1:].strip()
    if nicks is None:
        nicks = get(conf.supybot.reply.whenAddressedBy.nicks)
        nicks = list(map(ircutils.toLower, nicks))
    else:
        nicks = list(nicks) # Just in case.
    nicks.insert(0, ircutils.toLower(nick))
    # Ok, let's see if it's a private message.
    if ircutils.nickEqual(target, nick):
        payload = stripPrefixStrings(payload)
        while payload and payload[0] in prefixChars:
            payload = payload[1:].lstrip()
        return payload
    # Ok, not private.  Does it start with our nick?
    elif whenAddressedByNick:
        for nick in nicks:
            lowered = ircutils.toLower(payload)
            if lowered.startswith(nick):
                try:
                    (maybeNick, rest) = payload.split(None, 1)
                    toContinue = False
                    while not ircutils.isNick(maybeNick, strictRfc=True):
                        if maybeNick[-1].isalnum():
                            toContinue = True
                            break
                        maybeNick = maybeNick[:-1]
                    if toContinue:
                        continue
                    if ircutils.nickEqual(maybeNick, nick):
                        return rest
                    else:
                        continue
                except ValueError: # split didn't work.
                    continue
            elif whenAddressedByNickAtEnd and lowered.endswith(nick):
                rest = payload[:-len(nick)]
                possiblePayload = rest.rstrip(' \t,;')
                if possiblePayload != rest:
                    # There should be some separator between the nick and the
                    # previous alphanumeric character.
                    return possiblePayload
    if get(conf.supybot.reply.whenNotAddressed):
        return payload
    else:
        return ''

def addressed(nick, msg, **kwargs):
    """If msg is addressed to 'name', returns the portion after the address.
    Otherwise returns the empty string.
    """
    payload = msg.addressed
    if payload is not None:
        return payload
    else:
        payload = _addressed(nick, msg, **kwargs)
        msg.tag('addressed', payload)
        return payload

def canonicalName(command, preserve_spaces=False):
    """Turn a command into its canonical form.

    Currently, this makes everything lowercase and removes all dashes and
    underscores.
    """
    if sys.version_info[0] < 3 and isinstance(command, unicode):
        command = command.encode('utf-8')
    elif sys.version_info[0] >= 3 and isinstance(command, bytes):
        command = command.decode()
    special = '\t-_'
    if not preserve_spaces:
        special += ' '
    reAppend = ''
    while command and command[-1] in special:
        reAppend = command[-1] + reAppend
        command = command[:-1]
    return ''.join([x for x in command if x not in special]).lower() + reAppend

def reply(msg, s, prefixNick=None, private=None,
          notice=None, to=None, action=None, error=False):
    msg.tag('repliedTo')
    # Ok, let's make the target:
    # XXX This isn't entirely right.  Consider to=#foo, private=True.
    target = ircutils.replyTo(msg)
    if ircutils.isChannel(to):
        target = to
    if ircutils.isChannel(target):
        channel = target
    else:
        channel = None
    if notice is None:
        notice = conf.get(conf.supybot.reply.withNotice, channel)
    if private is None:
        private = conf.get(conf.supybot.reply.inPrivate, channel)
    if prefixNick is None:
        prefixNick = conf.get(conf.supybot.reply.withNickPrefix, channel)
    if error:
        notice =conf.get(conf.supybot.reply.error.withNotice, channel) or notice
        private=conf.get(conf.supybot.reply.error.inPrivate, channel) or private
        s = _('Error: ') + s
    if private:
        prefixNick = False
        if to is None:
            target = msg.nick
        else:
            target = to
    if action:
        prefixNick = False
    if to is None:
        to = msg.nick
    # Ok, now let's make the payload:
    s = ircutils.safeArgument(s)
    if not s and not action:
        s = _('Error: I tried to send you an empty message.')
    if prefixNick and ircutils.isChannel(target):
        # Let's may sure we don't do, "#channel: foo.".
        if not ircutils.isChannel(to):
            s = '%s: %s' % (to, s)
    if not ircutils.isChannel(target):
        if conf.supybot.reply.withNoticeWhenPrivate():
            notice = True
    # And now, let's decide whether it's a PRIVMSG or a NOTICE.
    msgmaker = ircmsgs.privmsg
    if notice:
        msgmaker = ircmsgs.notice
    # We don't use elif here because actions can't be sent as NOTICEs.
    if action:
        msgmaker = ircmsgs.action
    # Finally, we'll return the actual message.
    ret = msgmaker(target, s)
    ret.tag('inReplyTo', msg)
    return ret

def error(msg, s, **kwargs):
    """Makes an error reply to msg with the appropriate error payload."""
    kwargs['error'] = True
    msg.tag('isError')
    return reply(msg, s, **kwargs)

def getHelp(method, name=None, doc=None):
    if name is None:
        name = method.__name__
    if doc is None:
        if method.__doc__ is None:
            doclines = ['This command has no help.  Complain to the author.']
        else:
            doclines = method.__doc__.splitlines()
    else:
        doclines = doc.splitlines()
    s = '%s %s' % (name, doclines.pop(0))
    if doclines:
        help = ' '.join(doclines)
        s = '(%s) -- %s' % (ircutils.bold(s), help)
    return utils.str.normalizeWhitespace(s)

def getSyntax(method, name=None, doc=None):
    if name is None:
        name = method.__name__
    if doc is None:
        doclines = method.__doc__.splitlines()
    else:
        doclines = doc.splitlines()
    return '%s %s' % (name, doclines[0])

class Error(Exception):
    """Generic class for errors in Privmsg callbacks."""
    pass

class ArgumentError(Error):
    """The bot replies with a help message when this is raised."""
    pass

class SilentError(Error):
    """An error that we should not notify the user."""
    pass

class Tokenizer(object):
    # This will be used as a global environment to evaluate strings in.
    # Evaluation is, of course, necessary in order to allow escaped
    # characters to be properly handled.
    #
    # These are the characters valid in a token.  Everything printable except
    # double-quote, left-bracket, and right-bracket.
    separators = '\x00\r\n \t'
    def __init__(self, brackets='', pipe=False, quotes='"'):
        if brackets:
            self.separators += brackets
            self.left = brackets[0]
            self.right = brackets[1]
        else:
            self.left = ''
            self.right = ''
        self.pipe = pipe
        if self.pipe:
            self.separators += '|'
        self.quotes = quotes
        self.separators += quotes


    def _handleToken(self, token):
        if token[0] == token[-1] and token[0] in self.quotes:
            token = token[1:-1]
            # FIXME: No need to tell you this is a hack.
            # It has to handle both IRC commands and serialized configuration.
            #
            # Whoever you are, if you make a single modification to this
            # code, TEST the code with Python 2 & 3, both with the unit
            # tests and on IRC with this: @echo "好"
            if sys.version_info[0] < 3:
                try:
                    token = token.encode('utf8').decode('string_escape')
                    token = token.decode('utf8')
                except:
                    token = token.decode('string_escape')
            else:
                token = codecs.getencoder('utf8')(token)[0]
                token = codecs.getdecoder('unicode_escape')(token)[0]
                try:
                    token = token.encode('iso-8859-1').decode()
                except: # Prevent issue with tokens like '"\\x80"'.
                    pass
        return token

    def _insideBrackets(self, lexer):
        ret = []
        while True:
            token = lexer.get_token()
            if not token:
                raise SyntaxError(_('Missing "%s".  You may want to '
                                   'quote your arguments with double '
                                   'quotes in order to prevent extra '
                                   'brackets from being evaluated '
                                   'as nested commands.') % self.right)
            elif token == self.right:
                return ret
            elif token == self.left:
                ret.append(self._insideBrackets(lexer))
            else:
                ret.append(self._handleToken(token))
            firstToken = False
        return ret

    def tokenize(self, s):
        lexer = shlex.shlex(StringIO(s))
        lexer.commenters = ''
        lexer.quotes = self.quotes
        lexer.separators = self.separators
        args = []
        ends = []
        while True:
            token = lexer.get_token()
            if not token:
                break
            elif token == '|' and self.pipe:
                # The "and self.pipe" might seem redundant here, but it's there
                # for strings like 'foo | bar', where a pipe stands alone as a
                # token, but shouldn't be treated specially.
                if not args:
                    raise SyntaxError(_('"|" with nothing preceding.  I '
                                       'obviously can\'t do a pipe with '
                                       'nothing before the |.'))
                ends.append(args)
                args = []
            elif token == self.left:
                args.append(self._insideBrackets(lexer))
            elif token == self.right:
                raise SyntaxError(_('Spurious "%s".  You may want to '
                                   'quote your arguments with double '
                                   'quotes in order to prevent extra '
                                   'brackets from being evaluated '
                                   'as nested commands.') % self.right)
            else:
                args.append(self._handleToken(token))
        if ends:
            if not args:
                raise SyntaxError(_('"|" with nothing following.  I '
                                   'obviously can\'t do a pipe with '
                                   'nothing after the |.'))
            args.append(ends.pop())
            while ends:
                args[-1].append(ends.pop())
        return args

def tokenize(s, channel=None):
    """A utility function to create a Tokenizer and tokenize a string."""
    pipe = False
    brackets = ''
    nested = conf.supybot.commands.nested
    if nested():
        brackets = conf.get(nested.brackets, channel)
        if conf.get(nested.pipeSyntax, channel): # No nesting, no pipe.
            pipe = True
    quotes = conf.get(conf.supybot.commands.quotes, channel)
    start = time.time()
    try:
        ret = Tokenizer(brackets=brackets,pipe=pipe,quotes=quotes).tokenize(s)
        return ret
    except ValueError as e:
        raise SyntaxError(str(e))

def formatCommand(command):
    return ' '.join(command)

def checkCommandCapability(msg, cb, commandName):
    assert isinstance(commandName, basestring), commandName
    plugin = cb.name().lower()
    pluginCommand = '%s.%s' % (plugin, commandName)
    def checkCapability(capability):
        assert ircdb.isAntiCapability(capability)
        if ircdb.checkCapability(msg.prefix, capability):
            log.info('Preventing %s from calling %s because of %s.',
                     msg.prefix, pluginCommand, capability)
            raise RuntimeError(capability)
    try:
        antiPlugin = ircdb.makeAntiCapability(plugin)
        antiCommand = ircdb.makeAntiCapability(commandName)
        antiPluginCommand = ircdb.makeAntiCapability(pluginCommand)
        checkCapability(antiPlugin)
        checkCapability(antiCommand)
        checkCapability(antiPluginCommand)
        checkAtEnd = [commandName, pluginCommand]
        default = conf.supybot.capabilities.default()
        if ircutils.isChannel(msg.args[0]):
            channel = msg.args[0]
            checkCapability(ircdb.makeChannelCapability(channel, antiCommand))
            checkCapability(ircdb.makeChannelCapability(channel, antiPlugin))
            checkCapability(ircdb.makeChannelCapability(channel,
                                                        antiPluginCommand))
            chanPlugin = ircdb.makeChannelCapability(channel, plugin)
            chanCommand = ircdb.makeChannelCapability(channel, commandName)
            chanPluginCommand = ircdb.makeChannelCapability(channel,
                                                            pluginCommand)
            checkAtEnd += [chanCommand, chanPlugin, chanPluginCommand]
            default &= ircdb.channels.getChannel(channel).defaultAllow
        return not (default or \
                    any(lambda x: ircdb.checkCapability(msg.prefix, x),
                        checkAtEnd))
    except RuntimeError as e:
        s = ircdb.unAntiCapability(str(e))
        return s


class RichReplyMethods(object):
    """This is a mixin so these replies need only be defined once.  It operates
    under several assumptions, including the fact that 'self' is an Irc object
    of some sort and there is a self.msg that is an IrcMsg."""
    def __makeReply(self, prefix, s):
        if s:
            s = '%s  %s' % (prefix, s)
        else:
            s = prefix
        return ircutils.standardSubstitute(self, self.msg, s)

    def _getConfig(self, wrapper):
        return conf.get(wrapper, self.msg.args[0])

    def replySuccess(self, s='', **kwargs):
        v = self._getConfig(conf.supybot.replies.success)
        if v:
            s = self.__makeReply(v, s)
            return self.reply(s, **kwargs)
        else:
            self.noReply()

    def replyError(self, s='', **kwargs):
        v = self._getConfig(conf.supybot.replies.error)
        if 'msg' in kwargs:
            msg = kwargs['msg']
            if ircdb.checkCapability(msg.prefix, 'owner'):
                v = self._getConfig(conf.supybot.replies.errorOwner)
        s = self.__makeReply(v, s)
        return self.reply(s, **kwargs)

    def replies(self, L, prefixer=None, joiner=None,
                onlyPrefixFirst=False, to=None,
                oneToOne=None, **kwargs):
        if prefixer is None:
            prefixer = ''
        if joiner is None:
            joiner = utils.str.commaAndify
        if isinstance(prefixer, basestring):
            prefixer = prefixer.__add__
        if isinstance(joiner, basestring):
            joiner = joiner.join
        if oneToOne is None: # Can be True, False, or None
            if ircutils.isChannel(to):
                oneToOne = conf.get(conf.supybot.reply.oneToOne, to)
            else:
                oneToOne = conf.supybot.reply.oneToOne()
        if oneToOne:
            return self.reply(prefixer(joiner(L)), to=to, **kwargs)
        else:
            msg = None
            first = True
            for s in L:
                if onlyPrefixFirst:
                    if first:
                        first = False
                        msg = self.reply(prefixer(s), to=to, **kwargs)
                    else:
                        msg = self.reply(s, to=to, **kwargs)
                else:
                    msg = self.reply(prefixer(s), to=to, **kwargs)
            return msg

    def noReply(self):
        self.repliedTo = True

    def _error(self, s, Raise=False, **kwargs):
        if Raise:
            raise Error(s)
        else:
            return self.error(s, **kwargs)

    def errorNoCapability(self, capability, s='', **kwargs):
        if 'Raise' not in kwargs:
            kwargs['Raise'] = True
        if isinstance(capability, basestring): # checkCommandCapability!
            log.warning('Denying %s for lacking %q capability.',
                        self.msg.prefix, capability)
            # noCapability means "don't send a specific capability error
            # message" not "don't send a capability error message at all", like
            # one would think
            if self._getConfig(conf.supybot.reply.error.noCapability) or \
                capability in conf.supybot.capabilities.private():
                v = self._getConfig(conf.supybot.replies.genericNoCapability)
            else:
                v = self._getConfig(conf.supybot.replies.noCapability)
                try:
                    v %= capability
                except TypeError: # No %s in string
                    pass
            s = self.__makeReply(v, s)
            if s:
                return self._error(s, **kwargs)
        else:
            log.warning('Denying %s for some unspecified capability '
                        '(or a default).', self.msg.prefix)
            v = self._getConfig(conf.supybot.replies.genericNoCapability)
            return self._error(self.__makeReply(v, s), **kwargs)

    def errorPossibleBug(self, s='', **kwargs):
        v = self._getConfig(conf.supybot.replies.possibleBug)
        if s:
            s += '  (%s)' % v
        else:
            s = v
        return self._error(s, **kwargs)

    def errorNotRegistered(self, s='', **kwargs):
        v = self._getConfig(conf.supybot.replies.notRegistered)
        return self._error(self.__makeReply(v, s), **kwargs)

    def errorNoUser(self, s='', name='that user', **kwargs):
        if 'Raise' not in kwargs:
            kwargs['Raise'] = True
        v = self._getConfig(conf.supybot.replies.noUser)
        try:
            v = v % name
        except TypeError:
            log.warning('supybot.replies.noUser should have one "%s" in it.')
        return self._error(self.__makeReply(v, s), **kwargs)

    def errorRequiresPrivacy(self, s='', **kwargs):
        v = self._getConfig(conf.supybot.replies.requiresPrivacy)
        return self._error(self.__makeReply(v, s), **kwargs)

    def errorInvalid(self, what, given=None, s='', repr=True, **kwargs):
        if given is not None:
            if repr:
                given = _repr(given)
            else:
                given = '"%s"' % given
            v = _('%s is not a valid %s.') % (given, what)
        else:
            v = _('That\'s not a valid %s.') % what
        if 'Raise' not in kwargs:
            kwargs['Raise'] = True
        return self._error(self.__makeReply(v, s), **kwargs)

_repr = repr

class ReplyIrcProxy(RichReplyMethods):
    """This class is a thin wrapper around an irclib.Irc object that gives it
    the reply() and error() methods (as well as everything in RichReplyMethods,
    based on those two)."""
    def __init__(self, irc, msg):
        self.irc = irc
        self.msg = msg

    def getRealIrc(self):
        """Returns the real irclib.Irc object underlying this proxy chain."""
        if isinstance(self.irc, irclib.Irc):
            return self.irc
        else:
            return self.irc.getRealIrc()

    # This should make us be considered equal to our irclib.Irc object for
    # hashing; an important thing (no more "too many open files" exceptions :))
    def __hash__(self):
        return hash(self.getRealIrc())
    def __eq__(self, other):
        return self.getRealIrc() == other
    __req__ = __eq__
    def __ne__(self, other):
        return not (self == other)
    __rne__ = __ne__

    def error(self, s, msg=None, **kwargs):
        if 'Raise' in kwargs and kwargs['Raise']:
            if s:
                raise Error(s)
            else:
                raise ArgumentError
        if msg is None:
            msg = self.msg
        m = error(msg, s, **kwargs)
        self.irc.queueMsg(m)
        return m

    def reply(self, s, msg=None, **kwargs):
        if msg is None:
            msg = self.msg
        assert not isinstance(s, ircmsgs.IrcMsg), \
               'Old code alert: there is no longer a "msg" argument to reply.'
        kwargs.pop('noLengthCheck', None)
        m = reply(msg, s, **kwargs)
        self.irc.queueMsg(m)
        return m

    def __getattr__(self, attr):
        return getattr(self.irc, attr)

SimpleProxy = ReplyIrcProxy # Backwards-compatibility

class NestedCommandsIrcProxy(ReplyIrcProxy):
    "A proxy object to allow proper nesting of commands (even threaded ones)."
    _mores = ircutils.IrcDict()
    def __init__(self, irc, msg, args, nested=0):
        assert isinstance(args, list), 'Args should be a list, not a string.'
        self.irc = irc
        self.msg = msg
        self.nested = nested
        self.repliedTo = False
        if not self.nested and isinstance(irc, self.__class__):
            # This means we were given an NestedCommandsIrcProxy instead of an
            # irclib.Irc, and so we're obviously nested.  But nested wasn't
            # set!  So we take our given Irc's nested value.
            self.nested += irc.nested
        maxNesting = conf.supybot.commands.nested.maximum()
        if maxNesting and self.nested > maxNesting:
            log.warning('%s attempted more than %s levels of nesting.',
                        self.msg.prefix, maxNesting)
            self.error(_('You\'ve attempted more nesting than is '
                              'currently allowed on this bot.'))
        # The deepcopy here is necessary for Scheduler; it re-runs already
        # tokenized commands.  There's a possibility a simple copy[:] would
        # work, but we're being careful.
        self.args = copy.deepcopy(args)
        self.counter = 0
        self._resetReplyAttributes()
        if not args:
            self.finalEvaled = True
            self._callInvalidCommands()
        else:
            self.finalEvaled = False
            world.commandsProcessed += 1
            self.evalArgs()

    def __eq__(self, other):
        return other == self.getRealIrc()

    def __hash__(self):
        return hash(self.getRealIrc())

    def _resetReplyAttributes(self):
        self.to = None
        self.action = None
        self.notice = None
        self.private = None
        self.noLengthCheck = None
        if ircutils.isChannel(self.msg.args[0]):
            self.prefixNick = conf.get(conf.supybot.reply.withNickPrefix,
                                       self.msg.args[0])
        else:
            self.prefixNick = conf.supybot.reply.withNickPrefix()

    def evalArgs(self):
        while self.counter < len(self.args):
            self.repliedTo = False
            if isinstance(self.args[self.counter], basestring):
                # If it's a string, just go to the next arg.  There is no
                # evaluation to be done for strings.  If, at some point,
                # we decided to, say, convert every string using
                # ircutils.standardSubstitute, this would be where we would
                # probably put it.
                self.counter += 1
            else:
                assert isinstance(self.args[self.counter], list)
                # It's a list.  So we spawn another NestedCommandsIrcProxy
                # to evaluate its args.  When that class has finished
                # evaluating its args, it will call our reply method, which
                # will subsequently call this function again, and we'll
                # pick up where we left off via self.counter.
                self.__class__(self, self.msg,
                               self.args[self.counter], nested=self.nested+1)
                # We have to return here because the new NestedCommandsIrcProxy
                # might not have called our reply method instantly, since
                # its command might be threaded.  So (obviously) we can't
                # just fall through to self.finalEval.
                return
        # Once all the list args are evaluated, we then evaluate our own
        # list of args, since we're assured that they're all strings now.
        assert all(lambda x: isinstance(x, basestring), self.args)
        self.finalEval()

    def _callInvalidCommands(self):
        log.debug('Calling invalidCommands.')
        threaded = False
        cbs = []
        for cb in self.irc.callbacks:
            if hasattr(cb, 'invalidCommand'):
                cbs.append(cb)
                threaded = threaded or cb.threaded
        def callInvalidCommands():
            self.repliedTo = False
            for cb in cbs:
                log.debug('Calling %s.invalidCommand.', cb.name())
                try:
                    cb.invalidCommand(self, self.msg, self.args)
                except Error as e:
                    self.error(str(e))
                except Exception as e:
                    log.exception('Uncaught exception in %s.invalidCommand.',
                                  cb.name())
                log.debug('Finished calling %s.invalidCommand.', cb.name())
                if self.repliedTo:
                    log.debug('Done calling invalidCommands: %s.',cb.name())
                    return
        if threaded:
            name = 'Thread #%s (for invalidCommands)' % world.threadsSpawned
            t = world.SupyThread(target=callInvalidCommands, name=name)
            t.setDaemon(True)
            t.start()
        else:
            callInvalidCommands()

    def findCallbacksForArgs(self, args):
        """Returns a two-tuple of (command, plugins) that has the command
        (a list of strings) and the plugins for which it was a command."""
        assert isinstance(args, list)
        args = list(map(canonicalName, args))
        cbs = []
        maxL = []
        for cb in self.irc.callbacks:
            if not hasattr(cb, 'getCommand'):
                continue
            L = cb.getCommand(args)
            #log.debug('%s.getCommand(%r) returned %r', cb.name(), args, L)
            if L and L >= maxL:
                maxL = L
                cbs.append((cb, L))
                assert isinstance(L, list), \
                       'getCommand now returns a list, not a method.'
                assert utils.iter.startswith(L, args), \
                       'getCommand must return a prefix of the args given.  ' \
                       '(args given: %r, returned: %r)' % (args, L)
        log.debug('findCallbacksForArgs: %r', cbs)
        cbs = [cb for (cb, L) in cbs if L == maxL]
        if len(maxL) == 1:
            # Special case: one arg determines the callback.  In this case, we
            # have to check, in order:
            # 1. Whether the arg is the same as the name of a callback.  This
            #    callback would then win.
            for cb in cbs:
                if cb.canonicalName() == maxL[0]:
                    return (maxL, [cb])

            # 2. Whether a defaultplugin is defined.
            defaultPlugins = conf.supybot.commands.defaultPlugins
            try:
                defaultPlugin = defaultPlugins.get(maxL[0])()
                log.debug('defaultPlugin: %r', defaultPlugin)
                if defaultPlugin:
                    cb = self.irc.getCallback(defaultPlugin)
                    if cb in cbs:
                        # This is just a sanity check, but there's a small
                        # possibility that a default plugin for a command
                        # is configured to point to a plugin that doesn't
                        # actually have that command.
                        return (maxL, [cb])
            except registry.NonExistentRegistryEntry:
                pass

            # 3. Whether an importantPlugin is one of the responses.
            important = defaultPlugins.importantPlugins()
            important = list(map(canonicalName, important))
            importants = []
            for cb in cbs:
                if cb.canonicalName() in important:
                    importants.append(cb)
            if len(importants) == 1:
                return (maxL, importants)
        return (maxL, cbs)

    def finalEval(self):
        # Now that we've already iterated through our args and made sure
        # that any list of args was evaluated (by spawning another
        # NestedCommandsIrcProxy to evaluated it into a string), we can finally
        # evaluated our own list of arguments.
        assert not self.finalEvaled, 'finalEval called twice.'
        self.finalEvaled = True
        # Now, the way we call a command is we iterate over the loaded pluings,
        # asking each one if the list of args we have interests it.  The
        # way we do that is by calling getCommand on the plugin.
        # The plugin will return a list of args which it considers to be
        # "interesting."  We will then give our args to the plugin which
        # has the *longest* list.  The reason we pick the longest list is
        # that it seems reasonable that the longest the list, the more
        # specific the command is.  That is, given a list of length X, a list
        # of length X+1 would be even more specific (assuming that both lists
        # used the same prefix. Of course, if two plugins return a list of the
        # same length, we'll just error out with a message about ambiguity.
        (command, cbs) = self.findCallbacksForArgs(self.args)
        if not cbs:
            # We used to handle addressedRegexps here, but I think we'll let
            # them handle themselves in getCommand.  They can always just
            # return the full list of args as their "command".
            self._callInvalidCommands()
        elif len(cbs) > 1:
            names = sorted([cb.name() for cb in cbs])
            command = formatCommand(command)
            self.error(format(_('The command %q is available in the %L '
                              'plugins.  Please specify the plugin '
                              'whose command you wish to call by using '
                              'its name as a command before %q.'),
                              command, names, command))
        else:
            cb = cbs[0]
            args = self.args[len(command):]
            if world.isMainThread() and \
               (cb.threaded or conf.supybot.debug.threadAllCommands()):
                t = CommandThread(target=cb._callCommand,
                                  args=(command, self, self.msg, args))
                t.start()
            else:
                cb._callCommand(command, self, self.msg, args)

    def reply(self, s, noLengthCheck=False, prefixNick=None,
              action=None, private=None, notice=None, to=None, msg=None):
        """
        Keyword arguments:

        * `noLengthCheck=False`: True if the length shouldn't be checked
                                 (used for 'more' handling)
        * `prefixNick=True`:     False if the nick shouldn't be prefixed to the
                                 reply.
        * `action=False`:        True if the reply should be an action.
        * `private=False`:       True if the reply should be in private.
        * `notice=False`:        True if the reply should be noticed when the
                                 bot is configured to do so.
        * `to=<nick|channel>`:   The nick or channel the reply should go to.
                                 Defaults to msg.args[0] (or msg.nick if private)
        """
        # These use and or or based on whether or not they default to True or
        # False.  Those that default to True use and; those that default to
        # False use or.
        assert not isinstance(s, ircmsgs.IrcMsg), \
               'Old code alert: there is no longer a "msg" argument to reply.'
        self.repliedTo = True
        if msg is None:
            msg = self.msg
        if prefixNick is not None:
            self.prefixNick = prefixNick
        if action is not None:
            self.action = self.action or action
            if action:
                self.prefixNick = False
        if notice is not None:
            self.notice = self.notice or notice
        if private is not None:
            self.private = self.private or private
        if to is not None:
            self.to = self.to or to
        # action=True implies noLengthCheck=True and prefixNick=False
        self.noLengthCheck=noLengthCheck or self.noLengthCheck or self.action
        target = self.private and self.to or self.msg.args[0]
        if not isinstance(s, basestring): # avoid trying to str() unicode
            s = str(s) # Allow non-string esses.
        if self.finalEvaled:
            try:
                if isinstance(self.irc, self.__class__):
                    s = s[:conf.supybot.reply.maximumLength()]
                    return self.irc.reply(s, to=self.to,
                                          notice=self.notice,
                                          action=self.action,
                                          private=self.private,
                                          prefixNick=self.prefixNick,
                                          noLengthCheck=self.noLengthCheck)
                elif self.noLengthCheck:
                    # noLengthCheck only matters to NestedCommandsIrcProxy, so
                    # it's not used here.  Just in case you were wondering.
                    m = reply(msg, s, to=self.to,
                              notice=self.notice,
                              action=self.action,
                              private=self.private,
                              prefixNick=self.prefixNick)
                    self.irc.queueMsg(m)
                    return m
                else:
                    s = ircutils.safeArgument(s)
                    allowedLength = conf.get(conf.supybot.reply.mores.length,
                                             target)
                    if not allowedLength: # 0 indicates this.
                        allowedLength = 470 - len(self.irc.prefix)
                        allowedLength -= len(msg.nick)
                        # The '(XX more messages)' may have not the same
                        # length in the current locale
                        allowedLength -= len(_('(XX more messages)'))
                    maximumMores = conf.get(conf.supybot.reply.mores.maximum,
                                            target)
                    maximumLength = allowedLength * maximumMores
                    if len(s) > maximumLength:
                        log.warning('Truncating to %s bytes from %s bytes.',
                                    maximumLength, len(s))
                        s = s[:maximumLength]
                    if len(s) < allowedLength or \
                       not conf.get(conf.supybot.reply.mores, target):
                        # In case we're truncating, we add 20 to allowedLength,
                        # because our allowedLength is shortened for the
                        # "(XX more messages)" trailer.
                        s = s[:allowedLength+len(_('(XX more messages)'))]
                        # There's no need for action=self.action here because
                        # action implies noLengthCheck, which has already been
                        # handled.  Let's stick an assert in here just in case.
                        assert not self.action
                        m = reply(msg, s, to=self.to,
                                  notice=self.notice,
                                  private=self.private,
                                  prefixNick=self.prefixNick)
                        self.irc.queueMsg(m)
                        return m
                    msgs = ircutils.wrap(s, allowedLength,
                            break_long_words=True)
                    msgs.reverse()
                    instant = conf.get(conf.supybot.reply.mores.instant,target)
                    while instant > 1 and msgs:
                        instant -= 1
                        response = msgs.pop()
                        m = reply(msg, response, to=self.to,
                                  notice=self.notice,
                                  private=self.private,
                                  prefixNick=self.prefixNick)
                        self.irc.queueMsg(m)
                        # XXX We should somehow allow these to be returned, but
                        #     until someone complains, we'll be fine :)  We
                        #     can't return from here, though, for obvious
                        #     reasons.
                        # return m
                    if not msgs:
                        return
                    response = msgs.pop()
                    if msgs:
                        if len(msgs) == 1:
                            more = _('more message')
                        else:
                            more = _('more messages')
                        n = ircutils.bold('(%i %s)' % (len(msgs), more))
                        response = '%s %s' % (response, n)
                    prefix = msg.prefix
                    if self.to and ircutils.isNick(self.to):
                        try:
                            state = self.getRealIrc().state
                            prefix = state.nickToHostmask(self.to)
                        except KeyError:
                            pass # We'll leave it as it is.
                    mask = prefix.split('!', 1)[1]
                    self._mores[mask] = msgs
                    public = ircutils.isChannel(msg.args[0])
                    private = self.private or not public
                    self._mores[msg.nick] = (private, msgs)
                    m = reply(msg, response, to=self.to,
                                            action=self.action,
                                            notice=self.notice,
                                            private=self.private,
                                            prefixNick=self.prefixNick)
                    self.irc.queueMsg(m)
                    return m
            finally:
                self._resetReplyAttributes()
        else:
            if msg.ignored:
                # Since the final reply string is constructed via
                # ' '.join(self.args), the args index for ignored commands
                # needs to be popped to avoid extra spaces in the final reply.
                self.args.pop(self.counter)
                msg.tag('ignored', False)
            else:
                self.args[self.counter] = s
            self.evalArgs()

    def error(self, s='', Raise=False, **kwargs):
        self.repliedTo = True
        if Raise:
            if s:
                raise Error(s)
            else:
                raise ArgumentError
        if s:
            if not isinstance(self.irc, irclib.Irc):
                return self.irc.error(s, **kwargs)
            else:
                m = error(self.msg, s, **kwargs)
                self.irc.queueMsg(m)
                return m
        else:
            raise ArgumentError

    def __getattr__(self, attr):
        return getattr(self.irc, attr)

IrcObjectProxy = NestedCommandsIrcProxy

class CommandThread(world.SupyThread):
    """Just does some extra logging and error-recovery for commands that need
    to run in threads.
    """
    def __init__(self, target=None, args=(), kwargs={}):
        self.command = args[0]
        self.cb = target.im_self
        threadName = 'Thread #%s (for %s.%s)' % (world.threadsSpawned,
                                                 self.cb.name(),
                                                 self.command)
        log.debug('Spawning thread %s (args: %r)', threadName, args)
        self.__parent = super(CommandThread, self)
        self.__parent.__init__(target=target, name=threadName,
                               args=args, kwargs=kwargs)
        self.setDaemon(True)
        self.originalThreaded = self.cb.threaded
        self.cb.threaded = True

    def run(self):
        try:
            self.__parent.run()
        finally:
            self.cb.threaded = self.originalThreaded

class CommandProcess(world.SupyProcess):
    """Just does some extra logging and error-recovery for commands that need
    to run in processes.
    """
    def __init__(self, target=None, args=(), kwargs={}):
        pn = kwargs.pop('pn', 'Unknown')
        cn = kwargs.pop('cn', 'unknown')
        procName = 'Process #%s (for %s.%s)' % (world.processesSpawned,
                                                 pn,
                                                 cn)
        log.debug('Spawning process %s (args: %r)', procName, args)
        self.__parent = super(CommandProcess, self)
        self.__parent.__init__(target=target, name=procName,
                               args=args, kwargs=kwargs)

    def run(self):
        self.__parent.run()

class CanonicalString(registry.NormalizedString):
    def normalize(self, s):
        return canonicalName(s)

class CanonicalNameSet(utils.NormalizingSet):
    def normalize(self, s):
        return canonicalName(s)

class CanonicalNameDict(utils.InsensitivePreservingDict):
    def key(self, s):
        return canonicalName(s)

class Disabled(registry.SpaceSeparatedListOf):
    sorted = True
    Value = CanonicalString
    List = CanonicalNameSet

conf.registerGlobalValue(conf.supybot.commands, 'disabled',
    Disabled([], _("""Determines what commands are currently disabled.  Such
    commands will not appear in command lists, etc.  They will appear not even
    to exist.""")))

class DisabledCommands(object):
    def __init__(self):
        self.d = CanonicalNameDict()
        for name in conf.supybot.commands.disabled():
            if '.' in name:
                (plugin, command) = name.split('.', 1)
                if command in self.d:
                    if self.d[command] is not None:
                        self.d[command].add(plugin)
                else:
                    self.d[command] = CanonicalNameSet([plugin])
            else:
                self.d[name] = None

    def disabled(self, command, plugin=None):
        if command in self.d:
            if self.d[command] is None:
                return True
            elif plugin in self.d[command]:
                return True
        return False

    def add(self, command, plugin=None):
        if plugin is None:
            self.d[command] = None
        else:
            if command in self.d:
                if self.d[command] is not None:
                    self.d[command].add(plugin)
            else:
                self.d[command] = CanonicalNameSet([plugin])

    def remove(self, command, plugin=None):
        if plugin is None:
            del self.d[command]
        else:
            if self.d[command] is not None:
                self.d[command].remove(plugin)

class BasePlugin(object):
    def __init__(self, *args, **kwargs):
        self.cbs = []
        for attr in dir(self):
            if attr != canonicalName(attr):
                continue
            obj = getattr(self, attr)
            if isinstance(obj, type) and issubclass(obj, BasePlugin):
                cb = obj(*args, **kwargs)
                setattr(self, attr, cb)
                self.cbs.append(cb)
                cb.log = log.getPluginLogger('%s.%s' % (self.name(),cb.name()))
        super(BasePlugin, self).__init__()

class SynchronizedAndFirewalled(log.MetaFirewall, utils.python.Synchronized):
    pass # Necessary for the metaclass compatibility issue.

class Commands(BasePlugin):
    __metaclass__ = SynchronizedAndFirewalled
    __synchronized__ = (
        '__call__',
        'callCommand',
        'invalidCommand',
        )
    # For a while, a comment stood here to say, "Eventually callCommand."  But
    # that's wrong, because we can't do generic error handling in this
    # callCommand -- plugins need to be able to override callCommand and do
    # error handling there (see the Web plugin for an example).
    __firewalled__ = {'isCommand': None,
                      '_callCommand': None}
    commandArgs = ['self', 'irc', 'msg', 'args']
    # These must be class-scope, so all plugins use the same one.
    _disabled = DisabledCommands()
    pre_command_callbacks = []
    def name(self):
        return self.__class__.__name__

    def canonicalName(self):
        return canonicalName(self.name())

    def isDisabled(self, command):
        return self._disabled.disabled(command, self.name())

    def isCommandMethod(self, name):
        """Returns whether a given method name is a command in this plugin."""
        # This function is ugly, but I don't want users to call methods like
        # doPrivmsg or __init__ or whatever, and this is good to stop them.

        # Don't normalize this name: consider outFilter(self, irc, msg).
        # name = canonicalName(name)
        if self.isDisabled(name):
            return False
        if name != canonicalName(name):
            return False
        if hasattr(self, name):
            method = getattr(self, name)
            if inspect.ismethod(method):
                code = method.im_func.__code__
                return inspect.getargs(code)[0] == self.commandArgs
            else:
                return False
        else:
            return False

    def isCommand(self, command):
        """Convenience, backwards-compatibility, semi-deprecated."""
        if isinstance(command, basestring):
            return self.isCommandMethod(command)
        else:
            # Since we're doing a little type dispatching here, let's not be
            # too liberal.
            assert isinstance(command, list)
            return self.getCommand(command) == command

    def getCommand(self, args, stripOwnName=True):
        assert args == list(map(canonicalName, args))
        first = args[0]
        for cb in self.cbs:
            if first == cb.canonicalName():
                return cb.getCommand(args)
        if first == self.canonicalName() and len(args) > 1 and \
                stripOwnName:
            ret = self.getCommand(args[1:], stripOwnName=False)
            if ret:
                return [first] + ret
        if self.isCommandMethod(first):
            return [first]
        return []

    def getCommandMethod(self, command):
        """Gets the given command from this plugin."""
        #print '*** %s.getCommandMethod(%r)' % (self.name(), command)
        assert not isinstance(command, basestring)
        assert command == list(map(canonicalName, command))
        assert self.getCommand(command) == command
        for cb in self.cbs:
            if command[0] == cb.canonicalName():
                return cb.getCommandMethod(command)
        if len(command) > 1:
            assert command[0] == self.canonicalName()
            return self.getCommandMethod(command[1:])
        else:
            method = getattr(self, command[0])
            if inspect.ismethod(method):
                code = method.im_func.__code__
                if inspect.getargs(code)[0] == self.commandArgs:
                    return method
                else:
                    raise AttributeError

    def listCommands(self, pluginCommands=[]):
        commands = set(pluginCommands)
        for s in dir(self):
            if self.isCommandMethod(s):
                commands.add(s)
        for cb in self.cbs:
            name = cb.canonicalName()
            for command in cb.listCommands():
                if command == name:
                    commands.add(command)
                else:
                    commands.add(' '.join([name, command]))
        L = list(commands)
        L.sort()
        return L

    def callCommand(self, command, irc, msg, *args, **kwargs):
        # We run all callbacks before checking if one of them returned True
        if any(bool, list(cb(self, command, irc, msg, *args, **kwargs)
                    for cb in self.pre_command_callbacks)):
            return
        method = self.getCommandMethod(command)
        method(irc, msg, *args, **kwargs)

    def _callCommand(self, command, irc, msg, *args, **kwargs):
        if irc.nick == msg.args[0]:
            self.log.info('%s called in private by %q.', formatCommand(command),
                    msg.prefix)
        else:
            self.log.info('%s called on %s by %q.', formatCommand(command),
                    msg.args[0], msg.prefix)
        # XXX I'm being extra-special-careful here, but we need to refactor
        #     this.
        try:
            for name in command:
                cap = checkCommandCapability(msg, self, name)
                if cap:
                    irc.errorNoCapability(cap)
                    return
            try:
                self.callingCommand = command
                self.callCommand(command, irc, msg, *args, **kwargs)
            finally:
                self.callingCommand = None
        except SilentError:
            pass
        except (getopt.GetoptError, ArgumentError) as e:
            self.log.debug('Got %s, giving argument error.',
                           utils.exnToString(e))
            help = self.getCommandHelp(command)
            if help.endswith('command has no help.'):
                irc.error(_('Invalid arguments for %s.') % method.__name__)
            else:
                irc.reply(help)
        except (SyntaxError, Error) as e:
            self.log.debug('Error return: %s', utils.exnToString(e))
            irc.error(str(e))
        except Exception as e:
            self.log.exception('Uncaught exception in %s.', command)
            if conf.supybot.reply.error.detailed():
                irc.error(utils.exnToString(e))
            else:
                irc.replyError(msg=msg)

    def getCommandHelp(self, command, simpleSyntax=None):
        method = self.getCommandMethod(command)
        help = getHelp
        chan = None
        if dynamic.msg is not None:
            chan = dynamic.msg.args[0]
        if simpleSyntax is None:
            simpleSyntax = conf.get(conf.supybot.reply.showSimpleSyntax, chan)
        if simpleSyntax:
            help = getSyntax
        if hasattr(method, '__doc__'):
            return help(method, name=formatCommand(command))
        else:
            return format(_('The %q command has no help.'),
                          formatCommand(command))

class PluginMixin(BasePlugin, irclib.IrcCallback):
    public = True
    alwaysCall = ()
    threaded = False
    noIgnore = False
    classModule = None
    Proxy = NestedCommandsIrcProxy
    def __init__(self, irc):
        myName = self.name()
        self.log = log.getPluginLogger(myName)
        self.__parent = super(PluginMixin, self)
        self.__parent.__init__(irc)
        # We can't do this because of the specialness that Owner and Misc do.
        # I guess plugin authors will have to get the capitalization right.
        # self.callAfter = map(str.lower, self.callAfter)
        # self.callBefore = map(str.lower, self.callBefore)

    def canonicalName(self):
        return canonicalName(self.name())

    def __call__(self, irc, msg):
        irc = SimpleProxy(irc, msg)
        if msg.command == 'PRIVMSG':
            if self.noIgnore or \
               not ircdb.checkIgnored(msg.prefix, msg.args[0]) or \
               not ircutils.isUserHostmask(msg.prefix):  # Some services impl.
                self.__parent.__call__(irc, msg)
        else:
            self.__parent.__call__(irc, msg)

    def registryValue(self, name, channel=None, value=True):
        plugin = self.name()
        group = conf.supybot.plugins.get(plugin)
        names = registry.split(name)
        for name in names:
            group = group.get(name)
        if channel is not None:
            if ircutils.isChannel(channel):
                group = group.get(channel)
            else:
                self.log.debug('registryValue got channel=%r', channel)
        if value:
            return group()
        else:
            return group

    def setRegistryValue(self, name, value, channel=None):
        plugin = self.name()
        group = conf.supybot.plugins.get(plugin)
        names = registry.split(name)
        for name in names:
            group = group.get(name)
        if channel is None:
            group.setValue(value)
        else:
            group.get(channel).setValue(value)

    def userValue(self, name, prefixOrName, default=None):
        try:
            id = str(ircdb.users.getUserId(prefixOrName))
        except KeyError:
            return None
        plugin = self.name()
        group = conf.users.plugins.get(plugin)
        names = registry.split(name)
        for name in names:
            group = group.get(name)
        return group.get(id)()

    def setUserValue(self, name, prefixOrName, value,
                     ignoreNoUser=True, setValue=True):
        try:
            id = str(ircdb.users.getUserId(prefixOrName))
        except KeyError:
            if ignoreNoUser:
                return
            else:
                raise
        plugin = self.name()
        group = conf.users.plugins.get(plugin)
        names = registry.split(name)
        for name in names:
            group = group.get(name)
        group = group.get(id)
        if setValue:
            group.setValue(value)
        else:
            group.set(value)

    def getPluginHelp(self):
        if hasattr(self, '__doc__'):
            return self.__doc__
        else:
            return None

class Plugin(PluginMixin, Commands):
    pass
Privmsg = Plugin # Backwards compatibility.


class PluginRegexp(Plugin):
    """Same as Plugin, except allows the user to also include regexp-based
    callbacks.  All regexp-based callbacks must be specified in the set (or
    list) attribute "regexps", "addressedRegexps", or "unaddressedRegexps"
    depending on whether they should always be triggered, triggered only when
    the bot is addressed, or triggered only when the bot isn't addressed.
    """
    flags = re.I
    regexps = ()
    """'regexps' methods are called whether the message is addressed or not."""
    addressedRegexps = ()
    """'addressedRegexps' methods are called only when the message is addressed,
    and then, only with the payload (i.e., what is returned from the
    'addressed' function."""
    unaddressedRegexps = ()
    """'unaddressedRegexps' methods are called only when the message is *not*
    addressed."""
    Proxy = SimpleProxy
    def __init__(self, irc):
        self.__parent = super(PluginRegexp, self)
        self.__parent.__init__(irc)
        self.res = []
        self.addressedRes = []
        self.unaddressedRes = []
        for name in self.regexps:
            method = getattr(self, name)
            r = re.compile(method.__doc__, self.flags)
            self.res.append((r, name))
        for name in self.addressedRegexps:
            method = getattr(self, name)
            r = re.compile(method.__doc__, self.flags)
            self.addressedRes.append((r, name))
        for name in self.unaddressedRegexps:
            method = getattr(self, name)
            r = re.compile(method.__doc__, self.flags)
            self.unaddressedRes.append((r, name))

    def _callRegexp(self, name, irc, msg, m):
        method = getattr(self, name)
        try:
            method(irc, msg, m)
        except Error as e:
            irc.error(str(e))
        except Exception as e:
            self.log.exception('Uncaught exception in _callRegexp:')

    def invalidCommand(self, irc, msg, tokens):
        s = ' '.join(tokens)
        for (r, name) in self.addressedRes:
            for m in r.finditer(s):
                self._callRegexp(name, irc, msg, m)

    def doPrivmsg(self, irc, msg):
        if msg.isError:
            return
        proxy = self.Proxy(irc, msg)
        if not msg.addressed:
            for (r, name) in self.unaddressedRes:
                for m in r.finditer(msg.args[1]):
                    self._callRegexp(name, proxy, msg, m)
        for (r, name) in self.res:
            for m in r.finditer(msg.args[1]):
                self._callRegexp(name, proxy, msg, m)
PrivmsgCommandAndRegexp = PluginRegexp


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = cdb
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

"""
Database module, similar to dbhash.  Uses a format similar to (if not entirely
the same as) DJB's CDB <http://cr.yp.to/cdb.html>.
"""

from __future__ import division

import os
import sys
import struct
import os.path
import cPickle as pickle

from . import utils

def hash(s):
    """DJB's hash function for CDB."""
    h = 5381
    for c in s:
        h = ((h + (h << 5)) ^ ord(c)) & 0xFFFFFFFFL
    return h

def unpack2Ints(s):
    """Returns two ints unpacked from the binary string s."""
    return struct.unpack('<LL', s)

def pack2Ints(i, j):
    """Returns a packed binary string from the two ints."""
    return struct.pack('<LL', i, j)

def dump(map, fd=sys.stdout):
    """Dumps a dictionary-structure in CDB format."""
    for (key, value) in map.iteritems():
        fd.write('+%s,%s:%s->%s\n' % (len(key), len(value), key, value))

def open_db(filename, mode='r', **kwargs):
    """Opens a database; used for compatibility with other database modules."""
    if mode == 'r':
        return Reader(filename, **kwargs)
    elif mode == 'w':
        return ReaderWriter(filename, **kwargs)
    elif mode == 'c':
        if os.path.exists(filename):
            return ReaderWriter(filename, **kwargs)
        else:
            maker = Maker(filename)
            maker.finish()
            return ReaderWriter(filename, **kwargs)
    elif mode == 'n':
        maker = Maker(filename)
        maker.finish()
        return ReaderWriter(filename, **kwargs)
    else:
        raise ValueError('Invalid flag: %s' % mode)

def shelf(filename, *args, **kwargs):
    """Opens a new shelf database object."""
    if os.path.exists(filename):
        return Shelf(filename, *args, **kwargs)
    else:
        maker = Maker(filename)
        maker.finish()
        return Shelf(filename, *args, **kwargs)

def _readKeyValue(fd):
    klen = 0
    dlen = 0
    s = initchar = fd.read(1)
    if s == '':
        return (None, None, None)
    s = fd.read(1)
    while s != ',':
        klen = 10 * klen + int(s)
        s = fd.read(1)
    s = fd.read(1)
    while s != ':':
        dlen = 10 * dlen + int(s)
        s = fd.read(1)
    key = fd.read(klen)
    assert fd.read(2) == '->'
    value = fd.read(dlen)
    assert fd.read(1) == '\n'
    return (initchar, key, value)

def make(dbFilename, readFilename=None):
    """Makes a database from the filename, otherwise uses stdin."""
    if readFilename is None:
        readfd = sys.stdin
    else:
        readfd = open(readFilename, 'rb')
    maker = Maker(dbFilename)
    while True:
        (initchar, key, value) = _readKeyValue(readfd)
        if initchar is None:
            break
        assert initchar == '+'
        maker.add(key, value)
    readfd.close()
    maker.finish()


class Maker(object):
    """Class for making CDB databases."""
    def __init__(self, filename):
        self.fd = utils.file.AtomicFile(filename, 'wb')
        self.filename = filename
        self.fd.seek(2048)
        self.hashPointers = [(0, 0)] * 256
        #self.hashes = [[]] * 256 # Can't use this, [] stays the same...
        self.hashes = []
        for _ in xrange(256):
            self.hashes.append([])

    def add(self, key, data):
        """Adds a key->value pair to the database."""
        h = hash(key)
        hashPointer = h % 256
        startPosition = self.fd.tell()
        self.fd.write(pack2Ints(len(key), len(data)))
        self.fd.write(key.encode())
        self.fd.write(data.encode())
        self.hashes[hashPointer].append((h, startPosition))

    def finish(self):
        """Finishes the current Maker object.

        Writes the remainder of the database to disk.
        """
        for i in xrange(256):
            hash = self.hashes[i]
            self.hashPointers[i] = (self.fd.tell(), self._serializeHash(hash))
        self._serializeHashPointers()
        self.fd.flush()
        self.fd.close()

    def _serializeHash(self, hash):
        hashLen = len(hash) * 2
        a = [(0, 0)] * hashLen
        for (h, pos) in hash:
            i = (h // 256) % hashLen
            while a[i] != (0, 0):
                i = (i + 1) % hashLen
            a[i] = (h, pos)
        for (h, pos) in a:
            self.fd.write(pack2Ints(h, pos))
        return hashLen

    def _serializeHashPointers(self):
        self.fd.seek(0)
        for (hashPos, hashLen) in self.hashPointers:
            self.fd.write(pack2Ints(hashPos, hashLen))


class Reader(utils.IterableMap):
    """Class for reading from a CDB database."""
    def __init__(self, filename):
        self.filename = filename
        import os
        self.fd = open(filename, 'rb')
        self.loop = 0
        self.khash = 0
        self.kpos = 0
        self.hpos = 0
        self.hslots = 0
        self.dpos = 0
        self.dlen = 0

    def close(self):
        self.fd.close()

    def _read(self, len, pos):
        self.fd.seek(pos)
        return self.fd.read(len)

    def _match(self, key, pos):
        return self._read(len(key), pos) == key

    def iteritems(self):
        # uses loop/hslots in a strange, non-re-entrant manner.
        (self.loop,) = struct.unpack('<i', self._read(4, 0))
        self.hslots = 2048
        while self.hslots < self.loop:
            (klen, dlen) = unpack2Ints(self._read(8, self.hslots))
            dpos = self.hslots + 8 + klen
            ret = (self._read(klen, self.hslots+8).decode(),
                    self._read(dlen, dpos).decode())
            self.hslots = dpos + dlen
            yield ret
        self.loop = 0
        self.hslots = 0

    def _findnext(self, key):
        if not self.loop:
            self.khash = hash(key)
            (self.hpos, self.hslots) = unpack2Ints(self._read(8,
                                                    (self.khash * 8) & 2047))
            if not self.hslots:
                return False
            self.kpos = self.hpos + (((self.khash // 256) % self.hslots) * 8)
        while self.loop < self.hslots:
            (h, p) = unpack2Ints(self._read(8, self.kpos))
            if p == 0:
                return False
            self.loop += 1
            self.kpos += 8
            if self.kpos == self.hpos + (self.hslots * 8):
                self.kpos = self.hpos
            if h == self.khash:
                (u, self.dlen) = unpack2Ints(self._read(8, p))
                if u == len(key):
                    if self._match(key, p+8):
                        self.dpos = p + 8 + u
                        return True
        return False

    def _find(self, key, loop=0):
        self.loop = loop
        return self._findnext(key)

    def _getCurrentData(self):
        return self._read(self.dlen, self.dpos).decode()

    def find(self, key, loop=0):
        if self._find(key, loop=loop):
            return self._getCurrentData()
        else:
            try:
                return self.default
            except AttributeError:
                raise KeyError(key)

    def findall(self, key):
        ret = []
        while self._findnext(key):
            ret.append(self._getCurrentData())
        return ret

    def get(self, key, default=None):
        try:
            return self[key]
        except KeyError:
            return default

    def __len__(self):
        (start,) = struct.unpack('<i', self._read(4, 0))
        self.fd.seek(0, 2)
        return ((self.fd.tell() - start) // 16)

    has_key = _find
    __contains__ = has_key
    __getitem__ = find


class ReaderWriter(utils.IterableMap):
    """Uses a journal to pretend that a CDB is writable database."""
    def __init__(self, filename, journalName=None, maxmods=0):
        if journalName is None:
            journalName = filename + '.journal'
        self.journalName = journalName
        self.maxmods = maxmods
        self.mods = 0
        self.filename = filename
        self._readJournal()
        self._openFiles()
        self.adds = {}
        self.removals = set()

    def _openFiles(self):
        self.cdb = Reader(self.filename)
        self.journal = open(self.journalName, 'w')

    def _closeFiles(self):
        self.cdb.close()
        self.journal.close()

    def _journalRemoveKey(self, key):
        s = '-%s,%s:%s->%s\n' % (len(key), 0, key, '')
        self.journal.write(s)
        self.journal.flush()

    def _journalAddKey(self, key, value):
        s = '+%s,%s:%s->%s\n' % (len(key), len(value), key, value)
        self.journal.write(s)
        self.journal.flush()

    def _readJournal(self):
        removals = set()
        adds = {}
        try:
            fd = open(self.journalName, 'r')
            while True:
                (initchar, key, value) = _readKeyValue(fd)
                if initchar is None:
                    break
                elif initchar == '+':
                    if key in removals:
                        removals.remove(key)
                    adds[key] = value
                elif initchar == '-':
                    if key in adds:
                        del adds[key]
                    removals.add(key)
            fd.close()
        except IOError:
            pass
        if removals or adds:
            maker = Maker(self.filename)
            cdb = Reader(self.filename)
            for (key, value) in cdb.iteritems():
                if key in removals:
                    continue
                elif key in adds:
                    value = adds[key]
                    if value is not None:
                        maker.add(key, value)
                        adds[key] = None
                else:
                    maker.add(key, value)
            for (key, value) in adds.iteritems():
                if value is not None:
                    maker.add(key, value)
            cdb.close()
            maker.finish()
        if os.path.exists(self.journalName):
            os.remove(self.journalName)

    def close(self):
        self.flush()
        self._closeFiles()

    def flush(self):
        self._closeFiles()
        self._readJournal()
        self._openFiles()

    def _flushIfOverLimit(self):
        if self.maxmods:
            if isinstance(self.maxmods, int):
                if self.mods > self.maxmods:
                    self.flush()
                    self.mods = 0
            elif isinstance(self.maxmods, float):
                assert 0 <= self.maxmods
                if self.mods / max(len(self.cdb), 100) > self.maxmods:
                    self.flush()
                    self.mods = 0

    def __getitem__(self, key):
        if key in self.removals:
            raise KeyError(key)
        else:
            try:
                return self.adds[key]
            except KeyError:
                return self.cdb[key] # If this raises KeyError, we lack key.

    def __delitem__(self, key):
        if key in self.removals:
            raise KeyError(key)
        else:
            if key in self.adds and key in self.cdb:
                self._journalRemoveKey(key)
                del self.adds[key]
                self.removals.add(key)
            elif key in self.adds:
                self._journalRemoveKey(key)
                del self.adds[key]
            elif key in self.cdb:
                self._journalRemoveKey(key)
            else:
                raise KeyError(key)
        self.mods += 1
        self._flushIfOverLimit()

    def __setitem__(self, key, value):
        if key in self.removals:
            self.removals.remove(key)
        self._journalAddKey(key, value)
        self.adds[key] = value
        self.mods += 1
        self._flushIfOverLimit()

    def __contains__(self, key):
        if key in self.removals:
            return False
        else:
            return key in self.adds or key in self.cdb

    has_key = __contains__

    def iteritems(self):
        already = set()
        for (key, value) in self.cdb.iteritems():
            if key in self.removals or key in already:
                continue
            elif key in self.adds:
                already.add(key)
                yield (key, self.adds[key])
            else:
                yield (key, value)
        for (key, value) in self.adds.iteritems():
            if key not in already:
                yield (key, value)

    def setdefault(self, key, value):
        try:
            return self[key]
        except KeyError:
            self[key] = value
            return value

    def get(self, key, default=None):
        try:
            return self[key]
        except KeyError:
            return default


class Shelf(ReaderWriter):
    """Uses pickle to mimic the shelf module."""
    def __getitem__(self, key):
        return pickle.loads(ReaderWriter.__getitem__(self, key))

    def __setitem__(self, key, value):
        ReaderWriter.__setitem__(self, key, pickle.dumps(value, True))

    def iteritems(self):
        for (key, value) in ReaderWriter.iteritems(self):
            yield (key, pickle.loads(value))


if __name__ == '__main__':
    if sys.argv[0] == 'cdbdump':
        if len(sys.argv) == 2:
            fd = open(sys.argv[1], 'rb')
        else:
            fd = sys.stdin
        db = Reader(fd)
        dump(db)
    elif sys.argv[0] == 'cdbmake':
        if len(sys.argv) == 2:
            make(sys.argv[1])
        else:
            make(sys.argv[1], sys.argv[2])
# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = commands
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# Copyright (c) 2009-2010, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

"""
Includes wrappers for commands.
"""

import time
import Queue
import types
import getopt
import inspect
import threading
import multiprocessing #python2.6 or later!
import Queue

try:
    import resource
except ImportError: # Windows!
    resource = None

from . import callbacks, conf, ircdb, ircmsgs, ircutils, log, utils, world
from .i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization()

###
# Non-arg wrappers -- these just change the behavior of a command without
# changing the arguments given to it.
###

# Thread has to be a non-arg wrapper because by the time we're parsing and
# validating arguments, we're inside the function we'd want to thread.
def thread(f):
    """Makes sure a command spawns a thread when called."""
    def newf(self, irc, msg, args, *L, **kwargs):
        if world.isMainThread():
            targetArgs = (self.callingCommand, irc, msg, args) + tuple(L)
            t = callbacks.CommandThread(target=self._callCommand,
                                        args=targetArgs, kwargs=kwargs)
            t.start()
        else:
            f(self, irc, msg, args, *L, **kwargs)
    return utils.python.changeFunctionName(newf, f.__name__, f.__doc__)

class ProcessTimeoutError(Exception):
    """Gets raised when a process is killed due to timeout."""
    pass

def process(f, *args, **kwargs):
    """Runs a function <f> in a subprocess.
    
    Several extra keyword arguments can be supplied. 
    <pn>, the pluginname, and <cn>, the command name, are strings used to
    create the process name, for identification purposes.
    <timeout>, if supplied, limits the length of execution of target 
    function to <timeout> seconds."""
    timeout = kwargs.pop('timeout', None)
    heap_size = kwargs.pop('heap_size', None)
    if resource and heap_size is None:
        heap_size = resource.RLIM_INFINITY

    if conf.disableMultiprocessing:
        pn = kwargs.pop('pn', 'Unknown')
        cn = kwargs.pop('cn', 'unknown')
        try:
            return f(*args, **kwargs)
        except Exception as e:
            raise e
    
    try:
        q = multiprocessing.Queue()
    except OSError:
        log.error('Using multiprocessing.Queue raised an OSError.\n'
                'This is probably caused by your system denying semaphore\n'
                'usage. You should run these two commands:\n'
                '\tsudo rmdir /dev/shm\n'
                '\tsudo ln -Tsf /{run,dev}/shm\n'
                '(See https://github.com/travis-ci/travis-core/issues/187\n'
                'for more informations about this bug.)\n')
        raise
    def newf(f, q, *args, **kwargs):
        if resource:
            rsrc = resource.RLIMIT_DATA
            resource.setrlimit(rsrc, (heap_size, heap_size))
        try:
            r = f(*args, **kwargs)
            q.put(r)
        except Exception as e:
            q.put(e)
    targetArgs = (f, q,) + args
    p = callbacks.CommandProcess(target=newf,
                                args=targetArgs, kwargs=kwargs)
    p.start()
    p.join(timeout)
    if p.is_alive():
        p.terminate()
        raise ProcessTimeoutError("%s aborted due to timeout." % (p.name,))
    try:
        v = q.get(block=False)
    except Queue.Empty:
        return None
    if isinstance(v, Exception):
        raise v
    else:
        return v

def regexp_wrapper(s, reobj, timeout, plugin_name, fcn_name):
    '''A convenient wrapper to stuff regexp search queries through a subprocess.
    
    This is used because specially-crafted regexps can use exponential time
    and hang the bot.'''
    def re_bool(s, reobj):
        """Since we can't enqueue match objects into the multiprocessing queue,
        we'll just wrap the function to return bools."""
        if reobj.search(s) is not None:
            return True
        else:
            return False
    try:
        v = process(re_bool, s, reobj, timeout=timeout, pn=plugin_name, cn=fcn_name)
        return v
    except ProcessTimeoutError:
        return False

class UrlSnarfThread(world.SupyThread):
    def __init__(self, *args, **kwargs):
        assert 'url' in kwargs
        kwargs['name'] = 'Thread #%s (for snarfing %s)' % \
                         (world.threadsSpawned, kwargs.pop('url'))
        super(UrlSnarfThread, self).__init__(*args, **kwargs)
        self.setDaemon(True)

    def run(self):
        try:
            super(UrlSnarfThread, self).run()
        except utils.web.Error as e:
            log.debug('Exception in urlSnarfer: %s', utils.exnToString(e))

class SnarfQueue(ircutils.FloodQueue):
    timeout = conf.supybot.snarfThrottle
    def key(self, channel):
        return channel

_snarfed = SnarfQueue()

class SnarfIrc(object):
    def __init__(self, irc, channel, url):
        self.irc = irc
        self.url = url
        self.channel = channel

    def __getattr__(self, attr):
        return getattr(self.irc, attr)

    def reply(self, *args, **kwargs):
        _snarfed.enqueue(self.channel, self.url)
        return self.irc.reply(*args, **kwargs)

# This lock is used to serialize the calls to snarfers, so
# earlier snarfers are guaranteed to beat out later snarfers.
_snarfLock = threading.Lock()
def urlSnarfer(f):
    """Protects the snarfer from loops (with other bots) and whatnot."""
    def newf(self, irc, msg, match, *L, **kwargs):
        url = match.group(0)
        channel = msg.args[0]
        if not irc.isChannel(channel) or (ircmsgs.isCtcp(msg) and not
                                          ircmsgs.isAction(msg)):
            return
        if ircdb.channels.getChannel(channel).lobotomized:
            self.log.debug('Not snarfing in %s: lobotomized.', channel)
            return
        if _snarfed.has(channel, url):
            self.log.info('Throttling snarf of %s in %s.', url, channel)
            return
        irc = SnarfIrc(irc, channel, url)
        def doSnarf():
            _snarfLock.acquire()
            try:
                # This has to be *after* we've acquired the lock so we can be
                # sure that all previous urlSnarfers have already run to
                # completion.
                if msg.repliedTo:
                    self.log.debug('Not snarfing, msg is already repliedTo.')
                    return
                f(self, irc, msg, match, *L, **kwargs)
            finally:
                _snarfLock.release()
        if threading.currentThread() is not world.mainThread:
            doSnarf()
        else:
            L = list(L)
            t = UrlSnarfThread(target=doSnarf, url=url)
            t.start()
    newf = utils.python.changeFunctionName(newf, f.__name__, f.__doc__)
    return newf


###
# Converters, which take irc, msg, args, and a state object, and build up the
# validated and converted args for the method in state.args.
###

# This is just so we can centralize this, since it may change.
def _int(s):
    base = 10
    if s.startswith('0x'):
        base = 16
        s = s[2:]
    elif s.startswith('0b'):
        base = 2
        s = s[2:]
    elif s.startswith('0') and len(s) > 1:
        base = 8
        s = s[1:]
    try:
        return int(s, base)
    except ValueError:
        if base == 10 and '.' not in s:
            try:
                return int(float(s))
            except OverflowError:
                raise ValueError('I don\'t understand numbers that large.')
        else:
            raise

def getInt(irc, msg, args, state, type=_('integer'), p=None):
    try:
        i = _int(args[0])
        if p is not None:
            if not p(i):
                state.errorInvalid(type, args[0])
        state.args.append(i)
        del args[0]
    except ValueError:
        state.errorInvalid(type, args[0])

def getNonInt(irc, msg, args, state, type=_('non-integer value')):
    try:
        i = _int(args[0])
        state.errorInvalid(type, args[0])
    except ValueError:
        state.args.append(args.pop(0))

def getLong(irc, msg, args, state, type='long'):
    getInt(irc, msg, args, state, type)
    state.args[-1] = long(state.args[-1])

def getFloat(irc, msg, args, state, type=_('floating point number')):
    try:
        state.args.append(float(args[0]))
        del args[0]
    except ValueError:
        state.errorInvalid(type, args[0])

def getPositiveInt(irc, msg, args, state, *L):
    getInt(irc, msg, args, state,
           p=lambda i: i>0, type=_('positive integer'), *L)

def getNonNegativeInt(irc, msg, args, state, *L):
    getInt(irc, msg, args, state,
            p=lambda i: i>=0, type=_('non-negative integer'), *L)

def getIndex(irc, msg, args, state):
    getInt(irc, msg, args, state, type=_('index'))
    if state.args[-1] > 0:
        state.args[-1] -= 1

def getId(irc, msg, args, state, kind=None):
    type = 'id'
    if kind is not None and not kind.endswith('id'):
        type = kind + ' id'
    original = args[0]
    try:
        args[0] = args[0].lstrip('#')
        getInt(irc, msg, args, state, type=type)
    except Exception as e:
        args[0] = original
        raise

def getExpiry(irc, msg, args, state):
    now = int(time.time())
    try:
        expires = _int(args[0])
        if expires:
            expires += now
        state.args.append(expires)
        del args[0]
    except ValueError:
        state.errorInvalid(_('number of seconds'), args[0])

def getBoolean(irc, msg, args, state):
    try:
        state.args.append(utils.str.toBool(args[0]))
        del args[0]
    except ValueError:
        state.errorInvalid(_('boolean'), args[0])

def getNetworkIrc(irc, msg, args, state, errorIfNoMatch=False):
    if args:
        for otherIrc in world.ircs:
            if otherIrc.network.lower() == args[0].lower():
                state.args.append(otherIrc)
                del args[0]
                return
    if errorIfNoMatch:
        raise callbacks.ArgumentError
    else:
        state.args.append(irc)

def getHaveVoice(irc, msg, args, state, action=_('do that')):
    getChannel(irc, msg, args, state)
    if state.channel not in irc.state.channels:
        state.error(_('I\'m not even in %s.') % state.channel, Raise=True)
    if not irc.state.channels[state.channel].isVoice(irc.nick):
        state.error(_('I need to be voiced to %s.') % action, Raise=True)

def getHaveVoicePlus(irc, msg, args, state, action=_('do that')):
    getChannel(irc, msg, args, state)
    if state.channel not in irc.state.channels:
        state.error(_('I\'m not even in %s.') % state.channel, Raise=True)
    if not irc.state.channels[state.channel].isVoicePlus(irc.nick):
        # isOp includes owners and protected users
        state.error(_('I need to be at least voiced to %s.') % action,
                Raise=True)

def getHaveHalfop(irc, msg, args, state, action=_('do that')):
    getChannel(irc, msg, args, state)
    if state.channel not in irc.state.channels:
        state.error(_('I\'m not even in %s.') % state.channel, Raise=True)
    if not irc.state.channels[state.channel].isHalfop(irc.nick):
        state.error(_('I need to be halfopped to %s.') % action, Raise=True)

def getHaveHalfopPlus(irc, msg, args, state, action=_('do that')):
    getChannel(irc, msg, args, state)
    if state.channel not in irc.state.channels:
        state.error(_('I\'m not even in %s.') % state.channel, Raise=True)
    if not irc.state.channels[state.channel].isHalfopPlus(irc.nick):
        # isOp includes owners and protected users
        state.error(_('I need to be at least halfopped to %s.') % action,
                Raise=True)

def getHaveOp(irc, msg, args, state, action=_('do that')):
    getChannel(irc, msg, args, state)
    if state.channel not in irc.state.channels:
        state.error(_('I\'m not even in %s.') % state.channel, Raise=True)
    if not irc.state.channels[state.channel].isOp(irc.nick):
        state.error(_('I need to be opped to %s.') % action, Raise=True)

def validChannel(irc, msg, args, state):
    if irc.isChannel(args[0]):
        state.args.append(args.pop(0))
    else:
        state.errorInvalid(_('channel'), args[0])

def getHostmask(irc, msg, args, state):
    if ircutils.isUserHostmask(args[0]) or \
            (not conf.supybot.protocols.irc.strictRfc() and
                    args[0].startswith('$')):
        state.args.append(args.pop(0))
    else:
        try:
            hostmask = irc.state.nickToHostmask(args[0])
            state.args.append(hostmask)
            del args[0]
        except KeyError:
            state.errorInvalid(_('nick or hostmask'), args[0])

def getBanmask(irc, msg, args, state):
    getHostmask(irc, msg, args, state)
    getChannel(irc, msg, args, state)
    channel = state.channel
    banmaskstyle = conf.supybot.protocols.irc.banmask
    state.args[-1] = banmaskstyle.makeBanmask(state.args[-1])

def getUser(irc, msg, args, state):
    try:
        state.args.append(ircdb.users.getUser(msg.prefix))
    except KeyError:
        state.errorNotRegistered(Raise=True)

def getOtherUser(irc, msg, args, state):
    # Although ircdb.users.getUser could accept a hostmask, we're explicitly
    # excluding that from our interface with this check
    if ircutils.isUserHostmask(args[0]):
        state.errorNoUser(args[0])
    try:
        state.args.append(ircdb.users.getUser(args[0]))
        del args[0]
    except KeyError:
        try:
            getHostmask(irc, msg, [args[0]], state)
            hostmask = state.args.pop()
            state.args.append(ircdb.users.getUser(hostmask))
            del args[0]
        except (KeyError, callbacks.Error):
            state.errorNoUser(name=args[0])

def _getRe(f):
    def get(irc, msg, args, state, convert=True):
        original = args[:]
        s = args.pop(0)
        def isRe(s):
            try:
                foo = f(s)
                return True
            except ValueError:
                return False
        try:
            while len(s) < 512 and not isRe(s):
                s += ' ' + args.pop(0)
            if len(s) < 512:
                if convert:
                    state.args.append(f(s))
                else:
                    state.args.append(s)
            else:
                state.errorInvalid(_('regular expression'), s)
        except IndexError:
            args[:] = original
            state.errorInvalid(_('regular expression'), s)
    return get

getMatcher = _getRe(utils.str.perlReToPythonRe)
getReplacer = _getRe(utils.str.perlReToReplacer)

def getNick(irc, msg, args, state):
    if ircutils.isNick(args[0], conf.supybot.protocols.irc.strictRfc()):
        if 'nicklen' in irc.state.supported:
            if len(args[0]) > irc.state.supported['nicklen']:
                state.errorInvalid(_('nick'), args[0],
                                 _('That nick is too long for this server.'))
        state.args.append(args.pop(0))
    else:
        state.errorInvalid(_('nick'), args[0])

def getSeenNick(irc, msg, args, state, errmsg=None):
    try:
        foo = irc.state.nickToHostmask(args[0])
        state.args.append(args.pop(0))
    except KeyError:
        if errmsg is None:
            errmsg = _('I haven\'t seen %s.') % args[0]
        state.error(errmsg, Raise=True)

def getChannel(irc, msg, args, state):
    if state.channel:
        return
    if args and irc.isChannel(args[0]):
        channel = args.pop(0)
    elif irc.isChannel(msg.args[0]):
        channel = msg.args[0]
    else:
        state.log.debug('Raising ArgumentError because there is no channel.')
        raise callbacks.ArgumentError
    state.channel = channel
    state.args.append(channel)

def getChannelDb(irc, msg, args, state, **kwargs):
    channelSpecific = conf.supybot.databases.plugins.channelSpecific
    try:
        getChannel(irc, msg, args, state, **kwargs)
        channel = channelSpecific.getChannelLink(state.channel)
        state.channel = channel
        state.args[-1] = channel
    except (callbacks.ArgumentError, IndexError):
        if channelSpecific():
            raise
        channel = channelSpecific.link()
        if not conf.get(channelSpecific.link.allow, channel):
            log.warning('channelSpecific.link is globally set to %s, but '
                        '%s disallowed linking to its db.', channel, channel)
            raise
        else:
            channel = channelSpecific.getChannelLink(channel)
            state.channel = channel
            state.args.append(channel)

def inChannel(irc, msg, args, state):
    getChannel(irc, msg, args, state)
    if state.channel not in irc.state.channels:
        state.error(_('I\'m not in %s.') % state.channel, Raise=True)

def onlyInChannel(irc, msg, args, state):
    if not (irc.isChannel(msg.args[0]) and msg.args[0] in irc.state.channels):
        state.error(_('This command may only be given in a channel that I am '
                    'in.'), Raise=True)
    else:
        state.channel = msg.args[0]
        state.args.append(state.channel)

def callerInGivenChannel(irc, msg, args, state):
    channel = args[0]
    if irc.isChannel(channel):
        if channel in irc.state.channels:
            if msg.nick in irc.state.channels[channel].users:
                state.args.append(args.pop(0))
            else:
                state.error(_('You must be in %s.') % channel, Raise=True)
        else:
            state.error(_('I\'m not in %s.') % channel, Raise=True)
    else:
        state.errorInvalid(_('channel'), args[0])

def nickInChannel(irc, msg, args, state):
    originalArgs = state.args[:]
    inChannel(irc, msg, args, state)
    state.args = originalArgs
    if args[0] not in irc.state.channels[state.channel].users:
        state.error(_('%s is not in %s.') % (args[0], state.channel), Raise=True)
    state.args.append(args.pop(0))

def getChannelOrNone(irc, msg, args, state):
    try:
        getChannel(irc, msg, args, state)
    except callbacks.ArgumentError:
        state.args.append(None)

def getChannelOrGlobal(irc, msg, args, state):
    if args and args[0] == 'global':
        channel = args.pop(0)
        channel = 'global'
    elif args and irc.isChannel(args[0]):
        channel = args.pop(0)
        state.channel = channel
    elif irc.isChannel(msg.args[0]):
        channel = msg.args[0]
        state.channel = channel
    else:
        state.log.debug('Raising ArgumentError because there is no channel.')
        raise callbacks.ArgumentError
    state.args.append(channel)

def checkChannelCapability(irc, msg, args, state, cap):
    getChannel(irc, msg, args, state)
    cap = ircdb.canonicalCapability(cap)
    cap = ircdb.makeChannelCapability(state.channel, cap)
    if not ircdb.checkCapability(msg.prefix, cap):
        state.errorNoCapability(cap, Raise=True)

def getOp(irc, msg, args, state):
    checkChannelCapability(irc, msg, args, state, 'op')

def getHalfop(irc, msg, args, state):
    checkChannelCapability(irc, msg, args, state, 'halfop')

def getVoice(irc, msg, args, state):
    checkChannelCapability(irc, msg, args, state, 'voice')

def getLowered(irc, msg, args, state):
    state.args.append(ircutils.toLower(args.pop(0)))

def getSomething(irc, msg, args, state, errorMsg=None, p=None):
    if p is None:
        p = lambda _: True
    if not args[0] or not p(args[0]):
        if errorMsg is None:
            errorMsg = _('You must not give the empty string as an argument.')
        state.error(errorMsg, Raise=True)
    else:
        state.args.append(args.pop(0))

def getSomethingNoSpaces(irc, msg, args, state, *L):
    def p(s):
        return len(s.split(None, 1)) == 1
    L = L or [_('You must not give a string containing spaces as an argument.')]
    getSomething(irc, msg, args, state, p=p, *L)

def private(irc, msg, args, state):
    if irc.isChannel(msg.args[0]):
        state.errorRequiresPrivacy(Raise=True)

def public(irc, msg, args, state, errmsg=None):
    if not irc.isChannel(msg.args[0]):
        if errmsg is None:
            errmsg = _('This message must be sent in a channel.')
        state.error(errmsg, Raise=True)

def checkCapability(irc, msg, args, state, cap):
    cap = ircdb.canonicalCapability(cap)
    if not ircdb.checkCapability(msg.prefix, cap):
        state.errorNoCapability(cap, Raise=True)

def checkCapabilityButIgnoreOwner(irc, msg, args, state, cap):
    cap = ircdb.canonicalCapability(cap)
    if not ircdb.checkCapability(msg.prefix, cap, ignoreOwner=True):
        state.errorNoCapability(cap, Raise=True)

def owner(irc, msg, args, state):
    checkCapability(irc, msg, args, state, 'owner')

def admin(irc, msg, args, state):
    checkCapability(irc, msg, args, state, 'admin')

def anything(irc, msg, args, state):
    state.args.append(args.pop(0))

def getGlob(irc, msg, args, state):
    glob = args.pop(0)
    if '*' not in glob and '?' not in glob:
        glob = '*%s*' % glob
    state.args.append(glob)

def getUrl(irc, msg, args, state):
    if utils.web.urlRe.match(args[0]):
        state.args.append(args.pop(0))
    else:
        state.errorInvalid(_('url'), args[0])

def getEmail(irc, msg, args, state):
    if utils.net.emailRe.match(args[0]):
        state.args.append(args.pop(0))
    else:
        state.errorInvalid(_('email'), args[0])

def getHttpUrl(irc, msg, args, state):
    if utils.web.httpUrlRe.match(args[0]):
        state.args.append(args.pop(0))
    elif utils.web.httpUrlRe.match('http://' + args[0]):
        state.args.append('http://' + args.pop(0))
    else:
        state.errorInvalid(_('http url'), args[0])

def getNow(irc, msg, args, state):
    state.args.append(int(time.time()))

def getCommandName(irc, msg, args, state):
    if ' ' in args[0]:
        state.errorInvalid(_('command name'), args[0])
    else:
        state.args.append(callbacks.canonicalName(args.pop(0)))

def getIp(irc, msg, args, state):
    if utils.net.isIP(args[0]):
        state.args.append(args.pop(0))
    else:
        state.errorInvalid(_('ip'), args[0])

def getLetter(irc, msg, args, state):
    if len(args[0]) == 1:
        state.args.append(args.pop(0))
    else:
        state.errorInvalid(_('letter'), args[0])

def getMatch(irc, msg, args, state, regexp, errmsg):
    m = regexp.search(args[0])
    if m is not None:
        state.args.append(m)
        del args[0]
    else:
        state.error(errmsg, Raise=True)

def getLiteral(irc, msg, args, state, literals, errmsg=None):
    # ??? Should we allow abbreviations?
    if isinstance(literals, basestring):
        literals = (literals,)
    abbrevs = utils.abbrev(literals)
    if args[0] in abbrevs:
        state.args.append(abbrevs[args.pop(0)])
    elif errmsg is not None:
        state.error(errmsg, Raise=True)
    else:
        raise callbacks.ArgumentError

def getTo(irc, msg, args, state):
    if args[0].lower() == 'to':
        args.pop(0)

def getPlugin(irc, msg, args, state, require=True):
    cb = irc.getCallback(args[0])
    if cb is not None:
        state.args.append(cb)
        del args[0]
    elif require:
        state.errorInvalid(_('plugin'), args[0])
    else:
        state.args.append(None)

def getIrcColor(irc, msg, args, state):
    if args[0] in ircutils.mircColors:
        state.args.append(ircutils.mircColors[args.pop(0)])
    else:
        state.errorInvalid(_('irc color'))

def getText(irc, msg, args, state):
    if args:
        state.args.append(' '.join(args))
        args[:] = []
    else:
        raise IndexError

wrappers = ircutils.IrcDict({
    'admin': admin,
    'anything': anything,
    'banmask': getBanmask,
    'boolean': getBoolean,
    'callerInGivenChannel': callerInGivenChannel,
    'isGranted': getHaveHalfopPlus, # Backward compatibility
    'capability': getSomethingNoSpaces,
    'channel': getChannel,
    'channelOrGlobal': getChannelOrGlobal,
    'channelDb': getChannelDb,
    'checkCapability': checkCapability,
    'checkCapabilityButIgnoreOwner': checkCapabilityButIgnoreOwner,
    'checkChannelCapability': checkChannelCapability,
    'color': getIrcColor,
    'commandName': getCommandName,
    'email': getEmail,
    'expiry': getExpiry,
    'filename': getSomething, # XXX Check for validity.
    'float': getFloat,
    'glob': getGlob,
    'halfop': getHalfop,
    'haveHalfop': getHaveHalfop,
    'haveHalfop+': getHaveHalfopPlus,
    'haveOp': getHaveOp,
    'haveOp+': getHaveOp, # We don't handle modes greater than op.
    'haveVoice': getHaveVoice,
    'haveVoice+': getHaveVoicePlus,
    'hostmask': getHostmask,
    'httpUrl': getHttpUrl,
    'id': getId,
    'inChannel': inChannel,
    'index': getIndex,
    'int': getInt,
    'ip': getIp,
    'letter': getLetter,
    'literal': getLiteral,
    'long': getLong,
    'lowered': getLowered,
    'matches': getMatch,
    'networkIrc': getNetworkIrc,
    'nick': getNick,
    'nickInChannel': nickInChannel,
    'nonInt': getNonInt,
    'nonNegativeInt': getNonNegativeInt,
    'now': getNow,
    'onlyInChannel': onlyInChannel,
    'op': getOp,
    'otherUser': getOtherUser,
    'owner': owner,
    'plugin': getPlugin,
    'positiveInt': getPositiveInt,
    'private': private,
    'public': public,
    'regexpMatcher': getMatcher,
    'regexpReplacer': getReplacer,
    'seenNick': getSeenNick,
    'something': getSomething,
    'somethingWithoutSpaces': getSomethingNoSpaces,
    'text': getText,
    'to': getTo,
    'url': getUrl,
    'user': getUser,
    'validChannel': validChannel,
    'voice': getVoice,
})

def addConverter(name, wrapper):
    wrappers[name] = wrapper

class UnknownConverter(KeyError):
    pass

def getConverter(name):
    try:
        return wrappers[name]
    except KeyError as e:
        raise UnknownConverter(str(e))

def callConverter(name, irc, msg, args, state, *L):
    getConverter(name)(irc, msg, args, state, *L)

###
# Contexts.  These determine what the nature of conversions is; whether they're
# defaulted, or many of them are allowed, etc.  Contexts should be reusable;
# i.e., they should not maintain state between calls.
###
def contextify(spec):
    if not isinstance(spec, context):
        spec = context(spec)
    return spec

def setDefault(state, default):
    if callable(default):
        state.args.append(default())
    else:
        state.args.append(default)

class context(object):
    def __init__(self, spec):
        self.args = ()
        self.spec = spec # for repr
        if isinstance(spec, tuple):
            assert spec, 'tuple spec must not be empty.'
            self.args = spec[1:]
            self.converter = getConverter(spec[0])
        elif spec is None:
            self.converter = getConverter('anything')
        elif isinstance(spec, basestring):
            self.args = ()
            self.converter = getConverter(spec)
        else:
            assert isinstance(spec, context)
            self.converter = spec

    def __call__(self, irc, msg, args, state):
        log.debug('args before %r: %r', self, args)
        self.converter(irc, msg, args, state, *self.args)
        log.debug('args after %r: %r', self, args)

    def __repr__(self):
        return '<%s for %s>' % (self.__class__.__name__, self.spec)

class rest(context):
    def __call__(self, irc, msg, args, state):
        if args:
            original = args[:]
            args[:] = [' '.join(args)]
            try:
                super(rest, self).__call__(irc, msg, args, state)
            except Exception as e:
                args[:] = original
        else:
            raise IndexError

# additional means:  Look for this (and make sure it's of this type).  If
# there are no arguments for us to check, then use our default.
class additional(context):
    def __init__(self, spec, default=None):
        self.__parent = super(additional, self)
        self.__parent.__init__(spec)
        self.default = default

    def __call__(self, irc, msg, args, state):
        try:
            self.__parent.__call__(irc, msg, args, state)
        except IndexError:
            log.debug('Got IndexError, returning default.')
            setDefault(state, self.default)

# optional means: Look for this, but if it's not the type I'm expecting or
# there are no arguments for us to check, then use the default value.
class optional(additional):
    def __call__(self, irc, msg, args, state):
        try:
            super(optional, self).__call__(irc, msg, args, state)
        except (callbacks.ArgumentError, callbacks.Error) as e:
            log.debug('Got %s, returning default.', utils.exnToString(e))
            state.errored = False
            setDefault(state, self.default)

class any(context):
    def __init__(self, spec, continueOnError=False):
        self.__parent = super(any, self)
        self.__parent.__init__(spec)
        self.continueOnError = continueOnError

    def __call__(self, irc, msg, args, state):
        st = state.essence()
        try:
            while args:
                self.__parent.__call__(irc, msg, args, st)
        except IndexError:
            pass
        except (callbacks.ArgumentError, callbacks.Error) as e:
            if not self.continueOnError:
                raise
            else:
                log.debug('Got %s, returning default.', utils.exnToString(e))
                pass
        state.args.append(st.args)

class many(any):
    def __call__(self, irc, msg, args, state):
        super(many, self).__call__(irc, msg, args, state)
        if not state.args[-1]:
            state.args.pop()
            raise callbacks.ArgumentError

class first(context):
    def __init__(self, *specs, **kw):
        if 'default' in kw:
            self.default = kw.pop('default')
            assert not kw, 'Bad kwargs for first.__init__'
        self.spec = specs # for __repr__
        self.specs = list(map(contextify, specs))

    def __call__(self, irc, msg, args, state):
        errored = False
        for spec in self.specs:
            try:
                spec(irc, msg, args, state)
                return
            except Exception as e:
                e2 = e # 'e' is local.
                errored = state.errored
                state.errored = False
                continue
        if hasattr(self, 'default'):
            state.args.append(self.default)
        else:
            state.errored = errored
            raise e2

class reverse(context):
    def __call__(self, irc, msg, args, state):
        args[:] = args[::-1]
        super(reverse, self).__call__(irc, msg, args, state)
        args[:] = args[::-1]

class commalist(context):
    def __call__(self, irc, msg, args, state):
        original = args[:]
        st = state.essence()
        trailingComma = True
        try:
            while trailingComma:
                arg = args.pop(0)
                if not arg.endswith(','):
                    trailingComma = False
                for part in arg.split(','):
                    if part: # trailing commas
                        super(commalist, self).__call__(irc, msg, [part], st)
            state.args.append(st.args)
        except Exception as e:
            args[:] = original
            raise

class getopts(context):
    """The empty string indicates that no argument is taken; None indicates
    that there is no converter for the argument."""
    def __init__(self, getopts):
        self.spec = getopts # for repr
        self.getopts = {}
        self.getoptL = []
        self.getoptLs = ''
        for (name, spec) in getopts.iteritems():
            if spec == '':
                if len(name) == 1:
                    self.getoptLs += name
                    self.getopts[name] = None
                self.getoptL.append(name)
                self.getopts[name] = None
            else:
                if len(name) == 1:
                    self.getoptLs += name + ':'
                    self.getopts[name] = contextify(spec)
                self.getoptL.append(name + '=')
                self.getopts[name] = contextify(spec)
        log.debug('getopts: %r', self.getopts)
        log.debug('getoptL: %r', self.getoptL)

    def __call__(self, irc, msg, args, state):
        log.debug('args before %r: %r', self, args)
        (optlist, rest) = getopt.getopt(args, self.getoptLs, self.getoptL)
        getopts = []
        for (opt, arg) in optlist:
            if opt.startswith('--'):
                opt = opt[2:] # Strip --
            else:
                opt = opt[1:]
            log.debug('opt: %r, arg: %r', opt, arg)
            context = self.getopts[opt]
            if context is not None:
                st = state.essence()
                context(irc, msg, [arg], st)
                assert len(st.args) == 1
                getopts.append((opt, st.args[0]))
            else:
                getopts.append((opt, True))
        state.args.append(getopts)
        args[:] = rest
        log.debug('args after %r: %r', self, args)

###
# This is our state object, passed to converters along with irc, msg, and args.
###

class State(object):
    log = log
    def __init__(self, types):
        self.args = []
        self.kwargs = {}
        self.types = types
        self.channel = None
        self.errored = False

    def __getattr__(self, attr):
        if attr.startswith('error'):
            self.errored = True
            return getattr(dynamic.irc, attr)
        else:
            raise AttributeError(attr)

    def essence(self):
        st = State(self.types)
        for (attr, value) in self.__dict__.iteritems():
            if attr not in ('args', 'kwargs'):
                setattr(st, attr, value)
        return st

    def __repr__(self):
        return '%s(args=%r, kwargs=%r, channel=%r)' % (self.__class__.__name__,
                                                       self.args, self.kwargs,
                                                       self.channel)


###
# This is a compiled Spec object.
###
class Spec(object):
    def _state(self, types, attrs={}):
        st = State(types)
        st.__dict__.update(attrs)
        st.allowExtra = self.allowExtra
        return st

    def __init__(self, types, allowExtra=False):
        self.types = types
        self.allowExtra = allowExtra
        utils.seq.mapinto(contextify, self.types)

    def __call__(self, irc, msg, args, stateAttrs={}):
        state = self._state(self.types[:], stateAttrs)
        while state.types:
            context = state.types.pop(0)
            try:
                context(irc, msg, args, state)
            except IndexError:
                raise callbacks.ArgumentError
        if args and not state.allowExtra:
            log.debug('args and not self.allowExtra: %r', args)
            raise callbacks.ArgumentError
        return state

def _wrap(f, specList=[], name=None, checkDoc=True, **kw):
    name = name or f.__name__
    assert (not checkDoc) or (hasattr(f, '__doc__') and f.__doc__), \
                'Command %r has no docstring.' % name
    spec = Spec(specList, **kw)
    def newf(self, irc, msg, args, **kwargs):
        state = spec(irc, msg, args, stateAttrs={'cb': self, 'log': self.log})
        self.log.debug('State before call: %s', state)
        if state.errored:
            self.log.debug('Refusing to call %s due to state.errored.', f)
        else:
            try:
                f(self, irc, msg, args, *state.args, **state.kwargs)
            except TypeError:
                self.log.error('Spec: %s', specList)
                self.log.error('Received args: %s', args)
                code = f.__code__
                funcArgs = inspect.getargs(code)[0][len(self.commandArgs):]
                self.log.error('Extra args: %s', funcArgs)
                self.log.debug('Make sure you did not wrap a wrapped '
                               'function ;)')
                raise
    newf2 = utils.python.changeFunctionName(newf, name, f.__doc__)
    return internationalizeDocstring(newf2)

def wrap(f, *args, **kwargs):
    if callable(f):
        # Old-style call OR decorator syntax with no converter.
        # f is the command.
        return _wrap(f, *args, **kwargs)
    else:
        # Call with the Python decorator syntax
        assert isinstance(f, list) or isinstance(f, tuple)
        specList = f
        def decorator(f):
            return _wrap(f, specList, *args, **kwargs)
        return decorator
wrap.__doc__ = """Useful wrapper for plugin commands.

Valid converters are: %s.

:param f: A command, taking (self, irc, msg, args, ...) as arguments
:param specList: A list of converters and contexts""" % \
        ', '.join(sorted(wrappers.keys()))

__all__ = [
    # Contexts.
    'any', 'many',
    'optional', 'additional',
    'rest', 'getopts',
    'first', 'reverse',
    'commalist',
    # Converter helpers.
    'getConverter', 'addConverter', 'callConverter',
    # Decorators.
    'urlSnarfer', 'thread',
    # Functions.
    'wrap', 'process', 'regexp_wrapper',
    # Stuff for testing.
    'Spec',
]

# This doesn't work.  Suck.
## if world.testing:
##     __all__.append('Spec')

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = conf
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# Copyright (c) 2008-2009,2011, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import os
import sys
import time
import socket

from . import ircutils, registry, utils
from .version import version
from .i18n import PluginInternationalization
_ = PluginInternationalization()

###
# *** The following variables are affected by command-line options.  They are
#     not registry variables for a specific reason.  Do *not* change these to
#     registry variables without first consulting people smarter than yourself.
###

###
# daemonized: This determines whether or not the bot has been daemonized
#             (i.e., set to run in the background).  Obviously, this defaults
#             to False.  A command-line option for obvious reasons.
###
daemonized = False

###
# allowDefaultOwner: True if supybot.capabilities is allowed not to include
#                    '-owner' -- that is, if all users should be automatically
#                    recognized as owners.  That would suck, hence we require a
#                    command-line option to allow this stupidity.
###
allowDefaultOwner = False

###
# Here we replace values in other modules as appropriate.
###
utils.web.defaultHeaders['User-agent'] = \
                         'Mozilla/5.0 (Compatible; Supybot %s)' % version

###
# The standard registry.
###
supybot = registry.Group()
supybot.setName('supybot')

def registerGroup(Group, name, group=None, **kwargs):
    if kwargs:
        group = registry.Group(**kwargs)
    return Group.register(name, group)

def registerGlobalValue(group, name, value):
    value.channelValue = False
    return group.register(name, value)

def registerChannelValue(group, name, value):
    value._supplyDefault = True
    value.channelValue = True
    g = group.register(name, value)
    gname = g._name.lower()
    for name in registry._cache.keys():
        if name.lower().startswith(gname) and len(gname) < len(name):
            name = name[len(gname)+1:] # +1 for .
            parts = registry.split(name)
            if len(parts) == 1 and parts[0] and ircutils.isChannel(parts[0]):
                # This gets the channel values so they always persist.
                g.get(parts[0])()

def registerPlugin(name, currentValue=None, public=True):
    group = registerGlobalValue(supybot.plugins, name,
        registry.Boolean(False, _("""Determines whether this plugin is loaded
         by default."""), showDefault=False))
    supybot.plugins().add(name)
    registerGlobalValue(group, 'public',
        registry.Boolean(public, _("""Determines whether this plugin is
        publicly visible.""")))
    if currentValue is not None:
        supybot.plugins.get(name).setValue(currentValue)
    registerGroup(users.plugins, name)
    return group

def get(group, channel=None):
    if group.channelValue and \
       channel is not None and ircutils.isChannel(channel):
        return group.get(channel)()
    else:
        return group()

###
# The user info registry.
###
users = registry.Group()
users.setName('users')
registerGroup(users, 'plugins', orderAlphabetically=True)

def registerUserValue(group, name, value):
    assert group._name.startswith('users')
    value._supplyDefault = True
    group.register(name, value)

class ValidNick(registry.String):
    """Value must be a valid IRC nick."""
    def setValue(self, v):
        if not ircutils.isNick(v):
            self.error()
        else:
            registry.String.setValue(self, v)

class ValidNickOrEmpty(ValidNick):
    """Value must be a valid IRC nick or empty."""
    def setValue(self, v):
        if v != '' and not ircutils.isNick(v):
            self.error()
        else:
            registry.String.setValue(self, v)

class ValidNicks(registry.SpaceSeparatedListOf):
    Value = ValidNick

class ValidNickAllowingPercentS(ValidNick):
    """Value must be a valid IRC nick, with the possible exception of a %s
    in it."""
    def setValue(self, v):
        # If this works, it's a valid nick, aside from the %s.
        try:
            ValidNick.setValue(self, v.replace('%s', ''))
            # It's valid aside from the %s, we'll let it through.
            registry.String.setValue(self, v)
        except registry.InvalidRegistryValue:
            self.error()

class ValidNicksAllowingPercentS(ValidNicks):
    Value = ValidNickAllowingPercentS

class ValidChannel(registry.String):
    """Value must be a valid IRC channel name."""
    def setValue(self, v):
        self.channel = v
        if ',' in v:
            # To prevent stupid users from: a) trying to add a channel key
            # with a comma in it, b) trying to add channels separated by
            # commas instead of spaces
            try:
                (channel, _) = v.split(',')
            except ValueError:
                self.error()
        else:
            channel = v
        if not ircutils.isChannel(channel):
            self.error()
        else:
            registry.String.setValue(self, v)

    def error(self):
        try:
            super(ValidChannel, self).error()
        except registry.InvalidRegistryValue as e:
            e.channel = self.channel
            raise e

class ValidHostmask(registry.String):
    """Value must be a valid user hostmask."""
    def setValue(self, v):
        if not ircutils.isUserHostmask(v):
            self.error()
        super(ValidHostmask, self).setValue(v)

registerGlobalValue(supybot, 'nick',
   ValidNick('supybot', _("""Determines the bot's default nick.""")))

registerGlobalValue(supybot.nick, 'alternates',
   ValidNicksAllowingPercentS(['%s`', '%s_'], _("""Determines what alternative
   nicks will be used if the primary nick (supybot.nick) isn't available.  A
   %s in this nick is replaced by the value of supybot.nick when used. If no
   alternates are given, or if all are used, the supybot.nick will be perturbed
   appropriately until an unused nick is found.""")))

registerGlobalValue(supybot, 'ident',
    ValidNick('limnoria', _("""Determines the bot's ident string, if the server
    doesn't provide one by default.""")))

class VersionIfEmpty(registry.String):
    def __call__(self):
        ret = registry.String.__call__(self)
        if not ret:
            ret = 'Supybot %s' % version
        return ret

registerGlobalValue(supybot, 'user',
    VersionIfEmpty('', _("""Determines the user the bot sends to the server.
    A standard user using the current version of the bot will be generated if
    this is left empty.""")))

class Networks(registry.SpaceSeparatedSetOfStrings):
    List = ircutils.IrcSet

registerGlobalValue(supybot, 'networks',
    Networks([], _("""Determines what networks the bot will connect to."""),
             orderAlphabetically=True))

class Servers(registry.SpaceSeparatedListOfStrings):
    def normalize(self, s):
        if ':' not in s:
            s += ':6667'
        return s

    def convert(self, s):
        s = self.normalize(s)
        (server, port) = s.rsplit(':', 1)
        port = int(port)
        return (server, port)

    def __call__(self):
        L = registry.SpaceSeparatedListOfStrings.__call__(self)
        return list(map(self.convert, L))

    def __str__(self):
        return ' '.join(registry.SpaceSeparatedListOfStrings.__call__(self))

    def append(self, s):
        L = registry.SpaceSeparatedListOfStrings.__call__(self)
        L.append(s)

class SocksProxy(registry.String):
    """Value must be a valid hostname:port string."""
    def setValue(self, v):
        # TODO: improve checks
        if ':' not in v:
            self.error()
        try:
            int(v.rsplit(':', 1)[1])
        except ValueError:
            self.error()
        super(SocksProxy, self).setValue(v)

class SpaceSeparatedSetOfChannels(registry.SpaceSeparatedListOf):
    sorted = True
    List = ircutils.IrcSet
    Value = ValidChannel
    def join(self, channel):
        from . import ircmsgs # Don't put this globally!  It's recursive.
        key = self.key.get(channel)()
        if key:
            return ircmsgs.join(channel, key)
        else:
            return ircmsgs.join(channel)
    def joins(self):
        from . import ircmsgs # Don't put this globally!  It's recursive.
        channels = []
        channels_with_key = []
        keys = []
        for channel in self():
            key = self.key.get(channel)()
            if key:
                keys.append(key)
                channels_with_key.append(channel)
            else:
                channels.append(channel)
        if channels_with_key or channels:
            return ircmsgs.joins(channels_with_key + channels, keys)
        else:
            # Let's be explicit about it
            return None

def registerNetwork(name, password='', ssl=False, sasl_username='',
        sasl_password=''):
    network = registerGroup(supybot.networks, name)
    registerGlobalValue(network, 'password', registry.String(password,
        _("""Determines what password will be used on %s.  Yes, we know that
        technically passwords are server-specific and not network-specific,
        but this is the best we can do right now.""") % name, private=True))
    registryServers = registerGlobalValue(network, 'servers', Servers([],
        _("""Space-separated list of servers the bot will connect to for %s.
        Each will be tried in order, wrapping back to the first when the cycle
        is completed.""") % name))
    registerGlobalValue(network, 'channels', SpaceSeparatedSetOfChannels([],
        _("""Space-separated list of channels the bot will join only on %s.""")
        % name, private=True))
    registerGlobalValue(network, 'ssl', registry.Boolean(ssl,
        _("""Determines whether the bot will attempt to connect with SSL
        sockets to %s.""") % name))
    registerGlobalValue(network, 'certfile', registry.String('',
        _("""Determines what certificate file (if any) the bot will use to
        connect with SSL sockets to %s.""") % name))
    registerChannelValue(network.channels, 'key', registry.String('',
        _("""Determines what key (if any) will be used to join the
        channel."""), private=True))
    registerGlobalValue(network, 'nick', ValidNickOrEmpty('', _("""Determines
        what nick the bot will use on this network. If empty, defaults to
        supybot.nick.""")))
    registerGlobalValue(network, 'ident', ValidNickOrEmpty('', _("""Determines
        the bot's ident string, if the server doesn't provide one by default.
        If empty, defaults to supybot.ident.""")))
    registerGlobalValue(network, 'user', registry.String('', _("""Determines
        the username the bot sends to the server. If empty, defaults to
        supybot.user""")))
    registerGlobalValue(network, 'umodes',
        registry.String('', _("""Determines what user modes the bot will request
        from the server when it first connects. If empty, defaults to
        supybot.protocols.irc.umodes""")))
    sasl = registerGroup(network, 'sasl')
    registerGlobalValue(sasl, 'username', registry.String(sasl_username,
        _("""Determines what SASL username will be used on %s. This should
        be the bot's account name. Due to the way SASL works, you can't use
        any grouped nick.""") % name, private=False))
    registerGlobalValue(sasl, 'password', registry.String(sasl_password,
        _("""Determines what SASL password will be used on %s.""") \
        % name, private=True))
    registerGlobalValue(network, 'socksproxy', registry.String('',
        _("""If not empty, determines the hostname of the socks proxy that
        will be used to connect to this network.""")))
    return network

# Let's fill our networks.
for (name, s) in registry._cache.items():
    if name.startswith('supybot.networks.'):
        parts = name.split('.')
        name = parts[2]
        if name != 'default':
            registerNetwork(name)


###
# Reply/error tweaking.
###
registerGroup(supybot, 'reply')

registerGroup(supybot.reply, 'format')
registerChannelValue(supybot.reply.format, 'url',
    registry.String('<%s>', _("""Determines how urls should be formatted.""")))
registerChannelValue(supybot.reply.format, 'time',
    registry.String('%I:%M %p, %B %d, %Y', _("""Determines how timestamps
    printed for human reading should be formatted. Refer to the Python
    documentation for the time module to see valid formatting characters for
    time formats.""")))
def timestamp(t):
    if t is None:
        t = time.time()
    t = time.localtime(t)
    format = get(supybot.reply.format.time, dynamic.channel)
    return time.strftime(format, t)
utils.str.timestamp = timestamp

registerGroup(supybot.reply.format.time, 'elapsed')
registerChannelValue(supybot.reply.format.time.elapsed, 'short',
    registry.Boolean(False, _("""Determines whether elapsed times will be given
    as "1 day, 2 hours, 3 minutes, and 15 seconds" or as "1d 2h 3m 15s".""")))

originalTimeElapsed = utils.timeElapsed
def timeElapsed(*args, **kwargs):
    kwargs['short'] = supybot.reply.format.time.elapsed.short()
    return originalTimeElapsed(*args, **kwargs)
utils.timeElapsed = timeElapsed

registerGlobalValue(supybot.reply, 'maximumLength',
    registry.Integer(512*256, _("""Determines the absolute maximum length of
    the bot's reply -- no reply will be passed through the bot with a length
    greater than this.""")))

registerChannelValue(supybot.reply, 'mores',
    registry.Boolean(True, _("""Determines whether the bot will break up long
    messages into chunks and allow users to use  the 'more' command to get the
    remaining chunks.""")))

registerChannelValue(supybot.reply.mores, 'maximum',
    registry.PositiveInteger(50, _("""Determines what the maximum number of
    chunks (for use with the 'more' command) will be.""")))

registerChannelValue(supybot.reply.mores, 'length',
    registry.NonNegativeInteger(0, _("""Determines how long individual chunks
    will be.  If set to 0, uses our super-tweaked,
    get-the-most-out-of-an-individual-message default.""")))

registerChannelValue(supybot.reply.mores, 'instant',
    registry.PositiveInteger(1, _("""Determines how many mores will be sent
    instantly (i.e., without the use of the more command, immediately when
    they are formed).  Defaults to 1, which means that a more command will be
    required for all but the first chunk.""")))

registerChannelValue(supybot.reply, 'oneToOne',
    registry.Boolean(True, _("""Determines whether the bot will send
    multi-message replies in a single message or in multiple messages.  For
    safety purposes (so the bot is less likely to flood) it will normally send
    everything in a single message, using mores if necessary.""")))

registerChannelValue(supybot.reply, 'whenNotCommand',
    registry.Boolean(True, _("""Determines whether the bot will reply with an
    error message when it is addressed but not given a valid command.  If this
    value is False, the bot will remain silent, as long as no other plugins
    override the normal behavior.""")))

registerGroup(supybot.reply, 'error')
registerGlobalValue(supybot.reply.error, 'detailed',
    registry.Boolean(False, _("""Determines whether error messages that result
    from bugs in the bot will show a detailed error message (the uncaught
    exception) or a generic error message.""")))
registerChannelValue(supybot.reply.error, 'inPrivate',
    registry.Boolean(False, _("""Determines whether the bot will send error
    messages to users in private.  You might want to do this in order to keep
    channel traffic to minimum.  This can be used in combination with
    supybot.reply.error.withNotice.""")))
registerChannelValue(supybot.reply.error, 'withNotice',
    registry.Boolean(False, _("""Determines whether the bot will send error
    messages to users via NOTICE instead of PRIVMSG.  You might want to do this
    so users can ignore NOTICEs from the bot and not have to see error
    messages; or you might want to use it in combination with
    supybot.reply.errorInPrivate so private errors don't open a query window
    in most IRC clients.""")))
registerChannelValue(supybot.reply.error, 'noCapability',
    registry.Boolean(False, _("""Determines whether the bot will send an error
    message to users who attempt to call a command for which they do not have
    the necessary capability.  You may wish to make this True if you don't want
    users to understand the underlying security system preventing them from
    running certain commands.""")))

registerChannelValue(supybot.reply, 'inPrivate',
    registry.Boolean(False, _("""Determines whether the bot will reply
     privately when replying in a channel, rather than replying to the whole
     channel.""")))

registerChannelValue(supybot.reply, 'withNotice',
    registry.Boolean(False, _("""Determines whether the bot will reply with a
    notice when replying in a channel, rather than replying with a privmsg as
    normal.""")))

# XXX: User value.
registerGlobalValue(supybot.reply, 'withNoticeWhenPrivate',
    registry.Boolean(False, _("""Determines whether the bot will reply with a
    notice when it is sending a private message, in order not to open a /query
    window in clients.  This can be overridden by individual users via the user
    configuration variable reply.withNoticeWhenPrivate.""")))

registerChannelValue(supybot.reply, 'withNickPrefix',
    registry.Boolean(True, _("""Determines whether the bot will always prefix
     the user's nick to its reply to that user's command.""")))

registerChannelValue(supybot.reply, 'whenNotAddressed',
    registry.Boolean(False, _("""Determines whether the bot should attempt to
    reply to all messages even if they don't address it (either via its nick
    or a prefix character).  If you set this to True, you almost certainly want
    to set supybot.reply.whenNotCommand to False.""")))

registerChannelValue(supybot.reply, 'requireChannelCommandsToBeSentInChannel',
    registry.Boolean(False, _("""Determines whether the bot will allow you to
    send channel-related commands outside of that channel.  Sometimes people
    find it confusing if a channel-related command (like Filter.outfilter)
    changes the behavior of the channel but was sent outside the channel
    itself.""")))

registerGlobalValue(supybot, 'followIdentificationThroughNickChanges',
    registry.Boolean(False, _("""Determines whether the bot will unidentify
    someone when that person changes his or her nick.  Setting this to True
    will cause the bot to track such changes.  It defaults to False for a
    little greater security.""")))

registerChannelValue(supybot, 'alwaysJoinOnInvite',
    registry.Boolean(False, _("""Determines whether the bot will always join a
    channel when it's invited.  If this value is False, the bot will only join
    a channel if the user inviting it has the 'admin' capability (or if it's
    explicitly told to join the channel using the Admin.join command).""")))

registerChannelValue(supybot.reply, 'showSimpleSyntax',
    registry.Boolean(False, _("""Supybot normally replies with the full help
    whenever a user misuses a command.  If this value is set to True, the bot
    will only reply with the syntax of the command (the first line of the
    help) rather than the full help.""")))

class ValidPrefixChars(registry.String):
    """Value must contain only ~!@#$%^&*()_-+=[{}]\\|'\";:,<.>/?"""
    def setValue(self, v):
        if any([x not in '`~!@#$%^&*()_-+=[{}]\\|\'";:,<.>/?' for x in v]):
            self.error()
        registry.String.setValue(self, v)

registerGroup(supybot.reply, 'whenAddressedBy')
registerChannelValue(supybot.reply.whenAddressedBy, 'chars',
    ValidPrefixChars('', _("""Determines what prefix characters the bot will
    reply to.  A prefix character is a single character that the bot will use
    to determine what messages are addressed to it; when there are no prefix
    characters set, it just uses its nick.  Each character in this string is
    interpreted individually; you can have multiple prefix chars
    simultaneously, and if any one of them is used as a prefix the bot will
    assume it is being addressed.""")))

registerChannelValue(supybot.reply.whenAddressedBy, 'strings',
    registry.SpaceSeparatedSetOfStrings([], _("""Determines what strings the
    bot will reply to when they are at the beginning of the message.  Whereas
    prefix.chars can only be one character (although there can be many of
    them), this variable is a space-separated list of strings, so you can
    set something like '@@ ??' and the bot will reply when a message is
    prefixed by either @@ or ??.""")))
registerChannelValue(supybot.reply.whenAddressedBy, 'nick',
    registry.Boolean(True, _("""Determines whether the bot will reply when
    people address it by its nick, rather than with a prefix character.""")))
registerChannelValue(supybot.reply.whenAddressedBy.nick, 'atEnd',
    registry.Boolean(False, _("""Determines whether the bot will reply when
    people address it by its nick at the end of the message, rather than at
    the beginning.""")))
registerChannelValue(supybot.reply.whenAddressedBy, 'nicks',
    registry.SpaceSeparatedSetOfStrings([], _("""Determines what extra nicks
    the bot will always respond to when addressed by, even if its current nick
    is something else.""")))

###
# Replies
###
registerGroup(supybot, 'replies')

registerChannelValue(supybot.replies, 'success',
    registry.NormalizedString(_("""The operation succeeded."""),
    _("""Determines what message the bot replies with when a command succeeded.
    If this configuration variable is empty, no success message will be
    sent.""")))

registerChannelValue(supybot.replies, 'error',
    registry.NormalizedString(_("""An error has occurred and has been logged.
    Please contact this bot's administrator for more information."""), _("""
    Determines what error message the bot gives when it wants to be
    ambiguous.""")))

registerChannelValue(supybot.replies, 'errorOwner',
    registry.NormalizedString(_("""An error has occurred and has been logged.
    Check the logs for more informations."""), _("""Determines what error
    message the bot gives to the owner when it wants to be ambiguous.""")))

registerChannelValue(supybot.replies, 'incorrectAuthentication',
    registry.NormalizedString(_("""Your hostmask doesn't match or your password
    is wrong."""), _("""Determines what message the bot replies with when
     someone tries to use a command that requires being identified or having a
    password and neither credential is correct.""")))

# XXX: This should eventually check that there's one and only one %s here.
registerChannelValue(supybot.replies, 'noUser',
    registry.NormalizedString(_("""I can't find %s in my user
    database.  If you didn't give a user name, then I might not know what your
    user is, and you'll need to identify before this command might work."""),
    _("""Determines what error message the bot replies with when someone tries
    to accessing some information on a user the bot doesn't know about.""")))

registerChannelValue(supybot.replies, 'notRegistered',
    registry.NormalizedString(_("""You must be registered to use this command.
    If you are already registered, you must either identify (using the identify
    command) or add a hostmask matching your current hostmask (using the
    "hostmask add" command)."""), _("""Determines what error message the bot
    replies with when someone tries to do something that requires them to be
    registered but they're not currently recognized.""")))

registerChannelValue(supybot.replies, 'noCapability',
    registry.NormalizedString(_("""You don't have the %s capability.  If you
    think that you should have this capability, be sure that you are identified
    before trying again.  The 'whoami' command can tell you if you're
    identified."""), _("""Determines what error message is given when the bot
    is telling someone they aren't cool enough to use the command they tried to
    use.""")))

registerChannelValue(supybot.replies, 'genericNoCapability',
    registry.NormalizedString(_("""You're missing some capability you need.
    This could be because you actually possess the anti-capability for the
    capability that's required of you, or because the channel provides that
    anti-capability by default, or because the global capabilities include
    that anti-capability.  Or, it could be because the channel or
    supybot.capabilities.default is set to False, meaning that no commands are
    allowed unless explicitly in your capabilities.  Either way, you can't do
    what you want to do."""),
    _("""Determines what generic error message is given when the bot is telling
    someone that they aren't cool enough to use the command they tried to use,
    and the author of the code calling errorNoCapability didn't provide an
    explicit capability for whatever reason.""")))

registerChannelValue(supybot.replies, 'requiresPrivacy',
    registry.NormalizedString(_("""That operation cannot be done in a
    channel."""), _("""Determines what error messages the bot sends to people
    who try to do things in a channel that really should be done in
    private.""")))

registerChannelValue(supybot.replies, 'possibleBug',
    registry.NormalizedString(_("""This may be a bug.  If you think it is,
    please file a bug report at
    <https://github.com/ProgVal/Limnoria/issues>."""),
    _("""Determines what message the bot sends when it thinks you've
    encountered a bug that the developers don't know about.""")))
###
# End supybot.replies.
###

registerGlobalValue(supybot, 'snarfThrottle',
    registry.Float(10.0, _("""A floating point number of seconds to throttle
    snarfed URLs, in order to prevent loops between two bots snarfing the same
    URLs and having the snarfed URL in the output of the snarf message.""")))

registerGlobalValue(supybot, 'upkeepInterval',
    registry.PositiveInteger(3600, _("""Determines the number of seconds
    between running the upkeep function that flushes (commits) open databases,
    collects garbage, and records some useful statistics at the debugging
     level.""")))

registerGlobalValue(supybot, 'flush',
    registry.Boolean(True, _("""Determines whether the bot will periodically
    flush data and configuration files to disk.  Generally, the only time
    you'll want to set this to False is when you want to modify those
    configuration files by hand and don't want the bot to flush its current
    version over your modifications.  Do note that if you change this to False
    inside the bot, your changes won't be flushed.  To make this change
    permanent, you must edit the registry yourself.""")))


###
# supybot.commands.  For stuff relating to commands.
###
registerGroup(supybot, 'commands')

class ValidQuotes(registry.Value):
    """Value must consist solely of \", ', and ` characters."""
    def setValue(self, v):
        if [c for c in v if c not in '"`\'']:
            self.error()
        super(ValidQuotes, self).setValue(v)

    def __str__(self):
        return str(self.value)

registerChannelValue(supybot.commands, 'quotes',
    ValidQuotes('"', _("""Determines what characters are valid for quoting
    arguments to commands in order to prevent them from being tokenized.
    """)))
# This is a GlobalValue because bot owners should be able to say, "There will
# be no nesting at all on this bot."  Individual channels can just set their
# brackets to the empty string.
registerGlobalValue(supybot.commands, 'nested',
    registry.Boolean(True, _("""Determines whether the bot will allow nested
    commands, which rule.  You definitely should keep this on.""")))
registerGlobalValue(supybot.commands.nested, 'maximum',
    registry.PositiveInteger(10, _("""Determines what the maximum number of
    nested commands will be; users will receive an error if they attempt
    commands more nested than this.""")))

class ValidBrackets(registry.OnlySomeStrings):
    validStrings = ('', '[]', '<>', '{}', '()')

registerChannelValue(supybot.commands.nested, 'brackets',
    ValidBrackets('[]', _("""Supybot allows you to specify what brackets are
    used for your nested commands.  Valid sets of brackets include [], <>, and
    {} ().  [] has strong historical motivation, as well as being the brackets
    that don't require shift.  <> or () might be slightly superior because they
    cannot occur in a nick.  If this string is empty, nested commands will
    not be allowed in this channel.""")))
registerChannelValue(supybot.commands.nested, 'pipeSyntax',
    registry.Boolean(False, _("""Supybot allows nested commands. Enabling this
    option will allow nested commands with a syntax similar to UNIX pipes, for
    example: 'bot: foo | bar'.""")))

registerGroup(supybot.commands, 'defaultPlugins',
    orderAlphabetically=True, help=_("""Determines what commands have default
    plugins set, and which plugins are set to be the default for each of those
    commands."""))
registerGlobalValue(supybot.commands.defaultPlugins, 'importantPlugins',
    registry.SpaceSeparatedSetOfStrings(
        ['Admin', 'Channel', 'Config', 'Misc', 'Owner', 'Plugin', 'User'],
        _("""Determines what plugins automatically get precedence over all
        other plugins when selecting a default plugin for a command.  By
        default, this includes the standard loaded plugins.  You probably
        shouldn't change this if you don't know what you're doing; if you do
        know what you're doing, then also know that this set is
        case-sensitive.""")))

# supybot.commands.disabled moved to callbacks for canonicalName.

###
# supybot.abuse.  For stuff relating to abuse of the bot.
###
registerGroup(supybot, 'abuse')
registerGroup(supybot.abuse, 'flood')
registerGlobalValue(supybot.abuse.flood, 'interval',
    registry.PositiveInteger(60, _("""Determines the interval used for
    the history storage.""")))
registerGlobalValue(supybot.abuse.flood, 'command',
    registry.Boolean(True, _("""Determines whether the bot will defend itself
    against command-flooding.""")))
registerGlobalValue(supybot.abuse.flood.command, 'maximum',
    registry.PositiveInteger(12, _("""Determines how many commands users are
    allowed per minute.  If a user sends more than this many commands in any
    60 second period, he or she will be ignored for
    supybot.abuse.flood.command.punishment seconds.""")))
registerGlobalValue(supybot.abuse.flood.command, 'punishment',
    registry.PositiveInteger(300, _("""Determines how many seconds the bot
    will ignore users who flood it with commands.""")))

registerGlobalValue(supybot.abuse.flood.command, 'invalid',
    registry.Boolean(True, _("""Determines whether the bot will defend itself
    against invalid command-flooding.""")))
registerGlobalValue(supybot.abuse.flood.command.invalid, 'maximum',
    registry.PositiveInteger(5, _("""Determines how many invalid commands users
    are allowed per minute.  If a user sends more than this many invalid
    commands in any 60 second period, he or she will be ignored for
    supybot.abuse.flood.command.invalid.punishment seconds.  Typically, this
    value is lower than supybot.abuse.flood.command.maximum, since it's far
    less likely (and far more annoying) for users to flood with invalid
    commands than for them to flood with valid commands.""")))
registerGlobalValue(supybot.abuse.flood.command.invalid, 'punishment',
    registry.PositiveInteger(600, _("""Determines how many seconds the bot
    will ignore users who flood it with invalid commands.  Typically, this
    value is higher than supybot.abuse.flood.command.punishment, since it's far
    less likely (and far more annoying) for users to flood with invalid
    commands than for them to flood with valid commands.""")))
registerGlobalValue(supybot.abuse.flood.command.invalid, 'notify',
    registry.Boolean(True, _("""Determines whether the bot will notify people
    that they're being ignored for invalid command flooding.""")))


###
# supybot.drivers.  For stuff relating to Supybot's drivers (duh!)
###
registerGroup(supybot, 'drivers')
registerGlobalValue(supybot.drivers, 'poll',
    registry.PositiveFloat(1.0, _("""Determines the default length of time a
    driver should block waiting for input.""")))

class ValidDriverModule(registry.OnlySomeStrings):
    validStrings = ('default', 'Socket', 'Twisted')

registerGlobalValue(supybot.drivers, 'module',
    ValidDriverModule('default', _("""Determines what driver module the bot
    will use.  Socket, a simple driver based on timeout sockets, is used by
    default because it's simple and stable.  Twisted is very stable and simple,
    and if you've got Twisted installed, is probably your best bet.""")))

registerGlobalValue(supybot.drivers, 'maxReconnectWait',
    registry.PositiveFloat(300.0, _("""Determines the maximum time the bot will
    wait before attempting to reconnect to an IRC server.  The bot may, of
    course, reconnect earlier if possible.""")))

###
# supybot.directories, for stuff relating to directories.
###

# XXX This shouldn't make directories willy-nilly.  As it is now, if it's
#     configured, it'll still make the default directories, I think.
class Directory(registry.String):
    def __call__(self):
        # ??? Should we perhaps always return an absolute path here?
        v = super(Directory, self).__call__()
        if not os.path.exists(v):
            os.mkdir(v)
        return v

    def dirize(self, filename):
        myself = self()
        if os.path.isabs(filename):
            filename = os.path.abspath(filename)
            selfAbs = os.path.abspath(myself)
            commonPrefix = os.path.commonprefix([selfAbs, filename])
            filename = filename[len(commonPrefix):]
        elif not os.path.isabs(myself):
            if filename.startswith(myself):
                filename = filename[len(myself):]
        filename = filename.lstrip(os.path.sep) # Stupid os.path.join!
        return os.path.join(myself, filename)

class DataFilename(registry.String):
    def __call__(self):
        v = super(DataFilename, self).__call__()
        dataDir = supybot.directories.data()
        if not v.startswith(dataDir):
            v = os.path.basename(v)
            v = os.path.join(dataDir, v)
        self.setValue(v)
        return v

class DataFilenameDirectory(DataFilename, Directory):
    def __call__(self):
        v = DataFilename.__call__(self)
        v = Directory.__call__(self)
        return v

registerGroup(supybot, 'directories')
registerGlobalValue(supybot.directories, 'conf',
    Directory('conf', _("""Determines what directory configuration data is
    put into.""")))
registerGlobalValue(supybot.directories, 'data',
    Directory('data', _("""Determines what directory data is put into.""")))
registerGlobalValue(supybot.directories, 'backup',
    Directory('backup', _("""Determines what directory backup data is put
    into. Set it to /dev/null to disable backup (it is a special value,
    so it also works on Windows and systems without /dev/null).""")))
registerGlobalValue(supybot.directories.data, 'tmp',
    DataFilenameDirectory('tmp', _("""Determines what directory temporary files
    are put into.""")))
registerGlobalValue(supybot.directories.data, 'web',
    DataFilenameDirectory('web', _("""Determines what directory files of the
    web server (templates, custom images, ...) are put into.""")))

utils.file.AtomicFile.default.tmpDir = supybot.directories.data.tmp
utils.file.AtomicFile.default.backupDir = supybot.directories.backup

registerGlobalValue(supybot.directories, 'plugins',
    registry.CommaSeparatedListOfStrings([], _("""Determines what directories
    the bot will look for plugins in.  Accepts a comma-separated list of
    strings.
    This means that to add another directory, you can nest the former value and
    add a new one.  E.g. you can say: bot: 'config supybot.directories.plugins
    [config supybot.directories.plugins], newPluginDirectory'.""")))

registerGlobalValue(supybot, 'plugins',
    registry.SpaceSeparatedSetOfStrings([], _("""Determines what plugins will
    be loaded."""), orderAlphabetically=True))
registerGlobalValue(supybot.plugins, 'alwaysLoadImportant',
    registry.Boolean(True, _("""Determines whether the bot will always load
    important plugins (Admin, Channel, Config, Misc, Owner, and User)
    regardless of what their configured state is.  Generally, if these plugins
    are configured not to load, you didn't do it on purpose, and you still
    want them to load.  Users who don't want to load these plugins are smart
    enough to change the value of this variable appropriately :)""")))

###
# supybot.databases.  For stuff relating to Supybot's databases (duh!)
###
class Databases(registry.SpaceSeparatedListOfStrings):
    def __call__(self):
        v = super(Databases, self).__call__()
        if not v:
            v = ['anydbm', 'dbm', 'cdb', 'flat', 'pickle']
            if 'sqlite' in sys.modules:
                v.insert(0, 'sqlite')
            if 'sqlite3' in sys.modules:
                v.insert(0, 'sqlite3')
            if 'sqlalchemy' in sys.modules:
                v.insert(0, 'sqlalchemy')
        return v

    def serialize(self):
        return ' '.join(self.value)

registerGlobalValue(supybot, 'databases',
    Databases([], _("""Determines what databases are available for use. If this
    value is not configured (that is, if its value is empty) then sane defaults
    will be provided.""")))

registerGroup(supybot.databases, 'users')
registerGlobalValue(supybot.databases.users, 'filename',
    registry.String('users.conf', _("""Determines what filename will be used
    for the users database.  This file will go into the directory specified by
    the supybot.directories.conf variable.""")))
registerGlobalValue(supybot.databases.users, 'timeoutIdentification',
    registry.Integer(0, _("""Determines how long it takes identification to
    time out.  If the value is less than or equal to zero, identification never
    times out.""")))
registerGlobalValue(supybot.databases.users, 'allowUnregistration',
    registry.Boolean(False, _("""Determines whether the bot will allow users to
    unregister their users.  This can wreak havoc with already-existing
    databases, so by default we don't allow it.  Enable this at your own risk.
    (Do also note that this does not prevent the owner of the bot from using
    the unregister command.)
    """)))

registerGroup(supybot.databases, 'ignores')
registerGlobalValue(supybot.databases.ignores, 'filename',
    registry.String('ignores.conf', _("""Determines what filename will be used
    for the ignores database.  This file will go into the directory specified
    by the supybot.directories.conf variable.""")))

registerGroup(supybot.databases, 'channels')
registerGlobalValue(supybot.databases.channels, 'filename',
    registry.String('channels.conf', _("""Determines what filename will be used
    for the channels database.  This file will go into the directory specified
    by the supybot.directories.conf variable.""")))

# TODO This will need to do more in the future (such as making sure link.allow
# will let the link occur), but for now let's just leave it as this.
class ChannelSpecific(registry.Boolean):
    def getChannelLink(self, channel):
        channelSpecific = supybot.databases.plugins.channelSpecific
        channels = [channel]
        def hasLinkChannel(channel):
            if not get(channelSpecific, channel):
                lchannel = get(channelSpecific.link, channel)
                if not get(channelSpecific.link.allow, lchannel):
                    return False
                return channel != lchannel
            return False
        lchannel = channel
        while hasLinkChannel(lchannel):
            lchannel = get(channelSpecific.link, lchannel)
            if lchannel not in channels:
                channels.append(lchannel)
            else:
                # Found a cyclic link.  We'll just use the current channel
                lchannel = channel
                break
        return lchannel

registerGroup(supybot.databases, 'plugins')
registerChannelValue(supybot.databases.plugins, 'channelSpecific',
    ChannelSpecific(True, _("""Determines whether database-based plugins that
    can be channel-specific will be so.  This can be overridden by individual
    channels.  Do note that the bot needs to be restarted immediately after
    changing this variable or your db plugins may not work for your channel;
    also note that you may wish to set
    supybot.databases.plugins.channelSpecific.link appropriately if you wish
    to share a certain channel's databases globally.""")))
registerChannelValue(supybot.databases.plugins.channelSpecific, 'link',
    ValidChannel('#', _("""Determines what channel global
    (non-channel-specific) databases will be considered a part of.  This is
    helpful if you've been running channel-specific for awhile and want to turn
    the databases for your primary channel into global databases.  If
    supybot.databases.plugins.channelSpecific.link.allow prevents linking, the
    current channel will be used.  Do note that the bot needs to be restarted
    immediately after changing this variable or your db plugins may not work
    for your channel.""")))
registerChannelValue(supybot.databases.plugins.channelSpecific.link, 'allow',
    registry.Boolean(True, _("""Determines whether another channel's global
    (non-channel-specific) databases will be allowed to link to this channel's
    databases.  Do note that the bot needs to be restarted immediately after
    changing this variable or your db plugins may not work for your channel.
    """)))


class CDB(registry.Boolean):
    def connect(self, filename):
        from . import cdb
        basename = os.path.basename(filename)
        journalName = supybot.directories.data.tmp.dirize(basename+'.journal')
        return cdb.open_db(filename, 'c',
                        journalName=journalName,
                        maxmods=self.maximumModifications())

registerGroup(supybot.databases, 'types')
registerGlobalValue(supybot.databases.types, 'cdb', CDB(True, _("""Determines
    whether CDB databases will be allowed as a database implementation.""")))
registerGlobalValue(supybot.databases.types.cdb, 'maximumModifications',
    registry.Probability(0.5, _("""Determines how often CDB databases will have
    their modifications flushed to disk.  When the number of modified records
    is greater than this fraction of the total number of records, the database
    will be entirely flushed to disk.""")))

# XXX Configuration variables for dbi, sqlite, flat, mysql, etc.

###
# Protocol information.
###
originalIsNick = ircutils.isNick
def isNick(s, strictRfc=None, **kw):
    if strictRfc is None:
        strictRfc = supybot.protocols.irc.strictRfc()
    return originalIsNick(s, strictRfc=strictRfc, **kw)
ircutils.isNick = isNick

###
# supybot.protocols
###
registerGroup(supybot, 'protocols')

###
# supybot.protocols.irc
###
registerGroup(supybot.protocols, 'irc')

class Banmask(registry.SpaceSeparatedSetOfStrings):
    validStrings = ('exact', 'nick', 'user', 'host')
    def __init__(self, *args, **kwargs):
        assert self.validStrings, 'There must be some valid strings.  ' \
                                  'This is a bug.'
        self.__parent = super(Banmask, self)
        self.__parent.__init__(*args, **kwargs)
        self.__doc__ = format('Valid values include %L.',
                              list(map(repr, self.validStrings)))

    def help(self):
        strings = [s for s in self.validStrings if s]
        return format('%s  Valid strings: %L.', self._help, strings)

    def normalize(self, s):
        lowered = s.lower()
        L = list(map(str.lower, self.validStrings))
        try:
            i = L.index(lowered)
        except ValueError:
            return s # This is handled in setValue.
        return self.validStrings[i]

    def setValue(self, v):
        v = list(map(self.normalize, v))
        for s in v:
            if s not in self.validStrings:
                self.error()
        self.__parent.setValue(self.List(v))

    def makeBanmask(self, hostmask, options=None, channel=None):
        """Create a banmask from the given hostmask.  If a style of banmask
        isn't specified via options, the value of
        conf.supybot.protocols.irc.banmask is used.

        options - A list specifying which parts of the hostmask should
        explicitly be matched: nick, user, host.  If 'exact' is given, then
        only the exact hostmask will be used."""
        if not channel:
            channel = dynamic.channel
        assert channel is None or ircutils.isChannel(channel)
        (nick, user, host) = ircutils.splitHostmask(hostmask)
        bnick = '*'
        buser = '*'
        bhost = '*'
        if not options:
            options = get(supybot.protocols.irc.banmask, channel)
        for option in options:
            if option == 'nick':
                bnick = nick
            elif option == 'user':
                buser = user
            elif option == 'host':
                bhost = host
            elif option == 'exact':
                return hostmask
        if (bnick, buser, bhost) == ('*', '*', '*') and \
                ircutils.isUserHostmask(hostmask):
            return hostmask
        return ircutils.joinHostmask(bnick, buser, bhost)

registerChannelValue(supybot.protocols.irc, 'banmask',
    Banmask(['user', 'host'], _("""Determines what will be used as the
    default banmask style.""")))

registerGlobalValue(supybot.protocols.irc, 'strictRfc',
    registry.Boolean(True, _("""Determines whether the bot will strictly follow
    the RFC; currently this only affects what strings are considered to be
    nicks. If you're using a server or a network that requires you to message
    a nick such as services@this.network.server then you you should set this to
    False.""")))

registerGlobalValue(supybot.protocols.irc, 'umodes',
    registry.String('', _("""Determines what user modes the bot will request
    from the server when it first connects.  Many people might choose +i; some
    networks allow +x, which indicates to the auth services on those networks
    that you should be given a fake host.""")))

registerGlobalValue(supybot.protocols.irc, 'vhost',
    registry.String('', _("""Determines what vhost the bot will bind to before
    connecting a server (IRC, HTTP, ...) via IPv4.""")))

registerGlobalValue(supybot.protocols.irc, 'vhostv6',
    registry.String('', _("""Determines what vhost the bot will bind to before
    connecting a server (IRC, HTTP, ...) via IPv6.""")))

registerGlobalValue(supybot.protocols.irc, 'maxHistoryLength',
    registry.Integer(1000, _("""Determines how many old messages the bot will
    keep around in its history.  Changing this variable will not take effect
    until the bot is restarted.""")))

registerGlobalValue(supybot.protocols.irc, 'throttleTime',
    registry.Float(1.0, _("""A floating point number of seconds to throttle
    queued messages -- that is, messages will not be sent faster than once per
    throttleTime seconds.""")))

registerGlobalValue(supybot.protocols.irc, 'ping',
    registry.Boolean(True, _("""Determines whether the bot will send PINGs to
    the server it's connected to in order to keep the connection alive and
    discover earlier when it breaks.  Really, this option only exists for
    debugging purposes: you always should make it True unless you're testing
    some strange server issues.""")))

registerGlobalValue(supybot.protocols.irc.ping, 'interval',
    registry.Integer(120, _("""Determines the number of seconds between sending
    pings to the server, if pings are being sent to the server.""")))

registerGroup(supybot.protocols.irc, 'queuing')
registerGlobalValue(supybot.protocols.irc.queuing, 'duplicates',
    registry.Boolean(False, _("""Determines whether the bot will refuse
    duplicated messages to be queued for delivery to the server.  This is a
    safety mechanism put in place to prevent plugins from sending the same
    message multiple times; most of the time it doesn't matter, unless you're
    doing certain kinds of plugin hacking.""")))

registerGroup(supybot.protocols.irc.queuing, 'rateLimit')
registerGlobalValue(supybot.protocols.irc.queuing.rateLimit, 'join',
    registry.Float(0, _("""Determines how many seconds must elapse between
    JOINs sent to the server.""")))

###
# supybot.protocols.http
###
registerGroup(supybot.protocols, 'http')
registerGlobalValue(supybot.protocols.http, 'peekSize',
    registry.PositiveInteger(4096, _("""Determines how many bytes the bot will
    'peek' at when looking through a URL for a doctype or title or something
    similar.  It'll give up after it reads this many bytes, even if it hasn't
    found what it was looking for.""")))

registerGlobalValue(supybot.protocols.http, 'proxy',
    registry.String('', _("""Determines what proxy all HTTP requests should go
    through.  The value should be of the form 'host:port'.""")))
utils.web.proxy = supybot.protocols.http.proxy


###
# HTTP server
###
registerGroup(supybot, 'servers')
registerGroup(supybot.servers, 'http')

class IP(registry.String):
    """Value must be a valid IP."""
    def setValue(self, v):
        if v and not utils.net.isIP(v):
            self.error()
        else:
            registry.String.setValue(self, v)

registerGlobalValue(supybot.servers.http, 'hosts4',
    IP('0.0.0.0', _("""Space-separated list of IPv4 hosts the HTTP server
    will bind.""")))
registerGlobalValue(supybot.servers.http, 'hosts6',
    IP('', _("""Space-separated list of IPv6 hosts the HTTP server will
    bind.""")))
registerGlobalValue(supybot.servers.http, 'port',
    registry.Integer(8080, _("""Determines what port the HTTP server will
    bind.""")))
registerGlobalValue(supybot.servers.http, 'keepAlive',
    registry.Boolean(False, _("""Determines whether the server will stay
    alive if no plugin is using it. This also means that the server will
    start even if it is not used.""")))
registerGlobalValue(supybot.servers.http, 'favicon',
    registry.String('', _("""Determines the path of the file served as
    favicon to browsers.""")))


###
# Especially boring stuff.
###
registerGlobalValue(supybot, 'defaultIgnore',
    registry.Boolean(False, _("""Determines whether the bot will ignore
    unregistered users by default.  Of course, that'll make it particularly
    hard for those users to register or identify with the bot, but that's your
    problem to solve.""")))


registerGlobalValue(supybot, 'externalIP',
   IP('', _("""A string that is the external IP of the bot.  If this is the
   empty string, the bot will attempt to find out its IP dynamically (though
   sometimes that doesn't work, hence this variable).""")))

class SocketTimeout(registry.PositiveInteger):
    """Value must be an integer greater than supybot.drivers.poll and must be
    greater than or equal to 1."""
    def setValue(self, v):
        if v < supybot.drivers.poll() or v < 1:
            self.error()
        registry.PositiveInteger.setValue(self, v)
        socket.setdefaulttimeout(self.value)

registerGlobalValue(supybot, 'defaultSocketTimeout',
    SocketTimeout(10, _("""Determines what the default timeout for socket
    objects will be.  This means that *all* sockets will timeout when this many
    seconds has gone by (unless otherwise modified by the author of the code
    that uses the sockets).""")))

registerGlobalValue(supybot, 'pidFile',
    registry.String('', _("""Determines what file the bot should write its PID
    (Process ID) to, so you can kill it more easily.  If it's left unset (as is
    the default) then no PID file will be written.  A restart is required for
    changes to this variable to take effect.""")))

###
# Debugging options.
###
registerGroup(supybot, 'debug')
registerGlobalValue(supybot.debug, 'threadAllCommands',
    registry.Boolean(False, _("""Determines whether the bot will automatically
    thread all commands.""")))
registerGlobalValue(supybot.debug, 'flushVeryOften',
    registry.Boolean(False, _("""Determines whether the bot will automatically
    flush all flushers *very* often.  Useful for debugging when you don't know
    what's breaking or when, but think that it might be logged.""")))


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = dbi
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

"""
Module for some slight database-independence for simple databases.
"""

import os
import csv
import math

from . import cdb, utils
from .utils.iter import ilen

class Error(Exception):
    """General error for this module."""

class NoRecordError(KeyError):
    pass

class InvalidDBError(Exception):
    pass

class MappingInterface(object):
    """This is a class to represent the underlying representation of a map
    from integer keys to strings."""
    def __init__(self, filename, **kwargs):
        """Feel free to ignore the filename."""
        raise NotImplementedError

    def get(id):
        """Gets the record matching id.  Raises NoRecordError otherwise."""
        raise NotImplementedError

    def set(id, s):
        """Sets the record matching id to s."""
        raise NotImplementedError

    def add(self, s):
        """Adds a new record, returning a new id for it."""
        raise NotImplementedError

    def remove(self, id):
        "Returns and removes the record with the given id from the database."
        raise NotImplementedError

    def __iter__(self):
        "Return an iterator over (id, s) pairs.  Not required to be ordered."
        raise NotImplementedError

    def flush(self):
        """Flushes current state to disk."""
        raise NotImplementedError

    def close(self):
        """Flushes current state to disk and invalidates the Mapping."""
        raise NotImplementedError

    def vacuum(self):
        "Cleans up in the database, if possible.  Not required to do anything."
        pass


class DirMapping(MappingInterface):
    def __init__(self, filename, **kwargs):
        self.dirname = filename
        if not os.path.exists(self.dirname):
            os.mkdir(self.dirname)
        if not os.path.exists(os.path.join(self.dirname, 'max')):
            self._setMax(1)

    def _setMax(self, id):
        fd = open(os.path.join(self.dirname, 'max'), 'w')
        try:
            fd.write(str(id))
        finally:
            fd.close()

    def _getMax(self):
        fd = open(os.path.join(self.dirname, 'max'))
        try:
            i = int(fd.read())
            return i
        finally:
            fd.close()

    def _makeFilename(self, id):
        return os.path.join(self.dirname, str(id))

    def get(self, id):
        try:
            fd = open(self._makeFilename(id))
            return fd.read()
        except EnvironmentError as e:
            exn = NoRecordError(id)
            exn.realException = e
            raise exn
        finally:
            fd.close()

    def set(self, id, s):
        fd = open(self._makeFilename(id), 'w')
        fd.write(s)
        fd.close()

    def add(self, s):
        id = self._getMax()
        fd = open(self._makeFilename(id), 'w')
        try:
            fd.write(s)
            return id
        finally:
            fd.close()

    def remove(self, id):
        try:
            os.remove(self._makeFilename(id))
        except EnvironmentError as e:
            raise NoRecordError(id)

class FlatfileMapping(MappingInterface):
    def __init__(self, filename, maxSize=10**6):
        self.filename = filename
        try:
            fd = open(self.filename)
            strId = fd.readline().rstrip()
            self.maxSize = len(strId)
            try:
                self.currentId = int(strId)
            except ValueError:
                raise Error('Invalid file for FlatfileMapping: %s' % filename)
        except EnvironmentError as e:
            # File couldn't be opened.
            self.maxSize = int(math.log10(maxSize))
            self.currentId = 0
            self._incrementCurrentId()
        finally:
            if 'fd' in locals():
                fd.close()

    def _canonicalId(self, id):
        if id is not None:
            return str(id).zfill(self.maxSize)
        else:
            return '-'*self.maxSize
    
    def _incrementCurrentId(self, fd=None):
        fdWasNone = fd is None
        if fdWasNone:
            fd = open(self.filename, 'a')
        fd.seek(0)
        self.currentId += 1
        fd.write(self._canonicalId(self.currentId))
        fd.write('\n')
        if fdWasNone:
            fd.close()
        
    def _splitLine(self, line):
        line = line.rstrip('\r\n')
        (id, s) = line.split(':', 1)
        return (id, s)

    def _joinLine(self, id, s):
        return '%s:%s\n' % (self._canonicalId(id), s)

    def add(self, s):
        line = self._joinLine(self.currentId, s)
        fd = open(self.filename, 'r+')
        try:
            fd.seek(0, 2) # End.
            fd.write(line)
            return self.currentId
        finally:
            self._incrementCurrentId(fd)
            fd.close()

    def get(self, id):
        strId = self._canonicalId(id)
        try:
            fd = open(self.filename)
            fd.readline() # First line, nextId.
            for line in fd:
                (lineId, s) = self._splitLine(line)
                if lineId == strId:
                    return s
            raise NoRecordError(id)
        finally:
            fd.close()

    # XXX This assumes it's not been given out.  We should make sure that our
    #     maximum id remains accurate if this is some value we've never given
    #     out -- i.e., self.maxid = max(self.maxid, id) or something.
    def set(self, id, s):
        strLine = self._joinLine(id, s)
        try:
            fd = open(self.filename, 'r+')
            self.remove(id, fd)
            fd.seek(0, 2) # End.
            fd.write(strLine)
        finally:
            fd.close()

    def remove(self, id, fd=None):
        fdWasNone = fd is None
        strId = self._canonicalId(id)
        try:
            if fdWasNone:
                fd = open(self.filename, 'r+')
            fd.seek(0)
            fd.readline() # First line, nextId
            pos = fd.tell()
            line = fd.readline()
            while line:
                (lineId, _) = self._splitLine(line)
                if lineId == strId:
                    fd.seek(pos)
                    fd.write(self._canonicalId(None))
                    fd.seek(pos)
                    fd.readline() # Same line we just rewrote the id for.
                pos = fd.tell()
                line = fd.readline()
            # We should be at the end.
        finally:
            if fdWasNone:
                fd.close()

    def __iter__(self):
        fd = open(self.filename)
        fd.readline() # First line, nextId.
        for line in fd:
            (id, s) = self._splitLine(line)
            if not id.startswith('-'):
                yield (int(id), s)
        fd.close()

    def vacuum(self):
        infd = open(self.filename)
        outfd = utils.file.AtomicFile(self.filename,makeBackupIfSmaller=False)
        outfd.write(infd.readline()) # First line, nextId.
        for line in infd:
            if not line.startswith('-'):
                outfd.write(line)
        infd.close()
        outfd.close()

    def flush(self):
        pass # No-op, we maintain no open files.

    def close(self):
        self.vacuum() # Should we do this?  It should be fine.
        

class CdbMapping(MappingInterface):
    def __init__(self, filename, **kwargs):
        self.filename = filename
        self._openCdb() # So it can be overridden later.
        if 'nextId' not in self.db:
            self.db['nextId'] = '1'

    def _openCdb(self, *args, **kwargs):
        self.db = cdb.open_db(self.filename, 'c', **kwargs)

    def _getNextId(self):
        i = int(self.db['nextId'])
        self.db['nextId'] = str(i+1)
        return i

    def get(self, id):
        try:
            return self.db[str(id)]
        except KeyError:
            raise NoRecordError(id)

    # XXX Same as above.
    def set(self, id, s):
        self.db[str(id)] = s

    def add(self, s):
        id = self._getNextId()
        self.set(id, s)
        return id

    def remove(self, id):
        del self.db[str(id)]

    def __iter__(self):
        for (id, s) in self.db.iteritems():
            if id != 'nextId':
                yield (int(id), s)

    def flush(self):
        self.db.flush()

    def close(self):
        self.db.close()


class DB(object):
    Mapping = 'flat' # This is a good, sane default.
    Record = None
    def __init__(self, filename, Mapping=None, Record=None):
        if Record is not None:
            self.Record = Record
        if Mapping is not None:
            self.Mapping = Mapping
        if isinstance(self.Mapping, basestring):
            self.Mapping = Mappings[self.Mapping]
        self.map = self.Mapping(filename)

    def _newRecord(self, id, s):
        record = self.Record(id=id)
        record.deserialize(s)
        return record 

    def get(self, id):
        s = self.map.get(id)
        return self._newRecord(id, s)

    def set(self, id, record):
        s = record.serialize()
        self.map.set(id, s)

    def add(self, record):
        s = record.serialize()
        id = self.map.add(s)
        record.id = id
        return id

    def remove(self, id):
        self.map.remove(id)

    def __iter__(self):
        for (id, s) in self.map:
            # We don't need to yield the id because it's in the record.
            yield self._newRecord(id, s)

    def select(self, p):
        for record in self:
            if p(record):
                yield record

    def random(self):
        try:
            return self._newRecord(*utils.iter.choice(self.map))
        except IndexError:
            return None

    def size(self):
        return ilen(self.map)

    def flush(self):
        self.map.flush()

    def vacuum(self):
        self.map.vacuum()

    def close(self):
        self.map.close()

Mappings = {
    'cdb': CdbMapping,
    'flat': FlatfileMapping,
    }


class Record(object):
    def __init__(self, id=None, **kwargs):
        if id is not None:
            assert isinstance(id, int), 'id must be an integer.'
        self.id = id
        self.fields = []
        self.defaults = {}
        self.converters = {}
        for name in self.__fields__:
            if isinstance(name, tuple):
                (name, spec) = name
            else:
                spec = utils.safeEval
            assert name != 'id'
            self.fields.append(name)
            if isinstance(spec, tuple):
                (converter, default) = spec
            else:
                converter = spec
                default = None
            self.defaults[name] = default
            self.converters[name] = converter
        seen = set()
        for (name, value) in kwargs.iteritems():
            assert name in self.fields, 'name must be a record value.'
            seen.add(name)
            setattr(self, name, value)
        for name in self.fields:
            if name not in seen:
                default = self.defaults[name]
                if callable(default):
                    default = default()
                setattr(self, name, default)

    def serialize(self):
        return csv.join([repr(getattr(self, name)) for name in self.fields])

    def deserialize(self, s):
        unseenRecords = set(self.fields)
        for (name, strValue) in zip(self.fields, csv.split(s)):
            setattr(self, name, self.converters[name](strValue))
            unseenRecords.remove(name)
        for name in unseenRecords:
            setattr(self, name, self.defaults[name])

    
# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = Socket
##
# Copyright (c) 2002-2004, Jeremiah Fincher
# Copyright (c) 2010, 2013, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

"""
Contains simple socket drivers.  Asyncore bugged (haha, pun!) me.
"""

from __future__ import division

import os
import sys
import time
import errno
import select
import socket

from .. import (conf, drivers, log, schedule, utils, world)
from ..utils.iter import imap
try:
    from charade.universaldetector import UniversalDetector
    charadeLoaded = True
except:
    drivers.log.debug('charade module not available, '
                      'cannot guess character encoding if'
                      'using Python3')
    charadeLoaded = False

try:
    import ssl
    SSLError = ssl.SSLError
except:
    drivers.log.debug('ssl module is not available, '
                      'cannot connect to SSL servers.')
    class SSLError(Exception):
        pass


class SocketDriver(drivers.IrcDriver, drivers.ServersMixin):
    _instances = []
    _selecting = [False] # We want it to be mutable.
    def __init__(self, irc):
        self._instances.append(self)
        assert irc is not None
        self.irc = irc
        drivers.IrcDriver.__init__(self, irc)
        drivers.ServersMixin.__init__(self, irc)
        self.conn = None
        self._attempt = -1
        self.servers = ()
        self.eagains = 0
        self.inbuffer = b''
        self.outbuffer = ''
        self.zombie = False
        self.connected = False
        self.writeCheckTime = None
        self.nextReconnectTime = None
        self.resetDelay()
        if self.networkGroup.get('ssl').value and 'ssl' not in globals():
            drivers.log.error('The Socket driver can not connect to SSL '
                              'servers for your Python version.  Try the '
                              'Twisted driver instead, or install a Python'
                              'version that supports SSL (2.6 and greater).')
        else:
            self.connect()

    def getDelay(self):
        ret = self.currentDelay
        self.currentDelay = min(self.currentDelay * 2,
                                conf.supybot.drivers.maxReconnectWait())
        return ret

    def resetDelay(self):
        self.currentDelay = 10.0

    def _getNextServer(self):
        oldServer = getattr(self, 'currentServer', None)
        server = drivers.ServersMixin._getNextServer(self)
        if self.currentServer != oldServer:
            self.resetDelay()
        return server

    def _handleSocketError(self, e):
        # (11, 'Resource temporarily unavailable') raised if connect
        # hasn't finished yet.  We'll keep track of how many we get.
        if e.args[0] != 11 or self.eagains > 120:
            drivers.log.disconnect(self.currentServer, e)
            if self in self._instances:
                self._instances.remove(self)
            try:
                self.conn.close()
            except:
                pass
            self.connected = False
            self.scheduleReconnect()
        else:
            log.debug('Got EAGAIN, current count: %s.', self.eagains)
            self.eagains += 1

    def _sendIfMsgs(self):
        if not self.connected:
            return
        if not self.zombie:
            msgs = [self.irc.takeMsg()]
            while msgs[-1] is not None:
                msgs.append(self.irc.takeMsg())
            del msgs[-1]
            self.outbuffer += ''.join(map(str, msgs))
        if self.outbuffer:
            try:
                if sys.version_info[0] < 3:
                    sent = self.conn.send(self.outbuffer)
                else:
                    sent = self.conn.send(self.outbuffer.encode())
                self.outbuffer = self.outbuffer[sent:]
                self.eagains = 0
            except socket.error as e:
                self._handleSocketError(e)
        if self.zombie and not self.outbuffer:
            self._reallyDie()

    @classmethod
    def _select(cls):
        if cls._selecting[0]:
            return
        try:
            cls._selecting[0] = True
            for inst in cls._instances:
                # Do not use a list comprehension here, we have to edit the list
                # and not to reassign it.
                if not inst.connected or \
                        (sys.version_info[0] == 3 and inst.conn._closed) or \
                        (sys.version_info[0] == 2 and
                            inst.conn._sock.__class__ is socket._closedsocket):
                    cls._instances.remove(inst)
                elif inst.conn.fileno() == -1:
                    inst.reconnect()
            if not cls._instances:
                return
            rlist, wlist, xlist = select.select([x.conn for x in cls._instances],
                    [], [], conf.supybot.drivers.poll())
            for instance in cls._instances:
                if instance.conn in rlist:
                    instance._read()
        except select.error as e:
            if e.args[0] != errno.EINTR:
                # 'Interrupted system call'
                raise
        finally:
            cls._selecting[0] = False
        for instance in cls._instances:
            if instance.irc and not instance.irc.zombie:
                instance._sendIfMsgs()


    def run(self):
        now = time.time()
        if self.nextReconnectTime is not None and now > self.nextReconnectTime:
            self.reconnect()
        elif self.writeCheckTime is not None and now > self.writeCheckTime:
            self._checkAndWriteOrReconnect()
        if not self.connected:
            # We sleep here because otherwise, if we're the only driver, we'll
            # spin at 100% CPU while we're disconnected.
            time.sleep(conf.supybot.drivers.poll())
            return
        self._sendIfMsgs()
        self._select()

    def _read(self):
        """Called by _select() when we can read data."""
        try:
            self.inbuffer += self.conn.recv(1024)
            self.eagains = 0 # If we successfully recv'ed, we can reset this.
            lines = self.inbuffer.split(b'\n')
            self.inbuffer = lines.pop()
            for line in lines:
                if sys.version_info[0] >= 3:
                    #first, try to decode using utf-8
                    try:
                        line = line.decode('utf8', 'strict')
                    except UnicodeError:
                        # if this fails and charade is loaded, try to guess the correct encoding
                        if charadeLoaded:
                            u = UniversalDetector()
                            u.feed(line)
                            u.close()
                            if u.result['encoding']:
                                # try to use the guessed encoding
                                try:
                                    line = line.decode(u.result['encoding'],
                                        'strict')
                                # on error, give up and replace the offending characters
                                except UnicodeError:
                                    line = line.decode(errors='replace')
                            else:
                                # if no encoding could be guessed, fall back to utf-8 and
                                # replace offending characters
                                line = line.decode('utf8', 'replace')
                        # if charade is not loaded, try to decode using utf-8 and replace any
                        # offending characters
                        else:
                            line = line.decode('utf8', 'replace')

                msg = drivers.parseMsg(line)
                if msg is not None and self.irc is not None:
                    self.irc.feedMsg(msg)
        except socket.timeout:
            pass
        except SSLError as e:
            if e.args[0] == 'The read operation timed out':
                pass
            else:
                self._handleSocketError(e)
                return
        except socket.error as e:
            self._handleSocketError(e)
            return
        if self.irc and not self.irc.zombie:
            self._sendIfMsgs()

    def connect(self, **kwargs):
        self.reconnect(reset=False, **kwargs)

    def reconnect(self, wait=False, reset=True):
        self._attempt += 1
        self.nextReconnectTime = None
        if self.connected:
            drivers.log.reconnect(self.irc.network)
            if self in self._instances:
                self._instances.remove(self)
            try:
                self.conn.shutdown(socket.SHUT_RDWR)
            except: # "Transport endpoint not connected"
                pass
            self.conn.close()
            self.connected = False
        if reset:
            drivers.log.debug('Resetting %s.', self.irc)
            self.irc.reset()
        else:
            drivers.log.debug('Not resetting %s.', self.irc)
        if wait:
            self.scheduleReconnect()
            return
        server = self._getNextServer()
        socks_proxy = getattr(conf.supybot.networks, self.irc.network) \
                .socksproxy()
        resolver = None
        try:
            if socks_proxy:
                import socks
        except ImportError:
            log.error('Cannot use socks proxy (SocksiPy not installed), '
                    'using direct connection instead.')
            socks_proxy = ''
        if socks_proxy:
            address = server[0]
        else:
            try:
                address = utils.net.getAddressFromHostname(server[0],
                        attempt=self._attempt)
            except socket.gaierror as e:
                drivers.log.connectError(self.currentServer, e)
                self.scheduleReconnect()
                return
        port = server[1]
        drivers.log.connect(self.currentServer)
        try:
            self.conn = utils.net.getSocket(address, port=port,
                    socks_proxy=socks_proxy)
        except socket.error as e:
            drivers.log.connectError(self.currentServer, e)
            self.scheduleReconnect()
            return
        # We allow more time for the connect here, since it might take longer.
        # At least 10 seconds.
        self.conn.settimeout(max(10, conf.supybot.drivers.poll()*10))
        try:
            if getattr(conf.supybot.networks, self.irc.network).ssl():
                assert 'ssl' in globals()
                certfile = getattr(conf.supybot.networks, self.irc.network) \
                        .certfile()
                if not certfile:
                    certfile = None
                elif not os.path.isfile(certfile):
                    drivers.log.warning('Could not find cert file %s.' %
                            certfile)
                    certfile = None
                self.conn = ssl.wrap_socket(self.conn, certfile=certfile)
            self.conn.connect((address, server[1]))
            def setTimeout():
                self.conn.settimeout(conf.supybot.drivers.poll())
            conf.supybot.drivers.poll.addCallback(setTimeout)
            setTimeout()
            self.connected = True
            self.resetDelay()
        except socket.error as e:
            if e.args[0] == 115:
                now = time.time()
                when = now + 60
                whenS = log.timestamp(when)
                drivers.log.debug('Connection in progress, scheduling '
                                  'connectedness check for %s', whenS)
                self.writeCheckTime = when
            else:
                drivers.log.connectError(self.currentServer, e)
                self.scheduleReconnect()
            return
        self._instances.append(self)

    def _checkAndWriteOrReconnect(self):
        self.writeCheckTime = None
        drivers.log.debug('Checking whether we are connected.')
        (_, w, _) = select.select([], [self.conn], [], 0)
        if w:
            drivers.log.debug('Socket is writable, it might be connected.')
            self.connected = True
            self.resetDelay()
        else:
            drivers.log.connectError(self.currentServer, 'Timed out')
            self.reconnect()

    def scheduleReconnect(self):
        when = time.time() + self.getDelay()
        if not world.dying:
            drivers.log.reconnect(self.irc.network, when)
        if self.nextReconnectTime:
            drivers.log.error('Updating next reconnect time when one is '
                              'already present.  This is a bug; please '
                              'report it, with an explanation of what caused '
                              'this to happen.')
        self.nextReconnectTime = when

    def die(self):
        if self in self._instances:
            self._instances.remove(self)
        self.zombie = True
        if self.nextReconnectTime is not None:
            self.nextReconnectTime = None
        if self.writeCheckTime is not None:
            self.writeCheckTime = None
        drivers.log.die(self.irc)

    def _reallyDie(self):
        if self.conn is not None:
            self.conn.close()
        drivers.IrcDriver.die(self)
        # self.irc.die() Kill off the ircs yourself, jerk!

    def name(self):
        return '%s(%s)' % (self.__class__.__name__, self.irc)


Driver = SocketDriver

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:


########NEW FILE########
__FILENAME__ = Twisted
###
# Copyright (c) 2002-2004, Jeremiah Fincher
# Copyright (c) 2009, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from .. import conf, drivers, ircmsgs, log

from twisted.names import client
from twisted.internet import reactor, error
from twisted.protocols.basic import LineReceiver
from twisted.internet.protocol import ReconnectingClientFactory


# This hack prevents the standard Twisted resolver from starting any
# threads, which allows for a clean shut-down in Twisted>=2.0
reactor.installResolver(client.createResolver())


try:
    from OpenSSL import SSL
    from twisted.internet import ssl
except ImportError:
    drivers.log.debug('PyOpenSSL is not available, '
                      'cannot connect to SSL servers.')
    SSL = None

class TwistedRunnerDriver(drivers.IrcDriver):
    def name(self):
        return self.__class__.__name__

    def run(self):
        try:
            reactor.iterate(conf.supybot.drivers.poll())
        except:
            drivers.log.exception('Uncaught exception outside reactor:')

class SupyIrcProtocol(LineReceiver):
    delimiter = '\n'
    MAX_LENGTH = 1024
    def __init__(self):
        self.mostRecentCall = reactor.callLater(0.1, self.checkIrcForMsgs)

    def lineReceived(self, line):
        msg = drivers.parseMsg(line)
        if msg is not None:
            self.irc.feedMsg(msg)

    def checkIrcForMsgs(self):
        if self.connected:
            msg = self.irc.takeMsg()
            while msg:
                self.transport.write(str(msg))
                msg = self.irc.takeMsg()
        self.mostRecentCall = reactor.callLater(0.1, self.checkIrcForMsgs)

    def connectionLost(self, r):
        self.mostRecentCall.cancel()
        if r.check(error.ConnectionDone):
            drivers.log.disconnect(self.factory.currentServer)
        else:
            drivers.log.disconnect(self.factory.currentServer, errorMsg(r))
        if self.irc.zombie:
            self.factory.stopTrying()
            while self.irc.takeMsg():
                continue
        else:
            self.irc.reset()

    def connectionMade(self):
        self.factory.resetDelay()
        self.irc.driver = self

    def die(self):
        drivers.log.die(self.irc)
        self.factory.stopTrying()
        self.transport.loseConnection()

    def reconnect(self, wait=None):
        # We ignore wait here, because we handled our own waiting.
        drivers.log.reconnect(self.irc.network)
        self.transport.loseConnection()

def errorMsg(reason):
    return reason.getErrorMessage()

class SupyReconnectingFactory(ReconnectingClientFactory, drivers.ServersMixin):
    maxDelay = property(lambda self: conf.supybot.drivers.maxReconnectWait())
    protocol = SupyIrcProtocol
    def __init__(self, irc):
        self.irc = irc
        drivers.ServersMixin.__init__(self, irc)
        (server, port) = self._getNextServer()
        vhost = conf.supybot.protocols.irc.vhost()
        if self.networkGroup.get('ssl').value:
            self.connectSSL(server, port, vhost)
        else:
            self.connectTCP(server, port, vhost)

    def connectTCP(self, server, port, vhost):
        """Connect to the server with a standard TCP connection."""
        reactor.connectTCP(server, port, self, bindAddress=(vhost, 0))

    def connectSSL(self, server, port, vhost):
        """Connect to the server using an SSL socket."""
        drivers.log.info('Attempting an SSL connection.')
        if SSL:
            reactor.connectSSL(server, port, self,
                ssl.ClientContextFactory(), bindAddress=(vhost, 0))
        else:
            drivers.log.error('PyOpenSSL is not available. Not connecting.')

    def clientConnectionFailed(self, connector, r):
        drivers.log.connectError(self.currentServer, errorMsg(r))
        (connector.host, connector.port) = self._getNextServer()
        ReconnectingClientFactory.clientConnectionFailed(self, connector,r)

    def clientConnectionLost(self, connector, r):
        (connector.host, connector.port) = self._getNextServer()
        ReconnectingClientFactory.clientConnectionLost(self, connector, r)

    def startedConnecting(self, connector):
        drivers.log.connect(self.currentServer)

    def buildProtocol(self, addr):
        protocol = ReconnectingClientFactory.buildProtocol(self, addr)
        protocol.irc = self.irc
        return protocol

Driver = SupyReconnectingFactory
poller = TwistedRunnerDriver()

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = dynamicScope
###
# Copyright (c) 2004-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import sys

class DynamicScope(object):
    def _getLocals(self, name):
        f = sys._getframe().f_back.f_back # _getLocals <- __[gs]etattr__ <- ...
        while f:
            if name in f.f_locals:
                return f.f_locals
            f = f.f_back
        raise NameError(name)
    
    def __getattr__(self, name):
        try:
            return self._getLocals(name)[name]
        except (NameError, KeyError):
            return None
            
    def __setattr__(self, name, value):
        self._getLocals(name)[name] = value

(__builtins__ if isinstance(__builtins__, dict) else __builtins__.__dict__)['dynamic'] = DynamicScope()

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = gpg
###
# Copyright (c) 2012, Valentin Lorentz
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import os

import supybot.log as log
import supybot.conf as conf
import supybot.world as world

try:
    import gnupg
except ImportError:
    # As we do not want Supybot to depend on GnuPG, we will use it only if
    # it is available. Otherwise, we just don't allow user auth through GPG.
    log.debug('Cannot import gnupg, using fallback.')
    gnupg = None
try:
    if gnupg:
        gnupg.GPG(gnupghome=None)
except TypeError:
    # This is the 'gnupg' library, not 'python-gnupg'.
    gnupg = None

available = (gnupg is not None)

def fallback(default_return=None):
    """Decorator.
    Does nothing if gnupg is loaded. Otherwise, returns the supplied
    default value."""
    def decorator(f):
        if available:
            def newf(*args, **kwargs):
                return f(*args, **kwargs)
        else:
            def newf(*args, **kwargs):
                return default_return
        return newf
    return decorator

@fallback()
def loadKeyring():
    global keyring
    path = os.path.abspath(conf.supybot.directories.data.dirize('GPGkeyring'))
    if not os.path.isdir(path):
        log.info('Creating directory %s' % path)
        os.mkdir(path, 0700)
    assert os.path.isdir(path)
    keyring = gnupg.GPG(gnupghome=path)
loadKeyring()

# Reload the keyring if path changed
conf.supybot.directories.data.addCallback(loadKeyring)

########NEW FILE########
__FILENAME__ = httpserver
###
# Copyright (c) 2011, Valentin Lorentz
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

"""
An embedded and centralized HTTP server for Supybot's plugins.
"""

import os
import sys
import cgi
import socket
from threading import Event, Thread
from cStringIO import StringIO
from SocketServer import ThreadingMixIn
from BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler
# For testing purposes
from SocketServer import StreamRequestHandler

import supybot.log as log
import supybot.conf as conf
import supybot.world as world
from supybot.i18n import PluginInternationalization
_ = PluginInternationalization()

configGroup = conf.supybot.servers.http

class RequestNotHandled(Exception):
    pass

DEFAULT_TEMPLATES = {
    'index.html': """\
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <title>""" + _('Supybot Web server index') + """</title>
  <link rel="stylesheet" type="text/css" href="/default.css" media="screen" />
 </head>
 <body class="purelisting">
  <h1>Supybot web server index</h1>
  <p>""" + _('Here is a list of the plugins that have a Web interface:') +\
  """
  </p>
  %(list)s
 </body>
</html>""",
    'generic/error.html': """\
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <title>%(title)s</title>
  <link rel="stylesheet" href="/default.css" />
 </head>
 <body class="error">
  <h1>Error</h1>
  <p>%(error)s</p>
 </body>
</html>""",
    'default.css': """\
body {
    background-color: #F0F0F0;
}

/************************************
 * Classes that plugins should use. *
 ************************************/

/* Error pages */
body.error {
    text-align: center;
}
body.error p {
    background-color: #FFE0E0;
    border: 1px #FFA0A0 solid;
}

/* Pages that only contain a list. */
.purelisting {
    text-align: center;
}
.purelisting ul {
    margin: 0;
    padding: 0;
}
.purelisting ul li {
    margin: 0;
    padding: 0;
    list-style-type: none;
}

/* Pages that only contain a table. */
.puretable {
    text-align: center;
}
.puretable table
{
    width: 100%;
    border-collapse: collapse;
    text-align: center;
}

.puretable table th
{
    /*color: #039;*/
    padding: 10px 8px;
    border-bottom: 2px solid #6678b1;
}

.puretable table td
{
    padding: 9px 8px 0px 8px;
    border-bottom: 1px solid #ccc;
}

""",
    'robots.txt': """""",
    }

def set_default_templates(defaults):
    for filename, content in defaults.items():
        path = conf.supybot.directories.data.web.dirize(filename)
        if os.path.isfile(path + '.example'):
            os.unlink(path + '.example')
        if not os.path.isdir(os.path.dirname(path)):
            os.makedirs(os.path.dirname(path))
        with open(path + '.example', 'a') as fd:
            fd.write(content)
set_default_templates(DEFAULT_TEMPLATES)

def get_template(filename):
    path = conf.supybot.directories.data.web.dirize(filename)
    if os.path.isfile(path):
        with open(path, 'r') as fd:
            return fd.read()
    else:
        assert os.path.isfile(path + '.example'), path + '.example'
        with open(path + '.example', 'r') as fd:
            return fd.read()

class RealSupyHTTPServer(HTTPServer):
    # TODO: make this configurable
    timeout = 0.5
    running = False

    def __init__(self, address, protocol, callback):
        if protocol == 4:
            self.address_family = socket.AF_INET
        elif protocol == 6:
            self.address_family = socket.AF_INET6
        else:
            raise AssertionError(protocol)
        HTTPServer.__init__(self, address, callback)
        self.callbacks = {}

    def hook(self, subdir, callback):
        if subdir in self.callbacks:
            log.warning(('The HTTP subdirectory `%s` was already hooked but '
                    'has been claimed by another plugin (or maybe you '
                    'reloaded the plugin and it didn\'t properly unhook. '
                    'Forced unhook.') % subdir)
        self.callbacks[subdir] = callback
        callback.doHook(self, subdir)
    def unhook(self, subdir):
        callback = self.callbacks.pop(subdir) # May raise a KeyError. We don't care.
        callback.doUnhook(self)
        return callback

    def __str__(self):
        return 'server at %s %i' % self.server_address[0:2]

class TestSupyHTTPServer(RealSupyHTTPServer):
    def __init__(self, *args, **kwargs):
        self.callbacks = {}
    def serve_forever(self, *args, **kwargs):
        pass
    def shutdown(self, *args, **kwargs):
        pass

if world.testing:
    SupyHTTPServer = TestSupyHTTPServer
else:
    SupyHTTPServer = RealSupyHTTPServer

class SupyHTTPRequestHandler(BaseHTTPRequestHandler):
    def do_X(self, callbackMethod, *args, **kwargs):
        if self.path == '/':
            callback = SupyIndex()
        elif self.path in ('/robots.txt',):
            callback = Static('text/plain; charset=utf-8')
        elif self.path in ('/default.css',):
            callback = Static('text/css')
        elif self.path == '/favicon.ico':
            callback = Favicon()
        else:
            subdir = self.path.split('/')[1]
            try:
                callback = self.server.callbacks[subdir]
            except KeyError:
                callback = Supy404()

        # Some shortcuts
        for name in ('send_response', 'send_header', 'end_headers', 'rfile',
                'wfile', 'headers'):
            setattr(callback, name, getattr(self, name))
        # We call doX, because this is more supybotic than do_X.
        path = self.path
        if not callback.fullpath:
            path = '/' + path.split('/', 2)[-1]
        getattr(callback, callbackMethod)(self, path,
                *args, **kwargs)

    def do_GET(self):
        self.do_X('doGet')

    def do_POST(self):
        if 'Content-Type' not in self.headers:
            self.headers['Content-Type'] = 'application/x-www-form-urlencoded'
        form = cgi.FieldStorage(
            fp=self.rfile,
            headers=self.headers,
            environ={'REQUEST_METHOD':'POST',
                     'CONTENT_TYPE':self.headers['Content-Type'],
                     })
        self.do_X('doPost', form=form)

    def do_HEAD(self):
        self.do_X('doHead')


    def log_message(self, format, *args):
        log.info('HTTP request: %s - %s' %
                (self.address_string(), format % args))

class SupyHTTPServerCallback(object):
    """This is a base class that should be overriden by any plugin that want
    to have a Web interface."""
    __metaclass__ = log.MetaFirewall
    __firewalled__ = {'doGet': None,
                      'doPost': None,
                      'doHead': None,
                      'doPut': None,
                      'doDelete': None,
                     }


    fullpath = False
    name = "Unnamed plugin"
    defaultResponse = _("""
    This is a default response of the Supybot HTTP server. If you see this
    message, it probably means you are developing a plugin, and you have
    neither overriden this message or defined an handler for this query.""")

    def doGet(self, handler, path, *args, **kwargs):
        handler.send_response(400)
        self.send_header('Content-Type', 'text/plain; charset=utf-8; charset=utf-8')
        self.send_header('Content-Length', len(self.defaultResponse))
        self.end_headers()
        self.wfile.write(self.defaultResponse.encode())

    doPost = doHead = doGet

    def doHook(self, handler, subdir):
        """Method called when hooking this callback."""
        pass
    def doUnhook(self, handler):
        """Method called when unhooking this callback."""
        pass

class Supy404(SupyHTTPServerCallback):
    """A 404 Not Found error."""
    name = "Error 404"
    fullpath = True
    response = _("""
    I am a pretty clever IRC bot, but I suck at serving Web pages, particulary
    if I don't know what to serve.
    What I'm saying is you just triggered a 404 Not Found, and I am not
    trained to help you in such a case.""")
    def doGet(self, handler, path, *args, **kwargs):
        handler.send_response(404)
        self.send_header('Content-Type', 'text/plain; charset=utf-8; charset=utf-8')
        self.send_header('Content-Length', len(self.response))
        self.end_headers()
        response = self.response
        if sys.version_info[0] >= 3:
            response = response.encode()
        self.wfile.write(response)

    doPost = doHead = doGet

class SupyIndex(SupyHTTPServerCallback):
    """Displays the index of available plugins."""
    name = "index"
    fullpath = True
    defaultResponse = _("Request not handled.")
    def doGet(self, handler, path):
        plugins = [x for x in handler.server.callbacks.items()]
        if plugins == []:
            plugins = _('No plugins available.')
        else:
            plugins = '<ul class="plugins"><li>%s</li></ul>' % '</li><li>'.join(
                    ['<a href="/%s/">%s</a>' % (x,y.name) for x,y in plugins])
        response = get_template('index.html') % {'list': plugins}
        handler.send_response(200)
        self.send_header('Content-Type', 'text/html; charset=utf-8')
        self.send_header('Content-Length', len(response))
        self.end_headers()
        if sys.version_info[0] >= 3:
            response = response.encode()
        self.wfile.write(response)

class Static(SupyHTTPServerCallback):
    """Serves static files."""
    fullpath = True
    name = 'static'
    defaultResponse = _('Request not handled')
    def __init__(self, mimetype='text/plain; charset=utf-8'):
        super(Static, self).__init__()
        self._mimetype = mimetype
    def doGet(self, handler, path):
        response = get_template(path)
        handler.send_response(200)
        self.send_header('Content-type', self._mimetype)
        self.send_header('Content-Length', len(response))
        self.end_headers()
        if sys.version_info[0] >= 3:
            response = response.encode()
        self.wfile.write(response)

class Favicon(SupyHTTPServerCallback):
    """Services the favicon.ico file to browsers."""
    name = 'favicon'
    defaultResponse = _('Request not handled')
    def doGet(self, handler, path):
        response = None
        file_path = conf.supybot.servers.http.favicon()
        found = False
        if file_path:
            try:
                icon = open(file_path, 'rb')
                response = icon.read()
            except IOError:
                pass
            finally:
                icon.close()
        if response is not None:
            filename = file_path.rsplit(os.sep, 1)[1]
            if '.' in filename:
                ext = filename.rsplit('.', 1)[1]
            else:
                ext = 'ico'
            # I have no idea why, but this headers are already sent.
            # self.send_header('Content-Length', len(response))
            # self.send_header('Content-type', 'image/' + ext)
            # self.end_headers()
            self.wfile.write(response)
        else:
            response = _('No favicon set.')
            handler.send_response(404)
            self.send_header('Content-type', 'text/plain; charset=utf-8')
            self.send_header('Content-Length', len(response))
            self.end_headers()
            if sys.version_info[0] >= 3:
                response = response.encode()
            self.wfile.write(response)

http_servers = []

def startServer():
    """Starts the HTTP server. Shouldn't be called from other modules.
    The callback should be an instance of a child of SupyHTTPServerCallback."""
    global http_servers
    addresses4 = [(4, (x, configGroup.port()))
            for x in configGroup.hosts4().split(' ') if x != '']
    addresses6 = [(6, (x, configGroup.port()))
            for x in configGroup.hosts6().split(' ') if x != '']
    http_servers = []
    for protocol, address in (addresses4 + addresses6):
        server = SupyHTTPServer(address, protocol, SupyHTTPRequestHandler)
        Thread(target=server.serve_forever, name='HTTP Server').start()
        http_servers.append(server)
        log.info('Starting HTTP server: %s' % str(server))

def stopServer():
    """Stops the HTTP server. Should be run only from this module or from
    when the bot is dying (ie. from supybot.world)"""
    global http_servers
    for server in http_servers:
        log.info('Stopping HTTP server: %s' % str(server))
        server.shutdown()
        server = None

if configGroup.keepAlive():
    startServer()

def hook(subdir, callback):
    """Sets a callback for a given subdir."""
    if not http_servers:
        startServer()
    assert isinstance(http_servers, list)
    for server in http_servers:
        server.hook(subdir, callback)

def unhook(subdir):
    """Unsets the callback assigned to the given subdir, and return it."""
    global http_servers
    assert isinstance(http_servers, list)
    for server in http_servers:
        callback = server.unhook(subdir)
        if len(server.callbacks) <= 0 and not configGroup.keepAlive():
            server.shutdown()
            http_servers.remove(server)

########NEW FILE########
__FILENAME__ = i18n
###
# Copyright (c) 2010, Valentin Lorentz
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

"""
Supybot internationalisation and localisation managment.
"""

__all__ = ['PluginInternationalization', 'internationalizeDocstring']

import os
import re
import sys
import time
import weakref
import threading
conf = None
# Don't import conf here ; because conf needs this module

WAITING_FOR_MSGID = 1
IN_MSGID = 2
WAITING_FOR_MSGSTR = 3
IN_MSGSTR = 4

MSGID = 'msgid "'
MSGSTR = 'msgstr "'

currentLocale = 'en'

class PluginNotFound(Exception):
    pass

def getLocaleFromRegistryFilename(filename):
    """Called by the 'supybot' script. Gets the locale name before conf is
    loaded."""
    global currentLocale
    with open(filename, 'r') as fd:
        for line in fd:
            if line.startswith('supybot.language: '):
                currentLocale = line[len('supybot.language: '):]

def import_conf():
    """Imports the conf into this module"""
    global conf
    conf = __import__('supybot.conf').conf
    conf.registerGlobalValue(conf.supybot, 'language',
        conf.registry.String(currentLocale, """Determines the bot's default
        language. Valid values are things like en, fr, de, etc."""))
    conf.supybot.language.addCallback(reloadLocalesIfRequired)

def getPluginDir(plugin_name):
    """Gets the directory of the given plugin"""
    filename = None
    try:
        filename = sys.modules[plugin_name].__file__
    except KeyError: # It sometimes happens with Owner
        pass
    if filename == None:
        try:
            filename = sys.modules['supybot.plugins.' + plugin_name].__file__
        except: # In the case where the plugin is not loaded by Supybot
            try:
                filename = sys.modules['plugin'].__file__
            except:
                filename = sys.modules['__main__'].__file__
    if filename.endswith(".pyc"):
        filename = filename[0:-1]

    allowed_files = ['__init__.py', 'config.py', 'plugin.py', 'test.py']
    for allowed_file in allowed_files:
        if filename.endswith(allowed_file):
            return filename[0:-len(allowed_file)]
    raise PluginNotFound()

def getLocalePath(name, localeName, extension):
    """Gets the path of the locale file of the given plugin ('supybot' stands
    for the core)."""
    if name != 'supybot':
        base = getPluginDir(name)
    else:
        from . import ansi # Any Supybot plugin could fit
        base = ansi.__file__[0:-len('ansi.pyc')]
    directory = os.path.join(base, 'locales')
    return '%s/%s.%s' % (directory, localeName, extension)

i18nClasses = weakref.WeakValueDictionary()
internationalizedCommands = weakref.WeakValueDictionary()
internationalizedFunctions = [] # No need to know their name

def reloadLocalesIfRequired():
    global currentLocale
    if conf is None:
        return
    if currentLocale != conf.supybot.language():
        currentLocale = conf.supybot.language()
        reloadLocales()

def reloadLocales():
    for pluginClass in i18nClasses.values():
        pluginClass.loadLocale()
    for command in internationalizedCommands.values():
        internationalizeDocstring(command)
    for function in internationalizedFunctions:
        function.loadLocale()

def parse(translationFile):
    step = WAITING_FOR_MSGID
    translations = set()
    for line in translationFile:
        line = line[0:-1] # Remove the ending \n
        line = line

        if line.startswith(MSGID):
            # Don't check if step is WAITING_FOR_MSGID
            untranslated = ''
            translated = ''
            data = line[len(MSGID):-1]
            if len(data) == 0: # Multiline mode
                step = IN_MSGID
            else:
                untranslated += data
                step = WAITING_FOR_MSGSTR


        elif step is IN_MSGID and line.startswith('"') and \
                                  line.endswith('"'):
            untranslated += line[1:-1]
        elif step is IN_MSGID and untranslated == '': # Empty MSGID
            step = WAITING_FOR_MSGID
        elif step is IN_MSGID: # the MSGID is finished
            step = WAITING_FOR_MSGSTR


        if step is WAITING_FOR_MSGSTR and line.startswith(MSGSTR):
            data = line[len(MSGSTR):-1]
            if len(data) == 0: # Multiline mode
                step = IN_MSGSTR
            else:
                translations |= set([(untranslated, data)])
                step = WAITING_FOR_MSGID


        elif step is IN_MSGSTR and line.startswith('"') and \
                                   line.endswith('"'):
            translated += line[1:-1]
        elif step is IN_MSGSTR: # the MSGSTR is finished
            step = WAITING_FOR_MSGID
            if translated == '':
                translated = untranslated
            translations |= set([(untranslated, data)])
    if step is IN_MSGSTR:
        if translated == '':
            translated = untranslated
        translations |= set([(untranslated, data)])
    return translations


i18nSupybot = None
def PluginInternationalization(name='supybot'):
    # This is a proxy that prevents having several objects for the same plugin
    if name in i18nClasses:
        return i18nClasses[name]
    else:
        return _PluginInternationalization(name)

class _PluginInternationalization:
    """Internationalization managment for a plugin."""
    def __init__(self, name='supybot'):
        self.name = name
        self.translations = {}
        self.currentLocaleName = None
        i18nClasses.update({name: self})
        self.loadLocale()

    def loadLocale(self, localeName=None):
        """(Re)loads the locale used by this class."""
        self.translations = {}
        if localeName is None:
            localeName = currentLocale
        self.currentLocaleName = localeName

        self._loadL10nCode()

        try:
            try:
                translationFile = open(getLocalePath(self.name,
                                                     localeName, 'po'), 'ru')
            except ValueError: # We are using Windows
                translationFile = open(getLocalePath(self.name,
                                                     localeName, 'po'), 'r')
            self._parse(translationFile)
        except (IOError, PluginNotFound): # The translation is unavailable
            pass
        finally:
            if 'translationFile' in locals():
                translationFile.close()

    def _parse(self, translationFile):
        """A .po files parser.

        Give it a file object."""
        self.translations = {}
        for translation in parse(translationFile):
            self._addToDatabase(*translation)

    def _addToDatabase(self, untranslated, translated):
        untranslated = self._unescape(untranslated, True)
        translated = self._unescape(translated)
        if translated:
            self.translations.update({untranslated: translated})

    def _unescape(self, string, removeNewline=False):
        import supybot.utils as utils
        string = string.replace('\\n\\n', '\n\n')
        string = string.replace('\\n', ' ')
        string = string.replace('\\"', '"')
        string = string.replace("\'", "'")
        string = utils.str.normalizeWhitespace(string, removeNewline)
        return string

    def __call__(self, untranslated):
        """Main function.

        This is the function which is called when a plugin runs _()"""
        if untranslated.__class__ is InternationalizedString:
            return untranslated._original
        escapedUntranslated = self._unescape(untranslated, True)
        untranslated = self._unescape(untranslated, False)
        try:
            string = self._translate(escapedUntranslated)
            return self._addTracker(string, untranslated)
        except KeyError:
            pass
        return untranslated

    def _translate(self, string):
        """Translate the string.

        C the string internationalizer if any; else, use the local database"""
        if string.__class__ == InternationalizedString:
            return string._internationalizer(string.untranslated)
        else:
            return self.translations[string]

    def _addTracker(self, string, untranslated):
        """Add a kind of 'tracker' on the string, in order to keep the
        untranslated string (used when changing the locale)"""
        if string.__class__ == InternationalizedString:
            return string
        else:
            string = InternationalizedString(string)
            string._original = untranslated
            string._internationalizer = self
            return string

    def _loadL10nCode(self):
        """Open the file containing the code specific to this locale, and
        load its functions."""
        if self.name != 'supybot':
            return
        path = self._getL10nCodePath()
        try:
            with open(path) as fd:
                exec(compile(fd.read(), path, 'exec'))
        except IOError: # File doesn't exist
            pass

        functions = locals()
        functions.pop('self')
        self._l10nFunctions = functions
            # Remove old functions and come back to the native language

    def _getL10nCodePath(self):
        """Returns the path to the code localization file.

        It contains functions that needs to by fully (code + strings)
        localized"""
        if self.name != 'supybot':
            return
        return getLocalePath('supybot', self.currentLocaleName, 'py')

    def localizeFunction(self, name):
        """Returns the localized version of the function.

        Should be used only by the InternationalizedFunction class"""
        if self.name != 'supybot':
            return
        if hasattr(self, '_l10nFunctions') and \
                name in self._l10nFunctions:
            return self._l10nFunctions[name]

    def internationalizeFunction(self, name):
        """Decorates functions and internationalize their code.

        Only useful for Supybot core functions"""
        if self.name != 'supybot':
            return
        class FunctionInternationalizer:
            def __init__(self, parent, name):
                self._parent = parent
                self._name = name
            def __call__(self, obj):
                obj = InternationalizedFunction(self._parent, self._name, obj)
                obj.loadLocale()
                return obj
        return FunctionInternationalizer(self, name)

class InternationalizedFunction:
    """Proxy for functions that need to be fully localized.

    The localization code is in locales/LOCALE.py"""
    def __init__(self, internationalizer, name, function):
        self._internationalizer = internationalizer
        self._name = name
        self._origin = function
        internationalizedFunctions.append(self)
    def loadLocale(self):
        self.__call__ = self._internationalizer.localizeFunction(self._name)
        if self.__call__ == None:
            self.restore()
    def restore(self):
        self.__call__ = self._origin

    def __call__(self, *args, **kwargs):
        return self._origin(*args, **kwargs)

class InternationalizedString(str):
    """Simple subclass to str, that allow to add attributes. Also used to
    know if a string is already localized"""
    pass

def internationalizeDocstring(obj):
    """Decorates functions and internationalize their docstring.

    Only useful for commands (commands' docstring is displayed on IRC)"""
    if obj.__doc__ == None:
        return obj
    if '_' in sys.modules[obj.__module__].__dict__:
        internationalizedCommands.update({hash(obj): obj})
        try:
            obj.__doc__=sys.modules[obj.__module__]._.__call__(obj.__doc__)
            # We use _.__call__() instead of _() because of a pygettext warning.
        except AttributeError:
            # attribute '__doc__' of 'type' objects is not writable
            pass
    return obj

########NEW FILE########
__FILENAME__ = ircdb
###
# Copyright (c) 2002-2009, Jeremiah Fincher
# Copyright (c) 2011, Valentin Lorentz
# Copyright (c) 2009,2013, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import os
import time
import operator

from . import conf, ircutils, log, registry, unpreserve, utils, world
from .utils.iter import imap, ilen, ifilter

def isCapability(capability):
    return len(capability.split(None, 1)) == 1

def fromChannelCapability(capability):
    """Returns a (channel, capability) tuple from a channel capability."""
    assert isChannelCapability(capability), 'got %s' % capability
    return capability.split(',', 1)

def isChannelCapability(capability):
    """Returns True if capability is a channel capability; False otherwise."""
    if ',' in capability:
        (channel, capability) = capability.split(',', 1)
        return ircutils.isChannel(channel) and isCapability(capability)
    else:
        return False

def makeChannelCapability(channel, capability):
    """Makes a channel capability given a channel and a capability."""
    assert isCapability(capability), 'got %s' % capability
    assert ircutils.isChannel(channel), 'got %s' % channel
    return '%s,%s' % (channel, capability)

def isAntiCapability(capability):
    """Returns True if capability is an anticapability; False otherwise."""
    if isChannelCapability(capability):
        (_, capability) = fromChannelCapability(capability)
    return isCapability(capability) and capability[0] == '-'

def makeAntiCapability(capability):
    """Returns the anticapability of a given capability."""
    assert isCapability(capability), 'got %s' % capability
    assert not isAntiCapability(capability), \
           'makeAntiCapability does not work on anticapabilities.  ' \
           'You probably want invertCapability; got %s.' % capability
    if isChannelCapability(capability):
        (channel, capability) = fromChannelCapability(capability)
        return makeChannelCapability(channel, '-' + capability)
    else:
        return '-' + capability

def unAntiCapability(capability):
    """Takes an anticapability and returns the non-anti form."""
    assert isCapability(capability), 'got %s' % capability
    if not isAntiCapability(capability):
        raise ValueError('%s is not an anti capability' % capability)
    if isChannelCapability(capability):
        (channel, capability) = fromChannelCapability(capability)
        return ','.join((channel, capability[1:]))
    else:
        return capability[1:]

def invertCapability(capability):
    """Make a capability into an anticapability and vice versa."""
    assert isCapability(capability), 'got %s' % capability
    if isAntiCapability(capability):
        return unAntiCapability(capability)
    else:
        return makeAntiCapability(capability)

def canonicalCapability(capability):
    if callable(capability):
        capability = capability()
    assert isCapability(capability), 'got %s' % capability
    return capability.lower()

_unwildcard_remover = utils.str.MultipleRemover('!@*?')
def unWildcardHostmask(hostmask):
    return _unwildcard_remover(hostmask)

_invert = invertCapability
class CapabilitySet(set):
    """A subclass of set handling basic capability stuff."""
    def __init__(self, capabilities=()):
        self.__parent = super(CapabilitySet, self)
        self.__parent.__init__()
        for capability in capabilities:
            self.add(capability)

    def add(self, capability):
        """Adds a capability to the set."""
        capability = ircutils.toLower(capability)
        inverted = _invert(capability)
        if self.__parent.__contains__(inverted):
            self.__parent.remove(inverted)
        self.__parent.add(capability)

    def remove(self, capability):
        """Removes a capability from the set."""
        capability = ircutils.toLower(capability)
        self.__parent.remove(capability)

    def __contains__(self, capability):
        capability = ircutils.toLower(capability)
        if self.__parent.__contains__(capability):
            return True
        if self.__parent.__contains__(_invert(capability)):
            return True
        else:
            return False

    def check(self, capability, ignoreOwner=False):
        """Returns the appropriate boolean for whether a given capability is
        'allowed' given its (or its anticapability's) presence in the set.
        """
        capability = ircutils.toLower(capability)
        if self.__parent.__contains__(capability):
            return True
        elif self.__parent.__contains__(_invert(capability)):
            return False
        else:
            raise KeyError

    def __repr__(self):
        return '%s([%s])' % (self.__class__.__name__,
                             ', '.join(map(repr, self)))

antiOwner = makeAntiCapability('owner')
class UserCapabilitySet(CapabilitySet):
    """A subclass of CapabilitySet to handle the owner capability correctly."""
    def __init__(self, *args, **kwargs):
        self.__parent = super(UserCapabilitySet, self)
        self.__parent.__init__(*args, **kwargs)

    def __contains__(self, capability, ignoreOwner=False):
        capability = ircutils.toLower(capability)
        if not ignoreOwner and capability == 'owner' or capability == antiOwner:
            return True
        elif not ignoreOwner and self.__parent.__contains__('owner'):
            return True
        else:
            return self.__parent.__contains__(capability)

    def check(self, capability, ignoreOwner=False):
        """Returns the appropriate boolean for whether a given capability is
        'allowed' given its (or its anticapability's) presence in the set.
        Differs from CapabilitySet in that it handles the 'owner' capability
        appropriately.
        """
        capability = ircutils.toLower(capability)
        if capability == 'owner' or capability == antiOwner:
            if self.__parent.__contains__('owner'):
                return not isAntiCapability(capability)
            else:
                return isAntiCapability(capability)
        elif not ignoreOwner and self.__parent.__contains__('owner'):
            if isAntiCapability(capability):
                return False
            else:
                return True
        else:
            return self.__parent.check(capability)

    def add(self, capability):
        """Adds a capability to the set.  Just make sure it's not -owner."""
        capability = ircutils.toLower(capability)
        assert capability != '-owner', '"-owner" disallowed.'
        self.__parent.add(capability)

class IrcUser(object):
    """This class holds the capabilities and authentications for a user."""
    def __init__(self, ignore=False, password='', name='',
                 capabilities=(), hostmasks=None, nicks=None,
                 secure=False, hashed=False):
        self.id = None
        self.auth = [] # The (time, hostmask) list of auth crap.
        self.name = name # The name of the user.
        self.ignore = ignore # A boolean deciding if the person is ignored.
        self.secure = secure # A boolean describing if hostmasks *must* match.
        self.hashed = hashed # True if the password is hashed on disk.
        self.password = password # password (plaintext? hashed?)
        self.capabilities = UserCapabilitySet()
        for capability in capabilities:
            self.capabilities.add(capability)
        if hostmasks is None:
            self.hostmasks = ircutils.IrcSet() # hostmasks used for recognition
        else:
            self.hostmasks = hostmasks
        if nicks is None:
            self.nicks = {} # {'network1': ['foo', 'bar'], 'network': ['baz']}
        else:
            self.nicks = nicks
        self.gpgkeys = [] # GPG key ids

    def __repr__(self):
        return format('%s(id=%s, ignore=%s, password="", name=%q, hashed=%r, '
                      'capabilities=%r, hostmasks=[], secure=%r)\n',
                      self.__class__.__name__, self.id, self.ignore,
                      self.name, self.hashed, self.capabilities, self.secure)

    def __hash__(self):
        return hash(self.id)

    def addCapability(self, capability):
        """Gives the user the given capability."""
        self.capabilities.add(capability)

    def removeCapability(self, capability):
        """Takes from the user the given capability."""
        self.capabilities.remove(capability)

    def _checkCapability(self, capability, ignoreOwner=False):
        """Checks the user for a given capability."""
        if self.ignore:
            if isAntiCapability(capability):
                return True
            else:
                return False
        else:
            return self.capabilities.check(capability, ignoreOwner=ignoreOwner)

    def setPassword(self, password, hashed=False):
        """Sets the user's password."""
        if hashed or self.hashed:
            self.hashed = True
            self.password = utils.saltHash(password)
        else:
            self.password = password

    def checkPassword(self, password):
        """Checks the user's password."""
        if password is None:
            return False
        if self.hashed:
            (salt, _) = self.password.split('|')
            return (self.password == utils.saltHash(password, salt=salt))
        else:
            return (self.password == password)

    def checkHostmask(self, hostmask, useAuth=True):
        """Checks a given hostmask against the user's hostmasks or current
        authentication.  If useAuth is False, only checks against the user's
        hostmasks.
        """
        if useAuth:
            timeout = conf.supybot.databases.users.timeoutIdentification()
            removals = []
            try:
                for (when, authmask) in self.auth:
                    if timeout and when+timeout < time.time():
                        removals.append((when, authmask))
                    elif hostmask == authmask:
                        return True
            finally:
                while removals:
                    self.auth.remove(removals.pop())
        for pat in self.hostmasks:
            if ircutils.hostmaskPatternEqual(pat, hostmask):
                return pat
        return False

    def addHostmask(self, hostmask):
        """Adds a hostmask to the user's hostmasks."""
        assert ircutils.isUserHostmask(hostmask), 'got %s' % hostmask
        if len(unWildcardHostmask(hostmask)) < 3:
            raise ValueError('Hostmask must contain at least 3 non-wildcard characters.')
        self.hostmasks.add(hostmask)

    def removeHostmask(self, hostmask):
        """Removes a hostmask from the user's hostmasks."""
        self.hostmasks.remove(hostmask)

    def checkNick(self, network, nick):
        """Checks a given nick against the user's nicks."""
        return nick in self.nicks[network]

    def addNick(self, network, nick):
        """Adds a nick to the user's registered nicks on the network."""
        global users
        assert isinstance(network, basestring)
        assert ircutils.isNick(nick), 'got %s' % nick
        if users.getUserFromNick(network, nick) is not None:
            raise KeyError
        if network not in self.nicks:
            self.nicks[network] = []
        if nick not in self.nicks[network]:
            self.nicks[network].append(nick)

    def removeNick(self, network, nick):
        """Removes a nick from the user's registered nicks on the network."""
        assert isinstance(network, basestring)
        if nick not in self.nicks[network]:
            raise KeyError
        self.nicks[network].remove(nick)

    def addAuth(self, hostmask):
        """Sets a user's authenticated hostmask.  This times out according to
        conf.supybot.timeoutIdentification.  If hostmask exactly matches an
        existing, known hostmask, the previous entry is removed."""
        if self.checkHostmask(hostmask, useAuth=False) or not self.secure:
            self.auth.append((time.time(), hostmask))
            knownHostmasks = set()
            def uniqueHostmask(auth):
                (_, mask) = auth
                if mask not in knownHostmasks:
                    knownHostmasks.add(mask)
                    return True
                return False
            uniqued = list(filter(uniqueHostmask, reversed(self.auth)))
            self.auth = list(reversed(uniqued))
        else:
            raise ValueError('secure flag set, unmatched hostmask')

    def clearAuth(self):
        """Unsets a user's authenticated hostmask."""
        for (when, hostmask) in self.auth:
            users.invalidateCache(hostmask=hostmask)
        self.auth = []

    def preserve(self, fd, indent=''):
        def write(s):
            fd.write(indent)
            fd.write(s)
            fd.write(os.linesep)
        write('name %s' % self.name)
        write('ignore %s' % self.ignore)
        write('secure %s' % self.secure)
        write('hashed %s' % self.hashed)
        write('password %s' % self.password)
        for capability in self.capabilities:
            write('capability %s' % capability)
        for hostmask in self.hostmasks:
            write('hostmask %s' % hostmask)
        for network, nicks in self.nicks.items():
            write('nicks %s %s' % (network, ' '.join(nicks)))
        for key in self.gpgkeys:
            write('gpgkey %s' % key)
        fd.write(os.linesep)


class IrcChannel(object):
    """This class holds the capabilities, bans, and ignores of a channel."""
    defaultOff = ('op', 'halfop', 'voice', 'protected')
    def __init__(self, bans=None, silences=None, exceptions=None, ignores=None,
                 capabilities=None, lobotomized=False, defaultAllow=True):
        self.defaultAllow = defaultAllow
        self.expiredBans = []
        self.bans = bans or {}
        self.ignores = ignores or {}
        self.silences = silences or []
        self.exceptions = exceptions or []
        self.capabilities = capabilities or CapabilitySet()
        for capability in self.defaultOff:
            if capability not in self.capabilities:
                self.capabilities.add(makeAntiCapability(capability))
        self.lobotomized = lobotomized

    def __repr__(self):
        return '%s(bans=%r, ignores=%r, capabilities=%r, ' \
               'lobotomized=%r, defaultAllow=%s, ' \
               'silences=%r, exceptions=%r)\n' % \
               (self.__class__.__name__, self.bans, self.ignores,
                self.capabilities, self.lobotomized,
                self.defaultAllow, self.silences, self.exceptions)

    def addBan(self, hostmask, expiration=0):
        """Adds a ban to the channel banlist."""
        assert not conf.supybot.protocols.irc.strictRfc() or \
                ircutils.isUserHostmask(hostmask), 'got %s' % hostmask
        self.bans[hostmask] = int(expiration)

    def removeBan(self, hostmask):
        """Removes a ban from the channel banlist."""
        assert not conf.supybot.protocols.irc.strictRfc() or \
                ircutils.isUserHostmask(hostmask), 'got %s' % hostmask
        return self.bans.pop(hostmask)

    def checkBan(self, hostmask):
        """Checks whether a given hostmask is banned by the channel banlist."""
        assert ircutils.isUserHostmask(hostmask), 'got %s' % hostmask
        now = time.time()
        for (pattern, expiration) in self.bans.items():
            if now < expiration or not expiration:
                if ircutils.hostmaskPatternEqual(pattern, hostmask):
                    return True
            else:
                self.expiredBans.append((pattern, expiration))
                del self.bans[pattern]
        return False

    def addIgnore(self, hostmask, expiration=0):
        """Adds an ignore to the channel ignore list."""
        assert ircutils.isUserHostmask(hostmask), 'got %s' % hostmask
        self.ignores[hostmask] = int(expiration)

    def removeIgnore(self, hostmask):
        """Removes an ignore from the channel ignore list."""
        assert ircutils.isUserHostmask(hostmask), 'got %s' % hostmask
        return self.ignores.pop(hostmask)

    def addCapability(self, capability):
        """Adds a capability to the channel's default capabilities."""
        assert isCapability(capability), 'got %s' % capability
        self.capabilities.add(capability)

    def removeCapability(self, capability):
        """Removes a capability from the channel's default capabilities."""
        assert isCapability(capability), 'got %s' % capability
        self.capabilities.remove(capability)

    def setDefaultCapability(self, b):
        """Sets the default capability in the channel."""
        self.defaultAllow = b

    def _checkCapability(self, capability, ignoreOwner=False):
        """Checks whether a certain capability is allowed by the channel."""
        assert isCapability(capability), 'got %s' % capability
        if capability in self.capabilities:
            return self.capabilities.check(capability, ignoreOwner=ignoreOwner)
        else:
            if isAntiCapability(capability):
                return not self.defaultAllow
            else:
                return self.defaultAllow

    def checkIgnored(self, hostmask):
        """Checks whether a given hostmask is to be ignored by the channel."""
        if self.lobotomized:
            return True
        if world.testing:
            return False
        assert ircutils.isUserHostmask(hostmask), 'got %s' % hostmask
        if self.checkBan(hostmask):
            return True
        now = time.time()
        for (pattern, expiration) in self.ignores.items():
            if now < expiration or not expiration:
                if ircutils.hostmaskPatternEqual(pattern, hostmask):
                    return True
            else:
                del self.ignores[pattern]
                # Later we may wish to keep expiredIgnores, but not now.
        return False

    def preserve(self, fd, indent=''):
        def write(s):
            fd.write(indent)
            fd.write(s)
            fd.write(os.linesep)
        write('lobotomized %s' % self.lobotomized)
        write('defaultAllow %s' % self.defaultAllow)
        for capability in self.capabilities:
            write('capability ' + capability)
        bans = self.bans.items()
        utils.sortBy(operator.itemgetter(1), bans)
        for (ban, expiration) in bans:
            write('ban %s %d' % (ban, expiration))
        ignores = self.ignores.items()
        utils.sortBy(operator.itemgetter(1), ignores)
        for (ignore, expiration) in ignores:
            write('ignore %s %d' % (ignore, expiration))
        fd.write(os.linesep)


class Creator(object):
    def badCommand(self, command, rest, lineno):
        raise ValueError('Invalid command on line %s: %s' % (lineno, command))

class IrcUserCreator(Creator):
    u = None
    def __init__(self, users):
        if self.u is None:
            IrcUserCreator.u = IrcUser()
        self.users = users

    def user(self, rest, lineno):
        if self.u.id is not None:
            raise ValueError('Unexpected user command on line %s.' % lineno)
        self.u.id = int(rest)

    def _checkId(self):
        if self.u.id is None:
            raise ValueError('Unexpected user description without user.')

    def name(self, rest, lineno):
        self._checkId()
        self.u.name = rest

    def ignore(self, rest, lineno):
        self._checkId()
        self.u.ignore = bool(eval(rest))

    def secure(self, rest, lineno):
        self._checkId()
        self.u.secure = bool(eval(rest))

    def hashed(self, rest, lineno):
        self._checkId()
        self.u.hashed = bool(eval(rest))

    def password(self, rest, lineno):
        self._checkId()
        self.u.password = rest

    def hostmask(self, rest, lineno):
        self._checkId()
        self.u.hostmasks.add(rest)

    def nicks(self, rest, lineno):
        self._checkId()
        network, nicks = rest.split(' ', 1)
        self.u.nicks[network] = nicks.split(' ')

    def capability(self, rest, lineno):
        self._checkId()
        self.u.capabilities.add(rest)

    def gpgkey(self, rest, lineno):
        self._checkId()
        self.u.gpgkeys.append(rest)

    def finish(self):
        if self.u.name:
            try:
                self.users.setUser(self.u)
            except DuplicateHostmask:
                log.error('Hostmasks for %s collided with another user\'s.  '
                          'Resetting hostmasks for %s.',
                          self.u.name, self.u.name)
                # Some might argue that this is arbitrary, and perhaps it is.
                # But we've got to do *something*, so we'll show some deference
                # to our lower-numbered users.
                self.u.hostmasks.clear()
                self.users.setUser(self.u)
            IrcUserCreator.u = None

class IrcChannelCreator(Creator):
    name = None
    def __init__(self, channels):
        self.c = IrcChannel()
        self.channels = channels
        self.hadChannel = bool(self.name)

    def channel(self, rest, lineno):
        if self.name is not None:
            raise ValueError('Unexpected channel command on line %s' % lineno)
        IrcChannelCreator.name = rest

    def _checkId(self):
        if self.name is None:
            raise ValueError('Unexpected channel description without channel.')

    def lobotomized(self, rest, lineno):
        self._checkId()
        self.c.lobotomized = bool(eval(rest))

    def defaultallow(self, rest, lineno):
        self._checkId()
        self.c.defaultAllow = bool(eval(rest))

    def capability(self, rest, lineno):
        self._checkId()
        self.c.capabilities.add(rest)

    def ban(self, rest, lineno):
        self._checkId()
        (pattern, expiration) = rest.split()
        self.c.bans[pattern] = int(float(expiration))

    def ignore(self, rest, lineno):
        self._checkId()
        (pattern, expiration) = rest.split()
        self.c.ignores[pattern] = int(float(expiration))

    def finish(self):
        if self.hadChannel:
            self.channels.setChannel(self.name, self.c)
            IrcChannelCreator.name = None


class DuplicateHostmask(ValueError):
    pass

class UsersDictionary(utils.IterableMap):
    """A simple serialized-to-file User Database."""
    def __init__(self):
        self.noFlush = False
        self.filename = None
        self.users = {}
        self.nextId = 0
        self._nameCache = utils.structures.CacheDict(1000)
        self._hostmaskCache = utils.structures.CacheDict(1000)

    # This is separate because the Creator has to access our instance.
    def open(self, filename):
        self.filename = filename
        reader = unpreserve.Reader(IrcUserCreator, self)
        try:
            self.noFlush = True
            try:
                reader.readFile(filename)
                self.noFlush = False
                self.flush()
            except EnvironmentError as e:
                log.error('Invalid user dictionary file, resetting to empty.')
                log.error('Exact error: %s', utils.exnToString(e))
            except Exception as e:
                log.exception('Exact error:')
        finally:
            self.noFlush = False

    def reload(self):
        """Reloads the database from its file."""
        self.nextId = 0
        self.users.clear()
        self._nameCache.clear()
        self._hostmaskCache.clear()
        if self.filename is not None:
            try:
                self.open(self.filename)
            except EnvironmentError as e:
                log.warning('UsersDictionary.reload failed: %s', e)
        else:
            log.error('UsersDictionary.reload called with no filename.')

    def flush(self):
        """Flushes the database to its file."""
        if not self.noFlush:
            if self.filename is not None:
                L = self.users.items()
                L.sort()
                fd = utils.file.AtomicFile(self.filename)
                for (id, u) in L:
                    fd.write('user %s' % id)
                    fd.write(os.linesep)
                    u.preserve(fd, indent='  ')
                fd.close()
            else:
                log.error('UsersDictionary.flush called with no filename.')
        else:
            log.debug('Not flushing UsersDictionary because of noFlush.')

    def close(self):
        self.flush()
        if self.flush in world.flushers:
            world.flushers.remove(self.flush)
        self.users.clear()

    def iteritems(self):
        return self.users.iteritems()

    def getUserId(self, s):
        """Returns the user ID of a given name or hostmask."""
        if ircutils.isUserHostmask(s):
            try:
                return self._hostmaskCache[s]
            except KeyError:
                ids = {}
                for (id, user) in self.users.iteritems():
                    x = user.checkHostmask(s)
                    if x:
                        ids[id] = x
                if len(ids) == 1:
                    id = ids.keys()[0]
                    self._hostmaskCache[s] = id
                    try:
                        self._hostmaskCache[id].add(s)
                    except KeyError:
                        self._hostmaskCache[id] = set([s])
                    return id
                elif len(ids) == 0:
                    raise KeyError(s)
                else:
                    log.error('Multiple matches found in user database.  '
                              'Removing the offending hostmasks.')
                    for (id, hostmask) in ids.iteritems():
                        log.error('Removing %q from user %s.', hostmask, id)
                        self.users[id].removeHostmask(hostmask)
                    raise DuplicateHostmask('Ids %r matched.' % ids)
        else: # Not a hostmask, must be a name.
            s = s.lower()
            try:
                return self._nameCache[s]
            except KeyError:
                for (id, user) in self.users.items():
                    if s == user.name.lower():
                        self._nameCache[s] = id
                        self._nameCache[id] = s
                        return id
                else:
                    raise KeyError(s)

    def getUser(self, id):
        """Returns a user given its id, name, or hostmask."""
        if not isinstance(id, int):
            # Must be a string.  Get the UserId first.
            id = self.getUserId(id)
        u = self.users[id]
        while isinstance(u, int):
            id = u
            u = self.users[id]
        u.id = id
        return u

    def getUserFromNick(self, network, nick):
        """Return a user given its nick."""
        for user in self.users.values():
            try:
                if nick in user.nicks[network]:
                    return user
            except KeyError:
                pass
        return None

    def hasUser(self, id):
        """Returns the database has a user given its id, name, or hostmask."""
        try:
            self.getUser(id)
            return True
        except KeyError:
            return False

    def numUsers(self):
        return len(self.users)

    def invalidateCache(self, id=None, hostmask=None, name=None):
        if hostmask is not None:
            if hostmask in self._hostmaskCache:
                id = self._hostmaskCache.pop(hostmask)
                self._hostmaskCache[id].remove(hostmask)
                if not self._hostmaskCache[id]:
                    del self._hostmaskCache[id]
        if name is not None:
            del self._nameCache[self._nameCache[id]]
            del self._nameCache[id]
        if id is not None:
            if id in self._nameCache:
                del self._nameCache[self._nameCache[id]]
                del self._nameCache[id]
            if id in self._hostmaskCache:
                for hostmask in self._hostmaskCache[id]:
                    del self._hostmaskCache[hostmask]
                del self._hostmaskCache[id]

    def setUser(self, user, flush=True):
        """Sets a user (given its id) to the IrcUser given it."""
        self.nextId = max(self.nextId, user.id)
        try:
            if self.getUserId(user.name) != user.id:
                raise DuplicateHostmask(user.name)
        except KeyError:
            pass
        for hostmask in user.hostmasks:
            for (i, u) in self.iteritems():
                if i == user.id:
                    continue
                elif u.checkHostmask(hostmask):
                    # We used to remove the hostmask here, but it's not
                    # appropriate for us both to remove the hostmask and to
                    # raise an exception.  So instead, we'll raise an
                    # exception, but be nice and give the offending hostmask
                    # back at the same time.
                    raise DuplicateHostmask(hostmask)
                for otherHostmask in u.hostmasks:
                    if ircutils.hostmaskPatternEqual(hostmask, otherHostmask):
                        raise DuplicateHostmask(hostmask)
        self.invalidateCache(user.id)
        self.users[user.id] = user
        if flush:
            self.flush()

    def delUser(self, id):
        """Removes a user from the database."""
        del self.users[id]
        if id in self._nameCache:
            del self._nameCache[self._nameCache[id]]
            del self._nameCache[id]
        if id in self._hostmaskCache:
            for hostmask in self._hostmaskCache[id]:
                del self._hostmaskCache[hostmask]
            del self._hostmaskCache[id]
        self.flush()

    def newUser(self):
        """Allocates a new user in the database and returns it and its id."""
        user = IrcUser(hashed=True)
        self.nextId += 1
        id = self.nextId
        self.users[id] = user
        self.flush()
        user.id = id
        return user


class ChannelsDictionary(utils.IterableMap):
    def __init__(self):
        self.noFlush = False
        self.filename = None
        self.channels = ircutils.IrcDict()

    def open(self, filename):
        self.noFlush = True
        try:
            self.filename = filename
            reader = unpreserve.Reader(IrcChannelCreator, self)
            try:
                reader.readFile(filename)
                self.noFlush = False
                self.flush()
            except EnvironmentError as e:
                log.error('Invalid channel database, resetting to empty.')
                log.error('Exact error: %s', utils.exnToString(e))
            except Exception as e:
                log.error('Invalid channel database, resetting to empty.')
                log.exception('Exact error:')
        finally:
            self.noFlush = False

    def flush(self):
        """Flushes the channel database to its file."""
        if not self.noFlush:
            if self.filename is not None:
                fd = utils.file.AtomicFile(self.filename)
                for (channel, c) in self.channels.iteritems():
                    fd.write('channel %s' % channel)
                    fd.write(os.linesep)
                    c.preserve(fd, indent='  ')
                fd.close()
            else:
                log.warning('ChannelsDictionary.flush without self.filename.')
        else:
            log.debug('Not flushing ChannelsDictionary because of noFlush.')

    def close(self):
        self.flush()
        if self.flush in world.flushers:
            world.flushers.remove(self.flush)
        self.channels.clear()

    def reload(self):
        """Reloads the channel database from its file."""
        if self.filename is not None:
            self.channels.clear()
            try:
                self.open(self.filename)
            except EnvironmentError as e:
                log.warning('ChannelsDictionary.reload failed: %s', e)
        else:
            log.warning('ChannelsDictionary.reload without self.filename.')

    def getChannel(self, channel):
        """Returns an IrcChannel object for the given channel."""
        channel = channel.lower()
        if channel in self.channels:
            return self.channels[channel]
        else:
            c = IrcChannel()
            self.channels[channel] = c
            return c

    def setChannel(self, channel, ircChannel):
        """Sets a given channel to the IrcChannel object given."""
        channel = channel.lower()
        self.channels[channel] = ircChannel
        self.flush()

    def iteritems(self):
        return self.channels.iteritems()


class IgnoresDB(object):
    def __init__(self):
        self.filename = None
        self.hostmasks = {}

    def open(self, filename):
        self.filename = filename
        fd = open(self.filename)
        for line in utils.file.nonCommentNonEmptyLines(fd):
            try:
                line = line.rstrip('\r\n')
                L = line.split()
                hostmask = L.pop(0)
                if L:
                    expiration = int(float(L.pop(0)))
                else:
                    expiration = 0
                self.add(hostmask, expiration)
            except Exception as e:
                log.error('Invalid line in ignores database: %q', line)
        fd.close()

    def flush(self):
        if self.filename is not None:
            fd = utils.file.AtomicFile(self.filename)
            now = time.time()
            for (hostmask, expiration) in self.hostmasks.items():
                if now < expiration or not expiration:
                    fd.write('%s %s' % (hostmask, expiration))
                    fd.write(os.linesep)
            fd.close()
        else:
            log.warning('IgnoresDB.flush called without self.filename.')

    def close(self):
        if self.flush in world.flushers:
            world.flushers.remove(self.flush)
        self.flush()
        self.hostmasks.clear()

    def reload(self):
        if self.filename is not None:
            oldhostmasks = self.hostmasks.copy()
            self.hostmasks.clear()
            try:
                self.open(self.filename)
            except EnvironmentError as e:
                log.warning('IgnoresDB.reload failed: %s', e)
                # Let's be somewhat transactional.
                self.hostmasks.update(oldhostmasks)
        else:
            log.warning('IgnoresDB.reload called without self.filename.')

    def checkIgnored(self, prefix):
        now = time.time()
        for (hostmask, expiration) in self.hostmasks.items():
            if expiration and now > expiration:
                del self.hostmasks[hostmask]
            else:
                if ircutils.hostmaskPatternEqual(hostmask, prefix):
                    return True
        return False

    def add(self, hostmask, expiration=0):
        assert ircutils.isUserHostmask(hostmask), 'got %s' % hostmask
        self.hostmasks[hostmask] = expiration

    def remove(self, hostmask):
        del self.hostmasks[hostmask]


confDir = conf.supybot.directories.conf()
try:
    userFile = os.path.join(confDir, conf.supybot.databases.users.filename())
    users = UsersDictionary()
    users.open(userFile)
except EnvironmentError as e:
    log.warning('Couldn\'t open user database: %s', e)

try:
    channelFile = os.path.join(confDir,
                               conf.supybot.databases.channels.filename())
    channels = ChannelsDictionary()
    channels.open(channelFile)
except EnvironmentError as e:
    log.warning('Couldn\'t open channel database: %s', e)

try:
    ignoreFile = os.path.join(confDir,
                              conf.supybot.databases.ignores.filename())
    ignores = IgnoresDB()
    ignores.open(ignoreFile)
except EnvironmentError as e:
    log.warning('Couldn\'t open ignore database: %s', e)


world.flushers.append(users.flush)
world.flushers.append(ignores.flush)
world.flushers.append(channels.flush)


###
# Useful functions for checking credentials.
###
def checkIgnored(hostmask, recipient='', users=users, channels=channels):
    """checkIgnored(hostmask, recipient='') -> True/False

    Checks if the user is ignored by the recipient of the message.
    """
    try:
        id = users.getUserId(hostmask)
        user = users.getUser(id)
        if user._checkCapability('owner'):
            # Owners shouldn't ever be ignored.
            return False
        elif user.ignore:
            log.debug('Ignoring %s due to their IrcUser ignore flag.', hostmask)
            return True
    except KeyError:
        # If there's no user...
        if conf.supybot.defaultIgnore():
            log.debug('Ignoring %s due to conf.supybot.defaultIgnore',
                     hostmask)
            return True
    if ignores.checkIgnored(hostmask):
        log.debug('Ignoring %s due to ignore database.', hostmask)
        return True
    if ircutils.isChannel(recipient):
        channel = channels.getChannel(recipient)
        if channel.checkIgnored(hostmask):
            log.debug('Ignoring %s due to the channel ignores.', hostmask)
            return True
    return False

def _x(capability, ret):
    if isAntiCapability(capability):
        return not ret
    else:
        return ret

def _checkCapabilityForUnknownUser(capability, users=users, channels=channels,
        ignoreDefaultAllow=False):
    if isChannelCapability(capability):
        (channel, capability) = fromChannelCapability(capability)
        try:
            c = channels.getChannel(channel)
            if capability in c.capabilities:
                return c._checkCapability(capability)
            else:
                return _x(capability, (not ignoreDefaultAllow) and c.defaultAllow)
        except KeyError:
            pass
    defaultCapabilities = conf.supybot.capabilities()
    if capability in defaultCapabilities:
        return defaultCapabilities.check(capability)
    elif ignoreDefaultAllow:
        return _x(capability, False)
    else:
        return _x(capability, conf.supybot.capabilities.default())

def checkCapability(hostmask, capability, users=users, channels=channels,
                    ignoreOwner=False, ignoreChannelOp=False,
                    ignoreDefaultAllow=False):
    """Checks that the user specified by name/hostmask has the capability given.

    ``users`` and ``channels`` default to ``ircdb.users`` and
    ``ircdb.channels``.

    ``ignoreOwner``, ``ignoreChannelOp``, and ``ignoreDefaultAllow`` are
    used to override default behavior of the capability system in special
    cases (actually, in the AutoMode plugin):

    * ``ignoreOwner`` disables the behavior "owners have all capabilites"
    * ``ignoreChannelOp`` disables the behavior "channel ops have all
      channel capabilities"
    * ``ignoreDefaultAllow`` disables the behavior "if a user does not have
      a capability or the associated anticapability, then they have the
      capability"
    """
    if world.testing and (not isinstance(hostmask, str) or
            '@' not in hostmask or
            '__no_testcap__' not in hostmask.split('@')[1]):
        return _x(capability, True)
    try:
        u = users.getUser(hostmask)
        if u.secure and not u.checkHostmask(hostmask, useAuth=False):
            raise KeyError
    except KeyError:
        # Raised when no hostmasks match.
        return _checkCapabilityForUnknownUser(capability, users=users,
                channels=channels, ignoreDefaultAllow=ignoreDefaultAllow)
    except ValueError as e:
        # Raised when multiple hostmasks match.
        log.warning('%s: %s', hostmask, e)
        return _checkCapabilityForUnknownUser(capability, users=users,
              channels=channels, ignoreDefaultAllow=ignoreDefaultAllow)
    if capability in u.capabilities:
        try:
            return u._checkCapability(capability, ignoreOwner)
        except KeyError:
            pass
    if isChannelCapability(capability):
        (channel, capability) = fromChannelCapability(capability)
        if not ignoreChannelOp:
            try:
                chanop = makeChannelCapability(channel, 'op')
                if u._checkCapability(chanop):
                    return _x(capability, True)
            except KeyError:
                pass
        c = channels.getChannel(channel)
        if capability in c.capabilities:
            return c._checkCapability(capability)
        elif not ignoreDefaultAllow:
            return _x(capability, c.defaultAllow)
        else:
            return False
    defaultCapabilities = conf.supybot.capabilities()
    if capability in defaultCapabilities:
        return defaultCapabilities.check(capability)
    elif ignoreDefaultAllow:
        return _x(capability, False)
    else:
        return _x(capability, conf.supybot.capabilities.default())


def checkCapabilities(hostmask, capabilities, requireAll=False):
    """Checks that a user has capabilities in a list.

    requireAll is True if *all* capabilities in the list must be had, False if
    *any* of the capabilities in the list must be had.
    """
    for capability in capabilities:
        if requireAll:
            if not checkCapability(hostmask, capability):
                return False
        else:
            if checkCapability(hostmask, capability):
                return True
    return requireAll

###
# supybot.capabilities
###

class DefaultCapabilities(registry.SpaceSeparatedListOfStrings):
    List = CapabilitySet
    # We use a keyword argument trick here to prevent eval'ing of code that
    # changes allowDefaultOwner from affecting this.  It's not perfect, but
    # it's still an improvement, raising the bar for potential crackers.
    def setValue(self, v, allowDefaultOwner=conf.allowDefaultOwner):
        registry.SpaceSeparatedListOfStrings.setValue(self, v)
        if '-owner' not in self.value and not allowDefaultOwner:
            print('*** You must run supybot with the --allow-default-owner')
            print('*** option in order to allow a default capability of owner.')
            print('*** Don\'t do that, it\'s dumb.')
            self.value.add('-owner')

conf.registerGlobalValue(conf.supybot, 'capabilities',
    DefaultCapabilities(['-owner', '-admin', '-trusted'], """These are the
    capabilities that are given to everyone by default.  If they are normal
    capabilities, then the user will have to have the appropriate
    anti-capability if you want to override these capabilities; if they are
    anti-capabilities, then the user will have to have the actual capability
    to override these capabilities.  See docs/CAPABILITIES if you don't
    understand why these default to what they do."""))

conf.registerGlobalValue(conf.supybot.capabilities, 'default',
    registry.Boolean(True, """Determines whether the bot by default will allow
    users to have a capability.  If this is disabled, a user must explicitly
    have the capability for whatever command they wish to run."""))
conf.registerGlobalValue(conf.supybot.capabilities, 'private',
    registry.SpaceSeparatedListOfStrings([], """Determines what capabilities
    the bot will never tell to a non-admin whether or not a user has them."""))


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = irclib
###
# Copyright (c) 2002-2005 Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import re
import copy
import time
import random
import base64

from . import conf, ircdb, ircmsgs, ircutils, log, utils, world
from .utils.str import rsplit
from .utils.iter import imap, chain, cycle
from .utils.structures import queue, smallqueue, RingBuffer

###
# The base class for a callback to be registered with an Irc object.  Shows
# the required interface for callbacks -- name(),
# inFilter(irc, msg), outFilter(irc, msg), and __call__(irc, msg) [used so as
# to make functions used as callbacks conceivable, and so if refactoring ever
# changes the nature of the callbacks from classes to functions, syntactical
# changes elsewhere won't be required.]
###

class IrcCommandDispatcher(object):
    """Base class for classes that must dispatch on a command."""
    def dispatchCommand(self, command):
        """Given a string 'command', dispatches to doCommand."""
        return getattr(self, 'do' + command.capitalize(), None)


class IrcCallback(IrcCommandDispatcher):
    """Base class for standard callbacks.

    Callbacks derived from this class should have methods of the form
    "doCommand" -- doPrivmsg, doNick, do433, etc.  These will be called
    on matching messages.
    """
    callAfter = ()
    callBefore = ()
    __metaclass__ = log.MetaFirewall
    __firewalled__ = {'die': None,
                      'reset': None,
                      '__call__': None,
                      'inFilter': lambda self, irc, msg: msg,
                      'outFilter': lambda self, irc, msg: msg,
                      'name': lambda self: self.__class__.__name__,
                      'callPrecedence': lambda self, irc: ([], []),
                      }

    def __init__(self, *args, **kwargs):
        #object doesn't take any args, so the buck stops here.
        #super(IrcCallback, self).__init__(*args, **kwargs)
        pass

    def __repr__(self):
        return '<%s %s %s>' % \
               (self.__class__.__name__, self.name(), object.__repr__(self))

    def name(self):
        """Returns the name of the callback."""
        return self.__class__.__name__

    def callPrecedence(self, irc):
        """Returns a pair of (callbacks to call before me,
                              callbacks to call after me)"""
        after = []
        before = []
        for name in self.callBefore:
            cb = irc.getCallback(name)
            if cb is not None:
                after.append(cb)
        for name in self.callAfter:
            cb = irc.getCallback(name)
            if cb is not None:
                before.append(cb)
        assert self not in after, '%s was in its own after.' % self.name()
        assert self not in before, '%s was in its own before.' % self.name()
        return (before, after)

    def inFilter(self, irc, msg):
        """Used for filtering/modifying messages as they're entering.

        ircmsgs.IrcMsg objects are immutable, so this method is expected to
        return another ircmsgs.IrcMsg object.  Obviously the same IrcMsg
        can be returned.
        """
        return msg

    def outFilter(self, irc, msg):
        """Used for filtering/modifying messages as they're leaving.

        As with inFilter, an IrcMsg is returned.
        """
        return msg

    def __call__(self, irc, msg):
        """Used for handling each message."""
        method = self.dispatchCommand(msg.command)
        if method is not None:
            method(irc, msg)

    def reset(self):
        """Resets the callback.  Called when reconnecting to the server."""
        pass

    def die(self):
        """Makes the callback die.  Called when the parent Irc object dies."""
        pass

###
# Basic queue for IRC messages.  It doesn't presently (but should at some
# later point) reorder messages based on priority or penalty calculations.
###
_high = frozenset(['MODE', 'KICK', 'PONG', 'NICK', 'PASS', 'CAPAB'])
_low = frozenset(['PRIVMSG', 'PING', 'WHO', 'NOTICE', 'JOIN'])
class IrcMsgQueue(object):
    """Class for a queue of IrcMsgs.  Eventually, it should be smart.

    Probably smarter than it is now, though it's gotten quite a bit smarter
    than it originally was.  A method to "score" methods, and a heapq to
    maintain a priority queue of the messages would be the ideal way to do
    intelligent queuing.

    As it stands, however, we simply keep track of 'high priority' messages,
    'low priority' messages, and normal messages, and just make sure to return
    the 'high priority' ones before the normal ones before the 'low priority'
    ones.
    """
    __slots__ = ('msgs', 'highpriority', 'normal', 'lowpriority', 'lastJoin')
    def __init__(self, iterable=()):
        self.reset()
        for msg in iterable:
            self.enqueue(msg)

    def reset(self):
        """Clears the queue."""
        self.lastJoin = 0
        self.highpriority = smallqueue()
        self.normal = smallqueue()
        self.lowpriority = smallqueue()

    def enqueue(self, msg):
        """Enqueues a given message."""
        if msg in self and \
           conf.supybot.protocols.irc.queuing.duplicates():
            s = str(msg).strip()
            log.info('Not adding message %q to queue, already added.', s)
            return False
        else:
            if msg.command in _high:
                self.highpriority.enqueue(msg)
            elif msg.command in _low:
                self.lowpriority.enqueue(msg)
            else:
                self.normal.enqueue(msg)
            return True

    def dequeue(self):
        """Dequeues a given message."""
        msg = None
        if self.highpriority:
            msg = self.highpriority.dequeue()
        elif self.normal:
            msg = self.normal.dequeue()
        elif self.lowpriority:
            msg = self.lowpriority.dequeue()
            if msg.command == 'JOIN':
                limit = conf.supybot.protocols.irc.queuing.rateLimit.join()
                now = time.time()
                if self.lastJoin + limit <= now:
                    self.lastJoin = now
                else:
                    self.lowpriority.enqueue(msg)
                    msg = None
        return msg

    def __contains__(self, msg):
        return msg in self.normal or \
               msg in self.lowpriority or \
               msg in self.highpriority

    def __bool__(self):
        return bool(self.highpriority or self.normal or self.lowpriority)
    __nonzero__ = __bool__

    def __len__(self):
        return len(self.highpriority)+len(self.lowpriority)+len(self.normal)

    def __repr__(self):
        name = self.__class__.__name__
        return '%s(%r)' % (name, list(chain(self.highpriority,
                                            self.normal,
                                            self.lowpriority)))
    __str__ = __repr__


###
# Maintains the state of IRC connection -- the most recent messages, the
# status of various modes (especially ops/halfops/voices) in channels, etc.
###
class ChannelState(utils.python.Object):
    __slots__ = ('users', 'ops', 'halfops', 'bans',
                 'voices', 'topic', 'modes', 'created')
    def __init__(self):
        self.topic = ''
        self.created = 0
        self.ops = ircutils.IrcSet()
        self.bans = ircutils.IrcSet()
        self.users = ircutils.IrcSet()
        self.voices = ircutils.IrcSet()
        self.halfops = ircutils.IrcSet()
        self.modes = {}

    def isOp(self, nick):
        return nick in self.ops
    def isOpPlus(self, nick):
        return nick in self.ops
    def isVoice(self, nick):
        return nick in self.voices
    def isVoicePlus(self, nick):
        return nick in self.voices or nick in self.halfops or nick in self.ops
    def isHalfop(self, nick):
        return nick in self.halfops
    def isHalfopPlus(self, nick):
        return nick in self.halfops or nick in self.ops

    def addUser(self, user):
        "Adds a given user to the ChannelState.  Power prefixes are handled."
        nick = user.lstrip('@%+&~!')
        if not nick:
            return
        # & is used to denote protected users in UnrealIRCd
        # ~ is used to denote channel owner in UnrealIRCd
        # ! is used to denote protected users in UltimateIRCd
        while user and user[0] in '@%+&~!':
            (marker, user) = (user[0], user[1:])
            assert user, 'Looks like my caller is passing chars, not nicks.'
            if marker in '@&~!':
                self.ops.add(nick)
            elif marker == '%':
                self.halfops.add(nick)
            elif marker == '+':
                self.voices.add(nick)
        self.users.add(nick)

    def replaceUser(self, oldNick, newNick):
        """Changes the user oldNick to newNick; used for NICK changes."""
        # Note that this doesn't have to have the sigil (@%+) that users
        # have to have for addUser; it just changes the name of the user
        # without changing any of their categories.
        for s in (self.users, self.ops, self.halfops, self.voices):
            if oldNick in s:
                s.remove(oldNick)
                s.add(newNick)

    def removeUser(self, user):
        """Removes a given user from the channel."""
        self.users.discard(user)
        self.ops.discard(user)
        self.halfops.discard(user)
        self.voices.discard(user)

    def setMode(self, mode, value=None):
        assert mode not in 'ovhbeq'
        self.modes[mode] = value

    def unsetMode(self, mode):
        assert mode not in 'ovhbeq'
        if mode in self.modes:
            del self.modes[mode]

    def doMode(self, msg):
        def getSet(c):
            if c == 'o':
                Set = self.ops
            elif c == 'v':
                Set = self.voices
            elif c == 'h':
                Set = self.halfops
            elif c == 'b':
                Set = self.bans
            else: # We don't care yet, so we'll just return an empty set.
                Set = set()
            return Set
        for (mode, value) in ircutils.separateModes(msg.args[1:]):
            (action, modeChar) = mode
            if modeChar in 'ovhbeq': # We don't handle e or q yet.
                Set = getSet(modeChar)
                if action == '-':
                    Set.discard(value)
                elif action == '+':
                    Set.add(value)
            else:
                if action == '+':
                    self.setMode(modeChar, value)
                else:
                    assert action == '-'
                    self.unsetMode(modeChar)

    def __getstate__(self):
        return [getattr(self, name) for name in self.__slots__]

    def __setstate__(self, t):
        for (name, value) in zip(self.__slots__, t):
            setattr(self, name, value)

    def __eq__(self, other):
        ret = True
        for name in self.__slots__:
            ret = ret and getattr(self, name) == getattr(other, name)
        return ret


class IrcState(IrcCommandDispatcher):
    """Maintains state of the Irc connection.  Should also become smarter.
    """
    __metaclass__ = log.MetaFirewall
    __firewalled__ = {'addMsg': None}
    def __init__(self, history=None, supported=None,
                 nicksToHostmasks=None, channels=None):
        if history is None:
            history = RingBuffer(conf.supybot.protocols.irc.maxHistoryLength())
        if supported is None:
            supported = utils.InsensitivePreservingDict()
        if nicksToHostmasks is None:
            nicksToHostmasks = ircutils.IrcDict()
        if channels is None:
            channels = ircutils.IrcDict()
        self.ircd = None
        self.supported = supported
        self.history = history
        self.channels = channels
        self.nicksToHostmasks = nicksToHostmasks

    def reset(self):
        """Resets the state to normal, unconnected state."""
        self.history.reset()
        self.channels.clear()
        self.supported.clear()
        self.nicksToHostmasks.clear()
        self.history.resize(conf.supybot.protocols.irc.maxHistoryLength())

    def __reduce__(self):
        return (self.__class__, (self.history, self.supported,
                                 self.nicksToHostmasks, self.channels))

    def __eq__(self, other):
        return self.history == other.history and \
               self.channels == other.channels and \
               self.supported == other.supported and \
               self.nicksToHostmasks == other.nicksToHostmasks

    def __ne__(self, other):
        return not self == other

    def copy(self):
        ret = self.__class__()
        ret.history = copy.deepcopy(self.history)
        ret.nicksToHostmasks = copy.deepcopy(self.nicksToHostmasks)
        ret.channels = copy.deepcopy(self.channels)
        return ret

    def addMsg(self, irc, msg):
        """Updates the state based on the irc object and the message."""
        self.history.append(msg)
        if ircutils.isUserHostmask(msg.prefix) and not msg.command == 'NICK':
            self.nicksToHostmasks[msg.nick] = msg.prefix
        method = self.dispatchCommand(msg.command)
        if method is not None:
            method(irc, msg)

    def getTopic(self, channel):
        """Returns the topic for a given channel."""
        return self.channels[channel].topic

    def nickToHostmask(self, nick):
        """Returns the hostmask for a given nick."""
        return self.nicksToHostmasks[nick]

    def do004(self, irc, msg):
        """Handles parsing the 004 reply

        Supported user and channel modes are cached"""
        # msg.args = [nick, server, ircd-version, umodes, modes,
        #             modes that require arguments? (non-standard)]
        self.ircd = msg.args[2]
        self.supported['umodes'] = msg.args[3]
        self.supported['chanmodes'] = msg.args[4]

    _005converters = utils.InsensitivePreservingDict({
        'modes': int,
        'keylen': int,
        'nicklen': int,
        'userlen': int,
        'hostlen': int,
        'kicklen': int,
        'awaylen': int,
        'silence': int,
        'topiclen': int,
        'channellen': int,
        'maxtargets': int,
        'maxnicklen': int,
        'maxchannels': int,
        'watch': int, # DynastyNet, EnterTheGame
        })
    def _prefixParser(s):
        if ')' in s:
            (left, right) = s.split(')')
            assert left[0] == '(', 'Odd PREFIX in 005: %s' % s
            left = left[1:]
            assert len(left) == len(right), 'Odd PREFIX in 005: %s' % s
            return dict(list(zip(left, right)))
        else:
            return dict(list(zip('ovh', s)))
    _005converters['prefix'] = _prefixParser
    del _prefixParser
    def _maxlistParser(s):
        modes = ''
        limits = []
        pairs = s.split(',')
        for pair in pairs:
            (mode, limit) = pair.split(':', 1)
            modes += mode
            limits += (int(limit),) * len(mode)
        return dict(list(zip(modes, limits)))
    _005converters['maxlist'] = _maxlistParser
    del _maxlistParser
    def _maxbansParser(s):
        # IRCd using a MAXLIST style string (IRCNet)
        if ':' in s:
            modes = ''
            limits = []
            pairs = s.split(',')
            for pair in pairs:
                (mode, limit) = pair.split(':', 1)
                modes += mode
                limits += (int(limit),) * len(mode)
            d = dict(list(zip(modes, limits)))
            assert 'b' in d
            return d['b']
        else:
            return int(s)
    _005converters['maxbans'] = _maxbansParser
    del _maxbansParser
    def do005(self, irc, msg):
        for arg in msg.args[1:-1]: # 0 is nick, -1 is "are supported"
            if '=' in arg:
                (name, value) = arg.split('=', 1)
                converter = self._005converters.get(name, lambda x: x)
                try:
                    self.supported[name] = converter(value)
                except Exception as e:
                    log.exception('Uncaught exception in 005 converter:')
                    log.error('Name: %s, Converter: %s', name, converter)
            else:
                self.supported[arg] = None

    def do352(self, irc, msg):
        # WHO reply.
        (nick, user, host) = (msg.args[5], msg.args[2], msg.args[3])
        hostmask = '%s!%s@%s' % (nick, user, host)
        self.nicksToHostmasks[nick] = hostmask

    def do353(self, irc, msg):
        # NAMES reply.
        (_, type, channel, names) = msg.args
        if channel not in self.channels:
            self.channels[channel] = ChannelState()
        c = self.channels[channel]
        for name in names.split():
            c.addUser(name)
        if type == '@':
            c.modes['s'] = None

    def doJoin(self, irc, msg):
        for channel in msg.args[0].split(','):
            if channel in self.channels:
                self.channels[channel].addUser(msg.nick)
            elif msg.nick: # It must be us.
                chan = ChannelState()
                chan.addUser(msg.nick)
                self.channels[channel] = chan
                # I don't know why this assert was here.
                #assert msg.nick == irc.nick, msg

    def do367(self, irc, msg):
        # Example:
        # :server 367 user #chan some!random@user evil!channel@op 1356276459
        try:
            state = self.channels[msg.args[1]]
        except KeyError:
            # We have been kicked of the channel before the server replied to
            # the MODE +b command.
            pass
        else:
            state.bans.add(msg.args[2])

    def doMode(self, irc, msg):
        channel = msg.args[0]
        if ircutils.isChannel(channel): # There can be user modes, as well.
            try:
                chan = self.channels[channel]
            except KeyError:
                chan = ChannelState()
                self.channels[channel] = chan
            chan.doMode(msg)

    def do324(self, irc, msg):
        channel = msg.args[1]
        try:
            chan = self.channels[channel]
        except KeyError:
            chan = ChannelState()
            self.channels[channel] = chan
        for (mode, value) in ircutils.separateModes(msg.args[2:]):
            modeChar = mode[1]
            if mode[0] == '+' and mode[1] not in 'ovh':
                chan.setMode(modeChar, value)
            elif mode[0] == '-' and mode[1] not in 'ovh':
                chan.unsetMode(modeChar)

    def do329(self, irc, msg):
        # This is the last part of an empty mode.
        channel = msg.args[1]
        try:
            chan = self.channels[channel]
        except KeyError:
            chan = ChannelState()
            self.channels[channel] = chan
        chan.created = int(msg.args[2])

    def doPart(self, irc, msg):
        for channel in msg.args[0].split(','):
            try:
                chan = self.channels[channel]
            except KeyError:
                continue
            if ircutils.strEqual(msg.nick, irc.nick):
                del self.channels[channel]
            else:
                chan.removeUser(msg.nick)

    def doKick(self, irc, msg):
        (channel, users) = msg.args[:2]
        chan = self.channels[channel]
        for user in users.split(','):
            if ircutils.strEqual(user, irc.nick):
                del self.channels[channel]
                return
            else:
                chan.removeUser(user)

    def doQuit(self, irc, msg):
        for channel in self.channels.itervalues():
            channel.removeUser(msg.nick)
        if msg.nick in self.nicksToHostmasks:
            # If we're quitting, it may not be.
            del self.nicksToHostmasks[msg.nick]

    def doTopic(self, irc, msg):
        if len(msg.args) == 1:
            return # Empty TOPIC for information.  Does not affect state.
        try:
            chan = self.channels[msg.args[0]]
            chan.topic = msg.args[1]
        except KeyError:
            pass # We don't have to be in a channel to send a TOPIC.

    def do332(self, irc, msg):
        chan = self.channels[msg.args[1]]
        chan.topic = msg.args[2]

    def doNick(self, irc, msg):
        newNick = msg.args[0]
        oldNick = msg.nick
        try:
            if msg.user and msg.host:
                # Nick messages being handed out from the bot itself won't
                # have the necessary prefix to make a hostmask.
                newHostmask = ircutils.joinHostmask(newNick,msg.user,msg.host)
                self.nicksToHostmasks[newNick] = newHostmask
            del self.nicksToHostmasks[oldNick]
        except KeyError:
            pass
        for channel in self.channels.itervalues():
            channel.replaceUser(oldNick, newNick)



###
# The basic class for handling a connection to an IRC server.  Accepts
# callbacks of the IrcCallback interface.  Public attributes include 'driver',
# 'queue', and 'state', in addition to the standard nick/user/ident attributes.
###
_callbacks = []
class Irc(IrcCommandDispatcher):
    """The base class for an IRC connection.

    Handles PING commands already.
    """
    __metaclass__ = log.MetaFirewall
    __firewalled__ = {'die': None,
                      'feedMsg': None,
                      'takeMsg': None,}
    _nickSetters = set(['001', '002', '003', '004', '250', '251', '252',
                        '254', '255', '265', '266', '372', '375', '376',
                        '333', '353', '332', '366', '005'])
    # We specifically want these callbacks to be common between all Ircs,
    # that's why we don't do the normal None default with a check.
    def __init__(self, network, callbacks=_callbacks):
        self.zombie = False
        world.ircs.append(self)
        self.network = network
        self.startedAt = time.time()
        self.callbacks = callbacks
        self.state = IrcState()
        self.queue = IrcMsgQueue()
        self.fastqueue = smallqueue()
        self.driver = None # The driver should set this later.
        self._setNonResettingVariables()
        self._queueConnectMessages()
        self.startedSync = ircutils.IrcDict()

    def isChannel(self, s):
        """Helper function to check whether a given string is a channel on
        the network this Irc object is connected to."""
        kw = {}
        if 'chantypes' in self.state.supported:
            kw['chantypes'] = self.state.supported['chantypes']
        if 'channellen' in self.state.supported:
            kw['channellen'] = self.state.supported['channellen']
        return ircutils.isChannel(s, **kw)

    def isNick(self, s):
        kw = {}
        if 'nicklen' in self.state.supported:
            kw['nicklen'] = self.state.supported['nicklen']
        return ircutils.isNick(s, **kw)

    # This *isn't* threadsafe!
    def addCallback(self, callback):
        """Adds a callback to the callbacks list.

        :param callback: A callback object
        :type callback: supybot.irclib.IrcCallback
        """
        assert not self.getCallback(callback.name())
        self.callbacks.append(callback)
        # This is the new list we're building, which will be tsorted.
        cbs = []
        # The vertices are self.callbacks itself.  Now we make the edges.
        edges = set()
        for cb in self.callbacks:
            (before, after) = cb.callPrecedence(self)
            assert cb not in after, 'cb was in its own after.'
            assert cb not in before, 'cb was in its own before.'
            for otherCb in before:
                edges.add((otherCb, cb))
            for otherCb in after:
                edges.add((cb, otherCb))
        def getFirsts():
            firsts = set(self.callbacks) - set(cbs)
            for (before, after) in edges:
                firsts.discard(after)
            return firsts
        firsts = getFirsts()
        while firsts:
            # Then we add these to our list of cbs, and remove all edges that
            # originate with these cbs.
            for cb in firsts:
                cbs.append(cb)
                edgesToRemove = []
                for edge in edges:
                    if edge[0] is cb:
                        edgesToRemove.append(edge)
                for edge in edgesToRemove:
                    edges.remove(edge)
            firsts = getFirsts()
        assert len(cbs) == len(self.callbacks), \
               'cbs: %s, self.callbacks: %s' % (cbs, self.callbacks)
        self.callbacks[:] = cbs

    def getCallback(self, name):
        """Gets a given callback by name."""
        name = name.lower()
        for callback in self.callbacks:
            if callback.name().lower() == name:
                return callback
        else:
            return None

    def removeCallback(self, name):
        """Removes a callback from the callback list."""
        name = name.lower()
        def nameMatches(cb):
            return cb.name().lower() == name
        (bad, good) = utils.iter.partition(nameMatches, self.callbacks)
        self.callbacks[:] = good
        return bad

    def queueMsg(self, msg):
        """Queues a message to be sent to the server."""
        if not self.zombie:
            return self.queue.enqueue(msg)
        else:
            log.warning('Refusing to queue %r; %s is a zombie.', msg, self)
            return False

    def sendMsg(self, msg):
        """Queues a message to be sent to the server *immediately*"""
        if not self.zombie:
            self.fastqueue.enqueue(msg)
        else:
            log.warning('Refusing to send %r; %s is a zombie.', msg, self)

    def takeMsg(self):
        """Called by the IrcDriver; takes a message to be sent."""
        if not self.callbacks:
            log.critical('No callbacks in %s.', self)
        now = time.time()
        msg = None
        if self.fastqueue:
            msg = self.fastqueue.dequeue()
        elif self.queue:
            if now-self.lastTake <= conf.supybot.protocols.irc.throttleTime():
                log.debug('Irc.takeMsg throttling.')
            else:
                self.lastTake = now
                msg = self.queue.dequeue()
        elif self.afterConnect and \
             conf.supybot.protocols.irc.ping() and \
             now > self.lastping + conf.supybot.protocols.irc.ping.interval():
            if self.outstandingPing:
                s = 'Ping sent at %s not replied to.' % \
                    log.timestamp(self.lastping)
                log.warning(s)
                self.feedMsg(ircmsgs.error(s))
                self.driver.reconnect()
            elif not self.zombie:
                self.lastping = now
                now = str(int(now))
                self.outstandingPing = True
                self.queueMsg(ircmsgs.ping(now))
        if msg:
            for callback in reversed(self.callbacks):
                msg = callback.outFilter(self, msg)
                if msg is None:
                    log.debug('%s.outFilter returned None.', callback.name())
                    return self.takeMsg()
                world.debugFlush()
            if len(str(msg)) > 512:
                # Yes, this violates the contract, but at this point it doesn't
                # matter.  That's why we gotta go munging in private attributes
                #
                # I'm changing this to a log.debug to fix a possible loop in
                # the LogToIrc plugin.  Since users can't do anything about
                # this issue, there's no fundamental reason to make it a
                # warning.
                log.debug('Truncating %r, message is too long.', msg)
                msg._str = msg._str[:500] + '\r\n'
                msg._len = len(str(msg))
            # I don't think we should do this.  Why should it matter?  If it's
            # something important, then the server will send it back to us,
            # and if it's just a privmsg/notice/etc., we don't care.
            # On second thought, we need this for testing.
            if world.testing:
                self.state.addMsg(self, msg)
            log.debug('Outgoing message (%s): %s', self.network, str(msg).rstrip('\r\n'))
            return msg
        elif self.zombie:
            # We kill the driver here so it doesn't continue to try to
            # take messages from us.
            self.driver.die()
            self._reallyDie()
        else:
            return None

    _numericErrorCommandRe = re.compile(r'^[45][0-9][0-9]$')
    def feedMsg(self, msg):
        """Called by the IrcDriver; feeds a message received."""
        msg.tag('receivedBy', self)
        msg.tag('receivedOn', self.network)
        msg.tag('receivedAt', time.time())
        if msg.args and self.isChannel(msg.args[0]):
            channel = msg.args[0]
        else:
            channel = None
        preInFilter = str(msg).rstrip('\r\n')
        log.debug('Incoming message (%s): %s', self.network, preInFilter)

        # Yeah, so this is odd.  Some networks (oftc) seem to give us certain
        # messages with our nick instead of our prefix.  We'll fix that here.
        if msg.prefix == self.nick:
            log.debug('Got one of those odd nick-instead-of-prefix msgs.')
            msg = ircmsgs.IrcMsg(prefix=self.prefix, msg=msg)

        # This catches cases where we know our own nick (from sending it to the
        # server) but we don't yet know our prefix.
        if msg.nick == self.nick and self.prefix != msg.prefix:
            self.prefix = msg.prefix

        # This keeps our nick and server attributes updated.
        if msg.command in self._nickSetters:
            if msg.args[0] != self.nick:
                self.nick = msg.args[0]
                log.debug('Updating nick attribute to %s.', self.nick)
            if msg.prefix != self.server:
                self.server = msg.prefix
                log.debug('Updating server attribute to %s.', self.server)

        # Dispatch to specific handlers for commands.
        method = self.dispatchCommand(msg.command)
        if method is not None:
            method(msg)
        elif self._numericErrorCommandRe.search(msg.command):
            log.error('Unhandled error message from server: %r' % msg)

        # Now update the IrcState object.
        try:
            self.state.addMsg(self, msg)
        except:
            log.exception('Exception in update of IrcState object:')

        # Now call the callbacks.
        world.debugFlush()
        for callback in self.callbacks:
            try:
                m = callback.inFilter(self, msg)
                if not m:
                    log.debug('%s.inFilter returned None', callback.name())
                    return
                msg = m
            except:
                log.exception('Uncaught exception in inFilter:')
            world.debugFlush()
        postInFilter = str(msg).rstrip('\r\n')
        if postInFilter != preInFilter:
            log.debug('Incoming message (post-inFilter): %s', postInFilter)
        for callback in self.callbacks:
            try:
                if callback is not None:
                    callback(self, msg)
            except:
                log.exception('Uncaught exception in callback:')
            world.debugFlush()

    def die(self):
        """Makes the Irc object *promise* to die -- but it won't die (of its
        own volition) until all its queues are clear.  Isn't that cool?"""
        self.zombie = True
        if not self.afterConnect:
            self._reallyDie()

    # This is useless because it's in world.ircs, so it won't be deleted until
    # the program exits.  Just figured you might want to know.
    #def __del__(self):
    #    self._reallyDie()

    def reset(self):
        """Resets the Irc object.  Called when the driver reconnects."""
        self._setNonResettingVariables()
        self.state.reset()
        self.queue.reset()
        self.fastqueue.reset()
        self.startedSync.clear()
        for callback in self.callbacks:
            callback.reset()
        self._queueConnectMessages()

    def _setNonResettingVariables(self):
        # Configuration stuff.
        def get_value(name):
            return getattr(conf.supybot.networks.get(self.network), name)() or \
                getattr(conf.supybot, name)()
        self.nick = get_value('nick')
        self.user = get_value('user')
        self.ident = get_value('ident')
        self.alternateNicks = conf.supybot.nick.alternates()[:]
        self.password = conf.supybot.networks.get(self.network).password()
        self.sasl_username = \
                conf.supybot.networks.get(self.network).sasl.username()
        # TODO Find a better way to fix this
        if hasattr(self.sasl_username, 'decode'):
            self.sasl_username = self.sasl_username.decode('utf-8')
        self.sasl_password = \
                conf.supybot.networks.get(self.network).sasl.password()
        # TODO Find a better way to fix this
        if hasattr(self.sasl_password, 'decode'):
            self.sasl_password = self.sasl_password.decode('utf-8')
        self.prefix = '%s!%s@%s' % (self.nick, self.ident, 'unset.domain')
        # The rest.
        self.lastTake = 0
        self.server = 'unset'
        self.afterConnect = False
        self.startedAt = time.time()
        self.lastping = time.time()
        self.outstandingPing = False


    def _queueConnectMessages(self):
        if self.zombie:
            self.driver.die()
            self._reallyDie()
        else:
            if self.sasl_password:
                if not self.sasl_username:
                    log.error('SASL username is not set, unable to identify.')
                else:
                    auth_string = base64.b64encode('\x00'.join([
                        self.sasl_username,
                        self.sasl_username,
                        self.sasl_password
                    ]).encode('utf-8')).decode('utf-8')
                    log.debug('Sending CAP REQ command, requesting capability \'sasl\'.')
                    self.queueMsg(ircmsgs.IrcMsg(command="CAP", args=('REQ', 'sasl')))
                    log.debug('Using SASL mechanism PLAIN.')
                    self.queueMsg(ircmsgs.IrcMsg(command="AUTHENTICATE", args=('PLAIN',)))
                    log.info('Authenticating using SASL.')
                    self.queueMsg(ircmsgs.IrcMsg(command="AUTHENTICATE", args=(auth_string,)))
            if self.password:
                log.info('Sending PASS command, not logging the password.')
                self.queueMsg(ircmsgs.password(self.password))
            log.debug('Queuing NICK command, nick is %s.', self.nick)
            self.queueMsg(ircmsgs.nick(self.nick))
            log.debug('Queuing USER command, ident is %s, user is %s.',
                     self.ident, self.user)
            self.queueMsg(ircmsgs.user(self.ident, self.user))

    def do903(self, msg):
        log.info('%s: SASL authentication successful' % self.network)
        self.queueMsg(ircmsgs.IrcMsg(command='CAP', args=('END',)))

    def do904(self, msg):
        log.warning('%s: SASL authentication failed' % self.network)
        self.queueMsg(ircmsgs.IrcMsg(command='CAP', args=('END',)))

    def do905(self, msg):
        log.warning(('%s: SASL authentication failed because your username '
                     'or password is too long.') % self.network)
        self.queueMsg(ircmsgs.IrcMsg(command='CAP', args=('END',)))

    def do906(self, msg):
        log.warning('%s: SASL authentication aborted' % self.network)
        self.queueMsg(ircmsgs.IrcMsg(command='CAP', args=('END',)))

    def do907(self, msg):
        log.warning(('%s: Attempted SASL authentication when we were already '
                     'authenticated.') % self.network)
        self.queueMsg(ircmsgs.IrcMsg(command='CAP', args=('END',)))

    def do908(self, msg):
        log.info('%s: Supported SASL mechanisms: %s' %
                 (self.network, msg.args[1]))

    def _getNextNick(self):
        if self.alternateNicks:
            nick = self.alternateNicks.pop(0)
            if '%s' in nick:
                network_nick = conf.supybot.networks.get(self.network).nick()
                if network_nick == '':
                    nick %= conf.supybot.nick()
                else:
                    nick %= network_nick
            return nick
        else:
            nick = conf.supybot.nick()
            network_nick = conf.supybot.networks.get(self.network).nick()
            if network_nick != '':
                nick = network_nick
            ret = nick
            L = list(nick)
            while len(L) <= 3:
                L.append('`')
            while ircutils.strEqual(ret, nick):
                L[random.randrange(len(L))] = utils.iter.choice('0123456789')
                ret = ''.join(L)
            return ret

    def do002(self, msg):
        """Logs the ircd version."""
        (beginning, version) = rsplit(msg.args[-1], maxsplit=1)
        log.info('Server %s has version %s', self.server, version)

    def doPing(self, msg):
        """Handles PING messages."""
        self.sendMsg(ircmsgs.pong(msg.args[0]))

    def doPong(self, msg):
        """Handles PONG messages."""
        self.outstandingPing = False

    def do376(self, msg):
        log.info('Got end of MOTD from %s', self.server)
        self.afterConnect = True
        # Let's reset nicks in case we had to use a weird one.
        self.alternateNicks = conf.supybot.nick.alternates()[:]
        umodes = conf.supybot.networks.get(self.network).umodes()
        if umodes == '':
            umodes = conf.supybot.protocols.irc.umodes()
        supported = self.state.supported.get('umodes')
        if umodes:
            addSub = '+'
            if umodes[0] in '+-':
                (addSub, umodes) = (umodes[0], umodes[1:])
            if supported:
                umodes = ''.join([m for m in umodes if m in supported])
            umodes = ''.join([addSub, umodes])
            log.info('Sending user modes to %s: %s', self.network, umodes)
            self.sendMsg(ircmsgs.mode(self.nick, umodes))
    do377 = do422 = do376

    def do43x(self, msg, problem):
        if not self.afterConnect:
            newNick = self._getNextNick()
            assert newNick != self.nick
            log.info('Got 433: %s %s.  Trying %s.',self.nick, problem, newNick)
            self.sendMsg(ircmsgs.nick(newNick))
    def do433(self, msg):
        self.do43x(msg, 'is in use')
    def do432(self, msg):
        self.do43x(msg, 'is not a valid nickname')

    def doJoin(self, msg):
        if msg.nick == self.nick:
            channel = msg.args[0]
            self.queueMsg(ircmsgs.who(channel)) # Ends with 315.
            self.queueMsg(ircmsgs.mode(channel)) # Ends with 329.
            for channel in msg.args[0].split(','):
                self.queueMsg(ircmsgs.mode(channel, '+b'))
            self.startedSync[channel] = time.time()

    def do315(self, msg):
        channel = msg.args[1]
        if channel in self.startedSync:
            now = time.time()
            started = self.startedSync.pop(channel)
            elapsed = now - started
            log.info('Join to %s on %s synced in %.2f seconds.',
                     channel, self.network, elapsed)

    def doError(self, msg):
        """Handles ERROR messages."""
        log.warning('Error message from %s: %s', self.network, msg.args[0])
        if not self.zombie:
           if msg.args[0].startswith('Closing Link'):
              self.driver.reconnect()
           elif 'too fast' in msg.args[0]: # Connecting too fast.
              self.driver.reconnect(wait=True)

    def doNick(self, msg):
        """Handles NICK messages."""
        if msg.nick == self.nick:
            newNick = msg.args[0]
            self.nick = newNick
            (nick, user, domain) = ircutils.splitHostmask(msg.prefix)
            self.prefix = ircutils.joinHostmask(self.nick, user, domain)
        elif conf.supybot.followIdentificationThroughNickChanges():
            # We use elif here because this means it's someone else's nick
            # change, not our own.
            try:
                id = ircdb.users.getUserId(msg.prefix)
                u = ircdb.users.getUser(id)
            except KeyError:
                return
            if u.auth:
                (_, user, host) = ircutils.splitHostmask(msg.prefix)
                newhostmask = ircutils.joinHostmask(msg.args[0], user, host)
                for (i, (when, authmask)) in enumerate(u.auth[:]):
                    if ircutils.strEqual(msg.prefix, authmask):
                        log.info('Following identification for %s: %s -> %s',
                                 u.name, authmask, newhostmask)
                        u.auth[i] = (u.auth[i][0], newhostmask)
                        ircdb.users.setUser(u)

    def _reallyDie(self):
        """Makes the Irc object die.  Dead."""
        log.info('Irc object for %s dying.', self.network)
        # XXX This hasattr should be removed, I'm just putting it here because
        #     we're so close to a release.  After 0.80.0 we should remove this
        #     and fix whatever AttributeErrors arise in the drivers themselves.
        if self.driver is not None and hasattr(self.driver, 'die'):
            self.driver.die()
        if self in world.ircs:
            world.ircs.remove(self)
            # Only kill the callbacks if we're the last Irc.
            if not world.ircs:
                for cb in self.callbacks:
                    cb.die()
                # If we shared our list of callbacks, this ensures that
                # cb.die() is only called once for each callback.  It's
                # not really necessary since we already check to make sure
                # we're the only Irc object, but a little robustitude never
                # hurt anybody.
                log.debug('Last Irc, clearing callbacks.')
                self.callbacks[:] = []
        else:
            log.warning('Irc object killed twice: %s', utils.stackTrace())

    def __hash__(self):
        return id(self)

    def __eq__(self, other):
        # We check isinstance here, so that if some proxy object (like those
        # defined in callbacks.py) has overridden __eq__, it takes precedence.
        if isinstance(other, self.__class__):
            return id(self) == id(other)
        else:
            return other.__eq__(self)

    def __ne__(self, other):
        return not (self == other)

    def __str__(self):
        return 'Irc object for %s' % self.network

    def __repr__(self):
        return '<irclib.Irc object for %s>' % self.network


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = ircmsgs
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# Copyright (c) 2010, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

"""
This module provides the basic IrcMsg object used throughout the bot to
represent the actual messages.  It also provides several helper functions to
construct such messages in an easier way than the constructor for the IrcMsg
object (which, as you'll read later, is quite...full-featured :))
"""

import re
import sys
import time
import functools

from . import conf, ircutils, utils
from .utils.iter import all

###
# IrcMsg class -- used for representing IRC messages acquired from a network.
###

class MalformedIrcMsg(ValueError):
    pass

class IrcMsg(object):
    """Class to represent an IRC message.

    As usual, ignore attributes that begin with an underscore.  They simply
    don't exist.  Instances of this class are *not* to be modified, since they
    are hashable.  Public attributes of this class are .prefix, .command,
    .args, .nick, .user, and .host.

    The constructor for this class is pretty intricate.  It's designed to take
    any of three major (sets of) arguments.

    Called with no keyword arguments, it takes a single string that is a raw
    IRC message (such as one taken straight from the network).

    Called with keyword arguments, it *requires* a command parameter.  Args is
    optional, but with most commands will be necessary.  Prefix is obviously
    optional, since clients aren't allowed (well, technically, they are, but
    only in a completely useless way) to send prefixes to the server.

    Since this class isn't to be modified, the constructor also accepts a 'msg'
    keyword argument representing a message from which to take all the
    attributes not provided otherwise as keyword arguments.  So, for instance,
    if a programmer wanted to take a PRIVMSG he'd gotten and simply redirect it
    to a different source, they could do this:

    IrcMsg(prefix='', args=(newSource, otherMsg.args[1]), msg=otherMsg)
    """
    # It's too useful to be able to tag IrcMsg objects with extra, unforeseen
    # data.  Goodbye, __slots__.
    # On second thought, let's use methods for tagging.
    __slots__ = ('args', 'command', 'host', 'nick', 'prefix', 'user',
                 '_hash', '_str', '_repr', '_len', 'tags', 'reply_env')
    def __init__(self, s='', command='', args=(), prefix='', msg=None,
            reply_env=None):
        assert not (msg and s), 'IrcMsg.__init__ cannot accept both s and msg'
        if not s and not command and not msg:
            raise MalformedIrcMsg('IRC messages require a command.')
        self._str = None
        self._repr = None
        self._hash = None
        self._len = None
        self.reply_env = reply_env
        self.tags = {}
        if s:
            originalString = s
            try:
                if not s.endswith('\n'):
                    s += '\n'
                self._str = s
                if s[0] == ':':
                    self.prefix, s = s[1:].split(None, 1)
                else:
                    self.prefix = ''
                if ' :' in s: # Note the space: IPV6 addresses are bad w/o it.
                    s, last = s.split(' :', 1)
                    self.args = s.split()
                    self.args.append(last.rstrip('\r\n'))
                else:
                    self.args = s.split()
                self.command = self.args.pop(0)
            except (IndexError, ValueError):
                raise MalformedIrcMsg(repr(originalString))
        else:
            if msg is not None:
                if prefix:
                    self.prefix = prefix
                else:
                    self.prefix = msg.prefix
                if command:
                    self.command = command
                else:
                    self.command = msg.command
                if args:
                    self.args = args
                else:
                    self.args = msg.args
                if reply_env:
                    self.reply_env = reply_env
                elif msg.reply_env:
                    self.reply_env = msg.reply_env.copy()
                else:
                    self.reply_env = None
                self.tags = msg.tags.copy()
            else:
                self.prefix = prefix
                self.command = command
                assert all(ircutils.isValidArgument, args), args
                self.args = args
        self.args = tuple(self.args)
        if isUserHostmask(self.prefix):
            (self.nick,self.user,self.host)=ircutils.splitHostmask(self.prefix)
        else:
            (self.nick, self.user, self.host) = (self.prefix,)*3

    def __str__(self):
        if self._str is not None:
            return self._str
        if self.prefix:
            if len(self.args) > 1:
                self._str = ':%s %s %s :%s\r\n' % \
                            (self.prefix, self.command,
                             ' '.join(self.args[:-1]), self.args[-1])
            else:
                if self.args:
                    self._str = ':%s %s :%s\r\n' % \
                                (self.prefix, self.command, self.args[0])
                else:
                    self._str = ':%s %s\r\n' % (self.prefix, self.command)
        else:
            if len(self.args) > 1:
                self._str = '%s %s :%s\r\n' % \
                            (self.command,
                             ' '.join(self.args[:-1]), self.args[-1])
            else:
                if self.args:
                    self._str = '%s :%s\r\n' % (self.command, self.args[0])
                else:
                    self._str = '%s\r\n' % self.command
        return self._str

    def __len__(self):
        return len(str(self))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and \
               hash(self) == hash(other) and \
               self.command == other.command and \
               self.prefix == other.prefix and \
               self.args == other.args
    __req__ = __eq__ # I don't know exactly what this does, but it can't hurt.

    def __ne__(self, other):
        return not (self == other)
    __rne__ = __ne__ # Likewise as above.

    def __hash__(self):
        if self._hash is not None:
            return self._hash
        self._hash = hash(self.command) ^ \
                     hash(self.prefix) ^ \
                     hash(repr(self.args))
        return self._hash

    def __repr__(self):
        if self._repr is not None:
            return self._repr
        self._repr = format('IrcMsg(prefix=%q, command=%q, args=%r)',
                            self.prefix, self.command, self.args)
        return self._repr

    def __reduce__(self):
        return (self.__class__, (str(self),))

    def tag(self, tag, value=True):
        """Affect a key:value pair to this message."""
        self.tags[tag] = value

    def tagged(self, tag):
        """Get the value affected to a tag."""
        return self.tags.get(tag) # Returns None if it's not there.

    def __getattr__(self, attr):
        return self.tagged(attr)


def isCtcp(msg):
    """Returns whether or not msg is a CTCP message."""
    return msg.command in ('PRIVMSG', 'NOTICE') and \
           msg.args[1].startswith('\x01') and \
           msg.args[1].endswith('\x01') and \
           len(msg.args[1]) >= 2

def isAction(msg):
    """A predicate returning true if the PRIVMSG in question is an ACTION"""
    if isCtcp(msg):
        s = msg.args[1]
        payload = s[1:-1] # Chop off \x01.
        command = payload.split(None, 1)[0]
        return command == 'ACTION'
    else:
        return False

def isSplit(msg):
    if msg.command == 'QUIT':
        # It's a quit.
        quitmsg = msg.args[0]
        if not quitmsg.startswith('"') and not quitmsg.endswith('"'):
            # It's not a user-generated quitmsg.
            servers = quitmsg.split()
            if len(servers) == 2:
                # We could check if domains match, or if the hostnames actually
                # resolve, but we're going to put that off for now.
                return True
    return False

_unactionre = re.compile(r'^\x01ACTION\s+(.*)\x01$')
def unAction(msg):
    """Returns the payload (i.e., non-ACTION text) of an ACTION msg."""
    assert isAction(msg)
    return _unactionre.match(msg.args[1]).group(1)

def _escape(s):
    s = s.replace('&', '&amp;')
    s = s.replace('"', '&quot;')
    s = s.replace('<', '&lt;')
    s = s.replace('>', '&gt;')
    return s

def toXml(msg, pretty=True, includeTime=True):
    assert msg.command == _escape(msg.command)
    L = []
    L.append('<msg command="%s" prefix="%s"'%(msg.command,_escape(msg.prefix)))
    if includeTime:
        L.append(' time="%s"' % time.time())
    L.append('>')
    if pretty:
        L.append('\n')
    for arg in msg.args:
        if pretty:
            L.append('    ')
        L.append('<arg>%s</arg>' % _escape(arg))
        if pretty:
            L.append('\n')
    L.append('</msg>\n')
    return ''.join(L)

def prettyPrint(msg, addRecipients=False, timestampFormat=None, showNick=True):
    """Provides a client-friendly string form for messages.

    IIRC, I copied BitchX's (or was it XChat's?) format for messages.
    """
    def nickorprefix():
        return msg.nick or msg.prefix
    def nick():
        if addRecipients:
            return '%s/%s' % (msg.nick, msg.args[0])
        else:
            return msg.nick
    if msg.command == 'PRIVMSG':
        m = _unactionre.match(msg.args[1])
        if m:
            s = '* %s %s' % (nick(), m.group(1))
        else:
            if not showNick:
                s = '%s' % msg.args[1]
            else:
                s = '<%s> %s' % (nick(), msg.args[1])
    elif msg.command == 'NOTICE':
        if not showNick:
            s = '%s' % msg.args[1]
        else:
            s = '-%s- %s' % (nick(), msg.args[1])
    elif msg.command == 'JOIN':
        prefix = msg.prefix
        if msg.nick:
            prefix = '%s <%s>' % (msg.nick, prefix)
        s = '*** %s has joined %s' % (prefix, msg.args[0])
    elif msg.command == 'PART':
        if len(msg.args) > 1:
            partmsg = ' (%s)' % msg.args[1]
        else:
            partmsg = ''
        s = '*** %s <%s> has parted %s%s' % (msg.nick, msg.prefix,
                                             msg.args[0], partmsg)
    elif msg.command == 'KICK':
        if len(msg.args) > 2:
            kickmsg = ' (%s)' % msg.args[1]
        else:
            kickmsg = ''
        s = '*** %s was kicked by %s%s' % (msg.args[1], msg.nick, kickmsg)
    elif msg.command == 'MODE':
        s = '*** %s sets mode: %s' % (nickorprefix(), ' '.join(msg.args))
    elif msg.command == 'QUIT':
        if msg.args:
            quitmsg = ' (%s)' % msg.args[0]
        else:
            quitmsg = ''
        s = '*** %s <%s> has quit IRC%s' % (msg.nick, msg.prefix, quitmsg)
    elif msg.command == 'TOPIC':
        s = '*** %s changes topic to %s' % (nickorprefix(), msg.args[1])
    elif msg.command == 'NICK':
        s = '*** %s is now known as %s' % (msg.nick, msg.args[0])
    else:
        s = utils.str.format('--- Unknown command %q', ' '.join(msg.args))
    at = getattr(msg, 'receivedAt', None)
    if timestampFormat and at:
        s = '%s %s' % (time.strftime(timestampFormat, time.localtime(at)), s)
    return s

###
# Various IrcMsg functions
###

isNick = ircutils.isNick
areNicks = ircutils.areNicks
isChannel = ircutils.isChannel
areChannels = ircutils.areChannels
areReceivers = ircutils.areReceivers
isUserHostmask = ircutils.isUserHostmask

def pong(payload, prefix='', msg=None):
    """Takes a payload and returns the proper PONG IrcMsg."""
    if conf.supybot.protocols.irc.strictRfc():
        assert payload, 'PONG requires a payload'
    if msg and not prefix:
        prefix = msg.prefix
    return IrcMsg(prefix=prefix, command='PONG', args=(payload,), msg=msg)

def ping(payload, prefix='', msg=None):
    """Takes a payload and returns the proper PING IrcMsg."""
    if conf.supybot.protocols.irc.strictRfc():
        assert payload, 'PING requires a payload'
    if msg and not prefix:
        prefix = msg.prefix
    return IrcMsg(prefix=prefix, command='PING', args=(payload,), msg=msg)

def op(channel, nick, prefix='', msg=None):
    """Returns a MODE to op nick on channel."""
    if conf.supybot.protocols.irc.strictRfc():
        assert isChannel(channel), repr(channel)
        assert isNick(nick), repr(nick)
    if msg and not prefix:
        prefix = msg.prefix
    return IrcMsg(prefix=prefix, command='MODE',
                  args=(channel, '+o', nick), msg=msg)

def ops(channel, nicks, prefix='', msg=None):
    """Returns a MODE to op each of nicks on channel."""
    if conf.supybot.protocols.irc.strictRfc():
        assert isChannel(channel), repr(channel)
        assert nicks, 'Nicks must not be empty.'
        assert all(isNick, nicks), nicks
    if msg and not prefix:
        prefix = msg.prefix
    return IrcMsg(prefix=prefix, command='MODE',
                  args=(channel, '+' + ('o'*len(nicks))) + tuple(nicks),
                  msg=msg)

def deop(channel, nick, prefix='', msg=None):
    """Returns a MODE to deop nick on channel."""
    if conf.supybot.protocols.irc.strictRfc():
        assert isChannel(channel), repr(channel)
        assert isNick(nick), repr(nick)
    if msg and not prefix:
        prefix = msg.prefix
    return IrcMsg(prefix=prefix, command='MODE',
                  args=(channel, '-o', nick), msg=msg)

def deops(channel, nicks, prefix='', msg=None):
    """Returns a MODE to deop each of nicks on channel."""
    if conf.supybot.protocols.irc.strictRfc():
        assert isChannel(channel), repr(channel)
        assert nicks, 'Nicks must not be empty.'
        assert all(isNick, nicks), nicks
    if msg and not prefix:
        prefix = msg.prefix
    return IrcMsg(prefix=prefix, command='MODE', msg=msg,
                  args=(channel, '-' + ('o'*len(nicks))) + tuple(nicks))

def halfop(channel, nick, prefix='', msg=None):
    """Returns a MODE to halfop nick on channel."""
    if conf.supybot.protocols.irc.strictRfc():
        assert isChannel(channel), repr(channel)
        assert isNick(nick), repr(nick)
    if msg and not prefix:
        prefix = msg.prefix
    return IrcMsg(prefix=prefix, command='MODE',
                  args=(channel, '+h', nick), msg=msg)

def halfops(channel, nicks, prefix='', msg=None):
    """Returns a MODE to halfop each of nicks on channel."""
    if conf.supybot.protocols.irc.strictRfc():
        assert isChannel(channel), repr(channel)
        assert nicks, 'Nicks must not be empty.'
        assert all(isNick, nicks), nicks
    if msg and not prefix:
        prefix = msg.prefix
    return IrcMsg(prefix=prefix, command='MODE', msg=msg,
                  args=(channel, '+' + ('h'*len(nicks))) + tuple(nicks))

def dehalfop(channel, nick, prefix='', msg=None):
    """Returns a MODE to dehalfop nick on channel."""
    if conf.supybot.protocols.irc.strictRfc():
        assert isChannel(channel), repr(channel)
        assert isNick(nick), repr(nick)
    if msg and not prefix:
        prefix = msg.prefix
    return IrcMsg(prefix=prefix, command='MODE',
                  args=(channel, '-h', nick), msg=msg)

def dehalfops(channel, nicks, prefix='', msg=None):
    """Returns a MODE to dehalfop each of nicks on channel."""
    if conf.supybot.protocols.irc.strictRfc():
        assert isChannel(channel), repr(channel)
        assert nicks, 'Nicks must not be empty.'
        assert all(isNick, nicks), nicks
    if msg and not prefix:
        prefix = msg.prefix
    return IrcMsg(prefix=prefix, command='MODE', msg=msg,
                  args=(channel, '-' + ('h'*len(nicks))) + tuple(nicks))

def voice(channel, nick, prefix='', msg=None):
    """Returns a MODE to voice nick on channel."""
    if conf.supybot.protocols.irc.strictRfc():
        assert isChannel(channel), repr(channel)
        assert isNick(nick), repr(nick)
    if msg and not prefix:
        prefix = msg.prefix
    return IrcMsg(prefix=prefix, command='MODE',
                  args=(channel, '+v', nick), msg=msg)

def voices(channel, nicks, prefix='', msg=None):
    """Returns a MODE to voice each of nicks on channel."""
    if conf.supybot.protocols.irc.strictRfc():
        assert isChannel(channel), repr(channel)
        assert nicks, 'Nicks must not be empty.'
        assert all(isNick, nicks)
    if msg and not prefix:
        prefix = msg.prefix
    return IrcMsg(prefix=prefix, command='MODE', msg=msg,
                  args=(channel, '+' + ('v'*len(nicks))) + tuple(nicks))

def devoice(channel, nick, prefix='', msg=None):
    """Returns a MODE to devoice nick on channel."""
    if conf.supybot.protocols.irc.strictRfc():
        assert isChannel(channel), repr(channel)
        assert isNick(nick), repr(nick)
    if msg and not prefix:
        prefix = msg.prefix
    return IrcMsg(prefix=prefix, command='MODE',
                  args=(channel, '-v', nick), msg=msg)

def devoices(channel, nicks, prefix='', msg=None):
    """Returns a MODE to devoice each of nicks on channel."""
    if conf.supybot.protocols.irc.strictRfc():
        assert isChannel(channel), repr(channel)
        assert nicks, 'Nicks must not be empty.'
        assert all(isNick, nicks), nicks
    if msg and not prefix:
        prefix = msg.prefix
    return IrcMsg(prefix=prefix, command='MODE', msg=msg,
                  args=(channel, '-' + ('v'*len(nicks))) + tuple(nicks))

def ban(channel, hostmask, exception='', prefix='', msg=None):
    """Returns a MODE to ban nick on channel."""
    if conf.supybot.protocols.irc.strictRfc():
        assert isChannel(channel), repr(channel)
        assert isUserHostmask(hostmask), repr(hostmask)
    modes = [('+b', hostmask)]
    if exception:
        modes.append(('+e', exception))
    if msg and not prefix:
        prefix = msg.prefix
    return IrcMsg(prefix=prefix, command='MODE',
                  args=[channel] + ircutils.joinModes(modes), msg=msg)

def bans(channel, hostmasks, exceptions=(), prefix='', msg=None):
    """Returns a MODE to ban each of nicks on channel."""
    if conf.supybot.protocols.irc.strictRfc():
        assert isChannel(channel), repr(channel)
        assert all(isUserHostmask, hostmasks), hostmasks
    modes = [('+b', s) for s in hostmasks] + [('+e', s) for s in exceptions]
    if msg and not prefix:
        prefix = msg.prefix
    return IrcMsg(prefix=prefix, command='MODE',
                  args=[channel] + ircutils.joinModes(modes), msg=msg)

def unban(channel, hostmask, prefix='', msg=None):
    """Returns a MODE to unban nick on channel."""
    if conf.supybot.protocols.irc.strictRfc():
        assert isChannel(channel), repr(channel)
        assert isUserHostmask(hostmask), repr(hostmask)
    if msg and not prefix:
        prefix = msg.prefix
    return IrcMsg(prefix=prefix, command='MODE',
                  args=(channel, '-b', hostmask), msg=msg)

def unbans(channel, hostmasks, prefix='', msg=None):
    """Returns a MODE to unban each of nicks on channel."""
    if conf.supybot.protocols.irc.strictRfc():
        assert isChannel(channel), repr(channel)
        assert all(isUserHostmask, hostmasks), hostmasks
    modes = [('-b', s) for s in hostmasks]
    if msg and not prefix:
        prefix = msg.prefix
    return IrcMsg(prefix=prefix, command='MODE',
                  args=[channel] + ircutils.joinModes(modes), msg=msg)

def kick(channel, nick, s='', prefix='', msg=None):
    """Returns a KICK to kick nick from channel with the message msg."""
    if conf.supybot.protocols.irc.strictRfc():
        assert isChannel(channel), repr(channel)
        assert isNick(nick), repr(nick)
    if msg and not prefix:
        prefix = msg.prefix
    if sys.version_info[0] < 3 and isinstance(s, unicode):
        s = s.encode('utf8')
    assert isinstance(s, str)
    if s:
        return IrcMsg(prefix=prefix, command='KICK',
                      args=(channel, nick, s), msg=msg)
    else:
        return IrcMsg(prefix=prefix, command='KICK',
                      args=(channel, nick), msg=msg)

def kicks(channels, nicks, s='', prefix='', msg=None):
    """Returns a KICK to kick each of nicks from channel with the message msg.
    """
    if isinstance(channels, str): # Backward compatibility
        channels = [channels]
    if conf.supybot.protocols.irc.strictRfc():
        assert areChannels(channels), repr(channels)
        assert areNicks(nicks), repr(nicks)
    if msg and not prefix:
        prefix = msg.prefix
    if sys.version_info[0] < 3 and isinstance(s, unicode):
        s = s.encode('utf8')
    assert isinstance(s, str)
    if s:
        for channel in channels:
            return IrcMsg(prefix=prefix, command='KICK',
                          args=(channel, ','.join(nicks), s), msg=msg)
    else:
        for channel in channels:
            return IrcMsg(prefix=prefix, command='KICK',
                          args=(channel, ','.join(nicks)), msg=msg)

def privmsg(recipient, s, prefix='', msg=None):
    """Returns a PRIVMSG to recipient with the message msg."""
    if conf.supybot.protocols.irc.strictRfc():
        assert (areReceivers(recipient)), repr(recipient)
        assert s, 's must not be empty.'
    if sys.version_info[0] < 3 and isinstance(s, unicode):
        s = s.encode('utf8')
    assert isinstance(s, str)
    if msg and not prefix:
        prefix = msg.prefix
    return IrcMsg(prefix=prefix, command='PRIVMSG',
                  args=(recipient, s), msg=msg)

def dcc(recipient, kind, *args, **kwargs):
    # Stupid Python won't allow (recipient, kind, *args, prefix=''), so we have
    # to use the **kwargs form.  Blech.
    assert isNick(recipient), 'Can\'t DCC a channel.'
    kind = kind.upper()
    assert kind in ('SEND', 'CHAT', 'RESUME', 'ACCEPT'), 'Invalid DCC command.'
    args = (kind,) + args
    return IrcMsg(prefix=kwargs.get('prefix', ''), command='PRIVMSG',
                  args=(recipient, ' '.join(args)))

def action(recipient, s, prefix='', msg=None):
    """Returns a PRIVMSG ACTION to recipient with the message msg."""
    if conf.supybot.protocols.irc.strictRfc():
        assert (isChannel(recipient) or isNick(recipient)), repr(recipient)
    if msg and not prefix:
        prefix = msg.prefix
    return IrcMsg(prefix=prefix, command='PRIVMSG',
                  args=(recipient, '\x01ACTION %s\x01' % s), msg=msg)

def notice(recipient, s, prefix='', msg=None):
    """Returns a NOTICE to recipient with the message msg."""
    if conf.supybot.protocols.irc.strictRfc():
        assert areReceivers(recipient), repr(recipient)
        assert s, 'msg must not be empty.'
    if sys.version_info[0] < 3 and isinstance(s, unicode):
        s = s.encode('utf8')
    assert isinstance(s, str)
    if msg and not prefix:
        prefix = msg.prefix
    return IrcMsg(prefix=prefix, command='NOTICE', args=(recipient, s), msg=msg)

def join(channel, key=None, prefix='', msg=None):
    """Returns a JOIN to a channel"""
    if conf.supybot.protocols.irc.strictRfc():
        assert areChannels(channel), repr(channel)
    if msg and not prefix:
        prefix = msg.prefix
    if key is None:
        return IrcMsg(prefix=prefix, command='JOIN', args=(channel,), msg=msg)
    else:
        if conf.supybot.protocols.irc.strictRfc():
            chars = '\x00\r\n\f\t\v '
            assert not any([(ord(x) >= 128 or x in chars) for x in key])
        return IrcMsg(prefix=prefix, command='JOIN',
                      args=(channel, key), msg=msg)

def joins(channels, keys=None, prefix='', msg=None):
    """Returns a JOIN to each of channels."""
    if conf.supybot.protocols.irc.strictRfc():
        assert all(isChannel, channels), channels
    if msg and not prefix:
        prefix = msg.prefix
    if keys is None:
        keys = []
    assert len(keys) <= len(channels), 'Got more keys than channels.'
    if not keys:
        return IrcMsg(prefix=prefix,
                      command='JOIN',
                      args=(','.join(channels),), msg=msg)
    else:
        if conf.supybot.protocols.irc.strictRfc():
            chars = '\x00\r\n\f\t\v '
            for key in keys:
                assert not any([(ord(x) >= 128 or x in chars) for x in key])
        return IrcMsg(prefix=prefix,
                      command='JOIN',
                      args=(','.join(channels), ','.join(keys)), msg=msg)

def part(channel, s='', prefix='', msg=None):
    """Returns a PART from channel with the message msg."""
    if conf.supybot.protocols.irc.strictRfc():
        assert isChannel(channel), repr(channel)
    if msg and not prefix:
        prefix = msg.prefix
    if sys.version_info[0] < 3 and isinstance(s, unicode):
        s = s.encode('utf8')
    assert isinstance(s, str)
    if s:
        return IrcMsg(prefix=prefix, command='PART',
                      args=(channel, s), msg=msg)
    else:
        return IrcMsg(prefix=prefix, command='PART',
                      args=(channel,), msg=msg)

def parts(channels, s='', prefix='', msg=None):
    """Returns a PART from each of channels with the message msg."""
    if conf.supybot.protocols.irc.strictRfc():
        assert all(isChannel, channels), channels
    if msg and not prefix:
        prefix = msg.prefix
    if sys.version_info[0] < 3 and isinstance(s, unicode):
        s = s.encode('utf8')
    assert isinstance(s, str)
    if s:
        return IrcMsg(prefix=prefix, command='PART',
                      args=(','.join(channels), s), msg=msg)
    else:
        return IrcMsg(prefix=prefix, command='PART',
                      args=(','.join(channels),), msg=msg)

def quit(s='', prefix='', msg=None):
    """Returns a QUIT with the message msg."""
    if msg and not prefix:
        prefix = msg.prefix
    if s:
        return IrcMsg(prefix=prefix, command='QUIT', args=(s,), msg=msg)
    else:
        return IrcMsg(prefix=prefix, command='QUIT', msg=msg)

def topic(channel, topic=None, prefix='', msg=None):
    """Returns a TOPIC for channel with the topic topic."""
    if conf.supybot.protocols.irc.strictRfc():
        assert isChannel(channel), repr(channel)
    if msg and not prefix:
        prefix = msg.prefix
    if topic is None:
        return IrcMsg(prefix=prefix, command='TOPIC',
                      args=(channel,), msg=msg)
    else:
        if sys.version_info[0] < 3 and isinstance(topic, unicode):
            topic = topic.encode('utf8')
        assert isinstance(topic, str)
        return IrcMsg(prefix=prefix, command='TOPIC',
                      args=(channel, topic), msg=msg)

def nick(nick, prefix='', msg=None):
    """Returns a NICK with nick nick."""
    if conf.supybot.protocols.irc.strictRfc():
        assert isNick(nick), repr(nick)
    if msg and not prefix:
        prefix = msg.prefix
    return IrcMsg(prefix=prefix, command='NICK', args=(nick,), msg=msg)

def user(ident, user, prefix='', msg=None):
    """Returns a USER with ident ident and user user."""
    if conf.supybot.protocols.irc.strictRfc():
        assert '\x00' not in ident and \
               '\r' not in ident and \
               '\n' not in ident and \
               ' ' not in ident and \
               '@' not in ident
    if msg and not prefix:
        prefix = msg.prefix
    return IrcMsg(prefix=prefix, command='USER',
                  args=(ident, '0', '*', user), msg=msg)

def who(hostmaskOrChannel, prefix='', msg=None):
    """Returns a WHO for the hostmask or channel hostmaskOrChannel."""
    if conf.supybot.protocols.irc.strictRfc():
        assert isChannel(hostmaskOrChannel) or \
               isUserHostmask(hostmaskOrChannel), repr(hostmaskOrChannel)
    if msg and not prefix:
        prefix = msg.prefix
    return IrcMsg(prefix=prefix, command='WHO',
                  args=(hostmaskOrChannel,), msg=msg)

def _whois(COMMAND, nick, mask='', prefix='', msg=None):
    """Returns a WHOIS for nick."""
    if conf.supybot.protocols.irc.strictRfc():
        assert areNicks(nick), repr(nick)
    if msg and not prefix:
        prefix = msg.prefix
    args = (nick,)
    if mask:
        args = (nick, mask)
    return IrcMsg(prefix=prefix, command=COMMAND, args=args, msg=msg)
whois = functools.partial(_whois, 'WHOIS')
whowas = functools.partial(_whois, 'WHOWAS')

def names(channel=None, prefix='', msg=None):
    if conf.supybot.protocols.irc.strictRfc():
        assert areChannels(channel)
    if msg and not prefix:
        prefix = msg.prefix
    if channel is not None:
        return IrcMsg(prefix=prefix, command='NAMES', args=(channel,), msg=msg)
    else:
        return IrcMsg(prefix=prefix, command='NAMES', msg=msg)

def mode(channel, args=(), prefix='', msg=None):
    if msg and not prefix:
        prefix = msg.prefix
    if isinstance(args, basestring):
        args = (args,)
    else:
        args = tuple(map(str, args))
    return IrcMsg(prefix=prefix, command='MODE', args=(channel,)+args, msg=msg)

def modes(channel, args=(), prefix='', msg=None):
    """Returns a MODE to quiet each of nicks on channel."""
    if conf.supybot.protocols.irc.strictRfc():
        assert isChannel(channel), repr(channel)
    modes = args
    if msg and not prefix:
        prefix = msg.prefix
    return IrcMsg(prefix=prefix, command='MODE',
                  args=[channel] + ircutils.joinModes(modes), msg=msg)

def limit(channel, limit, prefix='', msg=None):
    return mode(channel, ['+l', limit], prefix=prefix, msg=msg)

def unlimit(channel, limit, prefix='', msg=None):
    return mode(channel, ['-l', limit], prefix=prefix, msg=msg)

def invite(nick, channel, prefix='', msg=None):
    """Returns an INVITE for nick."""
    if conf.supybot.protocols.irc.strictRfc():
        assert isNick(nick), repr(nick)
    if msg and not prefix:
        prefix = msg.prefix
    return IrcMsg(prefix=prefix, command='INVITE',
                  args=(nick, channel), msg=msg)

def password(password, prefix='', msg=None):
    """Returns a PASS command for accessing a server."""
    if conf.supybot.protocols.irc.strictRfc():
        assert password, 'password must not be empty.'
    if msg and not prefix:
        prefix = msg.prefix
    return IrcMsg(prefix=prefix, command='PASS', args=(password,), msg=msg)

def ison(nick, prefix='', msg=None):
    if conf.supybot.protocols.irc.strictRfc():
        assert isNick(nick), repr(nick)
    if msg and not prefix:
        prefix = msg.prefix
    return IrcMsg(prefix=prefix, command='ISON', args=(nick,), msg=msg)

def error(s, msg=None):
    return IrcMsg(command='ERROR', args=(s,), msg=msg)

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = ircutils
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# Copyright (c) 2009,2011, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

"""
Provides a great number of useful utility functions for IRC.  Things to muck
around with hostmasks, set bold or color on strings, IRC-case-insensitive
dicts, a nick class to handle nicks (so comparisons and hashing and whatnot
work in an IRC-case-insensitive fashion), and numerous other things.
"""

from __future__ import division
from __future__ import print_function

import re
import sys
import time
import random
import string
import textwrap
import functools
from cStringIO import StringIO as sio

from . import utils
from . import minisix


def debug(s, *args):
    """Prints a debug string.  Most likely replaced by our logging debug."""
    print('***', s % args)

userHostmaskRe = re.compile(r'^\S+!\S+@\S+$')
def isUserHostmask(s):
    """Returns whether or not the string s is a valid User hostmask."""
    return userHostmaskRe.match(s) is not None

def isServerHostmask(s):
    """s => bool
    Returns True if s is a valid server hostmask."""
    return not isUserHostmask(s)

def nickFromHostmask(hostmask):
    """hostmask => nick
    Returns the nick from a user hostmask."""
    assert isUserHostmask(hostmask)
    return splitHostmask(hostmask)[0]

def userFromHostmask(hostmask):
    """hostmask => user
    Returns the user from a user hostmask."""
    assert isUserHostmask(hostmask)
    return splitHostmask(hostmask)[1]

def hostFromHostmask(hostmask):
    """hostmask => host
    Returns the host from a user hostmask."""
    assert isUserHostmask(hostmask)
    return splitHostmask(hostmask)[2]

def splitHostmask(hostmask):
    """hostmask => (nick, user, host)
    Returns the nick, user, host of a user hostmask."""
    assert isUserHostmask(hostmask)
    nick, rest = hostmask.split('!', 1)
    user, host = rest.split('@', 1)
    return (minisix.intern(nick), minisix.intern(user), minisix.intern(host))

def joinHostmask(nick, ident, host):
    """nick, user, host => hostmask
    Joins the nick, ident, host into a user hostmask."""
    assert nick and ident and host
    return minisix.intern('%s!%s@%s' % (nick, ident, host))

_rfc1459trans = utils.str.MultipleReplacer(dict(list(zip(
                                 string.ascii_uppercase + r'\[]~',
                                 string.ascii_lowercase + r'|{}^'))))
def toLower(s, casemapping=None):
    """s => s
    Returns the string s lowered according to IRC case rules."""
    if casemapping is None or casemapping == 'rfc1459':
        return _rfc1459trans(s)
    elif casemapping == 'ascii': # freenode
        return s.lower()
    else:
        raise ValueError('Invalid casemapping: %r' % casemapping)

def strEqual(nick1, nick2):
    """s1, s2 => bool
    Returns True if nick1 == nick2 according to IRC case rules."""
    assert isinstance(nick1, basestring)
    assert isinstance(nick2, basestring)
    return toLower(nick1) == toLower(nick2)

nickEqual = strEqual

_nickchars = r'[]\`_^{|}'
nickRe = re.compile(r'^[A-Za-z%s][-0-9A-Za-z%s]*$'
                    % (re.escape(_nickchars), re.escape(_nickchars)))
def isNick(s, strictRfc=True, nicklen=None):
    """s => bool
    Returns True if s is a valid IRC nick."""
    if strictRfc:
        ret = bool(nickRe.match(s))
        if ret and nicklen is not None:
            ret = len(s) <= nicklen
        return ret
    else:
        return not isChannel(s) and \
               not isUserHostmask(s) and \
               not ' ' in s and not '!' in s

def areNicks(s, strictRfc=True, nicklen=None):
    """Like 'isNick(x)' but for comma-separated list."""
    nick = functools.partial(isNick, strictRfc=strictRfc, nicklen=nicklen)
    return all(map(nick, s.split(',')))

def isChannel(s, chantypes='#&+!', channellen=50):
    """s => bool
    Returns True if s is a valid IRC channel name."""
    return s and \
           ',' not in s and \
           '\x07' not in s and \
           s[0] in chantypes and \
           len(s) <= channellen and \
           len(s.split(None, 1)) == 1

def areChannels(s, chantypes='#&+!',channellen=50):
    """Like 'isChannel(x)' but for comma-separated list."""
    chan = functools.partial(isChannel, chantypes=chantypes,
            channellen=channellen)
    return all(map(chan, s.split(',')))

def areReceivers(s, strictRfc=True, nicklen=None, chantypes='#&+!',
        channellen=50):
    """Like 'isNick(x) or isChannel(x)' but for comma-separated list."""
    nick = functools.partial(isNick, strictRfc=strictRfc, nicklen=nicklen)
    chan = functools.partial(isChannel, chantypes=chantypes,
            channellen=channellen)
    return all([nick(x) or chan(x) for x in s.split(',')])

_patternCache = utils.structures.CacheDict(1000)
def _hostmaskPatternEqual(pattern, hostmask):
    try:
        return _patternCache[pattern](hostmask) is not None
    except KeyError:
        # We make our own regexps, rather than use fnmatch, because fnmatch's
        # case-insensitivity is not IRC's case-insensitity.
        fd = sio()
        for c in pattern:
            if c == '*':
                fd.write('.*')
            elif c == '?':
                fd.write('.')
            elif c in '[{':
                fd.write('[[{]')
            elif c in '}]':
                fd.write(r'[}\]]')
            elif c in '|\\':
                fd.write(r'[|\\]')
            elif c in '^~':
                fd.write('[~^]')
            else:
                fd.write(re.escape(c))
        fd.write('$')
        f = re.compile(fd.getvalue(), re.I).match
        _patternCache[pattern] = f
        return f(hostmask) is not None

_hostmaskPatternEqualCache = utils.structures.CacheDict(1000)
def hostmaskPatternEqual(pattern, hostmask):
    """pattern, hostmask => bool
    Returns True if hostmask matches the hostmask pattern pattern."""
    try:
        return _hostmaskPatternEqualCache[(pattern, hostmask)]
    except KeyError:
        b = _hostmaskPatternEqual(pattern, hostmask)
        _hostmaskPatternEqualCache[(pattern, hostmask)] = b
        return b

def banmask(hostmask):
    """Returns a properly generic banning hostmask for a hostmask.

    >>> banmask('nick!user@host.domain.tld')
    '*!*@*.domain.tld'

    >>> banmask('nick!user@10.0.0.1')
    '*!*@10.0.0.*'
    """
    assert isUserHostmask(hostmask)
    host = hostFromHostmask(hostmask)
    if utils.net.isIPV4(host):
        L = host.split('.')
        L[-1] = '*'
        return '*!*@' + '.'.join(L)
    elif utils.net.isIPV6(host):
        L = host.split(':')
        L[-1] = '*'
        return '*!*@' + ':'.join(L)
    else:
        if len(host.split('.')) > 2: # If it is a subdomain
            return '*!*@*%s' % host[host.find('.'):]
        else:
            return '*!*@'  + host

_plusRequireArguments = 'ovhblkqeI'
_minusRequireArguments = 'ovhbkqeI'
def separateModes(args):
    """Separates modelines into single mode change tuples.  Basically, you
    should give it the .args of a MODE IrcMsg.

    Examples:

    >>> separateModes(['+ooo', 'jemfinch', 'StoneTable', 'philmes'])
    [('+o', 'jemfinch'), ('+o', 'StoneTable'), ('+o', 'philmes')]

    >>> separateModes(['+o-o', 'jemfinch', 'PeterB'])
    [('+o', 'jemfinch'), ('-o', 'PeterB')]

    >>> separateModes(['+s-o', 'test'])
    [('+s', None), ('-o', 'test')]

    >>> separateModes(['+sntl', '100'])
    [('+s', None), ('+n', None), ('+t', None), ('+l', 100)]
    """
    if not args:
        return []
    modes = args[0]
    assert modes[0] in '+-', 'Invalid args: %r' % args
    args = list(args[1:])
    ret = []
    for c in modes:
        if c in '+-':
            last = c
        else:
            if last == '+':
                requireArguments = _plusRequireArguments
            else:
                requireArguments = _minusRequireArguments
            if c in requireArguments:
                if not args:
                    # It happens, for example with "MODE #channel +b", which
                    # is used for getting the list of all bans.
                    continue
                arg = args.pop(0)
                try:
                    arg = int(arg)
                except ValueError:
                    pass
                ret.append((last + c, arg))
            else:
                ret.append((last + c, None))
    return ret

def joinModes(modes):
    """[(mode, targetOrNone), ...] => args
    Joins modes of the same form as returned by separateModes."""
    args = []
    modeChars = []
    currentMode = '\x00'
    for (mode, arg) in modes:
        if arg is not None:
            args.append(arg)
        if not mode.startswith(currentMode):
            currentMode = mode[0]
            modeChars.append(mode[0])
        modeChars.append(mode[1])
    args.insert(0, ''.join(modeChars))
    return args

def bold(s):
    """Returns the string s, bolded."""
    return '\x02%s\x02' % s

def reverse(s):
    """Returns the string s, reverse-videoed."""
    return '\x16%s\x16' % s

def underline(s):
    """Returns the string s, underlined."""
    return '\x1F%s\x1F' % s

# Definition of mircColors dictionary moved below because it became an IrcDict.
def mircColor(s, fg=None, bg=None):
    """Returns s with the appropriate mIRC color codes applied."""
    if fg is None and bg is None:
        return s
    elif bg is None:
        if str(fg) in mircColors:
            fg = mircColors[str(fg)]
        elif len(str(fg)) > 1:
            fg = mircColors[str(fg)[:-1]]
        else:
            # Should not happen
            pass
        return '\x03%s%s\x03' % (fg.zfill(2), s)
    elif fg is None:
        bg = mircColors[str(bg)]
        # According to the mirc color doc, a fg color MUST be specified if a
        # background color is specified.  So, we'll specify 00 (white) if the
        # user doesn't specify one.
        return '\x0300,%s%s\x03' % (bg.zfill(2), s)
    else:
        fg = mircColors[str(fg)]
        bg = mircColors[str(bg)]
        # No need to zfill fg because the comma delimits.
        return '\x03%s,%s%s\x03' % (fg, bg.zfill(2), s)

def canonicalColor(s, bg=False, shift=0):
    """Assigns an (fg, bg) canonical color pair to a string based on its hash
    value.  This means it might change between Python versions.  This pair can
    be used as a *parameter to mircColor.  The shift parameter is how much to
    right-shift the hash value initially.
    """
    h = hash(s) >> shift
    fg = h % 14 + 2 # The + 2 is to rule out black and white.
    if bg:
        bg = (h >> 4) & 3 # The 5th, 6th, and 7th least significant bits.
        if fg < 8:
            bg += 8
        else:
            bg += 2
        return (fg, bg)
    else:
        return (fg, None)

def stripBold(s):
    """Returns the string s, with bold removed."""
    return s.replace('\x02', '')

_stripColorRe = re.compile(r'\x03(?:\d{1,2},\d{1,2}|\d{1,2}|,\d{1,2}|)')
def stripColor(s):
    """Returns the string s, with color removed."""
    return _stripColorRe.sub('', s)

def stripReverse(s):
    """Returns the string s, with reverse-video removed."""
    return s.replace('\x16', '')

def stripUnderline(s):
    """Returns the string s, with underlining removed."""
    return s.replace('\x1f', '').replace('\x1F', '')

def stripFormatting(s):
    """Returns the string s, with all formatting removed."""
    # stripColor has to go first because of some strings, check the tests.
    s = stripColor(s)
    s = stripBold(s)
    s = stripReverse(s)
    s = stripUnderline(s)
    return s.replace('\x0f', '').replace('\x0F', '')

class FormatContext(object):
    def __init__(self):
        self.reset()

    def reset(self):
        self.fg = None
        self.bg = None
        self.bold = False
        self.reverse = False
        self.underline = False

    def start(self, s):
        """Given a string, starts all the formatters in this context."""
        if self.bold:
            s = '\x02' + s
        if self.reverse:
            s = '\x16' + s
        if self.underline:
            s = '\x1f' + s
        if self.fg is not None or self.bg is not None:
            s = mircColor(s, fg=self.fg, bg=self.bg)[:-1] # Remove \x03.
        return s

    def end(self, s):
        """Given a string, ends all the formatters in this context."""
        if self.bold or self.reverse or \
           self.fg or self.bg or self.underline:
            # Should we individually end formatters?
            s += '\x0f'
        return s

class FormatParser(object):
    def __init__(self, s):
        self.fd = sio(s)
        self.last = None

    def getChar(self):
        if self.last is not None:
            c = self.last
            self.last = None
            return c
        else:
            return self.fd.read(1)

    def ungetChar(self, c):
        self.last = c

    def parse(self):
        context = FormatContext()
        c = self.getChar()
        while c:
            if c == '\x02':
                context.bold = not context.bold
            elif c == '\x16':
                context.reverse = not context.reverse
            elif c == '\x1f':
                context.underline = not context.underline
            elif c == '\x0f':
                context.reset()
            elif c == '\x03':
                self.getColor(context)
            c = self.getChar()
        return context

    def getInt(self):
        i = 0
        setI = False
        c = self.getChar()
        while c.isdigit():
            j = i * 10
            j += int(c)
            if j >= 16:
                self.ungetChar(c)
                break
            else:
                setI = True
                i = j
                c = self.getChar()
        self.ungetChar(c)
        if setI:
            return i
        else:
            return None

    def getColor(self, context):
        context.fg = self.getInt()
        c = self.getChar()
        if c == ',':
            context.bg = self.getInt()
        else:
            self.ungetChar(c)

def wrap(s, length, break_on_hyphens = False, break_long_words = False):
    processed = []
    wrapper = textwrap.TextWrapper(width=length)
    wrapper.break_long_words = break_long_words
    wrapper.break_on_hyphens = break_on_hyphens
    chunks = wrapper.wrap(s)
    context = None
    for chunk in chunks:
        if context is not None:
            chunk = context.start(chunk)
        context = FormatParser(chunk).parse()
        processed.append(context.end(chunk))
    return processed

def isValidArgument(s):
    """Returns whether s is strictly a valid argument for an IRC message."""

    return '\r' not in s and '\n' not in s and '\x00' not in s

def safeArgument(s):
    """If s is unsafe for IRC, returns a safe version."""
    if sys.version_info[0] < 3 and isinstance(s, unicode):
        s = s.encode('utf-8')
    elif (sys.version_info[0] < 3 and not isinstance(s, basestring)) or \
            (sys.version_info[0] >= 3 and not isinstance(s, str)):
        debug('Got a non-string in safeArgument: %r', s)
        s = str(s)
    if isValidArgument(s):
        return s
    else:
        return repr(s)

def replyTo(msg):
    """Returns the appropriate target to send responses to msg."""
    if isChannel(msg.args[0]):
        return msg.args[0]
    else:
        return msg.nick

def dccIP(ip):
    """Converts an IP string to the DCC integer form."""
    assert utils.net.isIPV4(ip), \
           'argument must be a string ip in xxx.yyy.zzz.www format.'
    i = 0
    x = 256**3
    for quad in ip.split('.'):
        i += int(quad)*x
        x //= 256
    return i

def unDccIP(i):
    """Takes an integer DCC IP and return a normal string IP."""
    assert isinstance(i, (int, long)), '%r is not an number.' % i
    L = []
    while len(L) < 4:
        L.append(i % 256)
        i //= 256
    L.reverse()
    return '.'.join(map(str, L))

class IrcString(str):
    """This class does case-insensitive comparison and hashing of nicks."""
    def __new__(cls, s=''):
        x = super(IrcString, cls).__new__(cls, s)
        x.lowered = str(toLower(x))
        return x

    def __eq__(self, s):
        try:
            return toLower(s) == self.lowered
        except:
            return False

    def __ne__(self, s):
        return not (self == s)

    def __hash__(self):
        return hash(self.lowered)


class IrcDict(utils.InsensitivePreservingDict):
    """Subclass of dict to make key comparison IRC-case insensitive."""
    def key(self, s):
        if s is not None:
            s = toLower(s)
        return s

class CallableValueIrcDict(IrcDict):
    def __getitem__(self, k):
        v = super(IrcDict, self).__getitem__(k)
        if callable(v):
            v = v()
        return v

class IrcSet(utils.NormalizingSet):
    """A sets.Set using IrcStrings instead of regular strings."""
    def normalize(self, s):
        return IrcString(s)

    def __reduce__(self):
        return (self.__class__, (list(self),))


class FloodQueue(object):
    timeout = 0
    def __init__(self, timeout=None, queues=None):
        if timeout is not None:
            self.timeout = timeout
        if queues is None:
            queues = IrcDict()
        self.queues = queues

    def __repr__(self):
        return 'FloodQueue(timeout=%r, queues=%s)' % (self.timeout,
                                                      repr(self.queues))

    def key(self, msg):
        # This really ought to be configurable without subclassing, but for
        # now, it works.
        # used to be msg.user + '@' + msg.host but that was too easily abused.
        return msg.host

    def getTimeout(self):
        if callable(self.timeout):
            return self.timeout()
        else:
            return self.timeout

    def _getQueue(self, msg, insert=True):
        key = self.key(msg)
        try:
            return self.queues[key]
        except KeyError:
            if insert:
                # python--
                # instancemethod.__repr__ calls the instance.__repr__, which
                # means that our __repr__ calls self.queues.__repr__, which
                # calls structures.TimeoutQueue.__repr__, which calls
                # getTimeout.__repr__, which calls our __repr__, which calls...
                getTimeout = lambda : self.getTimeout()
                q = utils.structures.TimeoutQueue(getTimeout)
                self.queues[key] = q
                return q
            else:
                return None

    def enqueue(self, msg, what=None):
        if what is None:
            what = msg
        q = self._getQueue(msg)
        q.enqueue(what)

    def len(self, msg):
        q = self._getQueue(msg, insert=False)
        if q is not None:
            return len(q)
        else:
            return 0

    def has(self, msg, what=None):
        q = self._getQueue(msg, insert=False)
        if q is not None:
            if what is None:
                what = msg
            for elt in q:
                if elt == what:
                    return True
        return False


mircColors = IrcDict({
    'white': '0',
    'black': '1',
    'blue': '2',
    'green': '3',
    'red': '4',
    'brown': '5',
    'purple': '6',
    'orange': '7',
    'yellow': '8',
    'light green': '9',
    'teal': '10',
    'light blue': '11',
    'dark blue': '12',
    'pink': '13',
    'dark grey': '14',
    'light grey': '15',
    'dark gray': '14',
    'light gray': '15',
})

# We'll map integers to their string form so mircColor is simpler.
for (k, v) in mircColors.items():
    if k is not None: # Ignore empty string for None.
        sv = str(v)
        mircColors[sv] = sv

def standardSubstitute(irc, msg, text, env=None):
    """Do the standard set of substitutions on text, and return it"""
    if isChannel(msg.args[0]):
        channel = msg.args[0]
    else:
        channel = 'somewhere'
    def randInt():
        return str(random.randint(-1000, 1000))
    def randDate():
        t = pow(2,30)*random.random()+time.time()/4.0
        return time.ctime(t)
    def randNick():
        if channel != 'somewhere':
            L = list(irc.state.channels[channel].users)
            if len(L) > 1:
                n = msg.nick
                while n == msg.nick:
                    n = utils.iter.choice(L)
                return n
            else:
                return msg.nick
        else:
            return 'someone'
    ctime = time.strftime("%a %b %d %H:%M:%S %Y")
    localtime = time.localtime()
    gmtime = time.strftime("%a %b %d %H:%M:%S %Y", time.gmtime())
    vars = CallableValueIrcDict({
        'who': msg.nick,
        'nick': msg.nick,
        'user': msg.user,
        'host': msg.host,
        'channel': channel,
        'botnick': irc.nick,
        'now': ctime, 'ctime': ctime,
        'utc': gmtime, 'gmt': gmtime,
        'randnick': randNick, 'randomnick': randNick,
        'randdate': randDate, 'randomdate': randDate,
        'rand': randInt, 'randint': randInt, 'randomint': randInt,
        'today': time.strftime('%d %b %Y', localtime),
        'year': localtime[0],
        'month': localtime[1],
        'monthname': time.strftime('%b', localtime),
        'date': localtime[2],
        'day': time.strftime('%A', localtime),
        'h': localtime[3], 'hr': localtime[3], 'hour': localtime[3],
        'm': localtime[4], 'min': localtime[4], 'minute': localtime[4],
        's': localtime[5], 'sec': localtime[5], 'second': localtime[5],
        'tz': time.strftime('%Z', localtime),
        })
    if msg.reply_env:
        vars.update(msg.reply_env)
    if env is not None:
        vars.update(env)
    t = string.Template(text)
    t.idpattern = '[a-zA-Z][a-zA-Z0-9]*'
    return t.safe_substitute(vars)

if __name__ == '__main__':
    import sys, doctest
    doctest.testmod(sys.modules['__main__'])
# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = log
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import os
import sys
import time
import types
import atexit
import logging
import operator
import textwrap
import traceback

from . import ansi, conf, ircutils, registry, utils

deadlyExceptions = [KeyboardInterrupt, SystemExit]

###
# This is for testing, of course.  Mostly it just disables the firewall code
# so exceptions can propagate.
###
testing = False

class Formatter(logging.Formatter):
    _fmtConf = staticmethod(lambda : conf.supybot.log.format())
    def formatTime(self, record, datefmt=None):
        return timestamp(record.created)

    def formatException(self, exc_info):
        (E, e, tb) = exc_info
        for exn in deadlyExceptions:
            if issubclass(e.__class__, exn):
                raise
        return logging.Formatter.formatException(self, (E, e, tb))

    def format(self, record):
        self._fmt = self._fmtConf()
        if hasattr(self, '_style'): # Python 3
            self._style._fmt = self._fmtConf()
        return logging.Formatter.format(self, record)


class PluginFormatter(Formatter):
    _fmtConf = staticmethod(lambda : conf.supybot.log.plugins.format())


class Logger(logging.Logger):
    def exception(self, *args):
        (E, e, tb) = sys.exc_info()
        tbinfo = traceback.extract_tb(tb)
        path = '[%s]' % '|'.join(map(operator.itemgetter(2), tbinfo))
        eStrId = '%s:%s' % (E, path)
        eId = hex(hash(eStrId) & 0xFFFFF)
        logging.Logger.exception(self, *args)
        self.error('Exception id: %s', eId)
        self.debug('%s', utils.python.collect_extra_debug_data())
        # The traceback should be sufficient if we want it.
        # self.error('Exception string: %s', eStrId)

    def _log(self, level, msg, args, exc_info=None, extra=None):
        msg = format(msg, *args)
        logging.Logger._log(self, level, msg, (), exc_info=exc_info, 
                            extra=extra)


class StdoutStreamHandler(logging.StreamHandler):
    def format(self, record):
        s = logging.StreamHandler.format(self, record)
        if record.levelname != 'ERROR' and conf.supybot.log.stdout.wrap():
            # We check for ERROR there because otherwise, tracebacks (which are
            # already wrapped by Python itself) wrap oddly.
            if not isinstance(record.levelname, basestring):
                print(record)
                print(record.levelname)
                print(utils.stackTrace())
            prefixLen = len(record.levelname) + 1 # ' '
            s = textwrap.fill(s, width=78, subsequent_indent=' '*prefixLen)
            s.rstrip('\r\n')
        return s

    def emit(self, record):
        if conf.supybot.log.stdout() and not conf.daemonized:
            try:
                logging.StreamHandler.emit(self, record)
            except ValueError as e: # Raised if sys.stdout is closed.
                self.disable()
                error('Error logging to stdout.  Removing stdout handler.')
                exception('Uncaught exception in StdoutStreamHandler:')

    def disable(self):
        self.setLevel(sys.maxsize) # Just in case.
        _logger.removeHandler(self)
        logging._acquireLock()
        try:
            del logging._handlers[self]
        finally:
            logging._releaseLock()


class BetterFileHandler(logging.FileHandler):
    def emit(self, record):
        msg = self.format(record)
        if not hasattr(types, "UnicodeType"): #if no unicode support...
            self.stream.write(msg)
            self.stream.write(os.linesep)
        else:
            try:
                self.stream.write(msg)
                self.stream.write(os.linesep)
            except UnicodeError:
                self.stream.write(msg.encode("utf8"))
                self.stream.write(os.linesep)
        self.flush()


class ColorizedFormatter(Formatter):
    # This was necessary because these variables aren't defined until later.
    # The staticmethod is necessary because they get treated like methods.
    _fmtConf = staticmethod(lambda : conf.supybot.log.stdout.format())
    def formatException(self, exc_info):
        (E, e, tb) = exc_info
        if conf.supybot.log.stdout.colorized():
            return ''.join([ansi.RED,
                            Formatter.formatException(self, (E, e, tb)),
                            ansi.RESET])
        else:
            return Formatter.formatException(self, (E, e, tb))

    def format(self, record, *args, **kwargs):
        if conf.supybot.log.stdout.colorized():
            color = ''
            if record.levelno == logging.CRITICAL:
                color = ansi.WHITE + ansi.BOLD
            elif record.levelno == logging.ERROR:
                color = ansi.RED
            elif record.levelno == logging.WARNING:
                color = ansi.YELLOW
            if color:
                return ''.join([color,
                                Formatter.format(self, record, *args, **kwargs),
                                ansi.RESET])
            else:
                return Formatter.format(self, record, *args, **kwargs)
        else:
            return Formatter.format(self, record, *args, **kwargs)

conf.registerGlobalValue(conf.supybot.directories, 'log',
    conf.Directory('logs', """Determines what directory the bot will store its
    logfiles in."""))

_logDir = conf.supybot.directories.log()
if not os.path.exists(_logDir):
    os.mkdir(_logDir, 0755)

pluginLogDir = os.path.join(_logDir, 'plugins')

if not os.path.exists(pluginLogDir):
    os.mkdir(pluginLogDir, 0755)

try:
    messagesLogFilename = os.path.join(_logDir, 'messages.log')
    _handler = BetterFileHandler(messagesLogFilename)
except EnvironmentError as e:
    raise SystemExit('Error opening messages logfile (%s).  ' \
          'Generally, this is because you are running Supybot in a directory ' \
          'you don\'t have permissions to add files in, or you\'re running ' \
          'Supybot as a different user than you normal do.  The original ' \
          'error was: %s' % (messagesLogFilename, utils.gen.exnToString(e)))

# These are public.
formatter = Formatter('NEVER SEEN; IF YOU SEE THIS, FILE A BUG!')
pluginFormatter = PluginFormatter('NEVER SEEN; IF YOU SEE THIS, FILE A BUG!')

# These are not.
logging.setLoggerClass(Logger)
_logger = logging.getLogger('supybot')
_stdoutHandler = StdoutStreamHandler(sys.stdout)

class ValidLogLevel(registry.String):
    """Invalid log level."""
    handler = None
    minimumLevel = -1
    def set(self, s):
        s = s.upper()
        try:
            try:
                level = logging._levelNames[s]
            except AttributeError:
                level = logging._nameToLevel[s]
        except KeyError:
            try:
                level = int(s)
            except ValueError:
                self.error()
        if level < self.minimumLevel:
            self.error()
        if self.handler is not None:
            self.handler.setLevel(level)
        self.setValue(level)

    def __str__(self):
        # The str() is necessary here; apparently getLevelName returns an
        # integer on occasion.  logging--
        level = str(logging.getLevelName(self.value))
        if level.startswith('Level'):
            level = level.split()[-1]
        return level

class LogLevel(ValidLogLevel):
    """Invalid log level.  Value must be either DEBUG, INFO, WARNING,
    ERROR, or CRITICAL."""
    handler = _handler

class StdoutLogLevel(ValidLogLevel):
    """Invalid log level.  Value must be either DEBUG, INFO, WARNING,
    ERROR, or CRITICAL."""
    handler = _stdoutHandler

conf.registerGroup(conf.supybot, 'log')
conf.registerGlobalValue(conf.supybot.log, 'format',
    registry.String('%(levelname)s %(asctime)s %(name)s %(message)s',
    """Determines what the bot's logging format will be.  The relevant
    documentation on the available formattings is Python's documentation on
    its logging module."""))
conf.registerGlobalValue(conf.supybot.log, 'level',
    LogLevel(logging.INFO, """Determines what the minimum priority level logged
    to file will be.  Do note that this value does not affect the level logged
    to stdout; for that, you should set the value of supybot.log.stdout.level.
    Valid values are DEBUG, INFO, WARNING, ERROR, and CRITICAL, in order of
    increasing priority."""))
conf.registerGlobalValue(conf.supybot.log, 'timestampFormat',
    registry.String('%Y-%m-%dT%H:%M:%S', """Determines the format string for
    timestamps in logfiles.  Refer to the Python documentation for the time
    module to see what formats are accepted. If you set this variable to the
    empty string, times will be logged in a simple seconds-since-epoch
    format."""))

class BooleanRequiredFalseOnWindows(registry.Boolean):
    """Value cannot be true on Windows"""
    def set(self, s):
        registry.Boolean.set(self, s)
        if self.value and os.name == 'nt':
            self.error()

conf.registerGlobalValue(conf.supybot.log, 'stdout',
    registry.Boolean(True, """Determines whether the bot will log to
    stdout."""))
conf.registerGlobalValue(conf.supybot.log.stdout, 'colorized',
    BooleanRequiredFalseOnWindows(False, """Determines whether the bot's logs
    to stdout (if enabled) will be colorized with ANSI color."""))
conf.registerGlobalValue(conf.supybot.log.stdout, 'wrap',
    registry.Boolean(True, """Determines whether the bot will wrap its logs
    when they're output to stdout."""))
conf.registerGlobalValue(conf.supybot.log.stdout, 'format',
    registry.String('%(levelname)s %(asctime)s %(message)s',
    """Determines what the bot's logging format will be.  The relevant
    documentation on the available formattings is Python's documentation on
    its logging module."""))
conf.registerGlobalValue(conf.supybot.log.stdout, 'level',
    StdoutLogLevel(logging.INFO, """Determines what the minimum priority level
    logged will be.  Valid values are DEBUG, INFO, WARNING, ERROR, and
    CRITICAL, in order of increasing priority."""))

conf.registerGroup(conf.supybot.log, 'plugins')
conf.registerGlobalValue(conf.supybot.log.plugins, 'individualLogfiles',
    registry.Boolean(False, """Determines whether the bot will separate plugin
    logs into their own individual logfiles."""))
conf.registerGlobalValue(conf.supybot.log.plugins, 'format',
    registry.String('%(levelname)s %(asctime)s %(message)s',
    """Determines what the bot's logging format will be.  The relevant
    documentation on the available formattings is Python's documentation on
    its logging module."""))


# These just make things easier.
debug = _logger.debug
info = _logger.info
warning = _logger.warning
error = _logger.error
critical = _logger.critical
exception = _logger.exception

# These were just begging to be replaced.
registry.error = error
registry.exception = exception

setLevel = _logger.setLevel

atexit.register(logging.shutdown)

# ircutils will work without this, but it's useful.
ircutils.debug = debug

def getPluginLogger(name):
    if not conf.supybot.log.plugins.individualLogfiles():
        return _logger
    log = logging.getLogger('supybot.plugins.%s' % name)
    if not log.handlers:
        filename = os.path.join(pluginLogDir, '%s.log' % name)
        handler = BetterFileHandler(filename)
        handler.setLevel(-1)
        handler.setFormatter(pluginFormatter)
        log.addHandler(handler)
    if name in sys.modules:
        log.info('Starting log for %s.', name)
    return log

def timestamp(when=None):
    if when is None:
        when = time.time()
    format = conf.supybot.log.timestampFormat()
    t = time.localtime(when)
    if format:
        return time.strftime(format, t)
    else:
        return str(int(time.mktime(t)))

def firewall(f, errorHandler=None):
    def logException(self, s=None):
        if s is None:
            s = 'Uncaught exception'
        if hasattr(self, 'log'):
            logging_function = self.log.exception
        else:
            logging_function = exception
        logging_function('%s in %s.%s:', s, self.__class__.__name__, f.__name__)
    def m(self, *args, **kwargs):
        try:
            return f(self, *args, **kwargs)
        except Exception as e:
            if testing:
                raise
            logException(self)
            if errorHandler is not None:
                try:
                    return errorHandler(self, *args, **kwargs)
                except Exception as e:
                    logException(self, 'Uncaught exception in errorHandler')
    m = utils.python.changeFunctionName(m, f.__name__, f.__doc__)
    return m

class MetaFirewall(type):
    def __new__(cls, name, bases, classdict):
        firewalled = {}
        for base in bases:
            if hasattr(base, '__firewalled__'):
                cls.updateFirewalled(firewalled, base.__firewalled__)
        cls.updateFirewalled(firewalled, classdict.get('__firewalled__', []))
        for (attr, errorHandler) in firewalled.iteritems():
            if attr in classdict:
                classdict[attr] = firewall(classdict[attr], errorHandler)
        return super(MetaFirewall, cls).__new__(cls, name, bases, classdict)

    def getErrorHandler(cls, dictOrTuple, name):
        if isinstance(dictOrTuple, dict):
            return dictOrTuple[name]
        else:
            return None
    getErrorHandler = classmethod(getErrorHandler)

    def updateFirewalled(cls, firewalled, __firewalled__):
        for attr in __firewalled__:
            firewalled[attr] = cls.getErrorHandler(__firewalled__, attr)
    updateFirewalled = classmethod(updateFirewalled)


class PluginLogFilter(logging.Filter):
    def filter(self, record):
        if conf.supybot.log.plugins.individualLogfiles():
            if record.name.startswith('supybot.plugins'):
                return False
        return True

_handler.setFormatter(formatter)
_handler.addFilter(PluginLogFilter())

_handler.setLevel(conf.supybot.log.level())
_logger.addHandler(_handler)
_logger.setLevel(-1)

_stdoutFormatter = ColorizedFormatter('IF YOU SEE THIS, FILE A BUG!')
_stdoutHandler.setFormatter(_stdoutFormatter)
_stdoutHandler.setLevel(conf.supybot.log.stdout.level())
if not conf.daemonized:
    _logger.addHandler(_stdoutHandler)


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:


########NEW FILE########
__FILENAME__ = minisix
###
# Copyright (c) 2014, Valentin Lorentz
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

"""Restricted equivalent to six."""

import sys

if sys.version_info[0] >= 3:
    intern = sys.intern
else:
    if isinstance(__builtins__, dict):
        intern = __builtins__['intern']
    else:
        intern = __builtins__.intern

########NEW FILE########
__FILENAME__ = plugin
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import os
import sys
import imp
import os.path
import linecache
import re

from . import callbacks, conf, log, registry

installDir = os.path.dirname(sys.modules[__name__].__file__)
_pluginsDir = os.path.join(installDir, 'plugins')

class Deprecated(ImportError):
    pass

def loadPluginModule(name, ignoreDeprecation=False):
    """Loads (and returns) the module for the plugin with the given name."""
    files = []
    pluginDirs = conf.supybot.directories.plugins()[:]
    pluginDirs.append(_pluginsDir)
    for dir in pluginDirs:
        try:
            files.extend(os.listdir(dir))
        except EnvironmentError: # OSError, IOError superclass.
            log.warning('Invalid plugin directory: %s; removing.', dir)
            conf.supybot.directories.plugins().remove(dir)
    if name not in files:
        search = lambda x: re.search(r'(?i)^%s$' % (name,), x)
        matched_names = list(filter(search, files))
        if len(matched_names) == 1:
            name = matched_names[0]
        else:
            raise ImportError(name)
    moduleInfo = imp.find_module(name, pluginDirs)
    try:
        module = imp.load_module(name, *moduleInfo)
    except:
        sys.modules.pop(name, None)
        keys = sys.modules.keys()
        for key in keys:
            if key.startswith(name + '.'):
                sys.modules.pop(key)
        raise
    if 'deprecated' in module.__dict__ and module.deprecated:
        if ignoreDeprecation:
            log.warning('Deprecated plugin loaded: %s', name)
        else:
            raise Deprecated(format('Attempted to load deprecated plugin %s',
                                     name))
    if module.__name__ in sys.modules:
        sys.modules[module.__name__] = module
    linecache.checkcache()
    return module

def loadPluginClass(irc, module, register=None):
    """Loads the plugin Class from the given module into the given Irc."""
    try:
        cb = module.Class(irc)
    except TypeError as e:
        s = str(e)
        if '2 given' in s and '__init__' in s:
            raise callbacks.Error('In our switch from CVS to Darcs (after 0.80.1), we ' \
                  'changed the __init__ for callbacks.Privmsg* to also ' \
                  'accept an irc argument.  This plugin (%s) is overriding ' \
                  'its __init__ method and needs to update its prototype ' \
                  'to be \'def __init__(self, irc):\' as well as passing ' \
                  'that irc object on to any calls to the plugin\'s ' \
                  'parent\'s __init__. Another possible cause: the code in ' \
                  'your __init__ raised a TypeError when calling a function ' \
                  'or creating an object, which doesn\'t take 2 arguments.' %\
                  module.__name__)
        else:
            raise
    except AttributeError as e:
        if 'Class' in str(e):
            raise callbacks.Error('This plugin module doesn\'t have a "Class" ' \
                  'attribute to specify which plugin should be ' \
                  'instantiated.  If you didn\'t write this ' \
                  'plugin, but received it with Supybot, file ' \
                  'a bug with us about this error.')
        else:
            raise
    cb.classModule = module
    plugin = cb.name()
    public = True
    if hasattr(cb, 'public'):
        public = cb.public
    conf.registerPlugin(plugin, register, public)
    assert not irc.getCallback(plugin), \
           'There is already a %r plugin registered.' % plugin
    try:
        renames = []#XXX registerRename(plugin)()
        if renames:
            for command in renames:
                v = registerRename(plugin, command)
                newName = v()
                assert newName
                renameCommand(cb, command, newName)
        else:
            conf.supybot.commands.renames.unregister(plugin)
    except registry.NonExistentRegistryEntry as e:
        pass # The plugin isn't there.
    irc.addCallback(cb)
    return cb

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = questions
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

"""Handles interactive questions; useful for wizards and whatnot."""

from __future__ import print_function

import sys
import textwrap
from getpass import getpass as getPass

from . import ansi, utils
from supybot.i18n import PluginInternationalization, internationalizeDocstring
_ = PluginInternationalization()

useBold = False

def output(s, unformatted=True, fd=sys.stdout):
    if unformatted:
        s = textwrap.fill(utils.str.normalizeWhitespace(s), width=65)
    print(s, file=fd)
    print('', file=fd)

def expect(prompt, possibilities, recursed=False, default=None,
           acceptEmpty=False, fd=sys.stdout):
    """Prompt the user with prompt, allow them to choose from possibilities.

    If possibilities is empty, allow anything.
    """
    prompt = utils.str.normalizeWhitespace(prompt)
    originalPrompt = prompt
    if recursed:
        output(_('Sorry, that response was not an option.'))
    if useBold:
        choices = '[%s%%s%s]' % (ansi.RESET, ansi.BOLD)
    else:
        choices = '[%s]'
    if possibilities:
        prompt = '%s %s' % (originalPrompt, choices % '/'.join(possibilities))
        if len(prompt) > 70:
            prompt = '%s %s' % (originalPrompt, choices % '/ '.join(possibilities))
    if default is not None:
        if useBold:
            prompt = '%s %s(default: %s)' % (prompt, ansi.RESET, default)
        else:
            prompt = '%s (default: %s)' % (prompt, default)
    prompt = textwrap.fill(prompt)
    prompt = prompt.replace('/ ', '/')
    prompt = prompt.strip() + ' '
    if useBold:
        prompt += ansi.RESET
        print(ansi.BOLD, end=' ', file=fd)
    if sys.version_info[0] >= 3:
        s = input(prompt)
    else:
        s = raw_input(prompt)
    s = s.strip()
    print(file=fd)
    if possibilities:
        if s in possibilities:
            return s
        elif not s and default is not None:
            return default
        elif not s and acceptEmpty:
            return s
        else:
            return expect(originalPrompt, possibilities, recursed=True,
                          default=default)
    else:
        if not s and default is not None:
            return default
        return s.strip()

def anything(prompt):
    """Allow anything from the user."""
    return expect(prompt, [])

def something(prompt, default=None):
    """Allow anything *except* nothing from the user."""
    s = expect(prompt, [], default=default)
    while not s:
        output(_('Sorry, you must enter a value.'))
        s = expect(prompt, [], default=default)
    return s

def yn(prompt, default=None):
    """Allow only 'y' or 'n' from the user."""
    if default is not None:
        if default:
            default = 'y'
        else:
            default = 'n'
    s = expect(prompt, ['y', 'n'], default=default)
    if s == 'y':
        return True
    else:
        return False

def getpass(prompt=None, secondPrompt=None):
    """Prompt the user for a password."""
    if prompt is None:
        prompt = _('Enter password: ')
    if secondPrompt is None:
        secondPrompt = _('Re-enter password: ')
    password = ''
    secondPassword = ' ' # Note that this should be different than password.
    assert prompt
    if not prompt[-1].isspace():
        prompt += ' '
    while True:
        if useBold:
            prompt = ansi.BOLD + prompt + ansi.RESET
            secondPrompt = ansi.BOLD + secondPrompt + ansi.RESET
        password = getPass(prompt)
        secondPassword = getPass(secondPrompt)
        if password != secondPassword:
            output(_('Passwords don\'t match.'))
        else:
            break
    print('')
    return password


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = registry
###
# Copyright (c) 2004-2005, Jeremiah Fincher
# Copyright (c) 2009-2010, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import re
import os
import sys
import time
import json
import codecs
import string
import textwrap

from . import utils, i18n
_ = i18n.PluginInternationalization()

def error(s):
   """Replace me with something better from another module!"""
   print('***', s)

def exception(s):
    """Ditto!"""
    print('***', s, 'A bad exception.')

class RegistryException(Exception):
    pass

class InvalidRegistryFile(RegistryException):
    pass

class InvalidRegistryName(RegistryException):
    pass

class InvalidRegistryValue(RegistryException):
    pass

class NonExistentRegistryEntry(RegistryException, AttributeError):
    # If we use hasattr() on a configuration group/value, Python 3 calls
    # __getattr__ and looks for an AttributeError, so __getattr__ has to
    # raise an AttributeError if a registry entry does not exist.
    pass

ENCODING = 'string_escape' if sys.version_info[0] < 3 else 'unicode_escape'
decoder = codecs.getdecoder(ENCODING)
encoder = codecs.getencoder(ENCODING)

_cache = utils.InsensitivePreservingDict()
_lastModified = 0
def open_registry(filename, clear=False):
    """Initializes the module by loading the registry file into memory."""
    global _lastModified
    if clear:
        _cache.clear()
    _fd = open(filename)
    fd = utils.file.nonCommentNonEmptyLines(_fd)
    acc = ''
    slashEnd = re.compile(r'\\*$')
    for line in fd:
        line = line.rstrip('\r\n')
        # XXX There should be some way to determine whether or not we're
        #     starting a new variable or not.  As it is, if there's a backslash
        #     at the end of every line in a variable, it won't be read, and
        #     worse, the error will pass silently.
        #
        # If the line ends in an odd number of backslashes, then there is a
        # line-continutation.
        m = slashEnd.search(line)
        if m and len(m.group(0)) % 2:
            acc += line[:-1]
            continue
        else:
            acc += line
        try:
            (key, value) = re.split(r'(?<!\\):', acc, 1)
            key = key.strip()
            value = value.strip()
            value = decoder(value)[0]
            acc = ''
        except ValueError:
            raise InvalidRegistryFile('Error unpacking line %r' % acc)
        _cache[key] = value
    _lastModified = time.time()
    _fd.close()

def close(registry, filename, private=True):
    first = True
    fd = utils.file.AtomicFile(filename)
    for (name, value) in registry.getValues(getChildren=True):
        help = value.help()
        if help:
            lines = textwrap.wrap(value._help)
            for (i, line) in enumerate(lines):
                lines[i] = '# %s\n' % line
            lines.insert(0, '###\n')
            if first:
                first = False
            else:
                lines.insert(0, '\n')
            if hasattr(value, 'value'):
                if value._showDefault:
                    lines.append('#\n')
                    try:
                        x = value.__class__(value._default, value._help)
                    except Exception as e:
                        exception('Exception instantiating default for %s:' %
                                  value._name)
                    try:
                        lines.append('# Default value: %s\n' % x)
                    except Exception as e:
                        exception('Exception printing default value of %s:' %
                                  value._name)
            lines.append('###\n')
            fd.writelines(lines)
        if hasattr(value, 'value'): # This lets us print help for non-values.
            try:
                if private or not value._private:
                    s = value.serialize()
                else:
                    s = 'CENSORED'
                fd.write('%s: %s\n' % (name, s))
            except Exception as e:
                exception('Exception printing value:')
    fd.close()

def isValidRegistryName(name):
    # Now we can have . and : in names.  I'm still gonna call shenanigans on
    # anyone who tries to have spaces (though technically I can't see any
    # reason why it wouldn't work).  We also reserve all names starting with
    # underscores for internal use.
    return len(name.split()) == 1 and not name.startswith('_')

def escape(name):
    name = encoder(name)[0].decode()
    name = name.replace(':', '\\:')
    name = name.replace('.', '\\.')
    return name

def unescape(name):
    name = name.replace('\\.', '.')
    name = name.replace('\\:', ':')
    name = decoder(name.encode())[0]
    return name

_splitRe = re.compile(r'(?<!\\)\.')
def split(name):
    return list(map(unescape, _splitRe.split(name)))

def join(names):
    return '.'.join(map(escape, names))

class Group(object):
    """A group; it doesn't hold a value unless handled by a subclass."""
    def __init__(self, help='', supplyDefault=False,
                 orderAlphabetically=False, private=False):
        self._help = utils.str.normalizeWhitespace(help)
        self._name = 'unset'
        self._added = []
        self._children = utils.InsensitivePreservingDict()
        self._lastModified = 0
        self._private = private
        self._supplyDefault = supplyDefault
        self._orderAlphabetically = orderAlphabetically
        OriginalClass = self.__class__
        class X(OriginalClass):
            """This class exists to differentiate those values that have
            been changed from their default from those that haven't."""
            def set(self, *args):
                self.__class__ = OriginalClass
                self.set(*args)
            def setValue(self, *args):
                self.__class__ = OriginalClass
                self.setValue(*args)
        self.X = X

    def __call__(self):
        raise ValueError('Groups have no value.')

    def __nonExistentEntry(self, attr):
        s = '%r is not a valid entry in %r' % (attr, self._name)
        raise NonExistentRegistryEntry(s)

    def __makeChild(self, attr, s):
        v = self.__class__(self._default, self._help)
        v.set(s)
        v.__class__ = self.X
        v._supplyDefault = False
        v._help = '' # Clear this so it doesn't print a bazillion times.
        self.register(attr, v)
        return v

    def __getattr__(self, attr):
        if attr in self._children:
            return self._children[attr]
        elif self._supplyDefault:
            return self.__makeChild(attr, str(self))
        else:
            self.__nonExistentEntry(attr)

    def help(self):
        return i18n.PluginInternationalization().__call__(self._help)

    def get(self, attr):
        # Not getattr(self, attr) because some nodes might have groups that
        # are named the same as their methods.
        return self.__getattr__(attr)

    def setName(self, name):
        #print '***', name
        self._name = name
        if name in _cache and self._lastModified < _lastModified:
            #print '***>', _cache[name]
            self.set(_cache[name])
        if self._supplyDefault:
            for (k, v) in _cache.iteritems():
                if k.startswith(self._name):
                    rest = k[len(self._name)+1:] # +1 is for .
                    parts = split(rest)
                    if len(parts) == 1 and parts[0] == name:
                        try:
                            self.__makeChild(name, v)
                        except InvalidRegistryValue:
                            # It's probably supposed to be registered later.
                            pass

    def register(self, name, node=None):
        if not isValidRegistryName(name):
            raise InvalidRegistryName(name)
        if node is None:
            node = Group(private=self._private)
        else:
            node._private = node._private or self._private
        # We tried in any number of horrible ways to make it so that
        # re-registering something would work.  It doesn't, plain and simple.
        # For the longest time, we had an "Is this right?" comment here, but
        # from experience, we now know that it most definitely *is* right.
        if name not in self._children:
            self._children[name] = node
            self._added.append(name)
            names = split(self._name)
            names.append(name)
            fullname = join(names)
            node.setName(fullname)
        else:
            # We do this in order to reload the help, if it changed.
            if node._help != '' and node._help != self._children[name]._help:
                self._children[name]._help = node._help
            # We do this so the return value from here is at least useful;
            # otherwise, we're just returning a useless, unattached node
            # that's simply a waste of space.
            node = self._children[name]
        return node

    def unregister(self, name):
        try:
            node = self._children[name]
            del self._children[name]
            # We do this because we need to remove case-insensitively.
            name = name.lower()
            for elt in reversed(self._added):
                if elt.lower() == name:
                    self._added.remove(elt)
            if node._name in _cache:
                del _cache[node._name]
            return node
        except KeyError:
            self.__nonExistentEntry(name)

    def rename(self, old, new):
        node = self.unregister(old)
        self.register(new, node)

    def getValues(self, getChildren=False, fullNames=True):
        L = []
        if self._orderAlphabetically:
            self._added.sort()
        for name in self._added:
            node = self._children[name]
            if hasattr(node, 'value') or hasattr(node, 'help'):
                if node.__class__ is not self.X:
                    L.append((node._name, node))
            if getChildren:
                L.extend(node.getValues(getChildren, fullNames))
        if not fullNames:
            L = [(split(s)[-1], node) for (s, node) in L]
        return L

class _NoValueGiven:
    # Special value for Value.error()
    pass

class Value(Group):
    """Invalid registry value.  If you're getting this message, report it,
    because we forgot to put a proper help string here."""
    def __init__(self, default, help, setDefault=True,
                 showDefault=True, **kwargs):
        self.__parent = super(Value, self)
        self.__parent.__init__(help, **kwargs)
        self._default = default
        self._showDefault = showDefault
        self._help = utils.str.normalizeWhitespace(help.strip())
        self._callbacks = []
        if setDefault:
            self.setValue(default)

    def error(self, value=_NoValueGiven):
        if hasattr(self, 'errormsg') and value is not _NoValueGiven:
            try:
                s = self.errormsg % value
            except TypeError:
                s = self.errormsg
        elif self.__doc__:
            s = self.__doc__
        else:
            s = """%s has no docstring.  If you're getting this message,
            report it, because we forgot to put a proper help string here."""%\
            self._name
        e = InvalidRegistryValue(utils.str.normalizeWhitespace(s))
        e.value = self
        raise e

    def setName(self, *args):
        if self._name == 'unset':
            self._lastModified = 0
        self.__parent.setName(*args)
        self._lastModified = time.time()

    def set(self, s):
        """Override this with a function to convert a string to whatever type
        you want, and call self.setValue to set the value."""
        self.setValue(s)

    def setValue(self, v):
        """Check conditions on the actual value type here.  I.e., if you're a
        IntegerLessThanOneHundred (all your values must be integers less than
        100) convert to an integer in set() and check that the integer is less
        than 100 in this method.  You *must* call this parent method in your
        own setValue."""
        self._lastModified = time.time()
        self.value = v
        if self._supplyDefault:
            for (name, v) in self._children.items():
                if v.__class__ is self.X:
                    self.unregister(name)
        # We call the callback once everything is clean
        for callback, args, kwargs in self._callbacks:
            callback(*args, **kwargs)

    def context(self, value):
        """Return a context manager object, which sets this variable to a
        temporary value, and set the previous value back when exiting the
        context."""
        class Context:
            def __enter__(self2):
                self2._old_value = self.value
                self.setValue(value)
            def __exit__(self2, exc_type, exc_value, traceback):
                self.setValue(self2._old_value)
        return Context()

    def addCallback(self, callback, *args, **kwargs):
        """Add a callback to the list. A callback is a function that will be
        called when the value is changed. You can give this function as many
        extra arguments as you wish, they will be passed to the callback."""
        self._callbacks.append((callback, args, kwargs))

    def removeCallback(self, callback):
        """Remove all occurences of this callbacks from the callback list."""
        self._callbacks = [x for x in self._callbacks if x[0] is not callback]

    def __str__(self):
        return repr(self())

    def serialize(self):
        return encoder(str(self))[0].decode()

    # We tried many, *many* different syntactic methods here, and this one was
    # simply the best -- not very intrusive, easily overridden by subclasses,
    # etc.
    def __call__(self):
        if _lastModified > self._lastModified:
            if self._name in _cache:
                self.set(_cache[self._name])
        return self.value

class Boolean(Value):
    """Value must be either True or False (or On or Off)."""
    errormsg = _('Value must be either True or False (or On or Off), not %r.')
    def set(self, s):
        try:
            v = utils.str.toBool(s)
        except ValueError:
            if s.strip().lower() == 'toggle':
                v = not self.value
            else:
                self.error(s)
        self.setValue(v)

    def setValue(self, v):
        super(Boolean, self).setValue(bool(v))

class Integer(Value):
    """Value must be an integer."""
    errormsg = _('Value must be an integer, not %r.')
    def set(self, s):
        try:
            self.setValue(int(s))
        except ValueError:
            self.error(s)

class NonNegativeInteger(Integer):
    """Value must be a non-negative integer."""
    errormsg = _('Value must be a non-negative integer, not %r.')
    def setValue(self, v):
        if v < 0:
            self.error(v)
        super(NonNegativeInteger, self).setValue(v)

class PositiveInteger(NonNegativeInteger):
    """Value must be positive (non-zero) integer."""
    errormsg = _('Value must be positive (non-zero) integer, not %r.')
    def setValue(self, v):
        if not v:
            self.error(v)
        super(PositiveInteger, self).setValue(v)

class Float(Value):
    """Value must be a floating-point number."""
    errormsg = _('Value must be a floating-point number, not %r.')
    def set(self, s):
        try:
            self.setValue(float(s))
        except ValueError:
            self.error(s)

    def setValue(self, v):
        try:
            super(Float, self).setValue(float(v))
        except ValueError:
            self.error(v)

class PositiveFloat(Float):
    """Value must be a floating-point number greater than zero."""
    errormsg = _('Value must be a floating-point number greater than zero, '
            'not %r.')
    def setValue(self, v):
        if v <= 0:
            self.error(v)
        else:
            super(PositiveFloat, self).setValue(v)

class Probability(Float):
    """Value must be a floating point number in the range [0, 1]."""
    errormsg = _('Value must be a floating point number in the range [0, 1], '
            'not %r.')
    def __init__(self, *args, **kwargs):
        self.__parent = super(Probability, self)
        self.__parent.__init__(*args, **kwargs)

    def setValue(self, v):
        if 0 <= v <= 1:
            self.__parent.setValue(v)
        else:
            self.error(v)

class String(Value):
    """Value is not a valid Python string."""
    errormsg = _('Value is not a valid Python string, not %r.')
    def set(self, s):
        v = s
        if not v:
            v = '""'
        elif v[0] != v[-1] or v[0] not in '\'"':
            v = repr(v)
        try:
            v = utils.safeEval(v)
            if not isinstance(v, basestring):
                raise ValueError
            self.setValue(v)
        except ValueError: # This catches utils.safeEval(s) errors too.
            self.error(s)

    _printable = string.printable[:-4]
    def _needsQuoting(self, s):
        return any([x not in self._printable for x in s]) and s.strip() != s

    def __str__(self):
        s = self.value
        if self._needsQuoting(s):
            s = repr(s)
        return s

class OnlySomeStrings(String):
    validStrings = ()
    def __init__(self, *args, **kwargs):
        assert self.validStrings, 'There must be some valid strings.  ' \
                                  'This is a bug.'
        self.__parent = super(OnlySomeStrings, self)
        self.__parent.__init__(*args, **kwargs)
        self.__doc__ = format(_('Valid values include %L.'),
                              list(map(repr, self.validStrings)))
        self.errormsg = format(_('Valid values include %L, not %%r.'),
                              list(map(repr, self.validStrings)))

    def help(self):
        strings = [s for s in self.validStrings if s]
        return format('%s  Valid strings: %L.', self._help, strings)

    def normalize(self, s):
        lowered = s.lower()
        L = list(map(str.lower, self.validStrings))
        try:
            i = L.index(lowered)
        except ValueError:
            return s # This is handled in setValue.
        return self.validStrings[i]

    def setValue(self, s):
        v = self.normalize(s)
        if s in self.validStrings:
            self.__parent.setValue(v)
        else:
            self.error(v)

class NormalizedString(String):
    def __init__(self, default, *args, **kwargs):
        default = self.normalize(default)
        self.__parent = super(NormalizedString, self)
        self.__parent.__init__(default, *args, **kwargs)
        self._showDefault = False

    def normalize(self, s):
        return utils.str.normalizeWhitespace(s.strip())

    def set(self, s):
        s = self.normalize(s)
        self.__parent.set(s)

    def setValue(self, s):
        s = self.normalize(s)
        self.__parent.setValue(s)

    def serialize(self):
        s = self.__parent.serialize()
        prefixLen = len(self._name) + 2
        lines = textwrap.wrap(s, width=76-prefixLen)
        last = len(lines)-1
        for (i, line) in enumerate(lines):
            if i != 0:
                line = ' '*prefixLen + line
            if i != last:
                line += '\\'
            lines[i] = line
        ret = os.linesep.join(lines)
        return ret

class StringSurroundedBySpaces(String):
    def setValue(self, v):
        if v and v.lstrip() == v:
            v= ' ' + v
        if v.rstrip() == v:
            v += ' '
        super(StringSurroundedBySpaces, self).setValue(v)

class StringWithSpaceOnRight(String):
    def setValue(self, v):
        if v and v.rstrip() == v:
            v += ' '
        super(StringWithSpaceOnRight, self).setValue(v)

class Regexp(Value):
    """Value must be a valid regular expression."""
    errormsg = _('Value must be a valid regular expression, not %r.')
    def __init__(self, *args, **kwargs):
        kwargs['setDefault'] = False
        self.sr = ''
        self.value = None
        self.__parent = super(Regexp, self)
        self.__parent.__init__(*args, **kwargs)

    def error(self, e):
        s = 'Value must be a regexp of the form m/.../ or /.../. %s' % e
        e = InvalidRegistryValue(s)
        e.value = self
        raise e

    def set(self, s):
        try:
            if s:
                self.setValue(utils.str.perlReToPythonRe(s), sr=s)
            else:
                self.setValue(None)
        except ValueError as e:
            self.error(e)

    def setValue(self, v, sr=None):
        if v is None:
            self.sr = ''
            self.__parent.setValue(None)
        elif sr is not None:
            self.sr = sr
            self.__parent.setValue(v)
        else:
            raise InvalidRegistryValue('Can\'t setValue a regexp, there would be an inconsistency '\
                  'between the regexp and the recorded string value.')

    def __str__(self):
        self() # Gotta update if we've been reloaded.
        return self.sr

class SeparatedListOf(Value):
    List = list
    Value = Value
    sorted = False
    def splitter(self, s):
        """Override this with a function that takes a string and returns a list
        of strings."""
        raise NotImplementedError

    def joiner(self, L):
        """Override this to join the internal list for output."""
        raise NotImplementedError

    def set(self, s):
        L = self.splitter(s)
        for (i, s) in enumerate(L):
            v = self.Value(s, '')
            L[i] = v()
        self.setValue(L)

    def setValue(self, v):
        super(SeparatedListOf, self).setValue(self.List(v))

    def __str__(self):
        values = self()
        if self.sorted:
            values = sorted(values)
        if values:
            return self.joiner(values)
        else:
            # We must return *something* here, otherwise down along the road we
            # can run into issues showing users the value if they've disabled
            # nick prefixes in any of the numerous ways possible.  Since the
            # config parser doesn't care about this space, we'll use it :)
            return ' '

class SpaceSeparatedListOf(SeparatedListOf):
    def splitter(self, s):
        return s.split()
    joiner = ' '.join

class SpaceSeparatedListOfStrings(SpaceSeparatedListOf):
    Value = String

class SpaceSeparatedSetOfStrings(SpaceSeparatedListOfStrings):
    List = set

class CommaSeparatedListOfStrings(SeparatedListOf):
    Value = String
    def splitter(self, s):
        return re.split(r'\s*,\s*', s)
    joiner = ', '.join

class TemplatedString(String):
    requiredTemplates = []
    def __init__(self, *args, **kwargs):
        assert self.requiredTemplates, \
               'There must be some templates.  This is a bug.'
        self.__parent = super(String, self)
        self.__parent.__init__(*args, **kwargs)

    def setValue(self, v):
        def hasTemplate(s):
            return re.search(r'\$%s\b|\${%s}' % (s, s), v) is not None
        if utils.iter.all(hasTemplate, self.requiredTemplates):
            self.__parent.setValue(v)
        else:
            self.error(v)

class Json(String):
    # Json-serializable data
    def set(self, v):
        self.setValue(json.loads(v))
    def setValue(self, v):
        super(Json, self).setValue(json.dumps(v))
    def __call__(self):
        return json.loads(super(Json, self).__call__())

    class _Context:
        def __init__(self, var):
            self._var = var
        def __enter__(self):
            self._dict = self._var()
            return self._dict
        def __exit__(self, *args):
            self._var.setValue(self._dict)

    def editable(self):
        """Return an editable dict usable within a 'with' statement and
        committed to the configuration variable at the end."""
        return self._Context(self)

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = schedule
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

"""
Schedule plugin with a subclass of drivers.IrcDriver in order to be run as a
Supybot driver.
"""

from __future__ import with_statement

import time
import heapq
import functools
from threading import Lock

from . import drivers, log, world

class mytuple(tuple):
    def __cmp__(self, other):
        return cmp(self[0], other[0])
    def __le__(self, other):
        return self[0] <= other[0]
    def __lt__(self, other):
        return self[0] < other[0]
    def __gt__(self, other):
        return self[0] > other[0]
    def __ge__(self, other):
        return self[0] >= other[0]

class Schedule(drivers.IrcDriver):
    """An IrcDriver to handling scheduling of events.

    Events, in this case, are functions accepting no arguments.
    """
    def __init__(self):
        drivers.IrcDriver.__init__(self)
        self.schedule = []
        self.events = {}
        self.counter = 0
        self.lock = Lock()

    def reset(self):
        with self.lock:
            self.events.clear()
            self.schedule[:] = []
        # We don't reset the counter here because if someone has held an id of
        # one of the nuked events, we don't want them removing new events with
        # his/her old id.

    def name(self):
        return 'Schedule'

    def addEvent(self, f, t, name=None, args=[], kwargs={}):
        """Schedules an event f to run at time t.

        name must be hashable and not an int.
        """
        if name is None:
            name = self.counter
            self.counter += 1
        assert name not in self.events, \
               'An event with the same name has already been scheduled.'
        with self.lock:
            self.events[name] = f
            heapq.heappush(self.schedule, mytuple((t, name, args, kwargs)))
        return name

    def removeEvent(self, name):
        """Removes the event with the given name from the schedule."""
        f = self.events.pop(name)
        # We must heapify here because the heap property may not be preserved
        # by the above list comprehension.  We could, conceivably, just mark
        # the elements of the heap as removed and ignore them when we heappop,
        # but that would only save a constant factor (we're already linear for
        # the listcomp) so I'm not worried about it right now.
        with self.lock:
            self.schedule = [x for x in self.schedule if x[1] != name]
            heapq.heapify(self.schedule)
        return f

    def rescheduleEvent(self, name, t):
        f = self.removeEvent(name)
        self.addEvent(f, t, name=name)

    def addPeriodicEvent(self, f, t, name=None, now=True, args=[], kwargs={},
            count=None):
        """Adds a periodic event that is called every t seconds."""
        def wrapper(count):
            try:
                f(*args, **kwargs)
            finally:
                # Even if it raises an exception, let's schedule it.
                if count[0] is not None:
                    count[0] -= 1
                if count[0] is None or count[0] > 0:
                    return self.addEvent(wrapper, time.time() + t, name)
        wrapper = functools.partial(wrapper, [count])
        if now:
            return wrapper()
        else:
            return self.addEvent(wrapper, time.time() + t, name)

    removePeriodicEvent = removeEvent

    def run(self):
        if len(drivers._drivers) == 1 and not world.testing:
            log.error('Schedule is the only remaining driver, '
                      'why do we continue to live?')
            time.sleep(1) # We're the only driver; let's pause to think.
        while self.schedule and self.schedule[0][0] < time.time():
            with self.lock:
                (t, name, args, kwargs) = heapq.heappop(self.schedule)
                f = self.events[name]
            del self.events[name]
            try:
                f(*args, **kwargs)
            except Exception as e:
                log.exception('Uncaught exception in scheduled function:')


schedule = Schedule()
addEvent = schedule.addEvent
removeEvent = schedule.removeEvent
rescheduleEvent = schedule.rescheduleEvent
addPeriodicEvent = schedule.addPeriodicEvent
removePeriodicEvent = removeEvent
run = schedule.run


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = shlex
"""A lexical analyzer class for simple shell-like syntaxes."""

# Module and documentation by Eric S. Raymond, 21 Dec 1998
# Input stacking and error message cleanup added by ESR, March 2000
# push_source() and pop_source() made explicit by ESR, January 2001.

import os.path
import sys

__all__ = ["shlex"]

class shlex:
    "A lexical analyzer class for simple shell-like syntaxes."
    def __init__(self, instream=None, infile=None):
        if instream is not None:
            self.instream = instream
            self.infile = infile
        else:
            self.instream = sys.stdin
            self.infile = None
        self.commenters = '#'
        self.whitespace = ' \t\r\n'
        self.separators = self.whitespace
        self.quotes = '\'"'
        self.state = ' '
        self.pushback = []
        self.lineno = 1
        self.debug = 0
        self.token = ''
        self.backslash = False
        self.filestack = []
        self.source = None
        if self.debug:
            print('shlex: reading from %s, line %d' \
                  % (self.instream, self.lineno))

    def push_token(self, tok):
        "Push a token onto the stack popped by the get_token method"
        if self.debug >= 1:
            print("shlex: pushing token " + repr(tok))
        self.pushback = [tok] + self.pushback

    def push_source(self, newstream, newfile=None):
        "Push an input source onto the lexer's input source stack."
        self.filestack.insert(0, (self.infile, self.instream, self.lineno))
        self.infile = newfile
        self.instream = newstream
        self.lineno = 1
        if self.debug:
            if newfile is not None:
                print('shlex: pushing to file %s' % (self.infile,))
            else:
                print('shlex: pushing to stream %s' % (self.instream,))

    def pop_source(self):
        "Pop the input source stack."
        self.instream.close()
        (self.infile, self.instream, self.lineno) = self.filestack[0]
        self.filestack = self.filestack[1:]
        if self.debug:
            print('shlex: popping to %s, line %d' \
                  % (self.instream, self.lineno))
        self.state = ' '

    def get_token(self):
        "Get a token from the input stream (or from stack if it's nonempty)"
        if self.pushback:
            tok = self.pushback[0]
            self.pushback = self.pushback[1:]
            if self.debug >= 1:
                print("shlex: popping token " + repr(tok))
            return tok
        # No pushback.  Get a token.
        raw = self.read_token()
        # Handle inclusions
        while raw == self.source:
            spec = self.sourcehook(self.read_token())
            if spec:
                (newfile, newstream) = spec
                self.push_source(newstream, newfile)
            raw = self.get_token()
        # Maybe we got EOF instead?
        while raw == "":
            if len(self.filestack) == 0:
                return ""
            else:
                self.pop_source()
                raw = self.get_token()
         # Neither inclusion nor EOF
        if self.debug >= 1:
            if raw:
                print("shlex: token=" + repr(raw))
            else:
                print("shlex: token=EOF")
        return raw

    def read_token(self):
        "Read a token from the input stream (no pushback or inclusions)"
        while True:
            nextchar = self.instream.read(1)
            if nextchar == '\n':
                self.lineno = self.lineno + 1
            if self.debug >= 3:
                print("shlex: in state", repr(self.state), \
                      "I see character:", repr(nextchar))
            if self.state is None:
                self.token = ''        # past end of file
                break
            elif self.state == ' ':
                if not nextchar:
                    self.state = None  # end of file
                    break
                elif nextchar in self.whitespace:
                    if self.debug >= 2:
                        print("shlex: I see whitespace in whitespace state")
                    if self.token:
                        break   # emit current token
                    else:
                        continue
                elif nextchar in self.commenters:
                    self.instream.readline()
                    self.lineno = self.lineno + 1
                elif nextchar not in self.separators:
                    self.token = nextchar
                    self.state = 'a'
                elif nextchar in self.quotes:
                    self.token = nextchar
                    self.state = nextchar
                else:
                    self.token = nextchar
                    if self.token:
                        break   # emit current token
                    else:
                        continue
            elif self.state in self.quotes:
                self.token = self.token + nextchar
                if nextchar == '\\':
                    if self.backslash:
                        self.backslash = False
                    else:
                        self.backslash = True
                else:
                    if not self.backslash and nextchar == self.state:
                        self.state = ' '
                        break
                    elif self.backslash:
                        self.backslash = False
                    elif not nextchar:      # end of file
                        if self.debug >= 2:
                            print("shlex: I see EOF in quotes state")
                        # XXX what error should be raised here?
                        raise ValueError("No closing quotation")
            elif self.state == 'a':
                if not nextchar:
                    self.state = None   # end of file
                    break
                elif nextchar in self.whitespace:
                    if self.debug >= 2:
                        print("shlex: I see whitespace in word state")
                    self.state = ' '
                    if self.token:
                        break   # emit current token
                    else:
                        continue
                elif nextchar in self.commenters:
                    self.instream.readline()
                    self.lineno = self.lineno + 1
                elif nextchar not in self.separators or nextchar in self.quotes:
                    self.token = self.token + nextchar
                else:
                    self.pushback = [nextchar] + self.pushback
                    if self.debug >= 2:
                        print("shlex: I see punctuation in word state")
                    self.state = ' '
                    if self.token:
                        break   # emit current token
                    else:
                        continue
        result = self.token
        self.token = ''
        if self.debug > 1:
            if result:
                print("shlex: raw token=" + repr(result))
            else:
                print("shlex: raw token=EOF")
        return result

    def sourcehook(self, newfile):
        "Hook called on a filename to be sourced."
        if newfile[0] == '"':
            newfile = newfile[1:-1]
        # This implements cpp-like semantics for relative-path inclusion.
        if isinstance(self.infile, basestring) and not os.path.isabs(newfile):
            newfile = os.path.join(os.path.dirname(self.infile), newfile)
        return (newfile, open(newfile, "r"))

    def error_leader(self, infile=None, lineno=None):
        "Emit a C-compiler-like, Emacs-friendly error-message leader."
        if infile is None:
            infile = self.infile
        if lineno is None:
            lineno = self.lineno
        return "\"%s\", line %d: " % (infile, lineno)


if __name__ == '__main__':
    if len(sys.argv) == 1:
        lexer = shlex()
    else:
        file = sys.argv[1]
        with open(file) as fd:
            lexer = shlex(fd, file)
    while True:
        tt = lexer.get_token()
        if tt:
            print("Token: " + repr(tt))
        else:
            break

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# Copyright (c) 2011, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import gc
import os
import re
import sys
import time
import shutil
import urllib
import httplib
import unittest
import threading

from . import (callbacks, conf, drivers, httpserver, i18n, ircdb, irclib,
        ircmsgs, ircutils, log, plugin, registry, utils, world)

i18n.import_conf()
network = True

# This is the global list of suites that are to be run.
suites = []

timeout = 10

originalCallbacksGetHelp = callbacks.getHelp
lastGetHelp = 'x' * 1000
def cachingGetHelp(method, name=None, doc=None):
    global lastGetHelp
    lastGetHelp = originalCallbacksGetHelp(method, name, doc)
    return lastGetHelp
callbacks.getHelp = cachingGetHelp

def getTestIrc():
    irc = irclib.Irc('test')
    # Gotta clear the connect messages (USER, NICK, etc.)
    while irc.takeMsg():
        pass
    return irc

class TimeoutError(AssertionError):
    def __str__(self):
        return '%r timed out' % self.args[0]

class TestPlugin(callbacks.Plugin):
    def eval(self, irc, msg, args):
        """<text>

        This is the help for eval.  Since Owner doesn't have an eval command
        anymore, we needed to add this so as not to invalidate any of the tests
        that depended on that eval command.
        """
        try:
            irc.reply(repr(eval(' '.join(args))))
        except callbacks.ArgumentError:
            raise
        except Exception as e:
            irc.reply(utils.exnToString(e))
# Since we know we don't now need the Irc object, we just give None.  This
# might break if callbacks.Privmsg ever *requires* the Irc object.
TestInstance = TestPlugin(None)
conf.registerPlugin('TestPlugin', True, public=False)

class SupyTestCase(unittest.TestCase):
    """This class exists simply for extra logging.  It's come in useful in the
    past."""
    def setUp(self):
        log.critical('Beginning test case %s', self.id())
        threads = [t.getName() for t in threading.enumerate()]
        log.critical('Threads: %L', threads)
        unittest.TestCase.setUp(self)

    def tearDown(self):
        for irc in world.ircs[:]:
            irc._reallyDie()

    if sys.version_info < (2, 7, 0):
        def assertIn(self, member, container, msg=None):
            """Just like self.assertTrue(a in b), but with a nicer default message."""
            if member not in container:
                standardMsg = '%s not found in %s' % (repr(member),
                                                      repr(container))
                self.fail(self._formatMessage(msg, standardMsg))

        def assertNotIn(self, member, container, msg=None):
            """Just like self.assertTrue(a not in b), but with a nicer default message."""
            if member in container:
                standardMsg = '%s unexpectedly found in %s' % (repr(member),
                                                            repr(container))
                self.fail(self._formatMessage(msg, standardMsg))

        def assertIs(self, expr1, expr2, msg=None):
            """Just like self.assertTrue(a is b), but with a nicer default message."""
            if expr1 is not expr2:
                standardMsg = '%s is not %s' % (repr(expr1),
                                                 repr(expr2))
                self.fail(self._formatMessage(msg, standardMsg))

        def assertIsNot(self, expr1, expr2, msg=None):
            """Just like self.assertTrue(a is not b), but with a nicer default message."""
            if expr1 is expr2:
                standardMsg = 'unexpectedly identical: %s' % (repr(expr1),)
                self.fail(self._formatMessage(msg, standardMsg))


class PluginTestCase(SupyTestCase):
    """Subclass this to write a test case for a plugin.  See
    plugins/Plugin/test.py for an example.
    """
    plugins = None
    cleanConfDir = True
    cleanDataDir = True
    config = {}
    def __init__(self, methodName='runTest'):
        self.timeout = timeout
        originalRunTest = getattr(self, methodName)
        def runTest(self):
            run = True
            if hasattr(self, 'irc') and self.irc:
                for cb in self.irc.callbacks:
                    cbModule = sys.modules[cb.__class__.__module__]
                    if hasattr(cbModule, 'deprecated') and cbModule.deprecated:
                        print('')
                        print('Ignored, %s is deprecated.' % cb.name())
                        run = False
            if run:
                originalRunTest()
        runTest = utils.python.changeFunctionName(runTest, methodName)
        setattr(self.__class__, methodName, runTest)
        SupyTestCase.__init__(self, methodName=methodName)
        self.originals = {}

    def setUp(self, nick='test', forceSetup=False):
        if not forceSetup and \
                self.__class__ in (PluginTestCase, ChannelPluginTestCase):
            # Necessary because there's a test in here that shouldn\'t run.
            return
        SupyTestCase.setUp(self)
        # Just in case, let's do this.  Too many people forget to call their
        # super methods.
        for irc in world.ircs[:]:
            irc._reallyDie()
        # Set conf variables appropriately.
        conf.supybot.reply.whenAddressedBy.chars.setValue('@')
        conf.supybot.reply.error.detailed.setValue(True)
        conf.supybot.reply.whenNotCommand.setValue(True)
        self.myVerbose = world.myVerbose
        def rmFiles(dir):
            for filename in os.listdir(dir):
                file = os.path.join(dir, filename)
                if os.path.isfile(file):
                    os.remove(file)
                else:
                    shutil.rmtree(file)
        if self.cleanConfDir:
            rmFiles(conf.supybot.directories.conf())
        if self.cleanDataDir:
            rmFiles(conf.supybot.directories.data())
        ircdb.users.reload()
        ircdb.ignores.reload()
        ircdb.channels.reload()
        if self.plugins is None:
            raise ValueError('PluginTestCase must have a "plugins" attribute.')
        self.nick = nick
        self.prefix = ircutils.joinHostmask(nick, 'user', 'host.domain.tld')
        self.irc = getTestIrc()
        MiscModule = plugin.loadPluginModule('Misc')
        OwnerModule = plugin.loadPluginModule('Owner')
        ConfigModule = plugin.loadPluginModule('Config')
        _ = plugin.loadPluginClass(self.irc, MiscModule)
        _ = plugin.loadPluginClass(self.irc, OwnerModule)
        _ = plugin.loadPluginClass(self.irc, ConfigModule)
        if isinstance(self.plugins, str):
            self.plugins = [self.plugins]
        else:
            for name in self.plugins:
                if name not in ('Owner', 'Misc', 'Config'):
                    module = plugin.loadPluginModule(name,
                                                     ignoreDeprecation=True)
                    cb = plugin.loadPluginClass(self.irc, module)
        self.irc.addCallback(TestInstance)
        for (name, value) in self.config.iteritems():
            group = conf.supybot
            parts = registry.split(name)
            if parts[0] == 'supybot':
                parts.pop(0)
            for part in parts:
                group = group.get(part)
            self.originals[group] = group()
            group.setValue(value)

    def tearDown(self):
        if self.__class__ in (PluginTestCase, ChannelPluginTestCase):
            # Necessary because there's a test in here that shouldn\'t run.
            return
        for (group, original) in self.originals.iteritems():
            group.setValue(original)
        ircdb.users.close()
        ircdb.ignores.close()
        ircdb.channels.close()
        SupyTestCase.tearDown(self)
        self.irc = None
        gc.collect()

    def _feedMsg(self, query, timeout=None, to=None, frm=None,
                 usePrefixChar=True):
        if to is None:
            to = self.irc.nick
        if frm is None:
            frm = self.prefix
        if timeout is None:
            timeout = self.timeout
        if self.myVerbose:
            print('') # Extra newline, so it's pretty.
        prefixChars = conf.supybot.reply.whenAddressedBy.chars()
        if not usePrefixChar and query[0] in prefixChars:
            query = query[1:]
        if sys.version_info[0] < 3:
            query = query.encode('utf8') # unicode->str
        msg = ircmsgs.privmsg(to, query, prefix=frm)
        if self.myVerbose:
            print('Feeding: %r' % msg)
        self.irc.feedMsg(msg)
        fed = time.time()
        response = self.irc.takeMsg()
        while response is None and time.time() - fed < timeout:
            time.sleep(0.1) # So it doesn't suck up 100% cpu.
            drivers.run()
            response = self.irc.takeMsg()
        if self.myVerbose:
            print('Response: %r' % response)
        return response

    def getMsg(self, query, **kwargs):
        return self._feedMsg(query, **kwargs)

    def feedMsg(self, query, to=None, frm=None):
        """Just feeds it a message, that's all."""
        if to is None:
            to = self.irc.nick
        if frm is None:
            frm = self.prefix
        self.irc.feedMsg(ircmsgs.privmsg(to, query, prefix=frm))

    # These assertError/assertNoError are somewhat fragile.  The proper way to
    # do them would be to use a proxy for the irc object and intercept .error.
    # But that would be hard, so I don't bother.  When this breaks, it'll get
    # fixed, but not until then.
    def assertError(self, query, **kwargs):
        m = self._feedMsg(query, **kwargs)
        if m is None:
            raise TimeoutError(query)
        if lastGetHelp not in m.args[1]:
            self.failUnless(m.args[1].startswith('Error:'),
                            '%r did not error: %s' % (query, m.args[1]))
        return m

    def assertSnarfError(self, query, **kwargs):
        return self.assertError(query, usePrefixChar=False, **kwargs)

    def assertNotError(self, query, **kwargs):
        m = self._feedMsg(query, **kwargs)
        if m is None:
            raise TimeoutError(query)
        self.failIf(m.args[1].startswith('Error:'),
                    '%r errored: %s' % (query, m.args[1]))
        self.failIf(lastGetHelp in m.args[1],
                    '%r returned the help string.' % query)
        return m

    def assertSnarfNotError(self, query, **kwargs):
        return self.assertNotError(query, usePrefixChar=False, **kwargs)

    def assertHelp(self, query, **kwargs):
        m = self._feedMsg(query, **kwargs)
        if m is None:
            raise TimeoutError(query)
        msg = m.args[1]
        if 'more message' in msg:
            msg = msg[0:-27] # Strip (XXX more messages)
        self.failUnless(msg in lastGetHelp,
                        '%s is not the help (%s)' % (m.args[1], lastGetHelp))
        return m

    def assertNoResponse(self, query, timeout=0, **kwargs):
        m = self._feedMsg(query, timeout=timeout, **kwargs)
        self.failIf(m, 'Unexpected response: %r' % m)
        return m

    def assertSnarfNoResponse(self, query, timeout=0, **kwargs):
        return self.assertNoResponse(query, timeout=timeout,
                                     usePrefixChar=False, **kwargs)

    def assertResponse(self, query, expectedResponse, **kwargs):
        m = self._feedMsg(query, **kwargs)
        if m is None:
            raise TimeoutError(query)
        self.assertEqual(m.args[1], expectedResponse,
                         '%r != %r' % (expectedResponse, m.args[1]))
        return m

    def assertSnarfResponse(self, query, expectedResponse, **kwargs):
        return self.assertResponse(query, expectedResponse,
                                   usePrefixChar=False, **kwargs)

    def assertRegexp(self, query, regexp, flags=re.I, **kwargs):
        m = self._feedMsg(query, **kwargs)
        if m is None:
            raise TimeoutError(query)
        self.failUnless(re.search(regexp, m.args[1], flags),
                        '%r does not match %r' % (m.args[1], regexp))
        return m

    def assertSnarfRegexp(self, query, regexp, flags=re.I, **kwargs):
        return self.assertRegexp(query, regexp, flags=re.I,
                                 usePrefixChar=False, **kwargs)

    def assertNotRegexp(self, query, regexp, flags=re.I, **kwargs):
        m = self._feedMsg(query, **kwargs)
        if m is None:
            raise TimeoutError(query)
        self.failUnless(re.search(regexp, m.args[1], flags) is None,
                        '%r matched %r' % (m.args[1], regexp))
        return m

    def assertSnarfNotRegexp(self, query, regexp, flags=re.I, **kwargs):
        return self.assertNotRegexp(query, regexp, flags=re.I,
                                    usePrefixChar=False, **kwargs)

    def assertAction(self, query, expectedResponse=None, **kwargs):
        m = self._feedMsg(query, **kwargs)
        if m is None:
            raise TimeoutError(query)
        self.failUnless(ircmsgs.isAction(m), '%r is not an action.' % m)
        if expectedResponse is not None:
            s = ircmsgs.unAction(m)
            self.assertEqual(s, expectedResponse,
                             '%r != %r' % (s, expectedResponse))
        return m

    def assertSnarfAction(self, query, expectedResponse=None, **kwargs):
        return self.assertAction(query, expectedResponse=None,
                                 usePrefixChar=False, **kwargs)

    def assertActionRegexp(self, query, regexp, flags=re.I, **kwargs):
        m = self._feedMsg(query, **kwargs)
        if m is None:
            raise TimeoutError(query)
        self.failUnless(ircmsgs.isAction(m))
        s = ircmsgs.unAction(m)
        self.failUnless(re.search(regexp, s, flags),
                        '%r does not match %r' % (s, regexp))

    def assertSnarfActionRegexp(self, query, regexp, flags=re.I, **kwargs):
        return self.assertActionRegexp(query, regexp, flags=re.I,
                                       usePrefixChar=False, **kwargs)

    _noTestDoc = ('Admin', 'Channel', 'Config',
                  'Misc', 'Owner', 'User', 'TestPlugin')
    def TestDocumentation(self):
        if self.__class__ in (PluginTestCase, ChannelPluginTestCase):
            return
        for cb in self.irc.callbacks:
            name = cb.name()
            if ((name in self._noTestDoc) and \
               not name.lower() in self.__class__.__name__.lower()):
                continue
            self.failUnless(sys.modules[cb.__class__.__name__].__doc__,
                            '%s has no module documentation.' % name)
            if hasattr(cb, 'isCommandMethod'):
                for attr in dir(cb):
                    if cb.isCommandMethod(attr) and \
                       attr == callbacks.canonicalName(attr):
                        self.failUnless(getattr(cb, attr, None).__doc__,
                                        '%s.%s has no help.' % (name, attr))



class ChannelPluginTestCase(PluginTestCase):
    channel = '#test'
    def setUp(self, nick='test', forceSetup=False):
        if not forceSetup and \
                self.__class__ in (PluginTestCase, ChannelPluginTestCase):
            return
        PluginTestCase.setUp(self)
        self.irc.feedMsg(ircmsgs.join(self.channel, prefix=self.prefix))
        m = self.irc.takeMsg()
        self.failIf(m is None, 'No message back from joining channel.')
        self.assertEqual(m.command, 'MODE')
        m = self.irc.takeMsg()
        self.failIf(m is None, 'No message back from joining channel.')
        self.assertEqual(m.command, 'MODE')
        m = self.irc.takeMsg()
        self.failIf(m is None, 'No message back from joining channel.')
        self.assertEqual(m.command, 'WHO')

    def _feedMsg(self, query, timeout=None, to=None, frm=None, private=False,
                 usePrefixChar=True):
        if to is None:
            if private:
                to = self.irc.nick
            else:
                to = self.channel
        if frm is None:
            frm = self.prefix
        if timeout is None:
            timeout = self.timeout
        if self.myVerbose:
            print('') # Newline, just like PluginTestCase.
        prefixChars = conf.supybot.reply.whenAddressedBy.chars()
        if query[0] not in prefixChars and usePrefixChar:
            query = prefixChars[0] + query
        if sys.version_info[0] < 3 and isinstance(query, unicode):
            query = query.encode('utf8') # unicode->str
        msg = ircmsgs.privmsg(to, query, prefix=frm)
        if self.myVerbose:
            print('Feeding: %r' % msg)
        self.irc.feedMsg(msg)
        fed = time.time()
        response = self.irc.takeMsg()
        while response is None and time.time() - fed < timeout:
            time.sleep(0.1)
            drivers.run()
            response = self.irc.takeMsg()
        if response is not None:
            if response.command == 'PRIVMSG':
                args = list(response.args)
                # Strip off nick: at beginning of response.
                if args[1].startswith(self.nick) or \
                   args[1].startswith(ircutils.nickFromHostmask(self.prefix)):
                    try:
                        args[1] = args[1].split(' ', 1)[1]
                    except IndexError:
                        # Odd.  We'll skip this.
                        pass
                ret = ircmsgs.privmsg(*args)
            else:
                ret = response
        else:
            ret = None
        if self.myVerbose:
            print('Returning: %r' % ret)
        return ret

    def feedMsg(self, query, to=None, frm=None, private=False):
        """Just feeds it a message, that's all."""
        if to is None:
            if private:
                to = self.irc.nick
            else:
                to = self.channel
        if frm is None:
            frm = self.prefix
        self.irc.feedMsg(ircmsgs.privmsg(to, query, prefix=frm))

class TestRequestHandler(httpserver.SupyHTTPRequestHandler):
    def __init__(self, rfile, wfile, *args, **kwargs):
        self._headers_mode = True
        self.rfile = rfile
        self.wfile = wfile
        self.handle_one_request()

    def send_response(self, code):
        assert self._headers_mode
        self._response = code
    def send_headers(self, name, value):
        assert self._headers_mode
        self._headers[name] = value
    def end_headers(self):
        assert self._headers_mode
        self._headers_mode = False

    def do_X(self, *args, **kwargs):
        assert httpserver.http_servers, \
                'The HTTP server is not started.'
        self.server = httpserver.http_servers[0]
        httpserver.SupyHTTPRequestHandler.do_X(self, *args, **kwargs)

httpserver.http_servers = [httpserver.TestSupyHTTPServer()]

# Partially stolen from the standart Python library :)
def open_http(url, data=None):
    """Use HTTP protocol."""
    import httplib
    user_passwd = None
    proxy_passwd= None
    if isinstance(url, str):
        host, selector = urllib.splithost(url)
        if host:
            user_passwd, host = urllib.splituser(host)
            host = urllib.unquote(host)
        realhost = host
    else:
        host, selector = url
        # check whether the proxy contains authorization information
        proxy_passwd, host = urllib.splituser(host)
        # now we proceed with the url we want to obtain
        urltype, rest = urllib.splittype(selector)
        url = rest
        user_passwd = None
        if urltype.lower() != 'http':
            realhost = None
        else:
            realhost, rest = urllib.splithost(rest)
            if realhost:
                user_passwd, realhost = urllib.splituser(realhost)
            if user_passwd:
                selector = "%s://%s%s" % (urltype, realhost, rest)
            if urllib.proxy_bypass(realhost):
                host = realhost

        #print "proxy via http:", host, selector
    if not host: raise IOError('http error', 'no host given')

    if proxy_passwd:
        import base64
        proxy_auth = base64.b64encode(proxy_passwd).strip()
    else:
        proxy_auth = None

    if user_passwd:
        import base64
        auth = base64.b64encode(user_passwd).strip()
    else:
        auth = None
    c = FakeHTTPConnection(host)
    if data is not None:
        c.putrequest('POST', selector)
        c.putheader('Content-Type', 'application/x-www-form-urlencoded')
        c.putheader('Content-Length', '%d' % len(data))
    else:
        c.putrequest('GET', selector)
    if proxy_auth: c.putheader('Proxy-Authorization', 'Basic %s' % proxy_auth)
    if auth: c.putheader('Authorization', 'Basic %s' % auth)
    if realhost: c.putheader('Host', realhost)
    for args in urllib.URLopener().addheaders: c.putheader(*args)
    c.endheaders()
    return c

class FakeHTTPConnection(httplib.HTTPConnection):
    _data = ''
    _headers = {}
    def __init__(self, rfile, wfile):
        httplib.HTTPConnection.__init__(self, 'localhost')
        self.rfile = rfile
        self.wfile = wfile
    def send(self, data):
        self.wfile.write(data)
    #def putheader(self, name, value):
    #    self._headers[name] = value
    #def connect(self, *args, **kwargs):
    #    self.sock = self.wfile
    #def getresponse(self, *args, **kwargs):
    #    pass

class HTTPPluginTestCase(PluginTestCase):
    def setUp(self):
        PluginTestCase.setUp(self, forceSetup=True)

    def request(self, url, method='GET', read=True, data={}):
        assert url.startswith('/')
        try:
            from io import BytesIO as StringIO
        except ImportError:
            from StringIO import StringIO
        wfile = StringIO()
        rfile = StringIO()
        connection = FakeHTTPConnection(wfile, rfile)
        connection.putrequest(method, url)
        connection.endheaders()
        rfile.seek(0)
        wfile.seek(0)
        handler = TestRequestHandler(rfile, wfile)
        if read:
            return (handler._response, wfile.read())
        else:
            return handler._response

    def assertHTTPResponse(self, uri, expectedResponse, **kwargs):
        response = self.request(uri, read=False, **kwargs)
        self.assertEqual(response, expectedResponse)

    def assertNotHTTPResponse(self, uri, expectedResponse, **kwargs):
        response = self.request(uri, read=False, **kwargs)
        self.assertNotEqual(response, expectedResponse)

class ChannelHTTPPluginTestCase(ChannelPluginTestCase, HTTPPluginTestCase):
    def setUp(self):
        ChannelPluginTestCase.setUp(self, forceSetup=True)

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:


########NEW FILE########
__FILENAME__ = unpreserve
###
# Copyright (c) 2004-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

class Reader(object):
    def __init__(self, Creator, *args, **kwargs):
        self.Creator = Creator
        self.args = args
        self.kwargs = kwargs
        self.creator = None
        self.modifiedCreator = False
        self.indent = None

    def normalizeCommand(self, s):
        return s.lower()

    def readFile(self, filename):
        self.read(open(filename))

    def read(self, fd):
        lineno = 0
        for line in fd:
            lineno += 1
            if not line.strip():
                continue
            line = line.rstrip('\r\n')
            line = line.expandtabs()
            s = line.lstrip(' ')
            indent = len(line) - len(s)
            if indent != self.indent:
                # New indentation level.
                if self.creator is not None:
                    self.creator.finish()
                self.creator = self.Creator(*self.args, **self.kwargs)
                self.modifiedCreator = False
                self.indent = indent
            (command, rest) = s.split(None, 1)
            command = self.normalizeCommand(command)
            self.modifiedCreator = True
            if hasattr(self.creator, command):
                command = getattr(self.creator, command)
                command(rest, lineno)
            else:
                self.creator.badCommand(command, rest, lineno)
        if self.modifiedCreator:
            self.creator.finish()


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:


########NEW FILE########
__FILENAME__ = crypt
###
# Copyright (c) 2008, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import sys

from hashlib import md5
from hashlib import sha1 as sha

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = error
###
# Copyright (c) 2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import os

import gen

class Error(Exception):
    def __init__(self, msg, e=None):
        self.msg = msg
        self.e = e

    def __str__(self):
        if self.e is not None:
            return os.linesep.join([self.msg, gen.exnToString(self.e)])
        else:
            return self.msg

# vim:set shiftwidth=4 softtabstop=8 expandtab textwidth=78:

########NEW FILE########
__FILENAME__ = file
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# Copyright (c) 2008, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import os
import time
import random
import shutil
import os.path

from . import crypt
from .iter import ifilter

def contents(filename):
    with open(filename) as fd:
        return fd.read()

def open_mkdir(filename, mode='wb', *args, **kwargs):
    """filename -> file object.

    Returns a file object for filename, creating as many directories as may be
    necessary.  I.e., if the filename is ./foo/bar/baz, and . exists, and ./foo
    exists, but ./foo/bar does not exist, bar will be created before opening
    baz in it.
    """
    if mode not in ('w', 'wb'):
        raise ValueError('utils.file.open expects to write.')
    (dirname, basename) = os.path.split(filename)
    os.makedirs(dirname)
    return open(filename, mode, *args, **kwargs)

def copy(src, dst):
    """src, dst -> None

    Copies src to dst, using this module's 'open' function to open dst.
    """
    srcfd = open(src)
    dstfd = open_mkdir(dst, 'wb')
    shutil.copyfileobj(srcfd, dstfd)
    srcfd.close()
    dstfd.close()

def writeLine(fd, line):
    fd.write(line)
    if not line.endswith('\n'):
        fd.write('\n')

def readLines(filename):
    fd = open(filename)
    try:
        return [line.rstrip('\r\n') for line in fd.readlines()]
    finally:
        fd.close()

def touch(filename):
    fd = open(filename, 'w')
    fd.close()

def mktemp(suffix=''):
    """Gives a decent random string, suitable for a filename."""
    r = random.Random()
    m = crypt.md5(suffix.encode('utf8'))
    r.seed(time.time())
    s = str(r.getstate())
    period = random.random()
    now = start = time.time()
    while start + period < now:
        time.sleep() # Induce a context switch, if possible.
        now = time.time()
        m.update(str(random.random()))
        m.update(s)
        m.update(str(now))
        s = m.hexdigest()
    return crypt.sha((s + str(time.time())).encode('utf8')).hexdigest()+suffix

def nonCommentLines(fd):
    for line in fd:
        if not line.startswith('#'):
            yield line

def nonEmptyLines(fd):
    return filter(str.strip, fd)

def nonCommentNonEmptyLines(fd):
    return nonEmptyLines(nonCommentLines(fd))

def chunks(fd, size):
    return iter(lambda : fd.read(size), '')
##     chunk = fd.read(size)
##     while chunk:
##         yield chunk
##         chunk = fd.read(size)

class AtomicFile(object):
    """Used for files that need to be atomically written -- i.e., if there's a
    failure, the original file remains, unmodified.  mode must be 'w' or 'wb'"""
    class default(object): # Holder for values.
        # Callables?
        tmpDir = None
        backupDir = None
        makeBackupIfSmaller = True
        allowEmptyOverwrite = True
    def __init__(self, filename, mode='w', allowEmptyOverwrite=None,
                 makeBackupIfSmaller=None, tmpDir=None, backupDir=None):
        if tmpDir is None:
            tmpDir = force(self.default.tmpDir)
        if backupDir is None:
            backupDir = force(self.default.backupDir)
        if makeBackupIfSmaller is None:
            makeBackupIfSmaller = force(self.default.makeBackupIfSmaller)
        if allowEmptyOverwrite is None:
            allowEmptyOverwrite = force(self.default.allowEmptyOverwrite)
        if mode not in ('w', 'wb'):
            raise ValueError(format('Invalid mode: %q', mode))
        self.rolledback = False
        self.allowEmptyOverwrite = allowEmptyOverwrite
        self.makeBackupIfSmaller = makeBackupIfSmaller
        self.filename = filename
        self.backupDir = backupDir
        if tmpDir is None:
            # If not given a tmpDir, we'll just put a random token on the end
            # of our filename and put it in the same directory.
            self.tempFilename = '%s.%s' % (self.filename, mktemp())
        else:
            # If given a tmpDir, we'll get the basename (just the filename, no
            # directory), put our random token on the end, and put it in tmpDir
            tempFilename = '%s.%s' % (os.path.basename(self.filename), mktemp())
            self.tempFilename = os.path.join(tmpDir, tempFilename)
        # This doesn't work because of the uncollectable garbage effect.
        # self.__parent = super(AtomicFile, self)
        self._fd = open(self.tempFilename, mode)

    @property
    def closed(self):
        return self._fd.closed

    def close(self):
        return self._fd.close()

    def write(self, data):
        return self._fd.write(data)

    def writelines(self, lines):
        return self._fd.writelines(lines)

    def rollback(self):
        if not self.closed:
            self._fd.close()
            if os.path.exists(self.tempFilename):
                os.remove(self.tempFilename)
            self.rolledback = True

    def seek(self, offset):
        return self._fd.seek(offset)

    def tell(self):
        return self._fd.tell()

    def flush(self):
        return self._fd.flush()

    def close(self):
        if not self.rolledback:
            self._fd.close()
            # We don't mind writing an empty file if the file we're overwriting
            # doesn't exist.
            newSize = os.path.getsize(self.tempFilename)
            originalExists = os.path.exists(self.filename)
            if newSize or self.allowEmptyOverwrite or not originalExists:
                if originalExists:
                    oldSize = os.path.getsize(self.filename)
                    if self.makeBackupIfSmaller and newSize < oldSize and \
                            self.backupDir != '/dev/null':
                        now = int(time.time())
                        backupFilename = '%s.backup.%s' % (self.filename, now)
                        if self.backupDir is not None:
                            backupFilename = os.path.basename(backupFilename)
                            backupFilename = os.path.join(self.backupDir,
                                                          backupFilename)
                        shutil.copy(self.filename, backupFilename)
                # We use shutil.move here instead of os.rename because
                # the latter doesn't work on Windows when self.filename
                # (the target) already exists.  shutil.move handles those
                # intricacies for us.

                # This raises IOError if we can't write to the file.  Since
                # in *nix, it only takes write perms to the *directory* to
                # rename a file (and shutil.move will use os.rename if
                # possible), we first check if we have the write permission
                # and only then do we write.
                fd = open(self.filename, 'a')
                fd.close()
                shutil.move(self.tempFilename, self.filename)

        else:
            raise ValueError('AtomicFile.close called after rollback.')

    def __del__(self):
        # We rollback because if we're deleted without being explicitly closed,
        # that's bad.  We really should log this here, but as of yet we've got
        # no logging facility in utils.  I've got some ideas for this, though.
        self.rollback()

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = gen
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# Copyright (c) 2008, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from __future__ import print_function

import os
import sys
import ast
import time
import types
import textwrap
import traceback
import collections


from . import crypt
from .str import format
from .file import mktemp
from .iter import imap

from supybot.i18n import PluginInternationalization
_ = PluginInternationalization()

def abbrev(strings, d=None):
    """Returns a dictionary mapping unambiguous abbreviations to full forms."""
    def eachSubstring(s):
        for i in xrange(1, len(s)+1):
            yield s[:i]
    if len(strings) != len(set(strings)):
        raise ValueError(
              'strings given to utils.abbrev have duplicates: %r' % strings)
    if d is None:
        d = {}
    for s in strings:
        for abbreviation in eachSubstring(s):
            if abbreviation not in d:
                d[abbreviation] = s
            else:
                if abbreviation not in strings:
                    d[abbreviation] = None
    removals = []
    for key in d:
        if d[key] is None:
            removals.append(key)
    for key in removals:
        del d[key]
    return d

def timeElapsed(elapsed, short=False, leadingZeroes=False, years=True,
                weeks=True, days=True, hours=True, minutes=True, seconds=True):
    """Given <elapsed> seconds, returns a string with an English description of
    the amount of time passed.  leadingZeroes determines whether 0 days, 0
    hours, etc. will be printed; the others determine what larger time periods
    should be used.
    """
    ret = []
    before = False
    def Format(s, i):
        if i or leadingZeroes or ret:
            if short:
                ret.append('%s%s' % (i, s[0]))
            else:
                ret.append(format('%n', (i, s)))
    elapsed = int(elapsed)

    # Handle negative times
    if elapsed < 0:
        before = True
        elapsed = -elapsed

    assert years or weeks or days or \
           hours or minutes or seconds, 'One flag must be True'
    if years:
        (yrs, elapsed) = (elapsed // 31536000, elapsed % 31536000)
        Format(_('year'), yrs)
    if weeks:
        (wks, elapsed) = (elapsed // 604800, elapsed % 604800)
        Format(_('week'), wks)
    if days:
        (ds, elapsed) = (elapsed // 86400, elapsed % 86400)
        Format(_('day'), ds)
    if hours:
        (hrs, elapsed) = (elapsed // 3600, elapsed % 3600)
        Format(_('hour'), hrs)
    if minutes or seconds:
        (mins, secs) = (elapsed // 60, elapsed % 60)
        if leadingZeroes or mins:
            Format(_('minute'), mins)
        if seconds:
            leadingZeroes = True
            Format(_('second'), secs)
    if not ret:
        raise ValueError('Time difference not great enough to be noted.')
    result = ''
    if short:
        result = ' '.join(ret)
    else:
        result = format('%L', ret)
    if before:
        result = _('%s ago') % result
    return result

def findBinaryInPath(s):
    """Return full path of a binary if it's in PATH, otherwise return None."""
    cmdLine = None
    for dir in os.getenv('PATH').split(':'):
        filename = os.path.join(dir, s)
        if os.path.exists(filename):
            cmdLine = filename
            break
    return cmdLine

def sortBy(f, L):
    """Uses the decorate-sort-undecorate pattern to sort L by function f."""
    for (i, elt) in enumerate(L):
        L[i] = (f(elt), i, elt)
    L.sort()
    for (i, elt) in enumerate(L):
        L[i] = L[i][2]

def saltHash(password, salt=None, hash='sha'):
    if salt is None:
        salt = mktemp()[:8]
    if hash == 'sha':
        hasher = crypt.sha
    elif hash == 'md5':
        hasher = crypt.md5
    return '|'.join([salt, hasher((salt + password).encode('utf8')).hexdigest()])

_astStr2 = ast.Str if sys.version_info[0] < 3 else ast.Bytes
def safeEval(s, namespace={'True': True, 'False': False, 'None': None}):
    """Evaluates s, safely.  Useful for turning strings into tuples/lists/etc.
    without unsafely using eval()."""
    try:
        node = ast.parse(s)
    except SyntaxError as e:
        raise ValueError('Invalid string: %s.' % e)
    nodes = ast.parse(s).body
    if not nodes:
        if node.__class__ is ast.Module:
            return node.doc
        else:
            raise ValueError(format('Unsafe string: %q', s))
    node = nodes[0]
    def checkNode(node):
        if node.__class__ is ast.Expr:
            node = node.value
        if node.__class__ in (ast.Num,
                              ast.Str,
                              _astStr2):
            return True
        elif node.__class__ in (ast.List,
                              ast.Tuple):
            return all([checkNode(x) for x in node.elts])
        elif node.__class__ is ast.Dict:
            return all([checkNode(x) for x in node.values]) and \
                    all([checkNode(x) for x in node.values])
        elif node.__class__ is ast.Name:
            if node.id in namespace:
                return True
            else:
                return False
        elif sys.version_info[0:2] >= (3, 4) and \
                node.__class__ is ast.NameConstant:
            return True
        else:
            return False
    if checkNode(node):
        return eval(s, namespace, namespace)
    else:
        raise ValueError(format('Unsafe string: %q', s))

def exnToString(e):
    """Turns a simple exception instance into a string (better than str(e))"""
    strE = str(e)
    if strE:
        return '%s: %s' % (e.__class__.__name__, strE)
    else:
        return e.__class__.__name__

class IterableMap(object):
    """Define .iteritems() in a class and subclass this to get the other iters.
    """
    def iteritems(self):
        if sys.version_info[0] >= 3 and hasattr(self, 'iteritems'):
            # For old plugins
            return getattr(self, 'iteritems')() # avoid 2to3
        else:
            raise NotImplementedError()

    def iterkeys(self):
        for (key, _) in self.iteritems():
            yield key

    def itervalues(self):
        for (_, value) in self.iteritems():
            yield value

    if sys.version_info[0] < 3:
        # Our 2to3 fixers automatically rename iteritems/iterkeys/itervalues
        # to items/keys/values
        def items(self):
            return list(self.iteritems())

        def keys(self):
            return list(self.iterkeys())

        def values(self):
            return list(self.itervalues())
        __iter__ = iterkeys
    else:
        __iter__ = items

    def __len__(self):
        ret = 0
        for _ in self.iteritems():
            ret += 1
        return ret

    def __bool__(self):
        for _ in self.iteritems():
            return True
        return False
    __nonzero__ = __bool__


class InsensitivePreservingDict(collections.MutableMapping):
    def key(self, s):
        """Override this if you wish."""
        if s is not None:
            s = s.lower()
        return s

    def __init__(self, dict=None, key=None):
        if key is not None:
            self.key = key
        self.data = {}
        if dict is not None:
            self.update(dict)

    def __repr__(self):
        return '%s(%r)' % (self.__class__.__name__, self.data)

    def fromkeys(cls, keys, s=None, dict=None, key=None):
        d = cls(dict=dict, key=key)
        for key in keys:
            d[key] = s
        return d
    fromkeys = classmethod(fromkeys)

    def __getitem__(self, k):
        return self.data[self.key(k)][1]

    def __setitem__(self, k, v):
        self.data[self.key(k)] = (k, v)

    def __delitem__(self, k):
        del self.data[self.key(k)]

    def __iter__(self):
        return iter(self.data)

    def __len__(self):
        return len(self.data)

    def iteritems(self):
        return self.data.itervalues()

    def keys(self):
        L = []
        for (k, _) in self.iteritems():
            L.append(k)
        return L

    def __reduce__(self):
        return (self.__class__, (dict(self.data.values()),))


class NormalizingSet(set):
    def __init__(self, iterable=()):
        iterable = list(map(self.normalize, iterable))
        super(NormalizingSet, self).__init__(iterable)

    def normalize(self, x):
        return x

    def add(self, x):
        return super(NormalizingSet, self).add(self.normalize(x))

    def remove(self, x):
        return super(NormalizingSet, self).remove(self.normalize(x))

    def discard(self, x):
        return super(NormalizingSet, self).discard(self.normalize(x))

    def __contains__(self, x):
        return super(NormalizingSet, self).__contains__(self.normalize(x))
    has_key = __contains__

def stackTrace(frame=None, compact=True):
    if frame is None:
        frame = sys._getframe()
    if compact:
        L = []
        while frame:
            lineno = frame.f_lineno
            funcname = frame.f_code.co_name
            filename = os.path.basename(frame.f_code.co_filename)
            L.append('[%s|%s|%s]' % (filename, funcname, lineno))
            frame = frame.f_back
        return textwrap.fill(' '.join(L))
    else:
        return traceback.format_stack(frame)

def callTracer(fd=None, basename=True):
    if fd is None:
        fd = sys.stdout
    def tracer(frame, event, _):
        if event == 'call':
            code = frame.f_code
            lineno = frame.f_lineno
            funcname = code.co_name
            filename = code.co_filename
            if basename:
                filename = os.path.basename(filename)
            print('%s: %s(%s)' % (filename, funcname, lineno), file=fd)
    return tracer

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = iter
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from __future__ import division

import sys
import random

from itertools import *

# For old plugins
ifilter = filter
def filterfalse(p, L):
    return filter(lambda x:not p(x), L)
ifilterfalse = filterfalse
imap = map

def len(iterable):
    """Returns the length of an iterator."""
    i = 0
    for _ in iterable:
        i += 1
    return i

def trueCycle(iterable):
    while True:
        yielded = False
        for x in iterable:
            yield x
            yielded = True
        if not yielded:
            raise StopIteration

def partition(p, iterable):
    """Partitions an iterable based on a predicate p.
    Returns a (yes,no) tuple"""
    no = []
    yes = []
    for elt in iterable:
        if p(elt):
            yes.append(elt)
        else:
            no.append(elt)
    return (yes, no)

def any(p, iterable):
    """Returns true if any element in iterable satisfies predicate p."""
    for elt in filter(p, iterable):
        return True
    else:
        return False

def all(p, iterable):
    """Returns true if all elements in iterable satisfy predicate p."""
    for elt in filterfalse(p, iterable):
        return False
    else:
        return True

def choice(iterable):
    if isinstance(iterable, (list, tuple)):
        return random.choice(iterable)
    else:
        n = 1
        found = False
        for x in iterable:
            if random.random() < 1/n:
                ret = x
                found = True
            n += 1
        if not found:
            raise IndexError
        return ret

def flatten(iterable, strings=False):
    """Flattens a list of lists into a single list.  See the test for examples.
    """
    for elt in iterable:
        if not strings and isinstance(elt, basestring):
            yield elt
        else:
            try:
                for x in flatten(elt):
                    yield x
            except TypeError:
                yield elt

def split(isSeparator, iterable, maxsplit=-1, yieldEmpty=False):
    """split(isSeparator, iterable, maxsplit=-1, yieldEmpty=False)

    Splits an iterator based on a predicate isSeparator."""
    if isinstance(isSeparator, basestring):
        f = lambda s: s == isSeparator
    else:
        f = isSeparator
    acc = []
    for element in iterable:
        if maxsplit == 0 or not f(element):
            acc.append(element)
        else:
            maxsplit -= 1
            if acc or yieldEmpty:
                yield acc
            acc = []
    if acc or yieldEmpty:
        yield acc

def ilen(iterable):
    i = 0
    for _ in iterable:
        i += 1
    return i

def startswith(long_, short):
    longI = iter(long_)
    shortI = iter(short)
    try:
        while True:
            if next(shortI) != next(longI):
                return False
    except StopIteration:
        return True

def limited(iterable, limit):
    i = limit
    iterable = iter(iterable)
    try:
        while i:
            yield next(iterable)
            i -= 1
    except StopIteration:
        raise ValueError('Expected %s elements in iterable (%r), got %s.' % \
              (limit, iterable, limit-i))

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = net
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# Copyright (c) 2011, 2013, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

"""
Simple utility modules.
"""

import re
import socket

from .web import _ipAddr, _domain

emailRe = re.compile(r"^(\w&.+-]+!)*[\w&.+-]+@(%s|%s)$" % (_domain, _ipAddr),
                     re.I)

def getAddressFromHostname(host, port=None, attempt=0):
    addrinfo = socket.getaddrinfo(host, port)
    addresses = []
    for (family, socktype, proto, canonname, sockaddr) in addrinfo:
        if sockaddr[0] not in addresses:
            addresses.append(sockaddr[0])
    return addresses[attempt % len(addresses)]

def getSocket(host, port=None, socks_proxy=None, vhost=None, vhostv6=None):
    """Returns a socket of the correct AF_INET type (v4 or v6) in order to
    communicate with host.
    """
    if not socks_proxy:
        addrinfo = socket.getaddrinfo(host, port)
        host = addrinfo[0][4][0]
    if socks_proxy:
        import socks
        s = socks.socksocket()
        hostname, port = socks_proxy.rsplit(':', 1)
        s.setproxy(socks.PROXY_TYPE_SOCKS5, hostname, int(port),
                rdns=True)
        return s
    import supybot.conf as conf
    if isIPV4(host):
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        if not vhost:
            vhost = conf.supybot.protocols.irc.vhost()
        if vhost:
            s.bind((vhost, 0))
        return s
    elif isIPV6(host):
        s = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)
        if not vhostv6:
            vhostv6 = conf.supybot.protocols.irc.vhostv6()
        if vhostv6:
            s.bind((vhostv6, 0))
        return s
    else:
        raise socket.error('Something wonky happened.')

def isIP(s):
    """Returns whether or not a given string is an IP address.

    >>> isIP('255.255.255.255')
    1

    >>> isIP('::1')
    0
    """
    return isIPV4(s) or isIPV6(s)

def isIPV4(s):
    """Returns whether or not a given string is an IPV4 address.

    >>> isIPV4('255.255.255.255')
    1

    >>> isIPV4('abc.abc.abc.abc')
    0
    """
    try:
        return bool(socket.inet_aton(str(s)))
    except socket.error:
        return False

def bruteIsIPV6(s):
    if s.count('::') <= 1:
        L = s.split(':')
        if len(L) <= 8:
            for x in L:
                if x:
                    try:
                        int(x, 16)
                    except ValueError:
                        return False
            return True
    return False

def isIPV6(s):
    """Returns whether or not a given string is an IPV6 address."""
    try:
        if hasattr(socket, 'inet_pton'):
            return bool(socket.inet_pton(socket.AF_INET6, s))
        else:
            return bruteIsIPV6(s)
    except socket.error:
        try:
            socket.inet_pton(socket.AF_INET6, '::')
        except socket.error:
            # We gotta fake it.
            return bruteIsIPV6(s)
        return False

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = python
###
# Copyright (c) 2005-2009, Jeremiah Fincher
# Copyright (c) 2009-2010, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import sys
import types
import fnmatch
import threading
import traceback

def universalImport(*names):
    """Attempt to import the given modules, in order, returning the first
    successfully imported module.  ImportError will be raised, as usual, if
    no imports succeed.  To emulate ``from ModuleA import ModuleB'', pass the
    string 'ModuleA.ModuleB'"""
    f = sys._getframe(1)
    for name in names:
        try:
            # __import__ didn't gain keyword arguments until 2.5
            ret = __import__(name, f.f_globals)
        except ImportError:
            continue
        else:
            if '.' in name:
                parts = name.split('.')[1:]
                while parts:
                    ret = getattr(ret, parts[0])
                    del parts[0]
            return ret
    raise ImportError(','.join(names))

def changeFunctionName(f, name, doc=None):
    if doc is None:
        doc = f.__doc__
    if hasattr(f, '__closure__'):
        closure = f.__closure__
    else:
        # Pypy
        closure = f.func_closure
    newf = types.FunctionType(f.__code__, f.__globals__, name,
                              f.__defaults__, closure)
    newf.__doc__ = doc
    return newf

class Object(object):
    def __ne__(self, other):
        return not self == other

class Synchronized(type):
    METHODS = '__synchronized__'
    LOCK = '_Synchronized_rlock'
    def __new__(cls, name, bases, dict):
        sync = set()
        for base in bases:
            if hasattr(base, Synchronized.METHODS):
                sync.update(getattr(base, Synchronized.METHODS))
        if Synchronized.METHODS in dict:
            sync.update(dict[Synchronized.METHODS])
        if sync:
            def synchronized(f):
                def g(self, *args, **kwargs):
                    lock = getattr(self, Synchronized.LOCK)
                    lock.acquire()
                    try:
                        f(self, *args, **kwargs)
                    finally:
                        lock.release()
                return changeFunctionName(g, f.__name__, f.__doc__)
            for attr in sync:
                if attr in dict:
                    dict[attr] = synchronized(dict[attr])
            original__init__ = dict.get('__init__')
            def __init__(self, *args, **kwargs):
                if not hasattr(self, Synchronized.LOCK):
                    setattr(self, Synchronized.LOCK, threading.RLock())
                if original__init__:
                    original__init__(self, *args, **kwargs)
                else:
                    # newclass is defined below.
                    super(newclass, self).__init__(*args, **kwargs)
            dict['__init__'] = __init__
        newclass = super(Synchronized, cls).__new__(cls, name, bases, dict)
        return newclass

# Translate glob to regular expression, trimming the "match EOL" portion of
# the regular expression.
# Post-2.6 uses \Z(?ms) per http://issues.python.org/6665
def glob2re(g):
    return fnmatch.translate(g)[:-7]


# From http://code.activestate.com/recipes/52215-get-more-information-from-tracebacks/
def collect_extra_debug_data():
    """
    Print the usual traceback information, followed by a listing of all the
    local variables in each frame.
    """
    data = ''
    try:
        tb = sys.exc_info()[2]
        stack = []

        while tb:
            stack.append(tb.tb_frame)
            tb = tb.tb_next
    finally:
        del tb

    try:
        from supybot.version import version
        data += 'Supybot version: %s\n\n' % version
    except:
        data += '(Cannot get Supybot version.)\n\n'

    data += 'Locals by frame, innermost last:\n'
    for frame in stack:
        data += '\n\n'
        data += ('Frame %s in %s at line %s\n' % (frame.f_code.co_name,
                                             frame.f_code.co_filename,
                                             frame.f_lineno))
        frame_locals = frame.f_locals
        for inspected in ('self', 'cls'):
            if inspected in frame_locals:
                if hasattr(frame_locals[inspected], '__dict__') and \
                        frame_locals[inspected].__dict__:
                    for (key, value) in frame_locals[inspected].__dict__.items():
                        frame_locals['%s.%s' % (inspected, key)] = value
        for key, value in frame_locals.items():
            if key == '__builtins__':
                # This is flooding
                continue
            data += ('\t%20s = ' % key)
            #We have to be careful not to cause a new error in our error
            #printer! Calling str() on an unknown object could cause an
            #error we don't want.
            try:
                data += repr(value) + '\n'
            except:
                data += '<ERROR WHILE PRINTING VALUE>\n'
    data += '\n'
    data += '+-----------------------+\n'
    data += '| End of locals display |\n'
    data += '+-----------------------+\n'
    data += '\n'
    return data

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=78:

########NEW FILE########
__FILENAME__ = seq
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

def window(L, size):
    """list * size -> window iterable

    Returns a sliding 'window' through the list L of size size."""
    assert not isinstance(L, int), 'Argument order swapped: window(L, size)'
    if size < 1:
        raise ValueError('size <= 0 disallowed.')
    for i in xrange(len(L) - (size-1)):
        yield L[i:i+size]

def mapinto(f, L):
    for (i, x) in enumerate(L):
        L[i] = f(x)

def renumerate(L):
    for i in xrange(len(L)-1, -1, -1):
        yield (i, L[i])

def dameraulevenshtein(seq1, seq2):
    """Calculate the Damerau-Levenshtein distance between sequences.

    This distance is the number of additions, deletions, substitutions,
    and transpositions needed to transform the first sequence into the
    second. Although generally used with strings, any sequences of
    comparable objects will work.

    Transpositions are exchanges of *consecutive* characters; all other
    operations are self-explanatory.

    This implementation is O(N*M) time and O(M) space, for N and M the
    lengths of the two sequences.

    >>> dameraulevenshtein('ba', 'abc')
    2
    >>> dameraulevenshtein('fee', 'deed')
    2

    It works with arbitrary sequences too:
    >>> dameraulevenshtein('abcd', ['b', 'a', 'c', 'd', 'e'])
    2
    """
    # codesnippet:D0DE4716-B6E6-4161-9219-2903BF8F547F
    # Conceptually, this is based on a len(seq1) + 1 * len(seq2) + 1 matrix.
    # However, only the current and two previous rows are needed at once,
    # so we only store those.
    # Sourced from http://mwh.geek.nz/2009/04/26/python-damerau-levenshtein-distance/
    oneago = None
    thisrow = range(1, len(seq2) + 1) + [0]
    for x in xrange(len(seq1)):
        # Python lists wrap around for negative indices, so put the
        # leftmost column at the *end* of the list. This matches with
        # the zero-indexed strings and saves extra calculation.
        twoago, oneago, thisrow = oneago, thisrow, [0] * len(seq2) + [x + 1]
        for y in xrange(len(seq2)):
            delcost = oneago[y] + 1
            addcost = thisrow[y - 1] + 1
            subcost = oneago[y - 1] + (seq1[x] != seq2[y])
            thisrow[y] = min(delcost, addcost, subcost)
            # This block deals with transpositions
            if (x > 0 and y > 0 and seq1[x] == seq2[y - 1]
                and seq1[x-1] == seq2[y] and seq1[x] != seq2[y]):
                thisrow[y] = min(thisrow[y], twoago[y - 2] + 1)
    return thisrow[len(seq2) - 1]

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:


########NEW FILE########
__FILENAME__ = str
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# Copyright (c) 2008-2009, James McCoy
# Copyright (c) 2010, Valentin Lorentz
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

"""
Simple utility functions related to strings.
"""

import re
import sys
import time
import string
import textwrap

from .iter import all, any
from .structures import TwoWayDictionary

from supybot.i18n import PluginInternationalization
_ = PluginInternationalization()
internationalizeFunction = _.internationalizeFunction

def rsplit(s, sep=None, maxsplit=-1):
    """Equivalent to str.split, except splitting from the right."""
    return s.rsplit(sep, maxsplit)

def normalizeWhitespace(s, removeNewline=True):
    """Normalizes the whitespace in a string; \s+ becomes one space."""
    if not s:
        return str(s) # not the same reference
    starts_with_space = (s[0] in ' \n\t')
    ends_with_space = (s[-1] in ' \n\t')
    if removeNewline:
        s = ' '.join(filter(bool, s.split('\n')))
    s = ' '.join(filter(bool, s.split('\t')))
    s = ' '.join(filter(bool, s.split(' ')))
    if starts_with_space:
        s = ' ' + s
    if ends_with_space:
        s += ' '
    return s

def distance(s, t):
    """Returns the levenshtein edit distance between two strings."""
    n = len(s)
    m = len(t)
    if n == 0:
        return m
    elif m == 0:
        return n
    d = []
    for i in xrange(n+1):
        d.append([])
        for j in xrange(m+1):
            d[i].append(0)
            d[0][j] = j
        d[i][0] = i
    for i in xrange(1, n+1):
        cs = s[i-1]
        for j in xrange(1, m+1):
            ct = t[j-1]
            cost = int(cs != ct)
            d[i][j] = min(d[i-1][j]+1, d[i][j-1]+1, d[i-1][j-1]+cost)
    return d[n][m]

class MultipleReplacer:
    """Return a callable that replaces all dict keys by the associated
    value. More efficient than multiple .replace()."""

    # We use an object instead of a lambda function because it avoids the
    # need for using the staticmethod() on the lambda function if assigning
    # it to a class in Python 3.
    def __init__(self, dict_):
        self._dict = dict_
        dict_ = dict([(re.escape(key), val) for key,val in dict_.items()])
        self._matcher = re.compile('|'.join(dict_.keys()))
    def __call__(self, s):
        return self._matcher.sub(lambda m: self._dict[m.group(0)], s)
def multipleReplacer(dict_):
    return MultipleReplacer(dict_)

class MultipleRemover:
    """Return a callable that removes all words in the list. A bit more
    efficient than multipleReplacer"""
    # See comment of  MultipleReplacer
    def __init__(self, list_):
        list_ = [re.escape(x) for x in list_]
        self._matcher = re.compile('|'.join(list_))
    def __call__(self, s):
        return self._matcher.sub(lambda m: '', s)

_soundextrans = MultipleReplacer(dict(list(zip(string.ascii_uppercase,
                                 '01230120022455012623010202'))))
def soundex(s, length=4):
    """Returns the soundex hash of a given string.

    length=0 doesn't truncate the hash.
    """
    s = s.upper() # Make everything uppercase.
    s = ''.join([x for x in s if x in string.ascii_uppercase])
    if not s:
        raise ValueError('Invalid string for soundex: %s')
    firstChar = s[0] # Save the first character.
    s = _soundextrans(s) # Convert to soundex numbers.
    s = s.lstrip(s[0]) # Remove all repeated first characters.
    L = [firstChar]
    for c in s:
        if c != L[-1]:
            L.append(c)
    L = [c for c in L if c != '0']
    s = ''.join(L)
    if length:
        s = s.ljust(length, '0')[:length]
    return s

def dqrepr(s):
    """Returns a repr() of s guaranteed to be in double quotes."""
    # The wankers-that-be decided not to use double-quotes anymore in 2.3.
    # return '"' + repr("'\x00" + s)[6:]
    encoding = 'string_escape' if sys.version_info[0] < 3 else 'unicode_escape'
    if sys.version_info[0] < 3 and isinstance(s, unicode):
        s = s.encode('utf8', 'replace')
    return '"%s"' % s.encode(encoding).decode().replace('"', '\\"')

def quoted(s):
    """Returns a quoted s."""
    return '"%s"' % s

_openers = '{[(<'
_closers = '}])>'
def _getSep(s, allowBraces=False):
    if len(s) < 2:
        raise ValueError('string given to _getSep is too short: %r' % s)
    if allowBraces:
        braces = _closers
    else:
        braces = _openers + _closers
    if s.startswith('m') or s.startswith('s'):
        separator = s[1]
    else:
        separator = s[0]
    if separator.isalnum() or separator in braces:
        raise ValueError('Invalid separator: separator must not be alphanumeric or in ' \
              '"%s"' % braces)
    return separator

def perlReToPythonRe(s):
    """Converts a string representation of a Perl regular expression (i.e.,
    m/^foo$/i or /foo|bar/) to a Python regular expression.
    """
    opener = closer = _getSep(s, True)
    if opener in '{[(<':
        closer = _closers[_openers.index(opener)]
    opener = re.escape(opener)
    closer = re.escape(closer)
    matcher = re.compile(r'm?%s((?:\\.|[^\\])*)%s(.*)' % (opener, closer))
    try:
        (regexp, flags) = matcher.match(s).groups()
    except AttributeError: # Unpack list of wrong size.
        raise ValueError('Must be of the form m/.../ or /.../')
    regexp = regexp.replace('\\'+opener, opener)
    if opener != closer:
        regexp = regexp.replace('\\'+closer, closer)
    flag = 0
    try:
        for c in flags.upper():
            flag |= getattr(re, c)
    except AttributeError:
        raise ValueError('Invalid flag: %s' % c)
    try:
        return re.compile(regexp, flag)
    except re.error as e:
        raise ValueError(str(e))

def perlReToReplacer(s):
    """Converts a string representation of a Perl regular expression (i.e.,
    s/foo/bar/g or s/foo/bar/i) to a Python function doing the equivalent
    replacement.
    """
    sep = _getSep(s)
    escaped = re.escape(sep)
    matcher = re.compile(r's%s((?:\\.|[^\\])*)%s((?:\\.|[^\\])*)%s(.*)'
                         % (escaped, escaped, escaped))
    try:
        (regexp, replace, flags) = matcher.match(s).groups()
    except AttributeError: # Unpack list of wrong size.
        raise ValueError('Must be of the form s/.../.../')
    regexp = regexp.replace('\x08', r'\b')
    replace = replace.replace('\\'+sep, sep)
    for i in xrange(10):
        replace = replace.replace(chr(i), r'\%s' % i)
    g = False
    if 'g' in flags:
        g = True
        flags = list(filter('g'.__ne__, flags))
    if isinstance(flags, list):
        flags = ''.join(flags)
    r = perlReToPythonRe(sep.join(('', regexp, flags)))
    if g:
        return lambda s: r.sub(replace, s)
    else:
        return lambda s: r.sub(replace, s, 1)

_perlVarSubstituteRe = re.compile(r'\$\{([^}]+)\}|\$([a-zA-Z][a-zA-Z0-9]*)')
def perlVariableSubstitute(vars, text):
    def replacer(m):
        (braced, unbraced) = m.groups()
        var = braced or unbraced
        try:
            x = vars[var]
            if callable(x):
                return x()
            else:
                return str(x)
        except KeyError:
            if braced:
                return '${%s}' % braced
            else:
                return '$' + unbraced
    return _perlVarSubstituteRe.sub(replacer, text)

def commaAndify(seq, comma=',', And=None):
    """Given a a sequence, returns an English clause for that sequence.

    I.e., given [1, 2, 3], returns '1, 2, and 3'
    """
    if And is None:
        And = _('and')
    L = list(seq)
    if len(L) == 0:
        return ''
    elif len(L) == 1:
        return ''.join(L) # We need this because it raises TypeError.
    elif len(L) == 2:
        L.insert(1, And)
        return ' '.join(L)
    else:
        L[-1] = '%s %s' % (And, L[-1])
        sep = '%s ' % comma
        return sep.join(L)

_unCommaTheRe = re.compile(r'(.*),\s*(the)$', re.I)
def unCommaThe(s):
    """Takes a string of the form 'foo, the' and turns it into 'the foo'."""
    m = _unCommaTheRe.match(s)
    if m is not None:
        return '%s %s' % (m.group(2), m.group(1))
    else:
        return s

def ellipsisify(s, n):
    """Returns a shortened version of s.  Produces up to the first n chars at
    the nearest word boundary.
    """
    if len(s) <= n:
        return s
    else:
        return (textwrap.wrap(s, n-3)[0] + '...')

plurals = TwoWayDictionary({})
def matchCase(s1, s2):
    """Matches the case of s1 in s2"""
    if s1.isupper():
        return s2.upper()
    else:
        L = list(s2)
        for (i, char) in enumerate(s1[:len(s2)]):
            if char.isupper():
                L[i] = L[i].upper()
        return ''.join(L)

@internationalizeFunction('pluralize')
def pluralize(s):
    """Returns the plural of s.  Put any exceptions to the general English
    rule of appending 's' in the plurals dictionary.
    """
    consonants = 'bcdfghjklmnpqrstvwxz'
    _pluralizeRegex = re.compile('[%s]y$' % consonants)
    lowered = s.lower()
    # Exception dictionary
    if lowered in plurals:
        return matchCase(s, plurals[lowered])
    # Words ending with 'ch', 'sh' or 'ss' such as 'punch(es)', 'fish(es)
    # and miss(es)
    elif any(lowered.endswith, ['x', 'ch', 'sh', 'ss']):
        return matchCase(s, s+'es')
    # Words ending with a consonant followed by a 'y' such as
    # 'try (tries)' or 'spy (spies)'
    elif _pluralizeRegex.search(lowered):
        return matchCase(s, s[:-1] + 'ies')
    # In all other cases, we simply add an 's' to the base word
    else:
        return matchCase(s, s+'s')

@internationalizeFunction('depluralize')
def depluralize(s):
    """Returns the singular of s."""
    consonants = 'bcdfghjklmnpqrstvwxz'
    _depluralizeRegex = re.compile('[%s]ies' % consonants)
    lowered = s.lower()
    if lowered in plurals:
        return matchCase(s, plurals[lowered])
    elif any(lowered.endswith, ['ches', 'shes', 'sses']):
        return s[:-2]
    elif re.search(_depluralizeRegex, lowered):
        return s[:-3] + 'y'
    else:
        if lowered.endswith('s'):
            return s[:-1] # Chop off 's'.
        else:
            return s # Don't know what to do.

def nItems(n, item, between=None):
    """Works like this:

    >>> nItems(4, '<empty>')
    '4'

    >>> nItems(1, 'clock')
    '1 clock'

    >>> nItems(10, 'clock')
    '10 clocks'

    >>> nItems(4, '<empty>', between='grandfather')
    '4 grandfather'

    >>> nItems(10, 'clock', between='grandfather')
    '10 grandfather clocks'
    """
    assert isinstance(n, int) or isinstance(n, long), \
           'The order of the arguments to nItems changed again, sorry.'
    if item == '<empty>':
        if between is None:
            return format('%s', n)
        else:
            return format('%s %s', n, item)
    if between is None:
        if n != 1:
            return format('%s %p', n, item)
        else:
            return format('%s %s', n, item)
    else:
        if n != 1:
            return format('%s %s %p', n, between, item)
        else:
            return format('%s %s %s', n, between, item)

@internationalizeFunction('ordinal')
def ordinal(i):
    """Returns i + the ordinal indicator for the number.

    Example: ordinal(3) => '3rd'
    """
    i = int(i)
    if i % 100 in (11,12,13):
        return '%sth' % i
    ord = 'th'
    test = i % 10
    if test == 1:
        ord = 'st'
    elif test == 2:
        ord = 'nd'
    elif test == 3:
        ord = 'rd'
    return '%s%s' % (i, ord)

@internationalizeFunction('be')
def be(i):
    """Returns the form of the verb 'to be' based on the number i."""
    if i == 1:
        return 'is'
    else:
        return 'are'

@internationalizeFunction('has')
def has(i):
    """Returns the form of the verb 'to have' based on the number i."""
    if i == 1:
        return 'has'
    else:
        return 'have'

def toBool(s):
    s = s.strip().lower()
    if s in ('true', 'on', 'enable', 'enabled', '1'):
        return True
    elif s in ('false', 'off', 'disable', 'disabled', '0'):
        return False
    else:
        raise ValueError('Invalid string for toBool: %s' % quoted(s))

# When used with Supybot, this is overriden when supybot.conf is loaded
def timestamp(t):
    if t is None:
        t = time.time()
    return time.ctime(t)

_formatRe = re.compile('%((?:\d+)?\.\d+f|[bfhiLnpqrsStTuv%])')
def format(s, *args, **kwargs):
    """w00t.

    %: literal %.
    i: integer
    s: string
    f: float
    r: repr
    b: form of the verb 'to be' (takes an int)
    h: form of the verb 'to have' (takes an int)
    L: commaAndify (takes a list of strings or a tuple of ([strings], and))
    p: pluralize (takes a string)
    q: quoted (takes a string)
    n: nItems (takes a 2-tuple of (n, item) or a 3-tuple of (n, between, item))
    S: returns a human-readable size (takes an int)
    t: time, formatted (takes an int)
    T: time delta, formatted (takes an int)
    u: url, wrapped in braces (this should be configurable at some point)
    v: void : takes one or many arguments, but doesn't display it
       (useful for translation)
    """
    # Note to developers: If you want to add an argument type, do not forget
    # to add the character to the _formatRe regexp or it will be ignored
    # (and hard to debug if you don't know the trick).
    # Of course, you should also document it in the docstring above.
    args = list(args)
    args.reverse() # For more efficient popping.
    def sub(match):
        char = match.group(1)
        if char == 's':
            token = args.pop()
            if isinstance(token, str):
                return token
            elif sys.version_info[0] < 3 and isinstance(token, unicode):
                return token.encode('utf8', 'replace')
            else:
                return str(token)
        elif char == 'i':
            # XXX Improve me!
            return str(args.pop())
        elif char.endswith('f'):
            return ('%'+char) % args.pop()
        elif char == 'b':
            return be(args.pop())
        elif char == 'h':
            return has(args.pop())
        elif char == 'L':
            t = args.pop()
            if isinstance(t, list) or (sys.version_info[0] >= 3 and
                    (isinstance(t, map) or isinstance(t, filter))):
                return commaAndify(t)
            elif isinstance(t, tuple) and len(t) == 2:
                if not isinstance(t[0], list):
                    raise ValueError('Invalid list for %%L in format: %s' % t)
                if not isinstance(t[1], basestring):
                    raise ValueError('Invalid string for %%L in format: %s' % t)
                return commaAndify(t[0], And=t[1])
            else:
                raise ValueError('Invalid value for %%L in format: %s' % t)
        elif char == 'p':
            return pluralize(args.pop())
        elif char == 'q':
            return quoted(args.pop())
        elif char == 'r':
            return repr(args.pop())
        elif char == 'n':
            t = args.pop()
            if not isinstance(t, (tuple, list)):
                raise ValueError('Invalid value for %%n in format: %s' % t)
            if len(t) == 2:
                return nItems(*t)
            elif len(t) == 3:
                return nItems(t[0], t[2], between=t[1])
            else:
                raise ValueError('Invalid value for %%n in format: %s' % t)
        elif char == 'S':
            t = args.pop()
            if not isinstance(t, (int, long)):
                raise ValueError('Invalid value for %%S in format: %s' % t)
            for suffix in ['B','KB','MB','GB','TB']:
                if t < 1024:
                    return "%i%s" % (t, suffix)
                t /= 1024

        elif char == 't':
            return timestamp(args.pop())
        elif char == 'T':
            from gen import timeElapsed
            return timeElapsed(args.pop())
        elif char == 'u':
            import supybot.conf as conf
            url = args.pop()
            if url:
                return conf.supybot.reply.format.url() % url
            else:
                return ''
        elif char == 'v':
            args.pop()
            return ''
        elif char == '%':
            return '%'
        else:
            raise ValueError('Invalid char in sub (in format).')
    try:
        return _formatRe.sub(sub, s)
    except IndexError:
        raise ValueError('Extra format chars in format spec: %r' % s)

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = structures
###
# Copyright (c) 2002-2009, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

"""
Data structures for Python.
"""

import time
import types
import collections


class RingBuffer(object):
    """Class to represent a fixed-size ring buffer."""
    __slots__ = ('L', 'i', 'full', 'maxSize')
    def __init__(self, maxSize, seq=()):
        if maxSize <= 0:
            raise ValueError('maxSize must be > 0.')
        self.maxSize = maxSize
        self.reset()
        for elt in seq:
            self.append(elt)

    def reset(self):
        self.full = False
        self.L = []
        self.i = 0

    def resize(self, size):
        L = list(self)
        i = self.i
        self.reset()
        self.maxSize = size
        for elt in L[i+1:]:
            self.append(elt)
        for elt in L[0:i]:
            self.append(elt)

    def __len__(self):
        return len(self.L)

    def __eq__(self, other):
        if self.__class__ == other.__class__ and \
           self.maxSize == other.maxSize and len(self) == len(other):
            iterator = iter(other)
            for elt in self:
                otherelt = next(iterator)
                if not elt == otherelt:
                    return False
            return True
        return False

    def __bool__(self):
        return len(self) > 0
    __nonzero__ = __bool__

    def __contains__(self, elt):
        return elt in self.L

    def append(self, elt):
        if self.full:
            self.L[self.i] = elt
            self.i += 1
            self.i %= len(self.L)
        elif len(self) == self.maxSize:
            self.full = True
            self.append(elt)
        else:
            self.L.append(elt)

    def extend(self, seq):
        for elt in seq:
            self.append(elt)

    def __getitem__(self, idx):
        if self.full:
            oidx = idx
            if isinstance(oidx, types.SliceType):
                L = []
                for i in xrange(*slice.indices(oidx, len(self))):
                    L.append(self[i])
                return L
            else:
                (m, idx) = divmod(oidx, len(self.L))
                if m and m != -1:
                    raise IndexError(oidx)
                idx = (idx + self.i) % len(self.L)
                return self.L[idx]
        else:
            if isinstance(idx, types.SliceType):
                L = []
                for i in xrange(*slice.indices(idx, len(self))):
                    L.append(self[i])
                return L
            else:
                return self.L[idx]

    def __setitem__(self, idx, elt):
        if self.full:
            oidx = idx
            if isinstance(oidx, types.SliceType):
                range_ = xrange(*slice.indices(oidx, len(self)))
                if len(range_) != len(elt):
                    raise ValueError('seq must be the same length as slice.')
                else:
                    for (i, x) in zip(range_, elt):
                        self[i] = x
            else:
                (m, idx) = divmod(oidx, len(self.L))
                if m and m != -1:
                    raise IndexError(oidx)
                idx = (idx + self.i) % len(self.L)
                self.L[idx] = elt
        else:
            if isinstance(idx, types.SliceType):
                range_ = xrange(*slice.indices(idx, len(self)))
                if len(range_) != len(elt):
                    raise ValueError('seq must be the same length as slice.')
                else:
                    for (i, x) in zip(range_, elt):
                        self[i] = x
            else:
                self.L[idx] = elt

    def __repr__(self):
        return 'RingBuffer(%r, %r)' % (self.maxSize, list(self))

    def __getstate__(self):
        return (self.maxSize, self.full, self.i, self.L)

    def __setstate__(self, state):
        (maxSize, full, i, L) = state
        self.maxSize = maxSize
        self.full = full
        self.i = i
        self.L = L


class queue(object):
    """Queue class for handling large queues.  Queues smaller than 1,000 or so
    elements are probably better served by the smallqueue class.
    """
    __slots__ = ('front', 'back')
    def __init__(self, seq=()):
        self.back = []
        self.front = []
        for elt in seq:
            self.enqueue(elt)

    def reset(self):
        self.back[:] = []
        self.front[:] = []

    def enqueue(self, elt):
        self.back.append(elt)

    def dequeue(self):
        try:
            return self.front.pop()
        except IndexError:
            self.back.reverse()
            self.front = self.back
            self.back = []
            return self.front.pop()

    def peek(self):
        if self.front:
            return self.front[-1]
        else:
            return self.back[0]

    def __len__(self):
        return len(self.front) + len(self.back)

    def __bool__(self):
        return bool(self.back or self.front)
    __nonzero__ = __bool__

    def __contains__(self, elt):
        return elt in self.front or elt in self.back

    def __iter__(self):
        for elt in reversed(self.front):
            yield elt
        for elt in self.back:
            yield elt

    def __eq__(self, other):
        if len(self) == len(other):
            otheriter = iter(other)
            for elt in self:
                otherelt = next(otheriter)
                if not (elt == otherelt):
                    return False
            return True
        else:
            return False

    def __repr__(self):
        return 'queue([%s])' % ', '.join(map(repr, self))

    def __getitem__(self, oidx):
        if len(self) == 0:
            raise IndexError('queue index out of range')
        if isinstance(oidx, types.SliceType):
            L = []
            for i in xrange(*slice.indices(oidx, len(self))):
                L.append(self[i])
            return L
        else:
            (m, idx) = divmod(oidx, len(self))
            if m and m != -1:
                raise IndexError(oidx)
            if len(self.front) > idx:
                return self.front[-(idx+1)]
            else:
                return self.back[(idx-len(self.front))]

    def __setitem__(self, oidx, value):
        if len(self) == 0:
            raise IndexError('queue index out of range')
        if isinstance(oidx, types.SliceType):
            range_ = xrange(*slice.indices(oidx, len(self)))
            if len(range_) != len(value):
                raise ValueError('seq must be the same length as slice.')
            else:
                for i in range_:
                    (m, idx) = divmod(oidx, len(self))
                    if m and m != -1:
                        raise IndexError(oidx)
                for (i, x) in zip(range_, value):
                    self[i] = x
        else:
            (m, idx) = divmod(oidx, len(self))
            if m and m != -1:
                raise IndexError(oidx)
            if len(self.front) > idx:
                self.front[-(idx+1)] = value
            else:
                self.back[idx-len(self.front)] = value

    def __delitem__(self, oidx):
        if isinstance(oidx, types.SliceType):
            range_ = xrange(*slice.indices(oidx, len(self)))
            for i in range_:
                del self[i]
        else:
            (m, idx) = divmod(oidx, len(self))
            if m and m != -1:
                raise IndexError(oidx)
            if len(self.front) > idx:
                del self.front[-(idx+1)]
            else:
                del self.back[idx-len(self.front)]

    def __getstate__(self):
        return (list(self),)

    def __setstate__(self, state):
        (L,) = state
        L.reverse()
        self.front = L
        self.back = []

class smallqueue(list):
    __slots__ = ()
    def enqueue(self, elt):
        self.append(elt)

    def dequeue(self):
        return self.pop(0)

    def peek(self):
        return self[0]

    def __repr__(self):
        return 'smallqueue([%s])' % ', '.join(map(repr, self))

    def reset(self):
        self[:] = []


class TimeoutQueue(object):
    def __init__(self, timeout, queue=None):
        if queue is None:
            queue = smallqueue()
        self.queue = queue
        self.timeout = timeout

    def reset(self):
        self.queue.reset()

    def __repr__(self):
        self._clearOldElements()
        return '%s(timeout=%r, queue=%r)' % (self.__class__.__name__,
                                             self.timeout, self.queue)

    def _getTimeout(self):
        if callable(self.timeout):
            return self.timeout()
        else:
            return self.timeout

    def _clearOldElements(self):
        now = time.time()
        while self.queue and now - self.queue.peek()[0] > self._getTimeout():
            self.queue.dequeue()

    def setTimeout(self, i):
        self.timeout = i

    def enqueue(self, elt, at=None):
        if at is None:
            at = time.time()
        self.queue.enqueue((at, elt))

    def dequeue(self):
        self._clearOldElements()
        return self.queue.dequeue()[1]

    def __iter__(self):
        # We could _clearOldElements here, but what happens if someone stores
        # the resulting generator and elements that should've timed out are
        # yielded?  Hmm?  What happens then, smarty-pants?
        for (t, elt) in self.queue:
            if time.time() - t < self._getTimeout():
                yield elt

    def __len__(self):
        # No dependency on utils.iter
        # return ilen(self)
        self._clearOldElements()
        return len(self.queue)

class MaxLengthQueue(queue):
    __slots__ = ('length',)
    def __init__(self, length, seq=()):
        self.length = length
        queue.__init__(self, seq)

    def __getstate__(self):
        return (self.length, queue.__getstate__(self))

    def __setstate__(self, state):
        (length, q) = state
        self.length = length
        queue.__setstate__(self, q)

    def enqueue(self, elt):
        queue.enqueue(self, elt)
        if len(self) > self.length:
            self.dequeue()


class TwoWayDictionary(dict):
    __slots__ = ()
    def __init__(self, seq=(), **kwargs):
        if hasattr(seq, 'iteritems'):
            seq = seq.iteritems()
        elif hasattr(seq, 'items'):
            seq = seq.items()
        for (key, value) in seq:
            self[key] = value
            self[value] = key
        for (key, value) in kwargs.iteritems():
            self[key] = value
            self[value] = key

    def __setitem__(self, key, value):
        dict.__setitem__(self, key, value)
        dict.__setitem__(self, value, key)

    def __delitem__(self, key):
        value = self[key]
        dict.__delitem__(self, key)
        dict.__delitem__(self, value)


class MultiSet(object):
    def __init__(self, seq=()):
        self.d = {}
        for elt in seq:
            self.add(elt)

    def add(self, elt):
        try:
            self.d[elt] += 1
        except KeyError:
            self.d[elt] = 1

    def remove(self, elt):
        self.d[elt] -= 1
        if not self.d[elt]:
            del self.d[elt]

    def __getitem__(self, elt):
        return self.d[elt]

    def __contains__(self, elt):
        return elt in self.d


class CacheDict(collections.MutableMapping):
    def __init__(self, max, **kwargs):
        self.d = dict(**kwargs)
        self.max = max

    def __getitem__(self, key):
        return self.d[key]

    def __setitem__(self, key, value):
        if len(self.d) >= self.max:
            self.d.clear()
        self.d[key] = value

    def __delitem__(self, key):
        del self.d[key]

    def keys(self):
        return self.d.keys()
    
    def iteritems(self):
        return self.d.iteritems()

    def __iter__(self):
        return iter(self.d)

    def __len__(self):
        return len(self.d)


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = transaction
###
# Copyright (c) 2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

"""
Defines a Transaction class for multi-file transactions.
"""

import os
import shutil
import os.path

from . import error, file as File, python

# 'txn' is used as an abbreviation for 'transaction' in the following source.

class FailedAcquisition(error.Error):
    def __init__(self, txnDir, e=None):
        self.txnDir = txnDir
        msg = 'Could not acquire transaction directory: %s.' % self.txnDir
        error.Error.__init__(self, msg, e)
        
class InProgress(error.Error):
    def __init__(self, inProgress, e=None):
        self.inProgress = inProgress
        msg = 'Transaction appears to be in progress already: %s exists.' % \
              self.inProgress
        error.Error.__init__(self, msg, e)
        

class InvalidCwd(Exception):
    pass
class TransactionMixin(python.Object):
    JOURNAL = 'journal'
    ORIGINALS = 'originals'
    INPROGRESS = '.inProgress'
    REPLACEMENTS = 'replacements'
    # expects a self.dir.  used by Transaction and Rollback.
    def __init__(self, txnDir):
        self.txnDir = txnDir
        self.dir = self.txnDir + self.INPROGRESS
        self._journalName = self.dirize(self.JOURNAL)

    def escape(self, filename):
        return os.path.abspath(filename)[1:]
    
    def dirize(self, *args):
        return os.path.join(self.dir, *args)

    def _original(self, filename):
        return self.dirize(self.ORIGINALS, self.escape(filename))
    
    def _replacement(self, filename):
        return self.dirize(self.REPLACEMENTS, self.escape(filename))
    
    def _checkCwd(self):
        expected = File.contents(self.dirize('cwd'))
        if os.getcwd() != expected:
            raise InvalidCwd(expected)
        
    def _journalCommands(self):
        journal = open(self._journalName)
        for line in journal:
            line = line.rstrip('\n')
            (command, rest) = line.split(None, 1)
            args = rest.split()
            yield (command, args)
        journal.close()
        

class Transaction(TransactionMixin):
    # XXX Transaction needs to be made threadsafe.
    def __init__(self, *args, **kwargs):
        """Transaction(txnDir) -> None

        txnDir is the directory that will hold the transaction's working files
        and such.  If it can't be renamed, there is probably an active
        transaction.
        """
        TransactionMixin.__init__(self, *args, **kwargs)
        if os.path.exists(self.dir):
            raise InProgress(self.dir)
        if not os.path.exists(self.txnDir):
            raise FailedAcquisition(self.txnDir)
        try:
            os.rename(self.txnDir, self.dir)
        except EnvironmentError as e:
            raise FailedAcquisition(self.txnDir, e)
        os.mkdir(self.dirize(self.ORIGINALS))
        os.mkdir(self.dirize(self.REPLACEMENTS))
        self._journal = open(self._journalName, 'a')
        cwd = open(self.dirize('cwd'), 'w')
        cwd.write(os.getcwd())
        cwd.close()

    def _journalCommand(self, command, *args):
        File.writeLine(self._journal,
                       '%s %s' % (command, ' '.join(map(str, args))))
        self._journal.flush()

    def _makeOriginal(self, filename):
        File.copy(filename, self._original(filename))

    # XXX There needs to be a way, given a transaction, to get a
    #     "sub-transaction", which:
    #
    #     1. Doesn't try to grab the txnDir and move it, but instead is just
    #        given the actual directory being used and uses that.
    #     2. Acquires the lock of the original transaction, only releasing it
    #        when its .commit method is called (assuming Transaction is
    #        threadsafe).
    #     3. Has a no-op .commit method (i.e., doesn't commit).
    #
    #     This is so that, for instance, an object with an active Transaction
    #     can give other objects a Transaction-ish object without worrying that
    #     the transaction will be committed, while still allowing those objects
    #     to work properly with real transactions (i.e., they still call
    #     as they would on a normal Transaction, it just has no effect with a
    #     sub-transaction).
    #     The method that returns a subtransaction should be called "child."
    def child(self):
        raise NotImplementedError
    
    # XXX create, replace, etc. return file objects.  This class should keep a
    #     list of such file descriptors and only allow a commit if all of them
    #     are closed.  Trying to commit with open file objects should raise an
    #     exception.
    def create(self, filename):
        """
        Returns a file object for a filename that should be created (with
        the contents as they were written to the filename) when the transaction
        is committed.
        """
        raise NotImplementedError # XXX.

    def mkdir(self, filename):
        raise NotImplementedError # XXX

    def delete(self, filename):
        raise NotImplementedError # XXX

    def replace(self, filename):
        """
        Returns a file object for a filename that should be replaced by the
        contents written to the file object when the transaction is committed.
        """
        self._checkCwd()
        self._makeOriginal(filename)
        self._journalCommand('replace', filename)
        return File.open(self._replacement(filename))

    def append(self, filename):
        self._checkCwd()
        length = os.stat(filename).st_size
        self._journalCommand('append', filename, length)
        replacement = self._replacement(filename)
        File.copy(filename, replacement)
        return open(replacement, 'a')

    def commit(self, removeWhenComplete=True):
        self._journal.close()
        self._checkCwd()
        File.touch(self.dirize('commit'))
        for (command, args) in self._journalCommands():
            methodName = 'commit%s' % command.capitalize()
            getattr(self, methodName)(*args)
        File.touch(self.dirize('committed'))
        if removeWhenComplete:
            shutil.rmtree(self.dir)

    def commitReplace(self, filename):
        shutil.copy(self._replacement(filename), filename)

    def commitAppend(self, filename, length):
        shutil.copy(self._replacement(filename), filename)

    # XXX need to be able to rename files transactionally. (hard; especially
    #     with renames that depend on one another.  It might be easier to do
    #     rename separate from relocate.)


class Rollback(TransactionMixin):
    def rollback(self, removeWhenComplete=True):
        self._checkCwd()
        if not os.path.exists(self.dirize('commit')):
            return # No action taken; commit hadn't begun.
        for (command, args) in self._journalCommands():
            methodName = 'rollback%s' % command.capitalize()
            getattr(self, methodName)(*args)
        if removeWhenComplete:
            shutil.rmtree(self.dir)

    def rollbackReplace(self, filename):
        shutil.copy(self._original(filename), filename)

    def rollbackAppend(self, filename, length):
        fd = open(filename, 'a')
        fd.truncate(int(length))
        fd.close()
        

# vim:set shiftwidth=4 softtabstop=8 expandtab textwidth=78:

########NEW FILE########
__FILENAME__ = web
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# Copyright (c) 2009, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import re
import sys
import base64
import socket
import urllib
import urllib2
import httplib
import urlparse
import htmlentitydefs
from HTMLParser import HTMLParser

sockerrors = (socket.error,)
try:
    sockerrors += (socket.sslerror,)
except AttributeError:
    pass

from .str import normalizeWhitespace

Request = urllib2.Request
urlquote = urllib.quote
urlunquote = urllib.unquote

def urlencode(*args, **kwargs):
    return urllib.urlencode(*args, **kwargs).encode()

class Error(Exception):
    pass

_octet = r'(?:2(?:[0-4]\d|5[0-5])|1\d\d|\d{1,2})'
_ipAddr = r'%s(?:\.%s){3}' % (_octet, _octet)
# Base domain regex off RFC 1034 and 1738
_label = r'[0-9a-z][-0-9a-z]*[0-9a-z]?'
_domain = r'%s(?:\.%s)*\.[0-9a-z][-0-9a-z]+' % (_label, _label)
_urlRe = r'(\w+://(?:\S+@)?(?:%s|%s)(?::\d+)?(?:/[^\])>\s]*)?)' % (_domain,
                                                                   _ipAddr)
urlRe = re.compile(_urlRe, re.I)
_httpUrlRe = r'(https?://(?:\S+@)?(?:%s|%s)(?::\d+)?(?:/[^\])>\s]*)?)' % \
             (_domain, _ipAddr)
httpUrlRe = re.compile(_httpUrlRe, re.I)

REFUSED = 'Connection refused.'
TIMED_OUT = 'Connection timed out.'
UNKNOWN_HOST = 'Unknown host.'
RESET_BY_PEER = 'Connection reset by peer.'
FORBIDDEN = 'Client forbidden from accessing URL.'

def strError(e):
    try:
        n = e.args[0]
    except Exception:
        return str(e)
    if n == 111:
        return REFUSED
    elif n in (110, 10060):
        return TIMED_OUT
    elif n == 104:
        return RESET_BY_PEER
    elif n in (8, 7, 3, 2, -2, -3):
        return UNKNOWN_HOST
    elif n == 403:
        return FORBIDDEN
    else:
        return str(e)

defaultHeaders = {
    'User-agent': 'Mozilla/5.0 (compatible; utils.web python module)'
    }

# Other modules should feel free to replace this with an appropriate
# application-specific function.  Feel free to use a callable here.
proxy = None

def getUrlFd(url, headers=None, data=None, timeout=None):
    """getUrlFd(url, headers=None, data=None, timeout=None)

    Opens the given url and returns a file object.  Headers and data are
    a dict and string, respectively, as per urllib2.Request's arguments."""
    if headers is None:
        headers = defaultHeaders
    try:
        if not isinstance(url, urllib2.Request):
            (scheme, loc, path, query, frag) = urlparse.urlsplit(url)
            (user, host) = urllib.splituser(loc)
            url = urlparse.urlunsplit((scheme, host, path, query, ''))
            request = urllib2.Request(url, headers=headers, data=data)
            if user:
                request.add_header('Authorization',
                                   'Basic %s' % base64.b64encode(user))
        else:
            request = url
            request.add_data(data)
        httpProxy = force(proxy)
        if httpProxy:
            request.set_proxy(httpProxy, 'http')
        fd = urllib2.urlopen(request, timeout=timeout)
        return fd
    except socket.timeout as e:
        raise Error(TIMED_OUT)
    except sockerrors as e:
        raise Error(strError(e))
    except httplib.InvalidURL as e:
        raise Error('Invalid URL: %s' % e)
    except urllib2.HTTPError as e:
        raise Error(strError(e))
    except urllib2.URLError as e:
        raise Error(strError(e.reason))
    # Raised when urllib doesn't recognize the url type
    except ValueError as e:
        raise Error(strError(e))

def getUrl(url, size=None, headers=None, data=None, timeout=None):
    """getUrl(url, size=None, headers=None, data=None, timeout=None)

    Gets a page.  Returns a string that is the page gotten.  Size is an integer
    number of bytes to read from the URL.  Headers and data are dicts as per
    urllib2.Request's arguments."""
    fd = getUrlFd(url, headers=headers, data=data, timeout=timeout)
    try:
        if size is None:
            text = fd.read()
        else:
            text = fd.read(size)
    except socket.timeout as e:
        raise Error(TIMED_OUT)
    fd.close()
    return text

def getDomain(url):
    return urlparse.urlparse(url)[1]

_charset_re = ('<meta[^a-z<>]+charset='
    """(?P<charset>("[^"]+"|'[^']+'))""")
def getEncoding(s):
    try:
        match = re.search(_charset_re, s, re.MULTILINE)
        if match:
            return match.group('charset')[1:-1]
    except:
        match = re.search(_charset_re.encode(), s, re.MULTILINE)
        if match:
            return match.group('charset').decode()[1:-1]

    try:
        import charade.universaldetector
        u = charade.universaldetector.UniversalDetector()
        u.feed(s)
        u.close()
        return u.result['encoding']
    except:
        return None

class HtmlToText(HTMLParser, object):
    """Taken from some eff-bot code on c.l.p."""
    entitydefs = htmlentitydefs.entitydefs.copy()
    entitydefs['nbsp'] = ' '
    def __init__(self, tagReplace=' '):
        self.data = []
        self.tagReplace = tagReplace
        super(HtmlToText, self).__init__()

    def handle_starttag(self, tag, attr):
        self.data.append(self.tagReplace)

    def handle_endtag(self, tag):
        self.data.append(self.tagReplace)

    def handle_data(self, data):
        self.data.append(data)

    def handle_entityref(self, data):
        if data in htmlentitydefs.name2codepoint:
            self.data.append(unichr(htmlentitydefs.name2codepoint[data]))
        elif sys.version_info[0] >= 3 and isinstance(data, bytes):
            self.data.append(data.decode())
        elif sys.version_info[0] < 3 and isinstance(data, str):
            self.data.append(data.decode('utf8', errors='replace'))
        else:
            self.data.append(data)

    def getText(self):
        text = ''.join(self.data).strip()
        return normalizeWhitespace(text)

def htmlToText(s, tagReplace=' '):
    """Turns HTML into text.  tagReplace is a string to replace HTML tags with.
    """
    encoding = getEncoding(s)
    if encoding:
        s = s.decode(encoding)
    else:
        try:
            if sys.version_info[0] < 3 or isinstance(s, bytes):
                s = s.decode('utf8')
        except:
            pass
    x = HtmlToText(tagReplace)
    x.feed(s)
    return x.getText()

def mungeEmail(s):
    s = s.replace('@', ' AT ')
    s = s.replace('.', ' DOT ')
    return s


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:



########NEW FILE########
__FILENAME__ = world
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

"""
Module for general worldly stuff, like global variables and whatnot.
"""

import gc
import os
import sys
import time
import atexit
import select
import threading
import multiprocessing

import re

from . import conf, drivers, ircutils, log, registry

startedAt = time.time() # Just in case it doesn't get set later.

starting = False

mainThread = threading.currentThread()

def isMainThread():
    return mainThread is threading.currentThread()

threadsSpawned = 1 # Starts at one for the initial "thread."

class SupyThread(threading.Thread, object):
    def __init__(self, *args, **kwargs):
        global threadsSpawned
        threadsSpawned += 1
        super(SupyThread, self).__init__(*args, **kwargs)
        log.debug('Spawning thread %q.', self.getName())

processesSpawned = 1 # Starts at one for the initial process.
class SupyProcess(multiprocessing.Process):
    def __init__(self, *args, **kwargs):
        global processesSpawned
        processesSpawned += 1
        super(SupyProcess, self).__init__(*args, **kwargs)
        log.debug('Spawning process %q.', self.name)

if sys.version_info[0:3] == (3, 3, 1) and hasattr(select, 'poll'):
    # http://bugs.python.org/issue17707
    import multiprocessing.connection
    def _poll(fds, timeout):
        if timeout is not None:
            timeout = int(timeout * 1000)  # timeout is in milliseconds
        fd_map = {}
        pollster = select.poll()
        for fd in fds:
            pollster.register(fd, select.POLLIN)
            if hasattr(fd, 'fileno'):
                fd_map[fd.fileno()] = fd
            else:
                fd_map[fd] = fd
        ls = []
        for fd, event in pollster.poll(timeout):
            if event & select.POLLNVAL:
                raise ValueError('invalid file descriptor %i' % fd)
            ls.append(fd_map[fd])
        return ls
    multiprocessing.connection._poll = _poll


commandsProcessed = 0

ircs = [] # A list of all the IRCs.

def getIrc(network):
    network = network.lower()
    for irc in ircs:
        if irc.network.lower() == network:
            return irc
    return None

def _flushUserData():
    userdataFilename = os.path.join(conf.supybot.directories.conf(),
                                    'userdata.conf')
    registry.close(conf.users, userdataFilename)

flushers = [_flushUserData] # A periodic function will flush all these.

registryFilename = None

def flush():
    """Flushes all the registered flushers."""
    for (i, f) in enumerate(flushers):
        try:
            f()
        except Exception as e:
            log.exception('Uncaught exception in flusher #%s (%s):', i, f)

def debugFlush(s=''):
    if conf.supybot.debug.flushVeryOften():
        if s:
            log.debug(s)
        flush()

def upkeep():
    """Does upkeep (like flushing, garbage collection, etc.)"""
    # Just in case, let's clear the exception info.
    try:
        sys.exc_clear()
    except AttributeError:
        # Python 3 does not have sys.exc_clear. The except statement clears
        # the info itself (and we've just entered an except statement)
        pass
    if os.name == 'nt':
        try:
            import msvcrt
            msvcrt.heapmin()
        except ImportError:
            pass
        except IOError: # Win98 sux0rs!
            pass
    if conf.daemonized:
        # If we're daemonized, sys.stdout has been replaced with a StringIO
        # object, so let's see if anything's been printed, and if so, let's
        # log.warning it (things shouldn't be printed, and we're more likely
        # to get bug reports if we make it a warning).
        if not hasattr(sys.stdout, 'getvalue'):
            # Stupid twisted sometimes replaces our stdout with theirs, because
            # "The Twisted Way Is The Right Way" (ha!).  So we're stuck simply
            # returning.
            log.warning('Expected cStringIO as stdout, got %r.', sys.stdout)
            return
        s = sys.stdout.getvalue()
        if s:
            log.warning('Printed to stdout after daemonization: %s', s)
            sys.stdout.seek(0)
            sys.stdout.truncate() # Truncates to current offset.
        s = sys.stderr.getvalue()
        if s:
            log.error('Printed to stderr after daemonization: %s', s)
            sys.stderr.seek(0)
            sys.stderr.truncate() # Truncates to current offset.
    doFlush = conf.supybot.flush() and not starting
    if doFlush:
        flush()
        # This is so registry._cache gets filled.
        # This seems dumb, so we'll try not doing it anymore.
        #if registryFilename is not None:
        #    registry.open(registryFilename)
    if not dying:
        if sys.version_info[0] < 3:
            log.debug('Regexp cache size: %s', len(re._cache))
        log.debug('Pattern cache size: %s', len(ircutils._patternCache))
        log.debug('HostmaskPatternEqual cache size: %s',
                  len(ircutils._hostmaskPatternEqualCache))
        #timestamp = log.timestamp()
        if doFlush:
            log.info('Flushers flushed and garbage collected.')
        else:
            log.info('Garbage collected.')
    collected = gc.collect()
    if gc.garbage:
        log.warning('Noncollectable garbage (file this as a bug on SF.net): %s',
                    gc.garbage)
    return collected

def makeDriversDie():
    """Kills drivers."""
    log.info('Killing Driver objects.')
    for driver in drivers._drivers.itervalues():
        driver.die()

def makeIrcsDie():
    """Kills Ircs."""
    log.info('Killing Irc objects.')
    for irc in ircs[:]:
        if not irc.zombie:
            irc.die()
        else:
            log.debug('Not killing %s, it\'s already a zombie.', irc)

def startDying():
    """Starts dying."""
    log.info('Shutdown initiated.')
    global dying
    dying = True

def finished():
    log.info('Shutdown complete.')

# These are in order; don't reorder them for cosmetic purposes.  The order
# in which they're registered is the reverse order in which they will run.
atexit.register(finished)
atexit.register(upkeep)
atexit.register(makeIrcsDie)
atexit.register(makeDriversDie)
atexit.register(startDying)

##################################################
##################################################
##################################################
## Don't even *think* about messing with these. ##
##################################################
##################################################
##################################################
dying = False
testing = False
starting = False
profiling = False
documenting = False


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test
###
# Copyright (c) 2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import sys
import os.path
import unittest

import supybot.test as test

load = unittest.defaultTestLoader.loadTestsFromModule

GLOBALS = globals()
dirname = os.path.dirname(__file__)
sys.path.append(dirname)
filenames = os.listdir(dirname)
# Uncomment these if you need some consistency in the order these tests run.
# filenames.sort()
# filenames.reverse()
for filename in filenames:
    if filename.startswith('test_') and filename.endswith('.py'):
        name = filename[:-3]
        plugin = __import__(name)
        test.suites.append(load(plugin))

module = None
    

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test_callbacks
# -*- coding: utf8 -*-
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

import supybot.conf as conf
import supybot.utils as utils
import supybot.ircmsgs as ircmsgs
import supybot.callbacks as callbacks

tokenize = callbacks.tokenize


class TokenizerTestCase(SupyTestCase):
    def testEmpty(self):
        self.assertEqual(tokenize(''), [])

    def testNullCharacter(self):
        self.assertEqual(tokenize(utils.str.dqrepr('\0')), ['\0'])

    def testSingleDQInDQString(self):
        self.assertEqual(tokenize('"\\""'), ['"'])

    def testDQsWithBackslash(self):
        self.assertEqual(tokenize('"\\\\"'), ["\\"])

    def testDoubleQuotes(self):
        self.assertEqual(tokenize('"\\"foo\\""'), ['"foo"'])

    def testSingleWord(self):
        self.assertEqual(tokenize('foo'), ['foo'])

    def testMultipleSimpleWords(self):
        words = 'one two three four five six seven eight'.split()
        for i in range(len(words)):
            self.assertEqual(tokenize(' '.join(words[:i])), words[:i])

    def testSingleQuotesNotQuotes(self):
        self.assertEqual(tokenize("it's"), ["it's"])

    def testQuotedWords(self):
        self.assertEqual(tokenize('"foo bar"'), ['foo bar'])
        self.assertEqual(tokenize('""'), [''])
        self.assertEqual(tokenize('foo "" bar'), ['foo', '', 'bar'])
        self.assertEqual(tokenize('foo "bar baz" quux'),
                         ['foo', 'bar baz', 'quux'])

    _testUnicode = """
def testUnicode(self):
    self.assertEqual(tokenize(u'好'), [u'好'])
    self.assertEqual(tokenize(u'"好"'), [u'好'])"""
    if sys.version_info[0] >= 3:
        _testUnicode = _testUnicode.replace("u'", "'")
    exec(_testUnicode)

    def testNesting(self):
        self.assertEqual(tokenize('[]'), [[]])
        self.assertEqual(tokenize('[foo]'), [['foo']])
        self.assertEqual(tokenize('[ foo ]'), [['foo']])
        self.assertEqual(tokenize('foo [bar]'), ['foo', ['bar']])
        self.assertEqual(tokenize('foo bar [baz quux]'),
                         ['foo', 'bar', ['baz', 'quux']])
        try:
            orig = conf.supybot.commands.nested()
            conf.supybot.commands.nested.setValue(False)
            self.assertEqual(tokenize('[]'), ['[]'])
            self.assertEqual(tokenize('[foo]'), ['[foo]'])
            self.assertEqual(tokenize('foo [bar]'), ['foo', '[bar]'])
            self.assertEqual(tokenize('foo bar [baz quux]'),
                             ['foo', 'bar', '[baz', 'quux]'])
        finally:
            conf.supybot.commands.nested.setValue(orig)

    def testError(self):
        self.assertRaises(SyntaxError, tokenize, '[foo') #]
        self.assertRaises(SyntaxError, tokenize, '"foo') #"

    def testPipe(self):
        try:
            conf.supybot.commands.nested.pipeSyntax.setValue(True)
            self.assertRaises(SyntaxError, tokenize, '| foo')
            self.assertRaises(SyntaxError, tokenize, 'foo ||bar')
            self.assertRaises(SyntaxError, tokenize, 'bar |')
            self.assertEqual(tokenize('foo|bar'), ['bar', ['foo']])
            self.assertEqual(tokenize('foo | bar'), ['bar', ['foo']])
            self.assertEqual(tokenize('foo | bar | baz'),
                             ['baz', ['bar',['foo']]])
            self.assertEqual(tokenize('foo bar | baz'),
                             ['baz', ['foo', 'bar']])
            self.assertEqual(tokenize('foo | bar baz'),
                             ['bar', 'baz', ['foo']])
            self.assertEqual(tokenize('foo bar | baz quux'),
                             ['baz', 'quux', ['foo', 'bar']])
        finally:
            conf.supybot.commands.nested.pipeSyntax.setValue(False)
            self.assertEqual(tokenize('foo|bar'), ['foo|bar'])
            self.assertEqual(tokenize('foo | bar'), ['foo', '|', 'bar'])
            self.assertEqual(tokenize('foo | bar | baz'),
                             ['foo', '|', 'bar', '|', 'baz'])
            self.assertEqual(tokenize('foo bar | baz'),
                             ['foo', 'bar', '|', 'baz'])

    def testQuoteConfiguration(self):
        f = callbacks.tokenize
        self.assertEqual(f('[foo]'), [['foo']])
        self.assertEqual(f('"[foo]"'), ['[foo]'])
        try:
            original = conf.supybot.commands.quotes()
            conf.supybot.commands.quotes.setValue('`')
            self.assertEqual(f('[foo]'), [['foo']])
            self.assertEqual(f('`[foo]`'), ['[foo]'])
            conf.supybot.commands.quotes.setValue('\'')
            self.assertEqual(f('[foo]'), [['foo']])
            self.assertEqual(f('\'[foo]\''), ['[foo]'])
            conf.supybot.commands.quotes.setValue('`\'')
            self.assertEqual(f('[foo]'), [['foo']])
            self.assertEqual(f('`[foo]`'), ['[foo]'])
            self.assertEqual(f('[foo]'), [['foo']])
            self.assertEqual(f('\'[foo]\''), ['[foo]'])
        finally:
            conf.supybot.commands.quotes.setValue(original)

    def testBold(self):
        s = '\x02foo\x02'
        self.assertEqual(tokenize(s), [s])
        s = s[:-1] + '\x0f'
        self.assertEqual(tokenize(s), [s])

    def testColor(self):
        s = '\x032,3foo\x03'
        self.assertEqual(tokenize(s), [s])
        s = s[:-1] + '\x0f'
        self.assertEqual(tokenize(s), [s])


class FunctionsTestCase(SupyTestCase):
    def testCanonicalName(self):
        self.assertEqual('foo', callbacks.canonicalName('foo'))
        self.assertEqual('foobar', callbacks.canonicalName('foo-bar'))
        self.assertEqual('foobar', callbacks.canonicalName('foo_bar'))
        self.assertEqual('foobar', callbacks.canonicalName('FOO-bar'))
        self.assertEqual('foobar', callbacks.canonicalName('FOOBAR'))
        self.assertEqual('foobar', callbacks.canonicalName('foo___bar'))
        self.assertEqual('foobar', callbacks.canonicalName('_f_o_o-b_a_r'))
        # The following seems to be a hack for the Karma plugin; I'm not
        # entirely sure that it's completely necessary anymore.
        self.assertEqual('foobar--', callbacks.canonicalName('foobar--'))

    def testAddressed(self):
        oldprefixchars = str(conf.supybot.reply.whenAddressedBy.chars)
        nick = 'supybot'
        conf.supybot.reply.whenAddressedBy.chars.set('~!@')
        inChannel = ['~foo', '@foo', '!foo',
                     '%s: foo' % nick, '%s foo' % nick,
                     '%s: foo' % nick.capitalize(), '%s: foo' % nick.upper()]
        inChannel = [ircmsgs.privmsg('#foo', s) for s in inChannel]
        badmsg = ircmsgs.privmsg('#foo', '%s:foo' % nick)
        self.failIf(callbacks.addressed(nick, badmsg))
        badmsg = ircmsgs.privmsg('#foo', '%s^: foo' % nick)
        self.failIf(callbacks.addressed(nick, badmsg))
        for msg in inChannel:
            self.assertEqual('foo', callbacks.addressed(nick, msg), msg)
        msg = ircmsgs.privmsg(nick, 'foo')
        self.assertEqual('foo', callbacks.addressed(nick, msg))
        conf.supybot.reply.whenAddressedBy.chars.set(oldprefixchars)
        msg = ircmsgs.privmsg('#foo', '%s::::: bar' % nick)
        self.assertEqual('bar', callbacks.addressed(nick, msg))
        msg = ircmsgs.privmsg('#foo', '%s: foo' % nick.upper())
        self.assertEqual('foo', callbacks.addressed(nick, msg))
        badmsg = ircmsgs.privmsg('#foo', '%s`: foo' % nick)
        self.failIf(callbacks.addressed(nick, badmsg))

    def testAddressedReplyWhenNotAddressed(self):
        msg1 = ircmsgs.privmsg('#foo', '@bar')
        msg2 = ircmsgs.privmsg('#foo', 'bar')
        self.assertEqual(callbacks.addressed('blah', msg1), 'bar')
        self.assertEqual(callbacks.addressed('blah', msg2), '')
        try:
            original = conf.supybot.reply.whenNotAddressed()
            conf.supybot.reply.whenNotAddressed.setValue(True)
            # need to recreate the msg objects since the old ones have already
            # been tagged
            msg1 = ircmsgs.privmsg('#foo', '@bar')
            msg2 = ircmsgs.privmsg('#foo', 'bar')
            self.assertEqual(callbacks.addressed('blah', msg1), 'bar')
            self.assertEqual(callbacks.addressed('blah', msg2), 'bar')
        finally:
            conf.supybot.reply.whenNotAddressed.setValue(original)

    def testAddressedWithMultipleNicks(self):
        msg = ircmsgs.privmsg('#foo', 'bar: baz')
        self.assertEqual(callbacks.addressed('bar', msg), 'baz')
        # need to recreate the msg objects since the old ones have already
        # been tagged
        msg = ircmsgs.privmsg('#foo', 'bar: baz')
        self.assertEqual(callbacks.addressed('biff', msg, nicks=['bar']),
                         'baz')

    def testAddressedWithNickAtEnd(self):
        msg = ircmsgs.privmsg('#foo', 'baz, bar')
        self.assertEqual(callbacks.addressed('bar', msg,
                                             whenAddressedByNickAtEnd=True),
                         'baz')

    def testAddressedPrefixCharsTakePrecedenceOverNickAtEnd(self):
        msg = ircmsgs.privmsg('#foo', '@echo foo')
        self.assertEqual(callbacks.addressed('foo', msg,
                                             whenAddressedByNickAtEnd=True,
                                             prefixChars='@'),
                         'echo foo')


    def testReply(self):
        prefix = 'foo!bar@baz'
        channelMsg = ircmsgs.privmsg('#foo', 'bar baz', prefix=prefix)
        nonChannelMsg = ircmsgs.privmsg('supybot', 'bar baz', prefix=prefix)
        self.assertEqual(ircmsgs.privmsg(nonChannelMsg.nick, 'foo'),
                         callbacks.reply(channelMsg, 'foo', private=True))
        self.assertEqual(ircmsgs.privmsg(nonChannelMsg.nick, 'foo'),
                         callbacks.reply(nonChannelMsg, 'foo'))
        self.assertEqual(ircmsgs.privmsg(channelMsg.args[0],
                                         '%s: foo' % channelMsg.nick),
                         callbacks.reply(channelMsg, 'foo'))
        self.assertEqual(ircmsgs.privmsg(channelMsg.args[0],
                                         'foo'),
                         callbacks.reply(channelMsg, 'foo', prefixNick=False))
        self.assertEqual(ircmsgs.notice(nonChannelMsg.nick, 'foo'),
                         callbacks.reply(channelMsg, 'foo',
                                         notice=True, private=True))

    def testReplyTo(self):
        prefix = 'foo!bar@baz'
        msg = ircmsgs.privmsg('#foo', 'bar baz', prefix=prefix)
        self.assertEqual(callbacks.reply(msg, 'blah', to='blah'),
                         ircmsgs.privmsg('#foo', 'blah: blah'))
        self.assertEqual(callbacks.reply(msg, 'blah', to='blah', private=True),
                         ircmsgs.privmsg('blah', 'blah'))

    def testTokenize(self):
        self.assertEqual(callbacks.tokenize(''), [])
        self.assertEqual(callbacks.tokenize('foo'), ['foo'])
        self.assertEqual(callbacks.tokenize('foo'), ['foo'])
        self.assertEqual(callbacks.tokenize('bar [baz]'), ['bar', ['baz']])


class AmbiguityTestCase(PluginTestCase):
    plugins = ('Misc',) # Something so it doesn't complain.
    class Foo(callbacks.Plugin):
        def bar(self, irc, msg, args):
            irc.reply('foo.bar')
    class Bar(callbacks.Plugin):
        def bar(self, irc, msg, args):
            irc.reply('bar.bar')

    def testAmbiguityWithCommandSameNameAsPlugin(self):
        self.irc.addCallback(self.Foo(self.irc))
        self.assertResponse('bar', 'foo.bar')
        self.irc.addCallback(self.Bar(self.irc))
        self.assertResponse('bar', 'bar.bar')

class ProperStringificationOfReplyArgs(PluginTestCase):
    plugins = ('Misc',) # Same as above.
    class NonString(callbacks.Plugin):
        def int(self, irc, msg, args):
            irc.reply(1)
    class ExpectsString(callbacks.Plugin):
        def lower(self, irc, msg, args):
            irc.reply(args[0].lower())

    def test(self):
        self.irc.addCallback(self.NonString(self.irc))
        self.irc.addCallback(self.ExpectsString(self.irc))
        self.assertResponse('expectsstring lower [nonstring int]', '1')

## class PrivmsgTestCaseWithKarma(ChannelPluginTestCase):
##     plugins = ('Utilities', 'Misc', 'Web', 'Karma', 'String')
##     conf.allowEval = True
##     timeout = 2
##     def testSecondInvalidCommandRespondsWithThreadedInvalidCommands(self):
##         try:
##             orig = conf.supybot.plugins.Karma.response()
##             conf.supybot.plugins.Karma.response.setValue(True)
##             self.assertNotRegexp('echo [foo++] [foo++]', 'not a valid')
##             _ = self.irc.takeMsg()
##         finally:
##             conf.supybot.plugins.Karma.response.setValue(orig)

    
class PrivmsgTestCase(ChannelPluginTestCase):
    plugins = ('Utilities', 'Misc', 'Web', 'String')
    conf.allowEval = True
    timeout = 2
    def testEmptySquareBrackets(self):
        self.assertError('echo []')

##     def testHelpNoNameError(self):
##         # This will raise a NameError if some dynamic scoping isn't working
##         self.assertNotError('load Http')
##         self.assertHelp('extension')

    def testMaximumNestingDepth(self):
        original = conf.supybot.commands.nested.maximum()
        try:
            conf.supybot.commands.nested.maximum.setValue(3)
            self.assertResponse('echo foo', 'foo')
            self.assertResponse('echo [echo foo]', 'foo')
            self.assertResponse('echo [echo [echo foo]]', 'foo')
            self.assertResponse('echo [echo [echo [echo foo]]]', 'foo')
            self.assertError('echo [echo [echo [echo [echo foo]]]]')
        finally:
            conf.supybot.commands.nested.maximum.setValue(original)

    def testSimpleReply(self):
        self.assertResponse("eval irc.reply('foo')", 'foo')

    def testSimpleReplyAction(self):
        self.assertResponse("eval irc.reply('foo', action=True)",
                            '\x01ACTION foo\x01')

    def testReplyWithNickPrefix(self):
        self.feedMsg('@len foo')
        m = self.irc.takeMsg()
        self.failUnless(m is not None, 'm: %r' % m)
        self.failUnless(m.args[1].startswith(self.nick))
        try:
            original = conf.supybot.reply.withNickPrefix()
            conf.supybot.reply.withNickPrefix.setValue(False)
            self.feedMsg('@len foobar')
            m = self.irc.takeMsg()
            self.failUnless(m is not None)
            self.failIf(m.args[1].startswith(self.nick))
        finally:
            conf.supybot.reply.withNickPrefix.setValue(original)

    def testErrorPrivateKwarg(self):
        try:
            original = conf.supybot.reply.error.inPrivate()
            conf.supybot.reply.error.inPrivate.setValue(False)
            m = self.getMsg("eval irc.error('foo', private=True)")
            self.failUnless(m, 'No message returned.')
            self.failIf(ircutils.isChannel(m.args[0]))
        finally:
            conf.supybot.reply.error.inPrivate.setValue(original)

    def testErrorNoArgumentIsArgumentError(self):
        self.assertHelp('eval irc.error()')

    def testErrorWithNotice(self):
        try:
            original = conf.supybot.reply.error.withNotice()
            conf.supybot.reply.error.withNotice.setValue(True)
            m = self.getMsg("eval irc.error('foo')")
            self.failUnless(m, 'No message returned.')
            self.failUnless(m.command == 'NOTICE')
        finally:
            conf.supybot.reply.error.withNotice.setValue(original)

    def testErrorReplyPrivate(self):
        try:
            original = str(conf.supybot.reply.error.inPrivate)
            conf.supybot.reply.error.inPrivate.set('False')
            # If this doesn't raise an error, we've got a problem, so the next
            # two assertions shouldn't run.  So we first check that what we
            # expect to error actually does so we don't go on a wild goose
            # chase because our command never errored in the first place :)
            s = 're s/foo/bar baz' # will error; should be "re s/foo/bar/ baz"
            self.assertError(s)
            m = self.getMsg(s)
            self.failUnless(ircutils.isChannel(m.args[0]))
            conf.supybot.reply.error.inPrivate.set('True')
            m = self.getMsg(s)
            self.failIf(ircutils.isChannel(m.args[0]))
        finally:
            conf.supybot.reply.error.inPrivate.set(original)

    # Now for stuff not based on the plugins.
    class First(callbacks.Plugin):
        def firstcmd(self, irc, msg, args):
            """First"""
            irc.reply('foo')

    class Second(callbacks.Plugin):
        def secondcmd(self, irc, msg, args):
            """Second"""
            irc.reply('bar')

    class FirstRepeat(callbacks.Plugin):
        def firstcmd(self, irc, msg, args):
            """FirstRepeat"""
            irc.reply('baz')

    class Third(callbacks.Plugin):
        def third(self, irc, msg, args):
            """Third"""
            irc.reply(' '.join(args))

    def tearDown(self):
        if hasattr(self.First, 'first'):
            del self.First.first
        if hasattr(self.Second, 'second'):
            del self.Second.second
        if hasattr(self.FirstRepeat, 'firstrepeat'):
            del self.FirstRepeat.firstrepeat
        ChannelPluginTestCase.tearDown(self)

    def testDispatching(self):
        self.irc.addCallback(self.First(self.irc))
        self.irc.addCallback(self.Second(self.irc))
        self.assertResponse('firstcmd', 'foo')
        self.assertResponse('secondcmd', 'bar')
        self.assertResponse('first firstcmd', 'foo')
        self.assertResponse('second secondcmd', 'bar')
        self.assertRegexp('first first firstcmd',
                'there is no command named "first" in it')

    def testAmbiguousError(self):
        self.irc.addCallback(self.First(self.irc))
        self.assertNotError('firstcmd')
        self.irc.addCallback(self.FirstRepeat(self.irc))
        self.assertError('firstcmd')
        self.assertError('firstcmd [firstcmd]')
        self.assertNotRegexp('firstcmd', '(foo.*baz|baz.*foo)')
        self.assertResponse('first firstcmd', 'foo')
        self.assertResponse('firstrepeat firstcmd', 'baz')

    def testAmbiguousHelpError(self):
        self.irc.addCallback(self.First(self.irc))
        self.irc.addCallback(self.FirstRepeat(self.irc))
        self.assertError('help first')

    def testHelpDispatching(self):
        self.irc.addCallback(self.First(self.irc))
        self.assertHelp('help firstcmd')
        self.assertHelp('help first firstcmd')
        self.irc.addCallback(self.FirstRepeat(self.irc))
        self.assertError('help firstcmd')
        self.assertRegexp('help first firstcmd', 'First', 0) # no re.I flag.
        self.assertRegexp('help firstrepeat firstcmd', 'FirstRepeat', 0)

    class TwoRepliesFirstAction(callbacks.Plugin):
        def testactionreply(self, irc, msg, args):
            irc.reply('foo', action=True)
            irc.reply('bar') # We're going to check that this isn't an action.

    def testNotActionSecondReply(self):
        self.irc.addCallback(self.TwoRepliesFirstAction(self.irc))
        self.assertAction('testactionreply', 'foo')
        m = self.getMsg(' ')
        self.failIf(m.args[1].startswith('\x01ACTION'))

    def testEmptyNest(self):
        try:
            conf.supybot.reply.whenNotCommand.set('True')
            self.assertError('echo []')
            conf.supybot.reply.whenNotCommand.set('False')
            self.assertResponse('echo []', '[]')
        finally:
            conf.supybot.reply.whenNotCommand.set('False')

    def testDispatcherHelp(self):
        self.assertNotRegexp('help first', r'\(dispatcher')
        self.assertNotRegexp('help first', r'%s')

    def testDefaultCommand(self):
        self.irc.addCallback(self.First(self.irc))
        self.irc.addCallback(self.Third(self.irc))
        self.assertError('first blah')
        self.assertResponse('third foo bar baz', 'foo bar baz')

    def testSyntaxErrorNotEscaping(self):
        self.assertError('load [foo')
        self.assertError('load foo]')

    def testNoEscapingAttributeErrorFromTokenizeWithFirstElementList(self):
        self.assertError('[plugin list] list')

    class InvalidCommand(callbacks.Plugin):
        def invalidCommand(self, irc, msg, tokens):
            irc.reply('foo')

    def testInvalidCommandOneReplyOnly(self):
        try:
            original = str(conf.supybot.reply.whenNotCommand)
            conf.supybot.reply.whenNotCommand.set('True')
            self.assertRegexp('asdfjkl', 'not a valid command')
            self.irc.addCallback(self.InvalidCommand(self.irc))
            self.assertResponse('asdfjkl', 'foo')
            self.assertNoResponse(' ', 2)
        finally:
            conf.supybot.reply.whenNotCommand.set(original)

    class BadInvalidCommand(callbacks.Plugin):
        def invalidCommand(self, irc, msg, tokens):
            s = 'This shouldn\'t keep Misc.invalidCommand from being called'
            raise Exception(s)

    def testBadInvalidCommandDoesNotKillAll(self):
        try:
            original = str(conf.supybot.reply.whenNotCommand)
            conf.supybot.reply.whenNotCommand.set('True')
            self.irc.addCallback(self.BadInvalidCommand(self.irc))
            self.assertRegexp('asdfjkl', 'not a valid command')
        finally:
            conf.supybot.reply.whenNotCommand.set(original)


class PluginRegexpTestCase(PluginTestCase):
    plugins = ()
    class PCAR(callbacks.PluginRegexp):
        def test(self, irc, msg, args):
            "<foo>"
            raise callbacks.ArgumentError
    def testNoEscapingArgumentError(self):
        self.irc.addCallback(self.PCAR(self.irc))
        self.assertResponse('test', 'test <foo>')

class RichReplyMethodsTestCase(PluginTestCase):
    plugins = ('Config',)
    class NoCapability(callbacks.Plugin):
        def error(self, irc, msg, args):
            irc.errorNoCapability('admin')
    def testErrorNoCapability(self):
        self.irc.addCallback(self.NoCapability(self.irc))
        self.assertRegexp('error', 'You don\'t have the admin capability')
        self.assertNotError('config capabilities.private admin')
        self.assertRegexp('error', 'Error: You\'re missing some capability')
        self.assertNotError('config capabilities.private ""')


class SourceNestedPluginTestCase(PluginTestCase):
    plugins = ('Utilities',)
    class E(callbacks.Plugin):
        def f(self, irc, msg, args):
            """takes no arguments

            F
            """
            irc.reply('f')

        def empty(self, irc, msg, args):
            pass

        class g(callbacks.Commands):
            def h(self, irc, msg, args):
                """takes no arguments

                H
                """
                irc.reply('h')

            class i(callbacks.Commands):
                def j(self, irc, msg, args):
                    """takes no arguments

                    J
                    """
                    irc.reply('j')

        class same(callbacks.Commands):
            def same(self, irc, msg, args):
                """takes no arguments

                same
                """
                irc.reply('same')

    def test(self):
        cb = self.E(self.irc)
        self.irc.addCallback(cb)
        self.assertEqual(cb.getCommand(['f']), ['f'])
        self.assertEqual(cb.getCommand(['same']), ['same'])
        self.assertEqual(cb.getCommand(['e', 'f']), ['e', 'f'])
        self.assertEqual(cb.getCommand(['e', 'g', 'h']), ['e', 'g', 'h'])
        self.assertEqual(cb.getCommand(['e', 'g', 'i', 'j']),
                                       ['e', 'g', 'i', 'j'])
        self.assertResponse('e f', 'f')
        self.assertResponse('e same', 'same')
        self.assertResponse('e g h', 'h')
        self.assertResponse('e g i j', 'j')
        self.assertHelp('help f')
        self.assertHelp('help empty')
        self.assertHelp('help same')
        self.assertHelp('help e g h')
        self.assertHelp('help e g i j')
        self.assertRegexp('list e', 'f, g h, g i j, and same')

    def testCommandSameNameAsNestedPlugin(self):
        cb = self.E(self.irc)
        self.irc.addCallback(cb)
        self.assertResponse('e f', 'f') # Just to make sure it was loaded.
        self.assertEqual(cb.getCommand(['e', 'same']), ['e', 'same'])
        self.assertResponse('e same', 'same')


class WithPrivateNoticeTestCase(ChannelPluginTestCase):
    plugins = ('Utilities',)
    class WithPrivateNotice(callbacks.Plugin):
        def normal(self, irc, msg, args):
            irc.reply('should be with private notice')
        def explicit(self, irc, msg, args):
            irc.reply('should not be with private notice',
                      private=False, notice=False)
        def implicit(self, irc, msg, args):
            irc.reply('should be with notice due to private',
                      private=True)
    def test(self):
        self.irc.addCallback(self.WithPrivateNotice(self.irc))
        # Check normal behavior.
        m = self.assertNotError('normal')
        self.failIf(m.command == 'NOTICE')
        self.failUnless(ircutils.isChannel(m.args[0]))
        m = self.assertNotError('explicit')
        self.failIf(m.command == 'NOTICE')
        self.failUnless(ircutils.isChannel(m.args[0]))
        # Check abnormal behavior.
        originalInPrivate = conf.supybot.reply.inPrivate()
        originalWithNotice = conf.supybot.reply.withNotice()
        try:
            conf.supybot.reply.inPrivate.setValue(True)
            conf.supybot.reply.withNotice.setValue(True)
            m = self.assertNotError('normal')
            self.failUnless(m.command == 'NOTICE')
            self.failIf(ircutils.isChannel(m.args[0]))
            m = self.assertNotError('explicit')
            self.failIf(m.command == 'NOTICE')
            self.failUnless(ircutils.isChannel(m.args[0]))
        finally:
            conf.supybot.reply.inPrivate.setValue(originalInPrivate)
            conf.supybot.reply.withNotice.setValue(originalWithNotice)
        orig = conf.supybot.reply.withNoticeWhenPrivate()
        try:
            conf.supybot.reply.withNoticeWhenPrivate.setValue(True)
            m = self.assertNotError('implicit')
            self.failUnless(m.command == 'NOTICE')
            self.failIf(ircutils.isChannel(m.args[0]))
            m = self.assertNotError('normal')
            self.failIf(m.command == 'NOTICE')
            self.failUnless(ircutils.isChannel(m.args[0]))
        finally:
            conf.supybot.reply.withNoticeWhenPrivate.setValue(orig)

    def testWithNoticeWhenPrivateNotChannel(self):
        original = conf.supybot.reply.withNoticeWhenPrivate()
        try:
            conf.supybot.reply.withNoticeWhenPrivate.setValue(True)
            m = self.assertNotError("eval irc.reply('y',to='x',private=True)")
            self.failUnless(m.command == 'NOTICE')
            m = self.getMsg(' ')
            m = self.assertNotError("eval irc.reply('y',to='#x',private=True)")
            self.failIf(m.command == 'NOTICE')
        finally:
            conf.supybot.reply.withNoticeWhenPrivate.setValue(original)

class ProxyTestCase(SupyTestCase):
    def testHashing(self):
        msg = ircmsgs.ping('0')
        irc = irclib.Irc('test')
        proxy = callbacks.SimpleProxy(irc, msg)
        # First one way...
        self.failIf(proxy != irc)
        self.failUnless(proxy == irc)
        self.assertEqual(hash(proxy), hash(irc))
        # Then the other!
        self.failIf(irc != proxy)
        self.failUnless(irc == proxy)
        self.assertEqual(hash(irc), hash(proxy))

        # And now dictionaries...
        d = {}
        d[irc] = 'foo'
        self.failUnless(len(d) == 1)
        self.failUnless(d[irc] == 'foo')
        self.failUnless(d[proxy] == 'foo')
        d[proxy] = 'bar'
        self.failUnless(len(d) == 1)
        self.failUnless(d[irc] == 'bar')
        self.failUnless(d[proxy] == 'bar')
        d[irc] = 'foo'
        self.failUnless(len(d) == 1)
        self.failUnless(d[irc] == 'foo')
        self.failUnless(d[proxy] == 'foo')




# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test_commands
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import sys

from supybot.test import *

from supybot.commands import *
import supybot.conf as conf
import supybot.irclib as irclib
import supybot.ircmsgs as ircmsgs
import supybot.callbacks as callbacks


class CommandsTestCase(SupyTestCase):
    def assertState(self, spec, given, expected, target='test', **kwargs):
        msg = ircmsgs.privmsg(target, 'foo')
        realIrc = getTestIrc()
        realIrc.nick = 'test'
        realIrc.state.supported['chantypes'] = '#'
        irc = callbacks.SimpleProxy(realIrc, msg)
        myspec = Spec(spec, **kwargs)
        state = myspec(irc, msg, given)
        self.assertEqual(state.args, expected,
                         'Expected %r, got %r' % (expected, state.args))

    def assertError(self, spec, given):
        self.assertRaises(callbacks.Error,
                          self.assertState, spec, given, given)

    def assertStateErrored(self, spec, given, target='test', errored=True,
                           **kwargs):
        msg = ircmsgs.privmsg(target, 'foo')
        realIrc = getTestIrc()
        realIrc.nick = 'test'
        realIrc.state.supported['chantypes'] = '#'
        irc = callbacks.SimpleProxy(realIrc, msg)
        myspec = Spec(spec, **kwargs)
        state = myspec(irc, msg, given)
        self.assertEqual(state.errored, errored,
                         'Expected %r, got %r' % (errored, state.errored))


class GeneralContextTestCase(CommandsTestCase):
    def testEmptySpec(self):
        self.assertState([], [], [])

    def testSpecInt(self):
        self.assertState(['int'], ['1'], [1])
        self.assertState(['int', 'int', 'int'], ['1', '2', '3'], [1, 2, 3])
        self.assertError(['int'], ['9e999'])

    def testSpecNick(self):
        strict = conf.supybot.protocols.irc.strictRfc()
        try:
            conf.supybot.protocols.irc.strictRfc.setValue(True)
            self.assertError(['nick'], ['1abc'])
            conf.supybot.protocols.irc.strictRfc.setValue(False)
            self.assertState(['nick'], ['1abc'], ['1abc'])
        finally:
            conf.supybot.protocols.irc.strictRfc.setValue(strict)

    if sys.version_info[0] < 3:
        def testSpecLong(self):
            self.assertState(['long'], ['1'], [long(1)])
            self.assertState(['long', 'long', 'long'], ['1', '2', '3'],
                             [long(1), long(2), long(3)])

    def testRestHandling(self):
        self.assertState([rest(None)], ['foo', 'bar', 'baz'], ['foo bar baz'])

    def testRestRequiresArgs(self):
        self.assertError([rest('something')], [])

    def testOptional(self):
        spec = [optional('int', 999), None]
        self.assertState(spec, ['12', 'foo'], [12, 'foo'])
        self.assertState(spec, ['foo'], [999, 'foo'])

    def testAdditional(self):
        spec = [additional('int', 999)]
        self.assertState(spec, ['12'], [12])
        self.assertState(spec, [], [999])
        self.assertError(spec, ['foo'])

    def testReverse(self):
        spec = [reverse('positiveInt'), 'float', 'text']
        self.assertState(spec, ['-1.0', 'foo', '1'], [1, -1.0, 'foo'])

    def testGetopts(self):
        spec = ['int', getopts({'foo': None, 'bar': 'int'}), 'int']
        self.assertState(spec,
                         ['12', '--foo', 'baz', '--bar', '13', '15'],
                         [12, [('foo', 'baz'), ('bar', 13)], 15])

    def testAny(self):
        self.assertState([any('int')], ['1', '2', '3'], [[1, 2, 3]])
        self.assertState([None, any('int')], ['1', '2', '3'], ['1', [2, 3]])
        self.assertState([any('int')], [], [[]])
        self.assertState([any('int', continueOnError=True), 'text'],
                         ['1', '2', 'test'], [[1, 2], 'test'])

    def testMany(self):
        spec = [many('int')]
        self.assertState(spec, ['1', '2', '3'], [[1, 2, 3]])
        self.assertError(spec, [])

    def testChannelRespectsNetwork(self):
        spec = ['channel', 'text']
        self.assertState(spec, ['#foo', '+s'], ['#foo', '+s'])
        self.assertState(spec, ['+s'], ['#foo', '+s'], target='#foo')

    def testGlob(self):
        spec = ['glob']
        self.assertState(spec, ['foo'], ['*foo*'])
        self.assertState(spec, ['?foo'], ['?foo'])
        self.assertState(spec, ['foo*'], ['foo*'])

    def testGetId(self):
        spec = ['id']
        self.assertState(spec, ['#12'], [12])

    def testCommaList(self):
        spec = [commalist('int')]
        self.assertState(spec, ['12'], [[12]])
        self.assertState(spec, ['12,', '10'], [[12, 10]])
        self.assertState(spec, ['12,11,10,', '9'], [[12, 11, 10, 9]])
        spec.append('int')
        self.assertState(spec, ['12,11,10', '9'], [[12, 11, 10], 9])

    def testLiteral(self):
        spec = [('literal', ['foo', 'bar', 'baz'])]
        self.assertState(spec, ['foo'], ['foo'])
        self.assertState(spec, ['fo'], ['foo'])
        self.assertState(spec, ['f'], ['foo'])
        self.assertState(spec, ['bar'], ['bar'])
        self.assertState(spec, ['baz'], ['baz'])
        self.assertError(spec, ['ba'])

class ConverterTestCase(CommandsTestCase):
    def testUrlAllowsHttps(self):
        url = 'https://foo.bar/baz'
        self.assertState(['url'], [url], [url])
        self.assertState(['httpUrl'], [url], [url])

    def testEmail(self):
        email = 'jemfinch@supybot.com'
        self.assertState(['email'], [email], [email])
        self.assertError(['email'], ['foo'])
        self.assertError(['email'], ['foo@'])
        self.assertError(['email'], ['@foo'])

class FirstTestCase(CommandsTestCase):
    def testRepr(self):
        self.failUnless(repr(first('int')))

    def testFirstConverterFailsAndNotErroredState(self):
        self.assertStateErrored([first('int', 'something')], ['words'],
                                errored=False)

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:


########NEW FILE########
__FILENAME__ = test_dynamicScope
###
# Copyright (c) 2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

class TestDynamic(SupyTestCase):
    def test(self):
        def f(x):
            i = 2
            return g(x)
        def g(y):
            j = 3
            return h(y)
        def h(z):
            self.assertEqual(dynamic.z, z)
            self.assertEqual(dynamic.j, 3)
            self.assertEqual(dynamic.i, 2)
            self.assertEqual(dynamic.y, z)
            self.assertEqual(dynamic.x, z)
            #self.assertRaises(NameError, getattr, dynamic, 'asdfqwerqewr')
            self.assertEqual(dynamic.self, self)
            return z
        self.assertEqual(f(10), 10)

    def testCommonUsage(self):
        foo = 'bar'
        def f():
            foo = dynamic.foo
            self.assertEqual(foo, 'bar')
        f()

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test_firewall
###
# Copyright (c) 2008, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *
from supybot import log

class FirewallTestCase(SupyTestCase):
    def setUp(self):
        log.testing = False

    def tearDown(self):
        log.testing = True

    # Python 3's syntax for metaclasses is incompatible with Python 3 so
    # using Python 3's syntax directly will raise a SyntaxError on Python 2.
    exec("""
class C(%s
    __firewalled__ = {'foo': None}
    class MyException(Exception):
        pass
    def foo(self):
        raise self.MyException()""" %
        ('metaclass=log.MetaFirewall):\n' if sys.version_info[0] >= 3 else
            'object):\n    __metaclass__ = log.MetaFirewall'))

    def testCFooDoesNotRaise(self):
        c = self.C()
        self.assertEqual(c.foo(), None)

    class D(C):
        def foo(self):
            raise self.MyException()

    def testDFooDoesNotRaise(self):
        d = self.D()
        self.assertEqual(d.foo(), None)

    class E(C):
        __firewalled__ = {'bar': None}
        def foo(self):
            raise self.MyException()
        def bar(self):
            raise self.MyException()

    def testEFooDoesNotRaise(self):
        e = self.E()
        self.assertEqual(e.foo(), None)

    def testEBarDoesNotRaise(self):
        e = self.E()
        self.assertEqual(e.bar(), None)

    class F(C):
        __firewalled__ = {'bar': lambda self: 2}
        def bar(self):
            raise self.MyException()

    def testFBarReturns2(self):
        f = self.F()
        self.assertEqual(f.bar(), 2)



# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:


########NEW FILE########
__FILENAME__ = test_format
###
# Copyright (c) 2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

class FormatTestCase(SupyTestCase):
    def test_t_acceptsNone(self):
        self.failUnless(format('%t', None))

    def testFloatingPoint(self):
        self.assertEqual(format('%.2f', 0.12345), '0.12')


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test_i18n
# -*- coding: utf8 -*-
###
# Copyright (c) 2012, Valentin Lorentz
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *
from supybot.commands import wrap
from supybot.i18n import PluginInternationalization, internationalizeDocstring
import supybot.conf as conf

msg_en = 'The operation succeeded.'
msg_fr = 'Opération effectuée avec succès.'

_ = PluginInternationalization()

@internationalizeDocstring
def foo():
    """The operation succeeded."""
    pass

@wrap
def bar():
    """The operation succeeded."""
    pass

class I18nTestCase(SupyTestCase):
    def testPluginInternationalization(self):
        self.assertEqual(_(msg_en), msg_en)
        with conf.supybot.language.context('fr'):
            self.assertEqual(_(msg_en), msg_fr)
        conf.supybot.language.setValue('en')
        self.assertEqual(_(msg_en), msg_en)
        multiline = '%s\n\n%s' % (msg_en, msg_en)
        self.assertEqual(_(multiline), multiline)

    def testDocstring(self):
        self.assertEqual(foo.__doc__, msg_en)
        self.assertEqual(bar.__doc__, msg_en)
        with conf.supybot.language.context('fr'):
            self.assertEqual(foo.__doc__, msg_fr)
            self.assertEqual(bar.__doc__, msg_fr)
        self.assertEqual(foo.__doc__, msg_en)
        self.assertEqual(bar.__doc__, msg_en)

########NEW FILE########
__FILENAME__ = test_ircdb
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

import os
import unittest

import supybot.conf as conf
import supybot.world as world
import supybot.ircdb as ircdb
import supybot.ircutils as ircutils

class IrcdbTestCase(SupyTestCase):
    def setUp(self):
        world.testing = False
        SupyTestCase.setUp(self)

    def tearDown(self):
        world.testing = True
        SupyTestCase.tearDown(self)

class FunctionsTestCase(IrcdbTestCase):
    def testIsAntiCapability(self):
        self.failIf(ircdb.isAntiCapability('foo'))
        self.failIf(ircdb.isAntiCapability('#foo,bar'))
        self.failUnless(ircdb.isAntiCapability('-foo'))
        self.failUnless(ircdb.isAntiCapability('#foo,-bar'))
        self.failUnless(ircdb.isAntiCapability('#foo.bar,-baz'))

    def testIsChannelCapability(self):
        self.failIf(ircdb.isChannelCapability('foo'))
        self.failUnless(ircdb.isChannelCapability('#foo,bar'))
        self.failUnless(ircdb.isChannelCapability('#foo.bar,baz'))
        self.failUnless(ircdb.isChannelCapability('#foo,bar.baz'))

    def testMakeAntiCapability(self):
        self.assertEqual(ircdb.makeAntiCapability('foo'), '-foo')
        self.assertEqual(ircdb.makeAntiCapability('#foo,bar'), '#foo,-bar')

    def testMakeChannelCapability(self):
        self.assertEqual(ircdb.makeChannelCapability('#f', 'b'), '#f,b')
        self.assertEqual(ircdb.makeChannelCapability('#f', '-b'), '#f,-b')

    def testFromChannelCapability(self):
        self.assertEqual(ircdb.fromChannelCapability('#foo,bar'),
                         ['#foo', 'bar'])
        self.assertEqual(ircdb.fromChannelCapability('#foo.bar,baz'),
                         ['#foo.bar', 'baz'])
        self.assertEqual(ircdb.fromChannelCapability('#foo,bar.baz'),
                         ['#foo', 'bar.baz'])

    def testUnAntiCapability(self):
        self.assertEqual(ircdb.unAntiCapability('-bar'), 'bar')
        self.assertEqual(ircdb.unAntiCapability('#foo,-bar'), '#foo,bar')
        self.assertEqual(ircdb.unAntiCapability('#foo.bar,-baz'),
                         '#foo.bar,baz')

    def testInvertCapability(self):
        self.assertEqual(ircdb.invertCapability('bar'), '-bar')
        self.assertEqual(ircdb.invertCapability('-bar'), 'bar')
        self.assertEqual(ircdb.invertCapability('#foo,bar'), '#foo,-bar')
        self.assertEqual(ircdb.invertCapability('#foo,-bar'), '#foo,bar')


class CapabilitySetTestCase(SupyTestCase):
    def testGeneral(self):
        d = ircdb.CapabilitySet()
        self.assertRaises(KeyError, d.check, 'foo')
        d = ircdb.CapabilitySet(('foo',))
        self.failUnless(d.check('foo'))
        self.failIf(d.check('-foo'))
        d.add('bar')
        self.failUnless(d.check('bar'))
        self.failIf(d.check('-bar'))
        d.add('-baz')
        self.failIf(d.check('baz'))
        self.failUnless(d.check('-baz'))
        d.add('-bar')
        self.failIf(d.check('bar'))
        self.failUnless(d.check('-bar'))
        d.remove('-bar')
        self.assertRaises(KeyError, d.check, '-bar')
        self.assertRaises(KeyError, d.check, 'bar')

    def testReprEval(self):
        s = ircdb.UserCapabilitySet()
        self.assertEqual(s, eval(repr(s), ircdb.__dict__, ircdb.__dict__))
        s.add('foo')
        self.assertEqual(s, eval(repr(s), ircdb.__dict__, ircdb.__dict__))
        s.add('bar')
        self.assertEqual(s, eval(repr(s), ircdb.__dict__, ircdb.__dict__))

    def testContains(self):
        s = ircdb.CapabilitySet()
        self.failIf('foo' in s)
        self.failIf('-foo' in s)
        s.add('foo')
        self.failUnless('foo' in s)
        self.failUnless('-foo' in s)
        s.remove('foo')
        self.failIf('foo' in s)
        self.failIf('-foo' in s)
        s.add('-foo')
        self.failUnless('foo' in s)
        self.failUnless('-foo' in s)

    def testCheck(self):
        s = ircdb.CapabilitySet()
        self.assertRaises(KeyError, s.check, 'foo')
        self.assertRaises(KeyError, s.check, '-foo')
        s.add('foo')
        self.failUnless(s.check('foo'))
        self.failIf(s.check('-foo'))
        s.remove('foo')
        self.assertRaises(KeyError, s.check, 'foo')
        self.assertRaises(KeyError, s.check, '-foo')
        s.add('-foo')
        self.failIf(s.check('foo'))
        self.failUnless(s.check('-foo'))
        s.remove('-foo')
        self.assertRaises(KeyError, s.check, 'foo')
        self.assertRaises(KeyError, s.check, '-foo')

    def testAdd(self):
        s = ircdb.CapabilitySet()
        s.add('foo')
        s.add('-foo')
        self.failIf(s.check('foo'))
        self.failUnless(s.check('-foo'))
        s.add('foo')
        self.failUnless(s.check('foo'))
        self.failIf(s.check('-foo'))


class UserCapabilitySetTestCase(SupyTestCase):
    def testOwnerHasAll(self):
        d = ircdb.UserCapabilitySet(('owner',))
        self.failIf(d.check('-foo'))
        self.failUnless(d.check('foo'))

    def testOwnerIsAlwaysPresent(self):
        d = ircdb.UserCapabilitySet()
        self.failUnless('owner' in d)
        self.failUnless('-owner' in d)
        self.failIf(d.check('owner'))
        d.add('owner')
        self.failUnless(d.check('owner'))

    def testReprEval(self):
        s = ircdb.UserCapabilitySet()
        self.assertEqual(s, eval(repr(s), ircdb.__dict__, ircdb.__dict__))
        s.add('foo')
        self.assertEqual(s, eval(repr(s), ircdb.__dict__, ircdb.__dict__))
        s.add('bar')
        self.assertEqual(s, eval(repr(s), ircdb.__dict__, ircdb.__dict__))

    def testOwner(self):
        s = ircdb.UserCapabilitySet()
        s.add('owner')
        self.failUnless('foo' in s)
        self.failUnless('-foo' in s)
        self.failUnless(s.check('owner'))
        self.failIf(s.check('-owner'))
        self.failIf(s.check('-foo'))
        self.failUnless(s.check('foo'))

##     def testWorksAfterReload(self):
##         s = ircdb.UserCapabilitySet(['owner'])
##         self.failUnless(s.check('owner'))
##         import sets
##         reload(sets)
##         self.failUnless(s.check('owner'))


class IrcUserTestCase(IrcdbTestCase):
    def testCapabilities(self):
        u = ircdb.IrcUser()
        u.addCapability('foo')
        self.failUnless(u._checkCapability('foo'))
        self.failIf(u._checkCapability('-foo'))
        u.addCapability('-bar')
        self.failUnless(u._checkCapability('-bar'))
        self.failIf(u._checkCapability('bar'))
        u.removeCapability('foo')
        u.removeCapability('-bar')
        self.assertRaises(KeyError, u._checkCapability, 'foo')
        self.assertRaises(KeyError, u._checkCapability, '-bar')

    def testAddhostmask(self):
        u = ircdb.IrcUser()
        self.assertRaises(ValueError, u.addHostmask, '*!*@*')

    def testRemoveHostmask(self):
        u = ircdb.IrcUser()
        u.addHostmask('foo!bar@baz')
        self.failUnless(u.checkHostmask('foo!bar@baz'))
        u.addHostmask('foo!bar@baz')
        u.removeHostmask('foo!bar@baz')
        self.failIf(u.checkHostmask('foo!bar@baz'))

    def testOwner(self):
        u = ircdb.IrcUser()
        u.addCapability('owner')
        self.failUnless(u._checkCapability('foo'))
        self.failIf(u._checkCapability('-foo'))

    def testInitCapabilities(self):
        u = ircdb.IrcUser(capabilities=['foo'])
        self.failUnless(u._checkCapability('foo'))

    def testPassword(self):
        u = ircdb.IrcUser()
        u.setPassword('foobar')
        self.failUnless(u.checkPassword('foobar'))
        self.failIf(u.checkPassword('somethingelse'))

    def testTimeoutAuth(self):
        orig = conf.supybot.databases.users.timeoutIdentification()
        try:
            conf.supybot.databases.users.timeoutIdentification.setValue(2)
            u = ircdb.IrcUser()
            u.addAuth('foo!bar@baz')
            self.failUnless(u.checkHostmask('foo!bar@baz'))
            time.sleep(2.1)
            self.failIf(u.checkHostmask('foo!bar@baz'))
        finally:
            conf.supybot.databases.users.timeoutIdentification.setValue(orig)

    def testMultipleAuth(self):
        orig = conf.supybot.databases.users.timeoutIdentification()
        try:
            conf.supybot.databases.users.timeoutIdentification.setValue(2)
            u = ircdb.IrcUser()
            u.addAuth('foo!bar@baz')
            self.failUnless(u.checkHostmask('foo!bar@baz'))
            u.addAuth('foo!bar@baz')
            self.failUnless(u.checkHostmask('foo!bar@baz'))
            self.failUnless(len(u.auth) == 1)
            u.addAuth('boo!far@fizz')
            self.failUnless(u.checkHostmask('boo!far@fizz'))
            time.sleep(2.1)
            self.failIf(u.checkHostmask('foo!bar@baz'))
            self.failIf(u.checkHostmask('boo!far@fizz'))
        finally:
            conf.supybot.databases.users.timeoutIdentification.setValue(orig)

    def testHashedPassword(self):
        u = ircdb.IrcUser()
        u.setPassword('foobar', hashed=True)
        self.failUnless(u.checkPassword('foobar'))
        self.failIf(u.checkPassword('somethingelse'))
        self.assertNotEqual(u.password, 'foobar')

    def testHostmasks(self):
        prefix = 'foo12341234!bar@baz.domain.tld'
        hostmasks = ['*!bar@baz.domain.tld', 'foo12341234!*@*']
        u = ircdb.IrcUser()
        self.failIf(u.checkHostmask(prefix))
        for hostmask in hostmasks:
            u.addHostmask(hostmask)
        self.failUnless(u.checkHostmask(prefix))

    def testAuth(self):
        prefix = 'foo!bar@baz'
        u = ircdb.IrcUser()
        u.addAuth(prefix)
        self.failUnless(u.auth)
        u.clearAuth()
        self.failIf(u.auth)

    def testIgnore(self):
        u = ircdb.IrcUser(ignore=True)
        self.failIf(u._checkCapability('foo'))
        self.failUnless(u._checkCapability('-foo'))

    def testRemoveCapability(self):
        u = ircdb.IrcUser(capabilities=('foo',))
        self.assertRaises(KeyError, u.removeCapability, 'bar')

class IrcChannelTestCase(IrcdbTestCase):
    def testInit(self):
        c = ircdb.IrcChannel()
        self.failIf(c._checkCapability('op'))
        self.failIf(c._checkCapability('voice'))
        self.failIf(c._checkCapability('halfop'))
        self.failIf(c._checkCapability('protected'))

    def testCapabilities(self):
        c = ircdb.IrcChannel(defaultAllow=False)
        self.failIf(c._checkCapability('foo'))
        c.addCapability('foo')
        self.failUnless(c._checkCapability('foo'))
        c.removeCapability('foo')
        self.failIf(c._checkCapability('foo'))

    def testDefaultCapability(self):
        c = ircdb.IrcChannel()
        c.setDefaultCapability(False)
        self.failIf(c._checkCapability('foo'))
        self.failUnless(c._checkCapability('-foo'))
        c.setDefaultCapability(True)
        self.failUnless(c._checkCapability('foo'))
        self.failIf(c._checkCapability('-foo'))

    def testLobotomized(self):
        c = ircdb.IrcChannel(lobotomized=True)
        self.failUnless(c.checkIgnored('foo!bar@baz'))

    def testIgnored(self):
        prefix = 'foo!bar@baz'
        banmask = ircutils.banmask(prefix)
        c = ircdb.IrcChannel()
        self.failIf(c.checkIgnored(prefix))
        c.addIgnore(banmask)
        self.failUnless(c.checkIgnored(prefix))
        c.removeIgnore(banmask)
        self.failIf(c.checkIgnored(prefix))
        c.addBan(banmask)
        self.failUnless(c.checkIgnored(prefix))
        c.removeBan(banmask)
        self.failIf(c.checkIgnored(prefix))

class UsersDictionaryTestCase(IrcdbTestCase):
    filename = os.path.join(conf.supybot.directories.conf(),
                            'UsersDictionaryTestCase.conf')
    def setUp(self):
        try:
            os.remove(self.filename)
        except:
            pass
        self.users = ircdb.UsersDictionary()
        IrcdbTestCase.setUp(self)

    def testIterAndNumUsers(self):
        self.assertEqual(self.users.numUsers(), 0)
        u = self.users.newUser()
        hostmask = 'foo!xyzzy@baz.domain.com'
        banmask = ircutils.banmask(hostmask)
        u.addHostmask(banmask)
        u.name = 'foo'
        self.users.setUser(u)
        self.assertEqual(self.users.numUsers(), 1)
        u = self.users.newUser()
        hostmask = 'biff!fladksfj@blakjdsf'
        banmask = ircutils.banmask(hostmask)
        u.addHostmask(banmask)
        u.name = 'biff'
        self.users.setUser(u)
        self.assertEqual(self.users.numUsers(), 2)
        self.users.delUser(2)
        self.assertEqual(self.users.numUsers(), 1)
        self.users.delUser(1)
        self.assertEqual(self.users.numUsers(), 0)

    def testGetSetDelUser(self):
        self.assertRaises(KeyError, self.users.getUser, 'foo')
        self.assertRaises(KeyError,
                          self.users.getUser, 'foo!xyzzy@baz.domain.com')
        u = self.users.newUser()
        hostmask = 'foo!xyzzy@baz.domain.com'
        banmask = ircutils.banmask(hostmask)
        u.addHostmask(banmask)
        u.addHostmask(hostmask)
        u.name = 'foo'
        self.users.setUser(u)
        self.assertEqual(self.users.getUser('foo'), u)
        self.assertEqual(self.users.getUser('FOO'), u)
        self.assertEqual(self.users.getUser(hostmask), u)
        self.assertEqual(self.users.getUser(banmask), u)
        # The UsersDictionary shouldn't allow users to be added whose hostmasks
        # match another user's already in the database.
        u2 = self.users.newUser()
        u2.addHostmask('*!xyzzy@baz.domain.c?m')
        self.assertRaises(ValueError, self.users.setUser, u2)


class CheckCapabilityTestCase(IrcdbTestCase):
    filename = os.path.join(conf.supybot.directories.conf(),
                            'CheckCapabilityTestCase.conf')
    owner = 'owner!owner@owner'
    nothing = 'nothing!nothing@nothing'
    justfoo = 'justfoo!justfoo@justfoo'
    antifoo = 'antifoo!antifoo@antifoo'
    justchanfoo = 'justchanfoo!justchanfoo@justchanfoo'
    antichanfoo = 'antichanfoo!antichanfoo@antichanfoo'
    securefoo = 'securefoo!securefoo@securefoo'
    channel = '#channel'
    cap = 'foo'
    anticap = ircdb.makeAntiCapability(cap)
    chancap = ircdb.makeChannelCapability(channel, cap)
    antichancap = ircdb.makeAntiCapability(chancap)
    chanop = ircdb.makeChannelCapability(channel, 'op')
    channelnothing = ircdb.IrcChannel()
    channelcap = ircdb.IrcChannel()
    channelcap.addCapability(cap)
    channelanticap = ircdb.IrcChannel()
    channelanticap.addCapability(anticap)
    def setUp(self):
        IrcdbTestCase.setUp(self)
        try:
            os.remove(self.filename)
        except:
            pass
        self.users = ircdb.UsersDictionary()
        #self.users.open(self.filename)
        self.channels = ircdb.ChannelsDictionary()
        #self.channels.open(self.filename)

        owner = self.users.newUser()
        owner.name = 'owner'
        owner.addCapability('owner')
        owner.addHostmask(self.owner)
        self.users.setUser(owner)

        nothing = self.users.newUser()
        nothing.name = 'nothing'
        nothing.addHostmask(self.nothing)
        self.users.setUser(nothing)

        justfoo = self.users.newUser()
        justfoo.name = 'justfoo'
        justfoo.addCapability(self.cap)
        justfoo.addHostmask(self.justfoo)
        self.users.setUser(justfoo)

        antifoo = self.users.newUser()
        antifoo.name = 'antifoo'
        antifoo.addCapability(self.anticap)
        antifoo.addHostmask(self.antifoo)
        self.users.setUser(antifoo)

        justchanfoo = self.users.newUser()
        justchanfoo.name = 'justchanfoo'
        justchanfoo.addCapability(self.chancap)
        justchanfoo.addHostmask(self.justchanfoo)
        self.users.setUser(justchanfoo)

        antichanfoo = self.users.newUser()
        antichanfoo.name = 'antichanfoo'
        antichanfoo.addCapability(self.antichancap)
        antichanfoo.addHostmask(self.antichanfoo)
        self.users.setUser(antichanfoo)

        securefoo = self.users.newUser()
        securefoo.name = 'securefoo'
        securefoo.addCapability(self.cap)
        securefoo.secure = True
        securefoo.addHostmask(self.securefoo)
        self.users.setUser(securefoo)

        channel = ircdb.IrcChannel()
        self.channels.setChannel(self.channel, channel)

    def checkCapability(self, hostmask, capability):
        return ircdb.checkCapability(hostmask, capability,
                                     self.users, self.channels)

    def testOwner(self):
        self.failUnless(self.checkCapability(self.owner, self.cap))
        self.failIf(self.checkCapability(self.owner, self.anticap))
        self.failUnless(self.checkCapability(self.owner, self.chancap))
        self.failIf(self.checkCapability(self.owner, self.antichancap))
        self.channels.setChannel(self.channel, self.channelanticap)
        self.failUnless(self.checkCapability(self.owner, self.cap))
        self.failIf(self.checkCapability(self.owner, self.anticap))

    def testNothingAgainstChannel(self):
        self.channels.setChannel(self.channel, self.channelnothing)
        self.assertEqual(self.checkCapability(self.nothing, self.chancap),
                         self.channelnothing.defaultAllow)
        self.channelnothing.defaultAllow = not self.channelnothing.defaultAllow
        self.channels.setChannel(self.channel, self.channelnothing)
        self.assertEqual(self.checkCapability(self.nothing, self.chancap),
                         self.channelnothing.defaultAllow)
        self.channels.setChannel(self.channel, self.channelcap)
        self.failUnless(self.checkCapability(self.nothing, self.chancap))
        self.failIf(self.checkCapability(self.nothing, self.antichancap))
        self.channels.setChannel(self.channel, self.channelanticap)
        self.failIf(self.checkCapability(self.nothing, self.chancap))
        self.failUnless(self.checkCapability(self.nothing, self.antichancap))

    def testNothing(self):
        self.assertEqual(self.checkCapability(self.nothing, self.cap),
                         conf.supybot.capabilities.default())
        self.assertEqual(self.checkCapability(self.nothing, self.anticap),
                         not conf.supybot.capabilities.default())

    def testJustFoo(self):
        self.failUnless(self.checkCapability(self.justfoo, self.cap))
        self.failIf(self.checkCapability(self.justfoo, self.anticap))

    def testAntiFoo(self):
        self.failUnless(self.checkCapability(self.antifoo, self.anticap))
        self.failIf(self.checkCapability(self.antifoo, self.cap))

    def testJustChanFoo(self):
        self.channels.setChannel(self.channel, self.channelnothing)
        self.failUnless(self.checkCapability(self.justchanfoo, self.chancap))
        self.failIf(self.checkCapability(self.justchanfoo, self.antichancap))
        self.channelnothing.defaultAllow = not self.channelnothing.defaultAllow
        self.failUnless(self.checkCapability(self.justchanfoo, self.chancap))
        self.failIf(self.checkCapability(self.justchanfoo, self.antichancap))
        self.channels.setChannel(self.channel, self.channelanticap)
        self.failUnless(self.checkCapability(self.justchanfoo, self.chancap))
        self.failIf(self.checkCapability(self.justchanfoo, self.antichancap))

    def testChanOpCountsAsEverything(self):
        self.channels.setChannel(self.channel, self.channelanticap)
        id = self.users.getUserId('nothing')
        u = self.users.getUser(id)
        u.addCapability(self.chanop)
        self.users.setUser(u)
        self.failUnless(self.checkCapability(self.nothing, self.chancap))
        self.channels.setChannel(self.channel, self.channelnothing)
        self.failUnless(self.checkCapability(self.nothing, self.chancap))
        self.channelnothing.defaultAllow = not self.channelnothing.defaultAllow
        self.failUnless(self.checkCapability(self.nothing, self.chancap))

    def testAntiChanFoo(self):
        self.channels.setChannel(self.channel, self.channelnothing)
        self.failIf(self.checkCapability(self.antichanfoo, self.chancap))
        self.failUnless(self.checkCapability(self.antichanfoo,
                                             self.antichancap))

    def testSecurefoo(self):
        self.failUnless(self.checkCapability(self.securefoo, self.cap))
        id = self.users.getUserId(self.securefoo)
        u = self.users.getUser(id)
        u.addAuth(self.securefoo)
        self.users.setUser(u)
        try:
            originalConfDefaultAllow = conf.supybot.capabilities.default()
            conf.supybot.capabilities.default.set('False')
            self.failIf(self.checkCapability('a' + self.securefoo, self.cap))
        finally:
            conf.supybot.capabilities.default.set(str(originalConfDefaultAllow))


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:


########NEW FILE########
__FILENAME__ = test_irclib
##
# Copyright (c) 2002-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

import copy
import pickle

import supybot.conf as conf
import supybot.irclib as irclib
import supybot.ircmsgs as ircmsgs

# The test framework used to provide these, but not it doesn't.  We'll add
# messages to as we find bugs (if indeed we find bugs).
msgs = []
rawmsgs = []

class IrcMsgQueueTestCase(SupyTestCase):
    mode = ircmsgs.op('#foo', 'jemfinch')
    msg = ircmsgs.privmsg('#foo', 'hey, you')
    msgs = [ircmsgs.privmsg('#foo', str(i)) for i in range(10)]
    kick = ircmsgs.kick('#foo', 'PeterB')
    pong = ircmsgs.pong('123')
    ping = ircmsgs.ping('123')
    topic = ircmsgs.topic('#foo')
    notice = ircmsgs.notice('jemfinch', 'supybot here')
    join = ircmsgs.join('#foo')
    who = ircmsgs.who('#foo')

    def testInit(self):
        q = irclib.IrcMsgQueue([self.msg, self.topic, self.ping])
        self.assertEqual(len(q), 3)

    def testLen(self):
        q = irclib.IrcMsgQueue()
        q.enqueue(self.msg)
        self.assertEqual(len(q), 1)
        q.enqueue(self.mode)
        self.assertEqual(len(q), 2)
        q.enqueue(self.kick)
        self.assertEqual(len(q), 3)
        q.enqueue(self.topic)
        self.assertEqual(len(q), 4)
        q.dequeue()
        self.assertEqual(len(q), 3)
        q.dequeue()
        self.assertEqual(len(q), 2)
        q.dequeue()
        self.assertEqual(len(q), 1)
        q.dequeue()
        self.assertEqual(len(q), 0)

    def testContains(self):
        q = irclib.IrcMsgQueue()
        q.enqueue(self.msg)
        q.enqueue(self.msg)
        q.enqueue(self.msg)
        self.failUnless(self.msg in q)
        q.dequeue()
        self.failUnless(self.msg in q)
        q.dequeue()
        self.failUnless(self.msg in q)
        q.dequeue()
        self.failIf(self.msg in q)

    def testRepr(self):
        q = irclib.IrcMsgQueue()
        self.assertEqual(repr(q), 'IrcMsgQueue([])')
        q.enqueue(self.msg)
        try:
            repr(q)
        except Exception as e:
            self.fail('repr(q) raised an exception: %s' %
                      utils.exnToString(e))

    def testEmpty(self):
        q = irclib.IrcMsgQueue()
        self.failIf(q)

    def testEnqueueDequeue(self):
        q = irclib.IrcMsgQueue()
        q.enqueue(self.msg)
        self.failUnless(q)
        self.assertEqual(self.msg, q.dequeue())
        self.failIf(q)
        q.enqueue(self.msg)
        q.enqueue(self.notice)
        self.assertEqual(self.msg, q.dequeue())
        self.assertEqual(self.notice, q.dequeue())
        for msg in self.msgs:
            q.enqueue(msg)
        for msg in self.msgs:
            self.assertEqual(msg, q.dequeue())

    def testPrioritizing(self):
        q = irclib.IrcMsgQueue()
        q.enqueue(self.msg)
        q.enqueue(self.mode)
        self.assertEqual(self.mode, q.dequeue())
        self.assertEqual(self.msg, q.dequeue())
        q.enqueue(self.msg)
        q.enqueue(self.kick)
        self.assertEqual(self.kick, q.dequeue())
        self.assertEqual(self.msg, q.dequeue())
        q.enqueue(self.ping)
        q.enqueue(self.msgs[0])
        q.enqueue(self.kick)
        q.enqueue(self.msgs[1])
        q.enqueue(self.mode)
        self.assertEqual(self.kick, q.dequeue())
        self.assertEqual(self.mode, q.dequeue())
        self.assertEqual(self.ping, q.dequeue())
        self.assertEqual(self.msgs[0], q.dequeue())
        self.assertEqual(self.msgs[1], q.dequeue())

    def testNoIdenticals(self):
        configVar = conf.supybot.protocols.irc.queuing.duplicates
        original = configVar()
        try:
            configVar.setValue(True)
            q = irclib.IrcMsgQueue()
            q.enqueue(self.msg)
            q.enqueue(self.msg)
            self.assertEqual(self.msg, q.dequeue())
            self.failIf(q)
        finally:
            configVar.setValue(original)

    def testJoinBeforeWho(self):
        q = irclib.IrcMsgQueue()
        q.enqueue(self.join)
        q.enqueue(self.who)
        self.assertEqual(self.join, q.dequeue())
        self.assertEqual(self.who, q.dequeue())
##         q.enqueue(self.who)
##         q.enqueue(self.join)
##         self.assertEqual(self.join, q.dequeue())
##         self.assertEqual(self.who, q.dequeue())

    def testTopicBeforePrivmsg(self):
        q = irclib.IrcMsgQueue()
        q.enqueue(self.msg)
        q.enqueue(self.topic)
        self.assertEqual(self.topic, q.dequeue())
        self.assertEqual(self.msg, q.dequeue())

    def testModeBeforePrivmsg(self):
        q = irclib.IrcMsgQueue()
        q.enqueue(self.msg)
        q.enqueue(self.mode)
        self.assertEqual(self.mode, q.dequeue())
        self.assertEqual(self.msg, q.dequeue())
        q.enqueue(self.mode)
        q.enqueue(self.msg)
        self.assertEqual(self.mode, q.dequeue())
        self.assertEqual(self.msg, q.dequeue())


class ChannelStateTestCase(SupyTestCase):
    def testPickleCopy(self):
        c = irclib.ChannelState()
        self.assertEqual(pickle.loads(pickle.dumps(c)), c)
        c.addUser('jemfinch')
        c1 = pickle.loads(pickle.dumps(c))
        self.assertEqual(c, c1)
        c.removeUser('jemfinch')
        self.failIf('jemfinch' in c.users)
        self.failUnless('jemfinch' in c1.users)

    def testCopy(self):
        c = irclib.ChannelState()
        c.addUser('jemfinch')
        c1 = copy.deepcopy(c)
        c.removeUser('jemfinch')
        self.failIf('jemfinch' in c.users)
        self.failUnless('jemfinch' in c1.users)

    def testAddUser(self):
        c = irclib.ChannelState()
        c.addUser('foo')
        self.failUnless('foo' in c.users)
        self.failIf('foo' in c.ops)
        self.failIf('foo' in c.voices)
        self.failIf('foo' in c.halfops)
        c.addUser('+bar')
        self.failUnless('bar' in c.users)
        self.failUnless('bar' in c.voices)
        self.failIf('bar' in c.ops)
        self.failIf('bar' in c.halfops)
        c.addUser('%baz')
        self.failUnless('baz' in c.users)
        self.failUnless('baz' in c.halfops)
        self.failIf('baz' in c.voices)
        self.failIf('baz' in c.ops)
        c.addUser('@quuz')
        self.failUnless('quuz' in c.users)
        self.failUnless('quuz' in c.ops)
        self.failIf('quuz' in c.halfops)
        self.failIf('quuz' in c.voices)


class IrcStateTestCase(SupyTestCase):
    class FakeIrc:
        nick = 'nick'
        prefix = 'nick!user@host'
    irc = FakeIrc()
    def testKickRemovesChannel(self):
        st = irclib.IrcState()
        st.channels['#foo'] = irclib.ChannelState()
        m = ircmsgs.kick('#foo', self.irc.nick, prefix=self.irc.prefix)
        st.addMsg(self.irc, m)
        self.failIf('#foo' in st.channels)

    def testAddMsgRemovesOpsProperly(self):
        st = irclib.IrcState()
        st.channels['#foo'] = irclib.ChannelState()
        st.channels['#foo'].ops.add('bar')
        m = ircmsgs.mode('#foo', ('-o', 'bar'))
        st.addMsg(self.irc, m)
        self.failIf('bar' in st.channels['#foo'].ops)

    def testNickChangesChangeChannelUsers(self):
        st = irclib.IrcState()
        st.channels['#foo'] = irclib.ChannelState()
        st.channels['#foo'].addUser('@bar')
        self.failUnless('bar' in st.channels['#foo'].users)
        self.failUnless(st.channels['#foo'].isOp('bar'))
        st.addMsg(self.irc, ircmsgs.IrcMsg(':bar!asfd@asdf.com NICK baz'))
        self.failIf('bar' in st.channels['#foo'].users)
        self.failIf(st.channels['#foo'].isOp('bar'))
        self.failUnless('baz' in st.channels['#foo'].users)
        self.failUnless(st.channels['#foo'].isOp('baz'))

    def testHistory(self):
        if len(msgs) < 10:
            return
        maxHistoryLength = conf.supybot.protocols.irc.maxHistoryLength
        with maxHistoryLength.context(10):
            state = irclib.IrcState()
            for msg in msgs:
                try:
                    state.addMsg(self.irc, msg)
                except Exception:
                    pass
                self.failIf(len(state.history) > maxHistoryLength())
            self.assertEqual(len(state.history), maxHistoryLength())
            self.assertEqual(list(state.history),
                             msgs[len(msgs) - maxHistoryLength():])

    def testWasteland005(self):
        state = irclib.IrcState()
        # Here we're testing if PREFIX works without the (ov) there.
        state.addMsg(self.irc, ircmsgs.IrcMsg(':desolate.wasteland.org 005 jemfinch NOQUIT WATCH=128 SAFELIST MODES=6 MAXCHANNELS=10 MAXBANS=100 NICKLEN=30 TOPICLEN=307 KICKLEN=307 CHANTYPES=&# PREFIX=@+ NETWORK=DALnet SILENCE=10 :are available on this server'))
        self.assertEqual(state.supported['prefix']['o'], '@')
        self.assertEqual(state.supported['prefix']['v'], '+')

    def testIRCNet005(self):
        state = irclib.IrcState()
        # Testing IRCNet's misuse of MAXBANS
        state.addMsg(self.irc, ircmsgs.IrcMsg(':irc.inet.tele.dk 005 adkwbot WALLCHOPS KNOCK EXCEPTS INVEX MODES=4 MAXCHANNELS=20 MAXBANS=beI:100 MAXTARGETS=4 NICKLEN=9 TOPICLEN=120 KICKLEN=90 :are supported by this server'))
        self.assertEqual(state.supported['maxbans'], 100)

    def testSupportedUmodes(self):
        state = irclib.IrcState()
        state.addMsg(self.irc, ircmsgs.IrcMsg(':coulomb.oftc.net 004 testnick coulomb.oftc.net hybrid-7.2.2+oftc1.6.8 CDGPRSabcdfgiklnorsuwxyz biklmnopstveI bkloveI'))
        self.assertEqual(state.supported['umodes'], 'CDGPRSabcdfgiklnorsuwxyz')
        self.assertEqual(state.supported['chanmodes'],
                         'biklmnopstveI')

    def testEmptyTopic(self):
        state = irclib.IrcState()
        state.addMsg(self.irc, ircmsgs.topic('#foo'))

    def testPickleCopy(self):
        state = irclib.IrcState()
        self.assertEqual(state, pickle.loads(pickle.dumps(state)))
        for msg in msgs:
            try:
                state.addMsg(self.irc, msg)
            except Exception:
                pass
        self.assertEqual(state, pickle.loads(pickle.dumps(state)))

    def testCopy(self):
        state = irclib.IrcState()
        self.assertEqual(state, state.copy())
        for msg in msgs:
            try:
                state.addMsg(self.irc, msg)
            except Exception:
                pass
        self.assertEqual(state, state.copy())

    def testCopyCopiesChannels(self):
        state = irclib.IrcState()
        stateCopy = state.copy()
        state.channels['#foo'] = None
        self.failIf('#foo' in stateCopy.channels)

    def testJoin(self):
        st = irclib.IrcState()
        st.addMsg(self.irc, ircmsgs.join('#foo', prefix=self.irc.prefix))
        self.failUnless('#foo' in st.channels)
        self.failUnless(self.irc.nick in st.channels['#foo'].users)
        st.addMsg(self.irc, ircmsgs.join('#foo', prefix='foo!bar@baz'))
        self.failUnless('foo' in st.channels['#foo'].users)
        st2 = st.copy()
        st.addMsg(self.irc, ircmsgs.quit(prefix='foo!bar@baz'))
        self.failIf('foo' in st.channels['#foo'].users)
        self.failUnless('foo' in st2.channels['#foo'].users)


    def testEq(self):
        state1 = irclib.IrcState()
        state2 = irclib.IrcState()
        self.assertEqual(state1, state2)
        for msg in msgs:
            try:
                state1.addMsg(self.irc, msg)
                state2.addMsg(self.irc, msg)
                self.assertEqual(state1, state2)
            except Exception:
                pass

    def testHandlesModes(self):
        st = irclib.IrcState()
        st.addMsg(self.irc, ircmsgs.join('#foo', prefix=self.irc.prefix))
        self.failIf('bar' in st.channels['#foo'].ops)
        st.addMsg(self.irc, ircmsgs.op('#foo', 'bar'))
        self.failUnless('bar' in st.channels['#foo'].ops)
        st.addMsg(self.irc, ircmsgs.deop('#foo', 'bar'))
        self.failIf('bar' in st.channels['#foo'].ops)

        self.failIf('bar' in st.channels['#foo'].voices)
        st.addMsg(self.irc, ircmsgs.voice('#foo', 'bar'))
        self.failUnless('bar' in st.channels['#foo'].voices)
        st.addMsg(self.irc, ircmsgs.devoice('#foo', 'bar'))
        self.failIf('bar' in st.channels['#foo'].voices)

        self.failIf('bar' in st.channels['#foo'].halfops)
        st.addMsg(self.irc, ircmsgs.halfop('#foo', 'bar'))
        self.failUnless('bar' in st.channels['#foo'].halfops)
        st.addMsg(self.irc, ircmsgs.dehalfop('#foo', 'bar'))
        self.failIf('bar' in st.channels['#foo'].halfops)

    def testDoModeOnlyChannels(self):
        st = irclib.IrcState()
        self.assert_(st.addMsg(self.irc, ircmsgs.IrcMsg('MODE foo +i')) or 1)


class IrcTestCase(SupyTestCase):
    def setUp(self):
        self.irc = irclib.Irc('test')
        #m = self.irc.takeMsg()
        #self.failUnless(m.command == 'PASS', 'Expected PASS, got %r.' % m)
        m = self.irc.takeMsg()
        self.failUnless(m.command == 'NICK', 'Expected NICK, got %r.' % m)
        m = self.irc.takeMsg()
        self.failUnless(m.command == 'USER', 'Expected USER, got %r.' % m)

    def testPingResponse(self):
        self.irc.feedMsg(ircmsgs.ping('123'))
        self.assertEqual(ircmsgs.pong('123'), self.irc.takeMsg())

    def test433Response(self):
        # This is necessary; it won't change nick if irc.originalName==irc.nick
        self.irc.nick = 'somethingElse'
        self.irc.feedMsg(ircmsgs.IrcMsg('433 * %s :Nickname already in use.' %\
                                        self.irc.nick))
        msg = self.irc.takeMsg()
        self.failUnless(msg.command == 'NICK' and msg.args[0] != self.irc.nick)
        self.irc.feedMsg(ircmsgs.IrcMsg('433 * %s :Nickname already in use.' %\
                                        self.irc.nick))
        msg = self.irc.takeMsg()
        self.failUnless(msg.command == 'NICK' and msg.args[0] != self.irc.nick)

    def testSendBeforeQueue(self):
        while self.irc.takeMsg() is not None:
            self.irc.takeMsg()
        self.irc.queueMsg(ircmsgs.IrcMsg('NOTICE #foo bar'))
        self.irc.sendMsg(ircmsgs.IrcMsg('PRIVMSG #foo yeah!'))
        msg = self.irc.takeMsg()
        self.failUnless(msg.command == 'PRIVMSG')
        msg = self.irc.takeMsg()
        self.failUnless(msg.command == 'NOTICE')

    def testNoMsgLongerThan512(self):
        self.irc.queueMsg(ircmsgs.privmsg('whocares', 'x'*1000))
        msg = self.irc.takeMsg()
        self.failUnless(len(msg) <= 512, 'len(msg) was %s' % len(msg))

    def testReset(self):
        for msg in msgs:
            try:
                self.irc.feedMsg(msg)
            except:
                pass
        self.irc.reset()
        self.failIf(self.irc.fastqueue)
        self.failIf(self.irc.state.history)
        self.failIf(self.irc.state.channels)
        self.failIf(self.irc.outstandingPing)

    def testHistory(self):
        self.irc.reset()
        msg1 = ircmsgs.IrcMsg('PRIVMSG #linux :foo bar baz!')
        self.irc.feedMsg(msg1)
        self.assertEqual(self.irc.state.history[0], msg1)
        msg2 = ircmsgs.IrcMsg('JOIN #sourcereview')
        self.irc.feedMsg(msg2)
        self.assertEqual(list(self.irc.state.history), [msg1, msg2])


class IrcCallbackTestCase(SupyTestCase):
    class FakeIrc:
        pass
    irc = FakeIrc()
    def testName(self):
        class UnnamedIrcCallback(irclib.IrcCallback):
            pass
        unnamed = UnnamedIrcCallback()

        class NamedIrcCallback(irclib.IrcCallback):
            myName = 'foobar'
            def name(self):
                return self.myName
        named = NamedIrcCallback()
        self.assertEqual(unnamed.name(), unnamed.__class__.__name__)
        self.assertEqual(named.name(), named.myName)

    def testDoCommand(self):
        def makeCommand(msg):
            return 'do' + msg.command.capitalize()
        class DoCommandCatcher(irclib.IrcCallback):
            def __init__(self):
                self.L = []
            def __getattr__(self, attr):
                self.L.append(attr)
                return lambda *args: None
        doCommandCatcher = DoCommandCatcher()
        for msg in msgs:
            doCommandCatcher(self.irc, msg)
        commands = list(map(makeCommand, msgs))
        self.assertEqual(doCommandCatcher.L, commands)

    def testFirstCommands(self):
        try:
            originalNick = conf.supybot.nick()
            originalUser = conf.supybot.user()
            originalPassword = conf.supybot.networks.test.password()
            nick = 'nick'
            conf.supybot.nick.setValue(nick)
            user = 'user any user'
            conf.supybot.user.setValue(user)
            expected = [ircmsgs.nick(nick), ircmsgs.user('limnoria', user)]
            irc = irclib.Irc('test')
            msgs = [irc.takeMsg()]
            while msgs[-1] != None:
                msgs.append(irc.takeMsg())
            msgs.pop()
            self.assertEqual(msgs, expected)
            password = 'password'
            conf.supybot.networks.test.password.setValue(password)
            irc = irclib.Irc('test')
            msgs = [irc.takeMsg()]
            while msgs[-1] != None:
                msgs.append(irc.takeMsg())
            msgs.pop()
            expected.insert(0, ircmsgs.password(password))
            self.assertEqual(msgs, expected)
        finally:
            conf.supybot.nick.setValue(originalNick)
            conf.supybot.user.setValue(originalUser)
            conf.supybot.networks.test.password.setValue(originalPassword)

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:


########NEW FILE########
__FILENAME__ = test_ircmsgs
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

import copy
import pickle

import supybot.conf as conf
import supybot.ircmsgs as ircmsgs
import supybot.ircutils as ircutils

# The test framework used to provide these, but not it doesn't.  We'll add
# messages to as we find bugs (if indeed we find bugs).
msgs = []
rawmsgs = []

class IrcMsgTestCase(SupyTestCase):
    def testLen(self):
        for msg in msgs:
            if msg.prefix:
                strmsg = str(msg)
                self.failIf(len(msg) != len(strmsg) and \
                            strmsg.replace(':', '') == strmsg)

    def testRepr(self):
        IrcMsg = ircmsgs.IrcMsg
        for msg in msgs:
            self.assertEqual(msg, eval(repr(msg)))

    def testStr(self):
        for (rawmsg, msg) in zip(rawmsgs, msgs):
            strmsg = str(msg).strip()
            self.failIf(rawmsg != strmsg and \
                        strmsg.replace(':', '') == strmsg)

    def testEq(self):
        for msg in msgs:
            self.assertEqual(msg, msg)
        self.failIf(msgs and msgs[0] == []) # Comparison to unhashable type.

    def testNe(self):
        for msg in msgs:
            self.failIf(msg != msg)

##     def testImmutability(self):
##         s = 'something else'
##         t = ('foo', 'bar', 'baz')
##         for msg in msgs:
##             self.assertRaises(AttributeError, setattr, msg, 'prefix', s)
##             self.assertRaises(AttributeError, setattr, msg, 'nick', s)
##             self.assertRaises(AttributeError, setattr, msg, 'user', s)
##             self.assertRaises(AttributeError, setattr, msg, 'host', s)
##             self.assertRaises(AttributeError, setattr, msg, 'command', s)
##             self.assertRaises(AttributeError, setattr, msg, 'args', t)
##             if msg.args:
##                 def setArgs(msg):
##                     msg.args[0] = s
##                 self.assertRaises(TypeError, setArgs, msg)

    def testInit(self):
        for msg in msgs:
            self.assertEqual(msg, ircmsgs.IrcMsg(prefix=msg.prefix,
                                                 command=msg.command,
                                                 args=msg.args))
            self.assertEqual(msg, ircmsgs.IrcMsg(msg=msg))
        self.assertRaises(ValueError,
                          ircmsgs.IrcMsg,
                          args=('foo', 'bar'),
                          prefix='foo!bar@baz')

    def testPickleCopy(self):
        for msg in msgs:
            self.assertEqual(msg, pickle.loads(pickle.dumps(msg)))
            self.assertEqual(msg, copy.copy(msg))

    def testHashNotZero(self):
        zeroes = 0
        for msg in msgs:
            if hash(msg) == 0:
                zeroes += 1
        self.failIf(zeroes > (len(msgs)/10), 'Too many zero hashes.')

    def testMsgKeywordHandledProperly(self):
        msg = ircmsgs.notice('foo', 'bar')
        msg2 = ircmsgs.IrcMsg(msg=msg, command='PRIVMSG')
        self.assertEqual(msg2.command, 'PRIVMSG')
        self.assertEqual(msg2.args, msg.args)

    def testMalformedIrcMsgRaised(self):
        self.assertRaises(ircmsgs.MalformedIrcMsg, ircmsgs.IrcMsg, ':foo')
        self.assertRaises(ircmsgs.MalformedIrcMsg, ircmsgs.IrcMsg,
                          args=('biff',), prefix='foo!bar@baz')

    def testTags(self):
        m = ircmsgs.privmsg('foo', 'bar')
        self.failIf(m.repliedTo)
        m.tag('repliedTo')
        self.failUnless(m.repliedTo)
        m.tag('repliedTo')
        self.failUnless(m.repliedTo)
        m.tag('repliedTo', 12)
        self.assertEqual(m.repliedTo, 12)

class FunctionsTestCase(SupyTestCase):
    def testIsAction(self):
        L = [':jemfinch!~jfincher@ts26-2.homenet.ohio-state.edu PRIVMSG'
             ' #sourcereview :ACTION does something',
             ':supybot!~supybot@underthemain.net PRIVMSG #sourcereview '
             ':ACTION beats angryman senseless with a Unix manual (#2)',
             ':supybot!~supybot@underthemain.net PRIVMSG #sourcereview '
             ':ACTION beats ang senseless with a 50lb Unix manual (#2)',
             ':supybot!~supybot@underthemain.net PRIVMSG #sourcereview '
             ':ACTION resizes angryman\'s terminal to 40x24 (#16)']
        msgs = list(map(ircmsgs.IrcMsg, L))
        for msg in msgs:
            self.failUnless(ircmsgs.isAction(msg))

    def testIsActionIsntStupid(self):
        m = ircmsgs.privmsg('#x', '\x01NOTANACTION foo\x01')
        self.failIf(ircmsgs.isAction(m))
        m = ircmsgs.privmsg('#x', '\x01ACTION foo bar\x01')
        self.failUnless(ircmsgs.isAction(m))

    def testIsCtcp(self):
        self.failUnless(ircmsgs.isCtcp(ircmsgs.privmsg('foo',
                                                       '\x01VERSION\x01')))
        self.failIf(ircmsgs.isCtcp(ircmsgs.privmsg('foo', '\x01')))

    def testIsActionFalseWhenNoSpaces(self):
        msg = ircmsgs.IrcMsg('PRIVMSG #foo :\x01ACTIONfoobar\x01')
        self.failIf(ircmsgs.isAction(msg))

    def testUnAction(self):
        s = 'foo bar baz'
        msg = ircmsgs.action('#foo', s)
        self.assertEqual(ircmsgs.unAction(msg), s)

    def testPrivmsg(self):
        self.assertEqual(str(ircmsgs.privmsg('foo', 'bar')),
                'PRIVMSG foo :bar\r\n')
        self.assertEqual(str(ircmsgs.privmsg('foo,bar', 'baz')),
                'PRIVMSG foo,bar :baz\r\n')

    def testWhois(self):
        with conf.supybot.protocols.irc.strictRfc.context(True):
            self.assertEqual(str(ircmsgs.whois('foo')), 'WHOIS :foo\r\n')
            self.assertEqual(str(ircmsgs.whois('foo,bar')), 'WHOIS :foo,bar\r\n')
            self.assertRaises(AssertionError, ircmsgs.whois, '#foo')
            self.assertRaises(AssertionError, ircmsgs.whois, 'foo,#foo')

    def testBan(self):
        channel = '#osu'
        ban = '*!*@*.edu'
        exception = '*!*@*ohio-state.edu'
        noException = ircmsgs.ban(channel, ban)
        self.assertEqual(ircutils.separateModes(noException.args[1:]),
                         [('+b', ban)])
        withException = ircmsgs.ban(channel, ban, exception)
        self.assertEqual(ircutils.separateModes(withException.args[1:]),
                         [('+b', ban), ('+e', exception)])

    def testBans(self):
        channel = '#osu'
        bans = ['*!*@*', 'jemfinch!*@*']
        exceptions = ['*!*@*ohio-state.edu']
        noException = ircmsgs.bans(channel, bans)
        self.assertEqual(ircutils.separateModes(noException.args[1:]),
                         [('+b', bans[0]), ('+b', bans[1])])
        withExceptions = ircmsgs.bans(channel, bans, exceptions)
        self.assertEqual(ircutils.separateModes(withExceptions.args[1:]),
                         [('+b', bans[0]), ('+b', bans[1]),
                          ('+e', exceptions[0])])

    def testUnban(self):
        channel = '#supybot'
        ban = 'foo!bar@baz'
        self.assertEqual(str(ircmsgs.unban(channel, ban)),
                         'MODE %s -b :%s\r\n' % (channel, ban))

    def testJoin(self):
        channel = '#osu'
        key = 'michiganSucks'
        self.assertEqual(ircmsgs.join(channel).args, ('#osu',))
        self.assertEqual(ircmsgs.join(channel, key).args,
                         ('#osu', 'michiganSucks'))

    def testJoins(self):
        channels = ['#osu', '#umich']
        keys = ['michiganSucks', 'osuSucks']
        self.assertEqual(ircmsgs.joins(channels).args, ('#osu,#umich',))
        self.assertEqual(ircmsgs.joins(channels, keys).args,
                         ('#osu,#umich', 'michiganSucks,osuSucks'))
        keys.pop()
        self.assertEqual(ircmsgs.joins(channels, keys).args,
                         ('#osu,#umich', 'michiganSucks'))

    def testQuit(self):
        self.failUnless(ircmsgs.quit(prefix='foo!bar@baz'))

    def testOps(self):
        m = ircmsgs.ops('#foo', ['foo', 'bar', 'baz'])
        self.assertEqual(str(m), 'MODE #foo +ooo foo bar :baz\r\n')

    def testDeops(self):
        m = ircmsgs.deops('#foo', ['foo', 'bar', 'baz'])
        self.assertEqual(str(m), 'MODE #foo -ooo foo bar :baz\r\n')

    def testVoices(self):
        m = ircmsgs.voices('#foo', ['foo', 'bar', 'baz'])
        self.assertEqual(str(m), 'MODE #foo +vvv foo bar :baz\r\n')

    def testDevoices(self):
        m = ircmsgs.devoices('#foo', ['foo', 'bar', 'baz'])
        self.assertEqual(str(m), 'MODE #foo -vvv foo bar :baz\r\n')

    def testHalfops(self):
        m = ircmsgs.halfops('#foo', ['foo', 'bar', 'baz'])
        self.assertEqual(str(m), 'MODE #foo +hhh foo bar :baz\r\n')

    def testDehalfops(self):
        m = ircmsgs.dehalfops('#foo', ['foo', 'bar', 'baz'])
        self.assertEqual(str(m), 'MODE #foo -hhh foo bar :baz\r\n')

    def testMode(self):
        m = ircmsgs.mode('#foo', ('-b', 'foo!bar@baz'))
        s = str(m)
        self.assertEqual(s, 'MODE #foo -b :foo!bar@baz\r\n')

    def testIsSplit(self):
        m = ircmsgs.IrcMsg(prefix="caker!~caker@ns.theshore.net",
                           command="QUIT",
                           args=('jupiter.oftc.net quasar.oftc.net',))
        self.failUnless(ircmsgs.isSplit(m))
        m = ircmsgs.IrcMsg(prefix="bzbot!Brad2901@ACC87473.ipt.aol.com",
                           command="QUIT",
                           args=('Read error: 110 (Connection timed out)',))
        self.failIf(ircmsgs.isSplit(m))
        m = ircmsgs.IrcMsg(prefix="JibberJim!~none@8212cl.b0nwbeoe.co.uk",
                           command="QUIT",
                           args=('"Bye!"',))
        self.failIf(ircmsgs.isSplit(m))


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test_ircutils
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###


from supybot.test import *

import copy
import random

import supybot.ircmsgs as ircmsgs
import supybot.ircutils as ircutils

# The test framework used to provide these, but not it doesn't.  We'll add
# messages to as we find bugs (if indeed we find bugs).
msgs = []
rawmsgs = []

class FunctionsTestCase(SupyTestCase):
    hostmask = 'foo!bar@baz'
    def testHostmaskPatternEqual(self):
        for msg in msgs:
            if msg.prefix and ircutils.isUserHostmask(msg.prefix):
                s = msg.prefix
                self.failUnless(ircutils.hostmaskPatternEqual(s, s),
                                '%r did not match itself.' % s)
                banmask = ircutils.banmask(s)
                self.failUnless(ircutils.hostmaskPatternEqual(banmask, s),
                                '%r did not match %r' % (s, banmask))
        s = 'supybot!~supybot@dhcp065-024-075-056.columbus.rr.com'
        self.failUnless(ircutils.hostmaskPatternEqual(s, s))
        s = 'jamessan|work!~jamessan@209-6-166-196.c3-0.' \
            'abr-ubr1.sbo-abr.ma.cable.rcn.com'
        self.failUnless(ircutils.hostmaskPatternEqual(s, s))

    def testIsUserHostmask(self):
        self.failUnless(ircutils.isUserHostmask(self.hostmask))
        self.failUnless(ircutils.isUserHostmask('a!b@c'))
        self.failIf(ircutils.isUserHostmask('!bar@baz'))
        self.failIf(ircutils.isUserHostmask('!@baz'))
        self.failIf(ircutils.isUserHostmask('!bar@'))
        self.failIf(ircutils.isUserHostmask('!@'))
        self.failIf(ircutils.isUserHostmask('foo!@baz'))
        self.failIf(ircutils.isUserHostmask('foo!bar@'))
        self.failIf(ircutils.isUserHostmask(''))
        self.failIf(ircutils.isUserHostmask('!'))
        self.failIf(ircutils.isUserHostmask('@'))
        self.failIf(ircutils.isUserHostmask('!bar@baz'))

    def testIsChannel(self):
        self.failUnless(ircutils.isChannel('#'))
        self.failUnless(ircutils.isChannel('&'))
        self.failUnless(ircutils.isChannel('+'))
        self.failUnless(ircutils.isChannel('!'))
        self.failUnless(ircutils.isChannel('#foo'))
        self.failUnless(ircutils.isChannel('&foo'))
        self.failUnless(ircutils.isChannel('+foo'))
        self.failUnless(ircutils.isChannel('!foo'))
        self.failIf(ircutils.isChannel('#foo bar'))
        self.failIf(ircutils.isChannel('#foo,bar'))
        self.failIf(ircutils.isChannel('#foobar\x07'))
        self.failIf(ircutils.isChannel('foo'))
        self.failIf(ircutils.isChannel(''))

    def testBold(self):
        s = ircutils.bold('foo')
        self.assertEqual(s[0], '\x02')
        self.assertEqual(s[-1], '\x02')

    def testUnderline(self):
        s = ircutils.underline('foo')
        self.assertEqual(s[0], '\x1f')
        self.assertEqual(s[-1], '\x1f')

    def testReverse(self):
        s = ircutils.reverse('foo')
        self.assertEqual(s[0], '\x16')
        self.assertEqual(s[-1], '\x16')

    def testMircColor(self):
        # No colors provided should return the same string
        s = 'foo'
        self.assertEqual(s, ircutils.mircColor(s))
        # Test positional args
        self.assertEqual('\x0300foo\x03', ircutils.mircColor(s, 'white'))
        self.assertEqual('\x031,02foo\x03',ircutils.mircColor(s,'black','blue'))
        self.assertEqual('\x0300,03foo\x03', ircutils.mircColor(s, None, 'green'))
        # Test keyword args
        self.assertEqual('\x0304foo\x03', ircutils.mircColor(s, fg='red'))
        self.assertEqual('\x0300,05foo\x03', ircutils.mircColor(s, bg='brown'))
        self.assertEqual('\x036,07foo\x03',
                         ircutils.mircColor(s, bg='orange', fg='purple'))

# Commented out because we don't map numbers to colors anymore.
##     def testMircColors(self):
##         # Make sure all (k, v) pairs are also (v, k) pairs.
##         for (k, v) in ircutils.mircColors.items():
##             if k:
##                 self.assertEqual(ircutils.mircColors[v], k)

    def testStripBold(self):
        self.assertEqual(ircutils.stripBold(ircutils.bold('foo')), 'foo')

    def testStripColor(self):
        self.assertEqual(ircutils.stripColor('\x02bold\x0302,04foo\x03bar\x0f'),
                         '\x02boldfoobar\x0f')
        self.assertEqual(ircutils.stripColor('\x03foo\x03'), 'foo')
        self.assertEqual(ircutils.stripColor('\x03foo\x0F'), 'foo\x0F')
        self.assertEqual(ircutils.stripColor('\x0312foo\x03'), 'foo')
        self.assertEqual(ircutils.stripColor('\x0312,14foo\x03'), 'foo')
        self.assertEqual(ircutils.stripColor('\x03,14foo\x03'), 'foo')
        self.assertEqual(ircutils.stripColor('\x03,foo\x03'), ',foo')
        self.assertEqual(ircutils.stripColor('\x0312foo\x0F'), 'foo\x0F')
        self.assertEqual(ircutils.stripColor('\x0312,14foo\x0F'), 'foo\x0F')
        self.assertEqual(ircutils.stripColor('\x03,14foo\x0F'), 'foo\x0F')
        self.assertEqual(ircutils.stripColor('\x03,foo\x0F'), ',foo\x0F')

    def testStripReverse(self):
        self.assertEqual(ircutils.stripReverse(ircutils.reverse('foo')), 'foo')

    def testStripUnderline(self):
        self.assertEqual(ircutils.stripUnderline(ircutils.underline('foo')),
                         'foo')

    def testStripFormatting(self):
        self.assertEqual(ircutils.stripFormatting(ircutils.bold('foo')), 'foo')
        self.assertEqual(ircutils.stripFormatting(ircutils.reverse('foo')),
                         'foo')
        self.assertEqual(ircutils.stripFormatting(ircutils.underline('foo')),
                         'foo')
        self.assertEqual(ircutils.stripFormatting('\x02bold\x0302,04foo\x03'
                                                  'bar\x0f'),
                         'boldfoobar')
        s = ircutils.mircColor('[', 'blue') + ircutils.bold('09:21')
        self.assertEqual(ircutils.stripFormatting(s), '[09:21')

    def testSafeArgument(self):
        s = 'I have been running for 9 seconds'
        bolds = ircutils.bold(s)
        colors = ircutils.mircColor(s, 'pink', 'orange')
        self.assertEqual(s, ircutils.safeArgument(s))
        self.assertEqual(bolds, ircutils.safeArgument(bolds))
        self.assertEqual(colors, ircutils.safeArgument(colors))

    def testSafeArgumentConvertsToString(self):
        self.assertEqual('1', ircutils.safeArgument(1))
        self.assertEqual(str(None), ircutils.safeArgument(None))

    def testIsNick(self):
        try:
            original = conf.supybot.protocols.irc.strictRfc()
            conf.supybot.protocols.irc.strictRfc.setValue(True)
            self.failUnless(ircutils.isNick('jemfinch'))
            self.failUnless(ircutils.isNick('jemfinch0'))
            self.failUnless(ircutils.isNick('[0]'))
            self.failUnless(ircutils.isNick('{jemfinch}'))
            self.failUnless(ircutils.isNick('[jemfinch]'))
            self.failUnless(ircutils.isNick('jem|finch'))
            self.failUnless(ircutils.isNick('\\```'))
            self.failUnless(ircutils.isNick('`'))
            self.failUnless(ircutils.isNick('A'))
            self.failIf(ircutils.isNick(''))
            self.failIf(ircutils.isNick('8foo'))
            self.failIf(ircutils.isNick('10'))
            self.failIf(ircutils.isNick('-'))
            self.failIf(ircutils.isNick('-foo'))
            conf.supybot.protocols.irc.strictRfc.setValue(False)
            self.failUnless(ircutils.isNick('services@something.undernet.net'))
        finally:
            conf.supybot.protocols.irc.strictRfc.setValue(original)

    def testIsNickNeverAllowsSpaces(self):
        try:
            original = conf.supybot.protocols.irc.strictRfc()
            conf.supybot.protocols.irc.strictRfc.setValue(True)
            self.failIf(ircutils.isNick('foo bar'))
            conf.supybot.protocols.irc.strictRfc.setValue(False)
            self.failIf(ircutils.isNick('foo bar'))
        finally:
            conf.supybot.protocols.irc.strictRfc.setValue(original)

    def testStandardSubstitute(self):
        # Stub out random msg and irc objects that provide what
        # standardSubstitute wants
        msg = ircmsgs.IrcMsg(':%s PRIVMSG #channel :stuff' % self.hostmask)
        class Irc(object):
            nick = 'bob'
        irc = Irc()

        f = ircutils.standardSubstitute
        vars = {'foo': 'bar', 'b': 'c', 'i': 100,
                'f': lambda: 'called'}
        self.assertEqual(f(irc, msg, '$foo', vars), 'bar')
        self.assertEqual(f(irc, msg, '${foo}', vars), 'bar')
        self.assertEqual(f(irc, msg, '$b', vars), 'c')
        self.assertEqual(f(irc, msg, '${b}', vars), 'c')
        self.assertEqual(f(irc, msg, '$i', vars), '100')
        self.assertEqual(f(irc, msg, '${i}', vars), '100')
        self.assertEqual(f(irc, msg, '$f', vars), 'called')
        self.assertEqual(f(irc, msg, '${f}', vars), 'called')
        self.assertEqual(f(irc, msg, '$b:$i', vars), 'c:100')

    def testBanmask(self):
        for msg in msgs:
            if ircutils.isUserHostmask(msg.prefix):
                banmask = ircutils.banmask(msg.prefix)
                self.failUnless(ircutils.hostmaskPatternEqual(banmask,
                                                              msg.prefix),
                                '%r didn\'t match %r' % (msg.prefix, banmask))
        self.assertEqual(ircutils.banmask('foobar!user@host'), '*!*@host')
        self.assertEqual(ircutils.banmask('foobar!user@host.tld'),
                         '*!*@host.tld')
        self.assertEqual(ircutils.banmask('foobar!user@sub.host.tld'),
                         '*!*@*.host.tld')
        self.assertEqual(ircutils.banmask('foo!bar@2001::'), '*!*@2001::*')

    def testSeparateModes(self):
        self.assertEqual(ircutils.separateModes(['+ooo', 'x', 'y', 'z']),
                         [('+o', 'x'), ('+o', 'y'), ('+o', 'z')])
        self.assertEqual(ircutils.separateModes(['+o-o', 'x', 'y']),
                         [('+o', 'x'), ('-o', 'y')])
        self.assertEqual(ircutils.separateModes(['+s-o', 'x']),
                         [('+s', None), ('-o', 'x')])
        self.assertEqual(ircutils.separateModes(['+sntl', '100']),
                        [('+s', None),('+n', None),('+t', None),('+l', 100)])

    def testNickFromHostmask(self):
        self.assertEqual(ircutils.nickFromHostmask('nick!user@host.domain.tld'),
                         'nick')

    def testToLower(self):
        self.assertEqual('jemfinch', ircutils.toLower('jemfinch'))
        self.assertEqual('{}|^', ircutils.toLower('[]\\~'))

    def testReplyTo(self):
        prefix = 'foo!bar@baz'
        channel = ircmsgs.privmsg('#foo', 'bar baz', prefix=prefix)
        private = ircmsgs.privmsg('jemfinch', 'bar baz', prefix=prefix)
        self.assertEqual(ircutils.replyTo(channel), channel.args[0])
        self.assertEqual(ircutils.replyTo(private), private.nick)

    def testJoinModes(self):
        plusE = ('+e', '*!*@*ohio-state.edu')
        plusB = ('+b', '*!*@*umich.edu')
        minusL = ('-l', None)
        modes = [plusB, plusE, minusL]
        self.assertEqual(ircutils.joinModes(modes),
                         ['+be-l', plusB[1], plusE[1]])

    def testDccIpStuff(self):
        def randomIP():
            def rand():
                return random.randrange(0, 256)
            return '.'.join(map(str, [rand(), rand(), rand(), rand()]))
        for _ in range(100): # 100 should be good :)
            ip = randomIP()
            self.assertEqual(ip, ircutils.unDccIP(ircutils.dccIP(ip)))


class IrcDictTestCase(SupyTestCase):
    def test(self):
        d = ircutils.IrcDict()
        d['#FOO'] = 'bar'
        self.assertEqual(d['#FOO'], 'bar')
        self.assertEqual(d['#Foo'], 'bar')
        self.assertEqual(d['#foo'], 'bar')
        del d['#fOO']
        d['jemfinch{}'] = 'bar'
        self.assertEqual(d['jemfinch{}'], 'bar')
        self.assertEqual(d['jemfinch[]'], 'bar')
        self.assertEqual(d['JEMFINCH[]'], 'bar')

    def testKeys(self):
        d = ircutils.IrcDict()
        self.assertEqual(d.keys(), [])

    def testSetdefault(self):
        d = ircutils.IrcDict()
        d.setdefault('#FOO', []).append(1)
        self.assertEqual(d['#foo'], [1])
        self.assertEqual(d['#fOO'], [1])
        self.assertEqual(d['#FOO'], [1])

    def testGet(self):
        d = ircutils.IrcDict()
        self.assertEqual(d.get('#FOO'), None)
        d['#foo'] = 1
        self.assertEqual(d.get('#FOO'), 1)

    def testContains(self):
        d = ircutils.IrcDict()
        d['#FOO'] = None
        self.failUnless('#foo' in d)
        d['#fOOBAR[]'] = None
        self.failUnless('#foobar{}' in d)

    def testGetSetItem(self):
        d = ircutils.IrcDict()
        d['#FOO'] = 12
        self.assertEqual(12, d['#foo'])
        d['#fOOBAR[]'] = 'blah'
        self.assertEqual('blah', d['#foobar{}'])

    def testCopyable(self):
        d = ircutils.IrcDict()
        d['foo'] = 'bar'
        self.failUnless(d == copy.copy(d))
        self.failUnless(d == copy.deepcopy(d))


class IrcSetTestCase(SupyTestCase):
    def test(self):
        s = ircutils.IrcSet()
        s.add('foo')
        s.add('bar')
        self.failUnless('foo' in s)
        self.failUnless('FOO' in s)
        s.discard('alfkj')
        s.remove('FOo')
        self.failIf('foo' in s)
        self.failIf('FOo' in s)

    def testCopy(self):
        s = ircutils.IrcSet()
        s.add('foo')
        s.add('bar')
        s1 = copy.deepcopy(s)
        self.failUnless('foo' in s)
        self.failUnless('FOO' in s)
        s.discard('alfkj')
        s.remove('FOo')
        self.failIf('foo' in s)
        self.failIf('FOo' in s)
        self.failUnless('foo' in s1)
        self.failUnless('FOO' in s1)
        s1.discard('alfkj')
        s1.remove('FOo')
        self.failIf('foo' in s1)
        self.failIf('FOo' in s1)


class IrcStringTestCase(SupyTestCase):
    def testEquality(self):
        self.assertEqual('#foo', ircutils.IrcString('#foo'))
        self.assertEqual('#foo', ircutils.IrcString('#FOO'))
        self.assertEqual('#FOO', ircutils.IrcString('#foo'))
        self.assertEqual('#FOO', ircutils.IrcString('#FOO'))
        self.assertEqual(hash(ircutils.IrcString('#FOO')),
                         hash(ircutils.IrcString('#foo')))

    def testInequality(self):
        s1 = 'supybot'
        s2 = ircutils.IrcString('Supybot')
        self.failUnless(s1 == s2)
        self.failIf(s1 != s2)


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:


########NEW FILE########
__FILENAME__ = test_plugin
###
# Copyright (c) 2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

import supybot.plugin as plugin

class FunctionsTestCase(SupyTestCase):
    def testLoadPluginModule(self):
        self.assertRaises(ImportError, plugin.loadPluginModule, 'asldj')
        self.failUnless(plugin.loadPluginModule('Owner'))
        # I haven't yet figured out a way to get case-insensitivity back for
        # "directoried" plugins.
        #self.failUnless(plugin.loadPluginModule('owner'))


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test_plugins
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# Copyright (c) 2008, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

import supybot.irclib as irclib
import supybot.plugins as plugins

########NEW FILE########
__FILENAME__ = test_registry
###
# Copyright (c) 2004, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

import re

import supybot.conf as conf
import supybot.registry as registry

join = registry.join
split = registry.split
escape = registry.escape
unescape = registry.unescape
class FunctionsTestCase(SupyTestCase):
    def testEscape(self):
        self.assertEqual('foo', escape('foo'))
        self.assertEqual('foo\\.bar', escape('foo.bar'))
        self.assertEqual('foo\\:bar', escape('foo:bar'))

    def testUnescape(self):
        self.assertEqual('foo', unescape('foo'))
        self.assertEqual('foo.bar', unescape('foo\\.bar'))
        self.assertEqual('foo:bar', unescape('foo\\:bar'))

    def testEscapeAndUnescapeAreInverses(self):
        for s in ['foo', 'foo.bar']:
            self.assertEqual(s, unescape(escape(s)))
            self.assertEqual(escape(s), escape(unescape(escape(s))))

    def testSplit(self):
        self.assertEqual(['foo'], split('foo'))
        self.assertEqual(['foo', 'bar'], split('foo.bar'))
        self.assertEqual(['foo.bar'], split('foo\\.bar'))

    def testJoin(self):
        self.assertEqual('foo', join(['foo']))
        self.assertEqual('foo.bar', join(['foo', 'bar']))
        self.assertEqual('foo\\.bar', join(['foo.bar']))

    def testJoinAndSplitAreInverses(self):
        for s in ['foo', 'foo.bar', 'foo\\.bar']:
            self.assertEqual(s, join(split(s)))
            self.assertEqual(split(s), split(join(split(s))))



class ValuesTestCase(SupyTestCase):
    def testBoolean(self):
        v = registry.Boolean(True, """Help""")
        self.failUnless(v())
        v.setValue(False)
        self.failIf(v())
        v.set('True')
        self.failUnless(v())
        v.set('False')
        self.failIf(v())
        v.set('On')
        self.failUnless(v())
        v.set('Off')
        self.failIf(v())
        v.set('enable')
        self.failUnless(v())
        v.set('disable')
        self.failIf(v())
        v.set('toggle')
        self.failUnless(v())
        v.set('toggle')
        self.failIf(v())

    def testInteger(self):
        v = registry.Integer(1, 'help')
        self.assertEqual(v(), 1)
        v.setValue(10)
        self.assertEqual(v(), 10)
        v.set('100')
        self.assertEqual(v(), 100)
        v.set('-1000')
        self.assertEqual(v(), -1000)

    def testPositiveInteger(self):
        v = registry.PositiveInteger(1, 'help')
        self.assertEqual(v(), 1)
        self.assertRaises(registry.InvalidRegistryValue, v.setValue, -1)
        self.assertRaises(registry.InvalidRegistryValue, v.set, '-1')

    def testFloat(self):
        v = registry.Float(1.0, 'help')
        self.assertEqual(v(), 1.0)
        v.setValue(10)
        self.assertEqual(v(), 10.0)
        v.set('0')
        self.assertEqual(v(), 0.0)

    def testString(self):
        v = registry.String('foo', 'help')
        self.assertEqual(v(), 'foo')
        v.setValue('bar')
        self.assertEqual(v(), 'bar')
        v.set('"biff"')
        self.assertEqual(v(), 'biff')
        v.set("'buff'")
        self.assertEqual(v(), 'buff')
        v.set('"xyzzy')
        self.assertEqual(v(), '"xyzzy')

    def testJson(self):
        data = {'foo': ['bar', 'baz', 5], 'qux': None}
        v = registry.Json('foo', 'help')
        self.assertEqual(v(), 'foo')
        v.setValue(data)
        self.assertEqual(v(), data)
        self.assertIsNot(v(), data)

        with v.editable() as dict_:
            dict_['supy'] = 'bot'
            del dict_['qux']
            self.assertNotIn('supy', v())
            self.assertIn('qux', v())
        self.assertIn('supy', v())
        self.assertEqual(v()['supy'], 'bot')
        self.assertIsNot(v()['supy'], 'bot')
        self.assertNotIn('qux', v())

    def testNormalizedString(self):
        v = registry.NormalizedString("""foo
        bar           baz
        biff
        """, 'help')
        self.assertEqual(v(), 'foo bar baz biff')
        v.setValue('foo          bar             baz')
        self.assertEqual(v(), 'foo bar baz')
        v.set('"foo         bar  baz"')
        self.assertEqual(v(), 'foo bar baz')

    def testStringSurroundedBySpaces(self):
        v = registry.StringSurroundedBySpaces('foo', 'help')
        self.assertEqual(v(), ' foo ')
        v.setValue('||')
        self.assertEqual(v(), ' || ')
        v.set('&&')
        self.assertEqual(v(), ' && ')

    def testCommaSeparatedListOfStrings(self):
        v = registry.CommaSeparatedListOfStrings(['foo', 'bar'], 'help')
        self.assertEqual(v(), ['foo', 'bar'])
        v.setValue(['foo', 'bar', 'baz'])
        self.assertEqual(v(), ['foo', 'bar', 'baz'])
        v.set('foo,bar')
        self.assertEqual(v(), ['foo', 'bar'])

    def testRegexp(self):
        v = registry.Regexp(None, 'help')
        self.assertEqual(v(), None)
        v.set('m/foo/')
        self.failUnless(v().match('foo'))
        v.set('')
        self.assertEqual(v(), None)
        self.assertRaises(registry.InvalidRegistryValue,
                          v.setValue, re.compile(r'foo'))

    def testBackslashes(self):
        conf.supybot.reply.whenAddressedBy.chars.set('\\')
        filename = conf.supybot.directories.conf.dirize('backslashes.conf')
        registry.close(conf.supybot, filename)
        registry.open_registry(filename)
        self.assertEqual(conf.supybot.reply.whenAddressedBy.chars(), '\\')

    def testWith(self):
        v = registry.String('foo', 'help')
        self.assertEqual(v(), 'foo')
        with v.context('bar'):
            self.assertEqual(v(), 'bar')
        self.assertEqual(v(), 'foo')

class SecurityTestCase(SupyTestCase):
    def testPrivate(self):
        v = registry.String('foo', 'help')
        self.assertFalse(v._private)
        v = registry.String('foo', 'help', private=True)
        self.assertTrue(v._private)

        g = registry.Group('foo')
        v = registry.String('foo', 'help')
        g.register('val', v)
        self.assertFalse(g._private)
        self.assertFalse(g.val._private)

        g = registry.Group('foo', private=True)
        v = registry.String('foo', 'help')
        g.register('val', v)
        self.assertTrue(g._private)
        self.assertTrue(g.val._private)

        g = registry.Group('foo')
        v = registry.String('foo', 'help', private=True)
        g.register('val', v)
        self.assertFalse(g._private)
        self.assertTrue(g.val._private)

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:

########NEW FILE########
__FILENAME__ = test_schedule
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

import time

import supybot.schedule as schedule

class TestSchedule(SupyTestCase):
    def testSchedule(self):
        sched = schedule.Schedule()
        i = [0]
        def add10():
            i[0] = i[0] + 10
        def add1():
            i[0] = i[0] + 1

        sched.addEvent(add10, time.time() + 3)
        sched.addEvent(add1, time.time() + 1)
        time.sleep(1.2)
        sched.run()
        self.assertEqual(i[0], 1)
        time.sleep(1.9)
        sched.run()
        self.assertEqual(i[0], 11)

        sched.addEvent(add10, time.time() + 3, 'test')
        sched.run()
        self.assertEqual(i[0], 11)
        sched.removeEvent('test')
        self.assertEqual(i[0], 11)
        time.sleep(3)
        self.assertEqual(i[0], 11)

    def testReschedule(self):
        sched = schedule.Schedule()
        i = [0]
        def inc():
            i[0] += 1
        n = sched.addEvent(inc, time.time() + 1)
        sched.rescheduleEvent(n, time.time() + 3)
        time.sleep(1.2)
        sched.run()
        self.assertEqual(i[0], 0)
        time.sleep(2)
        sched.run()
        self.assertEqual(i[0], 1)

    def testPeriodic(self):
        sched = schedule.Schedule()
        i = [0]
        def inc():
            i[0] += 1
        n = sched.addPeriodicEvent(inc, 1, name='test_periodic')
        time.sleep(0.6)
        sched.run() # 0.6
        self.assertEqual(i[0], 1)
        time.sleep(0.6)
        sched.run() # 1.2
        self.assertEqual(i[0], 2)
        time.sleep(0.6)
        sched.run() # 1.8
        self.assertEqual(i[0], 2)
        time.sleep(0.6)
        sched.run() # 2.4
        self.assertEqual(i[0], 3)
        sched.removePeriodicEvent(n)
        time.sleep(1)
        sched.run() # 3.4
        self.assertEqual(i[0], 3)

    def testCountedPeriodic(self):
        sched = schedule.Schedule()
        i = [0]
        def inc():
            i[0] += 1
        n = sched.addPeriodicEvent(inc, 1, name='test_periodic', count=3)
        time.sleep(0.6)
        sched.run() # 0.6
        self.assertEqual(i[0], 1)
        time.sleep(0.6)
        sched.run() # 1.2
        self.assertEqual(i[0], 2)
        time.sleep(0.6)
        sched.run() # 1.8
        self.assertEqual(i[0], 2)
        time.sleep(0.6)
        sched.run() # 2.4
        self.assertEqual(i[0], 3)
        time.sleep(1)
        sched.run() # 3.4
        self.assertEqual(i[0], 3)


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:


########NEW FILE########
__FILENAME__ = test_standardSubstitute
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

import supybot.irclib as irclib
from supybot.utils.iter import all
import supybot.ircutils as ircutils

class holder:
    users = set(map(str, range(1000)))

class FunctionsTestCase(SupyTestCase):
    class irc:
        class state:
            channels = {'#foo': holder()}
        nick = 'foobar'

    def testStandardSubstitute(self):
        f = ircutils.standardSubstitute
        msg = ircmsgs.privmsg('#foo', 'filler', prefix='biff!quux@xyzzy')
        s = f(self.irc, msg, '$rand')
        try:
            int(s)
        except ValueError:
            self.fail('$rand wasn\'t an int.')
        s = f(self.irc, msg, '$randomInt')
        try:
            int(s)
        except ValueError:
            self.fail('$randomint wasn\'t an int.')
        self.assertEqual(f(self.irc, msg, '$botnick'), self.irc.nick)
        self.assertEqual(f(self.irc, msg, '$who'), msg.nick)
        self.assertEqual(f(self.irc, msg, '$WHO'),
                         msg.nick, 'stand. sub. not case-insensitive.')
        self.assertEqual(f(self.irc, msg, '$nick'), msg.nick)
        self.assertNotEqual(f(self.irc, msg, '$randomdate'), '$randomdate')
        q = f(self.irc,msg,'$randomdate\t$randomdate')
        dl = q.split('\t')
        if dl[0] == dl[1]:
            self.fail ('Two $randomdates in the same string were the same')
        q = f(self.irc, msg, '$randomint\t$randomint')
        dl = q.split('\t')
        if dl[0] == dl[1]:
            self.fail ('Two $randomints in the same string were the same')
        self.assertNotEqual(f(self.irc, msg, '$today'), '$today')
        self.assertNotEqual(f(self.irc, msg, '$now'), '$now')
        n = f(self.irc, msg, '$randnick')
        self.failUnless(n in self.irc.state.channels['#foo'].users)
        n = f(self.irc, msg, '$randomnick')
        self.failUnless(n in self.irc.state.channels['#foo'].users)
        n = f(self.irc, msg, '$randomnick '*100)
        L = n.split()
        self.failIf(all(L[0].__eq__, L), 'all $randomnicks were the same')
        c = f(self.irc, msg, '$channel')
        self.assertEqual(c, msg.args[0])









########NEW FILE########
__FILENAME__ = test_utils
###
# Copyright (c) 2002-2005, Jeremiah Fincher
# Copyright (c) 2009,2011, James McCoy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

from supybot.test import *

import sys
import time
import pickle
import supybot.utils as utils
from supybot.utils.structures import *

if sys.version_info[0] >= 0:
    xrange = range

class UtilsTest(SupyTestCase):
    def testReversed(self):
        L = list(range(10))
        revL = list(reversed(L))
        L.reverse()
        self.assertEqual(L, revL, 'reversed didn\'t return reversed list')
        for _ in reversed([]):
            self.fail('reversed caused iteration over empty sequence')


class SeqTest(SupyTestCase):
    def testRenumerate(self):
        for i in xrange(5):
            L = list(enumerate(range(i)))
            LL = list(utils.seq.renumerate(range(i)))
            self.assertEqual(L, LL[::-1])
        
    def testWindow(self):
        L = list(range(10))
        def wwindow(*args):
            return list(utils.seq.window(*args))
        self.assertEqual(wwindow([], 1), [], 'Empty sequence, empty window')
        self.assertEqual(wwindow([], 2), [], 'Empty sequence, empty window')
        self.assertEqual(wwindow([], 5), [], 'Empty sequence, empty window')
        self.assertEqual(wwindow([], 100), [], 'Empty sequence, empty window')
        self.assertEqual(wwindow(L, 1), [[x] for x in L], 'Window length 1')
        self.assertRaises(ValueError, wwindow, [], 0)
        self.assertRaises(ValueError, wwindow, [], -1)



class GenTest(SupyTestCase):
    def testInsensitivePreservingDict(self):
        ipd = utils.InsensitivePreservingDict
        d = ipd(dict(Foo=10))
        self.failUnless(d['foo'] == 10)
        self.assertEqual(d.keys(), ['Foo'])
        self.assertEqual(d.get('foo'), 10)
        self.assertEqual(d.get('Foo'), 10)

    def testFindBinaryInPath(self):
        if os.name == 'posix':
            self.assertEqual(None, utils.findBinaryInPath('asdfhjklasdfhjkl'))
            self.failUnless(utils.findBinaryInPath('sh').endswith('/bin/sh'))

    def testExnToString(self):
        try:
            raise KeyError(1)
        except Exception as e:
            self.assertEqual(utils.exnToString(e), 'KeyError: 1')
        try:
            raise EOFError()
        except Exception as e:
            self.assertEqual(utils.exnToString(e), 'EOFError')

    def testSaltHash(self):
        s = utils.saltHash('jemfinch')
        (salt, hash) = s.split('|')
        self.assertEqual(utils.saltHash('jemfinch', salt=salt), s)

    def testSafeEval(self):
        for s in ['1', '()', '(1,)', '[]', '{}', '{1:2}', '{1:(2,3)}',
                  '1.0', '[1,2,3]', 'True', 'False', 'None',
                  '(True,False,None)', '"foo"', '{"foo": "bar"}']:
            self.assertEqual(eval(s), utils.safeEval(s))
        for s in ['lambda: 2', 'import foo', 'foo.bar']:
            self.assertRaises(ValueError, utils.safeEval, s)

    def testSafeEvalTurnsSyntaxErrorIntoValueError(self):
        self.assertRaises(ValueError, utils.safeEval, '/usr/local/')

    def testIterableMap(self):
        class alist(utils.IterableMap):
            def __init__(self):
                self.L = []

            def __setitem__(self, key, value):
                self.L.append((key, value))

            def iteritems(self):
                for (k, v) in self.L:
                    yield (k, v)
        AL = alist()
        self.failIf(AL)
        AL[1] = 2
        AL[2] = 3
        AL[3] = 4
        self.failUnless(AL)
        self.assertEqual(list(AL.items()), [(1, 2), (2, 3), (3, 4)])
        self.assertEqual(list(AL.iteritems()), [(1, 2), (2, 3), (3, 4)])
        self.assertEqual(list(AL.keys()), [1, 2, 3])
        if sys.version_info[0] < 3:
            self.assertEqual(list(AL.iterkeys()), [1, 2, 3])
            self.assertEqual(AL.values(), [2, 3, 4])
            self.assertEqual(list(AL.itervalues()), [2, 3, 4])
        self.assertEqual(len(AL), 3)

    def testSortBy(self):
        L = ['abc', 'z', 'AD']
        utils.sortBy(len, L)
        self.assertEqual(L, ['z', 'AD', 'abc'])
        utils.sortBy(str.lower, L)
        self.assertEqual(L, ['abc', 'AD', 'z'])
        L = ['supybot', 'Supybot']
        utils.sortBy(str.lower, L)
        self.assertEqual(L, ['supybot', 'Supybot'])

    def testSorted(self):
        L = ['a', 'c', 'b']
        self.assertEqual(sorted(L), ['a', 'b', 'c'])
        self.assertEqual(L, ['a', 'c', 'b'])
        self.assertEqual(sorted(L, reverse=True), ['c', 'b', 'a'])

    def testTimeElapsed(self):
        self.assertRaises(ValueError, utils.timeElapsed, 0,
                          leadingZeroes=False, seconds=False)
        then = 0
        now = 0
        for now, expected in [(0, '0 seconds'),
                              (1, '1 second'),
                              (60, '1 minute and 0 seconds'),
                              (61, '1 minute and 1 second'),
                              (62, '1 minute and 2 seconds'),
                              (122, '2 minutes and 2 seconds'),
                              (3722, '1 hour, 2 minutes, and 2 seconds'),
                              (7322, '2 hours, 2 minutes, and 2 seconds'),
                              (90061,'1 day, 1 hour, 1 minute, and 1 second'),
                              (180122, '2 days, 2 hours, 2 minutes, '
                                       'and 2 seconds')]:
            self.assertEqual(utils.timeElapsed(now - then), expected)

    def timeElapsedShort(self):
        self.assertEqual(utils.timeElapsed(123, short=True), '2m 3s')

    def testAbbrev(self):
        L = ['abc', 'bcd', 'bbe', 'foo', 'fool']
        d = utils.abbrev(L)
        def getItem(s):
            return d[s]
        self.assertRaises(KeyError, getItem, 'f')
        self.assertRaises(KeyError, getItem, 'fo')
        self.assertRaises(KeyError, getItem, 'b')
        self.assertEqual(d['bb'], 'bbe')
        self.assertEqual(d['bc'], 'bcd')
        self.assertEqual(d['a'], 'abc')
        self.assertEqual(d['ab'], 'abc')
        self.assertEqual(d['fool'], 'fool')
        self.assertEqual(d['foo'], 'foo')

    def testAbbrevFailsWithDups(self):
        L = ['english', 'english']
        self.assertRaises(ValueError, utils.abbrev, L)


class StrTest(SupyTestCase):
    def testRsplit(self):
        rsplit = utils.str.rsplit
        self.assertEqual(rsplit('foo bar baz'), 'foo bar baz'.split())
        self.assertEqual(rsplit('foo bar baz', maxsplit=1),
                         ['foo bar', 'baz'])
        self.assertEqual(rsplit('foo        bar baz', maxsplit=1),
                         ['foo        bar', 'baz'])
        self.assertEqual(rsplit('foobarbaz', 'bar'), ['foo', 'baz'])

    def testMatchCase(self):
        f = utils.str.matchCase
        self.assertEqual('bar', f('foo', 'bar'))
        self.assertEqual('Bar', f('Foo', 'bar'))
        self.assertEqual('BAr', f('FOo', 'bar'))
        self.assertEqual('BAR', f('FOO', 'bar'))
        self.assertEqual('bAR', f('fOO', 'bar'))
        self.assertEqual('baR', f('foO', 'bar'))
        self.assertEqual('BaR', f('FoO', 'bar'))

    def testPluralize(self):
        f = utils.str.pluralize
        self.assertEqual('bikes', f('bike'))
        self.assertEqual('BIKES', f('BIKE'))
        self.assertEqual('matches', f('match'))
        self.assertEqual('Patches', f('Patch'))
        self.assertEqual('fishes', f('fish'))
        self.assertEqual('tries', f('try'))
        self.assertEqual('days', f('day'))

    def testDepluralize(self):
        f = utils.str.depluralize
        self.assertEqual('bike', f('bikes'))
        self.assertEqual('Bike', f('Bikes'))
        self.assertEqual('BIKE', f('BIKES'))
        self.assertEqual('match', f('matches'))
        self.assertEqual('Match', f('Matches'))
        self.assertEqual('fish', f('fishes'))
        self.assertEqual('try', f('tries'))

    def testDistance(self):
        self.assertEqual(utils.str.distance('', ''), 0)
        self.assertEqual(utils.str.distance('a', 'b'), 1)
        self.assertEqual(utils.str.distance('a', 'a'), 0)
        self.assertEqual(utils.str.distance('foobar', 'jemfinch'), 8)
        self.assertEqual(utils.str.distance('a', 'ab'), 1)
        self.assertEqual(utils.str.distance('foo', ''), 3)
        self.assertEqual(utils.str.distance('', 'foo'), 3)
        self.assertEqual(utils.str.distance('appel', 'nappe'), 2)
        self.assertEqual(utils.str.distance('nappe', 'appel'), 2)

    def testSoundex(self):
        L = [('Euler', 'E460'),
             ('Ellery', 'E460'),
             ('Gauss', 'G200'),
             ('Ghosh', 'G200'),
             ('Hilbert', 'H416'),
             ('Heilbronn', 'H416'),
             ('Knuth', 'K530'),
             ('Kant', 'K530'),
             ('Lloyd', 'L300'),
             ('Ladd', 'L300'),
             ('Lukasiewicz', 'L222'),
             ('Lissajous', 'L222')]
        for (name, key) in L:
            soundex = utils.str.soundex(name)
            self.assertEqual(soundex, key,
                             '%s was %s, not %s' % (name, soundex, key))
        self.assertRaises(ValueError, utils.str.soundex, '3')
        self.assertRaises(ValueError, utils.str.soundex, "'")

    def testDQRepr(self):
        L = ['foo', 'foo\'bar', 'foo"bar', '"', '\\', '', '\x00']
        for s in L:
            r = utils.str.dqrepr(s)
            self.assertEqual(s, eval(r), s)
            self.failUnless(r[0] == '"' and r[-1] == '"', s)

    def testPerlReToPythonRe(self):
        f = utils.str.perlReToPythonRe
        r = f('m/foo/')
        self.failUnless(r.search('foo'))
        r = f('/foo/')
        self.failUnless(r.search('foo'))
        r = f('m/\\//')
        self.failUnless(r.search('/'))
        r = f('m/cat/i')
        self.failUnless(r.search('CAT'))
        self.assertRaises(ValueError, f, 'm/?/')

    def testP2PReDifferentSeparator(self):
        r = utils.str.perlReToPythonRe('m!foo!')
        self.failUnless(r.search('foo'))
        r = utils.str.perlReToPythonRe('m{cat}')
        self.failUnless(r.search('cat'))

    def testPerlReToReplacer(self):
        PRTR = utils.str.perlReToReplacer
        f = PRTR('s/foo/bar/')
        self.assertEqual(f('foobarbaz'), 'barbarbaz')
        f = PRTR('s/fool/bar/')
        self.assertEqual(f('foobarbaz'), 'foobarbaz')
        f = PRTR('s/foo//')
        self.assertEqual(f('foobarbaz'), 'barbaz')
        f = PRTR('s/ba//')
        self.assertEqual(f('foobarbaz'), 'foorbaz')
        f = PRTR('s/ba//g')
        self.assertEqual(f('foobarbaz'), 'foorz')
        f = PRTR('s/ba\\///g')
        self.assertEqual(f('fooba/rba/z'), 'foorz')
        f = PRTR('s/ba\\\\//g')
        self.assertEqual(f('fooba\\rba\\z'), 'foorz')
        f = PRTR('s/cat/dog/i')
        self.assertEqual(f('CATFISH'), 'dogFISH')
        f = PRTR('s/foo/foo\/bar/')
        self.assertEqual(f('foo'), 'foo/bar')
        f = PRTR('s/^/foo/')
        self.assertEqual(f('bar'), 'foobar')

    def testMultipleReplacer(self):
        replacer = utils.str.MultipleReplacer({'foo': 'bar', 'a': 'b'})
        self.assertEqual(replacer('hi foo hi'), 'hi bar hi')

    def testMultipleRemover(self):
        remover = utils.str.MultipleRemover(['foo', 'bar'])
        self.assertEqual(remover('testfoobarbaz'), 'testbaz')

    def testPReToReplacerDifferentSeparator(self):
        f = utils.str.perlReToReplacer('s#foo#bar#')
        self.assertEqual(f('foobarbaz'), 'barbarbaz')

    def testPerlReToReplacerBug850931(self):
        f = utils.str.perlReToReplacer('s/\b(\w+)\b/\1./g')
        self.assertEqual(f('foo bar baz'), 'foo. bar. baz.')

    def testCommaAndify(self):
        f = utils.str.commaAndify
        L = ['foo']
        original = L[:]
        self.assertEqual(f(L), 'foo')
        self.assertEqual(f(L, And='or'), 'foo')
        self.assertEqual(L, original)
        L.append('bar')
        original = L[:]
        self.assertEqual(f(L), 'foo and bar')
        self.assertEqual(f(L, And='or'), 'foo or bar')
        self.assertEqual(L, original)
        L.append('baz')
        original = L[:]
        self.assertEqual(f(L), 'foo, bar, and baz')
        self.assertEqual(f(L, And='or'), 'foo, bar, or baz')
        self.assertEqual(f(L, comma=';'), 'foo; bar; and baz')
        self.assertEqual(f(L, comma=';', And='or'),
                         'foo; bar; or baz')
        self.assertEqual(L, original)
        self.failUnless(f(set(L)))

    def testCommaAndifyRaisesTypeError(self):
        L = [(2,)]
        self.assertRaises(TypeError, utils.str.commaAndify, L)
        L.append((3,))
        self.assertRaises(TypeError, utils.str.commaAndify, L)

    def testUnCommaThe(self):
        f = utils.str.unCommaThe
        self.assertEqual(f('foo bar'), 'foo bar')
        self.assertEqual(f('foo bar, the'), 'the foo bar')
        self.assertEqual(f('foo bar, The'), 'The foo bar')
        self.assertEqual(f('foo bar,the'), 'the foo bar')

    def testNormalizeWhitespace(self):
        f = utils.str.normalizeWhitespace
        self.assertEqual(f('foo   bar'), 'foo bar')
        self.assertEqual(f('foo\nbar'), 'foo bar')
        self.assertEqual(f('foo\tbar'), 'foo bar')

    def testNItems(self):
        nItems = utils.str.nItems
        self.assertEqual(nItems(0, 'tool'), '0 tools')
        self.assertEqual(nItems(1, 'tool', 'crazy'), '1 crazy tool')
        self.assertEqual(nItems(1, 'tool'), '1 tool')
        self.assertEqual(nItems(2, 'tool', 'crazy'), '2 crazy tools')
        self.assertEqual(nItems(2, 'tool'), '2 tools')

    def testOrdinal(self):
        ordinal = utils.str.ordinal
        self.assertEqual(ordinal(3), '3rd')
        self.assertEqual(ordinal('3'), '3rd')
        self.assertRaises(ValueError, ordinal, 'a')

    def testEllipsisify(self):
        f = utils.str.ellipsisify
        self.assertEqual(f('x'*30, 30), 'x'*30)
        self.failUnless(len(f('x'*35, 30)) <= 30)
        self.failUnless(f(' '.join(['xxxx']*10), 30)[:-3].endswith('xxxx'))


class IterTest(SupyTestCase):
    def testLimited(self):
        L = range(10)
        self.assertEqual([], list(utils.iter.limited(L, 0)))
        self.assertEqual([0], list(utils.iter.limited(L, 1)))
        self.assertEqual([0, 1], list(utils.iter.limited(L, 2)))
        self.assertEqual(list(range(10)), list(utils.iter.limited(L, 10)))
        self.assertRaises(ValueError, list, utils.iter.limited(L, 11))

    def testRandomChoice(self):
        choice = utils.iter.choice
        self.assertRaises(IndexError, choice, {})
        self.assertRaises(IndexError, choice, [])
        self.assertRaises(IndexError, choice, ())
        L = [1, 2]
        seenList = set()
        seenIterable = set()
        for n in xrange(300):
            # 2**266 > 10**80, the number of atoms in the known universe.
            # (ignoring dark matter, but that likely doesn't exist in atoms
            #  anyway, so it shouldn't have a significant impact on that #)
            seenList.add(choice(L))
            seenIterable.add(choice(iter(L)))
        self.assertEqual(len(L), len(seenList),
                         'choice isn\'t being random with lists')
        self.assertEqual(len(L), len(seenIterable),
                         'choice isn\'t being random with iterables')

##     def testGroup(self):
##         group = utils.iter.group
##         s = '1. d4 d5 2. Nf3 Nc6 3. e3 Nf6 4. Nc3 e6 5. Bd3 a6'
##         self.assertEqual(group(s.split(), 3)[:3],
##                          [['1.', 'd4', 'd5'],
##                           ['2.', 'Nf3', 'Nc6'],
##                           ['3.', 'e3', 'Nf6']])

    def testAny(self):
        any = utils.iter.any
        self.failUnless(any(lambda i: i == 0, range(10)))
        self.failIf(any(None, range(1)))
        self.failUnless(any(None, range(2)))
        self.failIf(any(None, []))

    def testAll(self):
        all = utils.iter.all
        self.failIf(all(lambda i: i == 0, range(10)))
        self.failIf(all(lambda i: i % 2, range(2)))
        self.failIf(all(lambda i: i % 2 == 0, [1, 3, 5]))
        self.failUnless(all(lambda i: i % 2 == 0, [2, 4, 6]))
        self.failUnless(all(None, ()))

    def testPartition(self):
        partition = utils.iter.partition
        L = range(10)
        def even(i):
            return not(i % 2)
        (yes, no) = partition(even, L)
        self.assertEqual(yes, [0, 2, 4, 6, 8])
        self.assertEqual(no, [1, 3, 5, 7, 9])

    def testIlen(self):
        ilen = utils.iter.ilen
        self.assertEqual(ilen(iter(range(10))), 10)

    def testSplit(self):
        itersplit = utils.iter.split
        L = [1, 2, 3] * 3
        s = 'foo bar baz'
        self.assertEqual(list(itersplit(lambda x: x == 3, L)),
                         [[1, 2], [1, 2], [1, 2]])
        self.assertEqual(list(itersplit(lambda x: x == 3, L, yieldEmpty=True)),
                         [[1, 2], [1, 2], [1, 2], []])
        self.assertEqual(list(itersplit(lambda x: x, [])), [])
        self.assertEqual(list(itersplit(lambda c: c.isspace(), s)),
                         list(map(list, s.split())))
        self.assertEqual(list(itersplit('for'.__eq__, ['foo', 'for', 'bar'])),
                         [['foo'], ['bar']])
        self.assertEqual(list(itersplit('for'.__eq__,
                                        ['foo','for','bar','for', 'baz'], 1)),
                         [['foo'], ['bar', 'for', 'baz']])

    def testFlatten(self):
        def lflatten(seq):
            return list(utils.iter.flatten(seq))
        self.assertEqual(lflatten([]), [])
        self.assertEqual(lflatten([1]), [1])
        self.assertEqual(lflatten(range(10)), list(range(10)))
        twoRanges = list(range(10))*2
        twoRanges.sort()
        self.assertEqual(lflatten(list(zip(range(10), range(10)))), twoRanges)
        self.assertEqual(lflatten([1, [2, 3], 4]), [1, 2, 3, 4])
        self.assertEqual(lflatten([[[[[[[[[[]]]]]]]]]]), [])
        self.assertEqual(lflatten([1, [2, [3, 4], 5], 6]), [1, 2, 3, 4, 5, 6])
        self.assertRaises(TypeError, lflatten, 1)


class FileTest(SupyTestCase):
    def testLines(self):
        L = ['foo', 'bar', '#baz', '  ', 'biff']
        self.assertEqual(list(utils.file.nonEmptyLines(L)),
                         ['foo', 'bar', '#baz', 'biff'])
        self.assertEqual(list(utils.file.nonCommentLines(L)),
                         ['foo', 'bar', '  ', 'biff'])
        self.assertEqual(list(utils.file.nonCommentNonEmptyLines(L)),
                         ['foo', 'bar', 'biff'])

    def testMktemp(self):
        # This is mostly to test that it actually halts.
        self.failUnless(utils.file.mktemp())
        self.failUnless(utils.file.mktemp())
        self.failUnless(utils.file.mktemp())


class NetTest(SupyTestCase):
    def testEmailRe(self):
        emailRe = utils.net.emailRe
        self.failUnless(emailRe.match('jemfinch@supybot.com'))

    def testIsIP(self):
        isIP = utils.net.isIP
        self.failIf(isIP('a.b.c'))
        self.failIf(isIP('256.0.0.0'))
        self.failUnless(isIP('0.0.0.0'))
        self.failUnless(isIP('100.100.100.100'))
        self.failUnless(isIP('255.255.255.255'))

    def testIsIPV6(self):
        f = utils.net.isIPV6
        self.failUnless(f('2001::'))
        self.failUnless(f('2001:888:0:1::666'))

class WebTest(SupyTestCase):
    def testGetDomain(self):
        url = 'http://slashdot.org/foo/bar.exe'
        self.assertEqual(utils.web.getDomain(url), 'slashdot.org')

    if network:
        def testGetUrlWithSize(self):
            url = 'http://slashdot.org/'
            self.failUnless(len(utils.web.getUrl(url, 1024)) == 1024)

class FormatTestCase(SupyTestCase):
    def testNormal(self):
        format = utils.str.format
        self.assertEqual(format('I have %n of fruit: %L.', (3, 'kind'),
                                ['apples', 'oranges', 'watermelon']),
                         'I have 3 kinds of fruit: '
                         'apples, oranges, and watermelon.')

class RingBufferTestCase(SupyTestCase):
    def testInit(self):
        self.assertRaises(ValueError, RingBuffer, -1)
        self.assertRaises(ValueError, RingBuffer, 0)
        self.assertEqual(list(range(10)), list(RingBuffer(10, range(10))))

    def testLen(self):
        b = RingBuffer(3)
        self.assertEqual(0, len(b))
        b.append(1)
        self.assertEqual(1, len(b))
        b.append(2)
        self.assertEqual(2, len(b))
        b.append(3)
        self.assertEqual(3, len(b))
        b.append(4)
        self.assertEqual(3, len(b))
        b.append(5)
        self.assertEqual(3, len(b))

    def testNonzero(self):
        b = RingBuffer(3)
        self.failIf(b)
        b.append(1)
        self.failUnless(b)

    def testAppend(self):
        b = RingBuffer(3)
        self.assertEqual([], list(b))
        b.append(1)
        self.assertEqual([1], list(b))
        b.append(2)
        self.assertEqual([1, 2], list(b))
        b.append(3)
        self.assertEqual([1, 2, 3], list(b))
        b.append(4)
        self.assertEqual([2, 3, 4], list(b))
        b.append(5)
        self.assertEqual([3, 4, 5], list(b))
        b.append(6)
        self.assertEqual([4, 5, 6], list(b))

    def testContains(self):
        b = RingBuffer(3, range(3))
        self.failUnless(0 in b)
        self.failUnless(1 in b)
        self.failUnless(2 in b)
        self.failIf(3 in b)

    def testGetitem(self):
        L = range(10)
        b = RingBuffer(len(L), L)
        for i in range(len(b)):
            self.assertEqual(L[i], b[i])
        for i in range(len(b)):
            self.assertEqual(L[-i], b[-i])
        for i in range(len(b)):
            b.append(i)
        for i in range(len(b)):
            self.assertEqual(L[i], b[i])
        for i in range(len(b)):
            self.assertEqual(list(b), list(b[:i]) + list(b[i:]))

    def testSliceGetitem(self):
        L = list(range(10))
        b = RingBuffer(len(L), L)
        for i in range(len(b)):
            self.assertEqual(L[:i], b[:i])
            self.assertEqual(L[i:], b[i:])
            self.assertEqual(L[i:len(b)-i], b[i:len(b)-i])
            self.assertEqual(L[:-i], b[:-i])
            self.assertEqual(L[-i:], b[-i:])
            self.assertEqual(L[i:-i], b[i:-i])
        for i in range(len(b)):
            b.append(i)
        for i in range(len(b)):
            self.assertEqual(L[:i], b[:i])
            self.assertEqual(L[i:], b[i:])
            self.assertEqual(L[i:len(b)-i], b[i:len(b)-i])
            self.assertEqual(L[:-i], b[:-i])
            self.assertEqual(L[-i:], b[-i:])
            self.assertEqual(L[i:-i], b[i:-i])

    def testSetitem(self):
        L = range(10)
        b = RingBuffer(len(L), [0]*len(L))
        for i in range(len(b)):
            b[i] = i
        for i in range(len(b)):
            self.assertEqual(b[i], i)
        for i in range(len(b)):
            b.append(0)
        for i in range(len(b)):
            b[i] = i
        for i in range(len(b)):
            self.assertEqual(b[i], i)

    def testSliceSetitem(self):
        L = list(range(10))
        b = RingBuffer(len(L), [0]*len(L))
        self.assertRaises(ValueError, b.__setitem__, slice(0, 10), [])
        b[2:4] = L[2:4]
        self.assertEquals(b[2:4], L[2:4])
        for _ in range(len(b)):
            b.append(0)
        b[2:4] = L[2:4]
        self.assertEquals(b[2:4], L[2:4])

    def testExtend(self):
        b = RingBuffer(3, range(3))
        self.assertEqual(list(b), list(range(3)))
        b.extend(range(6))
        self.assertEqual(list(b), list(range(6)[3:]))

    def testRepr(self):
        b = RingBuffer(3)
        self.assertEqual(repr(b), 'RingBuffer(3, [])')
        b.append(1)
        self.assertEqual(repr(b), 'RingBuffer(3, [1])')
        b.append(2)
        self.assertEqual(repr(b), 'RingBuffer(3, [1, 2])')
        b.append(3)
        self.assertEqual(repr(b), 'RingBuffer(3, [1, 2, 3])')
        b.append(4)
        self.assertEqual(repr(b), 'RingBuffer(3, [2, 3, 4])')
        b.append(5)
        self.assertEqual(repr(b), 'RingBuffer(3, [3, 4, 5])')
        b.append(6)
        self.assertEqual(repr(b), 'RingBuffer(3, [4, 5, 6])')

    def testPickleCopy(self):
        b = RingBuffer(10, range(10))
        self.assertEqual(pickle.loads(pickle.dumps(b)), b)

    def testEq(self):
        b = RingBuffer(3, range(3))
        self.failIf(b == list(range(3)))
        b1 = RingBuffer(3)
        self.failIf(b == b1)
        b1.append(0)
        self.failIf(b == b1)
        b1.append(1)
        self.failIf(b == b1)
        b1.append(2)
        self.failUnless(b == b1)
        b = RingBuffer(100, range(10))
        b1 = RingBuffer(10, range(10))
        self.failIf(b == b1)

    def testIter(self):
        b = RingBuffer(3, range(3))
        L = []
        for elt in b:
            L.append(elt)
        self.assertEqual(L, list(range(3)))
        for elt in range(3):
            b.append(elt)
        del L[:]
        for elt in b:
            L.append(elt)
        self.assertEqual(L, list(range(3)))


class QueueTest(SupyTestCase):
    def testReset(self):
        q = queue()
        q.enqueue(1)
        self.assertEqual(len(q), 1)
        q.reset()
        self.assertEqual(len(q), 0)

    def testGetitem(self):
        q = queue()
        n = 10
        self.assertRaises(IndexError, q.__getitem__, 0)
        for i in xrange(n):
            q.enqueue(i)
        for i in xrange(n):
            self.assertEqual(q[i], i)
        for i in xrange(n, 0, -1):
            self.assertEqual(q[-i], n-i)
        for i in xrange(len(q)):
            self.assertEqual(list(q), list(q[:i]) + list(q[i:]))
        self.assertRaises(IndexError, q.__getitem__, -(n+1))
        self.assertRaises(IndexError, q.__getitem__, n)
        self.assertEqual(q[3:7], queue([3, 4, 5, 6]))

    def testSetitem(self):
        q1 = queue()
        self.assertRaises(IndexError, q1.__setitem__, 0, 0)
        for i in xrange(10):
            q1.enqueue(i)
        q2 = eval(repr(q1))
        for (i, elt) in enumerate(q2):
            q2[i] = elt*2
        self.assertEqual([x*2 for x in q1], list(q2))

    def testNonzero(self):
        q = queue()
        self.failIf(q, 'queue not zero after initialization')
        q.enqueue(1)
        self.failUnless(q, 'queue zero after adding element')
        q.dequeue()
        self.failIf(q, 'queue not zero after dequeue of only element')

    def testLen(self):
        q = queue()
        self.assertEqual(0, len(q), 'queue len not 0 after initialization')
        q.enqueue(1)
        self.assertEqual(1, len(q), 'queue len not 1 after enqueue')
        q.enqueue(2)
        self.assertEqual(2, len(q), 'queue len not 2 after enqueue')
        q.dequeue()
        self.assertEqual(1, len(q), 'queue len not 1 after dequeue')
        q.dequeue()
        self.assertEqual(0, len(q), 'queue len not 0 after dequeue')
        for i in range(10):
            L = range(i)
            q = queue(L)
            self.assertEqual(len(q), i)

    def testEq(self):
        q1 = queue()
        q2 = queue()
        self.failUnless(q1 == q1, 'queue not equal to itself')
        self.failUnless(q2 == q2, 'queue not equal to itself')
        self.failUnless(q1 == q2, 'initialized queues not equal')
        q1.enqueue(1)
        self.failUnless(q1 == q1, 'queue not equal to itself')
        self.failUnless(q2 == q2, 'queue not equal to itself')
        q2.enqueue(1)
        self.failUnless(q1 == q1, 'queue not equal to itself')
        self.failUnless(q2 == q2, 'queue not equal to itself')
        self.failUnless(q1 == q2, 'queues not equal after identical enqueue')
        q1.dequeue()
        self.failUnless(q1 == q1, 'queue not equal to itself')
        self.failUnless(q2 == q2, 'queue not equal to itself')
        self.failIf(q1 == q2, 'queues equal after one dequeue')
        q2.dequeue()
        self.failUnless(q1 == q2, 'queues not equal after both are dequeued')
        self.failUnless(q1 == q1, 'queue not equal to itself')
        self.failUnless(q2 == q2, 'queue not equal to itself')

    def testInit(self):
        self.assertEqual(len(queue()), 0, 'queue len not 0 after init')
        q = queue()
        q.enqueue(1)
        q.enqueue(2)
        q.enqueue(3)
        self.assertEqual(queue((1, 2, 3)),q, 'init not equivalent to enqueues')
        q = queue((1, 2, 3))
        self.assertEqual(q.dequeue(), 1, 'values not returned in proper order')
        self.assertEqual(q.dequeue(), 2, 'values not returned in proper order')
        self.assertEqual(q.dequeue(), 3, 'values not returned in proper order')

    def testRepr(self):
        q = queue()
        q.enqueue(1)
        self.assertEqual(q, eval(repr(q)), 'repr doesn\'t eval to same queue')
        q.enqueue('foo')
        self.assertEqual(q, eval(repr(q)), 'repr doesn\'t eval to same queue')
        q.enqueue(None)
        self.assertEqual(q, eval(repr(q)), 'repr doesn\'t eval to same queue')
        q.enqueue(1.0)
        self.assertEqual(q, eval(repr(q)), 'repr doesn\'t eval to same queue')
        q.enqueue([])
        self.assertEqual(q, eval(repr(q)), 'repr doesn\'t eval to same queue')
        q.enqueue(())
        self.assertEqual(q, eval(repr(q)), 'repr doesn\'t eval to same queue')
        q.enqueue([1])
        self.assertEqual(q, eval(repr(q)), 'repr doesn\'t eval to same queue')
        q.enqueue((1,))
        self.assertEqual(q, eval(repr(q)), 'repr doesn\'t eval to same queue')

    def testEnqueueDequeue(self):
        q = queue()
        self.assertRaises(IndexError, q.dequeue)
        q.enqueue(1)
        self.assertEqual(q.dequeue(), 1,
                         'first dequeue didn\'t return same as first enqueue')
        q.enqueue(1)
        q.enqueue(2)
        q.enqueue(3)
        self.assertEqual(q.dequeue(), 1)
        self.assertEqual(q.dequeue(), 2)
        self.assertEqual(q.dequeue(), 3)

    def testPeek(self):
        q = queue()
        self.assertRaises(IndexError, q.peek)
        q.enqueue(1)
        self.assertEqual(q.peek(), 1, 'peek didn\'t return first enqueue')
        q.enqueue(2)
        self.assertEqual(q.peek(), 1, 'peek didn\'t return first enqueue')
        q.dequeue()
        self.assertEqual(q.peek(), 2, 'peek didn\'t return second enqueue')
        q.dequeue()
        self.assertRaises(IndexError, q.peek)

    def testContains(self):
        q = queue()
        self.failIf(1 in q, 'empty queue cannot have elements')
        q.enqueue(1)
        self.failUnless(1 in q, 'recent enqueued element not in q')
        q.enqueue(2)
        self.failUnless(1 in q, 'original enqueued element not in q')
        self.failUnless(2 in q, 'second enqueued element not in q')
        q.dequeue()
        self.failIf(1 in q, 'dequeued element in q')
        self.failUnless(2 in q, 'not dequeued element not in q')
        q.dequeue()
        self.failIf(2 in q, 'dequeued element in q')

    def testIter(self):
        q1 = queue((1, 2, 3))
        q2 = queue()
        for i in q1:
            q2.enqueue(i)
        self.assertEqual(q1, q2, 'iterate didn\'t return all elements')
        for _ in queue():
            self.fail('no elements should be in empty queue')

    def testPickleCopy(self):
        q = queue(range(10))
        self.assertEqual(q, pickle.loads(pickle.dumps(q)))

queue = smallqueue

class SmallQueueTest(SupyTestCase):
    def testReset(self):
        q = queue()
        q.enqueue(1)
        self.assertEqual(len(q), 1)
        q.reset()
        self.assertEqual(len(q), 0)

    def testGetitem(self):
        q = queue()
        n = 10
        self.assertRaises(IndexError, q.__getitem__, 0)
        for i in xrange(n):
            q.enqueue(i)
        for i in xrange(n):
            self.assertEqual(q[i], i)
        for i in xrange(n, 0, -1):
            self.assertEqual(q[-i], n-i)
        for i in xrange(len(q)):
            self.assertEqual(list(q), list(q[:i]) + list(q[i:]))
        self.assertRaises(IndexError, q.__getitem__, -(n+1))
        self.assertRaises(IndexError, q.__getitem__, n)
        self.assertEqual(q[3:7], queue([3, 4, 5, 6]))

    def testSetitem(self):
        q1 = queue()
        self.assertRaises(IndexError, q1.__setitem__, 0, 0)
        for i in xrange(10):
            q1.enqueue(i)
        q2 = eval(repr(q1))
        for (i, elt) in enumerate(q2):
            q2[i] = elt*2
        self.assertEqual([x*2 for x in q1], list(q2))

    def testNonzero(self):
        q = queue()
        self.failIf(q, 'queue not zero after initialization')
        q.enqueue(1)
        self.failUnless(q, 'queue zero after adding element')
        q.dequeue()
        self.failIf(q, 'queue not zero after dequeue of only element')

    def testLen(self):
        q = queue()
        self.assertEqual(0, len(q), 'queue len not 0 after initialization')
        q.enqueue(1)
        self.assertEqual(1, len(q), 'queue len not 1 after enqueue')
        q.enqueue(2)
        self.assertEqual(2, len(q), 'queue len not 2 after enqueue')
        q.dequeue()
        self.assertEqual(1, len(q), 'queue len not 1 after dequeue')
        q.dequeue()
        self.assertEqual(0, len(q), 'queue len not 0 after dequeue')
        for i in range(10):
            L = range(i)
            q = queue(L)
            self.assertEqual(len(q), i)

    def testEq(self):
        q1 = queue()
        q2 = queue()
        self.failUnless(q1 == q1, 'queue not equal to itself')
        self.failUnless(q2 == q2, 'queue not equal to itself')
        self.failUnless(q1 == q2, 'initialized queues not equal')
        q1.enqueue(1)
        self.failUnless(q1 == q1, 'queue not equal to itself')
        self.failUnless(q2 == q2, 'queue not equal to itself')
        q2.enqueue(1)
        self.failUnless(q1 == q1, 'queue not equal to itself')
        self.failUnless(q2 == q2, 'queue not equal to itself')
        self.failUnless(q1 == q2, 'queues not equal after identical enqueue')
        q1.dequeue()
        self.failUnless(q1 == q1, 'queue not equal to itself')
        self.failUnless(q2 == q2, 'queue not equal to itself')
        self.failIf(q1 == q2, 'queues equal after one dequeue')
        q2.dequeue()
        self.failUnless(q1 == q2, 'queues not equal after both are dequeued')
        self.failUnless(q1 == q1, 'queue not equal to itself')
        self.failUnless(q2 == q2, 'queue not equal to itself')

    def testInit(self):
        self.assertEqual(len(queue()), 0, 'queue len not 0 after init')
        q = queue()
        q.enqueue(1)
        q.enqueue(2)
        q.enqueue(3)
        self.assertEqual(queue((1, 2, 3)),q, 'init not equivalent to enqueues')
        q = queue((1, 2, 3))
        self.assertEqual(q.dequeue(), 1, 'values not returned in proper order')
        self.assertEqual(q.dequeue(), 2, 'values not returned in proper order')
        self.assertEqual(q.dequeue(), 3, 'values not returned in proper order')

    def testRepr(self):
        q = queue()
        q.enqueue(1)
        self.assertEqual(q, eval(repr(q)), 'repr doesn\'t eval to same queue')
        q.enqueue('foo')
        self.assertEqual(q, eval(repr(q)), 'repr doesn\'t eval to same queue')
        q.enqueue(None)
        self.assertEqual(q, eval(repr(q)), 'repr doesn\'t eval to same queue')
        q.enqueue(1.0)
        self.assertEqual(q, eval(repr(q)), 'repr doesn\'t eval to same queue')
        q.enqueue([])
        self.assertEqual(q, eval(repr(q)), 'repr doesn\'t eval to same queue')
        q.enqueue(())
        self.assertEqual(q, eval(repr(q)), 'repr doesn\'t eval to same queue')
        q.enqueue([1])
        self.assertEqual(q, eval(repr(q)), 'repr doesn\'t eval to same queue')
        q.enqueue((1,))
        self.assertEqual(q, eval(repr(q)), 'repr doesn\'t eval to same queue')

    def testEnqueueDequeue(self):
        q = queue()
        self.assertRaises(IndexError, q.dequeue)
        q.enqueue(1)
        self.assertEqual(q.dequeue(), 1,
                         'first dequeue didn\'t return same as first enqueue')
        q.enqueue(1)
        q.enqueue(2)
        q.enqueue(3)
        self.assertEqual(q.dequeue(), 1)
        self.assertEqual(q.dequeue(), 2)
        self.assertEqual(q.dequeue(), 3)

    def testPeek(self):
        q = queue()
        self.assertRaises(IndexError, q.peek)
        q.enqueue(1)
        self.assertEqual(q.peek(), 1, 'peek didn\'t return first enqueue')
        q.enqueue(2)
        self.assertEqual(q.peek(), 1, 'peek didn\'t return first enqueue')
        q.dequeue()
        self.assertEqual(q.peek(), 2, 'peek didn\'t return second enqueue')
        q.dequeue()
        self.assertRaises(IndexError, q.peek)

    def testContains(self):
        q = queue()
        self.failIf(1 in q, 'empty queue cannot have elements')
        q.enqueue(1)
        self.failUnless(1 in q, 'recent enqueued element not in q')
        q.enqueue(2)
        self.failUnless(1 in q, 'original enqueued element not in q')
        self.failUnless(2 in q, 'second enqueued element not in q')
        q.dequeue()
        self.failIf(1 in q, 'dequeued element in q')
        self.failUnless(2 in q, 'not dequeued element not in q')
        q.dequeue()
        self.failIf(2 in q, 'dequeued element in q')

    def testIter(self):
        q1 = queue((1, 2, 3))
        q2 = queue()
        for i in q1:
            q2.enqueue(i)
        self.assertEqual(q1, q2, 'iterate didn\'t return all elements')
        for _ in queue():
            self.fail('no elements should be in empty queue')

    def testPickleCopy(self):
        q = queue(range(10))
        self.assertEqual(q, pickle.loads(pickle.dumps(q)))


class MaxLengthQueueTestCase(SupyTestCase):
    def testInit(self):
        q = MaxLengthQueue(3, (1, 2, 3))
        self.assertEqual(list(q), [1, 2, 3])
        self.assertRaises(TypeError, MaxLengthQueue, 3, 1, 2, 3)

    def testMaxLength(self):
        q = MaxLengthQueue(3)
        q.enqueue(1)
        self.assertEqual(len(q), 1)
        q.enqueue(2)
        self.assertEqual(len(q), 2)
        q.enqueue(3)
        self.assertEqual(len(q), 3)
        q.enqueue(4)
        self.assertEqual(len(q), 3)
        self.assertEqual(q.peek(), 2)
        q.enqueue(5)
        self.assertEqual(len(q), 3)
        self.assertEqual(q[0], 3)


class TwoWayDictionaryTestCase(SupyTestCase):
    def testInit(self):
        d = TwoWayDictionary(foo='bar')
        self.failUnless('foo' in d)
        self.failUnless('bar' in d)

        d = TwoWayDictionary({1: 2})
        self.failUnless(1 in d)
        self.failUnless(2 in d)

    def testSetitem(self):
        d = TwoWayDictionary()
        d['foo'] = 'bar'
        self.failUnless('foo' in d)
        self.failUnless('bar' in d)

    def testDelitem(self):
        d = TwoWayDictionary(foo='bar')
        del d['foo']
        self.failIf('foo' in d)
        self.failIf('bar' in d)
        d = TwoWayDictionary(foo='bar')
        del d['bar']
        self.failIf('bar' in d)
        self.failIf('foo' in d)


class TestTimeoutQueue(SupyTestCase):
    def test(self):
        q = TimeoutQueue(1)
        q.enqueue(1)
        self.assertEqual(len(q), 1)
        q.enqueue(2)
        self.assertEqual(len(q), 2)
        q.enqueue(3)
        self.assertEqual(len(q), 3)
        self.assertEqual(sum(q), 6)
        time.sleep(1.1)
        self.assertEqual(len(q), 0)
        self.assertEqual(sum(q), 0)

    def testCallableTimeout(self):
        q = TimeoutQueue(lambda : 1)
        q.enqueue(1)
        self.assertEqual(len(q), 1)
        q.enqueue(2)
        self.assertEqual(len(q), 2)
        q.enqueue(3)
        self.assertEqual(len(q), 3)
        self.assertEqual(sum(q), 6)
        time.sleep(1.1)
        self.assertEqual(len(q), 0)
        self.assertEqual(sum(q), 0)

    def testContains(self):
        q = TimeoutQueue(1)
        q.enqueue(1)
        self.failUnless(1 in q)
        self.failUnless(1 in q) # For some reason, the second one might fail.
        self.failIf(2 in q)
        time.sleep(1.1)
        self.failIf(1 in q)

    def testReset(self):
        q = TimeoutQueue(10)
        q.enqueue(1)
        self.failUnless(1 in q)
        q.reset()
        self.failIf(1 in q)

class TestCacheDict(SupyTestCase):
    def testMaxNeverExceeded(self):
        max = 10
        d = CacheDict(10)
        for i in xrange(max**2):
            d[i] = i
            self.failUnless(len(d) <= max)
            self.failUnless(i in d)
            self.failUnless(d[i] == i)
            

# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:


########NEW FILE########
